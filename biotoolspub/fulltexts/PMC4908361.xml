<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d1 20130915//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4908361</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btw277</article-id>
    <article-id pub-id-type="publisher-id">btw277</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb 2016 Proceedings July 8 to July 12, 2016, Orlando, Florida</subject>
        <subj-group subj-group-type="heading">
          <subject>Gene / Protein Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RapMap: a rapid, sensitive and accurate tool for mapping RNA-seq reads to transcriptomes</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Srivastava</surname>
          <given-names>Avi</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sarkar</surname>
          <given-names>Hirak</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Gupta</surname>
          <given-names>Nitish</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Patro</surname>
          <given-names>Rob</given-names>
        </name>
        <xref ref-type="corresp" rid="btw277-cor1">*</xref>
      </contrib>
      <aff id="btw277-aff1">Department of Computer Science, Stony Brook University Stony Brook, New York, NY 11794-2424, USA</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btw277-cor1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>6</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>6</month>
      <year>2016</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>32</volume>
    <issue>12</issue>
    <fpage>i192</fpage>
    <lpage>i200</lpage>
    <permissions>
      <copyright-statement>© The Author 2016. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2016</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> The alignment of sequencing reads to a transcriptome is a common and important step in many RNA-seq analysis tasks. When aligning RNA-seq reads directly to a transcriptome (as is common in the <italic>de novo</italic> setting or when a trusted reference annotation is available), care must be taken to report the potentially large number of multi-mapping locations per read. This can pose a substantial computational burden for existing aligners, and can considerably slow downstream analysis.</p>
      <p><bold>Results:</bold> We introduce a novel concept, quasi-mapping, and an efficient algorithm implementing this approach for mapping sequencing reads to a transcriptome. By attempting only to report the potential loci of origin of a sequencing read, and not the base-to-base alignment by which it derives from the reference, RapMap—our tool implementing quasi-mapping—is capable of <italic>mapping</italic> sequencing reads to a target transcriptome substantially faster than existing alignment tools. The algorithm we use to implement quasi-mapping uses several efficient data structures and takes advantage of the special structure of shared sequence prevalent in transcriptomes to rapidly provide highly-accurate mapping information. We demonstrate how quasi-mapping can be successfully applied to the problems of transcript-level quantification from RNA-seq reads and the clustering of contigs from <italic>de novo</italic> assembled transcriptomes into biologically meaningful groups.</p>
      <p><bold>Availability and implementation:</bold> RapMap is implemented in C ++11 and is available as open-source software, under GPL v3, at <ext-link ext-link-type="uri" xlink:href="https://github.com/COMBINE-lab/RapMap">https://github.com/COMBINE-lab/RapMap</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>rob.patro@cs.stonybrook.edu</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>1 Introduction</title>
    <p>The bioinformatics community has put tremendous effort into building a wide array of different tools to solve the read-alignment problem efficiently. These tools use many different strategies to quickly find potential alignment locations for reads; for example, Bowtie (<xref rid="btw277-B17" ref-type="bibr">Langmead <italic>et al.</italic>, 2009</xref>), Bowtie 2 (<xref rid="btw277-B16" ref-type="bibr">Langmead and Salzberg, 2012</xref>), BWA (<xref rid="btw277-B20" ref-type="bibr">Li and Durbin, 2009</xref>) and BWA-mem (<xref rid="btw277-B23" ref-type="bibr">Li, 2013</xref>) use variants of the FM-index, while tools like the Subread aligner (<xref rid="btw277-B24" ref-type="bibr">Liao <italic>et al.</italic>, 2013</xref>), Maq (<xref rid="btw277-B21" ref-type="bibr">Li <italic>et al.</italic>, 2008</xref>) and MrsFast (<xref rid="btw277-B11" ref-type="bibr">Hach <italic>et al.</italic>, 2010</xref>) use k-mer-based indices to help align reads efficiently. Because read alignment is such a ubiquitous task, the goal of such tools is often to provide accurate results as quickly as possible. Indeed, recent alignment tools like STAR (<xref rid="btw277-B5" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>) demonstrate that rapid alignment of sequenced reads is possible, and tools like HISAT (<xref rid="btw277-B14" ref-type="bibr">Kim <italic>et al.</italic>, 2015</xref>) demonstrate that this speed can be achieved with only moderate memory usage. When reads are aligned to a collection of reference sequences that share a substantial amount of sub-sequence (near or exact repeats), a single read can have many potential alignments, and considering all such alignment can be crucial for downstream analysis (e.g. considering all alignment locations for a read within a transcriptome for the purpose of quantification, <xref rid="btw277-B19" ref-type="bibr">Li and Dewey (2011)</xref>, or when attempting to cluster <italic>de novo</italic> assembled contigs by shared multi-mapping reads, <xref rid="btw277-B4" ref-type="bibr">Davidson and Oshlack, 2014</xref>). However, reporting multiple potential alignments for each read is a difficult task, and tends to substantially slow down even efficient alignment tools.</p>
    <p>Yet, in many cases, all of the information provided by the alignments is not necessary. For example, in the transcript analysis tasks mentioned above, simply the knowledge of the transcripts and positions to which a given read maps well is sufficient to answer the questions being posed. In support of such ‘analysis-efficient’ computation, we propose a novel concept, called quasi-mapping, and an efficient algorithm implementing quasi-mapping (exposed in the software tool RapMap) to solve the problem of mapping sequenced reads to a target transcriptome. This algorithm is <italic>considerably</italic> faster than state-of-the-art aligners, and achieves its impressive speed by exploiting the structure of the transcriptome (without requiring an annotation), and eliding the computation of full-alignments (e.g. CIGAR strings). Further, our algorithm produces mappings that meet or exceed the accuracy of existing popular aligners under different metrics of accuracy. Finally, we demonstrate how the mappings produced by RapMap can be used in the downstream analysis task of transcript-level quantification from RNA-seq data, by modifying the Sailfish (<xref rid="btw277-B32" ref-type="bibr">Patro <italic>et al.</italic>, 2014</xref>) tool to take advantage of quasi-mappings, as opposed to individual k-mer counts, for transcript quantification. We also demonstrate how quasi-mappings can be used to effectively cluster contigs from <italic>de novo</italic> assemblies. We show that the resulting clusterings are of comparable or superior accuracy to those produced by recent methods such as CORSET (<xref rid="btw277-B4" ref-type="bibr">Davidson and Oshlack, 2014</xref>), but that they can be computed <italic>much</italic> more quickly using quasi-mapping.</p>
  </sec>
  <sec id="SEC2">
    <title>2 Methods</title>
    <p>The quasi-mapping concept, implemented in the tool RapMap, is a new mapping technique to allow the rapid and accurate mapping of sequenced fragments (single or paired-end reads) to a target transcriptome. RapMap exploits a combination of data structures—a hash table, suffix array (SA) and efficient rank data structure. It takes into account the special structure present in transcriptomic references, as exposed by the SA, to enable ultra-fast and accurate determination of the likely loci of origin of a sequencing read. Rather than a standard alignment, quasi-mapping produces what we refer to as fragment <italic>mapping</italic> information. In particular, it provides, for each query (fragment), the reference sequences (transcripts), strand and position from which the query may have likely originated. In many cases, this mapping information is sufficient for downstream analysis. For example, tasks like transcript quantification, clustering of <italic>de novo</italic> assembled transcripts and filtering of potential target transcripts can be accomplished with this mapping information. However, this method does not compute the base-to-base alignment between the query and reference. Thus, such mappings may not be appropriate in every situation in which alignments are currently used (e.g. variant detection).</p>
    <p>We note here that the concept of quasi-mapping shares certain motivations with the notions of lightweight-alignment (<xref rid="btw277-B33" ref-type="bibr">Patro <italic>et al.</italic>, 2015</xref>) and pseudoalignment (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>). Yet, all three concepts—and the algorithms and data structures used to implement them—are distinct and, in places, substantially different. Lightweight-alignment scores potential matches based on approximately consistent chains of super-maximal exact matches shared between the query and targets. Therefore, it typically requires some more computation than the other methods, but allows the reporting of a score with each returned mapping and a more flexible notion of matching. Pseudoalignment, as implemented in Kallisto, refers only to the process of finding <italic>compatible</italic> targets for reads by determining approximately matching paths in a colored De Bruijn graph of a pre-specified order. Among compatible targets, extra information concerning the mapping (e.g. position and orientation) can be extracted <italic>post hoc</italic>, but this requires extra processing, and the resulting mapping is no longer technically a pseudoalignment. Quasi-mapping seeks to find the <italic>best</italic> mappings (targets and positions) for each read, and does so (approximately) by finding minimal collections of dynamically sized, right-maximal, matching contexts between target and query positions. Quasi-mapping is inspired by both lightweight-alignment (<xref rid="btw277-B33" ref-type="bibr">Patro <italic>et al.</italic> (2015)</xref>) and pseudoalignment (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>), and while each of these approaches provide some insight into the problems of alignment and mapping, they represent distinct concepts and exhibit unique characteristics in terms of speed and accuracy, as demonstrated below (We do not compare against lightweight-alignment here, as no stand-alone implementation of this approach is currently available).</p>
    <sec id="SEC2.1">
      <title>2.1 An algorithm for Quasi-mapping</title>
      <p>The algorithm we use for quasi-mapping makes use of two main data structures, the generalized SA (<xref rid="btw277-B26" ref-type="bibr">Manber and Myers, 1993</xref>) SA[T] of the transcriptome <italic>T</italic>, and a hash table <italic>h</italic> mapping each k-mer occurring in <italic>T</italic> to its SA interval (by default <italic>k</italic>  =  31). Additionally, we must maintain the original text <italic>T</italic> on which the SA was constructed, and the name and length of each of the original transcript sequences. <italic>T</italic> consists of a string in which all transcript sequences are joined together with a special separator character. Rather than designating a separate terminator <inline-formula id="IE1"><mml:math id="IEQ1"><mml:mrow><mml:msub><mml:mi>$</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for each reference sequence in the transcriptome, we make use of a single separator $, and maintain an auxiliary rank data structure, which allows us to map from an arbitrary position in the concatenated text to the index of the reference transcript in which it appears. We use the rank9b algorithm and data structure of <xref rid="btw277-B36" ref-type="bibr">Vigna (2008)</xref> to perform the rank operation quickly.</p>
      <p>Quasi-mapping determines the mapping locations for a query read <italic>r</italic> through repeated application of (i) determining the next hash table k-mer that starts past the current query position, (ii) computing the maximum mappable prefix (MMP) of the query beginning with this k-mer and then (iii) determining the next informative position (NIP) by performing a longest common prefix (LCP) query on two specifically chosen suffixes in the SA.</p>
      <p>The algorithm begins by hashing the k-mers of <italic>r</italic>, from left-to-right (a symmetric procedure can be used for mapping the reverse-complement of a read), until some k-mer <italic>k<sub>i</sub></italic>—the k-mer starting at position <italic>i</italic> within the read—is present in <italic>h</italic> and maps to a valid SA interval. We denote this interval as <inline-formula id="IE2"><mml:math id="IEQ2"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:math></inline-formula>. Because of the lexicographic order of the suffixes in the SA, we immediately know that this k-mer is a prefix of all of the suffixes appearing in the given interval. However, it may be possible to extend this match to some longer substring of the read beginning with <italic>k<sub>i</sub></italic>. In fact, the longest substring of the read that appears in the reference and is prefixed by <italic>k<sub>i</sub></italic> is exactly the MMP (<xref rid="btw277-B5" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>) of the suffix of the read beginning with <italic>k<sub>i</sub></italic>. We call this MMP<sub><italic>i</italic></sub>, and note that it can be found using a slight variant of the standard SA binary search (<xref rid="btw277-B26" ref-type="bibr">Manber and Myers, 1993</xref>) algorithm. For speed and simplicity, we implement the ‘simple accelerant’ binary search variant of <xref rid="btw277-B10" ref-type="bibr">Gusfield (1997)</xref>. Because we know that any substring that begins with <italic>k<sub>i</sub></italic> must reside in the interval [b,e), we can restrict the MMP<sub><italic>i</italic></sub> search to this region of the SA, which is typically small.</p>
      <p>After determining the length of MMP<sub><italic>i</italic></sub> within the read, one could begin the search for the next mappable SA interval at the position following this MMP. However, though the current substring of the read will differ from all of the reference sequence suffixes at the base following MMP<sub><italic>i</italic></sub>, the suffixes occurring at the lower and upper bounds of the SA interval corresponding to MMP<sub><italic>i</italic></sub> may not differ from each other (see <xref ref-type="fig" rid="btw277-F1">Fig. 1</xref>). That is, if <inline-formula id="IE3"><mml:math id="IEQ3"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mtext>MMP</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:math></inline-formula> is the SA interval corresponding to MMP<sub><italic>i</italic></sub>, it is possible that <inline-formula id="IE4"><mml:math id="IEQ4"><mml:mrow><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:mi mathvariant="normal">LCP</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi mathvariant="normal">SA</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mo>,</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi mathvariant="normal">SA</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mtext>MMP</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:math></inline-formula>. In this case, it is most likely that the read and the reference sequence bases following MMP<sub><italic>i</italic></sub> disagree as the result of a sequencing error, not because the (long) MMP discovered between the read and reference is a spurious match. Thus, beginning the search for the next MMP at the subsequent base in the read may not be productive, as the matches for this substring of the query may not be informative—that is, such a search will likely return the same (relative) positions and set of transcripts. To avoid querying for such substrings, we define and make use of the notion of the NIP. The notion of the NIP in the algorithm we present for quasi-mapping is motivated by the ‘k-mer skipping’ approach adopted in Kallisto (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>), though the manner in which this information is obtained is different (as are actual positions themselves), since the NIPs computed for quasi-mapping depend on the preceding matching context, which is of a dynamic and variable length. For a MMP<sub><italic>i</italic></sub>, with <inline-formula id="IE5"><mml:math id="IEQ5"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mtext>MMP</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:math></inline-formula>, we define <inline-formula id="IE6"><mml:math id="IEQ6"><mml:mrow><mml:mi mathvariant="normal">NIP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mtext>MMP</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:mi mathvariant="normal">LCP</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi mathvariant="normal">SA</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mo>,</mml:mo><mml:mi mathvariant="normal">T</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi mathvariant="normal">SA</mml:mi><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mtext> </mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Intuitively, the NIP of prefix MMP<sub><italic>i</italic></sub> is designed to return the next position in the query string where a SA search is likely to yield a set of transcripts different from those contained in <inline-formula id="IE7"><mml:math id="IEQ7"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mtext>MMP</mml:mtext></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. To compute the LCP between two suffixes when searching for the NIP, we use the ‘direct min’ algorithm of <xref rid="btw277-B12" ref-type="bibr">Ilie <italic>et al.</italic> (2010)</xref>. We found this to be the fastest approach. Additionally, it does not require the maintenance of an LCP array or other auxiliary tables aside from the standard SA.
<fig id="btw277-F1" orientation="portrait" position="float"><label>Fig. 1.</label><caption><p>The transcriptome (consisting of transcripts <inline-formula id="IE8"><mml:math id="IEQ8"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>6</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>) is converted into a <inline-formula id="IE9"><mml:math id="IEQ9"><mml:mi>$</mml:mi></mml:math></inline-formula>-separated string, <italic>T</italic>, on which a suffix array, SA[T], and a hash table, <italic>h</italic>, are constructed. The mapping operation begins with a k-mer (here, <italic>k</italic> = 3) mapping to an interval <inline-formula id="IE10"><mml:math id="IEQ10"><mml:mrow><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow></mml:math></inline-formula> in SA[T]. Given this interval and the read, MMP<sub><italic>i</italic></sub> and NIP(MMP<sub><italic>i</italic></sub>) are calculated as described in section 2. The search for the next hashable k-mer begins <italic>k</italic> bases before NIP(MMP<sub><italic>i</italic></sub>)</p></caption><graphic xlink:href="btw277f1p"/></fig>
</p>
      <p>Given the definitions we have explained above, we can summarize the quasi-mapping procedure as follows (an illustration of the mapping procedure is provided in <xref ref-type="fig" rid="btw277-F1">Fig. 1</xref>). First, a read is scanned from left to right (a symmetric procedure can be used for mapping the reverse-complement of a read) until a k-mer <italic>k<sub>i</sub></italic> is encountered that appears in <italic>h</italic>. A lookup in <italic>h</italic> returns the SA interval <inline-formula id="IE11"><mml:math id="IEQ11"><mml:mrow><mml:mi mathvariant="normal">I</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> corresponding to the substring of the read consisting of this k-mer. Then, the procedure described above is used to compute MMP<sub><italic>i</italic></sub> and <inline-formula id="IE12"><mml:math id="IEQ12"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">NIP</mml:mi></mml:mrow></mml:math></inline-formula>(MMP<sub><italic>i</italic></sub>). The search procedure then advances to position <inline-formula id="IE13"><mml:math id="IEQ13"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> in the read, and again begins hashing the k-mers it encounters. This process of determining the MMP and NIP of each processed k-mer and advancing to the NIP in the read continues until the NIP exceeds position <inline-formula id="IE14"><mml:math id="IEQ14"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE15"><mml:math id="IEQ15"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the length of the read <italic>r</italic>. The result of applying this procedure to a read is a set <inline-formula id="IE16"><mml:math id="IEQ16"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>o</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>o</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mtext> </mml:mtext></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of query positions, MMP orientations and SA intervals, with one such triplet corresponding to each MMP.</p>
      <p>The final set of mappings is determined by a consensus mechanism. Specifically, the algorithm reports the intersection of transcripts appearing in all hits—i.e. the set of transcripts that appear (in a consistent orientation) in every SA interval appearing in <italic>S</italic>. These transcripts, and the corresponding strand and location on each, are reported as <italic>quasi-mappings</italic> of this read. This lightweight consensus mechanism is inspired by Kallisto (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>), though certain differences exist (e.g. quasi-mapping requires all hits to be orientation-consistent, and, since transcript identifiers are obtained from generalized transcriptome positions via a rank calculation, the mapping positions for each hit—and therefore, each read—are immediately available, rather than decodable as auxiliary information). These mappings are reported in a samtools-compatible format in which the relevant information (e.g. target id, position, strand, pair status) is computed from the mapping. We note that alternative consensus mechanisms, both more and less stringent, are easy to enforce given the information contained in the hits (e.g. ensuring that the hits are co-linear with respect to both the query and reference can be done by passing RapMap the -c flag, and δ-consistency (Patro et al., 2015) can also be easily enforced). However, below, we consider this simple consensus mechanism.</p>
      <p>Intuitively, RapMap’s combination of speed and accuracy result from the manner in which it exploits the nature of exactly repeated sequence that is prevalent in transcriptomes (either as a result of alternative splicing or paralogous genes). In addition to efficient search for MMPs and NIPs, the SA allows RapMap to encode exact matches between the query and many potential transcripts efficiently (in the form of ‘hits’). This is because all reference locations for a given MMP appear in consecutive entries of the SA, and can be encoded efficiently by simply recording the SA interval corresponding to this MMP. By aggressively filtering the hits to determine the set of ‘best’ matching transcripts and positions, RapMap is able to quickly discard small matches that are unlikely to correspond to a correct mapping. Similarly, the large collection of exact matches that appear in the reported mapping are likely to appear in the alignment (were the actual alignments to be computed). In some sense, the success of the strategy adopted by RapMap further validates the claim of <xref rid="btw277-B24" ref-type="bibr">Liao <italic>et al.</italic> (2013)</xref> that the seed-and-vote paradigm can be considerably more efficient than the seed-and-extend paradigm, as RapMap adopts neither of these paradigms directly, but its approach is more similar to the former than the latter.</p>
      <p>In the next section, we analyze how this algorithm for quasi-mapping, as described above, compares with other aligners in terms of speed and mapping accuracy.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 Mapping speed and accuracy</title>
    <p>To test the practical performance of quasi-mapping, we compared RapMap against a number of existing tools, and analyzed both the speed and accuracy of these tools on synthetic and experimental data. Benchmarking was performed against the popular aligners Bowtie 2 (<xref rid="btw277-B16" ref-type="bibr">Langmead and Salzberg, 2012</xref>) (v2.2.6) and STAR (<xref rid="btw277-B5" ref-type="bibr">Dobin <italic>et al.</italic>, 2013</xref>) (v2.5.0c) and the recently introduced pseudoalignment procedure used in the quantification tool Kallisto (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>) (v0.42.4). All experiments were scripted using Snakemake (<xref rid="btw277-B15" ref-type="bibr">Köster and Rahmann, 2012</xref>) and performed on a 64-bit linux server with 256 GB of RAM and 4 × 6-core Intel Xeon E5-4607 v2 CPUs running at 2.60 GHz. Wall-clock time was recorded using the time command.</p>
    <p>In our testing we find that Bowtie 2 generally performs well in terms of reporting the true read origin among its set of multi-mapping locations. However, it takes considerably longer and tends to return a larger set of multi-mapping locations than the other methods. In comparison with Bowtie 2, STAR is <italic>substantially</italic> faster but somewhat less accurate. RapMap achieves accuracy comparable or superior to Bowtie 2, while simultaneously being much faster than even STAR. Kallisto is similar to (slightly slower than) RapMap in terms of single-threaded speed, and exhibits accuracy similar to that of STAR. For both RapMap and Kallisto, simply writing the output to disk tends to dominate the time required for large input files with significant multi-mapping (though we eliminate this overhead when benchmarking). This is due, in part, to the verbosity of the standard SAM format in which results are reported, and suggests that it may be worth developing a more efficient and succinct output format for mapping information.</p>
    <sec id="SEC3.1">
      <title>3.1 Speed and accuracy on synthetic data</title>
      <p>To test the accuracy of different mapping and alignment tools in a scenario where we know the true origin of each read, we generated data using the Flux Simulator (<xref rid="btw277-B9" ref-type="bibr">Griebel <italic>et al.</italic>, 2012</xref>). This synthetic dataset was generated for the human transcriptome from an annotation taken from the ENSEMBL (<xref rid="btw277-B3" ref-type="bibr">Cunningham <italic>et al.</italic>, 2015</xref>) database consisting of 86 090 transcripts corresponding to protein-coding genes. The dataset consists of <inline-formula id="IE17"><mml:math id="IEQ17"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>48</mml:mn></mml:mrow></mml:math></inline-formula> million 76 bp, paired-end reads. The detailed parameters used for the Flux Simulator can be found in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary Appendix 1.2</ext-link>.</p>
      <p>When benchmarking these methods, reads were aligned directly to the transcriptome, rather than to the genome. This was done because we wish to benchmark the tools in a manner that is applicable when the reference genome may not even be known (e.g. in <italic>de novo</italic> transcriptomics). The parameters of STAR (see <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary Appendix 1.1</ext-link>) were adjusted appropriately for this purpose (e.g. to dis-allow introns). Similarly, Bowtie 2 was also used to align reads directly to the target transcriptome; the parameters for Bowtie 2 are given in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary Appendix 1.1</ext-link>.</p>
      <sec id="SEC3.1.1">
        <title>3.1.1 Mapping speed</title>
        <p>We wish to measure, as directly as possible, just the time required by the mapping algorithms of the different tools. Thus, when benchmarking the runtime of different methods, we do not save the resulting alignments to disk. Further, to mitigate the effect of ‘outliers’ (a small number of reads which map to a large number of low-complexity reference positions), we bound the number of different transcripts to which a read can map to be 200.</p>
        <p>Additionally, we have also benchmarked Kallisto, but have not included the results in <xref ref-type="fig" rid="btw277-F2">Figure 2</xref>, as the software, unlike the other methods, does not allow multi-threaded execution if mappings are being reported. Thus, we ran Kallisto with a single thread, using the –pseudobam flag and redirecting output to /dev/null to avoid disk overhead. Kallisto requires 17.87 m to map the 48M simulated reads, which included &lt;1 m of quantification time. By comparison, RapMap required 11.65 m to complete with a single thread.
<fig id="btw277-F2" orientation="portrait" position="float"><label>Fig. 2.</label><caption><p>The time taken by Bowtie 2, STAR and RapMap to process the synthetic data using varying numbers of threads. RapMap processes the data substantially faster than the other tools, while providing results of comparable or better accuracy</p></caption><graphic xlink:href="btw277f2p"/></fig>
</p>
        <p>Finally, we note Kallisto, STAR and RapMap require 2–3× the memory of Bowtie 2, but all of the methods tested here exhibit reasonable memory usage. The synthetic set of 48 million reads can be mapped to an index of the entire human transcriptome on a typical laptop with 8 GB of RAM.</p>
        <p>As <xref ref-type="fig" rid="btw277-F2">Figure 2</xref> illustrates, RapMap outperforms both Bowtie 2 and STAR in terms of speed by a substantial margin, and finishes mapping the reads with a single thread faster than STAR and Bowtie 2 with 10 threads. We consider varying the number of threads used by RapMap and STAR to demonstrate how performance scales with the number of threads provided. On this dataset, RapMap quickly approaches peak performance after using only a few threads. We believe that this is not owing to limits on the scalability of RapMap, but rather because the process is so quick that, for a dataset of this size, simply reading the index constitutes a large (and growing) fraction of the total runtime (dotted line) as the number of threads is increased. Thus, we believe that the difference in runtime between RapMap and the other methods may be even larger for datasets consisting of a large number of reads, where the disk can reach peak efficiency and the multi-threaded input parser (we use the parser from the Jellyfish (<xref rid="btw277-B27" ref-type="bibr">Marçais and Kingsford, 2011</xref>) library) can provide input to RapMap quickly enough to make use of a larger number of threads. Because running Bowtie 2 with each potential number of threads on this dataset is time-consuming, we only consider Bowtie 2’s runtime using 10 threads.</p>
      </sec>
      <sec id="SEC3.1.2">
        <title>3.1.2 Mapping accuracy</title>
        <p>Because the Flux Simulator records the true origin of each read, we make use of this information as ground truth data to assess the accuracy of different methods. However, as a single read may have multiple, equally good alignments with respect to the transcriptome, care must be taken in defining accuracy-related terms appropriately. A read is said to be correctly mapped by a method (a true positive) if the set of transcripts reported by the mapper for this read contains the true transcript. A read is said to be incorrectly mapped by a method (a false positive) if it is mapped to some set of 1 or more transcripts, none of which are the true transcript of origin. Finally, a read is considered to be incorrectly un-mapped by a method (a false negative) if the method reports no mappings, but the transcript of origin is in the reference. Given these definitions, we report precision, recall, F1-Score and false discovery rate (FDR) in <xref ref-type="table" rid="btw277-T1">Table 1</xref> using the standard definitions of these metrics. Additionally, we report the average number of ‘hits-per-read’ (hpr) returned by each of the methods. Ideally, we want a method to return the smallest set of mappings that contains the true read origin. However, under the chosen definition of a true-positive mapping, the number of reported mappings is not taken into account, and a result is considered a true positive so long as it contains the actual transcript of origin. The hpr metric allows one to assess how many <italic>extra</italic> mappings, on average, are reported by a particular method.
<table-wrap id="btw277-T1" orientation="portrait" position="float"><label>Table 1.</label><caption><p><bold/> Accuracy of aligners/mappers under different metrics</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Metric</th><th rowspan="1" colspan="1">Bowtie 2</th><th rowspan="1" colspan="1">Kallisto</th><th rowspan="1" colspan="1">RapMap</th><th rowspan="1" colspan="1">STAR</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Reads aligned</td><td align="center" rowspan="1" colspan="1">47 579 567</td><td align="center" rowspan="1" colspan="1">44 804 857</td><td align="center" rowspan="1" colspan="1">47 613 536</td><td align="center" rowspan="1" colspan="1">44 711 604</td></tr><tr><td rowspan="1" colspan="1">Recall</td><td align="char" char="." rowspan="1" colspan="1">97.41</td><td align="char" char="." rowspan="1" colspan="1">91.60</td><td align="char" char="." rowspan="1" colspan="1">97.49</td><td align="char" char="." rowspan="1" colspan="1">91.35</td></tr><tr><td rowspan="1" colspan="1">Precision</td><td align="char" char="." rowspan="1" colspan="1">98.31</td><td align="char" char="." rowspan="1" colspan="1">97.72</td><td align="char" char="." rowspan="1" colspan="1">98.48</td><td align="char" char="." rowspan="1" colspan="1">97.02</td></tr><tr><td rowspan="1" colspan="1">F1-score</td><td align="char" char="." rowspan="1" colspan="1">97.86</td><td align="char" char="." rowspan="1" colspan="1">94.56</td><td align="char" char="." rowspan="1" colspan="1">97.98</td><td align="char" char="." rowspan="1" colspan="1">94.10</td></tr><tr><td rowspan="1" colspan="1">FDR</td><td align="char" char="." rowspan="1" colspan="1">1.69</td><td align="char" char="." rowspan="1" colspan="1">2.28</td><td align="char" char="." rowspan="1" colspan="1">1.52</td><td align="char" char="." rowspan="1" colspan="1">2.98</td></tr><tr><td rowspan="1" colspan="1">Hits per read</td><td align="char" char="." rowspan="1" colspan="1">5.98</td><td align="char" char="." rowspan="1" colspan="1">5.30</td><td align="char" char="." rowspan="1" colspan="1">4.30</td><td align="char" char="." rowspan="1" colspan="1">3.80</td></tr></tbody></table></table-wrap></p>
        <p>As expected, Bowtie 2— perhaps the most common method of directly mapping reads to transcriptomes— performs well in terms of precision and recall. However, we find that RapMap yields similar (in fact, slightly better) precision and recall. STAR and Kallisto obtain similar precision to Bowtie 2 and RapMap, but have lower recall. STAR and Kallisto perform similarly in general, though Kallisto achieves a lower (better) FDR than STAR. Taking the F1-score as a summary statistic, we observe that all methods perform reasonably well, and that, in general, alignment-based methods do not seem to be more accurate than mapping-based methods. We also observe that RapMap yields accurate mapping results that match or exceed those of Bowtie 2.</p>
        <p>Additionally, we tested the impact of noisy reads (i.e. reads not generated from the indexed reference) on the accuracy of the different mappers and aligners. To create these background reads, we use a model inspired by (<xref rid="btw277-B7" ref-type="bibr">Gilbert <italic>et al.</italic>, 2004</xref>), in which reads are sampled from nascent, un-spliced transcripts. The details of this experiment are included in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary Appendix 1.3</ext-link>.</p>
      </sec>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Speed and concordance on experimental data</title>
      <p>We also explore the concordance of RapMap with different mapping and alignment approaches using experimental data from the study of <xref rid="btw277-B2" ref-type="bibr">Cho <italic>et al.</italic> (2014)</xref> (NCBI GEO accession SRR1293902). The sample consists of <inline-formula id="IE18"><mml:math id="IEQ18"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>26</mml:mn></mml:mrow></mml:math></inline-formula> million 75 bp, paired-end reads sequenced on an Illumina HiSeq.</p>
      <p>Because we do not know the true origin of each read, we have instead examined the agreement between the different tools (see <xref ref-type="fig" rid="btw277-F3">Fig. 3</xref>). Intuitively, two tools agree on the mapping locations of a read if they align/map this read to the same subset of the reference transcriptome (i.e. the same set of transcripts). More formally, we define the elements of our universe, <inline-formula id="IE19"><mml:math id="IEQ19"><mml:mi mathvariant="script">U</mml:mi></mml:math></inline-formula>, to be tuples consisting of a read identifier and the set of transcripts returned by a particular tool. For example, if, for read <italic>r<sub>i</sub></italic>, tool <italic>A</italic> returns alignments to transcripts <inline-formula id="IE20"><mml:math id="IEQ20"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> then <inline-formula id="IE21"><mml:math id="IEQ21"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:math></inline-formula>. Similarly, if tool <italic>B</italic> maps read <italic>r<sub>i</sub></italic> to transcripts <inline-formula id="IE22"><mml:math id="IEQ22"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> then <inline-formula id="IE23"><mml:math id="IEQ23"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>∈</mml:mo><mml:mi mathvariant="script">U</mml:mi></mml:mrow></mml:math></inline-formula>. Here, tools <inline-formula id="IE24"><mml:math id="IEQ24"><mml:mi>A</mml:mi></mml:math></inline-formula> and <inline-formula id="IE25"><mml:math id="IEQ25"><mml:mi>B</mml:mi></mml:math></inline-formula> do not agree on the mapping of read <italic>r<sub>i</sub></italic>. Given a universe <inline-formula id="IE26"><mml:math id="IEQ26"><mml:mi mathvariant="script">U</mml:mi></mml:math></inline-formula> thusly defined, we can use the normal notions of set intersection and difference to explore how different subsets of methods agree on the mapping locations of the sequenced reads. These concordance results are presented in <xref ref-type="fig" rid="btw277-F3">Figure 3</xref>, which uses a bar plot to show the size of each set of potential intersections between the results of the tools we consider. In <xref ref-type="fig" rid="btw277-F3">Figure 3</xref> the dot matrix below the bar plot identifies the tools whose results are intersected to produce the corresponding bar. Tools producing mappings and alignments are denoted with black and red dots and bars, respectively. The left bar plot shows the size of the unique tuples produced by each tool (alignments/mappings that do not match with any other tool). The right bar plot shows the total number of tuples produced by each tool, and well as the concordance among all different subsets of tools.
<fig id="btw277-F3" orientation="portrait" position="float"><label>Fig. 3.</label><caption><p>Mapping agreement between subsets of Bowtie 2, STAR, Kallisto andRapMap.</p></caption><graphic xlink:href="btw277f3p"/></fig>
</p>
      <p>Under this measure of agreement, RapMap and Kallisto appear to agree on the exact same transcript assignments for the largest number of reads. Further, RapMap and Kallisto have the largest pairwise agreements with the aligners (STAR and Bowtie 2)—that is, the traditional aligners exactly agree more often with these tools than with each other. It is important to note that one possible reason we see (seemingly) low agreement between Bowtie 2 and other methods is because the transcript alignment sets reported by Bowtie 2 are generally larger (i.e. contain more transcripts) than those returned by other methods, and thus fail to qualify under our notion of agreement. This occurs, partially, because RapMap and Kallisto (and to some extent STAR) do not tend to return sub-optimal multi-mapping locations. However, unlike Bowtie 1, which provided an option to return only the best ‘stratum’ of alignments, there is no way to require that Bowtie 2 return only the best multi-mapping locations for a read. We observe similar behavior for Bowtie 2 (i.e. that it returns a larger set of mapping locations) in the synthetic tests as well, where the average number of hits per read is higher than for the other methods (see <xref ref-type="table" rid="btw277-T1">Table 1</xref>). In terms of runtime, RapMap, STAR and Bowtie 2 take 3, 26 and 1020 min, respectively, to align the reads from this experiment using four threads. We also observed a similar trend in terms of the average number of hits per read here as we did in the synthetic dataset. The average number of hits per read on these data were 4.56, 4.68, 4.21 and 7.97 for RapMap, Kallisto, STAR and Bowtie 2, respectively.</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 Application of quasi-mapping for transcript quantification</title>
    <p>While mapping cannot act as a stand-in for full alignments in all contexts, one problem where similar approaches have already proven useful is transcript abundance estimation. Recent work (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>; <xref rid="btw277-B32" ref-type="bibr">Patro <italic>et al.</italic>, 2014</xref>, <xref rid="btw277-B33" ref-type="bibr">2015</xref>; <xref rid="btw277-B37" ref-type="bibr">Zhang and Wang, 2014</xref>) has demonstrated that full alignments are not necessary to obtain accurate quantification results. Rather, simply knowing the transcripts and positions where reads may have reasonably originated is sufficient to produce accurate estimates of transcript abundance. Thus, we have chosen to apply quasi-mapping to transcript-level quantification as an example application, and have implemented our modifications as an update to the Sailfish (<xref rid="btw277-B32" ref-type="bibr">Patro <italic>et al.</italic>, 2014</xref>) software, which we refer to as quasi-Sailfish. These changes are present in the Sailfish software from version 0.7 forward. Here, we compare this updated method to the transcript-level quantification tools RSEM (<xref rid="btw277-B22" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>), Tigar2 (<xref rid="btw277-B29" ref-type="bibr">Nariai <italic>et al.</italic>, 2014</xref>) and Kallisto (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>), the last of which is based on the pseudoalignment concept mentioned above.</p>
    <sec id="SEC4.1">
      <title>4.1 Transcript quantification</title>
      <p>In an RNA-seq experiment, the underlying transcriptome consists of <italic>M</italic> transcripts and their respective counts. The transcriptome can be represented as a set <inline-formula id="IE27"><mml:math id="IEQ27"><mml:mrow><mml:mi mathvariant="script">X</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>t<sub>i</sub></italic> denotes the nucleotide sequence of transcript <inline-formula id="IE28"><mml:math id="IEQ28"><mml:mi>i</mml:mi></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IEQ29"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denotes the number of copies of <italic>t<sub>i</sub></italic> in the sample. The length of transcript <italic>t<sub>i</sub></italic> is denoted by <italic>l<sub>i</sub></italic>. Under ideal, uniform, sampling conditions (i.e. without considering various types of experimental bias), the probability of drawing a fragment from a transcript <italic>t<sub>i</sub></italic> is proportional to its nucleotide fraction (<xref rid="btw277-B22" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>) denoted by <inline-formula id="IE30"><mml:math id="IEQ30"><mml:mrow><mml:msub><mml:mi>η</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mstyle displaystyle="false"><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>M</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:msub><mml:mi>l</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>.</p>
      <p>If we normalize the <italic>η<sub>i</sub></italic> for each transcript by its length <italic>l<sub>i</sub></italic>, we obtain a measure of the relative abundance of each transcript called the transcript fraction (<xref rid="btw277-B22" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>), which is given by <inline-formula id="IE31"><mml:math id="IEQ31"><mml:mrow><mml:msub><mml:mi>τ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>η</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:mstyle displaystyle="false"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>η</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>.</p>
      <p>When performing transcript-level quantification, <inline-formula id="IE32"><mml:math id="IEQ32"><mml:mi mathvariant="bold-italic">η</mml:mi></mml:math></inline-formula> and <inline-formula id="IE33"><mml:math id="IEQ33"><mml:mi mathvariant="bold-italic">τ</mml:mi></mml:math></inline-formula> are generally the quantities we are interested in inferring. Because they are directly related, knowing one allows us to directly compute the other. Below, we describe our approach to approximating the estimated number of reads originating from each transcript, from which we estimate <inline-formula id="IE34"><mml:math id="IEQ34"><mml:mi mathvariant="bold-italic">τ</mml:mi></mml:math></inline-formula>, and subsequently transcripts per million (TPM).</p>
    </sec>
    <sec id="SEC4.2">
      <title>4.2 Quasi-mapping-based Sailfish</title>
      <p>Using the quasi-mapping procedure provided by RapMap as a library, we have updated the Sailfish (<xref rid="btw277-B32" ref-type="bibr">Patro <italic>et al.</italic>, 2014</xref>) software to make use of quasi-mapping, as opposed to individual k-mer counting, for transcript-level quantification. In the updated version of Sailfish, the index command builds the quasi-index over the reference transcriptome as described in Section 2. Given the index and a set of sequenced reads, the quant command quasi-maps the reads and uses the resulting mapping information to estimate transcript abundances.</p>
      <p>To reduce the memory usage and computational requirements of the inference procedure, quasi-Sailfish reduces the mapping information to a set of equivalence classes over sequenced fragments. These equivalence classes are similar to those used in <xref rid="btw277-B30" ref-type="bibr">Nicolae <italic>et al.</italic> (2011)</xref>, except that the position of each fragment within a transcript is not considered when defining the equivalence relation. Specifically, any fragments that map to exactly the same set of transcripts are placed into the same equivalence class. Following the notation of <xref rid="btw277-B33" ref-type="bibr">Patro <italic>et al.</italic> (2015)</xref>, the equivalence classes are denoted as <inline-formula id="IE35"><mml:math id="IEQ35"><mml:mrow><mml:mi mathvariant="script">C</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msup><mml:mi mathvariant="script">C</mml:mi><mml:mn>1</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi mathvariant="script">C</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and the count of fragments associated with equivalence class <inline-formula id="IE36"><mml:math id="IEQ36"><mml:mrow><mml:msup><mml:mi mathvariant="script">C</mml:mi><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is given by <italic>d<sup>j</sup></italic>. Associated with each equivalence class <inline-formula id="IE37"><mml:math id="IEQ37"><mml:mrow><mml:msup><mml:mi mathvariant="script">C</mml:mi><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is an ordered collection of transcript identifiers <inline-formula id="IE38"><mml:math id="IEQ38"><mml:mrow><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>t</mml:mi></mml:mstyle><mml:mi>j</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, which is simply the collection of transcripts to which all equivalent fragments in this class map. We call <inline-formula id="IE39"><mml:math id="IEQ39"><mml:mrow><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>t</mml:mi></mml:mstyle><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> the <italic>label</italic> of class <inline-formula id="IE40"><mml:math id="IEQ40"><mml:mrow><mml:msup><mml:mi mathvariant="script">C</mml:mi><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
      <sec id="SEC4.2.1">
        <title>4.2.1 Inferring transcript abundances</title>
        <p>The equivalence classes <inline-formula id="IE41"><mml:math id="IEQ41"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> and their associated counts and labels are used to estimate the number of fragments originating from each transcript. The estimated count vector is denoted by <inline-formula id="IE42"><mml:math id="IEQ42"><mml:mi mathvariant="bold-italic">α</mml:mi></mml:math></inline-formula>, and <italic>α<sub>i</sub></italic> is the estimated number of reads originating from transcript <italic>t<sub>i</sub></italic>. In quasi-Sailfish, we use the variational Bayesian expectation maximization (VBEM) algorithm to infer the parameters (the estimated number of reads originating from each transcript) that maximize a variational objective. Specifically, we maximize a simplified version of the variational objective of <xref rid="btw277-B28" ref-type="bibr">Nariai <italic>et al.</italic> (2013)</xref>.</p>
        <p>The VBEM update rule can be written as a simple iterative update in terms of the equivalence classes, their counts and the prior (<italic>α</italic><sub>0</sub>). The iterative update rule for the VBEM is:
<disp-formula id="E1"><label>(1)</label><mml:math id="EQ1"><mml:mrow><mml:msubsup><mml:mi>α</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msup><mml:mi mathvariant="script">C</mml:mi><mml:mi>j</mml:mi></mml:msup><mml:mo>∈</mml:mo><mml:mi mathvariant="script">C</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msubsup><mml:mi>γ</mml:mi><mml:mi>i</mml:mi><mml:mi>u</mml:mi></mml:msubsup></mml:mrow></mml:msup><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>t</mml:mi></mml:mstyle><mml:mi>j</mml:mi></mml:msup></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:msubsup><mml:mi>γ</mml:mi><mml:mi>k</mml:mi><mml:mi>u</mml:mi></mml:msubsup></mml:mrow></mml:msup></mml:mrow></mml:mstyle><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:mfrac></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where
<disp-formula id="E2"><label>(2)</label><mml:math id="EQ2"><mml:mrow><mml:msubsup><mml:mi>γ</mml:mi><mml:mi>i</mml:mi><mml:mi>u</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msubsup><mml:mi>α</mml:mi><mml:mi>i</mml:mi><mml:mi>u</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mi>k</mml:mi></mml:munder><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:msubsup><mml:mi>α</mml:mi><mml:mi>k</mml:mi><mml:mi>u</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
and <inline-formula id="IE43"><mml:math id="IEQ43"><mml:mrow><mml:mi>Ψ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the digamma function. Here, <inline-formula id="IE44"><mml:math id="IEQ44"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is the <italic>effective</italic> length of transcript <italic>t<sub>i</sub></italic>, computed as in <xref rid="btw277-B22" ref-type="bibr">Li <italic>et al.</italic> (2010)</xref>. To determine the final estimated counts—<inline-formula id="IE45"><mml:math id="IEQ45"><mml:mi mathvariant="bold-italic">α</mml:mi></mml:math></inline-formula>—<xref ref-type="disp-formula" rid="E1">Equation (1)</xref> is iterated until convergence. The estimated counts are considered to have converged when no transcript has estimated counts differing by &gt;1% between successive iterations.</p>
        <p>Given <inline-formula id="IE46"><mml:math id="IEQ46"><mml:mi mathvariant="bold-italic">α</mml:mi></mml:math></inline-formula>, we compute the TPM for transcript <italic>i</italic> as
<disp-formula id="E3"><label>(3)</label><mml:math id="EQ3"><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:msub><mml:mi>M</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mn>6</mml:mn></mml:msup><mml:mfrac><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:mstyle displaystyle="false"><mml:munder><mml:mo>∑</mml:mo><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">^</mml:mo></mml:mover></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
        <p>Sailfish outputs, for each transcript, its name, length, effective length, TPM and the estimated number of reads originating from it.</p>
      </sec>
    </sec>
    <sec id="SEC4.3">
      <title>4.3 Quantification performance comparison</title>
      <p>We compared the accuracy of quasi-Sailfish (Sailfish v0.9.0; q-Sailfish in <xref ref-type="table" rid="btw277-T2">Table 2</xref>) to the transcript-level quantification tools RSEM (<xref rid="btw277-B22" ref-type="bibr">Li <italic>et al.</italic>, 2010</xref>) (v1.2.22), Tigar 2 (<xref rid="btw277-B29" ref-type="bibr">Nariai <italic>et al.</italic>, 2014</xref>) (v2.1) and Kallisto (<xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic>, 2016</xref>) (v0.42.4) using six different accuracy metrics and data from two different simulation pipelines. One of the simulated datasets was generated with the Flux Simulator (<xref rid="btw277-B9" ref-type="bibr">Griebel <italic>et al.</italic>, 2012</xref>), and is the same dataset used in Section 3 to assess mapping accuracy and performance on synthetic data. The other dataset was generated using the RSEM simulator via the same methodology adopted by <xref rid="btw277-B1" ref-type="bibr">Bray <italic>et al.</italic> (2016)</xref>. That is, RSEM was run on sample NA12716_7 of the Geuvadis RNA-seq data (<xref rid="btw277-B18" ref-type="bibr">Lappalainen <italic>et al.</italic>, 2013</xref>) to learn model parameters and estimate true expression. The learned model was then used to generate the simulated dataset, which consists of 30 <italic>million</italic> 75 bp paired-end reads.
<table-wrap id="btw277-T2" orientation="portrait" position="float"><label>Table 2.</label><caption><p><bold/> Performance evaluation of different tools along with quasi-enabled sailfish (q-Sailfish) with other tools on synthetic data generated by Flux simulator and RSEM simulator</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" colspan="1">Metric</th><th align="center" colspan="4" rowspan="1">Flux simulation</th><th align="center" colspan="4" rowspan="1">RSEM-sim simulation</th></tr><tr><th rowspan="1" colspan="1">Kallisto</th><th rowspan="1" colspan="1">RSEM</th><th rowspan="1" colspan="1">q-Sailfish</th><th rowspan="1" colspan="1">Tigar 2</th><th rowspan="1" colspan="1">Kallisto</th><th rowspan="1" colspan="1">RSEM</th><th rowspan="1" colspan="1">q-Sailfish</th><th rowspan="1" colspan="1">Tigar 2</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Proportionality corr.</td><td align="char" char="." rowspan="1" colspan="1">0.74</td><td align="char" char="." rowspan="1" colspan="1">0.78</td><td align="char" char="." rowspan="1" colspan="1">0.75</td><td align="char" char="." rowspan="1" colspan="1">0.77</td><td align="char" char="." rowspan="1" colspan="1">0.91</td><td align="char" char="." rowspan="1" colspan="1">0.93</td><td align="char" char="." rowspan="1" colspan="1">0.91</td><td align="char" char="." rowspan="1" colspan="1">0.93</td></tr><tr><td rowspan="1" colspan="1">Spearman corr.</td><td align="char" char="." rowspan="1" colspan="1">0.69</td><td align="char" char="." rowspan="1" colspan="1">0.73</td><td align="char" char="." rowspan="1" colspan="1">0.70</td><td align="char" char="." rowspan="1" colspan="1">0.72</td><td align="char" char="." rowspan="1" colspan="1">0.91</td><td align="char" char="." rowspan="1" colspan="1">0.93</td><td align="char" char="." rowspan="1" colspan="1">0.91</td><td align="char" char="." rowspan="1" colspan="1">0.93</td></tr><tr><td rowspan="1" colspan="1">TPEF</td><td align="char" char="." rowspan="1" colspan="1">0.77</td><td align="char" char="." rowspan="1" colspan="1">0.96</td><td align="char" char="." rowspan="1" colspan="1">0.60</td><td align="char" char="." rowspan="1" colspan="1">0.59</td><td align="char" char="." rowspan="1" colspan="1">0.53</td><td align="char" char="." rowspan="1" colspan="1">0.49</td><td align="char" char="." rowspan="1" colspan="1">0.53</td><td align="char" char="." rowspan="1" colspan="1">0.50</td></tr><tr><td rowspan="1" colspan="1">TPME</td><td align="char" char="." rowspan="1" colspan="1">−0.24</td><td align="char" char="." rowspan="1" colspan="1">−0.37</td><td align="char" char="." rowspan="1" colspan="1">−0.10</td><td align="char" char="." rowspan="1" colspan="1">−0.09</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">−0.01</td><td align="char" char="." rowspan="1" colspan="1">0.00</td><td align="char" char="." rowspan="1" colspan="1">0.00</td></tr><tr><td rowspan="1" colspan="1">MARD</td><td align="char" char="." rowspan="1" colspan="1">0.36</td><td align="char" char="." rowspan="1" colspan="1">0.29</td><td align="char" char="." rowspan="1" colspan="1">0.31</td><td align="char" char="." rowspan="1" colspan="1">0.26</td><td align="char" char="." rowspan="1" colspan="1">0.29</td><td align="char" char="." rowspan="1" colspan="1">0.25</td><td align="char" char="." rowspan="1" colspan="1">0.29</td><td align="char" char="." rowspan="1" colspan="1">0.23</td></tr><tr><td rowspan="1" colspan="1">wMARD</td><td align="char" char="." rowspan="1" colspan="1">4.68</td><td align="char" char="." rowspan="1" colspan="1">5.23</td><td align="char" char="." rowspan="1" colspan="1">4.45</td><td align="char" char="." rowspan="1" colspan="1">4.35</td><td align="char" char="." rowspan="1" colspan="1">1.00</td><td align="char" char="." rowspan="1" colspan="1">0.88</td><td align="char" char="." rowspan="1" colspan="1">1.01</td><td align="char" char="." rowspan="1" colspan="1">0.94</td></tr></tbody></table></table-wrap></p>
      <p>We measure the accuracy of each method based on the estimated versus true number of reads originating from each transcript, and consider six different metrics of accuracy: proportionality correlation (<xref rid="btw277-B25" ref-type="bibr">Lovell <italic>et al.</italic>, 2015</xref>), Spearman correlation, the true positive error fraction (TPEF), the true positive median error (TPME), the mean absolute relative difference (MARD) and the weighted mean absolute relative difference (wMARD). Detailed definitions for the last four metrics are provided in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary Appendix 1.5</ext-link>.</p>
      <p>Each of these metrics captures a different notion of accuracy, and all are reported to provide a more comprehensive perspective on quantifier accuracy. The first two metrics—proportionality and Spearman correlation—provide a global notion of how well the estimated and true counts agree, but are fairly coarse measures. The TPEF assesses the fraction of transcripts where the estimate is different from the true count by more than some nominal fraction (here 10%). Unlike TPEF, the TPME metric takes into account the direction of the mis-estimate (i.e. is it an over or under-estimate of the true value?). However, both metrics are assessed only on truly expressed transcripts, and so provide no insight into the tendency of a quantifier to produce false positives.</p>
      <p>The absolute relative difference (ARD) metric has the benefit of being defined on all transcripts as opposed to only those that are truly expressed and ranges from 0 (lowest) to 2 (highest). Because the values of this metric are tightly bounded, the aggregate metric, MARD, is not dominated by high expression transcripts. Unfortunately, it therefore has limited ability to capture the magnitude of mis-estimation. The wMARD metric attempts to account for the magnitude of mis-estimation, while still trying to ensure that the measure is not completely dominated by high expression transcripts. This is done by scaling each ARD<sub><italic>i</italic></sub> value by the logarithm of the expression.</p>
      <p><xref ref-type="table" rid="btw277-T2">Table 2</xref> shows the performance of all four quantifiers, under all six metrics, on both datasets. While all methods seem to perform reasonably well, some patterns emerge. RSEM seems to perform well in terms of the correlation metrics, but less well in terms of the TPEF, TPME and wMARD metrics (specifically in the Flux Simulator-generated dataset). This is likely a result of the lower mapping rate obtained on this data by RSEM’s strict Bowtie 2 parameters. Tigar 2 generally performs well under a broad range of metrics, and produces highly accurate results. However, it is <italic>by far</italic> the slowest method considered here, and requires over a day to complete on the Flux simulator data and almost 7 h to complete on the RSEM-sim data given 16 threads (and not including the time required for Bowtie 2 alignment of the reads). Finally, both quasi-Sailfish and Kallisto perform well in general under multiple different metrics, with quasi-Sailfish tending to produce somewhat more accurate estimates. Both of these methods also completed in a matter of minutes on both datasets.</p>
      <p>One additional pattern that emerges is that the RSEM-sim data appears to present a much simpler inference problem compared with the Flux Simulator data. One reason for this may be that the RSEM-sim data are ‘clean’—yielding concordant mapping rates well over 99%, even under RSEM’s strict Bowtie 2 mapping parameters. As such, all methods tend to perform well on these data, and there is comparatively little deviation between the methods under most metrics.</p>
      <p>For completeness, we also provide (in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btw277/-/DC1">Supplementary Appendix 1.4</ext-link>) the results, under all of these metrics, where the true and predicted abundances are considered in terms of TPM rather than number of reads. We find that the results are generally similar, with the exception that TIGAR 2 performs considerably worse under the TPM measure.</p>
    </sec>
  </sec>
  <sec id="SEC5">
    <title>5 Application of quasi-mapping for clustering <italic>de novo</italic> assemblies</title>
    <p>Estimating gene-expression from RNA-seq reads is an especially challenging task when no reference genome is present. Typically, this problem is solved by performing <italic>de novo</italic> assembly of the RNA-seq reads, and subsequently mapping these reads to the resulting contigs to estimate expression. Owing to sequencing errors and artifacts, and genetic variation and repeats, <italic>de novo</italic> assemblers often fragment individual isoforms into separate assembled contigs. <xref rid="btw277-B4" ref-type="bibr">Davidson and Oshlack (2014)</xref> argue that better differential expression results can be obtained in <italic>de novo</italic> assemblies if contigs are first clustered into groups. They present a tool, CORSET, to perform this clustering, and compare their approach to existing tools such as CD-HIT (<xref rid="btw277-B6" ref-type="bibr">Fu <italic>et al.</italic>, 2012</xref>). CD-HIT compares the sequences (contigs) directly, and clusters them by sequence similarity. CORSET, alternatively, aligns reads to contigs (allowing multi-mapping) and defines a distance between each pair of contigs based on the number of multi-mapping reads shared between them, and the changes in estimated expression inferred for these contigs under different conditions. Hierarchical agglomerative clustering is then performed on these distances to obtain a clustering of contigs.</p>
    <p>Here, we show how RapMap can be used for the same task, by taking an approach similar to that of CORSET. First, we map the RNA-seq reads to the target contigs and simultaneously construct equivalence classes over the mapped fragments as in Section 4. We construct a weighted, undirected graph from these equivalence classes as follows. Given a set of contigs <bold>c</bold> and the equivalence classes <inline-formula id="IE47"><mml:math id="IEQ47"><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula>, we construct <inline-formula id="IE48"><mml:math id="IEQ48"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE49"><mml:math id="IEQ49"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>c</mml:mi></mml:mstyle></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE50"><mml:math id="IEQ50"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>{</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>∃</mml:mo><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>t</mml:mi></mml:mstyle><mml:mi>j</mml:mi></mml:msup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. We define the weight of edge <inline-formula id="IE51"><mml:math id="IEQ51"><mml:mrow><mml:mo>{</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as <inline-formula id="IE52"><mml:math id="IEQ52"><mml:mrow><mml:mi>w</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>R</mml:mi><mml:mi>v</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. Here <italic>R<sub>u</sub></italic> is the total number of reads belonging to all equivalence classes in which contig <italic>u</italic> appears in the label. <italic>R<sub>v</sub></italic> is defined analogously. <inline-formula id="IE53"><mml:math id="IEQ53"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the total sum of reads in all equivalence classes for which contigs <inline-formula id="IE54"><mml:math id="IEQ54"><mml:mi>u</mml:mi></mml:math></inline-formula> and <inline-formula id="IE55"><mml:math id="IEQ55"><mml:mi>v</mml:mi></mml:math></inline-formula> appear in the label. Given the undirected graph <italic>G</italic>, we use the <italic>Markov Cluster Algorithm</italic>, as implemented in MCL (<xref rid="btw277-B35" ref-type="bibr">Van Dongen, 2000</xref>), to cluster the graph.</p>
    <p>To benchmark the time and accuracy of our clustering scheme compared with CD-HIT and CORSET, we used two datasets from the CORSET paper (<xref rid="btw277-B4" ref-type="bibr">Davidson and Oshlack, 2014</xref>). The first dataset consists of 231 million human reads in total, across two conditions, each with three replicates (as originally described by <xref rid="btw277-B34" ref-type="bibr">Trapnell <italic>et al.</italic>, 2013</xref>). The second dataset, from yeast, was originally published by <xref rid="btw277-B31" ref-type="bibr">Nookaew <italic>et al.</italic> (2012)</xref> and consists 36 million reads, grown in two different conditions with three replicates each. For both of these datasets, we consider clustering the contigs of the corresponding <italic>de novo</italic> assemblies, which were generated using Trinity (<xref rid="btw277-B8" ref-type="bibr">Grabherr <italic>et al.</italic>, 2011</xref>).</p>
    <p>To measure accuracy, we consider the precision and recall induced by a clustering with respect to the true genes from which each contig originates. Assembled contigs were mapped to annotated transcripts using BLAT (<xref rid="btw277-B13" ref-type="bibr">Kent, 2002</xref>), and labeled with their gene of origin. A pair of contigs from the same cluster is regarded as true positive (tp) if they are from the same gene in the ground truth set. Similarly, a pair is a false positive (fp) if they are not from same gene but are clustered together. A pair is a false negative (fn) if they are from same gene but not predicted to be in the same cluster and all the remaining pairs are true negatives (tn). With these definitions of tp, fp, tn and fn we can define precision and recall in standard manner. As shown in <xref ref-type="table" rid="btw277-T3">Table 3</xref>, when considering both precision and recall, RapMap (quasi-mapping) enabled clustering performs substantially better than CD-HIT and similar to CORSET. RapMap enabled clustering takes 8 min and 2 min to cluster the human and yeast datasets respectively—which is substantially faster than the other tools. To generate the timing results above, CD-HIT was run with 25 threads. The time recorded for CORSET consists of both the time required to align the reads using Bowtie 2 (using 25 threads) and the time required to perform the actual clustering, which is single threaded. The time recorded for RapMap enabled clustering consists of the time required to quasi-map the reads, build the equivalence classes and construct the graph (using 25 threads), plus the time required to cluster the graph with MCL (using a single thread). Overall, on these datasets, RapMap-enabled clustering appears to provide comparable or better clusterings than existing methods, and produces these clusterings much more quickly.
<table-wrap id="btw277-T3" orientation="portrait" position="float"><label>Table 3.</label><caption><p><bold/> Performance of CORSET, CD-HIT and RapMap enabled clustering (R-CL) on yeast and human data</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" colspan="1">Metric</th><th align="center" colspan="3" rowspan="1">Human</th><th align="center" colspan="3" rowspan="1">Yeast</th></tr><tr><th rowspan="1" colspan="1">CORSET</th><th rowspan="1" colspan="1">CD-HIT</th><th rowspan="1" colspan="1">R-CL</th><th rowspan="1" colspan="1">CORSET</th><th rowspan="1" colspan="1">CD-HIT</th><th rowspan="1" colspan="1">R-CL</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">precision</td><td align="char" char="." rowspan="1" colspan="1">0.96</td><td align="char" char="." rowspan="1" colspan="1">0.96</td><td align="char" char="." rowspan="1" colspan="1">0.95</td><td align="char" char="." rowspan="1" colspan="1">0.36</td><td align="char" char="." rowspan="1" colspan="1">0.41</td><td align="char" char="." rowspan="1" colspan="1">0.36</td></tr><tr><td rowspan="1" colspan="1">recall</td><td align="char" char="." rowspan="1" colspan="1">0.56</td><td align="char" char="." rowspan="1" colspan="1">0.37</td><td align="char" char="." rowspan="1" colspan="1">0.60</td><td align="char" char="." rowspan="1" colspan="1">0.63</td><td align="char" char="." rowspan="1" colspan="1">0.36</td><td align="char" char="." rowspan="1" colspan="1">0.71</td></tr><tr><td rowspan="1" colspan="1">time (min)</td><td align="center" rowspan="1" colspan="1">957</td><td align="center" rowspan="1" colspan="1">268</td><td align="left" rowspan="1" colspan="1">8</td><td align="left" rowspan="1" colspan="1">23</td><td align="left" rowspan="1" colspan="1">5</td><td align="left" rowspan="1" colspan="1">2</td></tr></tbody></table></table-wrap></p>
  </sec>
  <sec id="SEC6">
    <title>6 Discussion and conclusion</title>
    <p>In this article we have argued for the usefulness of our novel approach, quasi-mapping, for mapping RNA-seq reads. More generally, we suspect that read <italic>mapping</italic>, wherein sequencing reads are assigned to reference locations, but base-to-base alignments are not computed, is a broadly useful tool. The speed of traditional aligners like Bowtie 2 and STAR is limited by the fact that they must produce optimal alignments for each location to which a read is reported to align.</p>
    <p>In addition to showing the speed and accuracy of quasi-mapping directly, we apply it to two problems in transcriptome analysis. First, we have updated the Sailfish software to make use of the quasi-mapping information produced by RapMap, rather than direct k-mer counts, for purposes of transcript-level abundance estimation. This update improves both the speed and accuracy of Sailfish, and also reduces the complexity of its codebase. We demonstrate, on synthetic data generated via two different simulators, that the resulting quantification estimates have accuracy comparable with state-of-the-art tools. We also demonstrate the application of RapMap to the problem of clustering <italic>de novo</italic> assembled contigs, a task that has been shown to improve expression quantification and downstream differential expression analysis (<xref rid="btw277-B4" ref-type="bibr">Davidson and Oshlack, 2014</xref>). RapMap can produce clusterings of comparable or superior accuracy to those of existing tools, and can do so much more quickly.</p>
    <p>However, RapMap is a stand-alone mapping program, and need not be used only for the applications we describe here. We expect that quasi-mapping will prove a useful and rapid alternative to alignment for tasks ranging from filtering large read sets (e.g. to check for contaminants or the presence or absence of specific targets) to more mundane tasks like quality control and, perhaps, even to related tasks like metagenomic and metatranscriptomic classification and abundance estimation.</p>
    <p>We hope that the quasi-mapping concept, and the availability of RapMap and the efficient and accurate mapping algorithms it exposes, will encourage the community to explore replacing alignment with mapping in the numerous scenarios where traditional alignment information is unnecessary for downstream analysis.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_32_12_i192__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btw277_Patro.166.sup.1.pdf"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btw277_Patro.166.sup.2.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <fn-group>
    <fn id="btw277-FN1">
      <label>1</label>
      <p>We do not compare against lightweight-alignment here, as no stand-alone implementation of this approach is currently available.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors thank Geet Duggal, Richard Smith-Unna and Owen Dando for useful discussions regarding various aspects of this work. The authors also thank the anonymous reviewers whose comments improved the manuscript and exposition.</p>
    <sec>
      <title>Funding</title>
      <p>This work was supported by start up funds from <funding-source>Stony Brook University</funding-source> to RP.</p>
      <p><italic>Conflict of Interest</italic>: none declared.</p>
    </sec>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btw277-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bray</surname><given-names>N.L.</given-names></name></person-group><etal/> (<year>2016</year>) 
<article-title>Near-optimal probabilistic RNA-seq quantification</article-title>. <source>Nature Biotech</source>., <volume>34</volume>(<issue>5</issue>), <fpage>525</fpage>–<lpage>527</lpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cho</surname><given-names>H.</given-names></name></person-group><etal/> (<year>2014</year>) 
<article-title>High-resolution transcriptome analysis with long-read RNA sequencing</article-title>. <source>PLoS ONE</source>, <volume>9</volume>, <fpage>e108095.</fpage><pub-id pub-id-type="pmid">25251678</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cunningham</surname><given-names>F.</given-names></name></person-group><etal/> (<year>2015</year>) 
<article-title>Ensembl 2015</article-title>. <source>Nucleic Acids Res</source>., <volume>43</volume>, <fpage>D662</fpage>–<lpage>D669</lpage>.<pub-id pub-id-type="pmid">25352552</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Davidson</surname><given-names>N.M.</given-names></name><name><surname>Oshlack</surname><given-names>A.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Corset: enabling differential gene expression analysis for de novo assembled transcriptomes</article-title>. <source>Genome Biol</source>., <volume>15</volume>, <fpage>410.</fpage><pub-id pub-id-type="pmid">25063469</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dobin</surname><given-names>A.</given-names></name></person-group><etal/> (<year>2013</year>) 
<article-title>Star: ultrafast universal RNA-seq aligner</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>15</fpage>–<lpage>21</lpage>.<pub-id pub-id-type="pmid">23104886</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fu</surname><given-names>L.</given-names></name></person-group><etal/> (<year>2012</year>) 
<article-title>Cd-hit: accelerated for clustering the next-generation sequencing data</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>3150</fpage>–<lpage>3152</lpage>.<pub-id pub-id-type="pmid">23060610</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gilbert</surname><given-names>C.</given-names></name></person-group><etal/> (<year>2004</year>) 
<article-title>Elongator interactions with nascent mrna revealed by RNA immunoprecipitation</article-title>. <source>Mol. Cell</source>, <volume>14</volume>, <fpage>457</fpage>–<lpage>464</lpage>.<pub-id pub-id-type="pmid">15149595</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grabherr</surname><given-names>M.G.</given-names></name></person-group><etal/> (<year>2011</year>) 
<article-title>Full-length transcriptome assembly from rna-seq data without a reference genome</article-title>. <source>Nat. Biotechnol</source>., <volume>29</volume>, <fpage>644</fpage>–<lpage>652</lpage>.<pub-id pub-id-type="pmid">21572440</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Griebel</surname><given-names>T.</given-names></name></person-group><etal/> (<year>2012</year>) 
<article-title>Modelling and simulating generic rna-seq experiments with the flux simulator</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>10073</fpage>–<lpage>10083</lpage>.<pub-id pub-id-type="pmid">22962361</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Gusfield</surname><given-names>D.</given-names></name></person-group> (<year>1997</year>). <source>Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology</source>. 
<publisher-name>Cambridge University Press</publisher-name>, 
<publisher-loc>New York, NY, USA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btw277-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hach</surname><given-names>F.</given-names></name></person-group><etal/> (<year>2010</year>) 
<article-title>mrsfast: a cache-oblivious algorithm for short-read mapping</article-title>. <source>Nat. Methods</source>, <volume>7</volume>, <fpage>576</fpage>–<lpage>577</lpage>.<pub-id pub-id-type="pmid">20676076</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ilie</surname><given-names>L.</given-names></name></person-group><etal/> (<year>2010</year>) 
<article-title>The longest common extension problem revisited and applications to approximate string searching</article-title>. <source>J. Discrete Algorithms</source>, <volume>8</volume>, <fpage>418</fpage>–<lpage>428</lpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kent</surname><given-names>W.J.</given-names></name></person-group> (<year>2002</year>) 
<article-title>Blat–the blast-like alignment tool</article-title>. <source>Genome Res</source>., <volume>12</volume>, <fpage>656</fpage>–<lpage>664</lpage>.<pub-id pub-id-type="pmid">11932250</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>D.</given-names></name></person-group><etal/> (<year>2015</year>) 
<article-title>Hisat: a fast spliced aligner with low memory requirements</article-title>. <source>Nat. Methods</source>, <volume>12</volume>, <fpage>357</fpage>–<lpage>360</lpage>.<pub-id pub-id-type="pmid">25751142</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Köster</surname><given-names>J.</given-names></name><name><surname>Rahmann</surname><given-names>S.</given-names></name></person-group> (<year>2012</year>) 
<article-title>Building and documenting workflows with python-based snakemake</article-title>. <source>GCB</source>, <volume>26</volume>, <fpage>49</fpage>–<lpage>56</lpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langmead</surname><given-names>B.</given-names></name><name><surname>Salzberg</surname><given-names>S.L.</given-names></name></person-group> (<year>2012</year>) 
<article-title>Fast gapped-read alignment with Bowtie 2</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>357</fpage>–<lpage>359</lpage>.<pub-id pub-id-type="pmid">22388286</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Langmead</surname><given-names>B.</given-names></name></person-group><etal/> (<year>2009</year>) 
<article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>. <source>Genome Biol</source>., <volume>10</volume>, <fpage>R25</fpage>.<pub-id pub-id-type="pmid">19261174</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lappalainen</surname><given-names>T.</given-names></name></person-group><etal/> (<year>2013</year>) 
<article-title>Transcriptome and genome sequencing uncovers functional variation in humans</article-title>. <source>Nature</source>, <volume>501</volume>, <fpage>506</fpage>–<lpage>511</lpage>.<pub-id pub-id-type="pmid">24037378</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>B.</given-names></name><name><surname>Dewey</surname><given-names>C. N.</given-names></name></person-group> (<year>2011</year>) 
<article-title>RSEM: accurate transcript quantification from RNA-seq data with or without a reference genome</article-title>. <source>BMC Bioinformatics</source>, <volume>12</volume>, <fpage>323.</fpage><pub-id pub-id-type="pmid">21816040</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H.</given-names></name><name><surname>Durbin</surname><given-names>R.</given-names></name></person-group> (<year>2009</year>) 
<article-title>Fast and accurate short read alignment with burrows–wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>25</volume>, <fpage>1754</fpage>–<lpage>1760</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H.</given-names></name></person-group><etal/> (<year>2008</year>) 
<article-title>Mapping short dna sequencing reads and calling variants using mapping quality scores</article-title>. <source>Genome Res</source>., <volume>18</volume>, <fpage>1851</fpage>–<lpage>1858</lpage>.<pub-id pub-id-type="pmid">18714091</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>B.</given-names></name></person-group><etal/> (<year>2010</year>) 
<article-title>RNA-seq gene expression estimation with read mapping uncertainty</article-title>. <source>Bioinformatics</source>, <volume>26</volume>, <fpage>493</fpage>–<lpage>500</lpage>.<pub-id pub-id-type="pmid">20022975</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B23">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H.</given-names></name></person-group> (<year>2013</year>). Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM.</mixed-citation>
    </ref>
    <ref id="btw277-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liao</surname><given-names>Y.</given-names></name></person-group><etal/> (<year>2013</year>) 
<article-title>The Subread aligner: fast, accurate and scalable read mapping by seed-and-vote</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>e108.</fpage><pub-id pub-id-type="pmid">23558742</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lovell</surname><given-names>D.</given-names></name></person-group><etal/> (<year>2015</year>) 
<article-title>Proportionality: a valid alternative to correlation for relative data</article-title>. <source>PLoS Comput. Biol</source>., <volume>11</volume>, <fpage>e1004075.</fpage><pub-id pub-id-type="pmid">25775355</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Manber</surname><given-names>U.</given-names></name><name><surname>Myers</surname><given-names>G.</given-names></name></person-group> (<year>1993</year>) 
<article-title>Suffix arrays: a new method for on-line string searches</article-title>. <source>SIAM J. Comput</source>., <volume>22</volume>, <fpage>935</fpage>–<lpage>948</lpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Marçais</surname><given-names>G.</given-names></name><name><surname>Kingsford</surname><given-names>C.</given-names></name></person-group> (<year>2011</year>) 
<article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>764</fpage>–<lpage>770</lpage>.<pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nariai</surname><given-names>N.</given-names></name></person-group><etal/> (<year>2013</year>) 
<article-title>Tigar: transcript isoform abundance estimation method with gapped alignment of RNA-Seq data by variational Bayesian inference</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>2292</fpage>–<lpage>2299</lpage>.<pub-id pub-id-type="pmid">23821651</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nariai</surname><given-names>N.</given-names></name></person-group><etal/> (<year>2014</year>) 
<article-title>Tigar2: sensitive and accurate estimation of transcript isoform expression with longer RNA-Seq reads</article-title>. <source>BMC Genomics</source>, <volume>15</volume>, <fpage>S5.</fpage><pub-id pub-id-type="pmid">25560536</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nicolae</surname><given-names>M.</given-names></name></person-group><etal/> (<year>2011</year>) 
<article-title>Estimation of alternative splicing isoform frequencies from rna-seq data</article-title>. <source>Algorithms Mol. Biol</source>., <volume>6</volume>, <fpage>9</fpage>.<pub-id pub-id-type="pmid">21504602</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nookaew</surname><given-names>I.</given-names></name></person-group><etal/> (<year>2012</year>) 
<article-title>A comprehensive comparison of RNA-Seq-based transcriptome analysis from reads to differential gene expression and cross-comparison with microarrays: a case study in saccharomyces cerevisiae</article-title>. <source>Nucleic Acids Res</source>., <volume>40</volume>, <fpage>10084</fpage>–<lpage>10097</lpage>.<pub-id pub-id-type="pmid">22965124</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Patro</surname><given-names>R.</given-names></name></person-group><etal/> (<year>2014</year>) 
<article-title>Sailfish enables alignment-free isoform quantification from RNA-Seq reads using lightweight algorithms</article-title>. <source>Nat. Biotechnol</source>., <volume>32</volume>, <fpage>462</fpage>–<lpage>464</lpage>.<pub-id pub-id-type="pmid">24752080</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Patro</surname><given-names>R.</given-names></name></person-group><etal/> (<year>2015</year>) 
<article-title>Salmon: accurate, versatile and ultrafast quantification from RNA-Seq data using lightweight-alignment</article-title>. <source>bioRxiv</source>, <volume>9</volume>, <fpage>021592</fpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Trapnell</surname><given-names>C.</given-names></name></person-group><etal/> (<year>2013</year>) 
<article-title>Differential analysis of gene regulation at transcript resolution with RNA-Seq</article-title>. <source>Nat. Biotechnol</source>., <volume>31</volume>, <fpage>46</fpage>–<lpage>53</lpage>.<pub-id pub-id-type="pmid">23222703</pub-id></mixed-citation>
    </ref>
    <ref id="btw277-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Van Dongen</surname><given-names>S.</given-names></name></person-group> (<year>2000</year>) 
<article-title>A cluster algorithm for graphs</article-title>. <source>Rep. Inf. Syst</source>., <volume>10</volume>, <fpage>1</fpage>–<lpage>40</lpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B36">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Vigna</surname><given-names>S.</given-names></name></person-group> (<year>2008</year>) <chapter-title>Broadword implementation of rank/select queries</chapter-title> In: <source>Experimental Algorithms</source>. 
<publisher-loc>Springer</publisher-loc>, 
<publisher-name>Berlin Heidelberg</publisher-name>, pp. <fpage>154</fpage>–<lpage>168</lpage>.</mixed-citation>
    </ref>
    <ref id="btw277-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>Z.</given-names></name><name><surname>Wang</surname><given-names>W.</given-names></name></person-group> (<year>2014</year>) 
<article-title>RNA-skim: a rapid method for RNA-Seq quantification at transcript level</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>i283</fpage>–<lpage>i292</lpage>.<pub-id pub-id-type="pmid">24931995</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
