<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-archivearticle1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3631255</article-id>
    <article-id pub-id-type="pmid">23620730</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-12-27979</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0061183</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Biology</subject>
        <subj-group>
          <subject>Genomics</subject>
          <subj-group>
            <subject>Genome Analysis Tools</subject>
            <subj-group>
              <subject>Genetic Networks</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Computer Science</subject>
        <subj-group>
          <subject>Algorithms</subject>
        </subj-group>
        <subj-group>
          <subject>Computing Methods</subject>
          <subj-group>
            <subject>Mathematical Computing</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Information Technology</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Mathematics</subject>
        <subj-group>
          <subject>Applied Mathematics</subject>
          <subj-group>
            <subject>Algorithms</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Discrete Mathematics</subject>
          <subj-group>
            <subject>Computational Systems</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Mathematical Computing</subject>
        </subj-group>
        <subj-group>
          <subject>Statistics</subject>
          <subj-group>
            <subject>Statistical Methods</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>The Index-Based Subgraph Matching Algorithm (ISMA): Fast Subgraph Enumeration in Large Networks Using Optimized Search Trees</article-title>
      <alt-title alt-title-type="running-head">The Index-Based Subgraph Matching Algorithm (ISMA)</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Demeyer</surname>
          <given-names>Sofie</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="cor1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Michoel</surname>
          <given-names>Tom</given-names>
        </name>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="aff3">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Fostier</surname>
          <given-names>Jan</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Audenaert</surname>
          <given-names>Pieter</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pickavet</surname>
          <given-names>Mario</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Demeester</surname>
          <given-names>Piet</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff1">
      <label>1</label>
      <addr-line>Department of Information Technology, Ghent University, Ghent, Belgium</addr-line>
    </aff>
    <aff id="aff2">
      <label>2</label>
      <addr-line>School of Life Sciences - LifeNet, Freiburg Institute of Advanced Studies, Freiburg, Germany</addr-line>
    </aff>
    <aff id="aff3">
      <label>3</label>
      <addr-line>Division of Genetics and Genomics, The Roslin Institute - University of Edinburgh, Midlothian, Scotland, United Kingdom</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Ravasi</surname>
          <given-names>Timothy</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>King Abdullah University of Science and Technology, Saudi Arabia</addr-line>
    </aff>
    <author-notes>
      <corresp id="cor1">* E-mail: <email>Sofie.Demeyer@intec.ugent.be</email></corresp>
      <fn fn-type="COI-statement">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <fn fn-type="con">
        <p>Conceived and designed the experiments: SD TM JF PA. Performed the experiments: SD. Analyzed the data: SD JF PA MP PD. Wrote the paper: SD TM JF MP PD.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>19</day>
      <month>4</month>
      <year>2013</year>
    </pub-date>
    <volume>8</volume>
    <issue>4</issue>
    <elocation-id>e61183</elocation-id>
    <history>
      <date date-type="received">
        <day>13</day>
        <month>9</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>5</day>
        <month>3</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Â© 2013 Demeyer et al</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Demeyer et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are properly credited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Subgraph matching algorithms are designed to find all instances of predefined subgraphs in a large graph or network and play an important role in the discovery and analysis of so-called network motifs, subgraph patterns which occur more often than expected by chance. We present the index-based subgraph matching algorithm (ISMA), a novel tree-based algorithm. ISMA realizes a speedup compared to existing algorithms by carefully selecting the order in which the nodes of a query subgraph are investigated. In order to achieve this, we developed a number of data structures and maximally exploited symmetry characteristics of the subgraph. We compared ISMA to a naive recursive tree-based algorithm and to a number of well-known subgraph matching algorithms. Our algorithm outperforms the other algorithms, especially on large networks and with large query subgraphs. An implementation of ISMA in Java is freely available at <ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/isma/">http://sourceforge.net/projects/isma/</ext-link>.</p>
    </abstract>
    <funding-group>
      <funding-statement>Funding from Ghent University and Freiburg Institute of Advanced Studies. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <page-count count="15"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>Introduction</title>
    <p>Over the last decade, network theory has come to play a central role in our understanding of complex systems in fields as diverse as molecular biology, sociology, economics, the internet, and others <xref rid="pone.0061183-Jasny1" ref-type="bibr">[1]</xref>. The central question in all these fields is to understand behavior at the level of the whole system from the topology of interactions between its individual constituents. In this respect, the existence of <italic>network motifs</italic>, small subgraph patterns which occur more often in a network than expected by chance, has turned out to be one of the defining properties of real-world complex networks, in particular biological networks <xref rid="pone.0061183-Milo1" ref-type="bibr">[2]</xref>. Network motifs act as the fundamental information processing units in cellular regulatory networks <xref rid="pone.0061183-Alon1" ref-type="bibr">[3]</xref> and they form the building blocks of larger functional modules (also known as network communities) <xref rid="pone.0061183-Kashtan1" ref-type="bibr">[4]</xref>â<xref rid="pone.0061183-Michoel1" ref-type="bibr">[6]</xref>. The discovery and analysis of network motifs crucially depends on the ability to enumerate all instances of a given query subgraph in a network or graph of interest, a classical problem in pattern recognition <xref rid="pone.0061183-Conte1" ref-type="bibr">[7]</xref>, that is known to be NP complete <xref rid="pone.0061183-Garey1" ref-type="bibr">[8]</xref>.</p>
    <p>Subgraph matching algorithms are usually classified as either exact algorithms, which require a strict correspondence between the query graph (i.e. the subgraph) and any match in the target graph, or inexact algorithms, where some deformation of the query graph is allowed when searching for a match <xref rid="pone.0061183-Conte1" ref-type="bibr">[7]</xref>. Here we are only concerned with exact algorithms. Some of the most well-known algorithms that realize this are the algorithm of Ullmann <xref rid="pone.0061183-Ullmann1" ref-type="bibr">[9]</xref>, the VF <xref rid="pone.0061183-Cordella1" ref-type="bibr">[10]</xref>, <xref rid="pone.0061183-Cordella2" ref-type="bibr">[11]</xref> and the VF2 algorithm <xref rid="pone.0061183-Cordella3" ref-type="bibr">[12]</xref>, <xref rid="pone.0061183-Cordella4" ref-type="bibr">[13]</xref>. The algorithm of Ullmann uses the adjacency matrix representation of the networks. A number of auxiliary matrices are defined to determine the set of subgraph isomorphisms iteratively. In the VF algorithms, on the other hand, the networks are represented by graphs. A state space representation is used in which each state depicts a (partial) mapping between nodes of both networks. The algorithm recursively builds a network of states by adding to the present states a pair of nodes that can be mapped on each other. After computing a set of candidate pairs, for each pair it is checked whether it meets the feasibility rules. Only then a new state is created. The difference between the VF and the VF2 algorithm is that the exploration of the search space has been improved in the VF2 algorithm to reduce memory requirements. This means that it is faster and can also be applied in larger graphs.</p>
    <p>Most of the other exact algorithms typically find subgraph isomorphisms in a database of graphs. To realize the subgraph matching efficiently, a preprocessing step on this database is introduced. Messmer and Bunke <xref rid="pone.0061183-Messmer1" ref-type="bibr">[14]</xref> proposed a method consisting of building a decision tree from the database of graphs by a form of indexing. This structure can then be used to find all subgraph instances. This preprocessing step has been further optimized by Weber et al. <xref rid="pone.0061183-Weber1" ref-type="bibr">[15]</xref>. Another algorithm, the GraphGrep algorithm <xref rid="pone.0061183-Giugno1" ref-type="bibr">[16]</xref>, uses hash-based fingerprinting to index the database of graphs. GIndex <xref rid="pone.0061183-Yan1" ref-type="bibr">[17]</xref> makes use of frequent substructures for its indexing. The GADDI algorithm <xref rid="pone.0061183-Zhang1" ref-type="bibr">[18]</xref> on the other hand deals with larger graphs and uses an indexing based on a neighborhood structure, similar to the TALE algorithm <xref rid="pone.0061183-Tian1" ref-type="bibr">[19]</xref>. Another way to deal with exact subgraph matching is to reformulate it as a constraint satisfaction problem and solving it with constraint programming, which is a good approach if there are other constraints that need to be taken into account as well <xref rid="pone.0061183-Larrosa1" ref-type="bibr">[20]</xref>, <xref rid="pone.0061183-Zampelli1" ref-type="bibr">[21]</xref>.</p>
    <p>Motivated by problems in biology, where it is necessary to find subgraph instances in graphs with certain characteristics on the links, which define the type of interaction between cellular components (e.g. protein-protein, protein-DNA or protein phosphorylation, etc.) <xref rid="pone.0061183-Michoel1" ref-type="bibr">[6]</xref>, <xref rid="pone.0061183-YegerLotem1" ref-type="bibr">[22]</xref>, <xref rid="pone.0061183-Yu1" ref-type="bibr">[23]</xref>, we developed a novel exact subgraph matching algorithm, which uses a search tree to find all instances of a query subgraph in an edge-colored graph without using an additional, usually time consuming, preprocessing step. The algorithms that resemble our algorithm most are the algorithm of Ullmann <xref rid="pone.0061183-Ullmann1" ref-type="bibr">[9]</xref>, the VF <xref rid="pone.0061183-Cordella1" ref-type="bibr">[10]</xref>, <xref rid="pone.0061183-Cordella2" ref-type="bibr">[11]</xref> and the VF2 algorithm <xref rid="pone.0061183-Cordella3" ref-type="bibr">[12]</xref>, <xref rid="pone.0061183-Cordella4" ref-type="bibr">[13]</xref>. Note that our problem differs from for example the SAGA algorithm <xref rid="pone.0061183-Tian2" ref-type="bibr">[24]</xref> in which the nodes instead of the edges contain certain characteristics.</p>
    <p>At the heart of our algorithm are custom designed data structures (for both the network and the algorithm) which provide, at each step in the subgraph matching procedure, rapid indexing of the candidate nodes for inclusion in a subgraph instance. By carefully selecting the order in which the motif nodes (denoted by an index) are investigated, these sets of candidate nodes are kept as small as possible. This allows to cut unfavorable branches in the search tree as soon as possible and leads to a dramatic speedup compared to existing algorithms. In this paper, we present a formal description of the Index-based Subgraph Matching Algorithm (ISMA), the data structures and how symmetries in the query subgraph are dealt with. This paper is organized as follows. After giving a general overview of the problem, together with the definitions of the concepts that are used in this article, a naive recursive algorithm is presented. The weaknesses of this algorithm are then identified and an improved recursive ISMA algorithm is proposed. As iterative algorithms may achieve a performance gain and require less stack space and function call overhead, an iterative version of the ISMA algorithm is presented, for which a number of custom data structures were designed. We also present comparisons to related subgraph matching algorithms using a variety of biological and non-biological networks.</p>
  </sec>
  <sec sec-type="methods" id="s2">
    <title>Methods</title>
    <sec id="s2a">
      <title>General description</title>
      <p>In biological networks, the same set of nodes (typically genes or proteins) can be connected in different ways, representing different physical interaction mechanisms, which may be directed or not <xref rid="pone.0061183-Zhu1" ref-type="bibr">[25]</xref>. In order to find matches for so-called composite motifs (subgraph patterns with more than one interaction type <xref rid="pone.0061183-YegerLotem1" ref-type="bibr">[22]</xref>, <xref rid="pone.0061183-Yu1" ref-type="bibr">[23]</xref>), the ISMA algorithm is designed to find all occurrences of a given query subgraph in graphs <inline-formula><inline-graphic xlink:href="pone.0061183.e001.jpg"/></inline-formula> with annotated edges. More precisely, <inline-formula><inline-graphic xlink:href="pone.0061183.e002.jpg"/></inline-formula> with <inline-formula><inline-graphic xlink:href="pone.0061183.e003.jpg"/></inline-formula> the set of vertices (or nodes) and <inline-formula><inline-graphic xlink:href="pone.0061183.e004.jpg"/></inline-formula> the set of edges (or links), where each link is represented by a triplet <inline-formula><inline-graphic xlink:href="pone.0061183.e005.jpg"/></inline-formula> with <inline-formula><inline-graphic xlink:href="pone.0061183.e006.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0061183.e007.jpg"/></inline-formula> the start and end node respectively, and <inline-formula><inline-graphic xlink:href="pone.0061183.e008.jpg"/></inline-formula> the type of the link. Hence, in contrast to ordinary graphs, the links now also have a type, which identifies a number of characteristics of the link such as whether it is directed or undirected. It should be noted that parallel links are allowed in <inline-formula><inline-graphic xlink:href="pone.0061183.e009.jpg"/></inline-formula> if and only if they are of a different type.</p>
      <p>A motif or query subgraph <inline-formula><inline-graphic xlink:href="pone.0061183.e010.jpg"/></inline-formula> is defined as follows. It is a small graph of <inline-formula><inline-graphic xlink:href="pone.0061183.e011.jpg"/></inline-formula> nodes with no (anti-)parallel links. This means that a motif has at most <inline-formula><inline-graphic xlink:href="pone.0061183.e012.jpg"/></inline-formula> links. The assumptions of no (anti-)parallel links is not a strict condition and the research presented here can easily be extended to motifs with (anti-)parallel links. There are four possible configurations between two nodes <inline-formula><inline-graphic xlink:href="pone.0061183.e013.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0061183.e014.jpg"/></inline-formula>: no link, a directed link from <inline-formula><inline-graphic xlink:href="pone.0061183.e015.jpg"/></inline-formula> to <inline-formula><inline-graphic xlink:href="pone.0061183.e016.jpg"/></inline-formula>, a directed link from <inline-formula><inline-graphic xlink:href="pone.0061183.e017.jpg"/></inline-formula> to <inline-formula><inline-graphic xlink:href="pone.0061183.e018.jpg"/></inline-formula>, or an undirected link between <inline-formula><inline-graphic xlink:href="pone.0061183.e019.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0061183.e020.jpg"/></inline-formula>. The motif nodes (<inline-formula><inline-graphic xlink:href="pone.0061183.e021.jpg"/></inline-formula>) are ordered and can hence be referred to by a unique index <inline-formula><inline-graphic xlink:href="pone.0061183.e022.jpg"/></inline-formula>. In the remainder of this article, this index will be used to refer to the motif nodes themselves. Motifs are specified by a list of K link types as follows:<disp-formula id="pone.0061183.e023"><graphic xlink:href="pone.0061183.e023.jpg" position="anchor" orientation="portrait"/></disp-formula>with <inline-formula><inline-graphic xlink:href="pone.0061183.e024.jpg"/></inline-formula> the link type between the <inline-formula><inline-graphic xlink:href="pone.0061183.e025.jpg"/></inline-formula>-th and the <inline-formula><inline-graphic xlink:href="pone.0061183.e026.jpg"/></inline-formula>-th node of the motif. It is defined that if no link exists between two nodes in a motif the corresponding link type is set to <inline-formula><inline-graphic xlink:href="pone.0061183.e027.jpg"/></inline-formula> (or â0â). This motif specification can easily be deduced from the adjacency matrix of the graph as indicated in <xref ref-type="fig" rid="pone-0061183-g001">figure 1</xref>.</p>
      <fig id="pone-0061183-g001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g001</object-id>
        <label>Figure 1</label>
        <caption>
          <title>The motif adjacency Matrix.</title>
          <p>In this article, motifs are denoted by a motif specification which can be deduced from its adjacency matrix as indicated by the red arrow.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g001"/>
      </fig>
      <p>Link types may be specified by upper case characters (A, B, etc.). In the case the links are directed, the reverse of a link can be represented by the corresponding lower case character. A number of examples of motifs and their specification are given in <xref ref-type="fig" rid="pone-0061183-g002">figure 2</xref>.</p>
      <fig id="pone-0061183-g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g002</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Examples of motifs and their specifications.</title>
          <p>Here nodes are denoted by their index. Look at for example the motif AAAB000B0A00BAA. Its motif specification can be deduced as follows: a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e028.jpg"/></inline-formula> from node 1 to node 2, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e029.jpg"/></inline-formula> from node 1 to node 3, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e030.jpg"/></inline-formula> from node 2 to node 3, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e031.jpg"/></inline-formula> from node 1 to node 4, no link between node 2 and node 4, no link between node 3 and node 4, no link between node 1 and node 5, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e032.jpg"/></inline-formula> from node 2 to node 5, no link between node 3 and node 5, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e033.jpg"/></inline-formula> from node 4 to node 5, no link between node 1 and node 6, no link between node 2 and node 6, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e034.jpg"/></inline-formula> from node 3 to node 6, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e035.jpg"/></inline-formula> from node 4 to node 6, a directed link of type <inline-formula><inline-graphic xlink:href="pone.0061183.e036.jpg"/></inline-formula> from node 5 to node 6.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g002"/>
      </fig>
    </sec>
    <sec id="s2b">
      <title>The naive recursive subgraph matching algorithm (RSMA)</title>
      <p>In this section, a naive recursive subgraph matching algorithm is described which is implemented in a motif clustering software tool (Cyclus 3D) <xref rid="pone.0061183-Audenaert1" ref-type="bibr">[26]</xref>. We describe this algorithm in detail here, as it will form the basis for the ISMA algorithm. It is a depth first tree search procedure in which the motif nodes are investigated in the order in which they are listed in the specification. This means that the algorithm will first map a network node on the first motif node, then on the second motif node, and so on.</p>
      <p>It should be noted that this algorithm resembles the VF2 algorithm. However, it is not completely similar. In the VF2 algorithms first a set of candidate pairs (i.e. a network node and a motif node on which this network node can be mapped) is calculated and subsequently this set is filtered according to the feasibility rules. One of these rules, for example, checks whether the links have the correct attributes (i.e. link types). By a careful design of the network data structure in the ISMA algorithm all candidate nodes are feasible nodes, which means that no additional checking operation is needed.</p>
      <p>The pseudocode of the recursive subgraph matching algorithm (RSMA) is given below. The algorithm (i.e. the function findMotifs) takes 3 input parameters: a motif specification mspec, the motif instance instance that tracks which network nodes have been mapped on the motif nodes, and the network <inline-formula><inline-graphic xlink:href="pone.0061183.e037.jpg"/></inline-formula>. In each recursive call, it is first checked whether the instance is complete, i.e. whether all motif nodes (mn) have network nodes (nn) mapped on them. If this is the case, the motif instance is exported. Otherwise, the next motif node (specified by its index) to be investigated is identified by the function next(). Here, next() returns the smallest index that has not been investigated yet. Subsequently, a set is determined of all network nodes that can be mapped on this motif node. This set contains all network nodes that are connected to the network nodes that were already mapped in the instance by links of the correct type (according to the motif specification). For the first motif node, this set simply consists of all nodes of the network <inline-formula><inline-graphic xlink:href="pone.0061183.e038.jpg"/></inline-formula>. One by one, the network nodes in this set are mapped onto the motif node, after which the findMotifs routine is called recursively. This way, all instances in <inline-formula><inline-graphic xlink:href="pone.0061183.e039.jpg"/></inline-formula> corresponding to the motif specification are enumerated.</p>
    </sec>
    <sec id="s2c">
      <title>Recursive subgraph matching algorithm</title>
      <p>1âfindMotifs(mspec, instance, Gt){</p>
      <p>2ââif(instance is complete){</p>
      <p>3âââexport(instance);</p>
      <p>4âââreturn;</p>
      <p>5ââ}</p>
      <p>6ââmnâ=ânext();</p>
      <p>7ââsetâ=âdetermineSet(instance, mn, Gt);</p>
      <p>8ââforall(nodes nn in set){</p>
      <p>9âââinstance.put(mn, nn);</p>
      <p>10âââfindMotifs(mspec, instance, Gt);</p>
      <p>11âââprevious();</p>
      <p>12âââinstance.remove(nn);</p>
      <p>13ââ}</p>
      <p>14â}</p>
      <p>15</p>
      <p>16âiâ=â0;</p>
      <p>17ânext(){</p>
      <p>18ââreturn i++;</p>
      <p>19â}</p>
      <p>20</p>
      <p>21âprevious(){</p>
      <p>22ââiâ;</p>
      <p>23â}</p>
      <p>24</p>
      <p>25âdetermineSet(instance, mn, Gt){</p>
      <p>26ââif(indexâ=ââ=â1){</p>
      <p>27âââreturn V;</p>
      <p>28ââ}else{</p>
      <p>29âââsetsâ=âEMPTY;</p>
      <p>30âââforall(nodes ni in instance){</p>
      <p>31ââââmotifIndexâ=âinstance.getIndex(ni);</p>
      <p>32ââââlinkTypeâ=âmspec.getLinkType(motifIndex, mn);</p>
      <p>33ââââsetâ=âni.getNeighborsofType(linkType);</p>
      <p>34ââââsets.add(set);</p>
      <p>35ââââ}</p>
      <p>36ââââreturn intersection(sets);</p>
      <p>37ââ}</p>
      <p>38â}</p>
      <p>The RMSA algorithm has some efficiency issues. When the set of candidate network nodes is determined for the first motif node, the complete set of network nodes is returned (line 22). It is possible that a lot of these network nodes don't even have the correct links (according to the motif specification) departing from them and thus are bad candidates to be mapped on the first motif node. This means that the search tree is very broad near the root. It would be better to narrow this down and determine a set of good candidate nodes by checking the types of the links that are departing from the network nodes and only select those nodes that have links of the same type as the links from the first motif node. Moreover, this set of candidate nodes can be further reduced by selecting another motif node to be investigated first. By changing the order in which the motif nodes are investigated (in the next()-function), the sets of candidate network nodes can be kept as small as possible. Smaller sets lead to less branches in the search tree and thus faster calculation times.</p>
    </sec>
    <sec id="s2d">
      <title>Operation of the ISMA algorithm: an example</title>
      <p>In this section, we will sketch the operation of the index-based subgraph matching algorithm by means of an example. In the three following sections, the algorithm is described in full detail.</p>
      <p>Suppose we want to find all occurrences of the motif ABC (with link types A and B directed, and link type C undirected) in the network depicted in <xref ref-type="fig" rid="pone-0061183-g003">figure 3</xref>. In the initialization phase, the best motif node to be investigated first is determined. As we want to narrow down the search tree, this should be the motif node with the least number of possible network nodes that can be mapped on it. These network nodes are the nodes that have the same types of outgoing links as the motif node. The set of possible network nodes for each motif node can then be determined by calculating the intersection of the sets of start network nodes of the corresponding link types. As calculating these intersections can be quite time-consuming, we opted to calculate the number of start nodes for each link type of the motif and select the motif node from which a link departs of the type with the lowest number of start nodes. This is shown in <xref ref-type="table" rid="pone-0061183-t001">table 1</xref>. In practice, these sets of network (start) nodes are retrieved in constant time since they are stored in the data structure of the network itself (see section on data structures). It should be noted that if some of the links are directed, the occurrences of the reverse links should also be taken into account. In our example, this means that the sets of starting network nodes from the link types a and b also need to be determined. The link type with the lowest cardinality of its corresponding set determines the first motif node, namely the motif node from which a link of this type departs.</p>
      <fig id="pone-0061183-g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g003</object-id>
        <label>Figure 3</label>
        <caption>
          <title>Example motif and network.</title>
          <p>The motif (left) which is searched for in the example network (right). Links of type A or B are directed; links of type C are undirected.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g003"/>
      </fig>
      <table-wrap id="pone-0061183-t001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.t001</object-id>
        <label>Table 1</label>
        <caption>
          <title>The initialization phase.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0061183-t001-1" xlink:href="pone.0061183.t001"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">link type</td>
                <td align="left" rowspan="1" colspan="1">{nn}</td>
                <td align="left" rowspan="1" colspan="1"># nn</td>
                <td align="left" rowspan="1" colspan="1">link type</td>
                <td align="left" rowspan="1" colspan="1">{nn}</td>
                <td align="left" rowspan="1" colspan="1"># nn</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">A</td>
                <td align="left" rowspan="1" colspan="1">{1,2,5}</td>
                <td align="left" rowspan="1" colspan="1">3</td>
                <td align="left" rowspan="1" colspan="1">a</td>
                <td align="left" rowspan="1" colspan="1">{1,5,6}</td>
                <td align="left" rowspan="1" colspan="1">3</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">B</td>
                <td align="left" rowspan="1" colspan="1">{1,2,4,5}</td>
                <td align="left" rowspan="1" colspan="1">4</td>
                <td align="left" rowspan="1" colspan="1">b</td>
                <td align="left" rowspan="1" colspan="1">{2,3,4}</td>
                <td align="left" rowspan="1" colspan="1">3</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">C</td>
                <td align="left" rowspan="1" colspan="1">{2,3,4,5,6}</td>
                <td align="left" rowspan="1" colspan="1">5</td>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1"/>
                <td align="left" rowspan="1" colspan="1"/>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt101">
            <label/>
            <p>For each link type the set of network nodes is depicted together with its cardinality.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>If there are multiple link types with the same cardinality, there are two possibilities: randomly picking one of these link types or actually calculating the sets of possible network nodes that can be mapped on the motif nodes. Here, we will apply the latter and calculate for the concerned motif nodes the intersection of the sets of starting network nodes of the links of which the types are specified in the motif. In our example, we encounter the same cardinality for the link types A, a and b, which correspond to motif nodes 1 (for A), 2 (for a) and 3 (for b). For the motif node 1, the set of possible network nodes is the intersection of the start sets of link type A ({1,2,5}) and link type B ({1,2,4,5}), thus set {1,2,5}. Similarly, for motif node 2 (link types a and C) and motif node 3 (link types b and C) this results in {5,6} and {2,3,4} respectively. From this we can conclude that motif node 2 is the best option to be investigated first as its set of candidate network nodes only has 2 elements, namely network nodes 5 and 6.</p>
      <p>We will map one of these nodes, network node 5, on motif node 2. Now it needs to be determined which of the 2 remaining motif nodes (1 or 3) is the best option to be investigated next. To do this, we determine the cardinality of the sets of network nodes that are neighbors of network node 5 according to the correct link types in order to be mapped on the specific motif nodes. For motif node 1 (connected to motif node 2 with link type a) this set of network nodes is {1,2}, while for motif node 3 (connected to motif node 2 with link type C) this set is {4}. As there is only one network node that can be mapped on motif node 3, we will consider this motif node to be investigated next.</p>
      <p>Network node 4 is mapped on motif node 3. Now, we need to determine which network nodes can be mapped on the last motif node, namely node 1. This is the intersection of the set of neighbors of network node 5 according to link type a ({1,2}) and the set of neighboring network nodes of node 4 according to link type b ({1}). This results in singleton {1}. We now have a complete instance that can be exported.</p>
      <p>As there are no other network nodes that can be mapped on motif node 1 (all nodes of the set {1} have been mapped), and no other network nodes can be mapped on motif node 3 (all nodes of the set {4} have been mapped), we will map the next network node on motif node 2, namely node 6 (from the set {5,6} determined at initialization). Again, it will be determined which of the remaining motif nodes (1 or 3) will be investigated first. For motif node 1, the set of possible network nodes (neighbors of network node 6 according to link type a) is {5}. For motif node 3 (connected to motif node 2 with link type C) this set is {2,3}. Now motif node 1 is the best option to be investigated first as there is only one network node that can be mapped on it. Network node 5 is mapped on motif node 1. To determine which network nodes can be mapped on the last motif node 3, the intersection is calculated between the set of neighbors of network node 6 according to link type C ({2,3}) and the set of neighbors of network node 5 according to link type B ({3}). This results in the singleton {3}. Network node 3 is mapped om motif node 3 and the complete instance can be exported.</p>
      <p>There are no more network nodes that can be mapped on motif node 3 (all nodes of the set {3} have been mapped), and no more network nodes that can be mapped on motif node 1 (all nodes of the set {5} have been mapped). Moreover, we iterated over all network nodes that can be mapped on motif node 2 (all nodes of the set {5,6} have been mapped). This means that the algorithm can terminate and has found all instances of the motif ABC in the network. Two motif instances have been found, one with the network nodes 1, 5 and 4 mapped on motif nodes 1, 2 and 3 respectively, and one with the network nodes 5, 6 and 3.</p>
      <p>Similar to the naive recursive algorithm, this algorithm is also a depth-first search algorithm. When <inline-formula><inline-graphic xlink:href="pone.0061183.e040.jpg"/></inline-formula> motif nodes have network nodes mapped on them, first all possibilities for the remaining <inline-formula><inline-graphic xlink:href="pone.0061183.e041.jpg"/></inline-formula> nodes (assuming the motif has <inline-formula><inline-graphic xlink:href="pone.0061183.e042.jpg"/></inline-formula> nodes) will be checked, before mapping the next network node on the <inline-formula><inline-graphic xlink:href="pone.0061183.e043.jpg"/></inline-formula>-th motif node. As mentioned before, in this algorithm motif nodes are not always investigated in the same order. In the above example, in both instances motif node 2 was investigated first, but for the first instance motif node 3 was the next to be investigated, while for the second instance this was motif node 1. By carefully selecting the order in which the motif nodes are investigated, the sets of network nodes that can be mapped on the motif nodes are kept as small as possible, reducing the number of branches in the search tree.</p>
      <p>The search trees of both the RSMA and the ISMA algorithm are depicted in <xref ref-type="fig" rid="pone-0061183-g004">figure 4</xref>. It can be seen that the ISMA algorithm indeed has a significantly smaller search tree, namely 6 nodes instead of 12.</p>
      <fig id="pone-0061183-g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g004</object-id>
        <label>Figure 4</label>
        <caption>
          <title>Search tree.</title>
          <p>The search tree of the ISMA algorithm (left) and the standard recursive algorithm (right) applied to the example network. A search tree indicates which network nodes have been mapped on the motif nodes.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g004"/>
      </fig>
    </sec>
    <sec id="s2e">
      <title>The recursive index-based subgraph matching algorithm</title>
      <p>Below, the pseudo code of the recursive index-based subgraph matching algorithm is presented. One can see that the main algorithm (i.e. the findMotifs-function) is similar to the one of the naive recursive algorithm. The determineSet-function only differs in the case in which no network nodes have been mapped on the motif nodes yet. Instead of returning the complete set of network nodes, now a set of good candidate network nodes for this motif node is returned. These are the networks nodes that have the same links (or more accurately link types) departing from them as the specific motif node.</p>
      <p>The next-function returns the best motif node to be investigated next. This is the motif node that has the smallest set of candidate network nodes, as this leads to a smaller search tree. In the case the motif instance is empty (i.e. no network nodes have been mapped on the motif nodes), we will determine for each link type the number of networks links of this type. The link type with the lowest cardinality determines the best motif node. As stated in the previous section, when multiple link types have the same cardinality (i.e. the boolean variable multiple is true), there are two options: randomly selecting one of these link types or calculating the sets of possible network nodes that can be mapped on the motif nodes. The code depicts the latter one. For each motif node the set of candidate network nodes is determined. These are the network nodes with the same outgoing link types as the motif node. The motif node with the smallest set of candidate nodes is the best option to be investigated first. In the case where some of the motif nodes have network nodes mapped on them, we will determine for each of the unmapped motif nodes the number of neighbors of the mapped network nodes that can be mapped on this motif node. The minimum number then determines which motif node will be investigated next. By always selecting the motif node with the smallest set of candidate network nodes, the number of branches in the search tree is kept as small as possible, leading to faster calculations.</p>
    </sec>
    <sec id="s2f">
      <title>Recursive ISMA algorithm</title>
      <p>1âfindMotifs(mspec, instance, Gt){</p>
      <p>2ââif(instance is complete){</p>
      <p>3âââexport(instance);</p>
      <p>4âââreturn;</p>
      <p>5ââ}</p>
      <p>6ââmnâ=ânext(instance, mspec);</p>
      <p>7ââsetâ=âdetermineSet(instance, mn, Gt, mspec);</p>
      <p>8ââforall(nodes nn in set){</p>
      <p>9âââinstance.put(mn, nn);</p>
      <p>10âââfindMotifs(mspec, instance, Gt);</p>
      <p>11âââinstance.remove(nn);</p>
      <p>12ââ}</p>
      <p>13â}</p>
      <p>14</p>
      <p>15ânext(instance, mspec){</p>
      <p>16ââminâ=âLARGE NUMBER;</p>
      <p>17ââif(instance is empty){</p>
      <p>18âââmultipleâ=âFALSE;</p>
      <p>19âââlinkTypesâ=âmspec.getLinkTypes();</p>
      <p>20âââforall(types t in linkTypes){</p>
      <p>21ââââ#NBSâ=â#fGt.getStartNodesofType(t)};</p>
      <p>22ââââif(#NBS&lt;min){</p>
      <p>23âââââminâ=â#NBS;</p>
      <p>24âââââiâ=ât.getStartNode();</p>
      <p>25âââââmultipleâ=âFALSE;</p>
      <p>26ââââ}else if(#NBSâ=ââ=âmin){</p>
      <p>27âââââmultipleâ=âTRUE;</p>
      <p>28ââââ}</p>
      <p>29âââ}</p>
      <p>30âââif(multiple){</p>
      <p>31ââââforall(motif nodes mn){</p>
      <p>32âââââ#NBSâ=â#fdetermineSet(instance, mn, <italic>Gt</italic>, mspec)};</p>
      <p>33âââââif(#NBS&lt;min){</p>
      <p>34ââââââminâ=â#NBS;</p>
      <p>35ââââââiâ=âmn;</p>
      <p>36âââââ}</p>
      <p>37ââââ}</p>
      <p>38âââ}</p>
      <p>39ââ}else{</p>
      <p>40âââforall(unmapped motif nodes mn){</p>
      <p>41ââââforall(mapped network nodes nn){</p>
      <p>42âââââ#NBSâ=ânumber of neighbors of nn that can be mapped on mn;</p>
      <p>43âââââif(#NBS&lt;min){</p>
      <p>44ââââââminâ=â#NBS;</p>
      <p>45ââââââiâ=âmn;</p>
      <p>46ââââââ}</p>
      <p>47ââââ}</p>
      <p>48âââ}</p>
      <p>49ââ}</p>
      <p>50ââreturn i;</p>
      <p>51â}</p>
      <p>52</p>
      <p>53âdetermineSet(instance, mn, Gt, mspec){</p>
      <p>54ââif(instance is empty){</p>
      <p>55âââlinkTypesâ=âmspec.getLinkTypesFrom(mn);</p>
      <p>56âââforall(types t in linkTypes){</p>
      <p>57ââââsetâ=âGt.getStartNodesofType(t);</p>
      <p>58ââââsets.add(set);</p>
      <p>59âââ}</p>
      <p>60âââreturn intersection(sets);</p>
      <p>61ââ}else{</p>
      <p>62âââsetsâ=âEMPTY;</p>
      <p>63âââforall(nodes ni in instance){</p>
      <p>64ââââmotifIndexâ=âinstance.getIndex(ni);</p>
      <p>65ââââlinkTypeâ=âmspec.getLinkType(motifIndex, mn);</p>
      <p>66ââââsetâ=âni.getNeighborsofType(linkType);</p>
      <p>67ââââsets.add(set);</p>
      <p>68âââ}</p>
      <p>69âââreturn intersection(sets);</p>
      <p>70ââ}</p>
      <p>71â}</p>
    </sec>
    <sec id="s2g">
      <title>Data structures</title>
      <p>As shown in the example and the recursive ISMA algorithm, the execution time of the recursive algorithm can be reduced by an intelligent choice of the order in which the nodes of a motif are investigated. This way, unfavorable branches of the search tree are pruned as soon as possible. Moreover, by an intelligent design of the network data structure an additional speedup can be realized for both the RSMA and the ISMA algorithm.</p>
      <p>This section starts with an overview of the optimizations to the network data structure which enable fast retrieval of the network nodes adjacent to links of a certain type. Subsequently, a number of data structures (see <xref ref-type="fig" rid="pone-0061183-g005">figure 5</xref>) are presented in order to realize an iterative version of the ISMA algorithm (which is more efficient and requires less stack space). The checklist keeps track of the order in which the motif nodes are investigated. A motif iterator is a collection of iterators that iterate over the possible network nodes for each of the motif nodes. The priority queue map is used in the algorithm to determine which of the motif nodes is the most lucrative to be investigated next. Investigating a motif node here means determining a set of network nodes that can be mapped on it, and adding each of these nodes to the instance one after the other.</p>
      <fig id="pone-0061183-g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g005</object-id>
        <label>Figure 5</label>
        <caption>
          <title>Data Structures.</title>
          <p>(a) The checklist. In the ISMA algorithm, the circles represent motif nodes (b) The motif iterator. (c) The priority queue map. (d) The priority object. It is assumed that the motif has k nodes.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g005"/>
      </fig>
      <p>To better understand the algorithm specific data structures, <xref ref-type="fig" rid="pone-0061183-g006">figure 6</xref> presents an example in which the possible content of the data structures is given for one instant during the execution of the algorithm.</p>
      <fig id="pone-0061183-g006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g006</object-id>
        <label>Figure 6</label>
        <caption>
          <title>Example of data structures.</title>
          <p>We are looking for a 4-node motif. In the motif instance (a) network node 9 is mapped on motif node 2 and network node 5 is mapped on motif node 4. These motif nodes were added (in the correct order) to the chosen list of the checklist (b), while the other two motif nodes (1 and 3) remain in the rest set. The motif iterator (c) contains two iterators that are of importance, namely the ones for the motif nodes of the chosen list. These iterate over the possible network nodes that can be mapped on the motif nodes. The priorityqueuemap (d) only contains valuable priority queues for the motif nodes 1 and 3. Each priority queue contains a priorityobject for each network node that is already mapped in the instance.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g006"/>
      </fig>
      <sec id="s2g1">
        <title>Optimizations to the network data structure</title>
        <p>The network data structure contains a network (i.e. graph). The main structure consists of a list of nodes. Each of these nodes has a list of neighbors, together with the links connecting them. The data structure has been optimized for two specific operations in the ISMA algorithm: the retrieval of the start nodes of all links of a specific type and the retrieval of all neighbors of a node that are connected to that node with a link of a specific type. This has been accomplished by 2 changes:</p>
        <list list-type="bullet">
          <list-item>
            <p>In the network structure a map is added with the link type as key and the set of the start nodes of all links of this link type as value. As the number of link types in a network is relatively small, finding the start nodes of all links of a specific type now only requires a small amount of execution time.</p>
            <p>However, this structure requires some additional memory. In a map, for each link type a set of reference to nodes (i.e. start nodes of links of this type) is stored. Assuming that the network has <inline-formula><inline-graphic xlink:href="pone.0061183.e044.jpg"/></inline-formula> links and that there are <inline-formula><inline-graphic xlink:href="pone.0061183.e045.jpg"/></inline-formula> link types, this means that the additional memory needed is equal to <inline-formula><inline-graphic xlink:href="pone.0061183.e046.jpg"/></inline-formula> references plus the memory overhead of one map and <inline-formula><inline-graphic xlink:href="pone.0061183.e047.jpg"/></inline-formula> sets.</p>
          </list-item>
          <list-item>
            <p>For every node a map is kept with the link types as keys and the sets of all neighbors according to this link types as values. This speeds up the operation of finding all neighbors that are connected with a link of a specific type.</p>
            <p>As in ânon-optimizedâ networks nodes also contain references to their neighbors, this structure only needs a small amount of additional memory, namely <inline-formula><inline-graphic xlink:href="pone.0061183.e048.jpg"/></inline-formula> references to the link types plus the memory overhead of one map and <inline-formula><inline-graphic xlink:href="pone.0061183.e049.jpg"/></inline-formula> sets.</p>
          </list-item>
        </list>
      </sec>
      <sec id="s2g2">
        <title>Checklist</title>
        <p>A checklist (CL) is a data structure that keeps track of the order in which elements (motif nodes) are chosen from a collection. It contains an ordered list of the chosen elements, together with the set of all elements that have not been chosen yet. It should be noted that in the recursive algorithm, this information is kept in the stack. The check list data structure is illustrated in <xref ref-type="fig" rid="pone-0061183-g005">figure 5a</xref>.</p>
        <p>In the example (see <xref ref-type="fig" rid="pone-0061183-g006">figure 6b</xref>) first motif node 2 was removed from the rest set and added to the chosen list. Subsequently motif node 4 was removed from the rest set and added to the chosen list. Two nodes (1 and 3) remain in the rest set.</p>
        <p>Following functions are defined on an checklist:</p>
        <list list-type="bullet">
          <list-item>
            <p>numberChecked(): returns the number of chosen elements</p>
          </list-item>
          <list-item>
            <p>lastChecked(): returns the last element that has been chosen</p>
          </list-item>
          <list-item>
            <p>check(element): removes element from the rest-set and adds it to the list of chosen elements</p>
          </list-item>
          <list-item>
            <p>uncheck(): removes the last element from the chosen-list and adds it to the rest-set</p>
          </list-item>
          <list-item>
            <p>checked(): returns the list of checked (i.e. chosen) elements</p>
          </list-item>
          <list-item>
            <p>rest(): returns the rest-set</p>
          </list-item>
        </list>
      </sec>
      <sec id="s2g3">
        <title>Motif iterator</title>
        <p>The motif iterator (MI) contains an iterator for each of the motif nodes that iterates over the possible network nodes that can be mapped on this motif node. Additionally, in order to know the order in which the motif nodes have been investigated, it contains a pointer to a checklist. When a motif node has not been investigated yet, the corresponding iterator is set to <inline-formula><inline-graphic xlink:href="pone.0061183.e050.jpg"/></inline-formula>. This data structure is depicted graphically in <xref ref-type="fig" rid="pone-0061183-g005">figure 5b</xref>.</p>
        <p>Whereas for the âfirstâ motif node the iterator stays the same during the complete execution of the algorithm, the iterators for the other motif nodes will change. Every time a motif node is determined as the best to be investigated next, a new iterator (that iterates over the set of possible network nodes that can be mapped on this motif node) is added to the motif iterator. The motif iterator will always first iterate over the set of nodes that can be mapped on the motif node that was last checked in the check list. Once it has iterated over all these network nodes, it will iterate further on the set of network nodes that can be mapped on the previous motif node according to the checklist. This explains the need of the checklist.</p>
        <p>In the example the motif iterator (<xref ref-type="fig" rid="pone-0061183-g006">figure 6c</xref>) has an iterator over the set (of network nodes) {2, 10, 9, 7} for motif node 2 and an iterator over the set {12, 5, 3} for motif node 4. The other iterators are of no importance at this stage in the algorithm. At this moment network node 9 is mapped on motif node 2, which means that network nodes 2 and 10 were already mapped on motif node 2. Similarly network node 5 is mapped on motif node 4 meaning that network node 12 was already mapped on this motif node. When the algorithm continues, after finding network nodes that can be mapped on motif nodes 1 and 3, network node 3 will be mapped on motif node 3. When this iterator finishes, it is removed from the motif iterator and the search continues by mapping network node 7 on motif node 2.</p>
        <p>Following functions are defined on an index iterator:</p>
        <list list-type="bullet">
          <list-item>
            <p>put(motifnode, iterator): adds the iterator to the corresponding motifnode</p>
          </list-item>
          <list-item>
            <p>hasNext(): returns a boolean value indicating if any of the iterators has a next element. It will first check the iterator of the checklist.lastChecked(). If it is empty, it will check the iterator of the previous motif node. And so on.</p>
          </list-item>
          <list-item>
            <p>next(): returns the next element of the index iterator. This is the next element of the current motif node in the index list</p>
          </list-item>
        </list>
      </sec>
      <sec id="s2g4">
        <title>Priorityqueuemap</title>
        <p>The priorityqueuemap (PQM) is an instrument to determine the best possible motif node to be investigated next. It contains a priority queue for each motif node. Moreover, in order to know which of the motif nodes have not been investigated yet, a pointer to the checklist object is kept. This data structure is illustrated in <xref ref-type="fig" rid="pone-0061183-g005">figure 5c</xref>. It is similar to the motif iterator, but the iterators are substituted by priority queues (PQ).</p>
        <p>In order to keep the search tree as small as possible, we want to select the (uninvestigated) motif node with the smallest set of possible network nodes that can be mapped on it. This set is the intersection of all the neighbor sets (a neighbor set is the set of all the network nodes that are connected to a mapped network node according to a specific link type) of nodes that can be mapped on this motif node. Since calculating this intersection can be time-consuming and the maximum cardinality of this intersection is the cardinality of the smallest of these neighbor sets, in the priority queues we will keep track of how many neighbors each mapped network node has according to the types of each of its outgoing links (according to the motif specification). By only taking into account the (cardinality of the) sets of neighbors of the mapped network nodes and not the intersection of these sets for one motif node, we do not produce the optimal (i.e. the smallest) search tree, but it is a good compromise between efficiency (calculating the intersection is time-consuming) and optimality.</p>
        <p>The objects that are stored in the priority queues were designed specifically for the ISMA algorithm. We opted to name them priority objects (PO) (see <xref ref-type="fig" rid="pone-0061183-g005">figure 5d</xref>). Priority objects consist of 4 fields: a network node, a motif start node, a motif end node and the number of neighbors of the network node according to the type of the link between the motif start node and end node. The network node is the node of the current instance that has been mapped on the motif start node. A priority object contains 2 motif nodes, a start and an end node, from which the link type can be deduced. It should be noted that for one priority queue all the âmotif end nodeâ fields are equal, and thus could be omitted. To determine the next best motif node, for each of the priority queues of the motif nodes that have not been chosen yet the minimum number of possible neighbors is retrieved. The overall minimum determines which motif node will be chosen next, as the maximum cardinality of the set of possible network nodes is minimal for this motif node.</p>
        <p>In the example (see <xref ref-type="fig" rid="pone-0061183-g006">figure 6d</xref>) priority objects are indicated by a list of 4 elements ([network node, motif start node, motif end node, number of neighbors]). Here only the priority queues of motif node 1 and 3 are of importance. Each priority queue contains 2 priority object, one for each of the mapped network nodes. Motif node 3 would be selected as the best motif node to be investigated next, since network node 5 has the least number of neighbors that can be mapped on it.</p>
        <p>The following functions are defined on a priorityqueuemap:</p>
        <list list-type="bullet">
          <list-item>
            <p>add(priorityqueueObject): adds the priorityqueueObject to the correct priority queue according to its motif end node</p>
          </list-item>
          <list-item>
            <p>poll(): removes and returns the overall best element (i.e. priority object) of the priority queues</p>
          </list-item>
        </list>
      </sec>
    </sec>
    <sec id="s2h">
      <title>The index-based subgraph matching algorithm (ISMA)</title>
      <p>As mentioned previously, the recursive ISMA algorithm outperforms the naive recursive algorithm by always selecting the motif node with the smallest set of possible network nodes that can be mapped on it. In this way, the number of branches in the search tree is minimized.</p>
      <p>Moreover, iterative algorithms can improve the performance and consume less stack space and function call overhead. In the previous section a number of data structures were presented in order to realize an iterative version of the ISMA algorithm. In this section the actual algorithm is discussed.</p>
      <p>The pseudo code of the iterative ISMA algorithm is given below.</p>
    </sec>
    <sec id="s2i">
      <title>Index-based Subgraph Matching Algorithm (ISMA)</title>
      <p>1âfindMotifs(mspec, Gt){</p>
      <p>2ââinstanceâ=âEMPTY INSTANCE;</p>
      <p>3ââmnâ=âdetermineFirstMotifNode();</p>
      <p>4ââCL.check(mn);</p>
      <p>5ââ{startsetgâ=âdetermineSet(instance, mn, Gt, mspec);</p>
      <p>6ââMI.put(mn, startset.iterator());</p>
      <p>7</p>
      <p>8ââwhile(MI.hasNext()){</p>
      <p>9ââânnâ=âMI.next();</p>
      <p>10âââbacktrack();</p>
      <p>11âââinstance.putNode(CL.lastChecked(), nn);</p>
      <p>12âââif(instance is complete){</p>
      <p>13ââââexport(instance);</p>
      <p>14ââââcontinue on line 8;</p>
      <p>15âââ}</p>
      <p>16âââforall(i in CL.rest()){</p>
      <p>17ââââPQM.add(new PO(nn, CL.lastChecked(), i, #NBS));</p>
      <p>18âââ}</p>
      <p>19âââmnâ=âPQM.poll().getEndNode();</p>
      <p>20âââCL.check(mn);</p>
      <p>21âââsetâ=âdetermineSet(instance, mn, Gt);</p>
      <p>22âââMI.put(mn, set.iterator());</p>
      <p>23ââ}</p>
      <p>24â}</p>
      <p>In the initialization phase (line 2â6) we will stipulate which of the motif nodes is best suited to be handled first (line 3). To determine this, for each link type present in the motif the number of occurrences in the network is counted. The start (motif) node of the link of the type with the least instances in the network is chosen to be the first motif node. If multiple motif nodes have an outgoing link of this type or multiple link types have the same number of instances, there are two options. One could randomly select one of these link types to determine the first motif node fast, but at the risk of creating a unnecessary branches in the search tree. The other option is to calculate the actual sets of candidate network nodes for these motif nodes by intersecting the sets for each of the link types departing from this motif node. Then the motif node with the smallest set of candidate network nodes is selected. This comes down to calculating the following intersection value (IV) for all motif nodes <inline-formula><inline-graphic xlink:href="pone.0061183.e051.jpg"/></inline-formula> from which links of the specific types depart:<disp-formula id="pone.0061183.e052"><graphic xlink:href="pone.0061183.e052.jpg" position="anchor" orientation="portrait"/></disp-formula>This is in fact the cardinality of the intersection (IS) of all sets of network start nodes of the links of the types that depart from <inline-formula><inline-graphic xlink:href="pone.0061183.e053.jpg"/></inline-formula>. For <inline-formula><inline-graphic xlink:href="pone.0061183.e054.jpg"/></inline-formula> all types of the links departing from it are determined. For each of these link types the set of starting nodes in the network is collected and the cardinality of the intersection of all these sets is calculated. The minimal value (for the different motif nodes) of this parameter then determines which motif node will be handled first. The determination of the first motif node is heuristic in the sense that we want to find a good first motif node as soon as possible, while we cannot guarantee that the search tree we build is indeed the smallest one possible. Once it is known which motif node is the first to be investigated, a start set of network nodes is calculated (line 5). It consists of all network nodes that can be mapped onto this motif node. It should be noted that the determineSet-function is identical to the one used in the recursive ISMA algorithm. The chosen motif node is checked in the checklist (line 4), and an iterator over the determined start set is added to the motif iterator (line 6).</p>
      <p>The main part of the algorithm executes the following as long as there are network nodes in the motif iterator (line 8). It retrieves the next network node from the motif iterator, and adds it to the instance on the position of the last checked motif node (line 9 and 11). If the instance is complete (i.e. all motif nodes have network nodes mapped on them), it is exported and the algorithm continues by retrieving the following network node from the motif iterator (line 12â15). If this is not the case, for all the motif nodes that have not been handled yet it is determined how many neighbors of this network node can be mapped on them and the results are added, in the form of a priority object, to the priorityqueuemap (line 16â18). Subsequently, the next best motif node is determined by retrieving the best priority object from the priorityqueuemap (line 19). This motif node is checked in the checklist, and an iterator over a set of network nodes is added to the motif iterator (line 20â22). This set is the result of the function determineSet that is identical to the one used in the recursive ISMA algorithm. For a complete description of this function we would like to refer to the section of the recursive algorithm.</p>
      <p>The algorithm terminates when there are no more network nodes left in the motif iterator. This means that there are no more network nodes that are good candidates to be mapped on the motif nodes. All motif instances have thus been found.</p>
      <p>It should be noted that, when the next motif node is retrieved from the motif iterator (line 9), the data structures are updated to allow backtracking. This is indicated by the backtrack-procedure (line 10). There are three possible situations. When a new iterator was added in the previous iteration, no updates are needed, and the algorithm can continue. If the motif iterator retrieves a motif node from the same iterator as in the previous iteration, both the motif instance and the priorityqueuemap need to be updated. The network node that was mapped in the previous iteration needs to be removed from the instance, so that a new network node can be mapped. Moreover, all priority objects that are associated with this previous network node need to be removed from the priorityqueuemap. If, on the other hand, the network node that is returned comes from an iterator that is associated with a motif node that was handled previously, all data structures are updated. In the checklist the motif nodes that have been investigated completely (i.e. the algorithm has iterated through all network nodes that can be mapped on them in the current situation) need to be unchecked. In the priorityqueuemap all priority objects that have these motif nodes as start node are removed. Moreover, all network nodes that are mapped on motif nodes of the rest-set of the checklist are removed from the instance, as well as the network node that is mapped on the current motif node (i.e. lastChecked()). The priority object associated with this last network node are also removed from the priorityqueumap.</p>
    </sec>
    <sec id="s2j">
      <title>Dealing with symmetry</title>
      <p>In this section it will be explained how the ISMA algorithm can be further optimized when dealing with symmetric motifs. A motif is called to be symmetric if it is identical to a motif from which the nodes are permutated in a certain way. The most common symmetries in motifs are reflections, rotations, translations and combinations of these three. By making use of the symmetry characteristics of a motif, the search tree of the (iterative) ISMA algorithm can be pruned further. Once a network node has been mapped on a motif node that takes part in a symmetric permutation, it should not be mapped again on the other nodes of this symmetry if this would lead to the same motif instance. In this paper, we will focus on two kind of symmetries, namely reflections (or mirror symmetry) and cyclic rotations, as these can easily be exploited to speed up the calculations. In the future, we plan to take into account all sorts of symmetries (like the algorithm of <xref rid="pone.0061183-Grochow1" ref-type="bibr">[27]</xref> does). At this time, for all other symmetries, duplicate instances will be eliminated once they have been found.</p>
      <p>A motif contains a reflection symmetry if and only if two or more nodes can be swapped without changing the motif's configuration. For example, the motif <inline-formula><inline-graphic xlink:href="pone.0061183.e055.jpg"/></inline-formula> in <xref ref-type="fig" rid="pone-0061183-g007">figure 7</xref> has a reflection symmetry between node 2 and node 3. A cyclic rotation symmetry is a symmetry in which nodes can be moved in circles. An example of a motif with this type of symmetry is <inline-formula><inline-graphic xlink:href="pone.0061183.e056.jpg"/></inline-formula> (<xref ref-type="fig" rid="pone-0061183-g007">figure 7</xref>) where the motif with nodes <inline-formula><inline-graphic xlink:href="pone.0061183.e057.jpg"/></inline-formula> is equal to the motif with nodes <inline-formula><inline-graphic xlink:href="pone.0061183.e058.jpg"/></inline-formula> and the one with nodes <inline-formula><inline-graphic xlink:href="pone.0061183.e059.jpg"/></inline-formula>.</p>
      <fig id="pone-0061183-g007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g007</object-id>
        <label>Figure 7</label>
        <caption>
          <title>Examples of reflection and cyclic rotation symmetries.</title>
          <p>The motif on the left has a reflection symmetry between nodes 2 and 3. The motif on the right has a cyclic rotation symmetry between the three nodes.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g007"/>
      </fig>
      <p>The idea behind âdealing with symmetryâ is that once we have mapped one network node on a motif node that is part of a symmetry, we do not want it mapped again on another motif node of the symmetry. Suppose that we have a reflection symmetry with <inline-formula><inline-graphic xlink:href="pone.0061183.e060.jpg"/></inline-formula> motif nodes and that there are <inline-formula><inline-graphic xlink:href="pone.0061183.e061.jpg"/></inline-formula> network nodes that can be mapped on them, then mapping the network nodes on these symmetric motif nodes comes down to choosing <inline-formula><inline-graphic xlink:href="pone.0061183.e062.jpg"/></inline-formula> distinct elements out of a set of <inline-formula><inline-graphic xlink:href="pone.0061183.e063.jpg"/></inline-formula> elements, not taking into account the order of the elements, which is in fact a combination of <inline-formula><inline-graphic xlink:href="pone.0061183.e064.jpg"/></inline-formula> elements out of a set of <inline-formula><inline-graphic xlink:href="pone.0061183.e065.jpg"/></inline-formula> elements. One way to enumerate all these combinations is by first summing up all sets with the first element, then all sets with the second element that have not been encountered yet, etc. This is illustrated in <xref ref-type="fig" rid="pone-0061183-g008">figure 8</xref>. From this, it can be seen that, once one network node is mapped on a symmetric motif node (in the figure the first motif node), it will never be mapped again on one of the other symmetric motif nodes that are investigated thereafter.</p>
      <fig id="pone-0061183-g008" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g008</object-id>
        <label>Figure 8</label>
        <caption>
          <title>Reflection symmetry.</title>
          <p>Enumeration of all possibilities to map 5 network nodes on 2 reflection symmetric motif nodes. The squares represent motif nodes, the circles represent network nodes. Once a network node has been mapped on a motif node that is part of a reflection symmetry, it will never be mapped on one of the other nodes of the symmetry.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g008"/>
      </fig>
      <p>For cyclic rotation symmetries this is slightly different. Here one motif node needs to be chosen as the âfirstâ node of the rotation and the idea is that once a network node is mapped on this âfirstâ node, it cannot be mapped on one of the other motif nodes in the symmetry, while a network node that is mapped on the âsecondâ (or higher) motif node still could be mapped on the other nodes of the symmetry. This is illustrated in <xref ref-type="fig" rid="pone-0061183-g009">figure 9</xref> where all possibilities are given to map 5 network nodes on 3 motif nodes that form a cyclic rotation. Once a network node has been mapped on the âfirstâ motif node of the rotation, it will not be mapped again on one of the other nodes in the rotation, while network nodes that are mapped on the âsecondâ motif node, still can be mapped on the âthirdâ motif node later on.</p>
      <fig id="pone-0061183-g009" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g009</object-id>
        <label>Figure 9</label>
        <caption>
          <title>Cyclic rotation symmetry.</title>
          <p>Enumeration of all possibilities to map 5 network nodes on 3 motif nodes that are part of a cyclic rotation. The squares represent motif nodes, the circles represent network nodes. Once a network node is mapped on the âfirstâ motif of the symmetry, it will never be mapped on the other nodes of the symmetry. For the other motif nodes of the symmetry, all possibilities still need to be explored.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g009"/>
      </fig>
      <p>In order to realize a speedup by making use of these symmetry characteristics, some changes were made to the motif data structure and the algorithm. Additional information is stored in the motif, namely for each motif node a list is kept of the motif nodes with which it is symmetric. In the case of reflection symmetry, for each node of the symmetry this list contains all other nodes of the symmetry. In the case of cyclic rotations for the motif node, that has been chosen as the âfirstâ node, this list contains all other symmetric nodes, while the lists of the other motif nodes only contain one element, namely the âfirstâ motif node. Next to these changes in the motif definition, a novel data structure, called symmetry sets, was developed. For each symmetric motif node it contains a set of all possible network nodes that have not been mapped on it yet. These sets are used to help determining the new set of candidate network nodes (line 21 of the ISMA algorithm). If the motif node is symmetric, the (symmetry) sets of all nodes that are symmetric to it (according to the symmetry structure that was added in the motif definition), are added to the set of sets in the determineSet procedure. As these sets only contain the network nodes that have not been mapped yet, they make sure that all network nodes that have been mapped on symmetric motif nodes are eliminated when calculating the intersection.</p>
      <p>In order to deal with symmetry (reflection or cyclic rotation) and further speed up the calculations, the ISMA algorithm is adapted in three ways:</p>
      <list list-type="bullet">
        <list-item>
          <p>Every time it is determined which motif node will be investigated next (line 19), it is checked whether this node is part of a symmetry with motif nodes that have not been investigated yet. If this is the case, the set of network nodes that can be mapped on this motif node is added to the symmetry sets data structure. This is realized by adding following code after line 21.</p>
          <p>21a if(mn.isSymmetric()){</p>
          <p>21bâsymmetrySets.put(mn, set);</p>
          <p>21c }</p>
        </list-item>
        <list-item>
          <p>Every time a network node is retrieved from the motif iterator (line 9), the symmetry sets are updated. This means that, if this network node is mapped on a symmetric motif node, this network node is removed from the set associated with this motif mode. In this way it will not be mapped on the other motif nodes of the symmetry. This is realized by adding following code after line 11.</p>
          <p>11a if(CL.lastChecked().isSymmetric()){</p>
          <p>11bâsymmetrySets.remove(CL.lastChecked(), nn);</p>
          <p>11c }</p>
        </list-item>
        <list-item>
          <p>When the determineSet procedure is called, it is checked whether the motif node (i.e. index) is symmetric to nodes that have been investigated before. If this is the case, the corresponding (symmetry) sets are retrieved from the symmetry sets data structure and added to the set of sets, from which the intersection is calculated (line 55 of the recursive ISMA algorithm). This is realized by adding following code after line 54 in the determineSet-procedure.</p>
          <p>54a forall(mn in CL.checked()){</p>
          <p>54bâif(mn.symmetricTo(motifnode)){</p>
          <p>54cââsets.add(symmetrySets.get(mn);</p>
          <p>54dâ}</p>
          <p>54e }</p>
        </list-item>
      </list>
      <p>As mentioned before, the above adaptations narrow down the search tree of the ISMA algorithm by making use of the characteristics of the reflection and the cyclic rotation symmetries. Besides this, for all other types of symmetry, every time a new instance has been found, it will be checked whether it is symmetric to a previously found instance. If this is the case, the instance will not be exported (line 13). In order to check this, all motifs that are symmetric to this motif (except for reflections and cyclic rotations) need to be identified. For a motif with <inline-formula><inline-graphic xlink:href="pone.0061183.e066.jpg"/></inline-formula> nodes, all symmetric motifs can be found by enumerating all permutations of the <inline-formula><inline-graphic xlink:href="pone.0061183.e067.jpg"/></inline-formula> motif nodes, connecting them according to the motif specification, and comparing this newly formed motif to the original one. From this list of symmetric motifs, the reflection and cyclic rotation symmetries are eliminated, as they are already accounted for in the algorithm. By mapping the motif nodes of an instance to all symmetric motifs, it can easily be checked whether the instance is symmetric to a previous one.</p>
      <p>In order to enumerate all permutations, a 17th century algorithm, called âplain changesâ by the English bell ringers, was used. In computer science, it is known as the Steinhaus-Johnson-Trotter algorithm <xref rid="pone.0061183-Steinhaus1" ref-type="bibr">[28]</xref>â<xref rid="pone.0061183-Trotter1" ref-type="bibr">[30]</xref>, and it has been improved by Even <xref rid="pone.0061183-Even1" ref-type="bibr">[31]</xref>. It is a powerful algorithm that generates an ordering of all permutations and is able to find all <inline-formula><inline-graphic xlink:href="pone.0061183.e068.jpg"/></inline-formula> permutations of <inline-formula><inline-graphic xlink:href="pone.0061183.e069.jpg"/></inline-formula> elements by swapping two adjacent elements <inline-formula><inline-graphic xlink:href="pone.0061183.e070.jpg"/></inline-formula> times. Due to the small differences between two consecutive permutations, this algorithm can be implemented in a constant time per permutation.</p>
    </sec>
  </sec>
  <sec id="s3">
    <title>Results and Discussion</title>
    <p>This section starts with a description of the software that incorporates the index-based subgraph matching algorithm. Subsequently, a number of results are presented that indicate the strength of the algorithm in comparison with other subgraph matching algorithms.</p>
    <sec id="s3a">
      <title>Software</title>
      <p>A software implementation of the iterative ISMA algorithm is freely available at <ext-link ext-link-type="uri" xlink:href="https://sourceforge.net/projects/isma/">https://sourceforge.net/projects/isma/</ext-link>. It is presented in the form of a Java .jar -file (ISMA.jar) and can be used from a command line interface as follows:</p>
      <p>java -jar â&lt;directory&gt;/ISMA.jarâ -folder â&lt;folder of input files&gt;â -linkfiles â&lt;list of &lt;typename u/d filename&gt; separated by spaces&gt;â -motif â&lt;motif&gt;â -output â&lt;reference to output file&gt;â</p>
      <p>The first two words indicate we want to execute a .jar-file. Subsequently, it is indicated where the .jar-file in question is situated. The program takes four arguments: folder, linkfiles, motif and output. The folder argument contains the directory where all input files are situated. It avoids retyping it for every inputfile. The linkfiles are the files that compose the network. Each linkfile contains all links for one specific type. It is denoted in the command by three arguments: the name of the link type (mostly an upper case character), a character indicating whether the links are directed (d) or undirected (u) and the name of the file. The different linkfiles are separated by spaces. The next argument is the motif. This is the motif specification as defined previously in this article. The last argument determines where the output should be stored.</p>
      <p>The input files contain all links of one type. These links are represented by the name of the start node and the name of the end node separated by a tab. Every line contains one link. Example input files can be found online. The output file has one line for every motif that has been exported. A motif is represented as follows: Motif [&lt;motifspecification&gt;]: [&lt;node 1&gt;, &lt;node 2&gt;, â¦].</p>
      <p>As the above notation is quite complicated, we will explain it in more detail by means of an example.</p>
      <p>java -jar âISMA/ISMA.jarâ -folder âISMA/input/â</p>
      <p>-linkfiles âA d linksAtype.txt B d linksBtype.txt C u linksCtype.txtâ -motif âABCâ</p>
      <p>-output âISMA/output/results.txtâ</p>
      <p>In this example ISMA.jar can be found in ISMA/. All input files are present in the folder ISMA/input/. The network contains links of three types: directed links of type A, directed links of type B and undirected links of type C. All these links can be found in the files linksAtype.txt, linksBtype.txt and linksCtype.txt respectively. The motif that is searched for is ABC, which is the motif we used in the example (see <xref ref-type="fig" rid="pone-0061183-g003">figure 3</xref>). The result of the ISMA algorithm (i.e. a list of all motifs found) is written to the file results.txt in the directory ISMA/output/.</p>
      <p>In the âFilesâ tab of this SourceForge project, all input (network) files that were used in the experiments are available. For a complete description of these networks, we would like to refer to the following section.</p>
    </sec>
    <sec id="s3b">
      <title>Results</title>
      <p>To demonstrate the strength of the ISMA algorithm, we compared it to the naive recursive subgraph matching algorithm (RSMA) as well as the algorithm of Ullmann <xref rid="pone.0061183-Ullmann1" ref-type="bibr">[9]</xref>, the VF algorithm <xref rid="pone.0061183-Cordella1" ref-type="bibr">[10]</xref>, <xref rid="pone.0061183-Cordella2" ref-type="bibr">[11]</xref> and the VF2 algorithm <xref rid="pone.0061183-Cordella3" ref-type="bibr">[12]</xref>, <xref rid="pone.0061183-Cordella4" ref-type="bibr">[13]</xref>, which are state-of-the-art subgraph matching algorithms. We used two networks with multiple edge types as test networks. The first is an integrated network of physical (P, undirected), genetic (G, undirected) and signaling (S, directed) interactions between kinases and phosphatases in yeast <xref rid="pone.0061183-Breitkreutz1" ref-type="bibr">[32]</xref>, <xref rid="pone.0061183-Fiedler1" ref-type="bibr">[33]</xref>, also used in <xref rid="pone.0061183-Audenaert1" ref-type="bibr">[26]</xref> (see left panel of <xref ref-type="table" rid="pone-0061183-t002">Table 2</xref> for basic network characteristics). The second consists of protein-protein interactions in yeast (X, undirected, obtained from the BioGRID <xref rid="pone.0061183-Stark1" ref-type="bibr">[34]</xref> database), protein-protein interactions in human (Y, undirected, obtained from the BioGRID <xref rid="pone.0061183-Stark1" ref-type="bibr">[34]</xref> and STRING <xref rid="pone.0061183-Jensen1" ref-type="bibr">[35]</xref> databases), and orthology relations between human and yeast proteins (Z, bipartite, from the InParanoid database <xref rid="pone.0061183-Berglund1" ref-type="bibr">[36]</xref>) (see right panel of <xref ref-type="table" rid="pone-0061183-t002">Table 2</xref> for basic network characteristics). Experiments were carried out on a 64-bit machine with a processor of the type Intel(R) Core(TM) 2 Duo CPU P8600, 2.40 GHz and 4 GB of RAM. Both the Recursive Subgraph Matching algorithm (RSMA) and the Index-based Subgraph Matching Algorithm (ISMA) were implemented in Java (version 1.6.0_18). The Ullmann, VF and VF2 algorithms are all present in the VFlibrary, a (sub)graph matching library implemented in C. These algorithms are known for finding subgraph isomorphisms in Attributed Relational Graphs (ARGs) fast, which is exactly what we are dealing with here.</p>
      <table-wrap id="pone-0061183-t002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.t002</object-id>
        <label>Table 2</label>
        <caption>
          <title>Network configurations of biological networks.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0061183-t002-2" xlink:href="pone.0061183.t002"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td colspan="2" align="left" rowspan="1">PGS network</td>
                <td colspan="2" align="left" rowspan="1">XYZ network</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1"># nodes</td>
                <td align="left" rowspan="1" colspan="1">1 255</td>
                <td align="left" rowspan="1" colspan="1"># nodes</td>
                <td align="left" rowspan="1" colspan="1">7 810</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"># S links</td>
                <td align="left" rowspan="1" colspan="1">667</td>
                <td align="left" rowspan="1" colspan="1"># X links</td>
                <td align="left" rowspan="1" colspan="1">36 391</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"># G links</td>
                <td align="left" rowspan="1" colspan="1">8 102</td>
                <td align="left" rowspan="1" colspan="1"># Y links</td>
                <td align="left" rowspan="1" colspan="1">40 630</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1"># P links</td>
                <td align="left" rowspan="1" colspan="1">3 688</td>
                <td align="left" rowspan="1" colspan="1"># Z links</td>
                <td align="left" rowspan="1" colspan="1">3 390</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>We first searched for a number of three-node motifs in the PGS-network, that are useful in the clustering algorithm of <xref rid="pone.0061183-Audenaert1" ref-type="bibr">[26]</xref>, and monitored the execution time for each of the algorithms. In <xref ref-type="table" rid="pone-0061183-t003">table 3</xref> an overview is given of these execution times (in milliseconds). Here, it can be seen that there is a major difference between the algorithms of the VFlibrary and the (naive) RSMA and (iterative) ISMA algorithm. Despite the fact that they are implemented in C, which is a language with less execution overhead, the VFlibrary algorithms are remarkably slower. One of the decisive reasons for this discrepancy is the way how the network is stored in memory. For the ISMA and RSMA algorithm, the network structure has been optimized for fast retrieval of all start nodes of a certain link type (see Data Structures section). Looking at the RSMA and the ISMA algorithm separately (<xref ref-type="fig" rid="pone-0061183-g010">figure 10</xref>), we see that the ISMA algorithm indeed has lower execution times than the RSMA algorithm.</p>
      <fig id="pone-0061183-g010" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g010</object-id>
        <label>Figure 10</label>
        <caption>
          <title>Execution times.</title>
          <p>Comparison of the execution times (in ms) of the RSMA and the ISMA algorithm for finding 3-node motifs in the PGS network.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g010"/>
      </fig>
      <table-wrap id="pone-0061183-t003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.t003</object-id>
        <label>Table 3</label>
        <caption>
          <title>The execution times (in milliseconds) for the different subgraph matching algorithms.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0061183-t003-3" xlink:href="pone.0061183.t003"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">motif</td>
                <td align="left" rowspan="1" colspan="1"># motifs</td>
                <td align="left" rowspan="1" colspan="1">Ullmann</td>
                <td align="left" rowspan="1" colspan="1">VF</td>
                <td align="left" rowspan="1" colspan="1">VF2</td>
                <td align="left" rowspan="1" colspan="1">RSMA</td>
                <td align="left" rowspan="1" colspan="1">ISMA</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">GGG</td>
                <td align="left" rowspan="1" colspan="1">9008</td>
                <td align="left" rowspan="1" colspan="1">3653.5</td>
                <td align="left" rowspan="1" colspan="1">4825.1</td>
                <td align="left" rowspan="1" colspan="1">3421.1</td>
                <td align="left" rowspan="1" colspan="1">181.0</td>
                <td align="left" rowspan="1" colspan="1">76.4</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SSS</td>
                <td align="left" rowspan="1" colspan="1">81</td>
                <td align="left" rowspan="1" colspan="1">851.0</td>
                <td align="left" rowspan="1" colspan="1">145.6</td>
                <td align="left" rowspan="1" colspan="1">80.4</td>
                <td align="left" rowspan="1" colspan="1">4.6</td>
                <td align="left" rowspan="1" colspan="1">0.9</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GPS</td>
                <td align="left" rowspan="1" colspan="1">47</td>
                <td align="left" rowspan="1" colspan="1">1142.0</td>
                <td align="left" rowspan="1" colspan="1">1061.9</td>
                <td align="left" rowspan="1" colspan="1">769.4</td>
                <td align="left" rowspan="1" colspan="1">12.8</td>
                <td align="left" rowspan="1" colspan="1">2.3</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SsS</td>
                <td align="left" rowspan="1" colspan="1">3</td>
                <td align="left" rowspan="1" colspan="1">815.2</td>
                <td align="left" rowspan="1" colspan="1">140.3</td>
                <td align="left" rowspan="1" colspan="1">76.7</td>
                <td align="left" rowspan="1" colspan="1">0.8</td>
                <td align="left" rowspan="1" colspan="1">0.8</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SSG</td>
                <td align="left" rowspan="1" colspan="1">103</td>
                <td align="left" rowspan="1" colspan="1">861.4</td>
                <td align="left" rowspan="1" colspan="1">155.7</td>
                <td align="left" rowspan="1" colspan="1">87.0</td>
                <td align="left" rowspan="1" colspan="1">4.9</td>
                <td align="left" rowspan="1" colspan="1">3.8</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SsG</td>
                <td align="left" rowspan="1" colspan="1">31</td>
                <td align="left" rowspan="1" colspan="1">838.4</td>
                <td align="left" rowspan="1" colspan="1">145.5</td>
                <td align="left" rowspan="1" colspan="1">83.0</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GGS</td>
                <td align="left" rowspan="1" colspan="1">312</td>
                <td align="left" rowspan="1" colspan="1">1659.8</td>
                <td align="left" rowspan="1" colspan="1">1167.6</td>
                <td align="left" rowspan="1" colspan="1">866.7</td>
                <td align="left" rowspan="1" colspan="1">106.0</td>
                <td align="left" rowspan="1" colspan="1">2.6</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GGP</td>
                <td align="left" rowspan="1" colspan="1">418</td>
                <td align="left" rowspan="1" colspan="1">1680.4</td>
                <td align="left" rowspan="1" colspan="1">1201.5</td>
                <td align="left" rowspan="1" colspan="1">898.7</td>
                <td align="left" rowspan="1" colspan="1">108.2</td>
                <td align="left" rowspan="1" colspan="1">7.3</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">ssG</td>
                <td align="left" rowspan="1" colspan="1">112</td>
                <td align="left" rowspan="1" colspan="1">868.2</td>
                <td align="left" rowspan="1" colspan="1">163.6</td>
                <td align="left" rowspan="1" colspan="1">94.5</td>
                <td align="left" rowspan="1" colspan="1">1.9</td>
                <td align="left" rowspan="1" colspan="1">1.9</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">8-clique</td>
                <td align="left" rowspan="1" colspan="1">226</td>
                <td align="left" rowspan="1" colspan="1">1 465 250</td>
                <td align="left" rowspan="1" colspan="1">4 826 735</td>
                <td align="left" rowspan="1" colspan="1">3 140 065</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e071.jpg"/></inline-formula>2 h</td>
                <td align="left" rowspan="1" colspan="1">954</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">10-clique</td>
                <td align="left" rowspan="1" colspan="1">1</td>
                <td align="left" rowspan="1" colspan="1">4 759 462</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e072.jpg"/></inline-formula>2 h</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e073.jpg"/></inline-formula>2 h</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e074.jpg"/></inline-formula>2 h</td>
                <td align="left" rowspan="1" colspan="1">1 009</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PGSPGS</td>
                <td align="left" rowspan="1" colspan="1">0</td>
                <td align="left" rowspan="1" colspan="1">1020.1</td>
                <td align="left" rowspan="1" colspan="1">251.3</td>
                <td align="left" rowspan="1" colspan="1">170.8</td>
                <td align="left" rowspan="1" colspan="1">83.9</td>
                <td align="left" rowspan="1" colspan="1">14.2</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">XZ00ZY</td>
                <td align="left" rowspan="1" colspan="1">2558</td>
                <td align="left" rowspan="1" colspan="1">535 657.0</td>
                <td align="left" rowspan="1" colspan="1">111 610.0</td>
                <td align="left" rowspan="1" colspan="1">42 514.0</td>
                <td align="left" rowspan="1" colspan="1">153.7</td>
                <td align="left" rowspan="1" colspan="1">93.9</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">XXXZ000Z0Y00ZYY</td>
                <td align="left" rowspan="1" colspan="1">4745</td>
                <td align="left" rowspan="1" colspan="1">1 828 683.0</td>
                <td align="left" rowspan="1" colspan="1">825 828.0</td>
                <td align="left" rowspan="1" colspan="1">182 734.0</td>
                <td align="left" rowspan="1" colspan="1">2354.6</td>
                <td align="left" rowspan="1" colspan="1">270.1</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">AAAZ000Z0B00ZBB</td>
                <td align="left" rowspan="1" colspan="1">840</td>
                <td align="left" rowspan="1" colspan="1">726 732.0</td>
                <td align="left" rowspan="1" colspan="1">166 608.0</td>
                <td align="left" rowspan="1" colspan="1">34 053.0</td>
                <td align="left" rowspan="1" colspan="1">595.2</td>
                <td align="left" rowspan="1" colspan="1">123.2</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt102">
            <label/>
            <p>It should be noted that the experiments were interrupted after 2 hours.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Subsequently, we looked for a number of larger motifs in this network. <xref ref-type="table" rid="pone-0061183-t003">Table 3</xref> shows the execution times of the algorithms when searching for all 8-cliques and 10-cliques (i.e. complete graphs of 8 and 10 nodes respectively). While for the ISMA algorithm, the execution times are around 1 second, they run up to more than two hours for the other algorithms. Here, the RSMA algorithm even performs worse that the algorithms of the VFlibrary. It should be noted that the difference between the ISMA algorithm and the other algorithms is most extreme for âcompleteâ motifs (i.e. cliques). However, for sparser motifs still significant speedups are realized, as will be shown in the experiments with the XYZ-network.</p>
      <p>Moreover, we looked for a motif that is not present in the PGS-network, viz the 4-node motif PGSPGS. Results are shown in <xref ref-type="table" rid="pone-0061183-t003">table 3</xref>. While the execution times are relatively low, the difference between the algorithms of the VFlibrary and the RSMA and ISMA algorithms is not as remarkable as in the previous cases.</p>
      <p>Next we searched in the XYZ-network for so-called <italic>interologs</italic>, 4-node subgraphs (with motif specification XZ00ZY) consisting of conserved protein-protein interactions between orthologous protein pairs in yeast and human <xref rid="pone.0061183-Yu2" ref-type="bibr">[37]</xref>. Generalizing this concept, we also searched for conserved triangles (6 nodes, motif specification XXXZ000Z0Y00ZYY). Despite of the fact that protein-protein interactions are undirected, in the experiments we also assumed the links to be directed. The directions were determined by the input files as the first and the second proteins were considered tails and heads respectively. In this directed network, we looked for the 6-node motif AAAZ000Z0B00ZBB. Here as well, we observe dramatic reduction in execution times for ISMA (and to a lesser extent RSMA) compared to the VF library algorithms, as these tend to be quite slow for larger motifs.</p>
      <p>In conclusion, by an intelligent design of the network data structure a remarkable speedup is realized for the RSMA and ISMA algorithm in comparison to the VFlibrary algorithms. Moreover, this speedup is increased even more by carefully selecting the order in which the motif nodes are investigated (i.e. ISMA vs. RSMA).</p>
      <p>To quantify the relative speedup realized by the ISMA algorithm, we defined the calculation time multiplicator (CTM) as<disp-formula id="pone.0061183.e075"><graphic xlink:href="pone.0061183.e075.jpg" position="anchor" orientation="portrait"/></disp-formula>For clarity reasons, in the remainder of this article we will use <inline-formula><inline-graphic xlink:href="pone.0061183.e076.jpg"/></inline-formula> in stead of <inline-formula><inline-graphic xlink:href="pone.0061183.e077.jpg"/></inline-formula>.</p>
      <p>These calculation time multiplicators are given in <xref ref-type="table" rid="pone-0061183-t004">table 4</xref>. It shows that the highest speedup factors are achieved for the motifs with an average number of occurrences. These figures show that the larger the motif, the larger the speedup that can be realized (XZ00ZY vs. XXXZ000Z0Y00ZYY) and that these speedups are higher when there are more occurrences in the network (XXXZ000Z0Y00ZYY vs. AAAZ000Z0B00ZBB). In conclusion, 2 factors contribute in reducing the calculation type: the network data structure that has been optimized for fast retrieval of all links of a certain type and the order in which the motif nodes are investigated in order to reduce the search tree. While the former one explains the difference between the VFlibrary algorithms and the RSMA and ISMA algorithm, the latter one causes the execution time of the ISMA algorithm to be smaller than that of the RSMA algorithm.</p>
      <table-wrap id="pone-0061183-t004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.t004</object-id>
        <label>Table 4</label>
        <caption>
          <title>The calculation time multiplicators (CTM) of the ISMA algorithm compared to other algorithms for a number of motif configurations.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0061183-t004-4" xlink:href="pone.0061183.t004"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">motif</td>
                <td align="left" rowspan="1" colspan="1"># motifs</td>
                <td align="left" rowspan="1" colspan="1">CTM(Ullmann)</td>
                <td align="left" rowspan="1" colspan="1">CTM(VF)</td>
                <td align="left" rowspan="1" colspan="1">CTM(VF2)</td>
                <td align="left" rowspan="1" colspan="1">CTM(RSMA)</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">GGG</td>
                <td align="left" rowspan="1" colspan="1">9008</td>
                <td align="left" rowspan="1" colspan="1">47.8</td>
                <td align="left" rowspan="1" colspan="1">63.1</td>
                <td align="left" rowspan="1" colspan="1">44.8</td>
                <td align="left" rowspan="1" colspan="1">2.4</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SSS</td>
                <td align="left" rowspan="1" colspan="1">81</td>
                <td align="left" rowspan="1" colspan="1">873.7</td>
                <td align="left" rowspan="1" colspan="1">149.5</td>
                <td align="left" rowspan="1" colspan="1">82.5</td>
                <td align="left" rowspan="1" colspan="1">4.8</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GPS</td>
                <td align="left" rowspan="1" colspan="1">47</td>
                <td align="left" rowspan="1" colspan="1">505.5</td>
                <td align="left" rowspan="1" colspan="1">470.1</td>
                <td align="left" rowspan="1" colspan="1">340.6</td>
                <td align="left" rowspan="1" colspan="1">5.7</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SsS</td>
                <td align="left" rowspan="1" colspan="1">3</td>
                <td align="left" rowspan="1" colspan="1">1000.2</td>
                <td align="left" rowspan="1" colspan="1">172.1</td>
                <td align="left" rowspan="1" colspan="1">94.1</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SSG</td>
                <td align="left" rowspan="1" colspan="1">103</td>
                <td align="left" rowspan="1" colspan="1">225.0</td>
                <td align="left" rowspan="1" colspan="1">40.7</td>
                <td align="left" rowspan="1" colspan="1">22.7</td>
                <td align="left" rowspan="1" colspan="1">1.3</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">SsG</td>
                <td align="left" rowspan="1" colspan="1">31</td>
                <td align="left" rowspan="1" colspan="1">831.7</td>
                <td align="left" rowspan="1" colspan="1">144.3</td>
                <td align="left" rowspan="1" colspan="1">82.3</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GGS</td>
                <td align="left" rowspan="1" colspan="1">312</td>
                <td align="left" rowspan="1" colspan="1">630.6</td>
                <td align="left" rowspan="1" colspan="1">443.6</td>
                <td align="left" rowspan="1" colspan="1">329.3</td>
                <td align="left" rowspan="1" colspan="1">40.3</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">GGP</td>
                <td align="left" rowspan="1" colspan="1">418</td>
                <td align="left" rowspan="1" colspan="1">231.2</td>
                <td align="left" rowspan="1" colspan="1">165.3</td>
                <td align="left" rowspan="1" colspan="1">123.6</td>
                <td align="left" rowspan="1" colspan="1">14.9</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">ssG</td>
                <td align="left" rowspan="1" colspan="1">112</td>
                <td align="left" rowspan="1" colspan="1">457.4</td>
                <td align="left" rowspan="1" colspan="1">86.2</td>
                <td align="left" rowspan="1" colspan="1">49.8</td>
                <td align="left" rowspan="1" colspan="1">1.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">8-clique</td>
                <td align="left" rowspan="1" colspan="1">226</td>
                <td align="left" rowspan="1" colspan="1">1 535.9</td>
                <td align="left" rowspan="1" colspan="1">5 059.5</td>
                <td align="left" rowspan="1" colspan="1">3 291.5</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e078.jpg"/></inline-formula>7 547.2</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">10-clique</td>
                <td align="left" rowspan="1" colspan="1">1</td>
                <td align="left" rowspan="1" colspan="1">4 717.0</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e079.jpg"/></inline-formula>7135.8</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e080.jpg"/></inline-formula>7 135.8</td>
                <td align="left" rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="pone.0061183.e081.jpg"/></inline-formula>7 135.8</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">PGSPGS</td>
                <td align="left" rowspan="1" colspan="1">0</td>
                <td align="left" rowspan="1" colspan="1">72.1</td>
                <td align="left" rowspan="1" colspan="1">17.8</td>
                <td align="left" rowspan="1" colspan="1">12.1</td>
                <td align="left" rowspan="1" colspan="1">5.9</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">XZ00ZY</td>
                <td align="left" rowspan="1" colspan="1">2558</td>
                <td align="left" rowspan="1" colspan="1">5704.5</td>
                <td align="left" rowspan="1" colspan="1">1188.6</td>
                <td align="left" rowspan="1" colspan="1">452.8</td>
                <td align="left" rowspan="1" colspan="1">1.7</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">XXXZ000Z0Y00ZYY</td>
                <td align="left" rowspan="1" colspan="1">4745</td>
                <td align="left" rowspan="1" colspan="1">6771.3</td>
                <td align="left" rowspan="1" colspan="1">3057.9</td>
                <td align="left" rowspan="1" colspan="1">676.6</td>
                <td align="left" rowspan="1" colspan="1">8.7</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">AAAZ000Z0B00ZBB</td>
                <td align="left" rowspan="1" colspan="1">840</td>
                <td align="left" rowspan="1" colspan="1">5900.3</td>
                <td align="left" rowspan="1" colspan="1">1352.7</td>
                <td align="left" rowspan="1" colspan="1">276.5</td>
                <td align="left" rowspan="1" colspan="1">4.8</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>As explained in the <xref ref-type="sec" rid="s2">Methods</xref> section, the ISMA algorithm achieves its speedup compared to the RSMA algorithm by reducing the size of the search tree. We counted the number of nodes in the search tree for both algorithms when searching for 3-node motifs in the PGS-network (see <xref ref-type="fig" rid="pone-0061183-g011">figure 11</xref>). On average, the search trees of the ISMA algorithm are around 100 times smaller than the corresponding search trees of the RSMA algorithm. It should be noted that the size of the search tree (and the execution time) is dependent on both the motif configuration and the network in which these motifs are searched for.</p>
      <fig id="pone-0061183-g011" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.g011</object-id>
        <label>Figure 11</label>
        <caption>
          <title>Size search tree.</title>
          <p>Comparison of the number of nodes in the search tree of the RSMA and the ISMA algorithm for finding 3-node motifs in the PGS network. The search tree reduction factor is defined as the size of the search tree of RSMA divided by the size of the search tree of ISMA.</p>
        </caption>
        <graphic xlink:href="pone.0061183.g011"/>
      </fig>
      <p>Although the development of the ISMA algorithm was motivated by the problem of identifying composite motifs in biological networks with multiple interaction types, or more generally Attributed Relational Graphs, it can of course be applied equally well to non-biological networks. We illustrate this by searching for all 3-node cliques in a number of networks from the SNAP database (<ext-link ext-link-type="uri" xlink:href="http://snap.stanford.edu/data/index.html">http://snap.stanford.edu/data/index.html</ext-link>), where we treated all networks as undirected. Assuming all link are of the type X, this means the motif XXX is searched. <xref ref-type="table" rid="pone-0061183-t005">Table 5</xref> shows the configurations of the networks that were used in the experiments, together with the number of 3-node cliques that were found in these networks. In <xref ref-type="table" rid="pone-0061183-t006">table 6</xref> the CTM's are given of the ISMA algorithm over the algorithms of the VFlibrary and over the recursive algorithm. Moreover, the search tree reduction factors (i.e. the number of nodes in the search tree of RSMA divided by the number of nodes in the search tree of ISMA) are depicted. This table shows that, similar to the experiments on biological networks, the execution times of the algorithm presented in this article are much lower that those of the algorithms of the VFlibrary. Again, this can be explained by the network data structure that allows fast retrieval of all links of a certain type. If we take into account the large numbers of (XXX) motifs that are present in these networks, the CTM's are relatively small in comparison to those in biological networks. This is also confirmed in the search tree reduction factors. Here the search tree reduction factors are on average around 20, which is small in comparison with the average search tree reduction factor of around 100 for the biological networks. The reason for this is that here, when determining the set of network nodes that can be mapped on a motif node, all neighbors of the mapped network nodes need to be taken into account in stead of only the neighbors according to one specific link type.</p>
      <table-wrap id="pone-0061183-t005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.t005</object-id>
        <label>Table 5</label>
        <caption>
          <title>Network configurations of the non-biological networks, together with the number of 3-node cliques present in these networks.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0061183-t005-5" xlink:href="pone.0061183.t005"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">network</td>
                <td align="left" rowspan="1" colspan="1"># nodes</td>
                <td align="left" rowspan="1" colspan="1"># links</td>
                <td align="left" rowspan="1" colspan="1"># motifs</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">Wiki-Vote</td>
                <td align="left" rowspan="1" colspan="1">7115</td>
                <td align="left" rowspan="1" colspan="1">103689</td>
                <td align="left" rowspan="1" colspan="1">608389</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">p2p-Gnutella08</td>
                <td align="left" rowspan="1" colspan="1">6301</td>
                <td align="left" rowspan="1" colspan="1">20777</td>
                <td align="left" rowspan="1" colspan="1">2383</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">p2p-Gnutella30</td>
                <td align="left" rowspan="1" colspan="1">36682</td>
                <td align="left" rowspan="1" colspan="1">88328</td>
                <td align="left" rowspan="1" colspan="1">1590</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">CA-CondMat</td>
                <td align="left" rowspan="1" colspan="1">23133</td>
                <td align="left" rowspan="1" colspan="1">186936</td>
                <td align="left" rowspan="1" colspan="1">173361</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">CA-HepTh</td>
                <td align="left" rowspan="1" colspan="1">9877</td>
                <td align="left" rowspan="1" colspan="1">51971</td>
                <td align="left" rowspan="1" colspan="1">28339</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <table-wrap id="pone-0061183-t006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0061183.t006</object-id>
        <label>Table 6</label>
        <caption>
          <title>The calculation time multiplicators (CTM) of the ISMA algorithm compared to other algorithms for a number of non-biological networks.</title>
        </caption>
        <alternatives>
          <graphic id="pone-0061183-t006-6" xlink:href="pone.0061183.t006"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" rowspan="1" colspan="1">network</td>
                <td align="left" rowspan="1" colspan="1">CTM(Ullmann)</td>
                <td align="left" rowspan="1" colspan="1">CTM(VF)</td>
                <td align="left" rowspan="1" colspan="1">CTM(VF2)</td>
                <td align="left" rowspan="1" colspan="1">CTM(RSMA)</td>
                <td align="left" rowspan="1" colspan="1">STRF</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" rowspan="1" colspan="1">Wiki-Vote</td>
                <td align="left" rowspan="1" colspan="1">126.8</td>
                <td align="left" rowspan="1" colspan="1">211.9</td>
                <td align="left" rowspan="1" colspan="1">142.8</td>
                <td align="left" rowspan="1" colspan="1">11.1</td>
                <td align="left" rowspan="1" colspan="1">41.2</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">p2p-Gnutella08</td>
                <td align="left" rowspan="1" colspan="1">131.9</td>
                <td align="left" rowspan="1" colspan="1">27.3</td>
                <td align="left" rowspan="1" colspan="1">12.9</td>
                <td align="left" rowspan="1" colspan="1">1.6</td>
                <td align="left" rowspan="1" colspan="1">26.5</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">p2p-Gnutella30</td>
                <td align="left" rowspan="1" colspan="1">706.4</td>
                <td align="left" rowspan="1" colspan="1">35.7</td>
                <td align="left" rowspan="1" colspan="1">6.4</td>
                <td align="left" rowspan="1" colspan="1">1.1</td>
                <td align="left" rowspan="1" colspan="1">17.7</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">CA-CondMat</td>
                <td align="left" rowspan="1" colspan="1">870.1</td>
                <td align="left" rowspan="1" colspan="1">565.2</td>
                <td align="left" rowspan="1" colspan="1">241.3</td>
                <td align="left" rowspan="1" colspan="1">2.3</td>
                <td align="left" rowspan="1" colspan="1">15.0</td>
              </tr>
              <tr>
                <td align="left" rowspan="1" colspan="1">CA-HepTh</td>
                <td align="left" rowspan="1" colspan="1">293.4</td>
                <td align="left" rowspan="1" colspan="1">195.0</td>
                <td align="left" rowspan="1" colspan="1">83.5</td>
                <td align="left" rowspan="1" colspan="1">1.5</td>
                <td align="left" rowspan="1" colspan="1">11.1</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="nt103">
            <label/>
            <p>The last column shows the search tree reduction factors (STRF), i.e. the ratio of the number of nodes in the search tree of the RSMA algorithm to the search tree of the ISMA algorithm.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec id="s3c">
      <title>Conclusion</title>
      <p>Motivated by problems in the analysis of biological networks composed of multiple directed and undirected interaction types, we have developed a novel exact subgraph matching algorithm that is optimized for graphs with specific link characteristics. By carefully selecting the order in which the nodes of a network motif are investigated and by designing appropriate data structures, a remarkable speedup can be realized. In each iteration of the algorithm, sets of network nodes are determined that can be mapped on the remaining motif nodes. Always selecting the motif node with the smallest corresponding set of network nodes leads to less branches closer to the root of the search tree and consequently a reduced search tree.</p>
      <p>In order to realize an iterative version of this algorithm, a number of data structures were developed: a checklist that keeps track of the order in which the motif nodes are investigated, a motif iterator to iterate over all the network nodes that can be mapped on a motif node, and a priorityqueuemap in order to select the best motif node to be investigated next.</p>
      <p>Incorporating motif symmetries can lead to further increases in computational efficiency. When present, ISMA explicitly takes into account two specific symmetries, namely the reflections and cyclic rotations, to further speed up the algorithm. For all other motif symmetries, duplicate instances are eliminated once they have been created. In future versions of ISMA, we plan to take into account additional types of symmetries to prune the search tree.</p>
      <p>Applications on real network data from the biological as well as non-biological domain, showed that the ISMA algorithm indeed leads to speedups compared to existing exact subgraph matching algorithms for attributed relational graphs. A comparison with a naive recursive tree-based subgraph matching algorithm shows that to a large extent, this speedup is indeed due to tree-pruning strategy implemented in ISMA, with search trees in ISMA being on average 100 times smaller than those of the recursive algorithm in our experiments on biological networks and on average 20 times smaller in our experiments on non-biological networks.</p>
      <p>Taken together, we believe ISMA is an interesting new exact subgraph matching algorithm which will be important for the discovery and analysis of small and large network motifs in ever growing biological networks, with potential applications in other domains as well.</p>
    </sec>
  </sec>
</body>
<back>
  <ref-list>
    <title>References</title>
    <ref id="pone.0061183-Jasny1">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Jasny</surname><given-names>B</given-names></name>, <name><surname>Zahn</surname><given-names>L</given-names></name>, <name><surname>Marshall</surname><given-names>E</given-names></name> (<year>2009</year>) <article-title>Connections</article-title>. <source>Science (New York, NY)</source>
<volume>325</volume>: <fpage>405</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Milo1">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Milo</surname><given-names>R</given-names></name>, <name><surname>Shen-Orr</surname><given-names>S</given-names></name>, <name><surname>Itzkovitz</surname><given-names>S</given-names></name>, <name><surname>Kashtan</surname><given-names>N</given-names></name>, <name><surname>Chklovskii</surname><given-names>D</given-names></name>, <etal>et al</etal> (<year>2002</year>) <article-title>Network motifs: simple building blocks of complex networks</article-title>. <source>Science</source>
<volume>298</volume>: <fpage>824</fpage>â<lpage>827</lpage>.<pub-id pub-id-type="pmid">12399590</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Alon1">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Alon</surname><given-names>U</given-names></name> (<year>2007</year>) <article-title>Network motifs: theory and experimental approaches</article-title>. <source>Nat Rev Genet</source>
<volume>8</volume>: <fpage>450</fpage>â<lpage>461</lpage>.<pub-id pub-id-type="pmid">17510665</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Kashtan1">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Kashtan</surname><given-names>N</given-names></name>, <name><surname>Itzkovitz</surname><given-names>S</given-names></name>, <name><surname>Milo</surname><given-names>R</given-names></name>, <name><surname>Alon</surname><given-names>U</given-names></name> (<year>2004</year>) <article-title>Topological generalizations of network motifs</article-title>. <source>Phys Rev E</source>
<volume>70</volume>: <fpage>031909</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Dobrin1">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Dobrin</surname><given-names>R</given-names></name>, <name><surname>Beg</surname><given-names>QK</given-names></name>, <name><surname>BarabÃ¡si</surname><given-names>AL</given-names></name>, <name><surname>Oltvai</surname><given-names>ZN</given-names></name> (<year>2004</year>) <article-title>Aggregation of topological motifs in the <italic>Es- cherichia coli</italic> transcription regulatory network</article-title>. <source>BMC Bioinformatics</source>
<volume>5</volume>: <fpage>10</fpage>.<pub-id pub-id-type="pmid">15018656</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Michoel1">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Michoel</surname><given-names>T</given-names></name>, <name><surname>Joshi</surname><given-names>A</given-names></name>, <name><surname>Nachtergaele</surname><given-names>B</given-names></name>, <name><surname>Van de Peer</surname><given-names>Y</given-names></name> (<year>2011</year>) <article-title>Enrichment and aggregation of topolog- ical network motifs are independent organizational principles of integrated interaction networks</article-title>. <source>Molecular BioSystems</source>
<volume>7</volume>: <fpage>2769</fpage>â<lpage>2778</lpage>.<pub-id pub-id-type="pmid">21860879</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Conte1">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Conte</surname><given-names>D</given-names></name>, <name><surname>Foggia</surname><given-names>P</given-names></name>, <name><surname>Sansone</surname><given-names>C</given-names></name>, <name><surname>Vento</surname><given-names>M</given-names></name> (<year>2004</year>) <article-title>Thirty years of graph matching in pattern recog- nition</article-title>. <source>IJPRAI</source>
<fpage>265</fpage>â<lpage>298</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Garey1">
      <label>8</label>
      <mixed-citation publication-type="book">Garey MR, Johnson DS (1990) Computers and Intractability: A Guide to the Theory of NP- Completeness. New York, NY, USA: W. H. Freeman &amp; Co., 338 pp.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Ullmann1">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Ullmann</surname><given-names>JR</given-names></name> (<year>1976</year>) <article-title>An algorithm for subgraph isomorphism</article-title>. <source>J ACM</source>
<volume>23</volume>: <fpage>31</fpage>â<lpage>42</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Cordella1">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Cordella</surname><given-names>L</given-names></name>, <name><surname>Foggia</surname><given-names>P</given-names></name>, <name><surname>Sansone</surname><given-names>C</given-names></name>, <name><surname>Tortorella</surname><given-names>F</given-names></name>, <name><surname>Vento</surname><given-names>M</given-names></name> (<year>1998</year>) <article-title>Graph matching: a fast algorithm and its evaluation</article-title>. <source>Proceedings of the 14th International Conference on Pattern Recognition</source>
<volume>2</volume>: <fpage>1582</fpage>â<lpage>1584</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Cordella2">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Cordella</surname><given-names>L</given-names></name>, <name><surname>Foggia</surname><given-names>P</given-names></name>, <name><surname>Sansone</surname><given-names>C</given-names></name>, <name><surname>Vento</surname><given-names>M</given-names></name> (<year>1999</year>) <article-title>Performance evaluation of the vf graph matching algorithm</article-title>. <source>Proceedings of the International Conference on Image Analysis and Processing</source>
<fpage>1172</fpage>â<lpage>1177</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Cordella3">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Cordella</surname><given-names>LP</given-names></name>, <name><surname>Foggia</surname><given-names>P</given-names></name>, <name><surname>Sansone</surname><given-names>C</given-names></name>, <name><surname>Vento</surname><given-names>M</given-names></name> (<year>2001</year>) <article-title>An improved algorithm for matching large graphs</article-title>. <source>3rd IAPR-TC15 Workshop on Graph-based Representations in Pattern Recognition, Cuen</source>
<fpage>149</fpage>â<lpage>159</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Cordella4">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Cordella</surname><given-names>L</given-names></name>, <name><surname>Foggia</surname><given-names>P</given-names></name>, <name><surname>Sansone</surname><given-names>C</given-names></name>, <name><surname>Vento</surname><given-names>M</given-names></name> (<year>2004</year>) <article-title>A (sub)graph isomorphism algorithm for matching large graphs</article-title>. <source>IEEE Transactions on Pattern Analysis and Machine Intelligence</source>
<volume>26</volume>: <fpage>1367</fpage>â<lpage>1372</lpage>.<pub-id pub-id-type="pmid">15641723</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Messmer1">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Messmer</surname><given-names>B</given-names></name>, <name><surname>Bunke</surname><given-names>H</given-names></name> (<year>1999</year>) <article-title>A decision tree approach to graph and subgraph isomorphism detec- tion</article-title>. <source>Pattern Recognition</source>
<volume>32</volume>: <fpage>1979</fpage>â<lpage>1998</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Weber1">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Weber</surname><given-names>M</given-names></name>, <name><surname>Liwicki</surname><given-names>M</given-names></name>, <name><surname>Dengel</surname><given-names>A</given-names></name> (<year>2012</year>) <article-title>Faster subgraph isomorphism detection by well-founded total order indexing</article-title>. <source>Pattern Recognition Letters</source>
<fpage>-</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Giugno1">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Giugno</surname><given-names>R</given-names></name>, <name><surname>Shasha</surname><given-names>D</given-names></name> (<year>2002</year>) <article-title>Graphgrep: A fast and universal method for querying graphs</article-title>. <source>Pro- ceedings of the 16th International Conference on Pattern Recognition</source>
<volume>2</volume>: <fpage>112</fpage>â<lpage>115</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Yan1">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Yan</surname><given-names>X</given-names></name>, <name><surname>Yu</surname><given-names>PS</given-names></name>, <name><surname>Han</surname><given-names>J</given-names></name> (<year>2004</year>) <article-title>Graph indexing: a frequent structure-based approach</article-title>. <source>Proceedings of the 2004 ACM SIGMOD</source>
<fpage>335</fpage>â<lpage>346</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Zhang1">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Zhang</surname><given-names>S</given-names></name>, <name><surname>Li</surname><given-names>S</given-names></name>, <name><surname>Yang</surname><given-names>J</given-names></name> (<year>2009</year>) <article-title>Gaddi: distance index based subgraph matching in biological net- works</article-title>. <source>Proceedings of the 12th International Conference on Extending Database Technology</source>
<fpage>192</fpage>â<lpage>203</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Tian1">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Tian</surname><given-names>Y</given-names></name>, <name><surname>Patel</surname><given-names>JM</given-names></name> (<year>2008</year>) <article-title>Tale: A tool for approximate large graph matching</article-title>. <source>Proceedings of the 2008 IEEE 24th International Conference on Data Engineering</source>
<fpage>963</fpage>â<lpage>972</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Larrosa1">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Larrosa</surname><given-names>J</given-names></name>, <name><surname>Valiente</surname><given-names>G</given-names></name> (<year>2002</year>) <article-title>Constraint satisfaction algorithms for graph pattern matching</article-title>. <source>Math- ematical Structures in Computer Science</source>
<volume>12</volume>: <fpage>403</fpage>â<lpage>422</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Zampelli1">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>Zampelli</surname><given-names>S</given-names></name>, <name><surname>Deville</surname><given-names>Y</given-names></name>, <name><surname>Solnon</surname><given-names>C</given-names></name> (<year>2010</year>) <article-title>Solving subgraph isomorphism problems with constraint programming</article-title>. <source>Journal of Constraints</source>
<volume>15</volume>: <fpage>327</fpage>â<lpage>353</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-YegerLotem1">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Yeger-Lotem</surname><given-names>E</given-names></name>, <name><surname>Sattath</surname><given-names>S</given-names></name>, <name><surname>Kashtan</surname><given-names>N</given-names></name>, <name><surname>Itzkovitz</surname><given-names>S</given-names></name>, <name><surname>Milo</surname><given-names>R</given-names></name>, <etal>et al</etal> (<year>2004</year>) <article-title>Network motifs in in- tegrated cellular networks of transcription-regulation and protein-protein interaction</article-title>. <source>PNAS</source>
<volume>101</volume>: <fpage>5934</fpage>â<lpage>5939</lpage>.<pub-id pub-id-type="pmid">15079056</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Yu1">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Yu</surname><given-names>H</given-names></name>, <name><surname>Xia</surname><given-names>Y</given-names></name>, <name><surname>Trifonov</surname><given-names>V</given-names></name>, <name><surname>Gerstein</surname><given-names>M</given-names></name> (<year>2006</year>) <article-title>Design principles of molecular networks revealed by global comparisons and composite motifs</article-title>. <source>Genome Biol</source>
<volume>7</volume>: <fpage>R55</fpage>.<pub-id pub-id-type="pmid">16859507</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Tian2">
      <label>24</label>
      <mixed-citation publication-type="journal"><name><surname>Tian</surname><given-names>Y</given-names></name>, <name><surname>McEachin</surname><given-names>RC</given-names></name>, <name><surname>Santos</surname><given-names>C</given-names></name>, <name><surname>States</surname><given-names>DJ</given-names></name>, <name><surname>Patel</surname><given-names>JM</given-names></name> (<year>2007</year>) <article-title>Saga: a subgraph matching tool for biological graphs</article-title>. <source>Bioinformatics</source>
<volume>23</volume>: <fpage>232</fpage>â<lpage>239</lpage>.<pub-id pub-id-type="pmid">17110368</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Zhu1">
      <label>25</label>
      <mixed-citation publication-type="journal"><name><surname>Zhu</surname><given-names>X</given-names></name>, <name><surname>Gerstein</surname><given-names>M</given-names></name>, <name><surname>Snyder</surname><given-names>M</given-names></name> (<year>2007</year>) <article-title>Getting connected: analysis and principles of biological networks</article-title>. <source>Genes &amp; development</source>
<volume>21</volume>: <fpage>1010</fpage>â<lpage>1024</lpage>.<pub-id pub-id-type="pmid">17473168</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Audenaert1">
      <label>26</label>
      <mixed-citation publication-type="journal"><name><surname>Audenaert</surname><given-names>P</given-names></name>, <name><surname>Van Parys</surname><given-names>T</given-names></name>, <name><surname>Brondel</surname><given-names>F</given-names></name>, <name><surname>Pickavet</surname><given-names>M</given-names></name>, <name><surname>Demeester</surname><given-names>P</given-names></name>, <etal>et al</etal> (<year>2011</year>) <article-title>Cyclus3d: a cytoscape plugin for clustering network motifs in integrated networks</article-title>. <source>Bioinformatics</source>
<volume>27</volume>: <fpage>1587</fpage>â<lpage>1588</lpage>.<pub-id pub-id-type="pmid">21478195</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Grochow1">
      <label>27</label>
      <mixed-citation publication-type="journal"><name><surname>Grochow</surname><given-names>J</given-names></name>, <name><surname>Kellis</surname><given-names>M</given-names></name> (<year>2007</year>) <article-title>Network motif discovery using subgraph enumeration and symmetry- breaking</article-title>. <source>Research in Computational Molecular Biology</source>
<fpage>92</fpage>â<lpage>106</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Steinhaus1">
      <label>28</label>
      <mixed-citation publication-type="book">Steinhaus H (1963) One hundred problems in elementary mathematics. Pergamon Press, Oxford, Eng., 174 pp.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Johnson1">
      <label>29</label>
      <mixed-citation publication-type="journal"><name><surname>Johnson</surname><given-names>SM</given-names></name> (<year>1963</year>) <article-title>Generation of permutations by adjacent transposition</article-title>. <source>Mathematics of Com- putation</source>
<volume>17</volume>: <fpage>282</fpage>â<lpage>285</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Trotter1">
      <label>30</label>
      <mixed-citation publication-type="journal"><name><surname>Trotter</surname><given-names>HF</given-names></name> (<year>1962</year>) <article-title>Algorithm 115: Perm</article-title>. <source>Commun ACM</source>
<volume>5</volume>: <fpage>434</fpage>â<lpage>435</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Even1">
      <label>31</label>
      <mixed-citation publication-type="book">Even S (1973) Algorithmic combinatorics. Macmillan, 260 pp.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Breitkreutz1">
      <label>32</label>
      <mixed-citation publication-type="journal"><name><surname>Breitkreutz</surname><given-names>A</given-names></name>, <name><surname>Choi</surname><given-names>H</given-names></name>, <name><surname>Sharom</surname><given-names>JR</given-names></name>, <name><surname>Boucher</surname><given-names>L</given-names></name>, <name><surname>Neduva</surname><given-names>V</given-names></name>, <etal>et al</etal> (<year>2010</year>) <article-title>A global protein kinase and phosphatase interaction network in yeast</article-title>. <source>Science</source>
<volume>328</volume>: <fpage>1043</fpage>â<lpage>1046</lpage>.<pub-id pub-id-type="pmid">20489023</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Fiedler1">
      <label>33</label>
      <mixed-citation publication-type="journal"><name><surname>Fiedler</surname><given-names>D</given-names></name>, <name><surname>Braberg</surname><given-names>H</given-names></name>, <name><surname>Mehta</surname><given-names>M</given-names></name>, <name><surname>Chechik</surname><given-names>G</given-names></name>, <name><surname>Cagney</surname><given-names>G</given-names></name>, <etal>et al</etal> (<year>2009</year>) <article-title>Functional organization of the S. cerevisiae phosphorylation network</article-title>. <source>Cell</source>
<volume>136</volume>: <fpage>952</fpage>â<lpage>963</lpage>.<pub-id pub-id-type="pmid">19269370</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Stark1">
      <label>34</label>
      <mixed-citation publication-type="journal"><name><surname>Stark</surname><given-names>C</given-names></name>, <name><surname>Breitkreutz</surname><given-names>BJ</given-names></name>, <name><surname>Reguly</surname><given-names>T</given-names></name>, <name><surname>Boucher</surname><given-names>L</given-names></name>, <name><surname>Breitkreutz</surname><given-names>A</given-names></name>, <etal>et al</etal> (<year>2006</year>) <article-title>BioGRID: a general repository for interaction datasets</article-title>. <source>Nucl Acids Res</source>
<volume>34</volume>: <fpage>535</fpage>â<lpage>539</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Jensen1">
      <label>35</label>
      <mixed-citation publication-type="journal"><name><surname>Jensen</surname><given-names>L</given-names></name>, <name><surname>Kuhn</surname><given-names>M</given-names></name>, <name><surname>Stark</surname><given-names>M</given-names></name>, <name><surname>Chaffron</surname><given-names>S</given-names></name>, <name><surname>Creevey</surname><given-names>C</given-names></name>, <etal>et al</etal> (<year>2009</year>) <article-title>String 8 â a global view on proteins and their functional interactions in 630 organisms</article-title>. <source>Nucl Acids Res</source>
<volume>37</volume>: <fpage>412</fpage>â<lpage>416</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0061183-Berglund1">
      <label>36</label>
      <mixed-citation publication-type="journal"><name><surname>Berglund</surname><given-names>AC</given-names></name>, <name><surname>Sjolund</surname><given-names>E</given-names></name>, <name><surname>Ostlund</surname><given-names>G</given-names></name>, <name><surname>Sonnhammer</surname><given-names>ELL</given-names></name> (<year>2008</year>) <article-title>InParanoid 6: eukaryotic ortholog clusters with inparalogs</article-title>. <source>Nucl Acids Res</source>
<volume>36</volume>: <fpage>263</fpage>â<lpage>266</lpage>.<pub-id pub-id-type="pmid">18025037</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0061183-Yu2">
      <label>37</label>
      <mixed-citation publication-type="journal"><name><surname>Yu</surname><given-names>H</given-names></name>, <name><surname>Luscombe</surname><given-names>N</given-names></name>, <name><surname>Lu</surname><given-names>H</given-names></name>, <name><surname>Zhu</surname><given-names>X</given-names></name>, <name><surname>Xia</surname><given-names>Y</given-names></name>, <etal>et al</etal> (<year>2004</year>) <article-title>Annotation transfer between genomes: proteinâprotein interologs and proteinâdna regulogs</article-title>. <source>Genome Res</source>
<volume>14</volume>: <fpage>1107</fpage>â<lpage>1118</lpage>.<pub-id pub-id-type="pmid">15173116</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
