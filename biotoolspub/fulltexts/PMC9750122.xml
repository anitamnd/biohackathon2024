<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9750122</article-id>
    <article-id pub-id-type="pmid">36308467</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btac708</article-id>
    <article-id pub-id-type="publisher-id">btac708</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>HaploDMF: viral haplotype reconstruction from long reads via deep matrix factorization</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-8148-4574</contrib-id>
        <name>
          <surname>Cai</surname>
          <given-names>Dehan</given-names>
        </name>
        <aff><institution>Department of Electrical Engineering, City University of Hong Kong</institution>, Kowloon, Hong Kong SAR, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-5974-4985</contrib-id>
        <name>
          <surname>Shang</surname>
          <given-names>Jiayu</given-names>
        </name>
        <aff><institution>Department of Electrical Engineering, City University of Hong Kong</institution>, Kowloon, Hong Kong SAR, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1373-8023</contrib-id>
        <name>
          <surname>Sun</surname>
          <given-names>Yanni</given-names>
        </name>
        <xref rid="btac708-cor1" ref-type="corresp"/>
        <!--yannisun@cityu.edu.hk-->
        <aff><institution>Department of Electrical Engineering, City University of Hong Kong</institution>, Kowloon, Hong Kong SAR, <country country="CN">China</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Martelli</surname>
          <given-names>Pier Luigi</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btac708-cor1">To whom correspondence should be addressed. Email: <email>yannisun@cityu.edu.hk</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>12</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2022-10-29">
      <day>29</day>
      <month>10</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>29</day>
      <month>10</month>
      <year>2022</year>
    </pub-date>
    <volume>38</volume>
    <issue>24</issue>
    <fpage>5360</fpage>
    <lpage>5367</lpage>
    <history>
      <date date-type="received">
        <day>20</day>
        <month>7</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>06</day>
        <month>10</month>
        <year>2022</year>
      </date>
      <date date-type="editorial-decision">
        <day>21</day>
        <month>10</month>
        <year>2022</year>
      </date>
      <date date-type="accepted">
        <day>25</day>
        <month>10</month>
        <year>2022</year>
      </date>
      <date date-type="corrected-typeset">
        <day>07</day>
        <month>11</month>
        <year>2022</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2022. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btac708.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Lacking strict proofreading mechanisms, many RNA viruses can generate progeny with slightly changed genomes. Being able to characterize highly similar genomes (i.e. haplotypes) in one virus population helps study the viruses’ evolution and their interactions with the host/other microbes. High-throughput sequencing data has become the major source for characterizing viral populations. However, the inherent limitation on read length by next-generation sequencing makes complete haplotype reconstruction difficult.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this work, we present a new tool named HaploDMF that can construct complete haplotypes using third-generation sequencing (TGS) data. HaploDMF utilizes a deep matrix factorization model with an adapted loss function to learn latent features from aligned reads automatically. The latent features are then used to cluster reads of the same haplotype. Unlike existing tools whose performance can be affected by the overlap size between reads, HaploDMF is able to achieve highly robust performance on data with different coverage, haplotype number and error rates. In particular, it can generate more complete haplotypes even when the sequencing coverage drops in the middle. We benchmark HaploDMF against the state-of-the-art tools on simulated and real sequencing TGS data on different viruses. The results show that HaploDMF competes favorably against all others.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The source code and the documentation of HaploDMF are available at <ext-link xlink:href="https://github.com/dhcai21/HaploDMF" ext-link-type="uri">https://github.com/dhcai21/HaploDMF</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Hong Kong Research Grants Council</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>General Research Fund</institution>
          </institution-wrap>
        </funding-source>
        <award-id>11217521</award-id>
        <award-id>11206819</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>City University of Hong Kong</institution>
            <institution-id institution-id-type="DOI">10.13039/100007567</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>9678241</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>RNA viruses are pathogens in many infectious diseases. Notable examples include acquired immunodeficiency syndrome (AIDS), severe acute respiratory syndrome (SARS), influenza, coronavirus disease-2019 (COVID-19), etc. Lacking strict proofreading mechanism during replication, many RNA viruses generate progeny with slightly different genomes (haploytpes). Although many haplotypes possess the same biological properties, some of them can exhibit undesirable properties like resistance to drugs and high transmissibility. For instance, it is estimated that the divergence of the surface proteins <italic toggle="yes">env</italic> of HIV can increase by 1–2% every year (<xref rid="btac708-B14" ref-type="bibr">Herbeck <italic toggle="yes">et al.</italic>, 2006</xref>), posing a great challenge for drug design. Another example is Omircon of SARS-CoV-2, which transmits much faster than other variants (<xref rid="btac708-B29" ref-type="bibr">Viana <italic toggle="yes">et al.</italic>, 2022</xref>). Given the high genetic divergence of RNA viral haplotypes, a sample can contain multiple haplotypes due to evolution or coinfection (<xref rid="btac708-B4" ref-type="bibr">Bull <italic toggle="yes">et al.</italic>, 2012</xref>; <xref rid="btac708-B11" ref-type="bibr">Ghedin <italic toggle="yes">et al.</italic>, 2011</xref>; <xref rid="btac708-B23" ref-type="bibr">Rockett <italic toggle="yes">et al.</italic>, 2022</xref>). Being able to output the haplotypes and their abundance in a given sample can provide substantive information for studying viruses’ evolution, transmission, fitness, etc.</p>
    <p>Thanks to the rapid development of sequencing technologies, we can characterize viral populations through their sequencing data. Next-generation sequencing (NGS) technologies and third-generation sequencing (TGS) technologies play important roles in virus sequencing. Although NGS technologies (e.g. Illumina) can produce sequencing data with high accuracy (error rate lower than 1%) (<xref rid="btac708-B25" ref-type="bibr">Salk <italic toggle="yes">et al.</italic>, 2018</xref>), its short length of reads (typically &lt;250 bp) makes full-length haplotype reconstruction difficult. In particular, short reads had limited success in distinguishing highly similar haplotypes because of the difficulty of phasing distant single-nucleotide variants (SNVs). In contrast, TGS platforms can generate much longer reads, making full-length haplotype construction feasible. The representative TGS technologies can produce reads with lengths reaching several kbp, covering entire viral genomes (<xref rid="btac708-B10" ref-type="bibr">Flint <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btac708-B19" ref-type="bibr">McNaughton <italic toggle="yes">et al.</italic>, 2019</xref>). Many researchers had utilized TGS data for virus sequencing (<xref rid="btac708-B5" ref-type="bibr">Bull <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btac708-B10" ref-type="bibr">Flint <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btac708-B19" ref-type="bibr">McNaughton <italic toggle="yes">et al.</italic>, 2019</xref>). However, TGS data can have a higher per-base error rate (e.g. 10%) than NGS data (<xref rid="btac708-B3" ref-type="bibr">Ardui <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac708-B13" ref-type="bibr">Goodwin <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btac708-B25" ref-type="bibr">Salk <italic toggle="yes">et al.</italic>, 2018</xref>), which poses a challenge to distinguish bona fide variants from sequencing errors. Although there are error-correction tools, many of them are not designed for data with multiple haplotypes (<xref rid="btac708-B16" ref-type="bibr">Koren <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btac708-B26" ref-type="bibr">Salmela and Rivals, 2014</xref>; <xref rid="btac708-B27" ref-type="bibr">Salmela <italic toggle="yes">et al.</italic>, 2017</xref>).</p>
    <p>Long-read assembly programs can be applied to haplotype reconstruction, but many of them (<xref rid="btac708-B15" ref-type="bibr">Kolmogorov <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btac708-B16" ref-type="bibr">Koren <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btac708-B17" ref-type="bibr">Li, 2016</xref>; <xref rid="btac708-B24" ref-type="bibr">Ruan and Li, 2020</xref>) are not designed for viral populations with highly similar haplotypes. They tend to output contigs from the most dominant one (<xref rid="btac708-B6" ref-type="bibr">Cai and Sun, 2022</xref>; <xref rid="btac708-B18" ref-type="bibr">Luo <italic toggle="yes">et al.</italic>, 2022</xref>). Thus, haplotype reconstruction requires a different set of efforts from the generic assembly.</p>
    <p>There are some viral haplotype reconstruction pipelines for NGS data (<xref rid="btac708-B1" ref-type="bibr">Ahn and Vikalo, 2017</xref>; <xref rid="btac708-B2" ref-type="bibr">Ahn <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac708-B8" ref-type="bibr">Chen <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac708-B22" ref-type="bibr">Posada-Céspedes <italic toggle="yes">et al.</italic>, 2021</xref>). Many of them require paired-end reads as input and are not suitable to error-prone TGS data. Three recently published tools use long reads to reconstruct haplotypes. RVHaplo (<xref rid="btac708-B6" ref-type="bibr">Cai and Sun, 2022</xref>) and iGDA (<xref rid="btac708-B9" ref-type="bibr">Feng <italic toggle="yes">et al.</italic>, 2021</xref>) are two reference-based tools. They first detect sites containing SNVs from the alignment between reads and a reference genome. Then, reads are concatenated to form the final haplotypes according to the shared SNVs. Without using a reference genome, Strainline (<xref rid="btac708-B18" ref-type="bibr">Luo <italic toggle="yes">et al.</italic>, 2022</xref>) takes the longest reads as templates and aligns other reads against them for generating error-corrected contigs. It outputs final haplotypes by further identifying the overlaps between contigs. These three tools rely on read/contig overlaps for haplotype reconstruction. It is not trivial to determine an optimal cutoff of consistency for reads with different overlap sizes. Using a relaxed threshold helps construct haplotypes of heterogeneous or low coverage, but may mix reads from highly similar haplotypes. On the contrary, setting a stringent threshold may overestimate the haplotypes due to the high sequencing error rate of TGS data. In addition, lacking the prior knowledge of the number of haplotypes further compounds the problem of choosing optimal thresholds. Thus, the performance of existing viral haplotype reconstruction tools for long reads may fluctuate on datasets with different properties.</p>
    <p>In this work, we developed a tool named HaploDMF for viral haplotype reconstruction from long reads. HaploDMF utilizes a deep matrix factorization (DMF) model to learn latent features for distinguishing reads from different haplotypes. In order to achieve more robust haplotype reconstruction performance for data with heterogeneous sequencing coverages, we design a new loss function that incorporates the shared SNVs between reads and also the frequency distribution of SNVs. We benchmarked HaploDMF with the state-of-the-art tools on both simulated and real sequencing data. The experimental results demonstrate that HaploDMF has the most robust performance with high accuracy on datasets with different properties.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>HaploDMF takes long reads and a reference genome as input. It outputs the number of haplotypes, their genomes, and their relative abundance in a given sample. HaploDMF partitions reads into different haplotypes by clustering the learned latent features from reads. The latent features compress the sequence information from original reads such as position and base frequency, so that it can distinguish reads from different haplotypes more effectively. There are two advantages of using latent features for clustering. First, the latent feature learning process uses all the reads and thus the distance computation between two learned latent features tends to be more accurate than raw reads. Second, using the latent features alleviates the difficulty of adjusting the thresholds for reads with different overlap sizes, leading to more robust performance. There are three steps in HaploDMF. In the first step, HaploDMF identifies potential SNV sites, which captures the differences between haplotypes while discarding the common bases between haplotypes. And then it constructs a matrix recording the base frequencies of reads at each SNV site. Second, HaploDMF employs a deep matrix factorization model (<xref rid="btac708-B32" ref-type="bibr">Xue <italic toggle="yes">et al.</italic>, 2017</xref>) with an augmented loss function to extract latent features for each read based on the frequency matrix. Third, HaploDMF applies a clustering algorithm on the learned latent features and obtains a set of read clusters representing haplotypes. Then, it outputs the haplotypes and their abundance from read clusters.</p>
    <sec>
      <title>2.1 Frequency matrix construction</title>
      <p>Because SNVs indicate the differences between haplotypes, focusing on SNVs helps distinguish reads from different haplotypes. There are different methods for SNV detection (<xref rid="btac708-B6" ref-type="bibr">Cai and Sun, 2022</xref>; <xref rid="btac708-B9" ref-type="bibr">Feng <italic toggle="yes">et al.</italic>, 2021</xref>). Users can select an SNV detection tool to generate SNV sites as input to HaploDMF. Here, we use our own method (RVHaplo) based on binomial tests for SNV detection (<xref rid="btac708-B6" ref-type="bibr">Cai and Sun, 2022</xref>). It outputs a set of SNV sites given the alignment between reads and a reference genome. The recall and precision are usually more than 95% when the sequencing error rate is not high (e.g. 12%). When the dataset has a high sequencing error rate (e.g. 18%), RVHaplo may output some fake SNV sites. For example, the precision and recall of SNV sites on a simulated 5-haplotype dataset with 18% sequencing error rate (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S5</xref>) are 0.83 and 0.86. Using the learned features from all reads makes HaploDMF more robust against the noise in SNV detection. With the SNV sites, we count the frequencies of four bases at these sites from the alignment and generate a <italic toggle="yes">M </italic>×<italic toggle="yes"> N</italic> frequency matrix (see <xref rid="btac708-F1" ref-type="fig">Fig. 1</xref>), where <italic toggle="yes">M</italic> and <italic toggle="yes">N</italic> are the number of reads and SNV sites, respectively. <italic toggle="yes">F<sub>ij</sub></italic> is the base frequency (0<inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo></mml:mrow></mml:math></inline-formula>1) of read <italic toggle="yes">i</italic> at site <italic toggle="yes">j</italic>. For example, if read <italic toggle="yes">i</italic> is aligned to the SNV site <italic toggle="yes">j</italic> with base ‘A’, the frequency of base ‘A’ at the SNV site <italic toggle="yes">j</italic> is assigned to <italic toggle="yes">F<sub>ij</sub></italic>. If read <italic toggle="yes">i</italic> does not contain a base at site <italic toggle="yes">j</italic>, <italic toggle="yes">F<sub>ij</sub></italic> = 0.</p>
      <fig position="float" id="btac708-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Schematic diagram of the deep matrix factorization model. The frequency matrix (size <italic toggle="yes">M </italic>×<italic toggle="yes"> N</italic>) records the base frequency of reads at SNV sites. Each row (<inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) represents the base frequency of a read at all the SNV sites. Each column (<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>) represents the base frequency of all reads at an SNV site. The colored panels in the middle denote the two-layer neural network. In layer <italic toggle="yes">l</italic>, <italic toggle="yes">W<sup>l</sup></italic> and <italic toggle="yes">B<sup>l</sup></italic> are the weight and bias of the neural network, and <italic toggle="yes">O<sup>l</sup></italic> is the output. Subscripts <italic toggle="yes">r</italic> and <italic toggle="yes">c</italic> are used to distinguish the network parameters of learning <italic toggle="yes">R<sub>i</sub></italic> and <italic toggle="yes">S<sub>j</sub></italic>, where <italic toggle="yes">R<sub>i</sub></italic> and <italic toggle="yes">S<sub>j</sub></italic> are two latent features of the read and the SNV site. ReLU is an activation function. In our design, we set <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>×</mml:mo><mml:mn>128</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>r</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>128</mml:mn><mml:mo>×</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>256</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>256</mml:mn><mml:mo>×</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Thus, <italic toggle="yes">R<sub>i</sub></italic> and <italic toggle="yes">S<sub>j</sub></italic> have the same dimension <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Finally, cosine similarity <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>F</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cosine</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be applied to the two latent features to approximate the frequency <italic toggle="yes">F<sub>ij</sub></italic></p>
        </caption>
        <graphic xlink:href="btac708f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Deep matrix factorization</title>
      <p>Deep matrix factorization (DMF) has been successfully applied in recommender systems for predicting ranking scores (<xref rid="btac708-B32" ref-type="bibr">Xue <italic toggle="yes">et al.</italic>, 2017</xref>). DMF can learn latent features of users and items, which can be used to predict the ranking score for other items. Because users of similar tastes tend to give similar scores to the same items, their learned latent features are similar too. Similarly, reads from the same haplotype tend to have the same bases at the shared SNV sites and thus show similar frequencies. As a result, the learned latent features from these reads are expected to be close by their cosine distance. Inspired by the recommender system, we build a DMF model to learn latent features representing each read and site (<xref rid="btac708-F1" ref-type="fig">Fig. 1</xref>). The optimization goal of DMF in HaploDMF is to learn the latent features of each read and each site so that their cosine distance can predict the observed frequencies. To reduce the impact of sequencing errors during training, we only keep the frequencies of two most dominant bases at each site (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S4.2</xref> for further details). As a result, each column in the frequency matrix has two non-zero values. Considering that SNV sites with more than two alleles are relatively rare, the frequency matrix maintains nearly all SNV information for training.</p>
      <p>Given the frequency vector <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of read <italic toggle="yes">i</italic> and the frequency vector <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo>*</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> at site <italic toggle="yes">j</italic>, the DMF model utilizes a pair of fully connected networks to learn latent features <italic toggle="yes">R<sub>i</sub></italic> and <italic toggle="yes">S<sub>j</sub></italic> for read <italic toggle="yes">i</italic> and site <italic toggle="yes">j</italic>, respectively (see <xref rid="btac708-F1" ref-type="fig">Fig. 1</xref>). Then, a cosine similarity <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>F</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="italic">cosine</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> between these two latent features is calculated to approximate the observed frequency <italic toggle="yes">F<sub>ij</sub></italic> (<inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>). By minimizing the square loss of <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>F</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">F<sub>ij</sub></italic>, DMF is able to learn the latent features <italic toggle="yes">R<sub>i</sub></italic> and <italic toggle="yes">S<sub>j</sub></italic>. In this process, if read <italic toggle="yes">i</italic> and read <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> originate from the same haplotype, their shared SNV sites (e.g. site j) can lead to highly similar <italic toggle="yes">F<sub>ij</sub></italic> and <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, thus similar <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cosine</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">cosine</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As a result, the learned features <italic toggle="yes">R<sub>i</sub></italic> and <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> tend to be similar for reads from the same haplotype. Because bases with small frequencies are more likely to be haplotype-specific SNVs, we use a weighted mean square loss (<xref rid="E1" ref-type="disp-formula">Eqn. (1)</xref>) to train the model. It assigns a bigger weight to small <italic toggle="yes">F<sub>ij</sub></italic><disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">los</mml:mi><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>F</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></disp-formula></p>
      <p>Optimizing <italic toggle="yes">loss</italic><sup>1</sup> enables us to learn the parameters of the fully connected networks in <xref rid="btac708-F1" ref-type="fig">Figure 1</xref>. Then, each read <italic toggle="yes">i</italic> can be converted into its latent features <italic toggle="yes">R<sub>i</sub></italic>, which is used for clustering. Although the reads without overlaps can still have similar latent features through their overlaps with intermediate reads, their latent features may not be that close due to their large distance. Especially, when the distant reads do not have enough intermediate reads to connect them, it becomes more difficult to cluster them into the same group. Thus, we design another loss function as shown in <xref rid="E2" ref-type="disp-formula">Eqn. (2)</xref>.
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">los</mml:mi><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>k</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mi mathvariant="italic">cosine</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Minimizing <italic toggle="yes">loss</italic><sup>2</sup> enables us to generate similar latent features for distant SNV sites that share similar frequency distributions. As a result, distant reads can have similar latent features if they contain similar frequencies at distant SNV sites. In <xref rid="E2" ref-type="disp-formula">Eqn. 2</xref>, a smaller value of <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo>−</mml:mo><mml:mi mathvariant="italic">cosine</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> indicates latent features <italic toggle="yes">S<sub>j</sub></italic> and <italic toggle="yes">S<sub>k</sub></italic> are closer. We force the loss function to be non-negative by adding one to the function. And <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> is to normalize the loss. In the training process, we combine the loss function (1) and (2) to update the parameters in the model as shown in <xref rid="E3" ref-type="disp-formula">Eqn. (3)</xref>. Because reads with overlaps still provide more reliable information for clustering, we assign a bigger weight to <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">los</mml:mi><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:math></inline-formula> (0.8 by default).
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">loss</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo>·</mml:mo><mml:mi mathvariant="italic">los</mml:mi><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mi mathvariant="italic">los</mml:mi><mml:msubsup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p>
    </sec>
    <sec>
      <title>2.3 Clustering and haplotype reconstruction</title>
      <p>With the normalized latent features of reads, we employ a hierarchical clustering algorithm (Ward’s method) (Ward Jr., 1963) to conduct clustering (<xref rid="btac708-B21" ref-type="bibr">Pedregosa <italic toggle="yes">et al.</italic>, 2011</xref>). And we utilize an elbow method (<xref rid="btac708-B28" ref-type="bibr">Thorndike, 1953</xref>) to determine the number of haplotypes. The elbow method determines the number of clusters using the within-cluster distance. Here, we use the total number of different bases in clusters as the within-cluster distance. Given a cluster of latent features, we can generate a consensus sequence from the corresponding reads and calculate the number of different bases between reads and the consensus sequences. With the increasing number of clusters, the different bases decrease sharply at the beginning points. At some points, the value will not change significantly because a majority of reads in each cluster are from one haplotype. The turning point is output as the optimal number of clusters. Further details are presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>.</p>
      <p>Given the clusters of reads, we use majority vote to output consensus sequences as the constructed haplotypes. And we calculate the abundance of each haplotype based on the number of reads within each cluster. As we have the consensus sequences and their corresponding clusters of reads, we can further polish the consensus sequences with a genome polish tool called Medaka (<xref rid="btac708-B20" ref-type="bibr">Oxford Nanopore Technologies, 2018</xref>). Our experiments demonstrate that using Medaka further reduces the base error rate of the consensus sequences. HaploDMF will output the polished consensus sequences as the final result.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>Because different viruses have different replication rates and intra-sample similarities, we conduct experiments on various viruses including hepatitis C virus (HCV), HIV, norovirus, SARS-CoV-2 and a DNA virus, hepatitis B virus (HBV), to evaluate the performance of our method. We tested HaploDMF on both simulated data and real data. In the simulated data experiment, we focus on HIV, HCV and SARS-CoV-2 because HIV and HCV both have high replication rates and tend to form multiple haplotypes in one sample, and SARS-CoV-2 is one of the largest RNA viruses with a genome size of ∼29 903. We first conducted experiments on simulated datasets containing 10 HCV haplotypes (<xref rid="btac708-F2" ref-type="fig">Fig. 2</xref>, <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>). Then, we tested HaploDMF on simulated datasets containing five simulated HIV haplotypes (<xref rid="btac708-F3" ref-type="fig">Fig. 3</xref>, Supplementary Figs S3–S5). To validate HaploDMF on datasets with different properties, we constructed the simulated HIV data with different settings of divergence, abundance, and sequencing error rate. In addition, we used simulated SARS-CoV-2 data to evaluate the performance of HaploDMF on a large virus (<xref rid="sup1" ref-type="supplementary-material">Supplementary Section S4.1</xref>). Finally, we evaluated HaploDMF on real sequencing data including datasets containing 2 HBV haplotypes, 5 HIV haplotypes and 7 norovirus haplotypes (<xref rid="btac708-F4" ref-type="fig">Fig. 4</xref>).</p>
    <fig position="float" id="btac708-F2">
      <label>Fig. 2.</label>
      <caption>
        <p>The performance of four tools on two simulated HCV datasets (∼9294 bp, 12% error rate). The black line in the ‘Number of Contigs’ panel indicates the real haplotype number. Two stacking colors (dark and light) and the gray color on each bar in the ‘Error rate (%)’ panel denote the mismatch rate, the indel rate and the zero value, respectively. As iGDA did not output the estimated abundance of haplotypes, it has no results in the ‘JSD’ panel. The ‘N50’ panel is presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S2</xref></p>
      </caption>
      <graphic xlink:href="btac708f2" position="float"/>
    </fig>
    <fig position="float" id="btac708-F3">
      <label>Fig. 3.</label>
      <caption>
        <p>The performance of four tools on simulated HIV datasets (∼9000 bp, 12% error rate) with different divergence settings and abundance distributions. X-axis: the average of pairwise divergences between haplotypes (0.3%, 0.5% and 1%). Complete results including the ‘N50’ panel are presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S4</xref>. Other legends are the same as <xref rid="btac708-F2" ref-type="fig">Figure 2</xref>. (<bold>a</bold>) abundance distribution (35%, 30%, 20%, 10%, <bold>5%</bold>), (<bold>b</bold>) abundance distribution (37%, 30%, 20%, 10%, <bold>3%</bold>) and (<bold>c</bold>) abundance distribution (39%, 30%, 20%, 10%, <bold>1%</bold>)</p>
      </caption>
      <graphic xlink:href="btac708f3" position="float"/>
    </fig>
    <fig position="float" id="btac708-F4">
      <label>Fig. 4.</label>
      <caption>
        <p>The performance of four tools on real/mock sequencing data: two HBV haplotypes, five HIV haplotypes and seven Norovirus haplotypes. X-axis: three datasets. The black lines in the ‘Number of Contigs’ panel and the ‘N50(k)’ panel indicate the real number of haplotypes and the average length of real haplotypes, respectively. Two stacking colors (dark and light) and the gray color on each bar in the ‘Error rate (%)’ panel denote the mismatch rate, the indel rate and the zero value, respectively. As iGDA did not output the estimated abundance of haplotypes, it has no results in the ‘JSD’ panel</p>
      </caption>
      <graphic xlink:href="btac708f4" position="float"/>
    </fig>
    <p>We used seven metrics to evaluate the quality of reconstructed haplotypes and the accuracy of estimated abundance following the previous work. They are target genome coverage, number of contigs (haplotypes), average error rate (summation of the indel rate and the mismatch rate), N50 and Jensen–Shannon divergence (JSD). Of them, target genome coverage evaluates the average percentage of target genomes covered by contigs (haplotypes). Error rate is calculated from the alignments between contigs and the target genomes. JSD measures the similarity between the estimated abundance distribution and the real abundance distribution. It can be calculated by <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">JSD</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Y</mml:mi><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>Z</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">X</italic> and <italic toggle="yes">Y</italic> are two abundance distributions, <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>Z</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mi>X</mml:mi><mml:mo>+</mml:mo><mml:mi>Y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <italic toggle="yes">D</italic> is the Kullback–Leibler divergence function. Small value of JSD indicates high similarity between two abundance distributions.</p>
    <p>We focus on benchmarking our tool HaploDMF with three recently published haplotype reconstruction tools RVHaplo, iGDA and Strainline. HaploDMF, RVHaplo and iGDA are reference-based tools. They take a reference genome and the alignment between long reads and the reference genome as input. The <italic toggle="yes">de novo</italic> tool Strainline only takes long reads as input. Because HaploDMF and RVHaplo output consensus sequences and read clusters, we are able to apply Medaka to polish their results directly. But iGDA and Strainline need more post-processing steps to apply Medaka. And we found that Medaka did not always improve the results of iGDA and Strainline. Thus, we only showed the results of applying Medaka to HaploDMF and RVHaplo but not to iGDA and Strainline. The details of applying Medaka to the four tools are presented in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S4.3</xref>.</p>
    <sec>
      <title>3.1 Experiments on simulated HCV data</title>
      <p>We simulated two datasets for 10 real HCV (genotype 1a) haplotypes (9273–9311 bp) using Badread (<xref rid="btac708-B31" ref-type="bibr">Wick, 2019</xref>) with an average error rate of 12% and read length of 2500. The accession IDs of the 10 haplotypes are summarized in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>. These 10 haplotypes were used in Strainline as case studies. The pairwise divergence ranges from 2.8% to 7.4% (<xref rid="btac708-B18" ref-type="bibr">Luo <italic toggle="yes">et al.</italic>, 2022</xref>). There are 44 700 and 44 783 reads in these two datasets, respectively. According to the smallest abundance of haplotype in the datasets, we used ‘HCV-5%’ and ‘HCV-1%’ to denote the datasets. The HCV-5% dataset has the same abundance distribution setting (5–15%) as Strainline. The smallest and the largest abundance of haplotypes in the HCV-1% dataset are 1% and 19%. The detailed abundance distributions of haplotypes in these two datasets are shown in <xref rid="btac708-T1" ref-type="table">Table 1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>.</p>
      <table-wrap position="float" id="btac708-T1">
        <label>Table 1.</label>
        <caption>
          <p>Abundance distribution of 10 HCV haplotypes</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th rowspan="1" colspan="1">Abundance distribution</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">HCV-5%</td>
              <td rowspan="1" colspan="1"><bold>5%</bold>, 6%, 7%, 8%, 9%, 11%, 12%, 13%, 14%, 15%</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">HCV-1%</td>
              <td rowspan="1" colspan="1"><bold>1%</bold>, <bold>3%</bold>, 5%, 8%, 9%, 11%, 12%, 15%, 17%, 19%</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>We tested the four tools on these two HCV datasets, respectively. For reference-based tools, we used the representative reference genome (NCBI: NC_038882.1) of HCV (genotype 1a) to align reads. <xref rid="btac708-F2" ref-type="fig">Figure 2</xref> shows the results of the four tools. Although iGDA has high target genome coverage on these two datasets, it significantly overestimated the number of haplotypes. RVHaplo, which clusters reads based on identified SNVs, only reconstructed three haplotypes in the HCV-5% dataset and eight haplotypes in the HCV-1% dataset because it grouped many reads from different haplotypes into the same clusters. If we set a more stringent threshold for read clustering, RVHaplo can better distinguish reads from different haplotypes. However, without knowing the number of haplotypes and their relative abundance, it is difficult to adjust the threshold for optimal clustering. With the learned latent features, HaploDMF is able to achieve robust outputs on both datasets. In the HCV-5% dataset, HaploDMF has the highest target coverage and the smallest error rate. It output ten haplotypes with accurate abundance estimation (smaller JSD value) while Strainline generated one more haplotype. In the HCV-1% dataset, HaploDMF has the second-largest target genome coverage and the smallest error rate. HaploDMF and Strainline both reconstructed the nine most dominant haplotypes but missed the 1%-abundance haplotype.</p>
    </sec>
    <sec>
      <title>3.2 Experiments on simulated HIV data</title>
      <p>The HCV experiment with 10 haplotypes allows us to evaluate the performance of the four tools when there are numerous haplotypes. In order to examine the performance of the four tools on datasets with varying divergences, abundance distributions and sequencing error rates, we simulated a series of datasets containing five simulated HIV haplotypes. Given an average divergence (0.3–5%) between haplotypes, we generated five simulated HIV haplotypes from a real HIV haplotype (9181 bp, NCBI: NC_001802.1) by random base mutations. Then, we used Badread to simulate nine datasets with three abundance distribution settings (see <xref rid="btac708-F3" ref-type="fig">Fig. 3</xref>) and three average error rates (6%, 12% and 18%). There are ∼43 321 reads in each dataset. And the average read length is ∼2500 bp. Using the real HIV haplotype as the reference for three reference-based tools, we tested the four tools on these datasets and summarized their performance in <xref rid="btac708-F3" ref-type="fig">Figure 3</xref> (12% error rate) and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figures S3–S5</xref> (6% and 18% error rate).</p>
      <p>In <xref rid="btac708-F3" ref-type="fig">Figure 3</xref>, three tools HaploDMF, RVHaplo and iGDA have comparable performance when the smallest abundance of haplotype is 5% or 3% (<xref rid="btac708-F3" ref-type="fig">Fig. 3a and b</xref>). They reconstructed five haplotypes with high target genome coverages and small error rates. When the lowest abundance is 1% (<xref rid="btac708-F3" ref-type="fig">Fig. 3c</xref>), HaploDMF and RVHaplo only output four haplotypes on datasets with small haplotype divergences (&lt;1%), while iGDA overestimated the number of haplotypes. When the divergence of haplotypes is high (&gt;1%), iGDA and RVHaplo can output the 1% haplotype (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S4</xref>). The performance of iGDA on the 12%-error-rate datasets is inconsistent with the HCV experiments with the same sequencing error rate. This may be because the lengths and pairwise divergences of haplotypes are the same in the HIV experiments but different in the HCV experiments. We can also observe this in the real data experiments (<xref rid="btac708-F4" ref-type="fig">Fig. 4</xref>). Strainline output some contigs (e.g. 4 and 5) on many datasets but the target genome coverages are still small as some contigs are from the same haplotypes. Strainline did not merge them into one contig due to some sequencing errors. Furthermore, if Strainline does not select reads from all haplotypes as templates, it will miss some haplotypes in the final output. The performance of these four tools on the 6%-error-rate datasets (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>) is similar to the 12% error-rate datasets. When the sequencing error rate increases to 18% (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S5</xref>), the performance of HaploDMF and RVHaplo is still stable. They missed one haplotype on datasets with small haplotype divergences. But iGDA tended to overestimate the number of haplotypes on these high-error-rate datasets.</p>
      <p>According to the simulated experiments on HCV and HIV, we observed the following: (i) The performance of HaploDMF is the most robust to the change in haplotypes’ number, divergence, sequencing error rate, and abundance; (ii) iGDA can reconstruct low abundance haplotypes when the sequencing error rate is low. However, it tended to overestimate the number of haplotypes in the following cases: (a) The sequencing error rate is high. (b) The lengths of the genomes and their pairwise divergences vary in the sample. (iii) In most samples, RVHaplo is robust to the change in error rate, divergence, and sequencing error rate. But it needs adjustment of the parameters to achieve optimal results. (iv) Strainline’s performance did not vary significantly across datasets with different properties. It can under- or overestimate the number of haplotypes. In addition, we recorded the running time and memory usage of the four tools on the simulated HIV datasets. The average running time and memory usage of HaploDMF are ∼1 h and ∼19 GB. Further details are presented in the Supplementary file.</p>
    </sec>
    <sec>
      <title>3.3 Experiments on real/mock sequencing data</title>
      <p>We used three real/mock sequencing datasets with increasing difficulty. They are TGS sequencing data from three viruses (including one DNA virus): HBV, HIV and norovirus. The detailed data properties are described in <xref rid="btac708-T2" ref-type="table">Table 2</xref>. <italic toggle="yes">The first dataset</italic> (NCBI: ERR3253560) contains two HBV haplotypes (NCBI: MK321264.1 and MK321265.1) with a high divergence (∼9%). Because reads in this dataset were sequenced with concatemeric amplicons, some reads have much longer lengths than the genome (<xref rid="btac708-B19" ref-type="bibr">McNaughton <italic toggle="yes">et al.</italic>, 2019</xref>). <italic toggle="yes">De novo</italic> tool (e.g. Strainline) may output haplotypes with extremely long lengths, while reference-based tools can handle the length of haplotypes with this type of data. Because a reference genome with ambiguous bases can fail the running of iGDA, we utilized a HBV genome (NCBI: MT622522.1) without ambiguous bases as the reference for all reference-based tools.</p>
      <table-wrap position="float" id="btac708-T2">
        <label>Table 2.</label>
        <caption>
          <p>Overview of three datasets with real/mock sequencing data</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th rowspan="1" colspan="1">HBV-2</th>
              <th rowspan="1" colspan="1">HIV-5</th>
              <th rowspan="1" colspan="1">Norovirus-7</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Platform</td>
              <td rowspan="1" colspan="1">Nanopore</td>
              <td rowspan="1" colspan="1">PacBio</td>
              <td rowspan="1" colspan="1">Nanopore</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Read number</td>
              <td rowspan="1" colspan="1">13 016</td>
              <td rowspan="1" colspan="1">15 932</td>
              <td rowspan="1" colspan="1">43 492</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Median length</td>
              <td rowspan="1" colspan="1">1274</td>
              <td rowspan="1" colspan="1">1554</td>
              <td rowspan="1" colspan="1">2594</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Genome size</td>
              <td rowspan="1" colspan="1">3212–3215</td>
              <td rowspan="1" colspan="1">9535–9719</td>
              <td rowspan="1" colspan="1">7513–7618</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Divergence (%)</td>
              <td rowspan="1" colspan="1">∼9</td>
              <td rowspan="1" colspan="1">2.61–8.45</td>
              <td rowspan="1" colspan="1">0.95–4.30</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Error rate (%)</td>
              <td rowspan="1" colspan="1">10.39</td>
              <td rowspan="1" colspan="1">2.34</td>
              <td rowspan="1" colspan="1">10.19</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Abundance (%)</td>
              <td rowspan="1" colspan="1">29.1, 70.9</td>
              <td rowspan="1" colspan="1">5.8, 14, 17.2, 27.7, 35.3</td>
              <td rowspan="1" colspan="1">1, 7, 9.2, 13.8, 18.4, 23.0, 27.6</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Numbers after the names of viruses denote the number of haplotypes within the datasets.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p><italic toggle="yes">The second dataset</italic> (NCBI: SRR961669) is a mock data containing five HIV haplotypes with known genomes (<xref rid="btac708-B12" ref-type="bibr">Giallonardo <italic toggle="yes">et al.</italic>, 2014</xref>). All the genomes of these five haplotypes can be found in (<xref rid="btac708-B12" ref-type="bibr">Giallonardo <italic toggle="yes">et al.</italic>, 2014</xref>). And we used the genome of HXB2 as the reference for all reference-based tools because HXB2 is a major circulating haplotype of HIV. Although the error rate of this dataset is small (2.34%), some haplotypes’ sequencing coverages in some regions are very low (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S8</xref>), impeding the full-length reconstruction of haplotypes. <italic toggle="yes">The third dataset</italic> contains seven haplotypes of norovirus. It was generated by mixing seven single-haplotype dataset. There are many single-haplotype datasets of norovirus by Nanopore sequencing in <xref rid="btac708-B10" ref-type="bibr">Flint <italic toggle="yes">et al.</italic> (2021)</xref>. We chose seven datasets of haplotypes with low pairwise divergence to form this mock dataset. The genomes of haplotypes and datasets can be downloaded from NCBI (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>). Because the sizes of the seven datasets differ significantly (518–196 525 reads), we randomly sampled reads from each dataset and used the smallest dataset as the 1%-abundance one to create the mock dataset. We only reserved reads that can be aligned to their genomes during the sampling procedure. And we retained reads with lengths between 800 and 8000 because the genome size is about 7.5k. All reference-based tools used a genome of norovirus (NCBI: MW661279.1) from the same project to align reads. The results of applying the four tools to these three datasets are summarized in <xref rid="btac708-F4" ref-type="fig">Figure 4</xref>.</p>
      <p>In the <italic toggle="yes">HBV experiment</italic>, only HaploDMF and RVHaplo output correct number of haplotypes with the high target genome coverage (∼100%). Although Strainline also has a high target genome coverage (∼100%), it overestimated the number of haplotypes. IGDA generated two haplotypes, but both of them are closer to one of the target genomes. Thus, its target genome coverage on this dataset is small. This may be because iGDA filtered some haplotypes by its stringent filtering conditions. All reference-based tools can generate haplotypes with appropriate lengths, but the <italic toggle="yes">de novo</italic> tool Strainline output extremely long haplotypes as it does not have prior information of the genome length. In addition, HaploDMF and RVHaplo estimated the abundance distribution of haplotypes with high accuracy (HaploDMF: 70% and 30%, RVHaplo: 69.7% and 30.3%). Thus, their JSD values on this dataset are small.</p>
      <p>In the <italic toggle="yes">HIV experiment</italic>, overlap-based tools RVHaplo, iGDA and Strainline overestimated the number of haplotypes (see <xref rid="btac708-F4" ref-type="fig">Fig. 4</xref>). Because the coverages in some regions of haplotypes are small, they failed to concatenate reads into full-length haplotypes, thus outputing many fragmental contigs. For example, RVHaplo output two short contigs for the 89.6 haplotype and the YU2 haplotype. <xref rid="btac708-F5" ref-type="fig">Figure 5</xref> shows the sequencing depth of these two haplotypes and contigs generated by RVHaplo and HaploDMF. The junction regions of two 89.6 contigs and two YU2 contigs generated by RVHaplo have low sequencing coverage. Thus, RVHaplo failed to concatenate two contigs into the full-length haplotype. Because <italic toggle="yes">loss</italic><sup>2</sup> helps latent features learn frequency information of distant reads that do not have sufficient overlaps, HaploDMF successfully output two long contigs for 89.6 and YU2. In this dataset, HaploDMF output five long contigs with the highest target genome coverage (∼94%). Without using <italic toggle="yes">loss</italic><sup>2</sup>, HaploDMF will output short contigs for 89.6 and YU2. And the small JSD value of HaploDMF indicates that the estimated abundance of haplotypes by HaploDMF is close to the ground truth (HaploDMF: 5.5%, 14.1%, 17.6%, 27.2% and 35.6%). Thus, HaploDMF outperforms other tools in this HIV experiment.</p>
      <fig position="float" id="btac708-F5">
        <label>Fig. 5.</label>
        <caption>
          <p>Alignments between contigs and genomes of two haplotypes (89.6 and YU2). The black lines present two haplotypes. The red and blue lines indicate the contigs generated by HaploDMF and RVHaplo, respectively. The grey bars show the sequencing depth of the two haplotypes</p>
        </caption>
        <graphic xlink:href="btac708f5" position="float"/>
      </fig>
      <p>In the <italic toggle="yes">norovirus experiment</italic>, iGDA and Strainline overestimated the number of haplotypes while HaploDMF and RVHaplo underestimated the number of haplotypes. Compared to other tools, HaploDMF reconstructed 6 haplotypes with the highest target genome coverage and the smallest error rate. It only missed the 1%-abundance haplotype, which is consistent with the simulated experiments. In this experiment, we further investigated the impact of using latent feature vectors on read clustering. As a comparison, we show the visualized clustering performance using the reads’ frequency vectors and the latent feature vectors. In order to cluster the reads’ frequency vectors, we first followed the standard recommender system to predict the ‘missing frequency’ in the frequency matrix (<xref rid="btac708-F1" ref-type="fig">Fig. 1</xref>). Then, we used T-SNE (<xref rid="btac708-B7" ref-type="bibr">Chan <italic toggle="yes">et al.</italic>, 2019</xref>) to map the completed frequency matrix and the latent features into the two-dimensional space. The scatter plot of the mapped data points is shown in <xref rid="btac708-F6" ref-type="fig">Figure 6</xref>. Each data point in <xref rid="btac708-F6" ref-type="fig">Figure 6</xref> presents a read and the colors denote different haplotypes. Clear boundaries between color blocks indicate that reads from the same haplotype can be grouped into the same cluster accurately. On the contrary, if the data points with different colors mix together, the clusters will contain reads from multiple haplotypes. In <xref rid="btac708-F6" ref-type="fig">Figure 6</xref>, the data points of the latent features are grouped into color blocks clearly, while many data points of the completed frequency matrix mix together with fuzzy boundaries. This comparison further shows the advantage of using latent features for read clustering over using raw frequency vectors from reads.</p>
      <fig position="float" id="btac708-F6">
        <label>Fig. 6.</label>
        <caption>
          <p>Visualization of the clustering on the norovirus dataset using T-SNE. (<bold>a</bold>) The input data for T-SNE is the completed frequency matrix complemented by HaploDMF. (<bold>b</bold>) The input data for T-SNE are the learned latent features by HaploDMF. Each data point presents the vector of a read. The colors indicate different haplotypes</p>
        </caption>
        <graphic xlink:href="btac708f6" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion and conclusion</title>
    <p>Reconstructing viral haplotypes of a viral population facilitates research on the virus’s evolution, transmission, fitness, etc. TGS technology can generate long sequencing data, which makes full-length haplotype reconstruction more feasible. However, higher per-base error rates in TGS data can lead to overestimation of the haplotypes. Existing error correction tools are not designed for a viral population consisting of multiple highly similar haplotypes. Thus, new methods are still in great need. Existing methods reconstruct haplotypes based on the identity/consistency of read overlaps. They utilize a threshold of base identity in the overlap region to cluster or concatenate reads/contigs. In most cases, the number and genetic similarity of haplotypes in the sample are unknown, making it difficult to decide an appropriate threshold for varying overlap sizes. Thus, the performance of these methods can fluctuate on datasets with different properties (e.g. coverage, sequencing error rate, number of haplotypes, etc.).</p>
    <p>In order to address the limitations of clustering reads with small or no overlaps, we developed a tool, HaploDMF, to output genomes of haplotypes and their abundance in samples from TGS data. Instead of relying on the identity of read overlaps directly, HaploDMF utilizes a deep matrix factorization model with a carefully designed loss function to automatically learn latent features from reads. Then, HaploDMF can cluster reads based on the latent features instead of the reads themselves. Thus, regardless of whether reads contain overlaps, HaploDMF can measure their distance with latent features for clustering, which renders HaploDMF more robust performance. In particular, when the dataset has heterogeneous sequencing coverage in some regions, HaploDMF can still reconstruct the full-length haplotypes (as shown in <xref rid="btac708-F5" ref-type="fig">Fig. 5</xref>).</p>
    <p>HaploDMF is a reference-based tool. Like RVHaplo and iGDA, it requires the user to provide a reference genome of the target virus. If a <italic toggle="yes">de novo</italic> assembly tool can produce a relatively complete contig, the contig can be used as the input. Otherwise, we recommend users to choose a reference genome that is more related to the haplotypes in the sample so that a quality alignment can be obtained for effective SNV detection. In our experiments, we did not purposely choose a closely related genome as a reference. Without assuming much prior knowledge, we choose the representative reference genome from NCBI using the virus name as the keyword in search. Thus, the results can reflect more general usages.</p>
    <p>According to our experiments, HaploDMF has the most robust performance on datasets with different properties. On datasets with a typical sequencing error rate (e.g. 10%), HaploDMF can reconstruct haplotypes with at least 0.3% divergence and &gt;1% relative abundance. When the sequencing error rate is high (e.g. 20%), the limits of acceptable abundance and divergence for HaploDMF may slightly increase.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btac708_Supplementary_Data</label>
      <media xlink:href="btac708_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We would like to acknowledge the High Performance Computing Cluster provided by Department of Electrical Engineering, City University of Hong Kong.</p>
    <sec>
      <title>Funding</title>
      <p>This work was supported in part by Hong Kong Research Grants Council (RGC) General Research Fund (GRF) [11217521 and 11206819] and City University of Hong Kong project [9678241].</p>
      <p><italic toggle="yes">Conflict of Interest</italic>: The authors declare that there is no conflict of interest.</p>
    </sec>
  </ack>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The simulation data and the tool of HaploDMF can be downloaded at <ext-link xlink:href="https://github.com/dhcai21/HaploDMF" ext-link-type="uri">https://github.com/dhcai21/HaploDMF</ext-link>. The sources of real sequencing data are provided in corresponding sections.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btac708-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Ahn</surname><given-names>S.</given-names></string-name>, <string-name><surname>Vikalo</surname><given-names>H.</given-names></string-name></person-group> (<year>2017</year>) <part-title>aBayesQR: a Bayesian method for reconstruction of viral populations characterized by low diversity</part-title>. In: <source>International Conference on Research in Computational Molecular Biology</source>, Hong Kong, China. <publisher-name>Springer</publisher-name>, Cham, pp. <fpage>353</fpage>–<lpage>369</lpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ahn</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Viral quasispecies reconstruction via tensor factorization with successive read removal</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i23</fpage>–<lpage>i31</lpage>.<pub-id pub-id-type="pmid">29949976</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ardui</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Single molecule real-time (SMRT) sequencing comes of age: applications and utilities for medical diagnostics</article-title>. <source>Nucleic Acids Res</source>., <volume>46</volume>, <fpage>2159</fpage>–<lpage>2168</lpage>.<pub-id pub-id-type="pmid">29401301</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bull</surname><given-names>R.A.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>Contribution of intra-and interhost dynamics to norovirus evolution</article-title>. <source>J. Virol</source>., <volume>86</volume>, <fpage>3219</fpage>–<lpage>3229</lpage>.<pub-id pub-id-type="pmid">22205753</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bull</surname><given-names>R.A.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Analytical validity of nanopore sequencing for rapid SARS-CoV-2 genome analysis</article-title>. <source>Nat. Commun</source>., <volume>11</volume>, <fpage>1</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">31911652</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cai</surname><given-names>D.</given-names></string-name>, <string-name><surname>Sun</surname><given-names>Y.</given-names></string-name></person-group> (<year>2022</year>) <article-title>Reconstructing viral haplotypes using long reads</article-title>. <source>Bioinformatics</source>, <volume>38</volume>, <fpage>2127</fpage>–<lpage>2134</lpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chan</surname><given-names>D.M.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>GPU accelerated t-distributed stochastic neighbor embedding</article-title>. <source>J. Parallel Distributed Comput</source>., <volume>131</volume>, <fpage>1</fpage>–<lpage>13</lpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>De novo haplotype reconstruction in viral quasispecies using paired-end read guided path finding</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>2927</fpage>–<lpage>2935</lpage>.<pub-id pub-id-type="pmid">29617936</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Feng</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Detecting and phasing minor single-nucleotide variants from long-read sequencing data</article-title>. <source>Nat. Commun</source>., <volume>12</volume>, <fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">33397941</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Flint</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Genomic analysis of human noroviruses using combined illumina–nanopore data</article-title>. <source>Virus Evol</source>., <volume>7</volume>, <fpage>veab079</fpage>.<pub-id pub-id-type="pmid">35186325</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ghedin</surname><given-names>E.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Deep sequencing reveals mixed infection with 2009 pandemic influenza A (H1N1) virus strains and the emergence of oseltamivir resistance</article-title>. <source>J. Infect. Dis</source>., <volume>203</volume>, <fpage>168</fpage>–<lpage>174</lpage>.<pub-id pub-id-type="pmid">21288815</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Giallonardo</surname><given-names>F.D.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>Full-length haplotype reconstruction to infer the structure of heterogeneous virus populations</article-title>. <source>Nucleic Acids Res</source>., <volume>42</volume>, <fpage>e115</fpage>.<pub-id pub-id-type="pmid">24972832</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goodwin</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>Oxford nanopore sequencing, hybrid error correction, and de novo assembly of a eukaryotic genome</article-title>. <source>Genome Res</source>., <volume>25</volume>, <fpage>1750</fpage>–<lpage>1756</lpage>.<pub-id pub-id-type="pmid">26447147</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Herbeck</surname><given-names>J.T.</given-names></string-name></person-group><etal>et al</etal> (<year>2006</year>) <article-title>Human immunodeficiency virus type 1 env evolves toward ancestral states upon transmission to a new host</article-title>. <source>J. Virol</source>., <volume>80</volume>, <fpage>1637</fpage>–<lpage>1644</lpage>.<pub-id pub-id-type="pmid">16439520</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kolmogorov</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>metaFlye: scalable long-read metagenome assembly using repeat graphs</article-title>. <source>Nat. Methods</source>, <volume>17</volume>, <fpage>1103</fpage>–<lpage>1110</lpage>.<pub-id pub-id-type="pmid">33020656</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koren</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>722</fpage>–<lpage>736</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</article-title>. <source>Bioinformatics</source>, <volume>32</volume>, <fpage>2103</fpage>–<lpage>2110</lpage>.<pub-id pub-id-type="pmid">27153593</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Luo</surname><given-names>X.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) <article-title>Strainline: full-length de novo viral haplotype reconstruction from noisy long reads</article-title>. <source>Genome Biol</source>., <volume>23</volume>, <fpage>1</fpage>–<lpage>27</lpage>.<pub-id pub-id-type="pmid">34980209</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McNaughton</surname><given-names>A.L.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Illumina and nanopore methods for whole genome sequencing of hepatitis B virus (HBV)</article-title>. <source>Sci. Rep</source>., <volume>9</volume>, <fpage>1</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">30626917</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B20">
      <mixed-citation publication-type="other"><collab>Oxford Nanopore Technologies</collab> (<year>2018</year>) GitHub - nanoporetech/medaka: sequence correction provided by ONT Research. <italic toggle="yes">GitHub</italic>, github.com/nanoporetech/medaka.</mixed-citation>
    </ref>
    <ref id="btac708-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pedregosa</surname><given-names>F.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Scikit-learn: machine learning in python</article-title>. <source>J. Mach. Learn. Res</source>., <volume>12</volume>, <fpage>2825</fpage>–<lpage>2830</lpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Posada-Céspedes</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>V-pipe: a computational pipeline for assessing viral genetic diversity from high-throughput data</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>1673</fpage>–<lpage>1680</lpage>.<pub-id pub-id-type="pmid">33471068</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rockett</surname><given-names>R.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) <article-title>Co-infection with SARS-CoV-2 omicron and Delta variants revealed by genomic surveillance</article-title>. <source>Nat. Commun</source>., <volume>13</volume>, <fpage>1</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">34983933</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ruan</surname><given-names>J.</given-names></string-name>, <string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2020</year>) <article-title>Fast and accurate long-read assembly with wtdbg2</article-title>. <source>Nat. Methods</source>, <volume>17</volume>, <fpage>155</fpage>–<lpage>158</lpage>.<pub-id pub-id-type="pmid">31819265</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Salk</surname><given-names>J.J.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Enhancing the accuracy of next-generation sequencing for detecting rare and subclonal mutations</article-title>. <source>Nat. Rev. Genet</source>., <volume>19</volume>, <fpage>269</fpage>–<lpage>285</lpage>.<pub-id pub-id-type="pmid">29576615</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Salmela</surname><given-names>L.</given-names></string-name>, <string-name><surname>Rivals</surname><given-names>E.</given-names></string-name></person-group> (<year>2014</year>) <article-title>LoRDEC: accurate and efficient long read error correction</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3506</fpage>–<lpage>3514</lpage>.<pub-id pub-id-type="pmid">25165095</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Salmela</surname><given-names>L.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>Accurate self-correction of errors in long reads using de bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>799</fpage>–<lpage>806</lpage>.<pub-id pub-id-type="pmid">27273673</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Thorndike</surname><given-names>R.L.</given-names></string-name></person-group> (<year>1953</year>) <article-title>Who belongs in the family</article-title>. <source>Psychometrika</source>, <volume>18</volume>, <fpage>267</fpage>–<lpage>276</lpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Viana</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) <article-title>Rapid epidemic expansion of the SARS-CoV-2 omicron variant in Southern africa</article-title>. <source>Nature</source>, <volume>603</volume>, <fpage>679</fpage>–<lpage>686</lpage>.<pub-id pub-id-type="pmid">35042229</pub-id></mixed-citation>
    </ref>
    <ref id="btac708-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ward</surname><given-names>J.H.</given-names><suffix>Jr.</suffix></string-name></person-group> (<year>1963</year>) <article-title>Hierarchical grouping to optimize an objective function</article-title>. <source>J. Am. Stat. Assoc</source>., <volume>58</volume>, <fpage>236</fpage>–<lpage>244</lpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wick</surname><given-names>R.R.</given-names></string-name></person-group> (<year>2019</year>) <article-title>Badread: simulation of error-prone long reads</article-title>. <source>J. Open Source Softw</source>., <volume>4</volume>, <fpage>1316</fpage>.</mixed-citation>
    </ref>
    <ref id="btac708-B32">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Xue</surname><given-names>H.-J.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <part-title>Deep matrix factorization models for recommender systems</part-title>. In: <source>IJCAI</source>, vol. <volume>17</volume>. <publisher-loc>Melbourne</publisher-loc>, <publisher-name>Australia</publisher-name>, pp. <fpage>3203</fpage>–<lpage>3209</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
