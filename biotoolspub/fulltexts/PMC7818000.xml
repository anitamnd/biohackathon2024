<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD with OASIS Tables v1.0 20120330//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing-oasis-article1.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName jats-oasis2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Neurophotonics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Neurophotonics</journal-id>
    <journal-id journal-id-type="coden">NEUROW</journal-id>
    <journal-id journal-id-type="publisher-id">NPh</journal-id>
    <journal-title-group>
      <journal-title>Neurophotonics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">2329-423X</issn>
    <issn pub-type="epub">2329-4248</issn>
    <publisher>
      <publisher-name>Society of Photo-Optical Instrumentation Engineers</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7818000</article-id>
    <article-id pub-id-type="doi">10.1117/1.NPh.8.1.010801</article-id>
    <article-id pub-id-type="publisher-manuscript">NPh-20075TR</article-id>
    <article-id pub-id-type="publisher-id">20075TR</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Tutorials</subject>
      </subj-group>
      <subj-group subj-group-type="SPIE-art-type">
        <subject>Paper</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Tools and tutorial on practical ray tracing for microscopy</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Pineau Noël</surname>
          <given-names>Valérie</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="fn1" ref-type="author-notes">†</xref>
        <xref rid="b1" ref-type="bio"/>
        <email>valerie.pineau-noel.1@ulaval.ca</email>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-6952-1582</contrib-id>
        <name>
          <surname>Masoumi</surname>
          <given-names>Shadi</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="fn1" ref-type="author-notes">†</xref>
        <xref rid="b2" ref-type="bio"/>
        <email>shadi.masoumi@cervo.ulaval.ca</email>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Parham</surname>
          <given-names>Elahe</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="fn1" ref-type="author-notes">†</xref>
        <xref rid="b3" ref-type="bio"/>
        <email>elahe.parham@cervo.ulaval.ca</email>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Genest</surname>
          <given-names>Gabriel</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="b4" ref-type="bio"/>
        <email>gabriel.genest.2@ulaval.ca</email>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bégin</surname>
          <given-names>Ludovick</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="b5" ref-type="bio"/>
        <email>ludovick.begin@gmail.com</email>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Vigneault</surname>
          <given-names>Marc-André</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="b6" ref-type="bio"/>
        <email>marc-andre.vigneault.2@ulaval.ca</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">https://orcid.org/0000-0001-6440-6948</contrib-id>
        <name>
          <surname>Côté</surname>
          <given-names>Daniel C.</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">a</xref>
        <xref rid="aff2" ref-type="aff">b</xref>
        <xref rid="cor1" ref-type="corresp">*</xref>
        <xref rid="b7" ref-type="bio"/>
        <email>Daniel. Cote@crulrg.ulaval.ca</email>
      </contrib>
      <aff id="aff1"><label>a</label><institution>Université Laval</institution>, CERVO Brain Research Center, Québec, <country>Canada</country></aff>
      <aff id="aff2"><label>b</label><institution>Université Laval</institution>, Centre D’Optique, Photonique et Laser, Québec, <country>Canada</country></aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><label>*</label>Address all correspondence to Daniel C. Côté, <email>dccote@cervo.ulaval.ca</email></corresp>
      <fn id="fn1">
        <label>†</label>
        <p>These authors contributed equally to this work</p>
      </fn>
    </author-notes>
    <pub-date pub-type="epub">
      <day>21</day>
      <month>1</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <month>1</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>21</day>
      <month>1</month>
      <year>2021</year>
    </pub-date>
    <!--PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>.-->
    <volume>8</volume>
    <issue>1</issue>
    <elocation-id>010801</elocation-id>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>10</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>18</day>
        <month>12</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 The Authors</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>The Authors</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>Published by SPIE under a Creative Commons Attribution 4.0 Unported License. Distribution or reproduction of this work in whole or in part requires full attribution of the original publication, including its DOI.</license-p>
      </license>
    </permissions>
    <self-uri xlink:title="pdf" xlink:href="NPH_8_1_010801.pdf"/>
    <abstract>
      <title>Abstract.</title>
      <p><bold>Significance:</bold> An advanced understanding of optical design is necessary to create optimal systems but this is rarely taught as part of general curriculum. Compounded by the fact that professional optical design software tools have a prohibitive learning curve, this means that neither knowledge nor tools are easily accessible.</p>
      <p><bold>Aim:</bold> In this tutorial, we introduce a raytracing module for Python, originally developed for teaching optics with ray matrices, to simplify the design and optimization of optical systems.</p>
      <p><bold>Approach:</bold> This module is developed for ray matrix calculations in Python. Many important concepts of optical design that are often poorly understood such as apertures, aperture stops, and field stops are illustrated.</p>
      <p><bold>Results:</bold> The module is explained with examples in real systems with collection efficiency, vignetting, and intensity profiles. Also, the optical invariant, an important benchmark property for optical systems, is used to characterize an optical system.</p>
      <p><bold>Conclusions:</bold> This raytracing Python module will help improve the reader’s understanding of optics and also help them design optimal systems.</p>
    </abstract>
    <kwd-group>
      <title>Keywords:</title>
      <kwd>coding</kwd>
      <kwd>optical engineering</kwd>
      <kwd>imaging systems</kwd>
      <kwd>illumination</kwd>
    </kwd-group>
    <funding-group>
      <award-group id="sp1">
        <funding-source>Canadian Network for Research and Innovation in Machining Technology, Natural Sciences and Engineering Research Council of Canada<named-content content-type="fundref:id">https://doi.org/10.13039/501100002790</named-content></funding-source>
        <award-id>RGPIN-2020-06936</award-id>
        <award-id>CREATE 497040-2017</award-id>
      </award-group>
    </funding-group>
    <counts>
      <fig-count count="8"/>
      <table-count count="2"/>
      <ref-count count="18"/>
      <page-count count="19"/>
    </counts>
    <custom-meta-group>
      <custom-meta>
        <meta-name>running-head</meta-name>
        <meta-value>Pineau Noël et al.: Tools and tutorial on practical ray tracing for microscopy</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="sec1">
    <label>1</label>
    <title>Introduction</title>
    <p>Engineers and scientists operating in fields such as neurophotonics, remote sensing, medicine, or even industrial manufacturing are often tasked with building or modifying imaging systems for customized applications. They must often resort to expert advice from optical designers to obtain clear and quantitative answers to their specific optics problems. Optical designers, with their knowledge and specialized software tools such as Zemax, Oslo, or CODE V, can indeed provide these answers. However, third-party expert advice can be prohibitively expensive, difficult to interpret without basic knowledge, and can lead to sub-optimal solutions if the requirements are miscommunicated to the external consultant. For the general engineer, scientist, and especially for trainees, learning these professional software tools is often not an option because of the abundance of features targeted to advanced optical designers that end up confusing trainees and non-experts alike. Yet, there should be a solution, between simplified analytical solutions and expert tools that can help non-experts tackle moderately complicated problems by themselves to obtain quantitative answers. It is therefore the purpose of the present tutorial to provide both the knowledge and the tools for this audience.</p>
    <p>In this paper, we describe both optical design concepts and a raytracing module based on the ray matrix formalism (i.e., ABCD matrices) to characterize important aspects of real optical systems typically encountered by non-experts, such as the effect of finite-sized lenses and apertures. The motivation for this project and tutorial was borne out of teaching a second-year optics class where it became clear that students understood the formalism but were not always able to obtain quantitative answers to practical problems for the laboratory. This led to the creation of the present module to explain the calculations and to provide a straightforward method to characterize reasonably complex optical systems. Over its development cycle, it has found a niche in research labs when professional tools are not available. There are two guiding principles: simplicity of usage and clarity of implementation for teaching purposes. The module, therefore, aims to model and evaluate optical systems, characterize their properties, and identify their weaknesses from the perspective of a non-expert optical designer. As will be shown, the module is specifically designed to assess microscopes but can also be used to evaluate fiber-based devices or illumination devices.</p>
    <p>The outline of the present tutorial is therefore as follows. Sec. <xref rid="sec1" ref-type="sec">1</xref> presents the installation of the raytracing module with its documentation and is followed by a brief description of the ray matrix formalism in Sec. <xref rid="sec3" ref-type="sec">3</xref>. Section <xref rid="sec4" ref-type="sec">4</xref> describes how to use the formalism to consider the finite size of elements and identify the limiting components of any optical system. Then, Sec. <xref rid="sec5" ref-type="sec">5</xref> dives into the module and rapidly presents some of its main functionalities. Finally, Sec. <xref rid="sec6" ref-type="sec">6</xref> shows practical examples that should be of interest to the readers. This tutorial ends with a discussion and a brief conclusion at Secs. <xref rid="sec7" ref-type="sec">7</xref> and <xref rid="sec8" ref-type="sec">8</xref>, respectively.</p>
  </sec>
  <sec id="sec2">
    <label>2</label>
    <title>Raytracing Module</title>
    <p>The raytracing module is programmed in Python for several reasons. First, Python is widely available and used in science by beginners and experts alike. In addition, the ray-tracing formalism is particularly well suited to object-oriented software design, and the Python language offers very good support for such paradigm. Third, the Python community has developed many tools to support development, such as a straightforward and powerful documentation system from within the code when needed (docstring, Sphynx, readthedocs, and unit testing) and also simple distribution tools (GitHub and PyPI). Finally, while Python is an interpreted language (which simplifies development), it offers a reasonably high performance for scientific calculations (which favors its adoption).</p>
    <p>One can install (or upgrade) the raytracing module with the following in a Python command prompt:</p>
    <p>
      <monospace>pip install raytracing --upgrade</monospace>
    </p>
    <p>and learn the basics of this module by referring to the examples in Secs. <xref rid="sec5" ref-type="sec">5</xref> and <xref rid="sec6" ref-type="sec">6</xref>. A more detailed installation procedure is available<xref rid="r1" ref-type="bibr"><sup>1</sup></xref> including videos if needed.<xref rid="r2" ref-type="bibr"><sup>2</sup></xref> Finally, documentation that describes all the elements, functions, and details of this module is available online at Ref. <xref rid="r3" ref-type="bibr">3</xref>. The code is open source. We have followed the guidelines from Clean Code:<xref rid="r4" ref-type="bibr"><sup>4</sup></xref> clear implementation over high-performance implementation, documentation within the code when needed, and unit testing.</p>
  </sec>
  <sec id="sec3">
    <label>3</label>
    <title>Formalism</title>
    <sec id="sec3.1">
      <label>3.1</label>
      <title>Rays through Optical Elements</title>
      <p>For completeness, we start with a short summary of the ray matrix formalism that describes the propagation of a ray along an optical axis (<inline-formula><mml:math id="math1" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>) and how it is transformed by matrices representing optical elements. A ray at a certain position <inline-formula><mml:math id="math2" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> along the optical path is defined by a column vector as <disp-formula id="e001"><mml:math id="math3" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">r</mml:mi><mml:mo>≡</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>θ</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(1)</label></disp-formula>where <inline-formula><mml:math id="math4" display="inline" overflow="scroll"><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> is the height of the ray with respect to the optical axis and <inline-formula><mml:math id="math5" display="inline" overflow="scroll"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:math></inline-formula> is the angle that this ray makes with the optical axis. It is worth noting that there are other definitions of the ray<xref rid="r5" ref-type="bibr"><sup>5</sup></xref> that include the index of refraction directly in the ray definition, but these are not used here. In the raytracing module, a ray will be an instance of <monospace>Ray</monospace>, and a collection of rays will be an instance of <monospace>Rays</monospace>.</p>
      <p>The ray matrix formalism allows a ray to be transformed from one reference plane to another through different optical elements, all represented by <inline-formula><mml:math id="math6" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> matrices of the form: <disp-formula id="e002"><mml:math id="math7" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">M</mml:mi><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>A</mml:mi></mml:mtd><mml:mtd><mml:mi>B</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>C</mml:mi></mml:mtd><mml:mtd><mml:mi>D</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>]</mml:mo></mml:mrow></mml:math><label>(2)</label></disp-formula>Such a matrix transforms a ray with a left multiplication: a ray <inline-formula><mml:math id="math8" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow></mml:math></inline-formula> that <inline-formula><mml:math id="math9" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="bold">M</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">M</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">M</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">M</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> will be transformed into <inline-formula><mml:math id="math10" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> by the sequential left application of the matrices representing the sequence of elements (note the order of multiplication): <disp-formula id="e003"><mml:math id="math11" display="block" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi mathvariant="bold">M</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi mathvariant="bold">r</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="bold">Mr</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(3)</label></disp-formula>which results in <disp-formula id="e004"><mml:math id="math12" display="block" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>y</mml:mi><mml:mo>+</mml:mo><mml:mi>B</mml:mi><mml:mi>θ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(4)</label></disp-formula><disp-formula id="e005"><mml:math id="math13" display="block" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mi>y</mml:mi><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mi>θ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(5)</label></disp-formula>where <inline-formula><mml:math id="math14" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="math15" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="math16" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="math17" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> are the elements of the transfer matrix and the necessary paraxial approximation, i.e., <inline-formula><mml:math id="math18" display="inline" overflow="scroll"><mml:mrow><mml:mi>sin</mml:mi><mml:mtext> </mml:mtext><mml:mi>θ</mml:mi><mml:mo>≈</mml:mo><mml:mi>θ</mml:mi></mml:mrow></mml:math></inline-formula>, is used: the consequences of foregoing the paraxial approximation would be significant and will be addressed in the discussion. The exact form of each matrix representing optical elements is obtained using Snell law and geometrical considerations.<xref rid="r6" ref-type="bibr"><sup>6</sup></xref> A list of the most important ray matrices is shown in <xref rid="f1" ref-type="fig">Fig. 1</xref>. The optical system is modeled by appending the desired matrices (e.g., <monospace>Space, Lens, System4f</monospace>) to an <monospace>ImagingPath</monospace> (see Sec. <xref rid="sec5" ref-type="sec">5</xref> for more details).</p>
      <fig position="float" id="f1">
        <label>Fig. 1</label>
        <caption>
          <p>ABCD matrices of different optical elements within the paraxial approximation.<xref rid="r6" ref-type="bibr"><sup>6</sup></xref></p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g001" position="float"/>
      </fig>
    </sec>
    <sec id="sec3.2">
      <label>3.2</label>
      <title>Useful Properties</title>
      <p>With this knowledge of the formalism, important properties can be extracted for any optical system:</p>
      <list list-type="simple">
        <list-item>
          <label>1.</label>
          <p>When <inline-formula><mml:math id="math19" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, we have an imaging condition where an object at the entrance is imaged at the exit plane since a ray originating from a height <inline-formula><mml:math id="math20" display="inline" overflow="scroll"><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> reaches a height that is independent of the angle of emission, i.e., <inline-formula><mml:math id="math21" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> not <inline-formula><mml:math id="math22" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>y</mml:mi><mml:mo>+</mml:mo><mml:mi>B</mml:mi><mml:mi>θ</mml:mi></mml:mrow></mml:math></inline-formula>. Naturally, in this situation, <inline-formula><mml:math id="math23" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula> is the transverse magnification and <inline-formula><mml:math id="math24" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> is the angular magnification [<xref rid="f2" ref-type="fig">Fig. 2(a)</xref>]. This property of an element or a group of elements can be verified in an imaging path with this module using <monospace>isImaging</monospace>.</p>
        </list-item>
        <list-item>
          <label>2.</label>
          <p>The effective focal distance at the back of any system is <inline-formula><mml:math id="math25" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>f</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> [<xref rid="f2" ref-type="fig">Fig. 2(b)</xref>], and it can be obtained for any element with <monospace>effectiveFocalLengths</monospace>. In general, the front and back focal lengths (BFLs) are different if the media on either side are different, but in many cases of interest, they will be identical.</p>
        </list-item>
        <list-item>
          <label>3.</label>
          <p>Focal distances are measured from principal planes, which are planes of unity magnification in any system where all the focusing power is concentrated. They are located <inline-formula><mml:math id="math26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:msub><mml:mi>PP</mml:mi><mml:mi mathvariant="normal">f</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">/</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mi>D</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> in front, and <inline-formula><mml:math id="math27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:msub><mml:mi>PP</mml:mi><mml:mi mathvariant="normal">b</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>A</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> after the input and output reference planes [<xref rid="f2" ref-type="fig">Fig. 2(b)</xref>]. The position of the two principal planes of any components can be obtained using <monospace>principalPlanePositions</monospace> in the module.</p>
        </list-item>
        <list-item>
          <label>4.</label>
          <p>Finally, it can be shown that for any two rays <inline-formula><mml:math id="math28" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="math29" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>, the following quantity <disp-formula id="e006"><mml:math id="math30" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(6)</label></disp-formula>at a given point is a constant throughout the system and is called the optical invariant [<xref rid="f2" ref-type="fig">Fig. 2(c)</xref>]. It can be calculated in a system with <monospace>opticalInvariant(ray1,ray2)</monospace> for any two rays (more details in Sec. <xref rid="sec5" ref-type="sec">5</xref>). When the principal and axial rays are used (defined below), the optical invariant is maximal and is rather called the Lagrange invariant noted by <inline-formula><mml:math id="math31" display="inline" overflow="scroll"><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:math></inline-formula>, obtainable with <monospace>lagrangeInvariant()</monospace>.<xref rid="r7" ref-type="bibr"><sup>7</sup></xref>:</p>
        </list-item>
      </list>
      <p>It is already possible to obtain, or rediscover, interesting results. For instance, it is fairly straightforward to obtain Gauss’s law of imaging by modeling an object <inline-formula><mml:math id="math32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>o</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in front of a thin lens of focal <inline-formula><mml:math id="math33" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula>: the position of the image is obtained when the transfer matrix that includes the propagation by a distance <inline-formula><mml:math id="math34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> after the lens has <inline-formula><mml:math id="math35" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Another example is the Lensmaker equation that describes the focal distance of a lens using the radii of the two curved surfaces and the index of refraction of the material: one can model the interfaces and the material, then obtain the focal distance with <inline-formula><mml:math id="math36" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">/</mml:mo><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula>. There are many other examples that will not be discussed in detail here, but one can read more about them if needed.<xref rid="r6" ref-type="bibr"><sup>6</sup></xref><sup>,</sup><xref rid="r8" ref-type="bibr"><sup>8</sup></xref><sup>,</sup><xref rid="r9" ref-type="bibr"><sup>9</sup></xref><sup>,</sup><xref rid="r10" ref-type="bibr"><sup>10</sup></xref> It can therefore be appreciated that despite its simplicity, the formalism recovers all known results from paraxial optics and will be sufficient to model most optical systems. The only aspect we have not considered yet is the effect of apertures that can block rays: this is considered in the next section.</p>
      <fig position="float" id="f2">
        <label>Fig. 2</label>
        <caption>
          <p>Illustration of a ray passing through an optical system defined by a generic ABCD matrix, dotted line is the optical axis. (a) The object (blue arrow) is imaged (red arrow) on the other side of the optical system, i.e., to its conjugate plane. (b) A ray parallel to the optical axis will go through the focal plane. (c) The input ray height <inline-formula><mml:math id="math37" display="inline" overflow="scroll"><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> and angle <inline-formula><mml:math id="math38" display="inline" overflow="scroll"><mml:mrow><mml:mi>θ</mml:mi></mml:mrow></mml:math></inline-formula> have changed to <inline-formula><mml:math id="math39" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="math40" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, respectively, according to the ABCD matrix. The product <inline-formula><mml:math id="math41" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:msup><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mi>θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is constant everywhere in the system.</p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g002" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec id="sec4">
    <label>4</label>
    <title>Apertures</title>
    <p>The ray matrix formalism is surprisingly complete and sufficient for many tasks. However, it does not consider the single most important limitation of real instrumentation: the finite sizes of elements or aperture. To consider the finite size of the optics in ray propagation, the height of the rays must be checked at each point along the propagation axis to make sure it is not blocked. To do so, tracing the rays one by one, i.e., ray tracing is necessary to identify those limiting optics, which can be done with <monospace>trace()</monospace> or <monospace>traceThrough()</monospace>, or other similar functions. Using this tracing procedure enables the identification of two essential apertures characterizing an optical system, the aperture stop (AS), and the field stop (FS).</p>
    <p>The AS is the physical aperture that limits the acceptance cone of light entering the system from a point on axis.<xref rid="r8" ref-type="bibr"><sup>8</sup></xref> Hence, a properly located AS will maximize the light collection and a misplaced or improperly sized AS will reduce it. Any ray from the object that hits the edge of AS is called a marginal ray, and the unique ray originating on axis that hits the edge of AS is called the axial ray.<xref rid="r11" ref-type="bibr"><sup>11</sup></xref> Many authors<xref rid="r12" ref-type="bibr"><sup>12</sup></xref><sup>,</sup><xref rid="r13" ref-type="bibr"><sup>13</sup></xref> define this ray as the marginal ray, but in this paper, this term is rather employed to define any ray passing at the maximal possible height of AS, regardless of the starting point on the object. All of these rays are shown in <xref rid="f3" ref-type="fig">Fig. 3(a)</xref>. To find the AS in an optical system, one can use the ABCD matrices to find the height <inline-formula><mml:math id="math42" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of a ray at all positions <inline-formula><mml:math id="math43" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>, then divide it by the real diameter <inline-formula><mml:math id="math44" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> at <inline-formula><mml:math id="math45" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula>. The AS location is where the ratio <inline-formula><mml:math id="math46" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> has the highest value.<xref rid="r6" ref-type="bibr"><sup>6</sup></xref> In the module, the position and diameter of the AS in an imaging path can be obtained using <monospace>apertureStop()</monospace>. In addition, two functions are defined to obtain the axial and marginal rays (i.e., their heights and angles) with <monospace>axialRay()</monospace> and <monospace>marginalRays()</monospace>, respectively.</p>
    <fig position="float" id="f3">
      <label>Fig. 3</label>
      <caption>
        <p>Simple system made of a lens and an aperture presenting the propagation of different rays. (a) presents the axial and marginal rays. The axial ray has the highest possible angle. Thus, any other ray with a greater angle cannot make it to the image plane (solid dark arrow). (b) presents the principal ray and the chief ray. Any ray starting with a greater height than the principal ray hits FS and therefore is not included in the image formation.</p>
      </caption>
      <graphic xlink:href="NPh-008-010801-g003" position="float"/>
    </fig>
    <p>Second, the FS is the physical aperture that limits the field-of-view (FOV, at the object) and the image size (at the image). To find the location of the FS, one traces a ray from different heights passing through the center of the AS until it gets blocked by an aperture, which is labeled the FS. The position and the diameter of FS can be found using <monospace>fieldStop()</monospace> in an imaging path. It should normally be the finite size of the sensor located at the camera,<xref rid="r8" ref-type="bibr"><sup>8</sup></xref> as presented in <xref rid="f3" ref-type="fig">Figs. 3(a)</xref> and <xref rid="f3" ref-type="fig">3(b)</xref>. When FS appears anywhere except at the camera, it will produce vignetting on the final image, which is the presence of dark blur, indicating that part of the cone of light from a source point does not reach the sensor. Even if the FS is at the image plane, vignetting can still occur if the diameter of a lens in the system is too small<xref rid="r12" ref-type="bibr"><sup>12</sup></xref> (see example Sec. <xref rid="sec6.3" ref-type="sec">6.3</xref>). The presence of vignetting in a system is the most common error by trainees and can readily be identified with the module.</p>
    <p>Any ray from the object going through the center of AS is called a chief ray, and the last chief ray that is not blocked by FS is called the principal ray,<xref rid="r11" ref-type="bibr"><sup>11</sup></xref> as shown in <xref rid="f3" ref-type="fig">Fig. 3(b)</xref>. While some authors use the term chief ray instead of principal ray,<xref rid="r12" ref-type="bibr"><sup>12</sup></xref><sup>,</sup><xref rid="r13" ref-type="bibr"><sup>13</sup></xref> it is used in this paper to define any ray still passing through the center of AS but starting at any point on the object [<xref rid="f3" ref-type="fig">Fig. 3(b)</xref>]. More specifically, the origin of the principal ray defines the field of view. Both of these rays can be obtained with <monospace>chiefRay()</monospace> and <monospace>principalRay()</monospace>. It is worth noting that AS position in an optical system must be known to find FS. In closing this section on the formalism, it is interesting to know that the principal and axial rays are the only two rays needed to completely characterize an optical system: any ray can be expressed as a linear combination of these two rays (see Sec. <xref rid="sec6.3" ref-type="sec">6.3</xref> where this is used to discuss efficiency). As can be appreciated, finding the AS and FS can become tedious if done manually, however, it is perfectly adapted to a computer program. We will now dive into the module and illustrate with examples how to obtain all optical properties dependent on AS and FS, which is critical to determine the real-life performance of any optical system.</p>
  </sec>
  <sec id="sec5">
    <label>5</label>
    <title>Module Overview</title>
    <p>The Python raytracing module is an implementation of the ray matrix formalism discussed previously. This section introduces its main features and functionalities. Specific functions from the module are typed in monospace fonts such as <monospace>System4f()</monospace>. Complete code and documentation are available online.<xref rid="r3" ref-type="bibr"><sup>3</sup></xref></p>
    <sec id="sec5.1">
      <label>5.1</label>
      <title>Creation of an Optical Path</title>
      <p>The first step is to create an optical path using <monospace>ImagingPath()</monospace>. Many elements, such as <monospace>Lens()</monospace>, <monospace>Space()</monospace>, <monospace>Aperture()</monospace>, and more, are defined and can be added to the imaging path using <monospace>append()</monospace>. As an example use, a simple 4f relay is presented in the following to show how to create an imaging path in raytracing and how to add elements.</p>
      <p>
        <monospace><bold>from</bold> raytracing <bold>import</bold> *</monospace>
      </p>
      <p>
        <monospace>path = ImagingPath()</monospace>
      </p>
      <p>
        <monospace>path.label="Simple example"</monospace>
      </p>
      <p>
        <monospace>path.append(Space(d=50))</monospace>
      </p>
      <p>
        <monospace>path.append(Lens(f=50, diameter=25, label="First lens"))</monospace>
      </p>
      <p>
        <monospace>path.append(Space(d=100))</monospace>
      </p>
      <p>
        <monospace>path.append(Lens(f=50, diameter=25, label="Second lens"))</monospace>
      </p>
      <p>
        <monospace>path.append(Space(d=50))</monospace>
      </p>
      <p>
        <monospace>
          <italic># For convenience, the creation of a 4f relay can be written as:</italic>
        </monospace>
      </p>
      <p>
        <monospace>
          <italic># path.append(System4f(f1=50, f2=50, diameter1=25, diameter2=25))</italic>
        </monospace>
      </p>
      <p>
        <monospace>
          <italic># Lenses from vendors can be added with:</italic>
        </monospace>
      </p>
      <p>
        <monospace>
          <italic># path.append(olympus.XLUMPlanFLN20X())</italic>
        </monospace>
      </p>
      <p>
        <monospace>
          <italic># path.append(thorlabs.AC254_100_A())</italic>
        </monospace>
      </p>
      <p>
        <monospace>path.display()</monospace>
      </p>
      <p>Many optical elements are already incorporated in the module and can therefore be included in any imaging path. For example, <italic>olympus.py</italic> contains many objectives from Olympus and <italic>thorlabs.py</italic> has achromatic lenses from Thorlabs. Similarly, for convenience <monospace>System2f()</monospace> for propagation focus-to-focus and <monospace>System4f()</monospace> for a 4f-relay are defined in the module and used in the remaining of this tutorial.</p>
      <p>As for the <monospace>display</monospace> function, it depicts the path and the traced rays starting at the object plane via an interface, where either rays from an object or the principal and axial rays can be shown as it is discussed next.</p>
    </sec>
    <sec id="sec5.2">
      <label>5.2</label>
      <title>Visualization</title>
      <p>Four graphical options that convey different and complementary information are available and shown in <xref rid="f4" ref-type="fig">Fig. 4</xref>. As was shown before, once the imaging path is defined, all the components can be depicted using <monospace>display()</monospace> [shown in <xref rid="f4" ref-type="fig">Fig. 4(a)</xref>] with default input rays. <xref rid="f4" ref-type="fig">Figure 4(b)</xref> shows that a single component such as a thick lens or a commercial lens can be displayed with the BFL, front focal length (FFL), and any planes of interest. If desired, user-provided rays or ray distributions can be used to compute the intensity profile at any point in an optical system using a Monte Carlo algorithm, as shown in <xref rid="f4" ref-type="fig">Fig. 4(c)</xref>. Finally, <monospace>reportEfficiency()</monospace> enables the user to study the vignetting caused by the inappropriate diameters of the lenses and apertures in an imaging path [an example is shown in <xref rid="f4" ref-type="fig">Fig. 4(d)</xref>]. These options are discussed next but specific examples are presented in the examples Sec. <xref rid="sec6" ref-type="sec">6</xref>.</p>
      <fig position="float" id="f4">
        <label>Fig. 4</label>
        <caption>
          <p>Some of the main features of the raytracing module overview. A 4f-system is defined using a thin lens and a Thorlabs doublet lens for which we (a) trace the imaging path; (b) display element properties for the Thorlabs lens AC-254-050-A where <inline-formula><mml:math id="math47" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>V</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> represent the front and back vertices and <inline-formula><mml:math id="math48" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are the front and back principal planes; (c) show the ray count distribution for the rays at the output; and (d) display its vignetting graph.</p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g004" position="float"/>
      </fig>
      <sec id="sec5.2.1">
        <label>5.2.1</label>
        <title>Display</title>
        <p>Used without any argument on an <monospace>ImagingPath</monospace>, <monospace>display</monospace> exhibits three ray groups in green, red, and blue, each group containing three rays, with an object corresponding to the FOV of the system as can be seen in <xref rid="f4" ref-type="fig">Fig. 4(a)</xref>. It is possible for the user to adjust the height and position of the object, and the number of displayed rays using the convenience function <monospace>displayWithObject</monospace> instead of <monospace>display</monospace>:</p>
        <p>(...)</p>
        <p>
          <monospace>path.displayWithObject(diameter=5, fanNumber=4, rayNumber=2)</monospace>
        </p>
        <p>More than one source of rays may be traced using <monospace>display(raysList=[...])</monospace> and adding as many <monospace>ObjectRays</monospace> and <monospace>LampRays</monospace> as desired [collections of rays with certain properties such as diameter, numerical aperture (NA), and angular spread]. An example of this functionality is presented in Sec. <xref rid="sec6.2" ref-type="sec">6.2</xref>. Used on a component (e.g., <monospace>thorlabs.AC254_050_A().display()</monospace>), it will show the important properties.</p>
      </sec>
      <sec id="sec5.2.2">
        <label>5.2.2</label>
        <title>Ray collections and histograms</title>
        <p>The relative output intensity can be obtained by tracing a collection of rays with a given angular distribution, such as a random uniform distribution or a random Lambertian distribution.<xref rid="r14" ref-type="bibr"><sup>14</sup></xref> These rays can then be traced through an optical system to obtain the output distribution using <monospace>traceManyThrough()</monospace> or <monospace>traceThrough()</monospace>, with the following code (Sec. <xref rid="sec6.3" ref-type="sec">6.3</xref> show an example):</p>
        <p>
          <monospace>
            <italic># RandomUniformRays Example</italic>
          </monospace>
        </p>
        <p>
          <monospace><bold>from</bold> raytracing <bold>import</bold> *</monospace>
        </p>
        <p>
          <monospace>
            <italic># define a list of rays with uniform distribution</italic>
          </monospace>
        </p>
        <p>
          <monospace>inputRays = RandomUniformRays(yMin = -5,</monospace>
        </p>
        <p>
          <monospace>                 yMax = 5,</monospace>
        </p>
        <p>
          <monospace>                 maxCount = 1000000,</monospace>
        </p>
        <p>
          <monospace>                 thetaMax = 0.5,</monospace>
        </p>
        <p>
          <monospace>                 thetaMin = -0.5)</monospace>
        </p>
        <p>
          <monospace>inputRays.display()</monospace>
        </p>
        <p>
          <monospace>
            <italic># Define path elsewhere</italic>
          </monospace>
        </p>
        <p>
          <monospace>outputRays = path.traceManyTrough(inputRays)</monospace>
        </p>
        <p>
          <monospace>outputRays.display()</monospace>
        </p>
        <p>It is worth mentioning that since the rays are randomly emitted with <monospace>RandomUniformRays()</monospace> and <monospace>RandomLambertianRays()</monospace>, the results and profiles will slightly change every time the code is run.</p>
      </sec>
      <sec id="sec5.2.3">
        <label>5.2.3</label>
        <title>Efficiency and vignetting</title>
        <p>Displaying the system helps identify the position of the apertures but it is often necessary to better quantify the design in addition to visualizing it. The module makes use of the fact that any ray in the system can be represented by a linear combination of two other rays 1 and 2: <disp-formula id="e007"><mml:math id="math49" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(7)</label></disp-formula><disp-formula id="e008"><mml:math id="math50" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mn>21</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:msub><mml:mrow><mml:mi>θ</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><label>(8)</label></disp-formula>where <inline-formula><mml:math id="math51" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the Lagrange invariant between ray <inline-formula><mml:math id="math52" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="math53" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> [Eq. (6)]. When rays 1 and 2 are the principal and axial rays, the coefficients <inline-formula><mml:math id="math54" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>I</mml:mi><mml:mn>32</mml:mn></mml:msub><mml:mi>H</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="math55" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:msub><mml:mi>I</mml:mi><mml:mn>13</mml:mn></mml:msub><mml:mi>H</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> are of great importance, because their values can be used to determine if a ray is vignetted or simply blocked, identifying the element causing vignetting in a system. Indeed, if <inline-formula><mml:math id="math56" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="math57" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> are higher than one for a certain ray, it is expected that this ray is blocked. If they are less than one, but the ray is still blocked, it means an element in the system causes vignetting, therefore limiting the invariant. In the raytracing module, using <monospace>reportEfficiency()</monospace> on an <monospace>ImagingPath</monospace> presents all of those characteristics and even more, such as the size of the FOV, the position of the element causing vignetting, and the NA at the object plane. A more complete example of using the invariant is described in Sec. <xref rid="sec6" ref-type="sec">6</xref>.</p>
      </sec>
    </sec>
  </sec>
  <sec id="sec6">
    <label>6</label>
    <title>Practical Examples Solved with Module</title>
    <sec id="sec6.1">
      <label>6.1</label>
      <title>Confocal Laser Scanning Microscope</title>
      <p>The main components of any confocal laser scanning microscope (CLSM) are a pinhole, conjugated to the illumination focal spot to block the out of focus light, and a set of mirrors to scan the laser beam across the sample.<xref rid="r15" ref-type="bibr"><sup>15</sup></xref> Ideally, the pinhole matches the size of the focal spot at the sample to produce appropriate optical sectioning.<xref rid="r15" ref-type="bibr"><sup>15</sup></xref> The scanning mirrors are at the focus of the scan lens to create a raster scan at the object. We can calculate optical sectioning as a function of pinhole size and show the covered FOV by the scanning components of the following CLSM<xref rid="r16" ref-type="bibr"><sup>16</sup></xref> (<xref rid="f5" ref-type="fig">Fig. 5</xref>). At first, the importance of the appropriate pinhole size in the final image formation is shown by sending a large number of rays in the optical system and computing how many make it through the pinhole for different focal spot positions. The output is a graph that presents the transmission efficiency, i.e., the number of output rays at the pinhole, divided by the number of input rays, as a function of the position of the focal spot (<xref rid="f6" ref-type="fig">Fig. 6</xref>). The solid curve in <xref rid="f6" ref-type="fig">Fig. 6(a)</xref> shows that, with the ideal pinhole size, the only position at which the transmission efficiency is optimal is at the focal plane of the objective, yielding optimal sectioning.</p>
      <fig position="float" id="f5">
        <label>Fig. 5</label>
        <caption>
          <p>CLSM platform and optical design: In this CLSM, the spinning polygonal mirror and the galvanometer scanner mirror perform raster scanning at the sample and the 4f systems are used to relay the light reflected from the scanning mirror to the sample.<xref rid="r16" ref-type="bibr"><sup>16</sup></xref></p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g005" position="float"/>
      </fig>
      <fig position="float" id="f6">
        <label>Fig. 6</label>
        <caption>
          <p>(a) Transmission efficiency according to the position in depth relative to the ideal position (0) for three different pinhole sizes. (b) Graph showing scanning position according to the scan angle of the polygon mirror.</p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g006" position="float"/>
      </fig>
      <p>Moreover, the covered horizontal FOV of the polygonal mirror according to the scan angle at the polygon plane is determined using the raytracing module, as it is shown in <xref rid="f6" ref-type="fig">Fig. 6(b)</xref>. In this part of the example, the object is considered to be the laser beam at the polygonal mirror plane. Therefore, only the path from the polygonal mirror to the sample is considered. <xref rid="f6" ref-type="fig">Figure 6(b)</xref> shows that the polygon mirror produces a straight line of <inline-formula><mml:math id="math58" display="inline" overflow="scroll"><mml:mrow><mml:mo form="prefix">≈</mml:mo><mml:mn>704</mml:mn><mml:mtext>  </mml:mtext><mml:mi>nm</mml:mi></mml:mrow></mml:math></inline-formula> of length in that optical system using the scan angle between 10° and <inline-formula><mml:math id="math59" display="inline" overflow="scroll"><mml:mrow><mml:mo form="prefix">−</mml:mo><mml:mn>10</mml:mn><mml:mo>°</mml:mo></mml:mrow></mml:math></inline-formula> at the polygon plane. It is possible to use the same method to determine the vertical FOV using the scan angle of the galvo mirror. The code related to the optimal pinhole size and scanning position has been written in Sec. <xref rid="sec9.1" ref-type="sec">9.1</xref>.</p>
    </sec>
    <sec id="sec6.2">
      <label>6.2</label>
      <title>Köhler Illumination</title>
      <p>The purpose of Köhler illumination is to provide a uniform light intensity at the sample.<xref rid="r15" ref-type="bibr"><sup>15</sup></xref> The opposite illumination system is called critical illumination whereby the light source is imaged onto the specimen.<xref rid="r15" ref-type="bibr"><sup>15</sup></xref> The main element to design Köhler illumination is an extra lens, i.e., the collector lens, close to the light source, which leads to uniformity by way of imaging the Fourier transform of the light source profile onto the specimen instead of the light source profile itself. This example verifies the design of Köhler illumination with the raytracing module, as it is shown in <xref rid="f7" ref-type="fig">Fig. 7</xref>. One can see that the conjugate planes of the light source do not overlay with the conjugate planes of the sample, showing that the light source is not imaged on the object and the object is also illuminated with parallel uniform light. The code of this example is available in Sec. <xref rid="sec9.2" ref-type="sec">8.2</xref>.</p>
      <fig position="float" id="f7">
        <label>Fig. 7</label>
        <caption>
          <p>Scheme of a conventional widefield microscope with the light source path (red) and the sample path (dashed green) with a Kohler illumination.</p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g007" position="float"/>
      </fig>
    </sec>
    <sec id="sec6.3">
      <label>6.3</label>
      <title>Widefield and Multiphoton Microscopy</title>
      <p>As presented in Secs. <xref rid="sec3" ref-type="sec">3</xref> and <xref rid="sec5" ref-type="sec">5</xref>, the Lagrange invariant, <inline-formula><mml:math id="math60" display="inline" overflow="scroll"><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:math></inline-formula>, is a constant related to the collection efficiency of an optical system and can be used to find the limiting element(s) in an optical system.<xref rid="r12" ref-type="bibr"><sup>12</sup></xref> The locations of AS and FS in optical systems, such as a widefield microscope<xref rid="r15" ref-type="bibr"><sup>15</sup></xref> or multiphoton microscope,<xref rid="r17" ref-type="bibr"><sup>17</sup></xref> allow us to validate their designs. Optimizing both systems is possible with the raytracing module: an example of a widefield microscope is provided in this section while an example of a multiphoton microscope showing the detector size importance in its design is provided in (<ext-link xlink:href="https://github.com/DCC-Lab/RayTracing/tree/master/examples" ext-link-type="uri">https://github.com/DCC-Lab/RayTracing/tree/master/examples</ext-link>). The example presents different optical systems in which AS and FS are in different positions using different sizes of lenses. This example shows how the locations of AS and FS, determined by the size of the lenses, affect the number of rays that can reach the image plane.</p>
      <p>As it is shown in <xref rid="f8" ref-type="fig">Fig. 8(a)</xref>, AS is at the first lens and FS is at the second one. Both lenses in this system are the same and too small, so the principal ray (green line) does not start at the top edge of the object and not all of the object is going to be imaged. Therefore, the output profile in <xref rid="f8" ref-type="fig">Fig. 8(b)</xref> includes vignetting at the image plane. The presence of red dots on the vignetting plot of <xref rid="f8" ref-type="fig">Fig. 8(c)</xref> verifies this too. <xref rid="f8" ref-type="fig">Figure 8(d)</xref> shows a similar 4f system while the second lens is smaller than the first one. AS is at the second lens and FS is at the camera. The output profile in <xref rid="f8" ref-type="fig">Figs. 8(b)</xref> and <xref rid="f8" ref-type="fig">8(e)</xref> show that there is no vignetting at the image plane, but the small number of rays reaching the image plane at each height could be improved by optimizing the location of the AS in the system.</p>
      <fig position="float" id="f8">
        <label>Fig. 8</label>
        <caption>
          <p>(a) The 4f system where <inline-formula><mml:math id="math61" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Both lenses are too small, so the AS is at the first lens and the FS is at the second lens, so not all of the object is going to be imaged. (b) Transmission efficiency according to the height of the detected ray; (c) the corresponding vignetting plot. The red dots in the figure represent vignetting happened by poorly placed FS. (d) 4f system where <inline-formula><mml:math id="math62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&gt;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> Thus, the AS is at the second lens and FS is at the camera. (e) The transmission efficiency according to the height of the detected ray and (f) the corresponding vignetting plot. There is no vignetting in this optical system, but the number of transmitted rays is low because of the suboptimal AS at the second lens. (g) The 4f system where <inline-formula><mml:math id="math63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Both lenses are big enough, so the first lens is the AS and the camera is the FS. (h) The transmission efficiency according to the height of the detected ray and (i) the corresponding vignetting plot. The number of transmitted rays is high contrary to the <xref rid="f8" ref-type="fig">Fig. 8(f)</xref> because of the better positioning of the AS and FS.</p>
        </caption>
        <graphic xlink:href="NPh-008-010801-g008" position="float"/>
      </fig>
      <p>Finally, the last optical path in <xref rid="f8" ref-type="fig">Fig. 8(g)</xref> contains two different lenses where the first one is smaller. The first lens is AS and the camera is FS. The output profile in <xref rid="f8" ref-type="fig">Fig. 8(h)</xref> shows that more than 12,000 rays are detected at each height at the image plane compared to 8000 in <xref rid="f8" ref-type="fig">Fig. 8(b)</xref>. In addition, there are much more green dots present in <xref rid="f8" ref-type="fig">Fig. 8(i)</xref> showing that more rays are detected at the image plane and verifying its assembly. The code of this example is available in Sec. <xref rid="sec9.3" ref-type="sec">9.3</xref>.</p>
    </sec>
  </sec>
  <sec id="sec7">
    <label>7</label>
    <title>Discussion and Outlook</title>
    <p>This tutorial presents the main features of the ray matrix formalism, in combination with a useful Python module to help visualize optical systems and to understand how they behave within the paraxial approximation. Although the paraxial approximation (<inline-formula><mml:math id="math64" display="inline" overflow="scroll"><mml:mrow><mml:mi>sin</mml:mi><mml:mtext> </mml:mtext><mml:mi>θ</mml:mi><mml:mo>≈</mml:mo><mml:mi>θ</mml:mi></mml:mrow></mml:math></inline-formula>) introduced early in the formalism may appear unnecessary at first sight, it is, in fact, essential. Unbeknown to many of us, the exact vector expression to calculate a refracted ray from an incident ray at any interface is nonlinear in the cosine of the incident angle.<xref rid="r11" ref-type="bibr"><sup>11</sup></xref> The paraxial approximation provides a simpler linear description of rays and optical elements that makes discussions of designs easier by relying on only a few simple concepts, all while being valid close to the axis even in complex systems. In addition, the transfer matrix method central to this formalism becomes very convenient to study general behaviors without focusing too much on the details. On the other hand, without the paraxial approximation, many terms such as focal planes, cardinal points, or magnification cease to be well-defined concepts. Another consequence is that the description of optical elements interfaces would now require a refined description of the surface profile beyond the simple spherical approximation, which may not always be available, and disregarding this detail would defeat the purpose of neglecting the paraxial approximation in the first place. For this reason, the ray matrix formalism always makes use of the paraxial approximation. See the very complete and very approachable book by Kloos for an excellent discussion of its necessity in its introductory chapter.<xref rid="r11" ref-type="bibr"><sup>11</sup></xref></p>
    <p>This Python module can be used to design and optimize a system before building it, but it can also be used to validate an already built optical system. To build a realistic system, many optical elements included in the module (e.g., simple and complex lenses, dielectric interface but also commercial lenses) can be combined to model the system under study. The ABCD transfer matrix for each element describes the transformation of a ray between two reference planes.<xref rid="r6" ref-type="bibr"><sup>6</sup></xref> Common properties of the system such as focal distances, conjugate planes, magnification, and principal planes are provided by methods in this object-oriented design.</p>
    <p>Apertures are not formally included in the ray matrix formalism because the blocking of a ray is not a linear transformation that can be expressed with a matrix transformation. Indeed, the apertures in the imaging path limit the image size and the amount of light that reaches the image plane. Therefore, it is important to consider them when modeling and building optical systems. With the simple addition of apertures with ray tracing, a wealth of information about the system becomes available, most importantly AS and FS. Although finding AS and FS in simple systems is straightforward, the presence of multiple lenses in a system makes it challenging to find their location without a noticeable amount of tedious calculations. The raytracing module simplifies the calculation of the positions and diameters of AS and FS. The impact of vignetting on the output profile can also be evaluated to help identify the limiting apertures, opening the door to further optimization.</p>
    <p>Although the given examples are intended to be inclusive, many other things can be done: it is possible to extract the final wavefront of a beam originating from a given point or to perform resonator studies with Gaussian beams since they can be modeled with the same formalism.<xref rid="r18" ref-type="bibr"><sup>18</sup></xref> All the functions and their details (API reference) are accessible to all users online at Ref. <xref rid="r3" ref-type="bibr">3</xref>. Below is a list of key classes and useful functions to help getting started with raytracing (<xref rid="t001" ref-type="table">Tables 1</xref> and <xref rid="t002" ref-type="table">2</xref>). In addition, many well-known lenses and objectives from Thorlabs, Edmund Optics, Nikon, and Olympus or special elements such as an axicon with its apex angle are defined and can be used whenever needed.</p>
    <table-wrap position="float" id="t001">
      <label>Table 1</label>
      <caption>
        <p>Useful classes of the raytracing module.</p>
      </caption>
      <!--OASIS TABLE HERE-->
      <table frame="hsides" rules="groups">
        <colgroup>
          <col/>
          <col align="left"/>
        </colgroup>
        <thead>
          <tr>
            <th valign="top">Classes</th>
            <th align="left" valign="top">Descriptions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <monospace>Ray()</monospace>
            </td>
            <td align="left">A light ray as transformed by ABCD matrices</td>
          </tr>
          <tr>
            <td>
              <monospace>Rays()</monospace>
            </td>
            <td align="left">A group of rays</td>
          </tr>
          <tr>
            <td>
              <monospace>Matrix()</monospace>
            </td>
            <td align="left">General ABCD matrix from which all elements are derived</td>
          </tr>
          <tr>
            <td>
              <monospace>Aperture()</monospace>
            </td>
            <td align="left">An aperture of finite diameter</td>
          </tr>
          <tr>
            <td>
              <monospace>Lens()</monospace>
            </td>
            <td align="left">A thin lens of focal <inline-formula><mml:math id="math65" display="inline" overflow="scroll"><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula></td>
          </tr>
          <tr>
            <td>
              <monospace>Space()</monospace>
            </td>
            <td align="left">Free space of length <inline-formula><mml:math id="math66" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></td>
          </tr>
          <tr>
            <td>
              <monospace>ImagingPath()</monospace>
            </td>
            <td align="left">Sequence of ABCD matrices with an object at the front</td>
          </tr>
          <tr>
            <td>
              <monospace>RandomUniformRays()</monospace>
            </td>
            <td align="left">A list of random rays with Uniform distribution</td>
          </tr>
          <tr>
            <td>
              <monospace>RandomLambertianRays()</monospace>
            </td>
            <td align="left">A list of random rays with Lambertian distribution</td>
          </tr>
          <tr>
            <td>
              <monospace>GaussianBeam()</monospace>
            </td>
            <td align="left">A coherent laser beam</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="t002">
      <label>Table 2</label>
      <caption>
        <p>Useful functions of the raytracing module.</p>
      </caption>
      <!--OASIS TABLE HERE-->
      <table frame="hsides" rules="groups">
        <colgroup>
          <col/>
          <col align="left"/>
          <col align="left"/>
        </colgroup>
        <thead>
          <tr>
            <th valign="top">Classes</th>
            <th align="left" valign="top">Functions</th>
            <th align="left" valign="top">Descriptions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <monospace>Matrix()</monospace>
            </td>
            <td align="left">
              <monospace>effectiveFocalLengths()</monospace>
            </td>
            <td align="left">The effective focal length</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>magnification()</monospace>
            </td>
            <td align="left">The magnification of the element</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>trace()</monospace>
            </td>
            <td align="left">The traced ray through an optical system</td>
          </tr>
          <tr>
            <td>
              <monospace>ImagingPath()</monospace>
            </td>
            <td align="left">
              <monospace>apertureStop()</monospace>
            </td>
            <td align="left">Position and diameter of AS</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>fieldStop()</monospace>
            </td>
            <td align="left">Position and diameter of FS</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>lagrangeInvariant()</monospace>
            </td>
            <td align="left">The Lagrange invariant</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>axialRay()</monospace>
            </td>
            <td align="left">Axial ray of the system</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>chiefRay()</monospace>
            </td>
            <td align="left">Chief ray of the system</td>
          </tr>
          <tr>
            <td> </td>
            <td align="left">
              <monospace>reportEfficiency()</monospace>
            </td>
            <td align="left">Efficiency report for the system</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <p>The raytracing module is developed to facilitate the simulation of an optical path for non-experts, however, there are some limitations. The use of this matrix-based formalism is advantageous compared to other calculation strategies such as diffraction integrals with finite element modeling. However, the simulations based on the finite difference time domain simulations, finite element modeling, or other numerical solver algorithms are time-consuming and they require high memory and processing power. In contrast, this module uses matrix calculations that are extremely fast but are limited to the first-order paraxial approximation and do not consider diffraction, geometrical aberrations, or interference. The results thus obtained must therefore be considered within these limitations. Finally, unlike commercial packages such as Zemax, Oslo, and Code V, the raytracing module does not include embedded optimization algorithms. However, the user is free to sweep through the parameters to perform optimizations manually.</p>
    <p>There are many other things that could be added to the raytracing module such as the complete 2D calculations for rays in the transverse plane, tilted optical components and even misaligned optical elements that could be treated with an expansion of the formalism (e.g., ABCDEF matrices). The possibility of reading files from commercial packages such as Zemax would also be welcome, but recent formats are not always publicly documented. Also, adding an optimization package with a few parameters is one possible area for further development, a general-purpose algorithm appears non trivial at this point. However, the goal is not to be complete, but rather to be useful and simple to use for non-experts. The code being Open Source, contributions (e.g., more commercial components, fixing issues, and suggestions.) can be made through the raytracing GitHub page at (<ext-link xlink:href="https://github.com/DCC-Lab/RayTracing" ext-link-type="uri">https://github.com/DCC-Lab/RayTracing</ext-link>).</p>
  </sec>
  <sec id="sec8">
    <label>8</label>
    <title>Conclusion</title>
    <p>The goal of this paper is to introduce the raytracing module, a freely available, well-developed simple tool for designing, optimizing, and quantifying optical systems by calculating the optical properties based on ABCD transfer matrices of the elements (version 1.3.0 corresponds exactly to this paper). Since it does not have the complexity of some advanced optical software, it can be used by beginners and students in the field of optical design. We emphasize once more in closing that the two main features that make this module convenient are the consideration of physical apertures and the freedom to use any desired light source for simple practical calculations.</p>
  </sec>
  <sec id="sec9">
    <label>9</label>
    <title>Code</title>
    <p>The code for the examples of Sec. <xref rid="sec6" ref-type="sec">6</xref> is available here.</p>
    <sec id="sec9.1">
      <label>9.1</label>
      <title>Confocal Laser Scanning Microscope Example</title>
      <p>This is the code used in the CLSM example in Sec. <xref rid="sec6.1" ref-type="sec">6.1</xref>.</p>
      <p>
        <monospace><bold>import</bold> envexamples</monospace>
      </p>
      <p>
        <monospace><bold>from</bold> raytracing <bold>import</bold> *</monospace>
      </p>
      <p>
        <monospace><bold>import</bold> matplotlib.pyplot as plt</monospace>
      </p>
      <p>
        <monospace><bold>import</bold> numpy as np</monospace>
      </p>
      <p>
        <monospace>thetas = []</monospace>
      </p>
      <p>
        <monospace>positions1 = []</monospace>
      </p>
      <p>
        <monospace>objectHalfHeight =focalRadius= 0.000250</monospace>
      </p>
      <p>
        <monospace>scanAngle = 10*np.pi/180</monospace>
      </p>
      <p>
        <monospace>pinholeModifier = <bold>{</bold>1 / 3: [], 1: [], 3: []<bold>}</bold></monospace>
      </p>
      <p>
        <monospace>positions = [1000, 800, 500, 300, 150, 100, 50, 25, 0, -25, -50, -100, -150, -300, -500, -800, -1000]</monospace>
      </p>
      <p>
        <monospace>nRays = 100000</monospace>
      </p>
      <p>
        <monospace>scanRays = UniformRays(yMax=0, thetaMax=scanAngle, M=1, N=nRays)</monospace>
      </p>
      <p>
        <monospace>inputRays = RandomUniformRays(yMax=focalRadius, yMin=-focalRadius, maxCount=nRays)</monospace>
      </p>
      <p>
        <monospace>focalSpotPosition=objFocalLength = 5</monospace>
      </p>
      <p>
        <monospace><bold>class</bold> UISUPLAPO60XW(Objective):</monospace>
      </p>
      <p> <monospace><bold>def</bold> __init__(self):</monospace></p>
      <p>
        <monospace>  <bold>super</bold>(UISUPLAPO60XW, self).__init__(f=180/60,</monospace>
      </p>
      <p>
        <monospace>NA=1.2,</monospace>
      </p>
      <p>
        <monospace>focusToFocusLength=40,</monospace>
      </p>
      <p>
        <monospace>backAperture=7,</monospace>
      </p>
      <p>
        <monospace>workingDistance=0.28,</monospace>
      </p>
      <p>
        <monospace>magnification=60,</monospace>
      </p>
      <p>
        <monospace>fieldNumber=22,</monospace>
      </p>
      <p>
        <monospace>label=’UISUPLAPO60XW Objective’)</monospace>
      </p>
      <p>
        <monospace><bold>def</bold> illuminationPath1():</monospace>
      </p>
      <p> <monospace>illumination1 = ImagingPath()</monospace></p>
      <p> <monospace><italic># The object in this situation is the laser beam at the scanning element.</italic></monospace></p>
      <p> <monospace>illumination1.objectHeight = objectHalfHeight*2</monospace></p>
      <p> <monospace>illumination1.rayNumber = 3</monospace></p>
      <p> <monospace>illumination1.fanNumber = 3</monospace></p>
      <p> <monospace>illumination1.fanAngle = 0</monospace></p>
      <p> <monospace>illumination1.append(System4f(f1=40, f2=75, diameter1=24.5, diameter2=24.5))</monospace></p>
      <p> <monospace>illumination1.append(System4f(f1=100, f2=100, diameter1=24.5, diameter2=24.5)) illumination1.append(Space(d=180/40))</monospace></p>
      <p> <monospace>illumination1.append(UISUPLAPO60XW())</monospace></p>
      <p> <monospace>illumination1.append(Space(d=180/40))</monospace></p>
      <p> <monospace><bold>return</bold> illumination1</monospace></p>
      <p>
        <monospace>path1 = illuminationPath1()</monospace>
      </p>
      <p>
        <monospace>outputRays1 = path1.traceManyThrough(scanRays)</monospace>
      </p>
      <p>
        <monospace><bold>for</bold> i <bold>in range</bold>(len(outputRays1)):</monospace>
      </p>
      <p>
        <monospace>thetas.append(scanRays[i].theta*180/np.pi)</monospace>
      </p>
      <p>
        <monospace>positions1.append(outputRays1[i].y*1000)</monospace>
      </p>
      <p>
        <monospace>scanRays.displayProgress()</monospace>
      </p>
      <p>
        <monospace>plt.plot(thetas,positions1)</monospace>
      </p>
      <p>
        <monospace>plt.xlabel(’Scan angle (degrees)’, fontsize=20)</monospace>
      </p>
      <p>
        <monospace>plt.ylabel(’Scanning position of the focal spot ($\micro$m)’, fontsize=20)</monospace>
      </p>
      <p>
        <monospace>plt.show()</monospace>
      </p>
      <p>
        <monospace>#--------------------------------------------------</monospace>
      </p>
      <p>
        <monospace><bold>def</bold> path(focalSpotPosition=objFocalLength):</monospace>
      </p>
      <p>
        <monospace> illumination2 = ImagingPath()</monospace>
      </p>
      <p>
        <monospace> illumination2.append(Space(d=focalSpotPosition))</monospace>
      </p>
      <p>
        <monospace> illumination2.append(Lens(f=objFocalLength))</monospace>
      </p>
      <p>
        <monospace> illumination2.append(Space(d=105))</monospace>
      </p>
      <p>
        <monospace> illumination2.append(Lens(f=100))</monospace>
      </p>
      <p>
        <monospace> illumination2.append(Space(d=100))</monospace>
      </p>
      <p>
        <monospace> illumination2.append(System4f(f1=100, f2=75))</monospace>
      </p>
      <p>
        <monospace> illumination2.append(System4f(f1=40, f2=50)) # <italic>Path finishes at the pinhole position</italic></monospace>
      </p>
      <p> <monospace><bold>return</bold> illumination2</monospace></p>
      <p>
        <monospace><bold>def</bold> optimalPinholeSize():</monospace>
      </p>
      <p> """</p>
      <p> <monospace><italic>Finds the magnification of the optical path and use it to find the optimal pinhole size when the focal spot is at one</italic></monospace></p>
      <p> <monospace><italic>focal length distance of the objective.</italic></monospace></p>
      <p> <monospace><italic>Return</italic></monospace></p>
      <p> -----------</p>
      <p>  <monospace><italic>pinholeIdeal : Float</italic></monospace></p>
      <p>   <monospace><italic>Returns the optimal pinhole size</italic></monospace></p>
      <p> """</p>
      <p> <monospace># <italic>Dictionnary of the position and magnification of all conjugate planes of the focal spot.</italic></monospace></p>
      <p> <monospace>planes = path().intermediateConjugates()</monospace></p>
      <p> <monospace># <italic>The last conjugate plane is the pinhole. The magnification of this position is saved in mag.</italic></monospace></p>
      <p> <monospace>mag = planes[-1][1]</monospace></p>
      <p> <monospace># <italic>Calculates the pinhole size that fits perfectly the focal spot diameter.</italic></monospace></p>
      <p> <monospace>pinholeIdeal = abs(mag * (focalRadius * 2))</monospace></p>
      <p> <monospace><bold>return</bold> pinholeIdeal</monospace></p>
      <p>
        <monospace><bold>def</bold> rayEfficiency(pinholeFactor=None, focalSpotPosition2=None):</monospace>
      </p>
      <p> """</p>
      <p> <monospace><italic>Determines the amount of rays emitted from the object that are detected at the pinhole plane.</italic></monospace></p>
      <p> <monospace><italic>Parameter</italic></monospace></p>
      <p> #---------------</p>
      <p>  <monospace><italic>pinholeFactor : Float</italic></monospace></p>
      <p>   <monospace><italic>Factor changing the pinhole size according to the ideal pinhole size.</italic></monospace></p>
      <p>  <monospace><italic>focalSpotPosition : float</italic></monospace></p>
      <p>   <monospace><italic>Position of the focal spot according to the objective (first lens)</italic></monospace></p>
      <p> <monospace><italic>Returns</italic></monospace></p>
      <p> ------------</p>
      <p>  <monospace><italic>illumination : object of ImagingPath class.</italic></monospace></p>
      <p>   <monospace><italic>Returns the illumination path</italic></monospace></p>
      <p> """</p>
      <p> <monospace>illumination2 = path(focalSpotPosition2)</monospace></p>
      <p> <monospace>pinholeSize = optimalPinholeSize() * pinholeFactor</monospace></p>
      <p> <monospace>illumination2.append(Aperture(diameter=pinholeSize))</monospace></p>
      <p> <monospace># <italic>Counts how many rays make it through the pinhole</italic></monospace></p>
      <p> <monospace>outputRays2 = illumination2.traceManyThroughInParallel(inputRays, progress=False)</monospace></p>
      <p> <monospace><bold>return</bold> outputRays2.count / inputRays.count</monospace></p>
      <p>
        <monospace><bold>for</bold> pinhole <bold>in</bold> pinholeModifier:</monospace>
      </p>
      <p> <monospace><bold>print</bold>("\nComputing transmission for pinhole size <bold>{</bold>0:0.1f<bold>}</bold>".<bold>format</bold>(pinhole))</monospace></p>
      <p> <monospace>efficiencyValues = []</monospace></p>
      <p> <monospace><bold>for</bold> z <bold>in</bold> positions:</monospace></p>
      <p>  <monospace><bold>print</bold>(".",end='')</monospace></p>
      <p>  <monospace>newPosition = 5 + (z * 0.000001)</monospace></p>
      <p>  <monospace>efficiency = rayEfficiency(pinholeFactor=pinhole,   focalSpotPosition2=newPosition)</monospace></p>
      <p> <monospace>efficiencyValues.append(efficiency)</monospace></p>
      <p> <monospace>pinholeModifier[pinhole] = efficiencyValues</monospace></p>
      <p> <monospace>plt.plot(positions, pinholeModifier[1 / 3], ’k:’, label=’Small pinhole’, linestyle=’dashed’)</monospace></p>
      <p> <monospace>plt.plot(positions, pinholeModifier[1], ’k-’, label=’Ideal pinhole’)</monospace></p>
      <p>
        <monospace>plt.plot(positions, pinholeModifier[3], ’k--’, label=’Large pinhole’, linestyle=’dotted’)</monospace>
      </p>
      <p>
        <monospace>plt.ylabel(’Transmission efficiency’, fontsize=20)</monospace>
      </p>
      <p>
        <monospace>plt.xlabel(’Position of the focal spot (nm)’, fontsize=20)</monospace>
      </p>
      <p>
        <monospace>plt.legend()</monospace>
      </p>
      <p>
        <monospace>plt.show()</monospace>
      </p>
    </sec>
    <sec id="sec9.2">
      <label>9.2</label>
      <title>Kohler Illumination System Example</title>
      <p>
        <monospace><bold>from</bold> raytracing <bold>import</bold> *</monospace>
      </p>
      <p>
        <monospace>illumination = ImagingPath()</monospace>
      </p>
      <p>
        <monospace>illumination.design(fontScale=1.5)</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=20))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Lens(f=10, diameter=25.4, label="Collector"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=30))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Aperture(diameter=2, label="Field diaphragm"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=10+30))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Lens(f=30, diameter=25.4, label="Condenser"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=30+30))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Lens(f=30, diameter=25.4, label="Objective"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=30+30))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Lens(f=30, diameter=25.4, label="Tube"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=30+30))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Lens(f=30, diameter=25.4, label="Eyepiece"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=30+2))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Lens(f=2, diameter=10, label="Eye Entrance"))</monospace>
      </p>
      <p>
        <monospace>illumination.append<?tic?>(Space(d=2))</monospace>
      </p>
      <p>
        <monospace>illumination.display(interactive=False, raysList=[LampRays(diameter=0.1, NA=0.5, N=2, T=6, z=6.6666666, rayColors=’r’, label="Source"),ObjectRays(diameter=2, halfAngle=0.1, H=2, T=2, z=120, rayColors=’g’, color=’g’, label="Sample")], removeBlocked=False)</monospace>
      </p>
    </sec>
    <sec id="sec9.3">
      <label>9.3</label>
      <title>Widefield Microscope Example</title>
      <p>The code for the example 6.3 is written below.</p>
      <p>
        <monospace><bold>from</bold> raytracing <bold>import</bold> *</monospace>
      </p>
      <p>
        <monospace>
          <italic># Defines the path. a and b are the diameter of the lenses.</italic>
        </monospace>
      </p>
      <p>
        <monospace><bold>def</bold> imagingPath(a=10, b=10, title=""):</monospace>
      </p>
      <p>
        <monospace> path = ImagingPath()</monospace>
      </p>
      <p>
        <monospace> path.label=title</monospace>
      </p>
      <p>
        <monospace> path.append<?tic?>(System4f(f1=50, diameter1=a, f2=50, diameter2=b))</monospace>
      </p>
      <p>
        <monospace> path.append<?tic?>(Aperture(diameter=10, label=’Camera’))</monospace>
      </p>
      <p>
        <monospace> <bold>return</bold> path</monospace>
      </p>
      <p>
        <monospace>
          <italic># Input from the expected field of view</italic>
        </monospace>
      </p>
      <p>
        <monospace>nRays=1000000</monospace>
      </p>
      <p>
        <monospace>objectHalfHeight = 5</monospace>
      </p>
      <p>
        <monospace>inputRays = RandomUniformRays(yMax = objectHalfHeight,yMin = -objectHalfHeight,thetaMin = -0.5, thetaMax = +0.5,maxCount=nRays)</monospace>
      </p>
      <p>
        <monospace>
          <italic># Three paths with different sets of lens diameter.</italic>
        </monospace>
      </p>
      <p>
        <monospace>path1 = imagingPath(a=d1, b=d2, title="Vignetting with FS poorly placed because of second lens diameter")</monospace>
      </p>
      <p>
        <monospace>outputRays = path1.traceManyThrough(inputRays)</monospace>
      </p>
      <p>
        <monospace>efficiency = 100*outputRays.count/inputRays.count</monospace>
      </p>
      <p>
        <monospace>path1.display(limitObjectToFieldOfView=False, onlyChiefAndMarginalRays=True)</monospace>
      </p>
      <p>
        <monospace>outputRays.display("Output profile with vignetting <bold>{</bold>0:.0f<bold>}</bold>\% efficiency".<bold>format</bold>(efficiency), showTheta=False)</monospace>
      </p>
      <p>
        <monospace>path1.reportEfficiency()</monospace>
      </p>
      <p>
        <monospace>path2 = (...) <italic># same as path1</italic></monospace>
      </p>
      <p>
        <monospace>path3 = (...) <italic># same as path1</italic></monospace>
      </p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>This work is supported by NSERC Discovery Grant (Grant No. RGPIN-2020-06936) and NSERC SMAART Training Grant (CREATE 497040-2017). We would like to thank Mireille Quémener and Vincent Boily for their very pertinent comments on the paper. Valérie, Shadi, Elahe, and Daniel wrote the manuscript. Valérie and Shadi worked on producing relevant examples and figures while Elahe perfected the PyPI documentation. Ludovick, Gabriel, Marc-André, and Daniel worked on the Python code of the project. Ludovick developed the display features while Gabriel worked on validating and quality testing of the code. Marc-André improved features and mentored less experimented coders. Finally, Daniel instituted the basics of the project and managed, led, and supervised its development.</p>
  </ack>
  <bio id="b1">
    <p><bold>Valérie Pineau Noël</bold> is a second-year MSc student in biophotonics. She obtained her bachelor’s degree in biochemistry in 2019. She is interested in building and optimizing a fast volumetric imaging technique called HiLo microscopy to study the neuronal activity in GCaMP transgenic zebrafish larvae <italic>in vivo</italic>. The goal of her project is to acquire images of the brain to better understand the brain-intestine-microbiome interactions.</p>
  </bio>
  <bio id="b2">
    <p><bold>Shadi Masoumi</bold> is a first-year PhD student in biophotonics. She obtained her bachelor’s degree in atomic physics in 2015. During her master’s, she worked on tissue optical clearing methods in combination with diffuse reflection spectroscopy. She graduated her master’s degree in 2018. Since 2020, she is working on her PhD project about polarization sensitive optical coherence tomography for neurosurgical guidance. In general, she is interested in application of light in biology.</p>
  </bio>
  <bio id="b3">
    <p><bold>Elahe Parham</bold> completed her bachelor’s degree in electrical engineering at Amirkabir University of Technology. She obtained her MSc degree in biomedical engineering from University of Tehran. She worked on the structural connections of neurons and artificial intelligence to analyze the signal. She is currently a PhD student in biophotonics. She aims to use the wavelength-swept system to obtain Raman spectra of brain tissue to be used for guidance during surgery.</p>
  </bio>
  <bio id="b4">
    <p><bold>Gabriel Genest</bold> is a first-year MSc student in physics. His interests include optics, quantum mechanics, information theory, statistics, and computer science. He is completing an MSc degree in physics with a focus on the underlying causal structure of the zebrafish’s brain, with the help of complex networks, statistical analysis, and programming.</p>
  </bio>
  <bio id="b5">
    <p><bold>Ludovick Bégin</bold> is a first-year MSc student in biophotonics with a bachelor’s degree in engineering physics. His interests include data science, software, and system programming. His current research focuses on the development of simulations and machine learning algorithms to improve signal treatment in neuroimaging techniques.</p>
  </bio>
  <bio id="b6">
    <p><bold>Marc-André Vignault</bold> is a physics engineering graduate currently undertaking his MSc degree in biophotonics. His interests lean toward the development of optical systems for detection and characterization of biological tissues. His main project is related to the design and development of a fibered SERS probe for detection and guidance in the brain for DBS neurosurgery. The rest of his projects focus on electronic engineering and python programming.</p>
  </bio>
  <bio id="b7">
    <p><bold>Daniel C. Côté</bold>, PhD and PEng, is the NSERC/HBI Chairholder in Optical Technologies for Neurosurgery at Laval University in Canada. He leads a research program at the CERVO Brain Research Center in live animal microscopy and spectroscopy with a focus on deploying technologies to scientists and clinicians. In addition, he has taught optics for seven years to undergraduate students in physics and engineering for which he has received several teaching awards, in addition to lab courses in optics and biophotonics. He recently started teaching mathematical physics to first-year students and loves it.</p>
  </bio>
  <notes notes-type="conflict-of-interest">
    <title>Disclosures</title>
    <p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </notes>
  <ref-list>
    <title>References</title>
    <ref id="r1">
      <label>1.</label>
      <mixed-citation publication-type="webpage"><ext-link xlink:href="https://github.com/dcc-lab/raytracing" ext-link-type="uri">https://github.com/dcc-lab/raytracing</ext-link>.</mixed-citation>
    </ref>
    <ref id="r2">
      <label>2.</label>
      <mixed-citation publication-type="webpage">“<article-title>Raytracing in Python</article-title>,” <ext-link xlink:href="https://www.youtube.com/playlist?list=PLUxTghemi4Ft0NzQwuufpU-EGgkmaInAf" ext-link-type="uri" specific-use="print">https://www.youtube.com/playlist?list=PLUxTghemi4Ft0NzQwuufpU-EGgkmaInAf</ext-link>.</mixed-citation>
    </ref>
    <ref id="r3">
      <label>3.</label>
      <mixed-citation publication-type="webpage"><ext-link xlink:href="https://raytracing.readthedocs.io/en/latest/" ext-link-type="uri">https://raytracing.readthedocs.io/en/latest/</ext-link>.</mixed-citation>
    </ref>
    <ref id="r4">
      <label>4.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Martin</surname><given-names>R. C.</given-names></name></person-group>, <source>Clean Code: A Handbook of Agile Software Craftsmanship</source>, <publisher-name>Pearson Education</publisher-name>, <publisher-loc>Westford, Massachusetts</publisher-loc> (<year>2009</year>).</mixed-citation>
    </ref>
    <ref id="r5">
      <label>5.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Siegman</surname><given-names>A. E.</given-names></name></person-group>, <source>Lasers</source>, <publisher-name>University of Science Books</publisher-name>, <publisher-loc>Sausalito, California</publisher-loc> (<year>1986</year>).</mixed-citation>
    </ref>
    <ref id="r6">
      <label>6.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Côté</surname><given-names>D. C.</given-names></name></person-group>, “<article-title>Optique</article-title>,” Québec (<year>2018</year>).</mixed-citation>
    </ref>
    <ref id="r7">
      <label>7.</label>
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bumstead</surname><given-names>J. R.</given-names></name><etal>et al.</etal></person-group>, “<article-title>Designing a large field-of-view two-photon microscope using optical invariant analysis</article-title>,” <source>Neurophotonics</source>
<volume>5</volume>, <fpage>025001</fpage> (<year>2018</year>).<pub-id pub-id-type="doi">10.1117/1.NPh.5.2.025001</pub-id><pub-id pub-id-type="pmid">29487876</pub-id></mixed-citation>
    </ref>
    <ref id="r8">
      <label>8.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Hecht</surname><given-names>E.</given-names></name></person-group>, <source>Optics</source>, <edition>4th ed</edition>., <publisher-name>Pearson/Addison-Wesley</publisher-name>, <publisher-loc>San Francisco</publisher-loc> (<year>2002</year>).</mixed-citation>
    </ref>
    <ref id="r9">
      <label>9.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>W.</given-names></name></person-group>, <source>Modern Lens Design</source>, <edition>2nd ed</edition>., Vol. 1, <publisher-name>McGraw-Hill Professional Engineering</publisher-name>, <publisher-loc>Toronto, Ontario</publisher-loc> (<year>2004</year>).</mixed-citation>
    </ref>
    <ref id="r10">
      <label>10.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>W. J.</given-names></name></person-group>, <source>Modern Optical Engineering</source>, <edition>4th ed.</edition>, Vol. 1, <publisher-name>SPIE Press</publisher-name>, <publisher-loc>Bellingham, Washington, DC</publisher-loc> (<year>2007</year>).</mixed-citation>
    </ref>
    <ref id="r11">
      <label>11.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kloos</surname><given-names>G.</given-names></name></person-group>, <source>Matrix Methods for Optical Layout</source>, <publisher-name>SPIE Press</publisher-name>, <publisher-loc>Bellingham, Washington</publisher-loc> (<year>2007</year>).</mixed-citation>
    </ref>
    <ref id="r12">
      <label>12.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Greivenkamp</surname><given-names>J. E.</given-names></name></person-group>, <source>Field Guide to Geometrical Optics</source>, Vol. 1, <publisher-name>SPIE Press</publisher-name>, <publisher-loc>Bellingham, Washington, DC</publisher-loc> (<year>2004</year>).</mixed-citation>
    </ref>
    <ref id="r13">
      <label>13.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Liang</surname><given-names>R.</given-names></name></person-group>, <source>Optical Design for Biomedical Imaging</source>, <publisher-name>Springer</publisher-name>, <publisher-loc>Heidelberg, New York, Dordrecht, London</publisher-loc> (<year>2011</year>).</mixed-citation>
    </ref>
    <ref id="r14">
      <label>14.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Weik</surname><given-names>M. H.</given-names></name></person-group>, <source>Lambert’s Cosine Law</source>, pp. <fpage>868</fpage>–<lpage>868</lpage>, <publisher-name>Springer US</publisher-name>, <publisher-loc>Boston, MA</publisher-loc> (<year>2001</year>).</mixed-citation>
    </ref>
    <ref id="r15">
      <label>15.</label>
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Pawley</surname><given-names>J.</given-names></name></person-group>, <source>Handbook of Biological Confocal Microscopy</source>, Vol. 23, <publisher-name>Springer Science+Business Media, LLC</publisher-name>, <publisher-loc>New York</publisher-loc> (<year>2006</year>).</mixed-citation>
    </ref>
    <ref id="r16">
      <label>16.</label>
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Veilleux</surname><given-names>I.</given-names></name><etal>et al.</etal></person-group>, “<article-title><italic>In vivo</italic> cell tracking with video rate multimodality laser scanning microscopy</article-title>,” <source>IEEE J. Sel. Top. Quantum Electron.</source>
<volume>14</volume>, <fpage>10</fpage>–<lpage>18</lpage> (<year>2008</year>).<pub-id pub-id-type="coden">IJSQEN</pub-id><issn>1077-260X</issn><pub-id pub-id-type="doi">10.1109/JSTQE.2007.912751</pub-id></mixed-citation>
    </ref>
    <ref id="r17">
      <label>17.</label>
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Svoboda</surname><given-names>K.</given-names></name><name><surname>Yasuda</surname><given-names>R.</given-names></name></person-group>, “<article-title>Principles of two-photon excitation microscopy and its applications to neuroscience</article-title>,” <source>Neuron</source>
<volume>50</volume>(<issue>6</issue>), <fpage>823</fpage>–<lpage>839</lpage> (<year>2006</year>).<pub-id pub-id-type="coden">NERNET</pub-id><issn>0896-6273</issn><pub-id pub-id-type="doi">10.1016/j.neuron.2006.05.019</pub-id><pub-id pub-id-type="pmid">16772166</pub-id></mixed-citation>
    </ref>
    <ref id="r18">
      <label>18.</label>
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bélanger</surname><given-names>P. A.</given-names></name></person-group>, “<article-title>Beam propagation and the ABCD ray matrices</article-title>,” <source>Opt. Lett.</source>
<volume>16</volume>(<issue>4</issue>), <fpage>196</fpage>–<lpage>198</lpage> (<year>1991</year>).<pub-id pub-id-type="coden">OPLEDP</pub-id><issn>0146-9592</issn><pub-id pub-id-type="doi">10.1364/OL.16.000196</pub-id><pub-id pub-id-type="pmid">19773880</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
