<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7291640</article-id>
    <article-id pub-id-type="publisher-id">3581</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-020-03581-8</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>AllesTM: predicting multiple structural features of transmembrane proteins</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Hönigschmid</surname>
          <given-names>Peter</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Breimann</surname>
          <given-names>Stephan</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Weigl</surname>
          <given-names>Martina</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-9006-4707</contrib-id>
        <name>
          <surname>Frishman</surname>
          <given-names>Dmitrij</given-names>
        </name>
        <address>
          <email>d.frishman@wzw.tum.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="GRID">grid.6936.a</institution-id><institution-id institution-id-type="ISNI">0000000123222966</institution-id><institution>Department of Bioinformatics, Wissenschaftszentrum Weihenstephan, </institution><institution>Technische Universität München, </institution></institution-wrap>Maximus-von-Imhof-Forum 3, 85354 Freising, Germany </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>6</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>6</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>21</volume>
    <elocation-id>242</elocation-id>
    <history>
      <date date-type="received">
        <day>19</day>
        <month>12</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>6</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">This study is motivated by the following three considerations: a) the physico-chemical properties of transmembrane (TM) proteins are distinctly different from those of globular proteins, necessitating the development of specialized structure prediction techniques, b) for many structural features no specialized predictors for TM proteins are available at all, and c) deep learning algorithms allow to automate the feature engineering process and thus facilitate the development of multi-target methods for predicting several protein properties at once.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">We present AllesTM, an integrated tool to predict almost all structural features of transmembrane proteins that can be extracted from atomic coordinate data. It blends several machine learning algorithms: random forests and gradient boosting machines, convolutional neural networks in their original form as well as those enhanced by dilated convolutions and residual connections, and, finally, long short-term memory architectures. AllesTM outperforms other available methods in predicting residue depth in the membrane, flexibility, topology, relative solvent accessibility in its bound state, while in torsion angles, secondary structure and monomer relative solvent accessibility prediction it lags only slightly behind the currently leading technique SPOT-1D. High accuracy on a multitude of prediction targets and easy installation make AllesTM a one-stop shop for many typical problems in the structural bioinformatics of transmembrane proteins.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">In addition to presenting a highly accurate prediction method and eliminating the need to install and maintain many different software tools, we also provide a comprehensive overview of the impact of different machine learning algorithms and parameter choices on the prediction performance.</p>
        <p id="Par4">AllesTM is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/phngs/allestm">https://github.com/phngs/allestm</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Protein evolution</kwd>
      <kwd>Protein structure prediction</kwd>
      <kwd>Transmembrane proteins</kwd>
      <kwd>Machine learning</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution>Deutsche Forschungsgemeinschaft</institution>
        </funding-source>
        <award-id>FR 1411/13-1</award-id>
        <principal-award-recipient>
          <name>
            <surname>Frishman</surname>
            <given-names>Dmitrij</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Introduction</title>
    <p id="Par5">Starting with the seminal work of Qian and Sejnowski [<xref ref-type="bibr" rid="CR1">1</xref>], only the sky seems to be the limit for the application of machine learning methods to sequence-based protein structure prediction. Over the years, as the variety of employed algorithms expanded (neural networks, support vector machines, random forests), so did the scope of prediction targets – from secondary structure, transmembrane regions, and signal peptides to solvent accessibility, crystallizability, contact maps, and interaction sites. The art of predictor design is not only in the construction of an optimal machine learning framework and rigorous training and testing procedures, but also in the meticulous choice of the relevant feature space. In each particular case, the latter step requires in-depth domain knowledge and almost unavoidably involves arbitrary decisions. Recent major advances in protein structure prediction accuracy, made apparent by the latest rounds of the CASP contest [<xref ref-type="bibr" rid="CR2">2</xref>], can be attributed to the wide adoption of deep learning methods [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR4">4</xref>], which are able to learn hierarchical features and infer input/output mappings directly from complex and noisy data (Goodfellow et al., 2016). One specific advantage of this group of methods is that they allow automating the feature engineering process and thus eliminate, or at least significantly alleviate, the arguably most time-consuming step in the development of bioinformatics prediction algorithms. This, in its turn, opens up the possibility of developing multi-target prediction methods, i.e. methods that predict a whole array of protein properties directly from input sequences or evolutionary profiles.</p>
    <p id="Par6">In this work, we explore this idea focusing on integral transmembrane proteins. In spite of its functional importance and biomedical relevance, this class of proteins has been, to some extent, neglected in the field of structural bioinformatics, mostly due to the sparsity of experimental data available for training algorithms. For example, the residue contact prediction field was initiated in 1994 [<xref ref-type="bibr" rid="CR5">5</xref>], but it was not until 2007 that specialized contact prediction methods for membrane proteins were proposed [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>]. Likewise, the first attempts to predict protein solubility were made almost 30 years ago [<xref ref-type="bibr" rid="CR8">8</xref>], while for membrane proteins the first predictor of solubility and other experimental properties was developed in 2008 [<xref ref-type="bibr" rid="CR9">9</xref>]. For some structural features, such as flexibility, secondary structure, torsion angles or solvent accessibility, membrane protein-specific predictors are not available at all. Experience shows that, in many cases, applying methods originally trained on soluble proteins to predict the structural features of transmembrane proteins leads to inferior performance.</p>
    <p id="Par7">Here we present AllesTM, an integrated tool to predict several essential structural features of transmembrane proteins: residue depth in the membrane, flexibility, topology, three-state secondary structure, relative solvent accessibility (in the protein’s monomer form as well as bound in a complex), and the torsion angles φ and ψ. By combining state of the art machine learning algorithms, a modern dataset of known transmembrane protein structures, widely accepted evaluation methods and metrics as well as heavy automation of training and parameter selection we were able to either outperform or at least achieve a comparable performance to the currently leading methods in terms prediction accuracy. An additional practical benefit of AllesTM is that it eliminates the need to install and maintain many different software tools and allows for easy installation by minimizing dependencies and proper packaging.</p>
  </sec>
  <sec id="Sec2">
    <title>Results</title>
    <sec id="Sec3">
      <title>Z-coordinates</title>
      <p id="Par8">The depth of a residue in the membrane is predicted as a continuous number, its distance from the membrane center, ranging from − 25 to + 25 Å (Fig. <xref rid="Fig1" ref-type="fig">1</xref>, <xref rid="MOESM1" ref-type="media">S1</xref> and <xref rid="MOESM1" ref-type="media">S2</xref> Figs). Significant deviations from the equal distribution of residue occurrence beyond the central portion of the transmembrane segment (i.e. outside of the range − 15 to + 15) can be explained as follows. The slightly higher occurrence of residues in the vicinity of the membrane boundaries (around − 15 and + 15) is apparently caused by interfacial helices oriented parallel to the membrane as well as reentrant regions. Minor ‘dents’ in the distribution at approximately − 20 Å and especially at 20 Å are due to the fact that in our data many amino acid chains begin (or end) at this distance from the membrane, and the protein N- or C-termini are more frequently positioned at 20 Å than at − 20 Å. Finally, peaks at − 25 Å and 25 Å are a trivial consequence of the fact that any values beyond this range are assigned these values.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Distribution of the observed and predicted z-coordinates on the independent test dataset. Only the most basic (RF) and the most advanced method (AllesTM) are shown</p></caption><graphic xlink:href="12859_2020_3581_Fig1_HTML" id="MO1"/></fig></p>
      <p id="Par9">While the z-coordinates are the only target where no other method is publicly available for comparison, several conclusions regarding the employed machine learning algorithm can be drawn from the performance overview shown in <xref rid="MOESM1" ref-type="media">S1</xref> Table. First, the accuracy increases with the receptive field of the method. The RF and the GBM with their limited receptive field achieve an MAE of 10.64 and 9.63, respectively, on the cross-validation dataset. The low performance of the RF is also visualized in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, Fig. <xref rid="MOESM1" ref-type="media">S1</xref> and Fig. <xref rid="MOESM1" ref-type="media">S2</xref>, showing that the predicted values deviate strongly from the expected distribution and are accumulated around a z-coordinate of 0. The conv method, which has a much wider receptive field due to its multiple layers, already achieves an MAE of 6.94 on the same data, while the dconv and LSTM approaches outperform the other models with MAEs of 6.02 and 4.99, respectively. The importance of a large receptive field indicates the depth of the residue on the membrane is influenced by long-range correlations between amino acid residues. At least for the cross-validation dataset, the MAE of the final method AllesTM (5.08) is slightly higher than the MAE of the LSTM model, but with a reduced MSE/RMSE. AllesTM produces results that resemble the observed distribution of z-coordinates quite well, especially when compared to the RF method (Fig. <xref rid="Fig1" ref-type="fig">1</xref>). All approaches without exception perform better on the independent test dataset than on the cross-validation dataset. This can have one of two reasons: either the independent test dataset is easier to predict, or the averaging of the five models derived from cross-validation led to an increased performance as the averaging procedure is equivalent to additional ensembling. The expected MAE from the final method AllesTM is 3.72 with an RMSE of only 6.32, which means that there are only a few large errors.</p>
    </sec>
    <sec id="Sec4">
      <title>Topology</title>
      <p id="Par10">AllesTM predicts not only the position of a residue with respect to the membrane as an absolute value, but also in which of the four types of segments the residue is situated in: inner and outer side of the membrane (In/Out), transmembrane segment (TMS), or reentrant region (RER). Table <xref rid="Tab1" ref-type="table">1</xref>, <xref rid="MOESM1" ref-type="media">S2</xref> Table, Fig. <xref rid="MOESM1" ref-type="media">S3</xref> and Fig. <xref rid="MOESM1" ref-type="media">S4</xref> show the performance of the trained algorithms compared with MEMSAT-SVM, PolyPhobius and SCAMPI on the cross-validation as well as the independent test dataset. Similar to the z-coordinate prediction, a larger receptive field has a positive impact on the prediction performance, although the effect is generally less pronounced compared to the z-coordinate prediction and more prominent for the In and Out segments than for the TMS and RER segments. For example, the RF model reaches an AUC of 0.85 compared to an AUC of 0.9 for the LSTM model in the In segments, while for the TMS segments the AUC differs only by 0.01 (0.88 for the RF model and 0.89 for the LSTM model). Furthermore, in terms of accuracy AllesTM outperforms MEMSAT-SVM as well as PolyPhobius and SCAMPI. This holds true when not including RER segments into the benchmark, a class neither PolyPhobius nor SCAMPI can predict. Focusing on the classes In, Out, TMS, and RER separately, only for RER segments MEMSAT-SVM achieves a higher AUC value.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Performance summary of all methods and predictions targets evaluated on the independent test dataset. Bold face indicates the best performing method. More detailed metrics, broken down to individual classes, can be found in the supplementary materials</p></caption><table frame="hsides" rules="groups"><tbody><tr><td/><td><bold>Z-coordinates</bold></td><td><bold>Topology</bold></td><td><bold>Continuous flexibility</bold></td><td><bold>Two-state flexibility</bold></td><td/><td/></tr><tr><td/><td><bold>MAE</bold></td><td><bold>ACC</bold></td><td><bold>MAE</bold></td><td><bold>ACC</bold></td><td/><td/></tr><tr><td><bold>RF</bold></td><td>9.1</td><td>0.83</td><td>0.67</td><td>0.68</td><td/><td/></tr><tr><td><bold>GBM</bold></td><td>7.82</td><td>0.86</td><td>0.65</td><td>0.69</td><td/><td/></tr><tr><td><bold>conv</bold></td><td>5.18</td><td>0.86</td><td><bold>0.63</bold></td><td><bold>0.7</bold></td><td/><td/></tr><tr><td><bold>dconv</bold></td><td>4.45</td><td>0.88</td><td><bold>0.63</bold></td><td><bold>0.7</bold></td><td/><td/></tr><tr><td><bold>LSTM</bold></td><td>3.71</td><td>0.89</td><td><bold>0.63</bold></td><td><bold>0.7</bold></td><td/><td/></tr><tr><td><bold>AllesTM</bold></td><td><bold>3.72</bold></td><td><bold>0.9</bold></td><td><bold>0.63</bold></td><td><bold>0.7</bold></td><td/><td/></tr><tr><td><bold>MEMSAT-SVM</bold></td><td/><td>0.74</td><td/><td/><td/><td/></tr><tr><td><bold>PolyPhobius</bold><sup><bold>a</bold></sup></td><td/><td>0.75/0.75</td><td/><td/><td/><td/></tr><tr><td><bold>SCAMPI</bold><sup><bold>a</bold></sup></td><td/><td>0.77/0.78</td><td/><td/><td/><td/></tr><tr><td><bold>PROFbval</bold></td><td/><td/><td>0.78</td><td>0.65</td><td/><td/></tr><tr><td><bold>PredyFlexy</bold></td><td/><td/><td>0.8</td><td/><td/><td/></tr><tr><td/><td><bold>Phi angles</bold></td><td><bold>Psi angles</bold></td><td><bold>Secondary structure</bold></td><td><bold>RSA monomer</bold></td><td><bold>RSA complex</bold></td><td><bold>RSA change</bold></td></tr><tr><td/><td><bold>MAE</bold></td><td><bold>MAE</bold></td><td><bold>ACC</bold></td><td><bold>MAE</bold></td><td><bold>MAE</bold></td><td><bold>MAE</bold></td></tr><tr><td><bold>RF</bold></td><td>18.91</td><td>39.5</td><td>0.82</td><td>0.18</td><td>0.16</td><td>0.09</td></tr><tr><td><bold>GBM</bold></td><td>18.5</td><td>35.93</td><td>0.84</td><td>0.17</td><td>0.15</td><td>0.09</td></tr><tr><td><bold>conv</bold></td><td>16.93</td><td>28.75</td><td>0.85</td><td>0.16</td><td><bold>0.14</bold></td><td><bold>0.07</bold></td></tr><tr><td><bold>dconv</bold></td><td>17.43</td><td>29.47</td><td>0.85</td><td>0.16</td><td><bold>0.14</bold></td><td><bold>0.07</bold></td></tr><tr><td><bold>LSTM</bold></td><td>17.03</td><td>28.81</td><td>0.85</td><td>0.16</td><td><bold>0.14</bold></td><td><bold>0.07</bold></td></tr><tr><td><bold>AllesTM</bold></td><td>17.34</td><td>30.41</td><td>0.86</td><td>0.15</td><td><bold>0.14</bold></td><td>0.08</td></tr><tr><td><bold>PROFphd</bold></td><td/><td/><td>0.78</td><td/><td/><td/></tr><tr><td><bold>PSIPRED</bold></td><td/><td/><td>0.87</td><td/><td/><td/></tr><tr><td><bold>ANGLOR</bold></td><td>19.57</td><td>38.33</td><td/><td/><td/><td/></tr><tr><td><bold>SPINE X</bold></td><td>20.68</td><td>41.77</td><td>0.77</td><td>0.2</td><td>0.17</td><td/></tr><tr><td><bold>SPOT-1D</bold></td><td><bold>15.85</bold></td><td><bold>23.51</bold></td><td><bold>0.89</bold></td><td><bold>0.14</bold></td><td>0.16</td><td/></tr></tbody></table><table-wrap-foot><p><sup>a</sup>The second value indicates the performance of PolyPhobius and SCAMPI without reentrant regions</p></table-wrap-foot></table-wrap></p>
      <p id="Par11">Again, all our models perform better on the independent test dataset by a wide margin. In particular, AllesTM, our final method, achieves an ACC of 0.85 during cross-validation and an unprecedented ACC of 0.9 on the independent test dataset. In contrast, MEMSAT-SVM, PolyPhobius and SCAMPI exhibit similar performance on the two datasets (ACC of 0.74, 0.75 and 0.77 on the independent test data set, respectively). Thus, it appears that the datasets have a similar difficulty but the additional ensembling from the cross-validation models boosts the prediction performance even further. With an AUC of 0.7 on RER segments, AllesTM now outperforms MEMSAT-SVM (AUC of 0.58) by a wide margin also on the independent test dataset.</p>
    </sec>
    <sec id="Sec5">
      <title>Flexibility</title>
      <p id="Par12">B-factors were normalized for each protein and predicted as continuous values as well as in terms of two classes, i.e. flexible and non-flexible. In contrast to the z-coordinate and topology predictions a large receptive field seems to be of less importance for the prediction of continuous and two-state flexibility. For example, comparing the performance of the GBM and the LSTM on the independent test dataset the MAE is only 0.02 smaller for continuous flexibility (0.65 and 0.63 respectively) and the AUC is only better by 0.01 for two-state flexibility (0.65 to 0.66 respectively) (Table <xref rid="Tab1" ref-type="table">1</xref>, <xref rid="MOESM1" ref-type="media">S3</xref> and <xref rid="MOESM1" ref-type="media">S4</xref> Tables, as well as Fig. <xref rid="MOESM1" ref-type="media">S5</xref>, Fig. <xref rid="MOESM1" ref-type="media">S6</xref>, Fig. <xref rid="MOESM1" ref-type="media">S7</xref> and Fig. <xref rid="MOESM1" ref-type="media">S8</xref>). In line with these observations, the blending approach, i.e. combining different models in the final method AllesTM, results in only a small performance improvement. AllesTM achieves an MAE of 0.51 for continuous flexibility on the independent test dataset, compared to an MAE of 0.4 for PROFbval and 0.13 measured for PredyFlexy. While the Neural Network (NN)-based PROFbval performs well compared to our RF model it is not specifically trained using TMPs and was trained on a substantially older dataset. While the creators of PredyFlexy claim a correlation with the target variable of 0.71, we were not able to reproduce this performance. As PredyFlexy predicts flexibility by mapping structure fragments with known flexibility values to the sequence, we presume that no TMPs were included in its fragment library.</p>
      <p id="Par13">Regarding the performance of two-state flexibility predictions a similar picture emerges. AllesTM achieves an AUC of 0.66 on the independent test dataset, 0.1 better than PROFbval. The difference in performance during cross-validation and on the independent test dataset is only marginal for the continuous as well as the two-state flexibility. As an example for continuous flexibility, AllesTM has an MAE of 0.66 on the cross-validation dataset but only 0.63 on the independent test dataset. PROFbval, on the other hand, performs slightly worse on the independent test dataset compared to the cross-validation dataset (MAEs of 0.78 and 0.77 respectively).</p>
    </sec>
    <sec id="Sec6">
      <title>Torsion angles</title>
      <p id="Par14">AllesTM only predicts the φ and ψ angles because the third dihedral angle, ω, is essentially fixed at 180°. Similar to the protein flexibility, long range interactions seem to play a minor role when predicting φ and ψ, as the methods with a larger receptive field only perform slightly better. Therefore ANGLOR, which uses a NN for φ and a SVN for ψ angles, and SPINE X which uses a multi-layer NN, perform slightly worse compared to AllesTM (Table <xref rid="Tab1" ref-type="table">1</xref>, <xref rid="MOESM1" ref-type="media">S5</xref> and <xref rid="MOESM1" ref-type="media">S6</xref> Tables, as well as Fig. <xref rid="MOESM1" ref-type="media">S9</xref>, Fig. <xref rid="MOESM1" ref-type="media">S10</xref>, Fig. <xref rid="MOESM1" ref-type="media">S11</xref> and Fig. <xref rid="MOESM1" ref-type="media">S12</xref>). For φ angles in the independent test dataset, SPINE X and ANGLOR achieve an MAE of 20.68 and 19.57 respectively, while the error of AllesTM is 17.34. For comparison, the MAE of our LSTM solution is only 0.31 higher (17.03) while the MAE of our worst performing approach, the RF, is only 1.57 higher (18.91) than that of AllesTM, and still ahead of SPINE X and ANGLOR. Nevertheless, looking at the MAE, SPOT-1D outperforms our method AllesTM (15.85 and 17.34), but with a slightly higher RMSE (31.03 and 31.69). That means that AllesTM, while being on average less accurate, makes fewer large mistakes.</p>
      <p id="Par15">The results are similar for ψ angles, although SPINE X achieves a slightly lower MAE than our RF method on both, the cross-validation (MAEs of 39.76 and 42.91, respectively) as well as the independent test dataset (MAEs of 38.33 and 39.5, respectively). In terms of RMSE, SPINE X trails behind the RF model for the ψ angles on both datasets. While performing with a similar MAE, ANGLOR achieves a much better performance according to the RMSE compared to SPINE X on the independent test dataset (57.88 and 77.41, respectively). In this case SPOT-1D with an MAE of 23.51 and a RMSE of 50.11 outperforms AllesTM with an MAE of 30.41 and a RMSE of 50.73. Both methods, AllesTM and SPOT-1D use LSTMs with their large receptive field, and the previous comparisons suggest that the size of the receptive field only has a minor impact on φ and ψ angle prediction performance, so the strength of SPOT-1D has to lie elsewhere. The two main differences are that SPOT-1D uses predicted contacts as a feature and a larger training dataset, as it is not restricted to TMPs. Therefore there are three possible explanations why contacts bring this benefit. The first is that contacts of residues which are sequentially very far apart such that even the receptive field cannot incorporate them have an impact on the prediction target. An alternative explanation is that the corellated mutations of sequentially co-located residues provide a very strong signal. The third possible explanation is that the usage of a larger trainging dataset outweights the specifics of TMPs.</p>
    </sec>
    <sec id="Sec7">
      <title>Secondary structure</title>
      <p id="Par16">Table <xref rid="Tab1" ref-type="table">1</xref> and <xref rid="MOESM1" ref-type="media">S7</xref> Table show the performance of AllesTM with its underlying models, SPINE X, PROFphd, PSIPRED and SPOT-1D for the three-state prediction of secondary structure, i.e. α-helix, β-strand, and coil. Looking at the overall accuracy (ACC) on the cross-validation as well as on the independent test dataset, AllesTM, PSIPRED and SPOT-1D perform best: AllesTM with an ACC of 0.84 and 0.86 respectively for both datasets and PSIPRED with an even higher ACC of 0.85 and 0.87 and SPOT-1D with a remarkable ACC of 0.88 and 0.89. Other models closely follow, with RF being the worst performer (ACC of 0.8 and 0.82 on the two datasets). SPINE X and PROFphd are slightly behind, with an ACC of 0.77 and 0.78 on the independent test dataset, respectively. With the overall ACC being rather close especially for our developed models, it could be assumed that the size of the receptive field does not play a significant role for the prediction of secondary structure. Zooming into the performance of the methods for α-helix, β-strand and coil separately reveals that this is only true for α-helices and coils. Using the AUC as a threshold-independent measure, the performance for predicting helices correlates almost perfectly with the overall ACC (Fig. <xref rid="MOESM1" ref-type="media">S13</xref> and Fig. <xref rid="MOESM1" ref-type="media">S14</xref>). The RF model, for instance, with its ACC of 0.82 on the independent test dataset has an AUC of 0.8 on helices, while the LSTM achieves an ACC of 0.85 and an AUC of 0.86 on the same dataset and the same class. For β-strands, however, the situation is different. The AUCs of the RF and the GBM, the two models with the smallest receptive field, are 0.62 and 0.73 on the independent test dataset, respectively. The models with a larger receptive field, including conv, all achieve an AUC of 0.79 and above for β-strands. This is also in line with the observation that SPOT-1D especially excels at predicting β-strands (AUC of 0.88), presumably by combining an LSTM, which has a large receptive field, with contact predictions as an input feature.</p>
      <p id="Par17">Furthermore, the exceptional performance of PSIPRED and SPOT-1D leads to the conclusion that secondary structure in TMPs can be predicted without data or algorithms specifically tailored to that protein class. In order to fortify this statement, we evaluated the performance of all prediction methods only on the residues not located in the membrane (<xref rid="MOESM1" ref-type="media">S8</xref> Table). The ACC of AllesTM as well as PSIPRED and SPOT-1D (and all other methods) suffers from excluding the TM segments. As an example, the ACC of AllesTM drops from 0.78 to 0.73 on the independent test dataset. This indicates that these regions, which are mostly helical, are relatively easy to predict due to their highly hydrophobic nature and degenerate amino acid composition. Additionally, this comparison shows that for some cases including data from globular proteins is beneficial for the prediction performance, be it because of the larger amount of training data, or because the differences between transmembrane and globular proteins are not as relevant for this specific target.</p>
    </sec>
    <sec id="Sec8">
      <title>Relative solvent accessibility</title>
      <p id="Par18">We predicted the relative solvent accessibility (RSA) for each residue in three forms: i) the monomer RSA, which is the RSA of a residue if the protein chain is not bound to any other chain, ii) the complex RSA, which is the RSA of a residue taking the whole complex into account, and iii) the change of RSA upon complex formation, i.e. if a residue is part of the interaction interface.</p>
      <p id="Par19">Table <xref rid="Tab1" ref-type="table">1</xref>, <xref rid="MOESM1" ref-type="media">S9</xref>, <xref rid="MOESM1" ref-type="media">S10</xref>, and <xref rid="MOESM1" ref-type="media">S11</xref> Tables as well as Fig. <xref rid="MOESM1" ref-type="media">S15</xref>, Fig. <xref rid="MOESM1" ref-type="media">S16</xref>, Fig. <xref rid="MOESM1" ref-type="media">S17</xref>, Fig. <xref rid="MOESM1" ref-type="media">S18</xref>, Fig. <xref rid="MOESM1" ref-type="media">S19</xref> and Fig. <xref rid="MOESM1" ref-type="media">S20</xref> show the performance of our models including the final method AllesTM for these three prediction targets. The prediction performance of AllesTM for the monomer and the complex RSA is very similar. For example, AllesTM achieves an MAE of 0.15 and 0.14 on the independent test data, respectively, which is representative for the other models as well. Long range signals, which would be captured by a larger receptive field, have a noticeable impact on the MAE (e.g. 0.18 for RF and 0.15 for AllesTM on the independent test dataset predicting the monomer RSA), but not on the RMSE (e.g. 0.22 and 0.2, respectively). As the RMSE, which is similar for all models, is sensitive especially to large prediction errors, the difference in prediction performance for the RSA cases seems to be rather nuanced and only impacting the MAE. For the monomer and complex RSA benchmarks, we included SPINE X and SPOT-1D as well. SPINE X lags behind AllesTM independent of the applied performance measure but performs better on the complex RSA (MAE of 0.17) than on the monomer RSA (MAE of 0.2). For SPOT-1D it is the other way around as it even outperfoms AllesTM slightly on the monomeric RSA with an MAE of 0.14 compared to 0.15 of AllesTM, while lagging behind on the complex RSA (MAE 0.16 compared to 0.14, respectively). According to the benefits of using contact predictions as input features for targets such as the secondary structure, it is surprising that this feature seems to have a rather small impact on RSA prediction. Figure <xref rid="Fig2" ref-type="fig">2</xref> supports the previous observations showing the distribution of the actual monomer RSA values and the predicted ones. Although not explicitly visible from the numbers, the distribution of RF and GBM models’ predictions is clearly of different shape than the observed distribution.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Distribution of the observed and predicted monomer solvent accessibility values in the independent test dataset</p></caption><graphic xlink:href="12859_2020_3581_Fig2_HTML" id="MO2"/></fig></p>
      <p id="Par20">Compared to the other targets, the prediction of RSA changes does not show a very clear picture, or at least is different from the previous observations and changes dependent on the measure applied. Regarding the RMSE, for example, the RF and GBM models are on par with the final AllesTM method, achieving 0.13 on the cross-validation data and 0.15 on the independent test data outperforming the conv, dconv and LSTM models. For MAE, however, the opposite is the case as AllesTM, RF and GBM do not achieve an MAE as low as the conv, dconv and LSTM models.</p>
    </sec>
  </sec>
  <sec id="Sec9">
    <title>Discussion</title>
    <p id="Par21">In contrast to most of the previously proposed methods, usually focused on just one property, AllesTM predicts 10 different structural features of transmembrane proteins, i.e. almost every aspect of protein structure that can be extracted from atomic coordinates. It blends several state of the art machine learning algorithms: random forests and gradient boosting machines, convolutional neural networks in their original form as well as enhanced by dilated convolutions and residual connections, and, finally, long short-term memory architectures. All predictions were carefully evaluated by 5-fold cross-validation, tested on an independent dataset, and compared to the respective state of the art methods.</p>
    <p id="Par22">We found that the size of the receptive field, i.e. the number of adjacent residues considered while making predictions for a specific residue position, has a varying impact for different prediction targets. This is also true for contact predictions which are used by SPOT-1D as an input feature, giving the tool an advantage for some targets. Furthermore, using a method specifically geared towards TMPs is not always beneficial or at least can be compensated by the availability of more training data, as is for example the case for secondary structure prediction accuracy.</p>
  </sec>
  <sec id="Sec10">
    <title>Conclusions</title>
    <p id="Par23">In terms of prediction accuracy, the main results can be summarized as follows:
<list list-type="bullet"><list-item><p id="Par24"><bold>Z-coordinate</bold>. Being the only publicly available method for this particular target, AllesTM predicts Z-coordinates for individual residues with an average error of 3.72 Å (about 12% of the average membrane thickness), therefore locating the residues reasonably well.</p></list-item><list-item><p id="Par25"><bold>Topology</bold>. AllesTM achieves an accuracy of 0.9 in a four-state prediction (inside, outside, transmembrane, and re-entrant regions) and thus outperforms the leading methods MEMSAT-SVM, SCAMPI and PolyPhobius.</p></list-item><list-item><p id="Par26"><bold>B-factors</bold>, i.e. residue flexibility. AllesTM achieves an MAE of 0.63 for continuous value predictions and an AUC of 0.66 for two state (flexible/non-flexible) predictions. The respective values for PROFbval are 0.78 and 0.56.</p></list-item><list-item><p id="Par27"><bold>Three-state secondary structure</bold>. With an accuracy of 0.86 AllesTM lags slightly behind PSIPRED (0.87) and SPOT-1D (0.89).</p></list-item><list-item><p id="Par28"><bold>Relative solvent accessibility</bold> (RSA). For proteins complexed with other chains (MAE of 0.14) AllesTM outperforms SPINE X by approximately 20% and SPOT-1D by a small margin (MAE of 0.16). For monomers (MAE of 0.15) SPOT-1D is marginally better by an MAE difference of 0.01. The difference between monomers and their bound forms is unique to AllesTM and can be predicted with an MAE of 0.08.</p></list-item><list-item><p id="Par29"><bold>Torsion angles φ and ψ</bold>. AllesTM (MAEs of 17.34 and 30.41 for φ and ψ, respectively) performs better than ANGLOR (19.57 and 38.33) but worse than SPOT-1D (15.85 and 23.51).</p></list-item></list></p>
    <p id="Par30">By providing the multitude of prediciton targets and avoiding the use of complex dependencies characteristic for many other prediction tools, AllesTM is easy to setup and run, making it a useful universal tool for structural bioinformatics studies. AllesTM was developed using Python and is available as a standalone tool having only HHblits as a non-Python dependency. It can be either installed from GitHub or via the Python Package Manager. See <ext-link ext-link-type="uri" xlink:href="https://github.com/phngs/allestm">https://github.com/phngs/allestm</ext-link> for detailed instructions.</p>
  </sec>
  <sec id="Sec11">
    <title>Materials and methods</title>
    <sec id="Sec12">
      <title>Dataset</title>
      <p id="Par31">We retrieved from the Orientations of Proteins in the Membranes database (OPM) [<xref ref-type="bibr" rid="CR10">10</xref>] all 4357 entries belonging to either the “Alpha-helical polytopic” or the “Bitopic proteins” class, each containing one or multiple protein chains with known 3D structures. OPM entries contain information about the thickness of the membrane and the relative position of the protein with respect to it. In addition, OPM offers modified PDB (Berman et al., 2000) files, with proteins rotated and translated in such a way that each atom’s z-coordinate corresponds to the depth of that atom in the membrane. A z-coordinate of 0 means that the atom is located at the center of the membrane, while values deviating from 0 indicate the distance of an atom from the membrane center measured in Å. These distances can be either negative or positive, depending on which side of the membrane the atom is located at. Positive z-coordinates correspond to the side of the membrane facing the compartment, which is more “outside” compared to the other side of the membrane, where z-coordinate values are negative. For example, z-values for the inner and outer bacterial membranes are assigned in such a way that the periplasmic space is annotated with positive values for the inner membrane (negative values represent the cytoplasm), and negative values for the outer membrane (where positive values represent the extracellular space). If the absolute value of a Cα atom’s z-coordinate exceeds a half of the membrane’s thickness (which is about 15.1 ± 1.0 Å in our final dataset according to the OPM database), the residue is considered to be located outside of the membrane. Protein chains not crossing the membrane at least once, i.e. not having at least one Cα atom on both sides of the membrane, were excluded from consideration.</p>
      <p id="Par32">We only considered protein structures solved by X-ray crystallography with a resolution of 3.5 Å or better. Protein chains shorter than 30 residues as well as those containing only one amino acid type were ignored. Because some OPM entries had no properly annotated B-factors, we required structures to have more than one different B-factor value. Amino acid sequences were extracted from the ATOM records of the PDB entries (atomseq), and only proteins with coordinate information available for the backbone atoms N, C and Cα of every amino acid were retained for further analysis. Because the atomseq records do not always correspond to the complete protein sequence provided in the seqres records, we required at least 80% of the seqres sequence to be covered by the atomseq sequence.</p>
      <p id="Par33">Missing residues can result in unrealistically large steps between the coordinate, B-factor torsion angle and solvent accessibility values if they are consecutive according to the atomseq sequence but not to the seqres sequence. For this reason, we only allowed missing residues at the beginning and the end of the atomseq sequence but did not consider them during training and benchmarking of the classifier. These filtering steps resulted in a dataset of 5375 high-quality protein chains, which were subjected to redundancy reduction and cross-validation described in the next section.</p>
    </sec>
    <sec id="Sec13">
      <title>Redundancy reduction and cross-validation</title>
      <p id="Par34">While it is desirable to retain as many sequences as possible for training a machine learning model, there are some practical limits to the amount of data that can be used. First, the training process can be quite computationally intensive depending on the algorithm used, and second, redundant data leads to an overestimation of the method’s performance. Therefore, we chose to combine a two-step redundancy reduction procedure with a standard 5-fold cross-validation and testing on an independent dataset (Fig. <xref rid="Fig3" ref-type="fig">3</xref>). First, the initial dataset containing the 5375 protein chains was made non-redundant at the 40% sequence identity level using CD-HIT [<xref ref-type="bibr" rid="CR11">11</xref>], which resulted in a much smaller dataset of only 302 sequences well suitable for computer-intensive training procedures. Thirty-one of these sequences, i.e. 10%, were set aside as independent test data and not employed for any training or parameter tuning until the final models were built. The remaining 271 proteins, or 90%, formed the foundation for the cross-validation data. In order to provide a fair assessment of our methodology, we ensured an equal distribution of protein topologies (proteins with a given number of transmembrane segments (TMS)) in both parts of the split. From the initial cross-validation data, all proteins which had a sequence identity above 30% to any protein in the independent test data were removed, resulting in 178 proteins. These sequences were randomly split into five equally sized bins, with four of these bins used for training and validation, and one bin for testing, again ensuring equal distribution of protein topologies. In order to not overestimate the performance of our predictor during cross-validation, we removed all proteins from these five bins that shared a sequence identity greater than 30% with any protein in the testing bin. This approach guarantees that the test bin is completely independent from the training and validation bins, while retaining as many proteins for training as possible. In order to be able to choose the hyperparameters of the learning algorithms (i.e. the parameters, which affect the model but have to be chosen prior to the training process) without using the test bin or even the independent test set, the 4 training and validation bins were split further. 90% of the sequences were used to learn the model’s parameters (training), while 10% were used to estimate the best performing hyperparameters (validation). Similar to the process employed in the previous splits, topologies were equally distributed and proteins in the training dataset sharing more than 30% sequence identity to any protein in the validation dataset were removed. We performed these steps 5 times using each bin, and therefore each protein, for testing exactly once. Because of the rigorous redundancy reduction inside each fold, the distribution by protein topology resulted in the folds being of slightly different sizes (<xref rid="MOESM1" ref-type="media">S12</xref> Table).
<fig id="Fig3"><label>Fig. 3</label><caption><p>Datasets used for 5-fold cross-validation and testing. Gray boxes indicate sequences excluded from consideration as they shared more than 30% identity with the test data. See text for further details</p></caption><graphic xlink:href="12859_2020_3581_Fig3_HTML" id="MO3"/></fig></p>
    </sec>
    <sec id="Sec14">
      <title>Prediction targets</title>
      <sec id="Sec15">
        <title>Residue z-coordinates and protein topology</title>
        <p id="Par35">The depth of a residue in the membrane was obtained from the z-coordinate of its Cα atom in the modified PDB files derived from the OPM. Because we are mainly interested in the z-coordinates of residues inside and adjacent to the membrane boundaries, we limited the z-coordinate values to the range from − 25 to 25 Å as the membrane thickness normally does not exceed 30 Å. Values outside that range were set to − 25 and 25 Å, respectively. For training and prediction we scaled the z-coordinate values to a range from − 1 to 1, while for reporting the results the actual values were used.</p>
        <p id="Par36">In order to assign residues to discrete states, we determined four types of topological domains for each transmembrane protein. Initially, TMSs were defined as segments of which both ends have a distance of at most 10 Å to the opposite sides of the membrane. These segments are extended in both directions as long as they touch the membrane boundaries. Next, reentrant regions (RERs) were identified by finding stretches of amino acids which enter and exit the membrane on the same side, consist of at least 3 amino acids and immerge at least 3 Å into the membrane [<xref ref-type="bibr" rid="CR12">12</xref>]. Finally, the remaining segments, i.e. those which are neither TMSs nor RERs, were annotated as domains residing on either the inner or the outer side of the membrane depending on whether their residues’ z-coordinates were negative or positive, respectively. All residues were assigned to one of the four discrete states - inside, TMS, outside and RER – and encoded by binary vectors [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0] and [0, 0, 0, 1], respectively.</p>
      </sec>
      <sec id="Sec16">
        <title>Continuous and two-state flexibility</title>
        <p id="Par37">Residue flexibility was represented both as a continuous and a two-state discrete variable based on the B-factors derived from the PDB entries. Because B-factors are heavily dependent on the experimental conditions and the structure resolution, they are not directly comparable between different structures. We therefore converted them into z-scores for each protein separately using the formula
<disp-formula id="Equa"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${B}_{norm}=\frac{B_{\mathrm{r} aw}-\mu }{\sigma }$$\end{document}</tex-math><mml:math id="M2" display="block"><mml:msub><mml:mi>B</mml:mi><mml:mi mathvariant="italic">norm</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mrow><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="italic">aw</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>μ</mml:mi></mml:mrow><mml:mi>σ</mml:mi></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equa.gif" position="anchor"/></alternatives></disp-formula>where B<sub>raw</sub> is the original B-factor of a residue’s Cα atom, μ and σ are the mean and the standard deviation of all B-factors for a particular protein, respectively, and B<sub>norm</sub> is the continuous residue flexibility used as a prediction target. Continuous flexibility was converted into two discrete states for flexible (Bnorm &gt; 0.03) and rigid (Bnorm ≤0.03) [<xref ref-type="bibr" rid="CR13">13</xref>], numerically represented as 1 and 0, respectively.</p>
        <p id="Par38">A recent study suggested an approach to estimate the maximal average values of B-factors at a given crystallographic resolution [<xref ref-type="bibr" rid="CR14">14</xref>]. We found that in roughly a half of the structures in our independent dataset B-factors actually exceed the proposed maximal values, presumably as a consequence of the membrane proteins being removed from their natural stabilizing environment. Given the small number of available structures we chose not to exclude from consideration the atomic records with excessive B-factor values, but this issue definitely deserves further consideration.</p>
      </sec>
      <sec id="Sec17">
        <title>Torsion angles</title>
        <p id="Par39">The conformation of the protein backbone can be characterized using the three dihedral angles, which are the rotations around the bonds between N and Cα, Cα and C, C and N, respectively. The values of these angles are continuous and range from − 180° to 180°. Because the torsion angle ω is essentially flat and fixed to 180° due to the partial double-bond character of the peptide bond, we are only predicting the φ and ψ angles. The values of torsion angles were converted to the range from − 1 to 1.</p>
      </sec>
    </sec>
    <sec id="Sec18">
      <title>Secondary structure</title>
      <p id="Par40">Secondary structure assignments were calculated from known 3D structures using DSSP [<xref ref-type="bibr" rid="CR15">15</xref>, <xref ref-type="bibr" rid="CR16">16</xref>]. While DSSP defines the total of eight different secondary structure states, we followed the common approach and collapsed them to three states. H (α-helix), G (3<sub>10</sub>-helix) and I (π-helix) were converted to helix, E (extended strand) and B (isolated β-bridge) to β-sheet, and all the remaining states - T (turn), S (bend) and coil, to coil. These three states were presented to the learning algorithms as binary vectors: [1, 0, 0], [0, 1, 0], [0, 0, 1] for helix, β-sheet and coil respectively.</p>
      <sec id="Sec19">
        <title>Relative solvent accessibility</title>
        <p id="Par41">The DSSP program was also utilized to calculate three continuous targets for each residue concerning relative solvent accessibility (RSA). The absolute solvent accessibility of each residue, expressed in Å<sup>2</sup>, was normalized by dividing it by the maximum solvent accessibility according to [<xref ref-type="bibr" rid="CR17">17</xref>]. The first RSA target was calculated taking into account only the amino acid chain to which a given residue belongs, i.e. treating the protein as a monomer. The second RSA target was calculated taking into account all protein subunits, while the third target was defined as the difference between both values and therefore representing the change of RSA upon complex formation.</p>
      </sec>
    </sec>
    <sec id="Sec20">
      <title>Input features</title>
      <p id="Par42">We used the amino acid sequence and the evolutionary profile of the query protein as input to the classifier. The amino acid sequence was presented to the model using the standard one-hot encoding. A residue is represented by a vector of length 20 initialized with zeros, in which each position corresponds to one of the 20 standard amino acids. Only the position which corresponds to the current amino acid is set to one. The entire protein sequence is thus represented by a <italic>Lx20</italic> matrix, where <italic>L</italic> is the length of the sequence.</p>
      <p id="Par43">An evolutionary profile is another <italic>Lx20</italic> matrix representation of the input protein sequence derived from a multiple sequence alignment (MSA). Each value of the matrix indicates to which extent a specific amino acid is over- or underrepresented at a specific position of the alignment. More precisely, each value m<sub>i,j</sub> of the <italic>Lx20</italic> matrix is the log ratio of the relative frequency <italic>p</italic><sub><italic>i,j</italic></sub> of the amino acid <italic>i</italic> at column <italic>j</italic> in the MSA and the relative frequency <italic>p</italic><sub><italic>i</italic></sub> of the amino acid <italic>i</italic> in the entire alignment, normalized with the sigmoid function:
<disp-formula id="Equb"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${m}_{i,j}=\frac{1}{1+\exp \left(-\log \left({p}_{i,j}/{p}_i\right)\right)}$$\end{document}</tex-math><mml:math id="M4" display="block"><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mo>exp</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mo>−</mml:mo><mml:mo>log</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equb.gif" position="anchor"/></alternatives></disp-formula></p>
      <p id="Par44">If the amino acid <italic>i</italic> does not occur in the entire alignment or at a given position <italic>j</italic> of the MSA, the respective values of <italic>p</italic><sub><italic>i</italic></sub> or <italic>p</italic><sub><italic>i,j</italic></sub> can become zero, rendering the logarithm of <italic>p</italic><sub><italic>i,j</italic></sub><italic>/p</italic><sub><italic>i</italic></sub> invalid. To overcome this issue, we added a pseudo count of one to each <italic>p</italic><sub><italic>i,j</italic></sub> and a pseudo count equal to the number of columns in the alignment to each <italic>p</italic><sub><italic>i</italic></sub>.</p>
      <p id="Par45">MSAs were calculated from top-scoring hits obtained by searching the Uniclust30 database [<xref ref-type="bibr" rid="CR18">18</xref>] using HHblits, an iterative hidden Markov model-based method [<xref ref-type="bibr" rid="CR19">19</xref>], with all default parameters.</p>
    </sec>
    <sec id="Sec21">
      <title>Prediction algorithms</title>
      <sec id="Sec22">
        <title>Neural network architecture</title>
        <p id="Par46">We implemented three different NNs sharing a similar basic architecture consisting of three building blocks (Fig. <xref rid="Fig4" ref-type="fig">4</xref>). In the following, the differences and the similarities between these NNs as well as the hyperparameters are described in more detail.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Overview of the neural network architecture. The embedding layer processes the sequence feature before its output is concatenated with the evolutionary profile feature and passed to the hidden layers. As described in the text each hidden layer is either a convolutional layer, an LSTM layer or a dilated convolution block, and the number of such layers is determined by hyperparameter selection. Another hyperparameter is whether an identity mapping is used or not. If this is the case, the input to each hidden layer additionally bypasses that layer to be added or concatenated to its output. Feeding the next layer with both the input as well as the output of the previous layer enables it to correct errors introduced by the previous layer. In case the first hidden layer’s inputs are added to its outputs instead of concatenating them, their dimensions must be aligned to make this operation possible. Therefore, the identity mapping is realized by another convolutional layer with a widow size of one in order to allow for the addition operation. After the hidden layers, several additional convolutional layers may be used with a window size of one, which are connected to the output neurons representing the actual predictions</p></caption><graphic xlink:href="12859_2020_3581_Fig4_HTML" id="MO4"/></fig></p>
        <p id="Par47">The input and embedding layer form the entry point where the sequence and the evolutionary profile are fed to the NN. Before the two <italic>Lx20</italic> matrices representing these features are combined, the sequence feature is processed by a so-called embedding layer [<xref ref-type="bibr" rid="CR20">20</xref>]. During the training process, this layer learns to map the vectors of length 20 containing the binary encodings of the amino acids to a vector of <italic>n</italic><sub><italic>embedding</italic></sub> real numbers, with each value of the vector potentially representing an amino acid property. The rationale behind this mapping is that the vectors of two amino acids with similar properties are closer to each other in terms of the Euclidean distance between them than two amino acids with different properties. The benefit of this approach is that residue-related features such as physicochemical properties do not have to be manually selected but are rather inferred from the data. The application of the embedding layer to the sequence feature matrix results in a matrix of dimension Lxnembedding, which is then combined with the evolutionary profile to form a <italic>Lx (20 + n</italic><sub><italic>embedding</italic></sub><italic>)</italic> sized matrix to be fed to the hidden layers.</p>
        <p id="Par48">The hidden layers are the variable building blocks between the three NN architectures. They either consist of <italic>n</italic><sub><italic>hidden_layers</italic></sub> standard convolutional layers (conv layers), blocks of dilated convolutional layers (dconv blocks) or layers containing Long Short-Term Memory cells (LSTM layers) [<xref ref-type="bibr" rid="CR21">21</xref>, <xref ref-type="bibr" rid="CR22">22</xref>].</p>
        <p id="Par49">Conv layers are equivalent to the established sliding window approach, i.e. the same set of <italic>n</italic><sub><italic>hidden_neurons</italic></sub> neurons is applied to sequence segments in each position, with the central residue serving as a prediction target. The number of residues in the segment is defined by the window length <italic>w</italic>, which is also commonly known as kernel size in the deep learning literature.</p>
        <p id="Par50">Dconv blocks contain at least two layers equivalent to conv layers, except that the residues in the window are not directly adjacent. Instead they are spaced according to the dilation rate d. Considering the central residue at position <italic>i</italic>, a window size of 5 and a dilation rate d of 2, the complete window would contain the residues <italic>i-4, i-2, i, i + 2, i + 4</italic>. The benefit of this approach is the expanded receptive field. Given a specific residue for which a target is predicted, the receptive field defines how many adjacent residues are considered when doing the prediction. By increasing the dilation rate exponentially for each subsequent hidden layer, the receptive field also increases exponentially while the number of free parameters only increases linearly. Each dconv block contains n<sub>dconv_layers</sub> layers, resulting in a total number of <italic>n</italic><sub><italic>hidden</italic> _ <italic>layers</italic></sub> ∗ <italic>n</italic><sub><italic>dconv</italic> _ <italic>layers</italic></sub> hidden layers. The dilation rate <italic>d</italic> increases with each subsequent layer <italic>l</italic> in a dconv block according to the formula <italic>d</italic><sub><italic>l</italic></sub> = 2<sup><italic>l</italic> − 1</sup>. The conv as well as the dconv layers use the rectified linear unit (ReLu) activation function, which has replaced the sigmoid function as the most commonly used activation function in NNs [<xref ref-type="bibr" rid="CR23">23</xref>]. The output of a ReLu is calculated as max(0, <italic>x</italic>), with <italic>x</italic> being the input to the ReLu activation function. One of ReLu’s benefits is that it does not get saturated even for large input values, mitigating the problem of vanishing gradients which can occur in deep NNs when using the sigmoid or tanh activation functions.</p>
        <p id="Par51">LSTM layers are a type of recurrent neural network layers (RNNs) widely applied in the field of speech recognition and text analysis. Unlike the conv layers, whose receptive field is limited by the filter or window size, RNNs are capable of processing the entire sequence. One can imagine a RNN as a filter of size one which gets applied to one sequence position after the other. The difference to a convolutional layer is that instead of being independent of the previous position, the LSTM has access to the previous position’s output which gets combined with the input of the actual residue. In our model, we are using LSTMs in a bidirectional way by applying two separate LSTMs, one on the actual and one on the reversed sequence. For each sequence position the outputs of each of the two LSTMs are processed by a tanh activation function and concatenated to serve as input for the next layer in the network. Figure <xref rid="Fig5" ref-type="fig">5</xref> visualizes the difference between the receptive fields for different types of hidden layers and a specific set of hyperparameters.
<fig id="Fig5"><label>Fig. 5</label><caption><p>Impact of different types of hidden layers on the receptive field. The receptive field reflects the number of adjacent residues considered when making a prediction for a specific residue. Using a window size of three, the classic neural network architecture consisting of convolutional layers achieves a receptive field of size seven after three hidden layers. Using an increasing dilation rate for each layer, the receptive field can be expanded to 15 residues using the same window size and number of layers. For a bidirectional LSTM, the information from the complete sequence is available at each position and each layer</p></caption><graphic xlink:href="12859_2020_3581_Fig5_HTML" id="MO5"/></fig></p>
        <p id="Par52">An additional hyperparameter is the use of residual connections, also called skip connections. This strategy allows a given hidden layer to learn from the mistakes of the previous hidden layer. This is achieved by creating a connection, called identity mapping, which combines the output of the previous hidden layer with the output of the actual layer, essentially bypassing it. This combination is performed by either adding the respective outputs of the previous hidden layer and the actual layer or concatenating them. A special case is the identity mapping used with the first hidden layer in case addition is used as the combination function. Because the dimensions of the input, i.e. a <italic>Lx (20 + n</italic><sub><italic>embedding</italic></sub><italic>)</italic> sized matrix, does not match the output dimensions of the first hidden layer, their elements cannot be added. Therefore, a conv layer with a window size of one and a number of neurons equivalent to the number of outputs from the first hidden layer is used as the identity mapping.</p>
        <p id="Par53">Finally, the dense and output layers transform the results from the hidden layers into the desired output. The dense layers are a set of <italic>n</italic><sub><italic>dense_layers</italic></sub> conv layers with a window size of one and a number of <italic>n</italic><sub><italic>dense_neurons</italic></sub> neurons using the ReLu activation function. Their result is processed by the output layers, each directly connected to the last dense layer. The output layers are again conv layers with a window size of one but each with the number of neurons matching the prediction target dimensionality, i.e. one for the continuous targets such as z-coordinates or angles, one for the two-state flexibility as it is represented as a binary value, and three or more for categorical targets such as secondary structure or topology. The activation function is also dependent on the prediction target: linear activations for continuous targets, binary cross-entropy for binary targets, and categorical cross-entropy for categorical targets.</p>
      </sec>
      <sec id="Sec23">
        <title>Neural network training</title>
        <p id="Par54">While the previously mentioned hyperparameters affect the architecture of the NNs, there are a few more decisions to be made in order to optimize the training process: the batch size, the optimization algorithm and its learning rate, and the method for optimizing the hyperparameters. A batch is a number of training examples which are presented to the NN and the optimization algorithm before the weights of the model get updated. It therefore leads to an update of the weights depending not only on the error on a single sample, but also on the average error over a specific number of samples. The optimization algorithm is used to update the weights of the neurons in the NN while the learning rate determines how much these weights are adapted after each batch. As designing and training a state of the art NN is often described more an art than an exact science, we ran some initial tests resulting in the following decisions. By trial and error, we settled on Adam as the optimization algorithm of our choice as it leads to the fastest convergence and therefore reduced training time for each experiment [<xref ref-type="bibr" rid="CR24">24</xref>]. In contrast to a global learning rate, the Adam algorithm maintains a learning rate for each trainable weight in the network and adapts the weights based on the recent magnitudes of their gradients. Furthermore, we narrowed down the number of hyperparameter values describing the architecture to the most promising candidates with respect to prediction performance and runtime based on manual trials (<xref rid="MOESM1" ref-type="media">S13</xref> Table).</p>
        <p id="Par55">Because a grid search, i.e. testing all possible parameter combinations, would be computationally infeasible, we employed further strategies to make the parameter search and the training more efficient. Similar prediction targets were combined into one NN containing the output neurons for multiple prediction targets, thereby reducing the number of NNs to be trained. We conducted a trial-and-error assessment of the impact exerted on model performance by specific combinations of prediction targets compared to training the models separately. As a result, we combined the z-coordinates with the topology, the continuous with the two-state flexibility, the two torsion angles, and the three solvent accessibility targets. Only secondary structure was predicted most accurately without the influence of other targets. This results in only five NNs per type of hidden layer/block, i.e. only 15 different NNs. Instead of an exhaustive grid search, we used a random parameter search with the possible values given in <xref rid="MOESM1" ref-type="media">S13</xref> Table. More precisely, for each type of NN and for each of the five folds a random set of the possible values was chosen. If the chosen set of parameters performed better for a certain type of NN and fold combination it was accepted as the currently best solution. Two additional measures were used to further speed up the training process: early stopping and reducing the learning rate during training. Early stopping is a procedure to abort the training process if no further improvements are expected. This is achieved by evaluating the current NN on the validation set after one iteration through all training samples. If the performance on the validation set stagnates or even decreases, the training is stopped early. Because performance fluctuations are quite normal, the training proceeds for up to 10 more iterations after the currently best result has been achieved, unless another performance increase occurs. If the training is stopped, the state of the model at the iteration with the highest performance is selected as the final model. The early stopping approach has two benefits: it prevents overfitting and unnecessary iterations which are computationally intensive and time-consuming. While after 10 iterations the training stops completely, the learning rate is multiplied by 0.1 and therefore reduced automatically after 5 iterations without performance increase. This approach allows for faster convergence by using a higher learning rate in the beginning of the training and more precise weight updates (albeit with a lower learning rate) at the end.</p>
        <p id="Par56">The neural networks were implemented using the deep learning framework Keras [<xref ref-type="bibr" rid="CR25">25</xref>], which is based on the TensorFlow library [<xref ref-type="bibr" rid="CR26">26</xref>].</p>
      </sec>
      <sec id="Sec24">
        <title>Random forest</title>
        <p id="Par57">In addition to the three types of NNs, a random forest (RF) was implemented using the scikit-learn package [<xref ref-type="bibr" rid="CR27">27</xref>, <xref ref-type="bibr" rid="CR28">28</xref>]. A random forest is an ensemble method that employs <italic>n</italic><sub><italic>trees</italic></sub> decision trees. The rationale for using this approach is to combine many classifiers/regressors, which are themselves as accurate as possible, while being diverse at the same time. To achieve this, a subset of training samples is created for each tree using bootstrapping. Additional diversity is introduced by using only the fraction <italic>n</italic><sub><italic>features</italic></sub> of all input features for each tree. A decision tree is trained on a randomly selected subset of training examples and features and then choosing the feature, which provides the best split between the classes to be used for the first decision. This process is then performed for the two resulting subtrees, their subtrees and so forth. The default criteria used for the splits are mean squared error for regression problems and Gini impurity for classification problems. The output of the random forest is either a value between 0 and 1 for regression and binary classification problems, and a vector of values between 0 and 1 with the length equal to the number of output classes for multiclass classification problems. Significant benefits of the random forest approach are that it does not require data normalization, is not susceptible to overfitting, and reveals the importance of each feature and its impact on the prediction. In addition to <italic>n</italic><sub><italic>trees</italic></sub> and <italic>n</italic><sub><italic>features</italic></sub> two further parameters were optimized: the minimum number of samples in each tree’s leaves <italic>n</italic><sub><italic>min_samples</italic></sub>, which effectively reduces the depth of the trees, and the window size <italic>w</italic>. Because training an individual random forest model is fast, we were able to do a complete grid search over the parameters <italic>n</italic><sub><italic>features</italic></sub>, <italic>n</italic><sub><italic>min_samples</italic></sub>, and <italic>w</italic> (<xref rid="MOESM1" ref-type="media">S14</xref> Table), while <italic>ntrees</italic> was determined by repeatedly adding 100 trees until the performance on the validation data did not increase further.</p>
      </sec>
      <sec id="Sec25">
        <title>Gradient boosting machine</title>
        <p id="Par58">The fifth algorithm used is a gradient boosting machine (GBM) implemented in the XGBoost package, which can be seen as an enhancement of RFs [<xref ref-type="bibr" rid="CR29">29</xref>–<xref ref-type="bibr" rid="CR31">31</xref>]. The difference is that in RFs the trees are independent of each other and can therefore be created in parallel. In GBMs every tree is trained to reduce the error of the preceding tree and therefore they are trained sequentially (which does not mean GBMs cannot use parallel processing). This effectively results in the model focusing more on the difficult samples for which the error is large. More precisely, the subsequent trees are trained on the gradient of a given loss function with respect to the predicted values of the previous tree. The output dimensions and value ranges are equal to those of RFs. Because of the more sophisticated approach and training methodology involving a gradient descent method, GBMs are generally more accurate and require fewer trees until convergence, i.e. until the point where additional trees do not lead to a performance increase. On the downside, they are more sensitive to overfitting and thus require regularization methods, which are controlled by additional hyperparameters. The parameters <italic>n</italic><sub><italic>trees</italic></sub>, <italic>n</italic><sub><italic>features</italic></sub> and <italic>w</italic> are similar to those of RFs with <italic>n</italic><sub><italic>trees</italic></sub> again being optimized by early stopping. The additional parameters control the number of samples <italic>n</italic><sub><italic>samples</italic></sub> used in each tree, the learning rate <italic>r</italic> for gradient descent, the maximum depth <italic>n</italic><sub><italic>depth</italic></sub> of each tree and the two parameters γ and <italic>n</italic><sub><italic>min_child_weight</italic></sub>, which are used for regularization. Because numerous tunable hyperparameter combinations would have been impossible to test exhaustively, we used a random search approach with the values shown in <xref rid="MOESM1" ref-type="media">S15</xref> Table.</p>
      </sec>
      <sec id="Sec26">
        <title>Blending</title>
        <p id="Par59">Our final predictor, AllesTM, is a combination of the previously described models derived during cross-validation. Similar to the idea to combine multiple weak classifiers on which RFs are based, we combined the tree different NNs with the RF and the GBM for each prediction target using a meta classifier, a process often referred to as blending. Because of the diversity of the classifiers, each of them is able to infer different associations between the input features and the target variable. To combine the methods, we first made predictions for the validation bins in each fold with every classifier created using the training data of the corresponding fold. These predictions were then used as input to train the meta classifier. The methods of choice for the meta classifiers are linear regression for continuous targets and logistic regression for binary and categorical targets, resembling a weighted average over the base models’ predictions. This approach was implemented using the scikit-learn library. Because the models are trained during cross-validation, there are five trained models for each algorithm. In order to make predictions for the independent test dataset as well as for the creation of the final predictor AllesTM, the outputs of the models are averaged. E.g. to predict the z-coordinates of a residue, five meta models exist, each combining the three different NNs with the RF and the GBM. The result of these five meta models is then averaged to produce the final prediction, which therefore can be seen as a combination of 30 different models, i.e. five different algorithms plus one meta model for each fold.</p>
      </sec>
    </sec>
    <sec id="Sec27">
      <title>Comparison with other methods</title>
      <p id="Par60">Because of the variety of prediction targets covered by AllesTM, we had to compare its predictive power with several individual previously published methods. The only target where no comparison was possible were the z-coordinates. Although a method called ZPRED [<xref ref-type="bibr" rid="CR32">32</xref>, <xref ref-type="bibr" rid="CR33">33</xref>] was published to predict the location of a residue in the membrane, it is not publicly available and, according to the publication, its predictions are restricted to the absolute distance of a residue to the membrane center, i.e. not providing information about the side of the membrane at which the residue is located. ANGLOR [<xref ref-type="bibr" rid="CR34">34</xref>] predicts dihedral angles by using a NN for the φ angles and a support vector machine (SVM) for the ψ angles. SPINE X [<xref ref-type="bibr" rid="CR35">35</xref>] is a multi-layer NN-based tool for predicting dihedral angles as well as secondary structure and solvent accessibility. We converted the absolute values of solvent accessibility produced by SPINE X to relative values by dividing them by the maximum solvent accessibility of a given amino acid, the same approach as in AllesTM. PredyFlexy [<xref ref-type="bibr" rid="CR36">36</xref>] derives continuous B-factor values by assigning short structural fragments from a pre-compiled library to the sequence using a SVM-powered scoring scheme. The B-factors of these fragments are then transferred to the target sequence resulting in the prediction. Another tool predicting B-factor values is PROFbval [<xref ref-type="bibr" rid="CR13">13</xref>]. The method is trained to emit a 10-state flexibility, which is then converted to a binary and a continuous prediction. PolyPhobius [<xref ref-type="bibr" rid="CR37">37</xref>] and MEMSAT-SVM [<xref ref-type="bibr" rid="CR38">38</xref>] both predict transmembrane protein topology. While the former is based on hidden Markov models, the latter uses an SVM. MEMSAT-SVM is especially interesting for comparison because of its ability to predict RERs. We also included SCAMPI [<xref ref-type="bibr" rid="CR39">39</xref>] as a more recent topology prediction method. SCAMPI is another HMM based method which uses the fact, that the N- and the C-terminal helices are more hydrophobic. Two further well-established methods were used to evaluate the secondary structure prediction performance, PROFphd [<xref ref-type="bibr" rid="CR40">40</xref>] and PSIPRED [<xref ref-type="bibr" rid="CR41">41</xref>]. Both are using evolutionary information derived from MSAs and two neural networks, one for the initial prediction and a second one for smoothing. Recently PSIPRED was retrained using more layers in order to improve its prediction performance [<xref ref-type="bibr" rid="CR42">42</xref>]. Finally, we included SPOT-1D [<xref ref-type="bibr" rid="CR43">43</xref>], a very recent and versatile method capable of predicting secondary structure, solvent accessibility (which we converted to relative values similar to SPINE X) as well as φ and ψ angles. It uses LSTMs and CNNs and takes the output of several other methods, e.g. contact predictions, to enhance prediction performance.</p>
    </sec>
    <sec id="Sec28">
      <title>Evaluation metrics</title>
      <p id="Par61">In order to benchmark the classifier and to compare its performance to other methods, we calculated several performance measures. For the continuous target variables (z-coordinates, flexibility and torsion angles), we calculated mean absolute error (MAE), mean squared error (MSE), root-mean-square error (RMSE), Pearson correlation coefficient (<italic>r</italic><sub><italic>p</italic></sub>) and Spearman’s rank correlation (<italic>r</italic><sub><italic>s</italic></sub>) using the following equations:
<disp-formula id="Equc"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$MAE=\frac{\sum_{i=1}^n\mid {y}_i-{x}_i\mid }{n}$$\end{document}</tex-math><mml:math id="M6" display="block"><mml:mi mathvariant="italic">MAE</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo>∣</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equc.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equd"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$MSE=\frac{\sum_{i=1}^n{\left({y}_i-{x}_i\right)}^2}{n}$$\end{document}</tex-math><mml:math id="M8" display="block"><mml:mi mathvariant="italic">MSE</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equd.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Eque"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$RMSE=\sqrt{MSE}$$\end{document}</tex-math><mml:math id="M10" display="block"><mml:mtext mathvariant="italic">RMSE</mml:mtext><mml:mo>=</mml:mo><mml:msqrt><mml:mi mathvariant="italic">MSE</mml:mi></mml:msqrt></mml:math><graphic xlink:href="12859_2020_3581_Article_Eque.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equf"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$r=\frac{\sum_{i=1}^n\left({x}_i-{m}_x\right)\ast \left({y}_i-{m}_y\right)}{\sqrt{\sum_{i=1}^n{\left({x}_i-{m}_x\right)}^2\ast {\left({y}_i-{m}_y\right)}^2}}$$\end{document}</tex-math><mml:math id="M12" display="block"><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mo>∗</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:msqrt><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>x</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup><mml:mo>∗</mml:mo><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>y</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equf.gif" position="anchor"/></alternatives></disp-formula>where <italic>y</italic><sub><italic>i</italic></sub> and <italic>x</italic><sub><italic>i</italic></sub> are the predicted and observed values, <italic>n</italic> is the number of predictions, and <italic>m</italic><sub><italic>x</italic></sub> and <italic>m</italic><sub><italic>y</italic></sub> are the means of all predictions and observed values, respectively.</p>
      <p id="Par62">For the discrete target variables (topology and flexibility) we calculated accuracy (ACC), precision (P), recall (R), F1-score (F1) and Matthews correlation coefficient (MCC) as follows:
<disp-formula id="Equg"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ACC=\frac{TP}{TP+ TN+ FP+ FN}$$\end{document}</tex-math><mml:math id="M14" display="block"><mml:mi mathvariant="italic">ACC</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi mathvariant="italic">TP</mml:mi><mml:mrow><mml:mi mathvariant="italic">TP</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">TN</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FP</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FN</mml:mi></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equg.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equh"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$P=\frac{TP}{TP+ FP}$$\end{document}</tex-math><mml:math id="M16" display="block"><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi mathvariant="italic">TP</mml:mi><mml:mrow><mml:mi mathvariant="italic">TP</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FP</mml:mi></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equh.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equi"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$R=\frac{TP}{TP+ FN}$$\end{document}</tex-math><mml:math id="M18" display="block"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mi mathvariant="italic">TP</mml:mi><mml:mrow><mml:mi mathvariant="italic">TP</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FN</mml:mi></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equi.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equj"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${F}_1=\frac{2\ast P\ast R}{P+R}$$\end{document}</tex-math><mml:math id="M20" display="block"><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>∗</mml:mo><mml:mi>P</mml:mi><mml:mo>∗</mml:mo><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equj.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equk"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$MCC=\frac{TP\ast TN- FP\ast FN}{\sqrt{\left( TP+ FP\right)\ast \left( TP+ FN\right)\ast \left( TN+ FP\right)\ast \left( TN+ FN\right)}}$$\end{document}</tex-math><mml:math id="M22" display="block"><mml:mi mathvariant="italic">MCC</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="italic">TP</mml:mi><mml:mo>∗</mml:mo><mml:mi mathvariant="italic">TN</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="italic">FP</mml:mi><mml:mo>∗</mml:mo><mml:mi mathvariant="italic">FN</mml:mi></mml:mrow><mml:msqrt><mml:mrow><mml:mfenced close=")" open="("><mml:mrow><mml:mi mathvariant="italic">TP</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FP</mml:mi></mml:mrow></mml:mfenced><mml:mo>∗</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mi mathvariant="italic">TP</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FN</mml:mi></mml:mrow></mml:mfenced><mml:mo>∗</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mi mathvariant="italic">TN</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FP</mml:mi></mml:mrow></mml:mfenced><mml:mo>∗</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mi mathvariant="italic">TN</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">FN</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msqrt></mml:mfrac></mml:math><graphic xlink:href="12859_2020_3581_Article_Equk.gif" position="anchor"/></alternatives></disp-formula>where TP, TN, FP and FN are the number of true positives, true negatives, false positives, and false negatives, respectively.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec29">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="12859_2020_3581_MOESM1_ESM.docx">
            <caption>
              <p><bold>Additional file 1: S1 Fig.</bold> Distribution of the observed and predicted z-coordinates on the cross-validation dataset. <bold>S2 Fig.</bold> Distribution of the observed and predicted z-coordinates on the independent test dataset. <bold>S3 Fig.</bold> Precision-recall and ROC curves of the predicted topology on the cross-validation dataset. <bold>S4 Fig.</bold> Precision-recall and ROC curves of the predicted topology on the independent test dataset. <bold>S5 Fig.</bold> Distribution of the observed and predicted continuous flexibility on the cross-validation dataset. <bold>S6 Fig.</bold> Distribution of the observed and predicted continuous flexibility on the independent test dataset. <bold>S7 Fig.</bold> Precision-recall and ROC curve of the predicted two-state flexibility on the cross-validation dataset. <bold>S8 Fig.</bold> Precision-recall and ROC curve of the predicted two-state flexibility on the independent test dataset. <bold>S9 Fig.</bold> Distribution of the observed and predicted φ angles on the cross-validation dataset. <bold>S10 Fig.</bold> Distribution of the observed and predicted φ angles on the independent test dataset. <bold>S11 Fig.</bold> Distribution of the observed and predicted ψ angles on the cross-validation dataset. <bold>S12 Fig.</bold> Distribution of the observed and predicted ψ angles on the independent test dataset. <bold>S13 Fig.</bold> Precision-recall and ROC curves of the predicted secondary structure on the cross-validation dataset. <bold>S14 Fig.</bold> Precision-recall and ROC curves of the predicted secondary structure on the independent test dataset. <bold>S15 Fig.</bold> Distribution of the observed and predicted relative solvent accessibility of monomers on the cross-validation dataset. <bold>S16 Fig.</bold> Distribution of the observed and predicted relative solvent accessibility of monomers on the independent test dataset. <bold>S17 Fig.</bold> Distribution of the observed and predicted relative solvent accessibility of protein chains in complexes on the cross-validation dataset. <bold>S18 Fig.</bold> Distribution of the observed and predicted relative solvent accessibility of protein chains in complexes on the independent test dataset. <bold>S19 Fig.</bold> Distribution of the observed and predicted difference in relative solvent accessibility between the bound and the unbound form of a protein chain on the cross-validation dataset. <bold>S20 Fig.</bold> Distribution of the observed and predicted difference in relative solvent accessibility between the bound and the unbound form of a protein chain on the independent test dataset. <bold>S1 Table.</bold> Performance of several algorithms, including the final method AllesTM, for z-coordinate prediction on the cross-validation and independent test datasets. <bold>S2 Table.</bold> Protein topology prediction performance. <bold>S3 Table.</bold> Continuous flexibility prediction performance. <bold>S4 Table.</bold> Two-state flexibility prediction performance. <bold>S5 Table.</bold> φ angles performance. <bold>S6 Table.</bold> ψ angles performance. <bold>S7 Table.</bold> Secondary structure prediction performance. <bold>S8 Table.</bold> Secondary structure prediction performance excluding residues situated in transmembrane segments. <bold>S9 Table.</bold> Monomer solvent accessibility performance. <bold>S10 Table.</bold> Complex solvent accessibility performance. <bold>S11 Table.</bold> Change of solvent accessibility performance. <bold>S12 Table.</bold> Number of sequences in the training, validation, and test datasets across the five folds. Because of the two-step redundancy reduction procedure, the number of proteins in the validation and training parts are dependent on the test data in the particular fold. <bold>S13 Table.</bold> Parameter values used for the different layer types during random parameter search. <bold>S14 Table.</bold> Parameter values used during grid search of random forest models. <bold>S15 Table.</bold> Parameter values used during random search of GBM models.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s12859-020-03581-8.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>This work was supported by the DFG grant “Understanding intramembrane proteolysis” (FR 1411/13-1) to DF.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>PH and DF designed the study. MW and PH analyzed the data. SB tested the method. DF obtained funding and supervised the project. PH and DF wrote the manuscript. All authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>This work was supported by the DFG grant “Understanding intramembrane proteolysis” (FR 1411/13–1) to DF.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>- The software AllesTM generated and analyzed in this study is available in the GitHub repository, <ext-link ext-link-type="uri" xlink:href="https://github.com/phngs/allestm">https://github.com/phngs/allestm</ext-link></p>
    <p>-The datasets used and/or analyzed in this current study are available from the corresponding author upon request</p>
  </notes>
  <notes id="FPar1">
    <title>Ethics approval and consent to participate</title>
    <p id="Par63">Not applicable.</p>
  </notes>
  <notes id="FPar2">
    <title>Consent for publication</title>
    <p id="Par64">Not applicable.</p>
  </notes>
  <notes id="FPar3" notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par65">The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qian</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Sejnowski</surname>
            <given-names>TJ</given-names>
          </name>
        </person-group>
        <article-title>Predicting the secondary structure of globular proteins using neural network models</article-title>
        <source>J Mol Biol</source>
        <year>1988</year>
        <volume>202</volume>
        <issue>4</issue>
        <fpage>865</fpage>
        <lpage>884</lpage>
        <?supplied-pmid 3172241?>
        <pub-id pub-id-type="pmid">3172241</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kandathil</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Greener</surname>
            <given-names>JG</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>DT</given-names>
          </name>
        </person-group>
        <article-title>Recent developments in deep learning applied to protein structure prediction</article-title>
        <source>Proteins.</source>
        <year>2019</year>
        <volume>87</volume>
        <issue>12</issue>
        <fpage>1179</fpage>
        <lpage>1189</lpage>
        <?supplied-pmid 31589782?>
        <pub-id pub-id-type="pmid">31589782</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Min</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Yoon</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Deep learning in bioinformatics</article-title>
        <source>Brief Bioinform</source>
        <year>2017</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>851</fpage>
        <lpage>869</lpage>
        <?supplied-pmid 27473064?>
        <pub-id pub-id-type="pmid">27473064</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Ding</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Pan</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Gao</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Deep learning in bioinformatics: introduction, application, and perspective in the big data era</article-title>
        <source>Methods.</source>
        <year>2019</year>
        <volume>166</volume>
        <fpage>4</fpage>
        <lpage>21</lpage>
        <?supplied-pmid 31022451?>
        <pub-id pub-id-type="pmid">31022451</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gobel</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Sander</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Schneider</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Valencia</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Correlated mutations and residue contacts in proteins</article-title>
        <source>Proteins.</source>
        <year>1994</year>
        <volume>18</volume>
        <issue>4</issue>
        <fpage>309</fpage>
        <lpage>317</lpage>
        <?supplied-pmid 8208723?>
        <pub-id pub-id-type="pmid">8208723</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fuchs</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kirschner</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Frishman</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Prediction of helix-helix contacts and interacting helices in polytopic membrane proteins using neural networks</article-title>
        <source>Proteins.</source>
        <year>2009</year>
        <volume>74</volume>
        <issue>4</issue>
        <fpage>857</fpage>
        <lpage>871</lpage>
        <?supplied-pmid 18704938?>
        <pub-id pub-id-type="pmid">18704938</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hönigschmid</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Frishman</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Accurate prediction of helix interactions and residue contacts in membrane proteins</article-title>
        <source>J Struct Biol</source>
        <year>2016</year>
        <volume>194</volume>
        <issue>1</issue>
        <fpage>112</fpage>
        <lpage>123</lpage>
        <?supplied-pmid 26851352?>
        <pub-id pub-id-type="pmid">26851352</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wilkinson</surname>
            <given-names>DL</given-names>
          </name>
          <name>
            <surname>Harrison</surname>
            <given-names>RG</given-names>
          </name>
        </person-group>
        <article-title>Predicting the solubility of recombinant proteins in Escherichia coli</article-title>
        <source>Biotechnology (NY)</source>
        <year>1991</year>
        <volume>9</volume>
        <issue>5</issue>
        <fpage>443</fpage>
        <lpage>448</lpage>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Martin-Galiano</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Smialowski</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Frishman</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Predicting experimental properties of integral membrane proteins by a naive Bayes approach</article-title>
        <source>Proteins.</source>
        <year>2008</year>
        <volume>70</volume>
        <issue>4</issue>
        <fpage>1243</fpage>
        <lpage>1256</lpage>
        <?supplied-pmid 17876826?>
        <pub-id pub-id-type="pmid">17876826</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lomize</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Lomize</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Pogozheva</surname>
            <given-names>ID</given-names>
          </name>
          <name>
            <surname>Mosberg</surname>
            <given-names>HI</given-names>
          </name>
        </person-group>
        <article-title>OPM: orientations of proteins in membranes database</article-title>
        <source>Bioinformatics.</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>5</issue>
        <fpage>623</fpage>
        <lpage>625</lpage>
        <?supplied-pmid 16397007?>
        <pub-id pub-id-type="pmid">16397007</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Godzik</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Cd-hit: a fast program for clustering and comparing large sets of protein or nucleotide sequences</article-title>
        <source>Bioinformatics.</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>13</issue>
        <fpage>1658</fpage>
        <lpage>1659</lpage>
        <?supplied-pmid 16731699?>
        <pub-id pub-id-type="pmid">16731699</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Viklund</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Granseth</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Elofsson</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Structural classification and prediction of reentrant regions in alpha-helical transmembrane proteins: application to complete genomes</article-title>
        <source>J Mol Biol</source>
        <year>2006</year>
        <volume>361</volume>
        <issue>3</issue>
        <fpage>591</fpage>
        <lpage>603</lpage>
        <?supplied-pmid 16860824?>
        <pub-id pub-id-type="pmid">16860824</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schlessinger</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rost</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Protein flexibility and rigidity predicted from sequence</article-title>
        <source>Proteins.</source>
        <year>2005</year>
        <volume>61</volume>
        <issue>1</issue>
        <fpage>115</fpage>
        <lpage>126</lpage>
        <?supplied-pmid 16080156?>
        <pub-id pub-id-type="pmid">16080156</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Carugo</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>How large B-factors can be in protein crystal structures</article-title>
        <source>BMC Bioinformatics.</source>
        <year>2018</year>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>61</fpage>
        <?supplied-pmid 29471780?>
        <pub-id pub-id-type="pmid">29471780</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kabsch</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Sander</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and geometrical features</article-title>
        <source>Biopolymers.</source>
        <year>1983</year>
        <volume>22</volume>
        <issue>12</issue>
        <fpage>2577</fpage>
        <lpage>2637</lpage>
        <?supplied-pmid 6667333?>
        <pub-id pub-id-type="pmid">6667333</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <mixed-citation publication-type="other">Touw WG, Baakman C, Black J, Beek te TAH, Krieger E, Joosten RP, et al. A series of PDB-related databanks for everyday needs. Nucleic Acids Res 2015;43(Database issue):D364–D368.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rost</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Sander</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Conservation and prediction of solvent accessibility in protein families</article-title>
        <source>Proteins.</source>
        <year>1994</year>
        <volume>20</volume>
        <issue>3</issue>
        <fpage>216</fpage>
        <lpage>226</lpage>
        <?supplied-pmid 7892171?>
        <pub-id pub-id-type="pmid">7892171</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <mixed-citation publication-type="other">Mirdita M, den Driesch von L, Galiez C, Martin MJ, Söding J, Steinegger M. Uniclust databases of clustered and deeply annotated protein sequences and alignments. Nucleic Acids Res 2017;45(D1):D170–D176.</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Remmert</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Biegert</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hauser</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Söding</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>HHblits: lightning-fast iterative protein sequence searching by HMM-HMM alignment</article-title>
        <source>Nat Methods</source>
        <year>2011</year>
        <volume>9</volume>
        <issue>2</issue>
        <fpage>173</fpage>
        <lpage>175</lpage>
        <?supplied-pmid 22198341?>
        <pub-id pub-id-type="pmid">22198341</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">Mikolov T, Sutskever I, Chen K, Corrado G, Dean J. Distributed Representations of Words and Phrases and their Compositionality. Vol. cs.CL, <ext-link ext-link-type="uri" xlink:href="http://arxiv.org">arXiv.org</ext-link>. 2013..</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>LeCun</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Bengio</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Hinton</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Deep learning</article-title>
        <source>Nature.</source>
        <year>2015</year>
        <volume>521</volume>
        <issue>7553</issue>
        <fpage>436</fpage>
        <lpage>444</lpage>
        <?supplied-pmid 26017442?>
        <pub-id pub-id-type="pmid">26017442</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Yu F, Koltun V. Multi-Scale Context Aggregation by Dilated Convolutions. Vol. cs.CV, <ext-link ext-link-type="uri" xlink:href="http://arxiv.org">arXiv.org</ext-link>. 2015.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Glorot</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Bordes</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Bengio</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Deep sparse rectifier neural networks</article-title>
        <source>Proceed Machine Learn Res</source>
        <year>2011</year>
        <volume>15</volume>
        <fpage>315</fpage>
        <lpage>323</lpage>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <mixed-citation publication-type="other">Kingma DP, Ba J. Adam: A Method for Stochastic Optimization. Vol. cs. LG, <ext-link ext-link-type="uri" xlink:href="http://arxiv.org">arXiv.org</ext-link>. 2014.</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <mixed-citation publication-type="other">Chollet F. Keras [Internet]. <ext-link ext-link-type="uri" xlink:href="https://keras.io">https://keras.io</ext-link>. 2015 [cited 2018 Mar 19]. Available from: <ext-link ext-link-type="uri" xlink:href="https://keras.io">https://keras.io</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <mixed-citation publication-type="other">Abadi M, Agarwal A, Barham P, Brevdo E, Chen Z, Citro C, et al. TensorFlow: Large-Scale Machine Learning on Heterogeneous Distributed Systems. Vol. cs. DC, <ext-link ext-link-type="uri" xlink:href="http://arxiv.org">arXiv.org</ext-link>. 2016.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Svetnik</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Liaw</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Tong</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Culberson</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Sheridan</surname>
            <given-names>RP</given-names>
          </name>
          <name>
            <surname>Feuston</surname>
            <given-names>BP</given-names>
          </name>
        </person-group>
        <article-title>Random forest: a classification and regression tool for compound classification and QSAR modeling</article-title>
        <source>J Chem Inf Comput Sci</source>
        <year>2003</year>
        <volume>43</volume>
        <issue>6</issue>
        <fpage>1947</fpage>
        <lpage>1958</lpage>
        <?supplied-pmid 14632445?>
        <pub-id pub-id-type="pmid">14632445</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <mixed-citation publication-type="other">Pedregosa F, Varoquaux G, Gramfort A, Michel V, Thirion B, Grisel O, et al. Scikit-learn: Machine Learning in Python. Vol. cs. LG, <ext-link ext-link-type="uri" xlink:href="http://arxiv.org">arXiv.org</ext-link>. 2012.</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Friedman</surname>
            <given-names>JH</given-names>
          </name>
        </person-group>
        <article-title>Stochastic gradient boosting</article-title>
        <source>Computational Stat Data Analysis</source>
        <year>2002</year>
        <volume>38</volume>
        <issue>4</issue>
        <fpage>367</fpage>
        <lpage>378</lpage>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Friedman</surname>
            <given-names>JH</given-names>
          </name>
        </person-group>
        <article-title>Greedy function approximation: a gradient boosting machine</article-title>
        <source>Ann Stat</source>
        <year>2000</year>
        <volume>29</volume>
        <fpage>1189</fpage>
        <lpage>1232</lpage>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <mixed-citation publication-type="other">Chen T, Guestrin C. XGBoost: A Scalable Tree Boosting System. Vol. cs. LG, <ext-link ext-link-type="uri" xlink:href="http://arxiv.org">arXiv.org</ext-link>. 2016.</mixed-citation>
    </ref>
    <ref id="CR32">
      <label>32.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Granseth</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Viklund</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Elofsson</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>ZPRED: predicting the distance to the membrane center for residues in alpha-helical membrane proteins</article-title>
        <source>Bioinformatics.</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>14</issue>
        <fpage>e191</fpage>
        <lpage>e196</lpage>
        <?supplied-pmid 16873471?>
        <pub-id pub-id-type="pmid">16873471</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Papaloukas</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Granseth</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Viklund</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Elofsson</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Estimating the length of transmembrane helices using Z-coordinate predictions</article-title>
        <source>Protein Sci</source>
        <year>2008</year>
        <volume>17</volume>
        <issue>2</issue>
        <fpage>271</fpage>
        <lpage>278</lpage>
        <?supplied-pmid 18096645?>
        <pub-id pub-id-type="pmid">18096645</pub-id>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>ANGLOR: a composite machine-learning algorithm for protein backbone torsion angle prediction</article-title>
        <source>PLoS One</source>
        <year>2008</year>
        <volume>3</volume>
        <issue>10</issue>
        <fpage>e3400</fpage>
        <?supplied-pmid 18923703?>
        <pub-id pub-id-type="pmid">18923703</pub-id>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Faraggi</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Kurgan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>SPINE X: improving protein secondary structure prediction by multistep learning coupled with prediction of solvent accessible surface area and backbone torsion angles</article-title>
        <source>J Comput Chem</source>
        <year>2012</year>
        <volume>33</volume>
        <issue>3</issue>
        <fpage>259</fpage>
        <lpage>267</lpage>
        <?supplied-pmid 22045506?>
        <pub-id pub-id-type="pmid">22045506</pub-id>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>de Brevern</surname>
            <given-names>AG</given-names>
          </name>
          <name>
            <surname>Bornot</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Craveur</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Etchebest</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Gelly</surname>
            <given-names>J-C</given-names>
          </name>
        </person-group>
        <article-title>PredyFlexy: flexibility and local structure prediction from sequence</article-title>
        <source>Nucleic Acids Research</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>Web Server issue</issue>
        <fpage>W317</fpage>
        <lpage>W322</lpage>
        <?supplied-pmid 22689641?>
        <pub-id pub-id-type="pmid">22689641</pub-id>
      </element-citation>
    </ref>
    <ref id="CR37">
      <label>37.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Käll</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Krogh</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Sonnhammer</surname>
            <given-names>ELL</given-names>
          </name>
        </person-group>
        <article-title>An HMM posterior decoder for sequence feature prediction that includes homology information</article-title>
        <source>Bioinformatics.</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>Suppl 1</issue>
        <fpage>i251</fpage>
        <lpage>i257</lpage>
        <?supplied-pmid 15961464?>
        <pub-id pub-id-type="pmid">15961464</pub-id>
      </element-citation>
    </ref>
    <ref id="CR38">
      <label>38.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nugent</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>DT</given-names>
          </name>
        </person-group>
        <article-title>Transmembrane protein topology prediction using support vector machines</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>159</fpage>
        <?supplied-pmid 19470175?>
        <pub-id pub-id-type="pmid">19470175</pub-id>
      </element-citation>
    </ref>
    <ref id="CR39">
      <label>39.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Peters</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Tsirigos</surname>
            <given-names>KD</given-names>
          </name>
          <name>
            <surname>Shu</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Elofsson</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Improved topology prediction using the terminal hydrophobic helices rule</article-title>
        <source>Bioinformatics.</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>8</issue>
        <fpage>1158</fpage>
        <lpage>1162</lpage>
        <?supplied-pmid 26644416?>
        <pub-id pub-id-type="pmid">26644416</pub-id>
      </element-citation>
    </ref>
    <ref id="CR40">
      <label>40.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rost</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Sander</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Combining evolutionary information and neural networks to predict protein secondary structure</article-title>
        <source>Proteins.</source>
        <year>1994</year>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>55</fpage>
        <lpage>72</lpage>
        <?supplied-pmid 8066087?>
        <pub-id pub-id-type="pmid">8066087</pub-id>
      </element-citation>
    </ref>
    <ref id="CR41">
      <label>41.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jones</surname>
            <given-names>DT</given-names>
          </name>
        </person-group>
        <article-title>Protein secondary structure prediction based on position-specific scoring matrices</article-title>
        <source>J Mol Biol</source>
        <year>1999</year>
        <volume>292</volume>
        <issue>2</issue>
        <fpage>195</fpage>
        <lpage>202</lpage>
        <?supplied-pmid 10493868?>
        <pub-id pub-id-type="pmid">10493868</pub-id>
      </element-citation>
    </ref>
    <ref id="CR42">
      <label>42.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Buchan</surname>
            <given-names>DWA</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>DT</given-names>
          </name>
        </person-group>
        <article-title>The PSIPRED protein analysis workbench: 20 years on</article-title>
        <source>Nucleic Acids Res</source>
        <year>2019</year>
        <volume>47</volume>
        <issue>W1</issue>
        <fpage>W402</fpage>
        <lpage>W407</lpage>
        <?supplied-pmid 31251384?>
        <pub-id pub-id-type="pmid">31251384</pub-id>
      </element-citation>
    </ref>
    <ref id="CR43">
      <label>43.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hanson</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Paliwal</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Litfin</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Improving prediction of protein secondary structure, backbone angles, solvent accessibility and contact numbers by using predicted contact maps and an ensemble of recurrent and residual convolutional neural networks. Valencia a, editor</article-title>
        <source>Bioinformatics.</source>
        <year>2019</year>
        <volume>35</volume>
        <issue>14</issue>
        <fpage>2403</fpage>
        <lpage>2410</lpage>
        <?supplied-pmid 30535134?>
        <pub-id pub-id-type="pmid">30535134</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
