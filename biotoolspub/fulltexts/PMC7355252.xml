<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7355252</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa505</article-id>
    <article-id pub-id-type="publisher-id">btaa505</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>General Computational Biology</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CRISPRL <sc>and</sc>: Interpretable large-scale inference of DNA repair landscape based on a spectral approach</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Aghazadeh</surname>
          <given-names>Amirali</given-names>
        </name>
        <xref ref-type="aff" rid="btaa505-aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ocal</surname>
          <given-names>Orhan</given-names>
        </name>
        <xref ref-type="aff" rid="btaa505-aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ramchandran</surname>
          <given-names>Kannan</given-names>
        </name>
        <xref ref-type="corresp" rid="btaa505-cor1"/>
        <xref ref-type="aff" rid="btaa505-aff1"/>
        <!--<email>kannanr@eecs.berkeley.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btaa505-aff1"><institution>Department of Electrical Engineering and Computer Science, University of California</institution>, Berkeley, Berkeley 94720, CA, <country country="US">USA</country></aff>
    <author-notes>
      <corresp id="btaa505-cor1">Corresponding email ID:<email>kannanr@eecs.berkeley.edu</email> To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-07-13">
      <day>13</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>36</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB 2020 Proceedings</issue-title>
    <fpage>i560</fpage>
    <lpage>i568</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa505.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Summary</title>
        <p>We propose a new spectral framework for reliable training, scalable inference and interpretable explanation of the DNA repair outcome following a Cas9 cutting. Our framework, dubbed CRISPRL <sc>and</sc>, relies on an unexploited observation about the nature of the repair process: the landscape of the DNA repair is highly sparse in the (Walsh–Hadamard) spectral domain. This observation enables our framework to address key shortcomings that limit the interpretability and scaling of current deep-learning-based DNA repair models. In particular, CRISPRL <sc>and</sc> reduces the time to compute the full DNA repair landscape from a striking 5230 years to 1 week and the sampling complexity from <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to 3 million guide RNAs with only a small loss in accuracy (R<sup>2</sup><inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:msup><mml:mi mathvariant="normal">R</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> ∼ 0.9). Our proposed framework is based on a divide-and-conquer strategy that uses a fast <italic>peeling</italic> algorithm to learn the DNA repair models. CRISPRL <sc>and</sc> captures lower-degree features around the cut site, which enrich for short insertions and deletions as well as higher-degree microhomology patterns that enrich for longer deletions.</p>
      </sec>
      <sec id="s2">
        <title>Availability and implementation</title>
        <p>The CRISPRL <sc>and</sc> software is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/UCBASiCS/CRISPRLand">https://github.com/UCBASiCS/CRISPRLand</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/100000001</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>CCF-Medium-1702678</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Recent studies on site-specific double-stranded breaks (DSBs) generated by the RNA-guided DNA endonuclease Cas9 have shown that the DNA repair outcome following Cas9 cutting is non-random and consistent across experimental replicates, cell lines and reagent delivery methods and highly a function of the DNA sequence around the cut site (<xref rid="btaa505-B18" ref-type="bibr">van Overbeek <italic>et al.</italic>, 2016</xref>). Follow-up studies have emerged which employ machine-learning models, such as deep neural networks (<xref rid="btaa505-B14" ref-type="bibr">Shen <italic>et al.</italic>, 2018</xref>), decision trees (<xref rid="btaa505-B8" ref-type="bibr">Leenay <italic>et al.</italic>, 2019</xref>) and logistic regression (<xref rid="btaa505-B2" ref-type="bibr">Allen <italic>et al.</italic>, 2019</xref>) to train DNA repair models using a database of DSBs generated in CRISPR-Cas9 experiments. These models take in the DNA sequence of the genome in a small window surrounding the cut and predict key statistics of the repair outcome, such as the percentage of cells with in-frame shifts, insertions and deletions (<xref ref-type="fig" rid="btaa505-F1">Fig. 1A</xref>).
</p>
    <fig id="btaa505-F1" orientation="portrait" position="float">
      <label>Fig. 1.</label>
      <caption>
        <p>Schematic of the CRISPRL <sc>and</sc> framework. (<bold>A</bold>) A Cas9 induced DSB is illustrated on the genome with the reference sequence surrounding the cut site as well as the three indels resulting from the DNA repair with their corresponding frequencies predicted by the machine-learning models [inDelphi (<xref rid="btaa505-B14" ref-type="bibr">Shen <italic>et al.</italic>, 2018</xref>), Sprout (<xref rid="btaa505-B8" ref-type="bibr">Leenay <italic>et al.</italic>, 2019</xref>) and FORECast (<xref rid="btaa505-B2" ref-type="bibr">Allen <italic>et al.</italic>, 2019</xref>)]. The 7-bp deletion indicates a microhomology-mediated deletion. The repeating patterns surrounding the deletion have been italicized for better visualization. Five key DNA repair outcomes including fraction of cells with an insertion, fraction of cells with an in-frame shift, average length of an indel, precision and average length of the microhomology-mediate deletions have been calculated. (<bold>B</bold>) The binary representation of the reference sequence is illustrated and its corresponding decimal index in the CRISPRL <sc>and</sc> framework. The DNA repair landscape (in terms of the percentage of insertions) as well as the spectrum of the landscape is illustrated for <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:mn>10</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> ordered gRNA sequences evaluated using CRISPRL <sc>and</sc></p>
      </caption>
      <graphic xlink:href="btaa505f1"/>
    </fig>
    <p>While initial studies have used the DNA repair models to design gene knock-out experiments in therapeutically important cell types, such as T cells (<xref rid="btaa505-B8" ref-type="bibr">Leenay <italic>et al.</italic>, 2019</xref>), as well as gene knock-in experiments, to edit certain genes (<xref rid="btaa505-B14" ref-type="bibr">Shen <italic>et al.</italic>, 2018</xref>), the applicability of the DNA repair models is severely hindered in a large-scale setting due to the lack of a reliable, interpretable and scalable machinery to train and analyze the DNA repair models. Here, we discuss these shortcomings in detail:</p>
    <p><bold>Reliability</bold>. Currently, there is no clear mechanism to determine the number of site-specific CRISPR experiments required for the reliable training of DNA repair models. The number of experiments is typically defined by the total budget invested in the experiments rather than a principled scientific mechanism backed by theoretical or computational reasoning. In addition, the location of cut sites (i.e. the guide RNAs) on the genome are determined either by random selection or enforced by other studies rather than experimental design procedures tailored to the DNA repair models.</p>
    <p><bold>Interpretability</bold>. Our understanding of how the current DNA repair models operate is extremely limited; e.g. we do not have a clear mechanism (other than ad hoc interpretation methods for general purpose deep neural networks) to determine what features or combination of features enrich for key repair outcomes, such as in-frame shifts, insertions and deletions. A powerful ineterpretable model would enable a mechanistic understanding of the repair process as well as a set of design rules for gene knock-out and knock-in experiments.</p>
    <p><bold>Scalability</bold>. Finally, the DNA repair models are extremely slow in the inference time. Running these models against the cut sites in the potential coding region on the human genome takes months on a regular computer. Considering the growing interest in gene editing and knock-out experiments in various cell types in the resolutions of single cells, there is a critical need for more scalable methods at the inference time.</p>
    <p>Here, we aim to address these problems by a new computational framework, dubbed CRISPRL <sc>and</sc>, which analyzes the landscape of the DNA repair process in the spectral domain. CRISPRL <sc>and</sc> focuses on the microhomology-mediated end-joining (MMEJ) and non-homologous end-joining (NHEJ) (<xref rid="btaa505-B15" ref-type="bibr">Sonoda <italic>et al.</italic>, 2006</xref>) repair processes for which machine-learning models have been recently developed. The key insight of our framework is that the MMEJ and NHEJ repair processes can be modeled by a pseudo-Boolean function <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup><mml:mo>→</mml:mo><mml:mo>ℝ</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>m<sub>i</sub></italic> are binary variables that encode the input DNA sequence of length <inline-formula id="IE6"><mml:math id="IM6"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> surrounding the cut site, <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> refers to finite field consisting {0, 1}, and <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is a real-valued outcome of interest, e.g. percentage of insertions (<xref ref-type="fig" rid="btaa505-F1">Fig. 1B</xref>).</p>
    <p><sc>CRISPRLand’</sc>s approach in analyzing the repair model <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> stems from a key theorem (<xref rid="btaa505-B4" ref-type="bibr">Boros and Hammer, 2002</xref>) in mathematics, which states that any pseudo-Boolean function <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be represented uniquely by a multi-linear polynomial over the hyper cube <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mo>α</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:msub></mml:mrow><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE12"><mml:math id="IM12"><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula> is a subset of <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:msub><mml:mo>α</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the Walsh–Hadamard transform (WHT) coefficient associated with the monomial <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. For example, the pseudo-Boolean function
<disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>12</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mn>6</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>has three monomials with degrees 2, 1 and 3 and WHT coefficients 12, –3 and 6, respectively. Note that, the pseudo-Boolean <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>.</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in this example is considered to be sparse since out of <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mi mathvariant="normal">5</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:math></inline-formula> possible monomials only three of them are active (i.e. have non-zero coefficient).</p>
    <p>If we replace <italic>z<sub>i</sub></italic> with <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> such that <italic>z<sub>i</sub></italic>=1 when <italic>m<sub>i</sub></italic>=0 and <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> when <italic>m<sub>i</sub></italic>=1, we have <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mi mathvariant="bold">m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and the WHT <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mi>n</mml:mi></mml:msqrt><mml:msub><mml:mo>α</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> such that supp(<inline-formula id="IE23"><mml:math id="IM23"><mml:mi mathvariant="bold">k</mml:mi></mml:math></inline-formula>) = <inline-formula id="IE24"><mml:math id="IM24"><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula>, where supp(.) indicates the non-zeros coordinates (called the support function in signal processing). The non-zero WHT coefficients reveal higher order interactions between the input features that enrich (or deplete) certain repair outcomes. Our main goal is to efficiently estimate these sparse coefficients from the underlying biological model and provide the biological interpretations behind them.</p>
    <p>To this end, we first formally define the notion of the fitness landscape (also called landscape in this article) of the DNA repair process using the pseudo–Boolean function <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and then show the steps to develop CRISPRL <sc>and</sc> in order to compute the landscape based on the recently developed DNA repair models. We, then analyze the repair landscape in the WHT spectral domain. We observe that the WHT coefficients <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:msub><mml:mo>α</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of the fitness landscape are surprisingly sparse and the level of sparsity depends on the type of the repair outcome. In particular, the landscape in terms of the insertion percentage is sparser than that of the in-frame shift percentage and the rest of the repair outcomes.</p>
    <sec>
      <title>1.1 Contributions</title>
      <p>The sparsity of the DNA repair outcome in the WHT domain enables CRISPRL <sc>and</sc> to address key shortcomings regarding the training, inference, and interpretation of the current repair models. First, CRISPRL <sc>and</sc> provides a method to significantly reduce the number of site-specific gRNAs to fully recover the DNA repair landscape. The idea is to leverage the sparsity of the landscape in the WHT spectral domain. Similar analysis has revolutionized sensing systems in areas, such as medical imaging, radio astronomy and radar/sonar imaging. Second, CRISPRL <sc>and</sc> provides a concrete framework to explain the black-box machine-learning models by simply inspecting the non-zero coefficients of the WHT. In particular, it reveals patterns that are indicative of deletions that are mediated by microhomologies, i.e. repeating patterns around the cut site. These patterns are highly difficult to observe using classical interpretation tools in machine learning since they reflect higher order interactions between the features. From this perspective, CRISPRL <sc>and</sc> serves as a complimentary tool-set to explain deep-learning-based DNA repair models. Third, the new massive-scale computational algorithm developed in CRISPRL <sc>and</sc> recovers the complete DNA repair landscape exponentially faster compared to the conventional way of repeatedly querying the machine-learning model. This speedup is achieved by employing a divide-and-conquer strategy building on concepts from signal processing and coding theory. Our algorithm allows us to recover a model for the DNA repair outcome through a fast <italic>peeling</italic> algorithm based on a number of carefully designed input guide RNAs whose cardinality scales <italic>logarithmically</italic> with the size of the landscape. We show how such design scheme enables CRISPRL <sc>and</sc> to extrapolate the repair landscape in massive scales; a task that is practically impossible using computers today. CRISPRL <sc>and</sc> reduces the computational complexity to compute the full repair landscape from a striking 5230 years to 1 week and the sampling complexity from 10<sup>12</sup> to 3 million guide RNAs. Our findings are demonstrated using the state-of-the-art models trained on recent experimental datasets from DNA repair in Cas9-mediated DSBs.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Repair landscape</title>
    <p>We will consider two landscapes of scientific interest, which symbolize two DNA repair outcomes with maximum differences in the WHT spectral domain. One is the percentage of cells with an insertions and the other one is the fraction of cells with an in-frame shift. Other DNA repair outcomes, such as deletion percentage, average indel length, average deletion length and precision can be analyzed similarly. We will instead provide a summary of those landscapes in terms of WHT complexity.</p>
    <sec>
      <title>2.1 Insertion percentage</title>
      <p>In order to compute the fitness landscape of the DNA repair outcome, we first generate all the different <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mo>ℓ</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> possible binary code words <inline-formula id="IE28"><mml:math id="IM28"><mml:mi mathvariant="bold">m</mml:mi></mml:math></inline-formula> of length <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>ℓ</mml:mo></mml:mrow></mml:math></inline-formula> ordered in a way that two adjacent binary codes are different only by one bit. We then encode the binary code words into their corresponding DNA sequences. While various encoding strategies can be used to encode the DNA sequence into a binary code; in this article, we use the following encoding: A : 00, T : 01, C : 10 and G : 11. With this encoding, we can represent a DNA sequence of length <inline-formula id="IE30"><mml:math id="IM30"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> using a binary code <inline-formula id="IE31"><mml:math id="IM31"><mml:mi mathvariant="bold">m</mml:mi></mml:math></inline-formula> of length <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>ℓ</mml:mo></mml:mrow></mml:math></inline-formula>. Other encoding will result in a similar analysis.</p>
      <p>We then construct CRISPR experiments where we introduce a DSB on the genome at a point exactly in the middle of the DNA sequence constructed above. We repeat the same experiment for all the <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mo>ℓ</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> generated DNA sequences and use an already trained repair model [e.g. inDelphi (<xref rid="btaa505-B14" ref-type="bibr">Shen <italic>et al.</italic>, 2018</xref>), Sprout (<xref rid="btaa505-B8" ref-type="bibr">Leenay <italic>et al.</italic>, 2019</xref>) or FORECast (<xref rid="btaa505-B2" ref-type="bibr">Allen <italic>et al.</italic>, 2019</xref>)] to find the repair outcome for all the generated DNA sequences. The outcomes can be obtained experimentally; however, here, we use a trained repair model as a proof-of-concept. We compute and store the key summary statistics (outputs) of the DNA repair outcome including, precision, in-frame shift percentage, insertion percentage, deletion percentage and indel length in <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mo>ℓ</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>-dimensional vectors in the same order as they appear in the binary code <inline-formula id="IE35"><mml:math id="IM35"><mml:mi mathvariant="bold">m</mml:mi></mml:math></inline-formula>; we call these vectors the fitness landscape of the DNA repair outcome. The fitness landscape fully describes the DNA repair models in terms of the outputs mentioned above. Note that, the repair landscape inherits the real-world statistics of the repair data, such as the presence of the protospacer adjacent motif around the cut site, since the original machine-learning models are trained on real-world experimental data.</p>
      <p>An example of the fitness landscape in terms of the insertion percentage is illustrated in <xref ref-type="fig" rid="btaa505-F2">Figure 2</xref> for <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> in human bone Osteosarcoma epithelial cells (U2OS). The figure illustrates the mean-subtracted insertion percentage of the first <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mn>100</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mn>10</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> and 1000 coordinates of the <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mn>048</mml:mn><mml:mo> </mml:mo><mml:mn>576</mml:mn></mml:mrow></mml:math></inline-formula>-dimensional landscape. In order to maintain the minimum input sequence length requirement of the DNA repair outcome prediction models, we append the DNA sequences from left and right with two fixed short DNA sequences of length 15. In the next section, we elaborate on the computational challenges in increasing <inline-formula id="IE39"><mml:math id="IM39"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> to larger values and we develop a new scheme that enables us to increase <inline-formula id="IE40"><mml:math id="IM40"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> to arbitrarily larger values and exploring the fitness landscape fully.
</p>
      <fig id="btaa505-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>The fitness landscape of DNA repair outcome in U2OS in terms of the insertion percentage. Only the first (<bold>A</bold>) <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mn>100</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula>, (<bold>B</bold>) <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mn>10</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> and (<bold>C</bold>) 1000 coordinates of the landscape are illustrated for more clarity. Insertion percentages are mean-subtracted. The landscape clearly shows redundant structures in different resolutions</p>
        </caption>
        <graphic xlink:href="btaa505f2"/>
      </fig>
      <p>We applied the WHT on the resulting 4<sup>10</sup>-dimensional landscape signal. The result is depicted in <xref ref-type="fig" rid="btaa505-F3">Figure 3</xref> in different resolutions. In order to measure how sparse the WHT transform is, we also plot the recovery error of the inverse WHT using only the top most components of the WHT in terms of the <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:msub><mml:mo>ℓ</mml:mo><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> norm. Our key observation is that the WHT transform of the landscape is surprisingly sparse; only the top-100 coefficients out of the total of 4<sup>10</sup> coefficients (&lt;0.01%) suffices to recover the landscape with around 10% error. The sparsity in the WHT domain is a consequence of the nature of the repair process; it would not have appeared in a random landscape, which would have a fully dense (i.e. flat) WHT spectrum. Our finding in <xref ref-type="fig" rid="btaa505-F3">Figure 3</xref> also suggests a fundamental bound in terms of the number of samples required to approximate the function <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. This suggests the minimum number of CRISPR experiments required for the reliable training of the DNA repair models.
</p>
      <fig id="btaa505-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>The WHT of the repair landscape for insertion percentage in U2OS. Only the first (<bold>A</bold>) <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:mn>100</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> and (<bold>B</bold>) <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:mn>20</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> coordinates of the landscape are illustrated for more clarity. (<bold>C</bold>) The <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mo>ℓ</mml:mo><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> error in recovering the landscape using the top coefficients of the WHT transform is illustrated in U2OS</p>
        </caption>
        <graphic xlink:href="btaa505f3"/>
      </fig>
      <p>Recent studies have shown that the DNA repair outcome is a function of the cell type. In other words, if we break the genome at the very same locations but in two different cell types we get two different repair outcomes. An intriguing question is how such variations across cell type affect the coefficients in the spectral domain. We compared the WHT of the fitness landscape of repair models across three cell types: U2OS, mESC (mouse embryonic stem cell) and HCT116 (human colon cancer cells) in <xref ref-type="fig" rid="btaa505-F4">Figure 4</xref>. The index of the top WHT coefficients stays surprisingly consistent across the cell types, while the values change. Our analysis on the landscape of the other repair outcomes (not shown here), such as in-frame shift percentage, indel length and precision, also shows the consistency across the set of top WHT coefficients. Further studies are required to test and explore this hypothesis; however, our results seem to suggest a shared repair dynamic across cell types with small mechanistic differences.
</p>
      <fig id="btaa505-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>The first 5000 coefficients of WHT of the repair landscape in terms of the percentage of insertion in three cell types: U2OS, mESC and HCT116. The index of large WHT coefficients is consistent across cell types</p>
        </caption>
        <graphic xlink:href="btaa505f4"/>
      </fig>
      <p>Knowing that the landscape of the repair outcome can be recovered using only a small fraction of the WHT coefficients, a natural question is what biological features the top WHT coefficients corresponds to. The theorem in <xref ref-type="disp-formula" rid="E1">Equation (1)</xref> suggests that each WHT coefficient <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:msub><mml:mo>α</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> corresponds to a monomial defined by <inline-formula id="IE49"><mml:math id="IM49"><mml:mi mathvariant="script">S</mml:mi></mml:math></inline-formula>. <xref rid="btaa505-T1" ref-type="table">Table 1</xref> tabulates the index of the top-5 WHT coefficients, their corresponding binary representation, monomial and a short interpretation of each monomial. Each code in the second column is the binary representation of the index written in <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>ℓ</mml:mo><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula> binary digits. The monomial is obtained based on the pattern of ‘1’s in the binary code. The repair model <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> can be written in terms of the first five monomials as,
<disp-formula id="E3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>x</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="bold">m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≈</mml:mo><mml:mn>13.76</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>9</mml:mn></mml:msub><mml:mo>−</mml:mo><mml:mn>4.61</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>9</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>3.96</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>9</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>+</mml:mo><mml:mn>2.84</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mn>9</mml:mn></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>2.56</mml:mn><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mi>z</mml:mi><mml:mrow><mml:mn>12</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Note that, the cut site is in between <italic>z</italic><sub>10</sub> and <italic>z</italic><sub>11</sub> and is indicated by a straight line in <xref rid="btaa505-T1" ref-type="table">Table 1</xref>, and the sign of the WHT coefficients indicates the direction of influence.
</p>
      <table-wrap id="btaa505-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Top-5 WHT coefficients of the repair landscape for percentage of insertions in U2OS cells</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Index</th>
              <th rowspan="1" colspan="1">Code</th>
              <th rowspan="1" colspan="1">Monomial</th>
              <th rowspan="1" colspan="1">Interpretation</th>
              <th rowspan="1" colspan="1">Coefficient</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">2048</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE53">
                  <mml:math id="IM53">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>10</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>z</italic>
                <sub>9</sub>
              </td>
              <td rowspan="1" colspan="1">
                <italic>{C, G}</italic>
                <inline-formula id="IE54">
                  <mml:math id="IM54">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, T}@−1?</italic>
              </td>
              <td rowspan="1" colspan="1">13.76</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">3072</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE55">
                  <mml:math id="IM55">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE56">
                  <mml:math id="IM56">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>9</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>10</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>−1 bp?</italic>
              </td>
              <td rowspan="1" colspan="1">−4.61</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">3840</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE57">
                  <mml:math id="IM57">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE58">
                  <mml:math id="IM58">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>9</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>10</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>11</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>12</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>−1 &amp; +1 bp?</italic>
              </td>
              <td rowspan="1" colspan="1">−3.96</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">2304</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE59">
                  <mml:math id="IM59">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>10</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>01</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE60">
                  <mml:math id="IM60">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>9</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>12</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>{C, G}</italic>
                <inline-formula id="IE61">
                  <mml:math id="IM61">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, T}@−1 &amp; {T, G}</italic>
                <inline-formula id="IE62">
                  <mml:math id="IM62">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, C}@+1?</italic>
              </td>
              <td rowspan="1" colspan="1">2.84</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1792</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE63">
                  <mml:math id="IM63">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>01</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE64">
                  <mml:math id="IM64">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>10</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>11</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>12</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>+1 bp? {T, G}</italic>
                <inline-formula id="IE65">
                  <mml:math id="IM65">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, C}@−1?</italic>
              </td>
              <td rowspan="1" colspan="1">2.56</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic>Note</italic>: WHT coefficients correspond to monomials defined by their binary expansions. Each monomial can be easily interpreted as a question regarding the type of the nucleotides around the cut site.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>In order to better understand the interpretation of each monomial, the biological meaning of the first monomial <italic>z</italic><sub>9</sub> will be described in details, and the rest follows from the same intuition. The monomial <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mn>9</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mn>9</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> only activates when the <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:mi mathvariant="normal">ninth</mml:mi></mml:mrow></mml:math></inline-formula> binary digit in one. Let us recall our encoding policy mentioned earlier: A : 00, T : 01, C : 10 and G : 11. Based on this encoding, the monomial <italic>z</italic><sub>9</sub> only activates when the nucleotide next to the cut site from the 5' end (we call it location –1) is either a C or a G nucleotide since these are the nucleotides that their binary code end in the digit 1. Therefore, this monomial is only asking if the nucleotide at location –1 is C/G or A/T. We represent this question using the logical statement <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>}</mml:mo></mml:mrow><mml:mo>∧</mml:mo></mml:msup><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo><mml:mo>@</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>?</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE69"><mml:math id="IM69"><mml:mo>∧</mml:mo></mml:math></inline-formula> is an OR operator and <inline-formula id="IE70"><mml:math id="IM70"><mml:mo>@</mml:mo></mml:math></inline-formula> points to a location on the genome. This feature has also shown to be have a significant correlation with the percentage of insertions (<xref rid="btaa505-B8" ref-type="bibr">Leenay <italic>et al.</italic>, 2019</xref>; <xref rid="btaa505-B14" ref-type="bibr">Shen <italic>et al.</italic>, 2018</xref>). The rest of the monomials can be interpreted similarly.</p>
      <p>All the top-five monomials showing up in the WHT of the fitness landscape for the insertion percentage are related to the nucleotides that are adjacent to the cut site. This shows that the nucleotides around the cut are sufficient to fully describe the DNA repair landscape for the insertion percentage. As the next section shows, this locality around the cut might not carry over to other landscapes.</p>
    </sec>
    <sec>
      <title>2.2 In-frame shift percentage</title>
      <p>We conduct a similar landscape analysis for another important repair outcome: the percentage of cells with in-frame shifts. Predicting the percentage of in-frame shift is another critical problem in designing efficient gene knock-out experiments. The WHT of the repair landscape for in-frame shifts is illustrated in <xref ref-type="fig" rid="btaa505-F5">Figure 5</xref>. The non-zero coordinates (i.e. the support) in the WHT domain is more wide spread and consists of coefficients that are periodically repeated along the spectrum. The spectrum is denser than the insertion percentage. In particular, more than 10 000 WHT coefficients out of the total of 4<sup>10</sup> coefficients (&gt;1%) is required to recover the landscape with around 10% error. This suggests that the information required to estimate the in-frame shift percentage are more widespread and has higher frequency components compared to insertion percentage, which is more localized to the nucleotides around the cut site.
</p>
      <fig id="btaa505-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>(<bold>A</bold>) The WHT of the repair landscape for in-frame percentage is illustrated in U2OS. (<bold>B</bold>) The WHT of in-frame percentage is denser than that of the insertion percentage. This suggests that more number of samples is required to recover the landscape of in-frame percentage compared to insertion percentage</p>
        </caption>
        <graphic xlink:href="btaa505f5"/>
      </fig>
      <p>The top-five WHT coefficients <inline-formula id="IE73"><mml:math id="IM71"><mml:mrow><mml:msub><mml:mo>α</mml:mo><mml:mi mathvariant="script">S</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of the repair landscape are tabulated in <xref rid="btaa505-T2" ref-type="table">Table 2</xref>. Similar to the landscape of insertion percentage, it can be seen that the first two monomials correspond to nucleotides that are just next to the cut site. The last two monomials, however, show a new pattern. These two monomials ask about symmetric patterns that occur around the cut site. These features resemble the microhomology patterns, i.e. repeating sequences around the cut site. Presence of a microhomology pattern is known to enrich for a deletion outcome (<xref rid="btaa505-B15" ref-type="bibr">Sonoda <italic>et al.</italic>, 2006</xref>). We will show the effect of macrologies in large-scale experiments in the next section.
</p>
      <table-wrap id="btaa505-T2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>Top-5 WHT coefficients of the CRISPR fitness landscape for the in-frame shift percentage in U2OS cells</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Index</th>
              <th rowspan="1" colspan="1">Code</th>
              <th rowspan="1" colspan="1">Monomial</th>
              <th rowspan="1" colspan="1">Interpretation</th>
              <th rowspan="1" colspan="1">Coefficient</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">2048</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE74">
                  <mml:math id="IM72">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>10</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>z</italic>
                <sub>9</sub>
              </td>
              <td rowspan="1" colspan="1">
                <italic>{C, G}</italic>
                <inline-formula id="IE75">
                  <mml:math id="IM73">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, T}@−1?</italic>
              </td>
              <td rowspan="1" colspan="1">−3.24</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">256</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE76">
                  <mml:math id="IM74">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>01</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>z</italic>
                <sub>12</sub>
              </td>
              <td rowspan="1" colspan="1">
                <italic>{T, G}</italic>
                <inline-formula id="IE77">
                  <mml:math id="IM75">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, C}@+1?</italic>
              </td>
              <td rowspan="1" colspan="1">1.50</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">12 288</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE78">
                  <mml:math id="IM76">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE79">
                  <mml:math id="IM77">
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>7</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>8</mml:mn>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>−2 bp?</italic>
              </td>
              <td rowspan="1" colspan="1">1.48</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">4160</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE80">
                  <mml:math id="IM78">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>01</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>01</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE81">
                  <mml:math id="IM79">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∗</mml:mo>
                      </mml:msup>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>8</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>14</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>{T, G}</italic>
                <inline-formula id="IE82">
                  <mml:math id="IM80">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∧</mml:mo>
                      </mml:msup>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
                <italic>{A, C}@-2 &amp; +2 bp?</italic>
              </td>
              <td rowspan="1" colspan="1">1.42</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">12 480</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE83">
                  <mml:math id="IM81">
                    <mml:mrow>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mo>|</mml:mo>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>11</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                      <mml:mo> </mml:mo>
                      <mml:mn>00</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE84">
                  <mml:math id="IM82">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mrow/>
                        <mml:mo>∗</mml:mo>
                      </mml:msup>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>7</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mn>8</mml:mn>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>13</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mi>z</mml:mi>
                        <mml:mrow>
                          <mml:mn>14</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <italic>−2 &amp; +2 bp?</italic>
              </td>
              <td rowspan="1" colspan="1">1.36</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic>Note</italic>: WHT coefficients correspond to monomials defined by their binary expansions. Each monomial can be easily interpreted as a question regarding the type of the nucleotides around the cut site. The monomials with <inline-formula id="IE85"><mml:math id="IM83"><mml:mrow><mml:msup><mml:mrow/><mml:mo>∗</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> sign indicate a microhomology feature, which are identical patterns repeating around the cut site and enrich for a deletion outcome.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>3 Massive-scale landscape extrapolation</title>
    <p>We now discuss the computational challenges in finding the full landscape of the repair outcome when the context sequence length goes beyond <inline-formula id="IE86"><mml:math id="IM84"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> and describe an algorithm that uses ideas from coding theory and signal processing in order to scale to these large dimensions. Note that, the number of possible DNA sequences of length <inline-formula id="IE87"><mml:math id="IM85"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> grows exponentially with <inline-formula id="IE88"><mml:math id="IM86"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> as <inline-formula id="IE89"><mml:math id="IM87"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mo>ℓ</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. Testing a single DNA sequence using the inDelphi software (<xref rid="btaa505-B14" ref-type="bibr">Shen <italic>et al.</italic>, 2018</xref>) takes about 0.15 s on a 2.7 GHz Intel Core i5 with 8 G of RAM. Therefore, it takes around <inline-formula id="IE90"><mml:math id="IM88"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msup><mml:mo>×</mml:mo><mml:mn>0.15</mml:mn><mml:mo>=</mml:mo><mml:mn>157</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>286</mml:mn><mml:mo> </mml:mo><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:math></inline-formula> (close to 2 days) to obtain the full landscape of the repair outcome of each cell type <italic>in silico</italic> with <inline-formula id="IE91"><mml:math id="IM89"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>. However, running the same inference problem for a longer sequence of length <inline-formula id="IE92"><mml:math id="IM90"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula> (i.e. just twice the length of the previous experiment) takes about 5220 years. This volume of computation cannot be done on the computers today. Needless to say that, even with today; s multiplexing technologies, doing as many experiments is also completely out of picture.</p>
    <p>Before talking about our massive-scale algorithm to handle larger values of <inline-formula id="IE93"><mml:math id="IM91"><mml:mo>ℓ</mml:mo></mml:math></inline-formula>, we want motivate that it is in fact necessary to consider larger values of <inline-formula id="IE94"><mml:math id="IM92"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> to accurately estimate the landscape of DNA repair outcome. We determine what is the minimum value of <inline-formula id="IE95"><mml:math id="IM93"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> to be considered to accurately estimate the landscape. To this end, we perform a systemic analysis of DNA repair outcomes as a function of the window size around the cut site. The aim is to find out what values of <inline-formula id="IE96"><mml:math id="IM94"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> enables us to capture most of the variation in the repair outcomes.</p>
    <p>A window is considered around the cut size with varying length. The DNA sequence in the window is varied and the maximum range that the DNA repair outcome changes is monitored as a function of the window size (nucleotide on each side of the cut) and plotted in <xref ref-type="fig" rid="btaa505-F6">Figure 6</xref>. While knowing only the 3 nt around the cut site (window of length 6) reduces the range of variation for insertion percentage below 5%, we need to know at least 20 nt (a window of size 40) to reduce the range of variation for other outcomes below 5%. This raises the need to develop a computational platform that scales to such large values of the window size.
</p>
    <fig id="btaa505-F6" orientation="portrait" position="float">
      <label>Fig. 6.</label>
      <caption>
        <p>The variation of the DNA repair landscape as a function of the window size around the cut site (number of nucleotides from each side of the cut). For all the outcomes, except for the Insertion Percentage, a window of 20 nt from each side is required to minimize the variation and fully capture the landscape</p>
      </caption>
      <graphic xlink:href="btaa505f6"/>
    </fig>
    <p>While it might seem that we need <inline-formula id="IE97"><mml:math id="IM95"><mml:mrow><mml:msup><mml:mn>4</mml:mn><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> number of experiments to obtain the full landscape, the actual number of samples required is much smaller. This is achieved through exploiting the structure of the landscape, i.e. the landscape of DNA repair outcome is sparse in the WHT domain. If we approximate the WHT of the landscape using only <italic>K</italic> number of non-zeros elements (by keeping only the top-<italic>K</italic> coefficients), results from compressed sensing (<xref rid="btaa505-B3" ref-type="bibr">Baraniuk, 2007</xref>; <xref rid="btaa505-B5" ref-type="bibr">Donoho, 2006</xref>) show that only <inline-formula id="IE98"><mml:math id="IM96"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mn>4</mml:mn><mml:mo>ℓ</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (i.e. <inline-formula id="IE99"><mml:math id="IM97"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>ℓ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) number of random samples are sufficient to recover the landscape. However, achieving an algorithm whose <italic>computational complexity</italic> also scales gracefully as the dimensions of the problem grows is challenging. This is the algorithmic challenge that we tackle in CRISPRL <sc>and</sc> using a divide-and-conquer strategy. The description of the CRISPRL <sc>and</sc> algorithm is provided in Section 4.</p>
    <p>We demonstrate that CRISPRL <sc>and</sc> approximates the DNA repair landscape in terms of the insertion percentage and in-frame shifts in U2OS cells with a context window of size <inline-formula id="IE100"><mml:math id="IM98"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula> using only about 3 million carefully designed gRNAs (samples) from coding theory. CRISPRL <sc>and</sc> designs the input samples using a variant of the SPRIGHT algorithm (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>) as we will describe in Section 4. Note that, in general, the DNA sequences of all the gRNAs suggested by CRISPRL <sc>and</sc> might not exactly appear on the human genome. In those cases, either a sufficiently close gRNA can be selected or the recovery algorithm can be changed to accommodate for the deviation from the designed gRNAs. Obviously, this will not be a problem when the repair outcomes are derived using an already trained repair model.</p>
    <p>As we will discuss in the next section, CRISPRL <sc>and</sc> uses a modified version of SPRIGHT’s recovery algorithm to find the full landscape. Here, we evaluate the generalization performance of CRISPRL <sc>and</sc> using 330 000 <italic>unseen</italic> samples from the DNA repair landscape. The results of our prediction algorithm can be seen in <xref ref-type="fig" rid="btaa505-F7">Figure 7</xref>. CRISPRL <sc>and</sc> predicts the DNA repair outcome of the set of 330 000 unseen test gRNAs with a very high accuracy (<inline-formula id="IE101"><mml:math id="IM99"><mml:mrow><mml:msup><mml:mi>R</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>∼</mml:mo><mml:mn>0.9</mml:mn></mml:mrow></mml:math></inline-formula>) in both the easier insertion percentage and the harder in-frame shift percentage landscapes. Given the repair outcome of the 3 million designed gRNAs (which takes about a week to acquire from inDelphi’s software), CRISPRL <sc>and</sc> requires only few seconds to recover the repair outcome of the queried gRNAs.
</p>
    <fig id="btaa505-F7" orientation="portrait" position="float">
      <label>Fig. 7.</label>
      <caption>
        <p>The prediction results of CRISPRL <sc>and</sc> on <inline-formula id="IE102"><mml:math id="IM100"><mml:mrow><mml:mn>330</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> randomly chosen unseen test CRISPR experiments. The analysis has been done on the sparse insertion percentage landscape as well as the less sparse in-frame shift percentage landscape. Only <inline-formula id="IE103"><mml:math id="IM101"><mml:mrow><mml:mn>10</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> data points are plotted for more clarity. In both landscapes, CRISPRL <sc>and</sc> predicts the outcomes with very high accuracy</p>
      </caption>
      <graphic xlink:href="btaa505f7"/>
    </fig>
  </sec>
  <sec>
    <title>4 Materials and methods</title>
    <p>Our CRISPRL <sc>and</sc> algorithm for learning the landscape for the DNA repair outcome is based on computing a sparse WHT. WHT is analogous to Fourier Transform for functions that take Boolean variables. More precisely, let <inline-formula id="IE104"><mml:math id="IM102"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> for a non-negative integer <italic>n</italic>, and let <inline-formula id="IE105"><mml:math id="IM103"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mo>ℝ</mml:mo><mml:mi>N</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> be a vector. We can index the elements of <italic>x</italic> with an <italic>n</italic>-length binary sequence <inline-formula id="IE106"><mml:math id="IM104"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>. WHT of <italic>x</italic> is then defined as follows
<disp-formula id="E4"><label>(4)</label><mml:math id="M4"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE107"><mml:math id="IM105"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with the addition operation being over <inline-formula id="IE108"><mml:math id="IM106"><mml:mrow><mml:msub><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Using the coefficients <italic>X<sub>k</sub></italic>, one can recover the vector <italic>x</italic> as
<disp-formula id="E5"><label>(5)</label><mml:math id="M5"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p>WHT can be viewed as recovering a multinomial representation of a function. Consider a pseudo-Boolean function <inline-formula id="IE109"><mml:math id="IM107"><mml:mrow><mml:mi>f</mml:mi><mml:mo>:</mml:mo><mml:msup><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:mo>→</mml:mo><mml:mo>ℝ</mml:mo></mml:mrow></mml:math></inline-formula> that takes <italic>n</italic> variables with values in <inline-formula id="IE110"><mml:math id="IM108"><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and outputs a real number. Every such function has a unique expansion of the form
<disp-formula id="E6"><label>(6)</label><mml:math id="M6"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p>Let, <italic>x<sub>m</sub></italic> be the evaluation of this polynomial at <inline-formula id="IE111"><mml:math id="IM109"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Then the <italic>k</italic>th Walsh–Hadamard coefficient <italic>X<sub>k</sub></italic> corresponds to the coefficient of the multinomial term <inline-formula id="IE112"><mml:math id="IM110"><mml:mrow><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Hence, WHT can be seen as recovering the coefficients of multinomial expansion of a pseudo-Boolean function.</p>
    <p>The problem we are interested in is recovering the WHT coefficients (equivalently, the pseudo-Boolean function) when there is sparsity in the WHT domain. Methods proposed in compressed sensing literature can be used to recover a sparse signal in a sample efficient way (<xref rid="btaa505-B5" ref-type="bibr">Donoho, 2006</xref>). However, the algorithms proposed in the literature like OMP (<xref rid="btaa505-B17" ref-type="bibr">Tropp, 2004</xref>) or LASSO (<xref rid="btaa505-B16" ref-type="bibr">Tibshirani, 1996</xref>) requires operations that scale at least linearly with the ambient dimension <italic>N</italic>. On the other hand, our method requires sublinear computational complexity whenever the degrees of freedom <italic>K</italic> scale sub-linearly with the ambient dimension <italic>N</italic> (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>). The key properties of the CRISPRL <sc>and</sc> algorithm are presented in the following theorem.<statement id="mthst1"><label>Theorem 1</label><p>[(<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>)] <italic>Let</italic> <inline-formula id="IE113"><mml:math id="IM111"><mml:mrow><mml:mo>α</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>be a fixed number. Suppose</italic> <inline-formula id="IE114"><mml:math id="IM112"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic>and assume</italic> <inline-formula id="IE115"><mml:math id="IM113"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>N</mml:mi><mml:mo>α</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula><italic>. Let</italic> <inline-formula id="IE116"><mml:math id="IM114"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mo>ℝ</mml:mo><mml:mi>N</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic>be a vector and</italic> <inline-formula id="IE117"><mml:math id="IM115"><mml:mrow><mml:mi>X</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mo>ℝ</mml:mo><mml:mi>N</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic>be its WHT. Assume that X is K-sparse and support is selected uniformly at random among all possible</italic> <inline-formula id="IE118"><mml:math id="IM116"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><italic>subsets of</italic> <inline-formula id="IE119"><mml:math id="IM117"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic>of size K. Then, there is an algorithm with the following properties:</italic><list list-type="order"><list-item><p><italic>Sample complexity: algorithm uses</italic> <inline-formula id="IE120"><mml:math id="IM118"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mtext>log</mml:mtext><mml:mo>⁡</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>samples of x.</italic></p></list-item><list-item><p><italic>Computational complexity: total number of operations to successfully decode all non-zero WHT coefficients or declare a decoding failure is</italic> <inline-formula id="IE121"><mml:math id="IM119"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mtext>log</mml:mtext><mml:mo>⁡</mml:mo></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>Success probability: probability of recovering X completely approaches 1 as N grows, where the probability is taken over randomness of selecting the support of X.</p></list-item></list></p></statement></p>
    <p>This speedup is achieved by employing a divide-and-conquer strategy, where we break the problem of recovering a <italic>K</italic>-sparse signal into <italic>K</italic>-many smaller problems of recovering 1-sparse signal, and solve each 1-sparse problem efficiently, and combine the solutions to each of them to recover the original signal. The recovery algorithm is closely tied to decoding a sparse-graph-code through <italic>peeling</italic>, and we use techniques from the literature on low-density parity check (LDPC) codes (<xref rid="btaa505-B11" ref-type="bibr">Richardson and Urbanke, 2008</xref>) and product codes (<xref rid="btaa505-B6" ref-type="bibr">Elias, 1954</xref>) for deriving our method.</p>
    <p>Note that, under the assumptions of the theorem, theoretically, order of <inline-formula id="IE122"><mml:math id="IM120"><mml:mrow><mml:mi>K</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> samples is required for learning the correct model by information theoretic arguments (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>). The algorithm described here, which requires <inline-formula id="IE123"><mml:math id="IM121"><mml:mrow><mml:mi>K</mml:mi><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mtext>log</mml:mtext><mml:mo>⁡</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> samples is off from order optimality by only a logarithmic factor. As a matter of fact, the algorithm can be tweaked to be order optimal (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>). However, that version of the algorithm is not described in this article as it requires a complex additional step.</p>
    <p>The first step of the algorithm is to generate linear mixing of transform domain coefficients based on the following property.<statement id="mthst2"><label>Property 1</label><p> <italic>Let x be an</italic> <inline-formula id="IE124"><mml:math id="IM122"><mml:mrow><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic>length vector. Given a shift vector</italic> <inline-formula id="IE125"><mml:math id="IM123"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula><italic>and a full-rank subsampling matrix</italic> <inline-formula id="IE126"><mml:math id="IM124"><mml:mrow><mml:mi mathvariant="bold">H</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mrow><mml:mi>b</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>, let y be the vector of length</italic> <inline-formula id="IE127"><mml:math id="IM125"><mml:mrow><mml:mi>B</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mn>2</mml:mn><mml:mi>b</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, <italic>where</italic> <inline-formula id="IE128"><mml:math id="IM126"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>m</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi mathvariant="bold">H</mml:mi><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>for all</italic> <inline-formula id="IE129"><mml:math id="IM127"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>b</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula><italic>. Then, the WHT coefficients of y satisfy</italic><disp-formula id="E7"><label>(7)</label><mml:math id="M7"><mml:mrow><mml:msub><mml:mi>Y</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mi>B</mml:mi><mml:mi>N</mml:mi></mml:mfrac></mml:mrow></mml:msqrt><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:msubsup><mml:mo>:</mml:mo><mml:mi>j</mml:mi><mml:msup><mml:mi mathvariant="bold">H</mml:mi><mml:mi mathvariant="normal">⊤</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><italic>where X<sub>j</sub> is the jth WHT coefficient of x.</italic></p></statement></p>
    <p>The above property states that the WHT coefficients <italic>X<sub>k</sub></italic> are modulated by <inline-formula id="IE130"><mml:math id="IM128"><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> when a shift of <italic>p</italic> is applied to the indices of <italic>x</italic>, and that subsampling of the input signal creates a linear mixing of WHT coefficients.</p>
    <p>Using Property 1, we create linear mixing of coefficients by choosing <italic>C</italic> many subsampling matrices <inline-formula id="IE131"><mml:math id="IM129"><mml:mrow><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where each matrix is <italic>b </italic>×<italic> n</italic> dimensional. Furthermore, we choose for each subsampling <inline-formula id="IE132"><mml:math id="IM130"><mml:mrow><mml:msub><mml:mi mathvariant="bold">P</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi mathvariant="bold">P</mml:mi><mml:mi>C</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> shift matrices, where each of them is <inline-formula id="IE133"><mml:math id="IM131"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mtext>log</mml:mtext><mml:mo>⁡</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> dimensional. The choice of <italic>C</italic>, the matrices <inline-formula id="IE134"><mml:math id="IM132"><mml:mrow><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and the delays <inline-formula id="IE135"><mml:math id="IM133"><mml:mrow><mml:msub><mml:mi mathvariant="bold">P</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE136"><mml:math id="IM134"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>C</mml:mi></mml:mrow></mml:math></inline-formula> are going to be described in the following sections. Then WHT coefficients are calculated for the shifted-and-sub-sampled sequences. We give an example below for the linear mixing resulting from subsampling.<statement id="mthst3"><label>Example 1</label><p><italic>Let x be a vector of length 16, and let us define</italic> <inline-formula id="IE137"><mml:math id="IM135"><mml:mrow><mml:msubsup><mml:mi>y</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic> <inline-formula id="IE138"><mml:math id="IM136"><mml:mrow><mml:msubsup><mml:mi>y</mml:mi><mml:mi>m</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <italic>where</italic><disp-formula id="E8"><mml:math id="M8"><mml:mrow><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mi mathvariant="bold">H</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p><p><italic>From property 1, we see that all the WHT coefficients of x whose binary index have the same last two digits is hashed to the same bin (underlined in the following equations) for</italic> <inline-formula id="IE139"><mml:math id="IM137"><mml:mrow><mml:msup><mml:mi>y</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula><italic>, i.e. we have</italic><disp-formula id="E9"><mml:math id="M9"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>00</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>01</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>11</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>00</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>01</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>11</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>00</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>01</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>11</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>00</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>01</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>11</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math></disp-formula></p><p><italic>Similarly, for</italic> <inline-formula id="IE140"><mml:math id="IM138"><mml:mrow><mml:msup><mml:mi>y</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula><italic>we get</italic><disp-formula id="E10"><mml:math id="M10"><mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>0</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p></statement></p>
    <p>Under the assumptions of Theorem 1 on sparsity and the support of the non-zero WHT coefficients of the signal, the linear mixing of coefficients take a form where they can be solved for through <italic>peeling</italic>. The following provides an example of such linear mixing.<statement id="mthst4"><label>Example 2</label><p><italic>Let</italic> <inline-formula id="IE141"><mml:math id="IM139"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mo>ℝ</mml:mo><mml:mrow><mml:mn>16</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula><italic>have WHT coefficients equal to</italic><disp-formula id="E11"><mml:math id="M11"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>0001</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">k</mml:mi><mml:mo>=</mml:mo><mml:mn>0001</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>0100</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">k</mml:mi><mml:mo>=</mml:mo><mml:mn>0100</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>0101</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">k</mml:mi><mml:mo>=</mml:mo><mml:mn>0101</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>1010</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">k</mml:mi><mml:mo>=</mml:mo><mml:mn>1010</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p><italic>Under the subsampling used in example 1 the WHT coefficients of the sub-sampled vectors satisfy</italic><disp-formula id="E12"><mml:math id="M12"><mml:mtable><mml:mtr><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>01</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>00</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>01</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>01</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>0</mml:mn><mml:mi mathvariant="normal">1</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>10</mml:mn><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:munder accentunder="true"><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:munder><mml:mn>1</mml:mn><mml:mi mathvariant="normal">0</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>11</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p></statement></p>
    <p>We give the details of peeling algorithm in reference to this example in the following section.</p>
    <sec>
      <title>4.1 Recovery through peeling with an oracle</title>
      <p>The relationship between the measurements and the unknown coefficients can be shown as a bipartite graph. The graph related to the linear mixing in Example 2 and the recovery of the non-zero coefficients is illustrated in <xref ref-type="fig" rid="btaa505-F8">Figure 8</xref>. The unknown coefficients are shown on the left and referred to as <italic>variable nodes</italic>, and the measurements are shown on the right and referred to as <italic>check nodes</italic>. An edge is drawn between a variable node and a check node if the unknown coefficient related to that variable node contributes to the measurement related to that check node. Each check node can be categorized into the following three types:
</p>
      <fig id="btaa505-F8" orientation="portrait" position="float">
        <label>Fig. 8.</label>
        <caption>
          <p>(Left) The connections between the variable nodes (WHT coefficients) and the check nodes (measurements) in Example 1. (Right) Recovering the unknown coefficients in Example 2. The graph induced by the non-zero coefficients is shown in panel (<bold>A</bold>). In the first round of peeling, we recover coefficients at indices 0100, 001 and 1010, and get the graph in panel (<bold>B</bold>). In two rounds of peeling, all the non-zero elements of the signal are recovered as shown in panel (<bold>C</bold>)</p>
        </caption>
        <graphic xlink:href="btaa505f8"/>
      </fig>
      <list list-type="order">
        <list-item>
          <p>Zero-ton: a check node is a zero-ton if it has no non-zero coefficients (shaded in white in <xref ref-type="fig" rid="btaa505-F8">Fig. 8</xref>).</p>
        </list-item>
        <list-item>
          <p>Single-ton: a check node is a single-ton if it involves only one non-zero coefficient (shaded in blue in <xref ref-type="fig" rid="btaa505-F8">Fig. 8</xref>). Specifically, we refer to the index <italic>k</italic> and its associated value <italic>X<sub>k</sub></italic> as the index-value pair <inline-formula id="IE142"><mml:math id="IM140"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
        <list-item>
          <p>Multi-ton: a check node is a multi-ton if it contains more than one non-zero coefficient (shaded in orange in <xref ref-type="fig" rid="btaa505-F8">Fig. 8</xref>).</p>
        </list-item>
      </list>
      <p>To illustrate the peeling algorithm for recovery, we assume that there exists an ‘oracle’ that informs the decoder exactly which check nodes are single-tons, and provides the index-value pair for that single-ton. In Example 2, in the first round of peeling (shown in <xref ref-type="fig" rid="btaa505-F8">Fig. 8A</xref>), the oracle informs the decoder that the check nodes corresponding to <inline-formula id="IE143"><mml:math id="IM141"><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>00</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE144"><mml:math id="IM142"><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> are single-tons with index-value pairs <inline-formula id="IE145"><mml:math id="IM143"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0100</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>0100</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1010</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>1010</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0001</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>0001</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE146"><mml:math id="IM144"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1010</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mrow><mml:mn>1010</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. Then the decoder can subtract their contributions from other check nodes, forming new single-tons. Therefore, with the oracle information, the peeling decoder repeats the following steps:
</p>
      <list list-type="order">
        <list-item>
          <p>select all the edges in the bipartite graph with right degree 1 (identify single-ton bins);</p>
        </list-item>
        <list-item>
          <p>remove (peel off) these edges as well as the corresponding pair of variable and check nodes connected to these edges;</p>
        </list-item>
        <list-item>
          <p>remove (peel off) all other edges connected to the variable nodes that have been removed in Step 2;</p>
        </list-item>
        <list-item>
          <p>subtract the contributions of the variable nodes from the check nodes whose edges have been removed in Step 3.</p>
        </list-item>
      </list>
      <p>Decoding is successful if all the edges are removed from the graph.</p>
      <p>In this work, we choose the subsampling matrices uniformly at random over <inline-formula id="IE147"><mml:math id="IM145"><mml:mrow><mml:msup><mml:mi>F</mml:mi><mml:mrow><mml:mi>b</mml:mi><mml:mo>×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Other constructions alongside with their theoretical guarantees can be found at <xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic> (2015)</xref> and <xref rid="btaa505-B13" ref-type="bibr">Scheibler <italic>et al.</italic> (2015)</xref>. We chose the random design as it is observed to have superior practical performance in some regimes of interest (<xref rid="btaa505-B10" ref-type="bibr">Ocal <italic>et al.</italic>, 2019</xref>; <xref rid="btaa505-B13" ref-type="bibr">Scheibler <italic>et al.</italic>, 2015</xref>).</p>
      <p>Since the proof of the algorithm follows the same steps as in <xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic> (2015)</xref>, we just provide a sketch here and refer the interested readers to that article. Since the sparsity is uniformly distributed, each non-zero entry of <italic>X</italic> is connected to a check node chosen uniformly at random in each subsampling group. This results in a left-regular LDPC code construction, and the proof for recovering the support <italic>X</italic> follows the same steps in <xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic> (2015)</xref>.</p>
      <p>In peeling, we recover a variable node (non-zero coefficient of <italic>X</italic>) if it is connected to a check node with degree 1, and remove the outgoing edges from that variable node. The <italic>density evolution</italic> is a powerful tool in modern coding theory that tracks the average density of remaining edges in the graph after <inline-formula id="IE148"><mml:math id="IM146"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> rounds of peeling (<xref rid="btaa505-B11" ref-type="bibr">Richardson and Urbanke, 2008</xref>). The density evolution equations for our setting is given by the recursive equation
<disp-formula id="E13"><label>(8)</label><mml:math id="M13"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mo>ℓ−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mo>/</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE149"><mml:math id="IM147"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and <italic>M</italic> is the total number of parity check nodes. This assumes that the depth <inline-formula id="IE150"><mml:math id="IM148"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> neighborhood of the chosen edge is a tree. We can show similarly to <xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic> (2015)</xref> that the depth <inline-formula id="IE151"><mml:math id="IM149"><mml:mo>ℓ</mml:mo></mml:math></inline-formula> neighborhood of a randomly chosen edge is a tree with high probability for any fixed <inline-formula id="IE152"><mml:math id="IM150"><mml:mo>ℓ</mml:mo></mml:math></inline-formula>. On average, an arbitrarily large fraction of edges are removed if <inline-formula id="IE153"><mml:math id="IM151"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> goes to zero as <inline-formula id="IE154"><mml:math id="IM152"><mml:mrow><mml:mo>ℓ</mml:mo><mml:mo>→</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE155"><mml:math id="IM153"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mo>ℓ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> to go to zero, <italic>M</italic>/<italic>K</italic> needs to be greater than a threshold for a fixed <italic>d</italic>. These thresholds are shown in <xref rid="btaa505-T3" ref-type="table">Table 3</xref>. Then, one can use the standard Doob’s martingale argument to show that the fraction of non-recovered components concentrates around its mean (<xref rid="btaa505-B12" ref-type="bibr">Richardson and Urbanke, 2001</xref>). This guarantees recovery of arbitrarily large fraction of significant components. Then, an expander-graph argument is used to show that peeling continues until all of the coefficients are recovered (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>).
</p>
      <table-wrap id="btaa505-T3" orientation="portrait" position="float">
        <label>Table 3.</label>
        <caption>
          <p>Thresholds for recovery (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Groups</th>
              <th align="center" rowspan="1" colspan="1">3</th>
              <th align="center" rowspan="1" colspan="1">4</th>
              <th align="center" rowspan="1" colspan="1">5</th>
              <th align="center" rowspan="1" colspan="1">6</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"><italic>M</italic> / <italic>K</italic></td>
              <td rowspan="1" colspan="1">1.2218</td>
              <td rowspan="1" colspan="1">1.2949</td>
              <td rowspan="1" colspan="1">1.4250</td>
              <td rowspan="1" colspan="1">1.5697</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic>Note</italic>: <italic>M</italic>, number of check nodes; <italic>K</italic>, number of variable nodes (sparsity).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>4.2 Replacing the oracle</title>
      <p>We now show how to replace the <italic>oracle</italic> in the peeling algorithm with a realizable mechanism. This is done by employing <inline-formula id="IE156"><mml:math id="IM154"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mtext>log</mml:mtext><mml:mo>⁡</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> shifts for each subsampling matrix where <inline-formula id="IE157"><mml:math id="IM155"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> shifts are to recover each digit of the location <italic>k</italic>, and we take <inline-formula id="IE158"><mml:math id="IM156"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>⁡</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> samples for each location for noise averaging. Let <inline-formula id="IE159"><mml:math id="IM157"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi mathvariant="bold">H</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the <italic>k</italic>th WHT coefficient of the signal obtained by shifting indices of <italic>x</italic> by <italic>p</italic> and then subsampling by <inline-formula id="IE160"><mml:math id="IM158"><mml:mi mathvariant="bold">H</mml:mi></mml:math></inline-formula>. From Property 1, we have
<disp-formula id="E14"><label>(9)</label><mml:math id="M14"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi mathvariant="bold">H</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mi>B</mml:mi><mml:mi>N</mml:mi></mml:mfrac></mml:mrow></mml:msqrt><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>:</mml:mo><mml:mi>j</mml:mi><mml:msup><mml:mi mathvariant="bold">H</mml:mi><mml:mi mathvariant="normal">⊤</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Furthermore, let us define the ratio of a WHT coefficient obtained by using the same subsampling matrix but using two different shifts
<disp-formula id="E15"><label>(10)</label><mml:math id="M15"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Assume that for a WHT index <italic>k</italic> in <xref ref-type="disp-formula" rid="E14">Equation (9)</xref>, there is only one index <italic>j</italic> such that <inline-formula id="IE161"><mml:math id="IM159"><mml:mrow><mml:msup><mml:mi>A</mml:mi><mml:mi mathvariant="normal">⊤</mml:mi></mml:msup><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE162"><mml:math id="IM160"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> (i.e. the check node corresponding to it is a single-ton). Then, it follows that <inline-formula id="IE163"><mml:math id="IM161"><mml:mrow><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mi>B</mml:mi><mml:mi>N</mml:mi></mml:mfrac></mml:mrow></mml:msqrt><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Using <inline-formula id="IE164"><mml:math id="IM162"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>F</mml:mi><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> (the vector with all indices =0 except for the <italic>i</italic>th index, which is =1) in <xref ref-type="disp-formula" rid="E15">Equation (10)</xref> yields
<disp-formula id="E16"><label>(11)</label><mml:math id="M16"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mi>X</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Note that, this value is in <inline-formula id="IE165"><mml:math id="IM163"><mml:mrow><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> for all <italic>p</italic> if there is no noise. As the value of <inline-formula id="IE166"><mml:math id="IM164"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is equal to the <italic>i</italic>th index of the location <inline-formula id="IE167"><mml:math id="IM165"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msubsup><mml:mi mathvariant="double-struck">F</mml:mi><mml:mn>2</mml:mn><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, by using shifts <inline-formula id="IE168"><mml:math id="IM166"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> going through all indices of <italic>j</italic>, we can recover it. When there is noise, it can be shown that by taking <inline-formula id="IE169"><mml:math id="IM167"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>⁡</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> random shifts, the probability of detecting the location wrongly can be made polynomially small (<xref rid="btaa505-B9" ref-type="bibr">Li <italic>et al.</italic>, 2015</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusion and discussion</title>
    <p>While much of the body of research in training, testing and interpreting image and text models generalize to machine-learning problems in computational biology, there are yet distinct aspects in modern biological datasets that require new perspectives and methodologies. In several of the molecular biology and genomics datasets, as an example, the data points comprise long sequences of discrete elements, such as oligonucleotides (<xref rid="btaa505-B1" ref-type="bibr">Alipanahi <italic>et al.</italic>, 2015</xref>), amino acids (<xref rid="btaa505-B7" ref-type="bibr">Huang <italic>et al.</italic>, 2016</xref>) or mutations (<xref rid="btaa505-B19" ref-type="bibr">Yang <italic>et al.</italic>, 2019</xref>) that can be represented using binary codes. These data modalities typically lack the common structures (e.g. invariance, etc.) present in image or text data while exhibiting other intriguing features.</p>
    <p>In this article, we took an important problem in molecular biology, i.e. the problem of predicting the DNA repair outcome, as a model problem and demonstrated how the discreteness of the input data as well as the structure of the biological process can be exploited in our CRISPRL <sc>and</sc> framework to do efficient training, inference and model interpretation using the ideas from coding theory and signal processing. The key observation that enables our analysis is the sparsity of the DNA repair models in the WHT spectral domain, which stems from the fact that the output of the model is a function of at most sparse number of monomials that capture distinct patterns around the cut site. Note that, both our results as well as the results in the DNA repair models employed in our work (e.g. InDelphi) explain more than 75% of the variance in the experimental data. The remaining unexplained variance due to other covariates, such as chromatin factor [see <xref rid="btaa505-B8" ref-type="bibr">Leenay <italic>et al.</italic> (2019)</xref>], only slightly changes the repair landscape.</p>
    <p>We demonstrate that CRISPRL <sc>and</sc> reduces the time required to find the DNA repair landscape from thousands of years to couples of days using a logarithmically less number of site-specific Cas9 cuttings on the human genome and thus meets the burgeoning demand for large-scale CRISPR gene editing studies. Nevertheless, depending on the scale of the inference task, the window size around the cut site can be set to adjust the number of gRNAs to achieve a desired accuracy even in smaller-scale CRISPR experiments.</p>
    <p>We speculate that several of the current machine-learning models trained for problems in computational biology would be sparse in WHT domain as well. The sparsity can be similarly exploited in these applications in various aspects including experimental design, interpretation and fast inference.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Science Foundation [CCF-Medium-1702678].</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa505-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Alipanahi</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Predicting the sequence specificities of DNA- and RNA-binding proteins by deep learning</article-title>. <source>Nat. Biotechnol</source>., <volume>33</volume>, <fpage>831</fpage>–<lpage>838</lpage>.<pub-id pub-id-type="pmid">26213851</pub-id></mixed-citation>
    </ref>
    <ref id="btaa505-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Allen</surname><given-names>F.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Predicting the mutations generated by repair of Cas9-induced double-strand breaks</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>64</fpage>–<lpage>72</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Baraniuk</surname><given-names>R.G.</given-names></name></person-group> (<year>2007</year>) 
<article-title>Compressive sensing</article-title>. <source>IEEE Signal Process. Mag</source>., <volume>24</volume>, <fpage>118</fpage>–<lpage>121</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Boros</surname><given-names>E.</given-names></name>, <name name-style="western"><surname>Hammer</surname><given-names>P.L.</given-names></name></person-group> (<year>2002</year>) 
<article-title>Pseudo-Boolean optimization</article-title>. <source>Discrete Appl. Math</source>., <volume>123</volume>, <fpage>155</fpage>–<lpage>225</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Donoho</surname><given-names>D.L.</given-names></name></person-group> (<year>2006</year>) 
<article-title>Compressed sensing</article-title>. <source>IEEE Trans. Inf. Theory</source>, <volume>52</volume>, <fpage>1289</fpage>–<lpage>1306</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Elias</surname><given-names>P.</given-names></name></person-group> (<year>1954</year>) 
<article-title>Error-free coding</article-title>. <source>Trans. IRE Prof. Group Inf. Theory</source>, <volume>4</volume>, <fpage>29</fpage>–<lpage>37</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Huang</surname><given-names>P.S.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>The coming of age of de novo protein design</article-title>. <source>Nature</source>, <volume>537</volume>, <fpage>320</fpage>–<lpage>327</lpage>.<pub-id pub-id-type="pmid">27629638</pub-id></mixed-citation>
    </ref>
    <ref id="btaa505-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Leenay</surname><given-names>R.T.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Large dataset enables prediction of repair after CRISPR–Cas9 editing in primary T cells</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>1034</fpage>–<lpage>1037</lpage>.<pub-id pub-id-type="pmid">31359007</pub-id></mixed-citation>
    </ref>
    <ref id="btaa505-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>X.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Spright: a fast and robust framework for sparse Walsh-Hadamard transform</article-title>. <source>arXiv preprint arXiv: 1508.06336</source>.</mixed-citation>
    </ref>
    <ref id="btaa505-B10">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Ocal</surname><given-names>O.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) Low-degree pseudo-Boolean function recovery using codes. In: <italic>2019 IEEE International Symposium on Information Theory (ISIT).</italic> pp. <fpage>1207</fpage>–<lpage>1211</lpage>. IEEE.</mixed-citation>
    </ref>
    <ref id="btaa505-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Richardson</surname><given-names>T.</given-names></name>, <name name-style="western"><surname>Urbanke</surname><given-names>R.</given-names></name></person-group> (<year>2008</year>) <source>Modern Coding Theory</source>. 
<publisher-name>Cambridge University Press</publisher-name>, 
<publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btaa505-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Richardson</surname><given-names>T.J.</given-names></name>, <name name-style="western"><surname>Urbanke</surname><given-names>R.L.</given-names></name></person-group> (<year>2001</year>) 
<article-title>The capacity of low-density parity-check codes under message-passing decoding</article-title>. <source>IEEE Trans. Inf. Theory</source>, <volume>47</volume>, <fpage>599</fpage>–<lpage>618</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Scheibler</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>A fast Hadamard transform for signals with sublinear sparsity in the transform domain</article-title>. <source>IEEE Trans. Inf. Theory</source>, <volume>61</volume>, <fpage>2115</fpage>–<lpage>2132</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Shen</surname><given-names>M.W.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Predictable and precise template-free CRISPR editing of pathogenic variants</article-title>. <source>Nature</source>, <volume>563</volume>, <fpage>646</fpage>–<lpage>651</lpage>.<pub-id pub-id-type="pmid">30405244</pub-id></mixed-citation>
    </ref>
    <ref id="btaa505-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sonoda</surname><given-names>E.</given-names></name></person-group><etal>et al</etal> (<year>2006</year>) 
<article-title>Differential usage of non-homologous end-joining and homologous recombination in double strand break repair</article-title>. <source>DNA Repair</source>, <volume>5</volume>, <fpage>1021</fpage>–<lpage>1029</lpage>.<pub-id pub-id-type="pmid">16807135</pub-id></mixed-citation>
    </ref>
    <ref id="btaa505-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tibshirani</surname><given-names>R.</given-names></name></person-group> (<year>1996</year>) 
<article-title>Regression shrinkage and selection via the lasso</article-title>. <source>J. R. Stat. Soc. Series B Methodol</source>., <volume>58</volume>, <fpage>267</fpage>–<lpage>288</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tropp</surname><given-names>J.A.</given-names></name></person-group> (<year>2004</year>) 
<article-title>Greed is good: algorithmic results for sparse approximation</article-title>. <source>IEEE Trans. Inf. Theory</source>, <volume>50</volume>, <fpage>2231</fpage>–<lpage>2242</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa505-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>van Overbeek</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>DNA repair profiling reveals nonrandom outcomes at Cas9-mediated breaks</article-title>. <source>Mol. Cell</source>, <volume>63</volume>, <fpage>633</fpage>–<lpage>646</lpage>.<pub-id pub-id-type="pmid">27499295</pub-id></mixed-citation>
    </ref>
    <ref id="btaa505-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yang</surname><given-names>K.K.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Machine-learning-guided directed evolution for protein engineering</article-title>. <source>Nat. Methods</source>, <volume>16</volume>, <fpage>687</fpage>–<lpage>694</lpage>.<pub-id pub-id-type="pmid">31308553</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
