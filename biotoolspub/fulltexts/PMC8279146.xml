<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PeerJ Comput Sci</journal-id>
    <journal-id journal-id-type="iso-abbrev">PeerJ Comput Sci</journal-id>
    <journal-id journal-id-type="pmc">peerj-cs</journal-id>
    <journal-id journal-id-type="publisher-id">peerj-cs</journal-id>
    <journal-title-group>
      <journal-title>PeerJ Computer Science</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2376-5992</issn>
    <publisher>
      <publisher-name>PeerJ Inc.</publisher-name>
      <publisher-loc>San Diego, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8279146</article-id>
    <article-id pub-id-type="publisher-id">cs-588</article-id>
    <article-id pub-id-type="doi">10.7717/peerj-cs.588</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Distributed and Parallel Computing</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Emerging Technologies</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Mobile and Ubiquitous Computing</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Real-Time and Embedded Systems</subject>
      </subj-group>
      <subj-group subj-group-type="heading">
        <subject>Software Engineering</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>FogFrame: a framework for IoT application execution in the fog</article-title>
    </title-group>
    <contrib-group>
      <contrib id="author-1" contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0003-2754-7770</contrib-id>
        <name>
          <surname>Skarlat</surname>
          <given-names>Olena</given-names>
        </name>
        <email>o.skarlat@infosys.tuwien.ac.at</email>
      </contrib>
      <contrib id="author-2" contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-6828-9945</contrib-id>
        <name>
          <surname>Schulte</surname>
          <given-names>Stefan</given-names>
        </name>
      </contrib>
      <aff><institution>Distributed Systems Group, Technische Universität Wien</institution>, <addr-line>Vienna</addr-line>, <country>Austria</country></aff>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Endler</surname>
          <given-names>Markus</given-names>
        </name>
      </contrib>
    </contrib-group>
    <pub-date pub-type="epub" date-type="pub" iso-8601-date="2021-07-05">
      <day>5</day>
      <month>7</month>
      <year iso-8601-date="2021">2021</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <volume>7</volume>
    <elocation-id>e588</elocation-id>
    <history>
      <date date-type="received" iso-8601-date="2021-02-19">
        <day>19</day>
        <month>2</month>
        <year iso-8601-date="2021">2021</year>
      </date>
      <date date-type="accepted" iso-8601-date="2021-05-20">
        <day>20</day>
        <month>5</month>
        <year iso-8601-date="2021">2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 Skarlat and Schulte</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>Skarlat and Schulte</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, reproduction and adaptation in any medium and for any purpose provided that it is properly attributed. For attribution, the original author(s), title, publication source (PeerJ Computer Science) and either DOI or URL of the article must be cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="https://peerj.com/articles/cs-588"/>
    <abstract>
      <p>Recently, a multitude of conceptual architectures and theoretical foundations for fog computing have been proposed. Despite this, there is still a lack of concrete frameworks to setup real-world fog landscapes. In this work, we design and implement the fog computing framework <italic>FogFrame</italic>—a system able to manage and monitor edge and cloud resources in fog landscapes and to execute Internet of Things (IoT) applications. FogFrame provides communication and interaction as well as application management within a fog landscape, namely, decentralized service placement, deployment and execution. For service placement, we formalize a system model, define an objective function and constraints, and solve the problem implementing a greedy algorithm and a genetic algorithm. The framework is evaluated with regard to Quality of Service parameters of IoT applications and the utilization of fog resources using a real-world operational testbed. The evaluation shows that the service placement is adapted according to the demand and the available resources in the fog landscape. The greedy placement leads to the maximum utilization of edge devices keeping at the edge as many services as possible, while the placement based on the genetic algorithm keeps devices from overloads by balancing between the cloud and edge. When comparing edge and cloud deployment, the service deployment time at the edge takes 14% of the deployment time in the cloud. If fog resources are utilized at maximum capacity, and a new application request arrives with the need of certain sensor equipment, service deployment becomes impossible, and the application needs to be delegated to other fog resources. The genetic algorithm allows to better accommodate new applications and keep the utilization of edge devices at about 50% CPU. During the experiments, the framework successfully reacts to runtime events: (i) services are recovered when devices disappear from the fog landscape; (ii) cloud resources and highly utilized devices are released by migrating services to new devices; (iii) and in case of overloads, services are migrated in order to release resources.</p>
    </abstract>
    <kwd-group kwd-group-type="author">
      <kwd>Fog computing</kwd>
      <kwd>Internet of Things</kwd>
      <kwd>Service placement</kwd>
      <kwd>Resource provisioning</kwd>
    </kwd-group>
    <funding-group>
      <award-group id="fund-1">
        <funding-source>Austrian Research Promotion Agency (FFG)</funding-source>
      </award-group>
      <award-group id="fund-2">
        <funding-source>Austrian Competence Center for Digital Production (CDP)</funding-source>
        <award-id>854187</award-id>
      </award-group>
      <award-group id="fund-3">
        <funding-source>Technische Universität Wien</funding-source>
      </award-group>
      <funding-statement>This work was supported by the Austrian Research Promotion Agency (FFG) via the “Austrian Competence Center for Digital Production” (CDP) under the contract number 854187 and by Technische Universität Wien. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro">
    <title>Introduction</title>
    <p>The Internet of Things (IoT) leads to the pervasion of business and private spaces with ubiquitous computing devices, which are able to act autonomously and provide network connectivity (<xref rid="ref-11" ref-type="bibr">Botta et al., 2016</xref>). Together with cloud technologies, the IoT enables small- and large-scale applications for smart cities (<xref rid="ref-21" ref-type="bibr">Gharaibeh et al., 2017</xref>), healthcare (<xref rid="ref-13" ref-type="bibr">Catarinucci et al., 2015</xref>), manufacturing (<xref rid="ref-16" ref-type="bibr">Compare, Baraldi &amp; Zio, 2020</xref>), etc.</p>
    <p>IoT data in such applications is mostly produced in a distributed way, sent to a centralized cloud for processing, and then delivered to distributed stakeholders or other distributed IoT devices, often located close to the initial data sources. This centralized processing approach results in high communication latency and low data transfer rates between IoT devices as well as the IoT devices and potential users (<xref rid="ref-10" ref-type="bibr">Bonomi et al., 2014</xref>; <xref rid="ref-35" ref-type="bibr">Mahmud, Ramamohanarao &amp; Buyya, 2019</xref>). Therefore, using centralized resources from the cloud does not match the decentralized nature of the IoT with its bandwidth- and delay-sensitivity. In addition to the centralized processing, the computational resources of IoT devices, which can be used not only for collecting data but also for data processing, are often neglected. Typical examples of such IoT devices which possess computational resources and are capable to host IoT applications are gateways, routers, or sensor nodes (<xref rid="ref-17" ref-type="bibr">Dastjerdi et al., 2016</xref>; <xref rid="ref-57" ref-type="bibr">Vaquero &amp; Rodero-Merino, 2014</xref>; <xref rid="ref-20" ref-type="bibr">Froiz-Mí­sguez et al., 2018</xref>). The combination of edge- and cloud-based computational resources in order to deploy and execute IoT applications is also known as <italic>fog computing</italic>. Together, these resources form a fog computing environment, or a so-called <italic>fog landscape</italic> (<xref rid="ref-52" ref-type="bibr">Skarlat et al., 2016</xref>). Recently, the notions of fog computing were put into the OpenFog Reference Architecture, which became an international standard (<xref rid="ref-29" ref-type="bibr">IEEE 1934, 2018</xref>).</p>
    <p>Fog computing has been named as an enabler to provide IoT applications in many different scenarios, especially with regard to smart systems, for example, smart cities, smart buildings, or smart factories (<xref rid="ref-54" ref-type="bibr">Stojmenovic, 2014</xref>; <xref rid="ref-28" ref-type="bibr">Hu et al., 2017</xref>; <xref rid="ref-24" ref-type="bibr">He et al., 2018</xref>; <xref rid="ref-33" ref-type="bibr">Katona &amp; Panfilov, 2018</xref>). By deploying IoT applications in the fog, it is possible, for example, to prefilter data for stream processing or to conduct IoT data processing on-site instead of relying on cloud-based computational resources (<xref rid="ref-10" ref-type="bibr">Bonomi et al., 2014</xref>; <xref rid="ref-25" ref-type="bibr">Hochreiner et al., 2017</xref>). This leads to lower latency in IoT scenarios (<xref rid="ref-44" ref-type="bibr">Puliafito et al., 2019</xref>).</p>
    <p>Fog computing has been a vivid field of research in recent years, and the theoretical principles of fog computing as well as conceptual fog architectures are already well-established (<xref rid="ref-44" ref-type="bibr">Puliafito et al., 2019</xref>; <xref rid="ref-8" ref-type="bibr">Bellendorf &amp; Mann, 2020</xref>; <xref rid="ref-46" ref-type="bibr">Salaht, Desprez &amp; Lebre, 2020</xref>; <xref rid="ref-26" ref-type="bibr">Hong &amp; Varghese, 2019</xref>). However, there is a lack of implemented frameworks with the functionality to manage and monitor infrastructure, to deploy and execute services, and to dynamically react to changes in computational demand and fog computing infrastructure.</p>
    <p>Notably, fog computing is based on common principles from the field of cloud computing, most importantly virtualization (<xref rid="ref-66" ref-type="bibr">Yi, Li &amp; Li, 2015</xref>; <xref rid="ref-15" ref-type="bibr">Celesti et al., 2016</xref>): while in the cloud, physical machines are provided in terms of virtual machines (VMs), fog computing employs the idea that computational resources from edge devices can be offered in a similar manner. However, since VMs are resource-intensive, they are not the best virtualization approach for rather resource-constraint edge devices (<xref rid="ref-58" ref-type="bibr">Varghese &amp; Buyya, 2018</xref>). A promising solution for this issue is the utilization of <italic>containers</italic>, for example, Docker containers, as a virtualization mechanism for edge resources (<xref rid="ref-10" ref-type="bibr">Bonomi et al., 2014</xref>; <xref rid="ref-37" ref-type="bibr">Morabito et al., 2018</xref>). Accordingly, in order to provide a practical framework for fog computing, it is necessary to introduce mechanisms both to manage fog landscapes and to execute distributed IoT applications in the fog using containers. This requires the provisioning of mechanisms for resource allocation, decentralized service placement, deployment, and execution in a fog landscape.</p>
    <p>In this paper, we present the design and implementation of the fog computing framework <italic>FogFrame</italic>. FogFrame is built to provide coordinated control over the physical and virtual infrastructure of a fog landscape. The framework enables volatile IoT landscapes, where the system is ever-changing, with fog nodes and data sources potentially entering or leaving a system at any time, and the data volume to be processed changing frequently (<xref rid="ref-59" ref-type="bibr">Varshney &amp; Simmhan, 2017</xref>; <xref rid="ref-47" ref-type="bibr">Santos et al., 2019</xref>).</p>
    <p>Taking into account the potentially volatile nature of fog landscapes, we define the following main goals to be achieved by FogFrame: (i) to create and maintain a fog landscape made up from computational resources at the edge of the network and in the cloud, (ii) to establish communication and interaction in such a fog landscape, (iii) to efficiently deploy and execute IoT applications in the fog by distributing the services of the applications on the available fog resources.</p>
    <p>Building on the challenges identified above, we formulate the following research questions that provide the foundation for the work at hand:<list list-type="bullet"><list-item><p>How can edge devices be utilized for the resource-efficient execution of IoT applications?</p></list-item><list-item><p>How can the execution of IoT applications in a fog landscape be optimized for resource efficiency while considering predefined Quality of Service (QoS) parameters?</p></list-item><list-item><p>How to achieve a highly available, durable, and fault-tolerant fog landscape?</p></list-item></list></p>
    <p>Our contributions can be summarized as follows:<list list-type="bullet"><list-item><p>We design and implement the FogFrame framework, which provides communication and interaction of virtualized resources within a fog landscape.</p></list-item><list-item><p>We implement functionalities for decentralized service placement, deployment and execution in a fog landscape. Service placement is performed by two heuristic algorithms—a greedy algorithm and a genetic algorithm. We distinguish service deployment at the edge of the network and in the cloud and implement according deployment mechanisms.</p></list-item><list-item><p>We develop mechanisms to react to runtime operational events in the fog landscape, namely, when devices appear and disappear in the fog landscape, and when devices experience failures and overloads. The framework identifies those events and migrates necessary services to balance workload between different resources.</p></list-item><list-item><p>We evaluate the capabilities of FogFrame with regard to service placement, adherence to QoS parameters, and utilization of fog resources.</p></list-item></list></p>
    <p>The work at hand is based on our former work on conceptual fog frameworks and fog computing resource allocation. If compared to our most recent work (<xref rid="ref-49" ref-type="bibr">Skarlat et al., 2018</xref>), this paper reflects in-depth technical details of the architecture of the framework, communication within the fog landscape devices, and the application management. In this work, the framework enables mechanisms to create a fog landscape and account for its volatile nature, namely, it reacts to devices appearing and disappearing from the fog landscape, and tackles overloads and failures of resources. The framework provides a decentralized application execution in the fog and introduces a service placement problem formulation to account for practical issues dealing with volatile fog landscapes. The presented service placement functionalities are based on our former work (<xref rid="ref-52" ref-type="bibr">Skarlat et al., 2016</xref>; <xref rid="ref-50" ref-type="bibr">Skarlat et al., 2017a</xref>, <xref rid="ref-51" ref-type="bibr">2017b</xref>), where we researched fog computing environments and different service placement approaches and evaluated them using the simulators CloudSim and iFogSim (<xref rid="ref-23" ref-type="bibr">Gupta et al., 2017</xref>). Instead, in this work, we implement and extensively evaluate service placement algorithms in a representative real-world Raspberry Pi-based testbed.</p>
    <p>Compared to other frameworks, our framework addresses the volatility of the IoT. We explain and build a real-world fog landscape based on lightweight technologies, and aim at fault-tolerant decentralized application execution and efficient resource provisioning and service placement. As an additional outcome, our framework can be freely used in the research community to develop and evaluate different resource provisioning methods. This is enabled by providing a working software publicly available within our GitHub repository (<uri xlink:href="https://github.com/softls/FogFrame-2.0">https://github.com/softls/FogFrame-2.0</uri>) for reimplementing exchangeable loosely-coupled components, building and connecting a fog computing environment, and executing IoT applications.</p>
    <p>The remainder of this paper is organized as follows: “Fog Landscape Operation” provides the design specifications of FogFrame. Afterwards, “Service Placement” describes the system model for service placement and according placement algorithms. The framework is evaluated in “Evaluation”. “Related Work” discusses the state-of-the-art in the area of fog computing frameworks and service placement algorithms. Finally, conclusions and insights into future work are given in “Conclusion”.</p>
  </sec>
  <sec sec-type="operation">
    <title>Fog Landscape Operation</title>
    <p>Before describing the needed functionalities of fog computing frameworks, it is necessary to discuss general characteristics of fog landscapes. For this, we follow the notion of the fog as a <italic>thing-to-cloud continuum</italic> (<xref rid="ref-29" ref-type="bibr">IEEE 1934, 2018</xref>).</p>
    <p>Accordingly, a <italic>fog landscape</italic> consists of the combined computational and storage resource pool of cloud and edge resources (<xref rid="ref-17" ref-type="bibr">Dastjerdi et al., 2016</xref>; <xref rid="ref-28" ref-type="bibr">Hu et al., 2017</xref>). In most state-of-the-art approaches and standardization activities, fog landscapes follow a hierarchical structure (see <xref ref-type="fig" rid="fig-1">Fig. 1</xref>) (<xref rid="ref-31" ref-type="bibr">Karagiannis &amp; Schulte, 2021</xref>). At the bottom of this hierarchy, there are sensors and actuators, which are attached to different IoT devices. These devices have computational power and are able to host and execute arbitrary services. Within FogFrame, we call such IoT devices <italic>fog cells</italic>. Fog cells control sensors and actuators and are in turn managed and orchestrated by <italic>fog nodes</italic>. Fog nodes are themselves extended fog cells which possess the capabilities to not only host services, but also to perform management activities, such as service placement and deployment. Fog cells and fog nodes are two specific types of <italic>fog devices</italic>.</p>
    <fig id="fig-1" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-1</object-id>
      <label>Figure 1</label>
      <caption>
        <title>An overview of a fog landscape.</title>
      </caption>
      <graphic xlink:href="peerj-cs-07-588-g001"/>
    </fig>
    <p>A hierarchy of fog devices forms a <italic>fog colony</italic>: (i) sensors and actuators attached to fog cells and (ii) fog cells connected to a fog node, which becomes a parent to those fog cells. In each fog colony, there is exactly one head fog node that performs service placement. Other fog nodes can be present in the fog colony, they can perform computations in the same manner as fog cells, and as well be responsible for data communication between the connected fog cells and other fog nodes higher in the hierarchy. Having a hierarchical structure allows to control application deployments over a colony of devices, for example, a fog colony may become a domain-specific execution environment or cover a certain area.</p>
    <p>Since fog landscapes comprise computational resources from the cloud and the edge of the network, it is necessary to mediate between fog colonies and the cloud. In FogFrame, we foresee a <italic>fog controller</italic> for this. Head fog nodes communicate with a fog controller in the case additional cloud resources are needed. This controller establishes communication between fog colonies and the cloud. The fog controller also helps to establish communication within and between fog colonies. However, the latter may also act autonomously if the fog controller is not available. Fog colonies are connected to the fog controller via their head fog nodes.</p>
    <p>Fog colonies do not only interact with the cloud. Instead, the colonies also need to interact with each other in order to delegate application requests from one colony to another. For instance, if one fog colony does not have enough resources to execute an application, then it may delegate the corresponding application request to a neighbor fog colony. To do this, fog colonies are connected to each other via their corresponding head fog nodes.</p>
    <p>To establish coordinated control over a fog landscape, a fog computing framework has to be able to monitor and control the available devices and computational resources in the cloud and at the edge and to orchestrate those resources in order to deploy arbitrary services. Hence, FogFrame needs to provide the following functionalities: (i) Mechanisms to manage and support a fog landscape, namely, to establish communication within the fog landscape and to handle data transfers between fog colonies and the cloud; (ii) Mechanisms to manage application execution in an efficient manner by optimizing resource provisioning and service placement; and (iii) Methods to automatically migrate services due to the volatile nature of the fog landscape, for example, because new resources at the edge of the network are discovered, already existing resources become overloaded, or even disappear from the fog landscape due to failures. In the following subsections, we will describe how FogFrame provides these functionalities.</p>
    <sec>
      <title>Communication</title>
      <p>A fog landscape starts with instantiating a fog controller, which is an initial communication point for fog colonies. After instantiating the fog controller, fog devices can enter the fog landscape and start forming fog colonies. When creating the fog landscape, we follow the assumptions that (i) all fog devices are able to provide their location data, (ii) all fog devices are configured with the fog controller address to request joining the fog landscape (or are able to get the fog controller IP addresses through some bootstrapping mechanism), and (iii) all fog nodes can operate within predefined coverage areas, can form fog colonies, and operate fog devices within their coverage area.</p>
      <p>To enter the fog landscape, a fog device sends an asynchronous pairing request containing the own location data to the fog controller. The fog controller has a dedicated location service that based on the location coordinates and coverage areas of all fog nodes in the fog landscape returns data about the fog node that becomes a parent to this fog device. This is possible because each fog device contains data about its own device name, IP address, and location coordinates. Other data differs according to the fog device type, for example, fog nodes also contain a coverage area parameter defined. The coverage area defines a geographical area each fog node is responsible for. The criteria of finding a parent fog node could be based on different aspects, for example, the calculation of the physical distance between fog devices, but also efficiency, ratio of successful service execution, or latency. For the purposes of FogFrame, we have implemented searching for the closest parent according to the location of the fog device which enters the fog landscape, but it would be possible to extend this functionality by the criteria just mentioned.</p>
      <p>If the request is satisfied, the fog device sends a pairing request to this fog node. Upon successful pairing, the device is instantiated as a fog cell or as a fog node in the fog colony and is added to the set of children of the fog node. If the request is not satisfied, we consider two possible outcomes: (i) if the fog device is a fog cell, an error message is returned, and (ii) if the fog device is a fog node, this fog node becomes the head of a new fog colony as it has a unique range of location coordinates, namely, its coverage area. This workflow is shown in <xref ref-type="fig" rid="fig-2">Fig. 2</xref>.</p>
      <fig id="fig-2" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-2</object-id>
        <label>Figure 2</label>
        <caption>
          <title>Instantiating fog cells and fog nodes in a fog landscape.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g002"/>
      </fig>
      <p>To be able to delegate applications to a neighbor fog colony, each head fog node has to be connected with the head fog node of a neighbor fog colony. This connection is also established when a fog node is instantiated in the fog landscape. It requests the neighbor head fog node from the fog controller. The location service of the fog controller finds the closest neighbor head fog node according to the provided location coordinates. If the request is satisfied, the head fog node sends a pairing request to the closest neighbor head fog node. If the request is not satisfied, the head fog node either connects with a fallback neighbor fog colony, or continues to act autonomously.</p>
      <p>Upon joining a fog colony, it is the goal that a request from a fog cell to the direct parent, which is a fog node, can be satisfied. If a pairing request cannot be satisfied, a fallback mechanism is applied. For that, we enable searching for a fallback parent or grandparent fog node if the closest fog node or even the fog controller are not available. Fallback details can be either implemented as an internal property of a device, or can be sent to the device upon pairing. In FogFrame, fallback parent and grandparent IP addresses are provided as properties of each fog device.</p>
    </sec>
    <sec>
      <title>Application management</title>
      <p>To achieve cooperative execution of IoT applications, a fog landscape has to enable decentralization of application execution, making it possible that different parts of an IoT application are deployed and executed close to the relevant data sources and data sinks. Because of the benefits of containerized applications mentioned in “Introduction”, in FogFrame, <italic>applications</italic> are built following the microservice architectural approach from stateless services deployed and executed to achieve a certain result. An application can be visualized as a distributed data flow (<xref rid="ref-22" ref-type="bibr">Giang et al., 2015</xref>)—a directed acyclic graph where vertices are tasks to be executed in the flow, corresponding to services, and edges between vertices are data shipment connections between those services (<xref rid="ref-34" ref-type="bibr">Kougka &amp; Gounaris, 2019</xref>) (see <xref ref-type="fig" rid="fig-3">Fig. 3</xref>). <italic>Services</italic> are deployed and running computational software instances which process service requests in the fog landscape. A <italic>service request</italic> is a single computational job to be computed on fog devices. Services can be of certain <italic>service types</italic>. Service types are bound to the capabilities of the devices in the fog landscape. For example, a service intended to receive temperature measurements can be deployed only on a fog cell with a temperature sensor attached, some services can be executed either in the cloud or in the fog, and other services can be executed only in the cloud.</p>
      <fig id="fig-3" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-3</object-id>
        <label>Figure 3</label>
        <caption>
          <title>An example of a distributed data flow in a fog landscape.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g003"/>
      </fig>
      <p>The application execution starts with an <italic>application request</italic> which defines a set of services to be placed and deployed in the fog landscape together with QoS information for execution, for example, deadlines on application execution and processing times. It has to be noted that an application can only be executed if all its services are deployed. The deployment of services depends on the service placement mechanism which is applied within each head fog node of each fog colony in the fog landscape. It is possible to integrate arbitrary service placement algorithms into FogFrame. Within the work at hand, we provide two particular approaches aiming at utilizing available resources of fog colonies in the most efficient way, as presented in “Service Placement”. In the following, we describe how the application is processed on different resources in the fog landscape: inside a fog colony, in the cloud, or after being delegated to a neighbor fog colony (see <xref ref-type="fig" rid="fig-4">Fig. 4</xref>).</p>
      <fig id="fig-4" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-4</object-id>
        <label>Figure 4</label>
        <caption>
          <title>Application request processing on different fog resources (A–C).</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g004"/>
      </fig>
      <p>Application deployment and execution can be done based on different settings. The first (and simplest) setting is when each fog colony has enough own resources to execute an application request. In this case, all the necessary services are deployed in the current fog colony. The latency and deployment time are minimal and depend on the computational power of the resources of the colony. As it can be seen in <xref ref-type="fig" rid="fig-4">Fig. 4A</xref>, a user submits an asynchronous application request to a fog node. The service placement is performed according to the chosen service placement algorithm by the reasoning service of the fog node. It has to be noted that an application request can also be submitted to a fog cell (not depicted in <xref ref-type="fig" rid="fig-4">Fig. 4</xref>). If this is the case, the fog cell forwards the request to its parent fog node until the request reaches the head fog node of the corresponding fog colony, which performs service placement.</p>
      <p>Service placement is performed in a decentralized manner and is independent in each fog colony. To perform computations, the reasoning service uses information about the availability and utilization of all the fog cells in the fog colony. The result of the calculations in the algorithms is a <italic>service placement plan</italic>. After the service placement plan is calculated, the head fog node deploys the necessary services on according fog cells, and the fog cells immediately start service execution.</p>
      <p>The second setting of application execution is when apart from executing services in a fog colony, it is necessary to support fog colonies with additional resources from the cloud (<xref ref-type="fig" rid="fig-4">Figs. 4A</xref>–<xref ref-type="fig" rid="fig-4">4B</xref>). This applies for services which can be executed only in the cloud, for example, big data processing, and those services which cannot be placed on fog devices because of QoS constraints or a lack of resource capabilities, or services which can be executed either on the edge devices or in the cloud as they do not require specific sensor equipment. If specific services in the application request are assigned to the cloud, the fog node sends the request to execute this service in the cloud. For this, the fog controller authenticates itself with the cloud provider, either leases and instantiates a new VM in the cloud or connects to an existing VM, and deploys the corresponding service container. Specific implementation details about service deployment at the edge of the network and in the cloud are provided in “Evaluation”.</p>
      <p>The third setting of application execution regards if an application cannot be executed by a fog colony. However, this application requires sensor equipment, therefore it cannot be executed purely in the cloud. In this case, the request is delegated to a neighbor fog colony. This is the case when the service placement plan determines that there are not enough resource capacities in the current fog colony to execute the application, however there is enough time indicated by the application deadline to postpone the execution. Therefore, the fog node delegates the application request to the neighbor fog colony (<xref ref-type="fig" rid="fig-4">Fig. 4C</xref>).</p>
    </sec>
    <sec>
      <title>Migration of services</title>
      <p>As has already been mentioned above, running an application is only possible when all its services are deployed. Hence, if a fog device fails, services which have been running on that fog device need to be redeployed on other fog devices to ensure the application execution. If a new fog cell appears, it is beneficial to use its capacities to release other devices that are not yet overloaded but already close to full capacity, and migrate suitable services from the cloud to reduce additional unnecessary cost of fog landscape operation. To address this, FogFrame can react to certain events: (i) device discovery, if a fog device appears in the fog landscape, (ii) device failure, if a fog device is not able to provide services any longer, and (iii) device overload, if a fog device is expected to overload, meaning when the CPU, RAM or storage utilization is above a predefined threshold. To handle each of these event types, FogFrame implements corresponding services. To achieve this, each fog device is provided with a <italic>host monitor service</italic> which records CPU, RAM and storage utilization of each device. Correspondingly, each fog node contains a <italic>watchdog</italic> which periodically checks if the connected fog devices respond.</p>
      <p>A common event in a fog landscape is device overload. When the CPU power is used up to the maximum specified level, unexpected performance can take place and compromise the execution of all deployed services. In this work, we aim for 80% CPU load to get a balance between utilization and room for spikes, ad-hoc processes, and I/O bottlenecks. This threshold was set up during pre-experiments to allow for uninterrupted execution and availability of the devices. This threshold is also recommended by AWS (<uri xlink:href="https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html">https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-scaling-simple-step.html</uri> and Oracle (<uri xlink:href="https://docs.oracle.com/en/cloud/get-started/subscriptions-cloud/mmocs/setting-alert-performance-metric.html">https://docs.oracle.com/en/cloud/get-started/subscriptions-cloud/mmocs/setting-alert-performance-metric.html</uri>). This parameter can be easily changed in the FogFrame monitoring component. It is a matter of future research to take into account different thresholds for different devices according to their capabilities, namely, adaptive thresholds as presented, for example, by <xref rid="ref-36" ref-type="bibr">Maurer, Brandic &amp; Sakellariou (2013)</xref>.</p>
      <p>When a device is identified as overloaded by the head fog node, this event is therefore triggered and the device <italic>overload service</italic> triggers service placement (as presented in “Application Management”) bounded to the current fog colony, and migrates one random container from the affected device. The device overload service migrates services one by one until the affected device is not overloaded anymore. This migration method was adopted according to similar techniques in cloud computing (<xref rid="ref-53" ref-type="bibr">Smimite &amp; Afdel, 2020</xref>). The overload policy can be easily reimplemented and substituted with other methods. The framework architecture is loosely coupled and allows to add new implementations of used methods. A very promising approach to predict overload of fog devices presented by <xref rid="ref-40" ref-type="bibr">Nair &amp; Somasundaram (2019)</xref> could be implemented in future work.</p>
      <p>If a new fog device joins a fog colony, all its resources are analyzed to identify the current workload. First, if applicable, the discovery service migrates the services from the cloud to save cost. Second, all devices that operate at the maximum capacity and are overloaded, are considered for migration. The <italic>discovery service</italic> triggers the placement of suitable services from overloaded devices and migrates them to the new device either while needed, or until it is filled to a maximum defined number of containers. The number of containers can be adjusted according to the computational capacity of each fog device. This mechanism allows easy horizontal scalability of the resources in the fog landscape.</p>
      <p>It has to be noted that the vertical scalability of resources is bounded by the computational capacities of devices in a fog landscape: If it is possible to extend CPU or RAM on a device, then FogFrame will accordingly use those capacities. This is enabled by the implemented host monitor service that is deployed as a satellite service to each fog cell or fog node. This monitoring service will be described in the next subsection.</p>
      <p>Due to the volatile nature of fog landscapes, fog devices may disappear from the fog landscape when a physical IoT device gets out of range or disconnects. When a fog cell disappears from a fog colony due to a failure, the head fog node checks the service assignments to identify whether the failed fog device had any services running. The <italic>device failure service</italic> adds all services that were running on that fog device to a migration list, and triggers service placement as presented in “Application Management”, bounded to the current fog colony. Failures of fog cells are identified by a parent fog node when the fog cell is disconnected. Failures of fog cells trigger the migration service. Because fog nodes take care of communication between their connected fog cells and other fog nodes higher in the fog colony’s hierarchy, a failure of such an intermediary fog node not only triggers the migration service to recover all running services, but also requires fog cells to ask for a new parent fog node from the fog controller. In the case when the head fog node of the fog colony fails, then either there is a mechanism in place to connect all the fog colonies resources to a fallback head fog node, or to trigger a complete reorganization of the fog colonies. The latter is a topic for future research, that can be formulated as a meta control mechanism for reactive and proactive reorganization and optimization of fog colonies to ensure system durability and fault tolerance.</p>
    </sec>
    <sec>
      <title>System architecture</title>
      <p>To summarize the discussion of the system design, we discuss the high-level architecture of the main components of FogFrame, namely the fog controller, fog nodes, and fog cells. These components consist of dedicated services and interfaces which provide communication between the components, and within the components as well. The design of the framework is based on lightweight technologies and loosely-coupled components with the goal to create a stable and fault-tolerant distributed system. The extensible modules within each component enable interoperability and a convenient substitution by implementing the specified interface methods.</p>
      <p>In the fog controller (see <xref ref-type="fig" rid="fig-5">Fig. 5</xref>), the <italic>cloud service</italic> establishes the communication with the cloud and implements necessary functionalities to manage VMs and containers. The <italic>location service</italic> provides connection data for fog devices entering the fog landscape. The <italic>pairing service</italic> is responsible for pairing of fog devices as described in “Communication”. A <italic>local storage</italic> stores data about the structure of the fog landscape and the usage of cloud resources. The local storage is operated by the <italic>storage service</italic>.</p>
      <fig id="fig-5" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-5</object-id>
        <label>Figure 5</label>
        <caption>
          <title>Fog controller architecture.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g005"/>
      </fig>
      <p><xref ref-type="fig" rid="fig-6">Figures 6</xref> and <xref ref-type="fig" rid="fig-7">7</xref> depict the architectures of fog cells and fog nodes. All components are communicating via API calls. As it can be seen, fog nodes are extended fog cells. The fog cell consists of a <italic>storage service</italic> which operates a <italic>local storage</italic>, storing connection data, identification data, and application execution data. The <italic>communication service</italic> is responsible for establishing and maintaining communication with the fog controller and the parent fog node. The <italic>compute unit</italic> executes services and is responsible for data transfer between services. The <italic>fog action control</italic> follows the orders from the fog node of the fog colony, and deploys necessary services by the means of the <italic>container service</italic>. Finally, the <italic>host monitor</italic> monitors the utilization of the fog cell.</p>
      <fig id="fig-6" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-6</object-id>
        <label>Figure 6</label>
        <caption>
          <title>Fog cell architecture.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g006"/>
      </fig>
      <fig id="fig-7" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-7</object-id>
        <label>Figure 7</label>
        <caption>
          <title>Fog node architecture.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g007"/>
      </fig>
      <p>A fog node consists of all the components of a fog cell as well as some additional components. The <italic>shared storage service</italic> operates the <italic>shared storage</italic> which stores a <italic>shared service registry</italic> of all service images to be used for deployment. The local storage on the fog node is similar to the one in the fog cell. However, it stores additional data about fog cells in the fog colony, service placement plans, and execution details of applications. The shared storage service in a fog node is intentionally separated from the local storage container to ensure flexibility and replaceability. The <italic>watchdog</italic> constantly monitors the utilization data of all the connected fog devices, and triggers runtime events: device discovery, overload or failure events. The <italic>reasoning service</italic> is triggered when an application request is submitted for execution to the fog node. The reasoning service calls the <italic>resource provisioning service</italic>, which implements a certain service placement algorithm. We will present two particular algorithms for this in the next section, but as pointed out above, any arbitrary placement algorithm could be applied here. To summarize, the fog cell and the fog node provide all necessary functionalities to establish application management and account for the volatile nature of the fog landscape. Implementation details are provided in “Evaluation”.</p>
    </sec>
  </sec>
  <sec sec-type="placement">
    <title>Service Placement</title>
    <p>FogFrame allows decentralized service placement, which is ensured by reasoning and placement capabilities of each head fog node in fog colonies, as has already been mentioned in “Fog Landscape Operation”. Fog colonies autonomously perform service placement, even in case the fog controller or cloud-based computational resources are not available. The underlying service placement model, which will be discussed in detail in this section, determines an optimal mapping between services of applications and computational resources at the edge of the network and in the cloud (if available). The resource provisioning and service placement problem has been shown to be NP-hard (<xref rid="ref-3" ref-type="bibr">Afzal &amp; Kavitha, 2019</xref>). For this problem, an analogy towards the multiple knapsack problem can be performed (<xref rid="ref-4" ref-type="bibr">Amarante et al., 2013</xref>): different fog resources are knapsacks, single services of IoT applications are items to be inserted into knapsacks, the weight of knapsacks corresponds to available resources of fog devices, such as CPU, RAM and storage, and the costs of the knapsack are the defined QoS parameters. The complexity of a multiple knapsack problem is proven to be <italic>O</italic>(<italic>n</italic><sup>2</sup> + <italic>nm</italic>) (<xref rid="ref-18" ref-type="bibr">Detti, 2009</xref>), where <italic>n</italic> is the number of services to be placed and <italic>m</italic> is the number of fog resources available in a fog colony. For service placement, the objective function is to maximize the utilization of devices at the edge of the network while satisfying the QoS requirements of applications, namely, satisfying deadlines on application deployment and execution time.</p>
    <p>For this, every head fog node considers resources available in its fog colony, cloud resources, and the closest neighbor fog colony. A mapping between applications and computational resources determines the following subsets of service placement: (i) services to be executed on fog devices in the fog colony, (ii) services to be executed locally on the fog node, and (iii) services to be executed in the cloud. If at least one service of the application cannot be placed in those subsets, the whole application request is sent to the closest neighbor fog colony. Splitting single services from applications and delegating them to the neighbor fog colony is not considered in order to eliminate tracking of single services in the fog landscape and high intra-application latency and because of the necessary coordination between fog colonies. The service placement approach is reactive, namely, whenever application requests are submitted for execution to a fog node, the service placement algorithm as described in “Application Management” is triggered. Additionally, service placement is triggered each time operational runtime events happen in the fog landscape: appearing and disappearing of resources at the edge, failures and overloads. In the following, we formalize the according system model. <xref rid="table-1" ref-type="table">Table 1</xref> gives an overview of the notation of fog resources and applications.</p>
    <table-wrap id="table-1" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.7717/peerj-cs.588/table-1</object-id>
      <label>Table 1</label>
      <caption>
        <title>Notation of the fog resources and applications.</title>
      </caption>
      <alternatives>
        <graphic xlink:href="peerj-cs-07-588-g016"/>
        <table frame="hsides" rules="groups" content-type="text">
          <colgroup span="1">
            <col span="1"/>
            <col span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Notation</th>
              <th rowspan="1" colspan="1">Definition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">
                <bold>Fog resources</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>t</italic>
              </td>
              <td rowspan="1" colspan="1">Current placement time</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>τ</italic>
              </td>
              <td rowspan="1" colspan="1">Time difference of previous placement</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>R</italic>
              </td>
              <td rowspan="1" colspan="1">Cloud</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>F</italic>
              </td>
              <td rowspan="1" colspan="1">Head fog node</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>N</italic>
              </td>
              <td rowspan="1" colspan="1">Closest neighbor to <italic>F</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><italic>Res</italic>(<italic>F</italic>)</td>
              <td rowspan="1" colspan="1">Fog cells connected to F</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><italic>C</italic> = {<italic>U</italic>, <italic>M</italic>, <italic>S</italic>}</td>
              <td rowspan="1" colspan="1">Resource capacities of fog devices</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>U</italic>
                <sub>
                  <italic>F</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">CPU capacity of <italic>F</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>M</italic>
                <sub>
                  <italic>F</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">RAM capacity of <italic>F</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>S</italic>
                <sub>
                  <italic>F</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Storage capacity of <italic>F</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>K</italic>
                <sub>
                  <italic>F</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Container capacity of <italic>F</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>f</italic>
                <sub>
                  <italic>j</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Fog cell</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>U</italic>
                <sub>
                  <italic>f<sub>j</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">CPU capacity of <italic>f</italic><sub><italic>j</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>M</italic>
                <sub>
                  <italic>f<sub>j</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">RAM capacity of <italic>f</italic><sub><italic>j</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>Sf<sub>j</sub></italic>
              </td>
              <td rowspan="1" colspan="1">Storage capacity of <italic>f</italic><sub><italic>j</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>K</italic>
                <sub>
                  <italic>f<sub>j</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Container capacity of <italic>f</italic><sub><italic>j</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>d</italic>
                <sub>
                  <italic>f<sub>j</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Latency between <italic>F</italic> and <italic>f</italic><sub><italic>j</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>d</italic>
                <sub>
                  <italic>R</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Latency between <italic>F</italic> and <italic>R</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>d</italic>
                <sub>
                  <italic>N</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Latency between <italic>F</italic> and <italic>N</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">
                <bold>Application</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>A</italic>
              </td>
              <td rowspan="1" colspan="1">Set of applications to be executed</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>A</italic>
                <sub>
                  <italic>k</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Application</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>D</italic>
                <sub>
                  <italic>A<sub>k</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Deadline of <italic>A</italic><sub><italic>k</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>w</italic>
                <sub>
                  <italic>A<sub>k</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Deployment time of <italic>A</italic><sub><italic>k</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>w</italic>
                <sup>
                  <italic>t</italic>
                </sup>
                <sub>
                  <italic>A<sub>k</sub></italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Already passed deployment time of <italic>A</italic><sub><italic>k</italic></sub> at <italic>t</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <inline-formula id="ieqn-10">
                  <alternatives>
                    <inline-graphic xlink:href="peerj-cs-07-588-i001.jpg"/>
                    <tex-math id="M1">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t\end{document}</tex-math>
                    <mml:math id="mml-ieqn-10">
                      <mml:msubsup>
                        <mml:mover>
                          <mml:mi>T</mml:mi>
                          <mml:mo accent="false">¯</mml:mo>
                        </mml:mover>
                        <mml:mrow>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>w</mml:mi>
                              <mml:mi>N</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mi>t</mml:mi>
                      </mml:msubsup>
                    </mml:math>
                  </alternatives>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">Deployment time in the neighbor colony</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>m<sub>A<sub>k</sub></sub></italic>
              </td>
              <td rowspan="1" colspan="1">Makespan duration of <italic>A</italic><sub><italic>k</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>r</italic>
                <sub>
                  <italic>A</italic>
                  <sub>
                    <italic>k</italic>
                  </sub>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Response time of <italic>A</italic><sub><italic>k</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">|<italic>A</italic><sub><italic>k</italic></sub>|</td>
              <td rowspan="1" colspan="1">Number of services in <italic>A</italic><sub><italic>k</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>a</italic>
                <sub>
                  <italic>i</italic>
                </sub>
              </td>
              <td rowspan="1" colspan="1">Service in an application <italic>A</italic><sub><italic>k</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>U</italic>
                <sub>
                  <italic>a</italic>
                  <sub>
                    <italic>i</italic>
                  </sub>
                </sub>
              </td>
              <td rowspan="1" colspan="1">CPU demand of service <italic>a</italic><sub><italic>i</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>M<sub>a<sub>i</sub></sub></italic>
              </td>
              <td rowspan="1" colspan="1">RAM demand of service <italic>a</italic><sub><italic>i</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>S<sub>a<sub>i</sub></sub></italic>
              </td>
              <td rowspan="1" colspan="1">Storage demand of service <italic>a</italic><sub><italic>i</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic>m<sub>a<sub>i</sub></sub></italic>
              </td>
              <td rowspan="1" colspan="1">Makespan duration of service <italic>a</italic><sub><italic>i</italic></sub></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"><italic>Res<sub>a<sub>i</sub></sub></italic> (<italic>F</italic>)</td>
              <td rowspan="1" colspan="1">Fog cells able to host service <italic>a</italic><sub><italic>i</italic></sub></td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <sec>
      <title>System model</title>
      <sec>
        <title>Domain definition</title>
        <p>The decision variables <italic>x</italic><sup><italic>f<sub>j</sub></italic></sup><sub><italic>a<sub>i</sub></italic></sub>, <italic>x</italic><sup><italic>F</italic></sup><sub><italic>a</italic><sub><italic>i</italic></sub></sub>, <italic>x</italic><sup><italic>R</italic></sup><sub><italic>a</italic><sub><italic>i</italic></sub></sub> indicate the placement of a service <italic>a</italic><sub><italic>i</italic></sub> on a specific resource in a fog landscape, namely, on a fog cell <italic>f</italic><sub><italic>j</italic></sub>, fog node <italic>F</italic>, or in the cloud <italic>R</italic>. The decision variable <italic>y<sub>A<sub>k</sub></sub></italic> indicates that the request for the execution of the application <italic>A</italic><sub><italic>k</italic></sub> has to be delegated to the closest neighbor fog colony, with the head fog node <italic>N</italic>. Together, the decision variables form a <italic>service placement plan</italic>.</p>
        <p>Let <italic>a</italic><sub><italic>i</italic></sub> denote a service of the application <italic>A</italic><sub><italic>k</italic></sub>. In order to ensure that a service is compatible with the allocated resource, <italic>Res<sub>a<sub>i</sub></sub></italic>(<italic>F</italic>) is introduced to denote all the fog cells capable to run service <italic>a</italic><sub><italic>i</italic></sub>, with <inline-formula id="ieqn-1"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i002.jpg"/><tex-math id="M2">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}Re{s_{{a_i}}}(F) \subseteq Res(F)\end{document}</tex-math><mml:math id="mml-ieqn-1"><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></alternatives></inline-formula>. This formalism is necessary to account for service types, with which resources can be compatible with, for example, sensing, processing service types. The decision variables of the service placement problem are provided in <xref ref-type="disp-formula" rid="eqn-1">Eqs. (1)</xref>–<xref ref-type="disp-formula" rid="eqn-4">(4)</xref>:</p>
        <p>
          <disp-formula id="eqn-1">
            <label>(1)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e001.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M3">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}x_{{a_i}}^{{f_j}} \in \{ 0,1\} ,\forall {a_i} \in {A_k},\forall {f_j} \in Re{s_{{a_i}}}(F)\end{document}</tex-math>
              <mml:math id="mml-eqn-1">
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>f</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>∈</mml:mo>
                <mml:mo stretchy="false" fence="false">{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false" fence="false">}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>a</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>R</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>s</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>F</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-2">
            <label>(2)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e002.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M4">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}x_{{a_i}}^F \in \{ 0,1\} ,\forall {a_i} \in {A_k}\end{document}</tex-math>
              <mml:math id="mml-eqn-2">
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:msubsup>
                <mml:mo>∈</mml:mo>
                <mml:mo stretchy="false" fence="false">{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false" fence="false">}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>a</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-3">
            <label>(3)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e003.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M5">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}x_{{a_i}}^R \in \{ 0,1\} ,\forall {a_i} \in {A_k}\end{document}</tex-math>
              <mml:math id="mml-eqn-3">
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>R</mml:mi>
                </mml:msubsup>
                <mml:mo>∈</mml:mo>
                <mml:mo stretchy="false" fence="false">{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false" fence="false">}</mml:mo>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>a</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-4">
            <label>(4)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e004.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M6">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{y_{{A_k}}} \in \{ 0,1\}\end{document}</tex-math>
              <mml:math id="mml-eqn-4">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mo stretchy="false" fence="false">{</mml:mo>
                <mml:mn>0</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false" fence="false">}</mml:mo>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
      </sec>
      <sec>
        <title>Objective function</title>
        <p>The objective function of the service placement is to maximize the number of service placements in the available fog colonies, while satisfying the QoS requirements of applications, as defined in <xref ref-type="disp-formula" rid="eqn-5">(5)</xref>. Unlike execution of all services within one fog colony, delegation of the application to the closest neighbor fog colony or execution in the cloud suggests additional delays, which can become a serious constraint when the response time of the application is close its declared deadline. Hence, we use the prioritization coefficient <italic>P</italic>(<italic>A</italic><sub><italic>k</italic></sub>) for each application. The coefficient <italic>P</italic>(<italic>A</italic><sub><italic>k</italic></sub>) represents a weight of an application <italic>A</italic><sub><italic>k</italic></sub> determined by the the difference between the deadline <italic>D</italic><sub><italic>A<sub>k</sub></italic></sub> of the application and its already recorded deployment time <italic>w<sub>A<sub>k</sub></sub></italic>, as defined in <xref ref-type="disp-formula" rid="eqn-6">(6)</xref>. <italic>w<sub>A<sub>k</sub></sub></italic> appears in the cases when the application was propagated from another fog colony and had to wait until it is correctly placed on necessary resources. The priority for deployment is given to the applications with high <italic>w<sub>A<sub>k</sub></sub></italic>, and accordingly little difference <italic>D<sub>A<sub>k</sub></sub></italic> − <italic>w<sub>A<sub>k</sub></sub></italic>. <italic>N</italic>(<italic>A</italic><sub><italic>k</italic></sub>) denotes the number of services in the application request to be placed in fog colonies, as defined in <xref ref-type="disp-formula" rid="eqn-7">(7)</xref>.</p>
        <p>
          <disp-formula id="eqn-5">
            <label>(5)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e005.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M7">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\max \sum\limits_{{A_k}}^A P({A_k})N({A_k})\end{document}</tex-math>
              <mml:math id="mml-eqn-5">
                <mml:mo form="prefix" movablelimits="true">max</mml:mo>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>A</mml:mi>
                </mml:munderover>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mi>N</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-6">
            <label>(6)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e006.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M8">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}P({A_k}) = \displaystyle{1 \over {{D_{{A_k}}} - {w_{{A_k}}}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-6">
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mstyle scriptlevel="0" displaystyle="true">
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mn>1</mml:mn>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>D</mml:mi>
                            <mml:mrow>
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mi>A</mml:mi>
                                  <mml:mi>k</mml:mi>
                                </mml:msub>
                              </mml:mrow>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo>−</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>w</mml:mi>
                            <mml:mrow>
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mi>A</mml:mi>
                                  <mml:mi>k</mml:mi>
                                </mml:msub>
                              </mml:mrow>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:mfrac>
                  </mml:mrow>
                </mml:mstyle>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-7">
            <label>(7)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e007.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M9">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}N({A_k}) = \sum\limits_{{a_i}}^{{A_k}} \left( {\sum\limits_{{f_j}}^{Re{s_{{a_i}}}(F)} x_{{a_i}}^{{f_j}} + x_{{a_i}}^F} \right) + |{A_k}|{y_{{A_k}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-7">
                <mml:mi>N</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:munderover>
                      <mml:mo movablelimits="false">∑</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>f</mml:mi>
                            <mml:mi>j</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                        <mml:mi>e</mml:mi>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>s</mml:mi>
                            <mml:mrow>
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mi>a</mml:mi>
                                  <mml:mi>i</mml:mi>
                                </mml:msub>
                              </mml:mrow>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>F</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:munderover>
                    <mml:msubsup>
                      <mml:mi>x</mml:mi>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>f</mml:mi>
                            <mml:mi>j</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>+</mml:mo>
                    <mml:msubsup>
                      <mml:mi>x</mml:mi>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>F</mml:mi>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
      </sec>
      <sec>
        <title>Constraints</title>
        <p>The first set of constraints defines the usage of available CPU, RAM, and storage of fog resources (<italic>U<sub>a<sub>i</sub></sub></italic>, <italic>M<sub>a<sub>i</sub></sub></italic>, and <italic>S<sub>a<sub>i</sub></sub></italic>, respectively). The sum load of placed services should be within the tolerance limits of resource capacities of according fog devices, as shown in <xref ref-type="disp-formula" rid="eqn-8">(8)</xref>–<xref ref-type="disp-formula" rid="eqn-10">(10)</xref>. The tolerance limit of a resource is <italic>γ</italic> ∈ [0,1], for example, <italic>γ</italic> = 0.8 indicates that 80% of all device resources can be used to execute services and the rest 20% should be kept free in order to account for operational stability of the device. As described in “Migration of Services”, it would also be possible to utilize an approach based on adaptive thresholds. <italic>C</italic> = {<italic>U</italic>,<italic>M</italic>,<italic>S</italic>} denotes the corresponding capacities of CPU, RAM, and storage of fog cells and the fog node, and the corresponding CPU, RAM, and storage demands of services (see <xref rid="table-1" ref-type="table">Table 1</xref>).</p>
        <p>
          <disp-formula id="eqn-8">
            <label>(8)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e008.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M10">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\sum\limits_{{A_k}}^A \sum\limits_{{a_i}}^{{A_k}} {C_{{a_i}}}x_{{a_i}}^{{f_j}} \le \gamma {C_{{f_j}}},\forall {f_j} \in Re{s_{{a_i}}}(F)\end{document}</tex-math>
              <mml:math id="mml-eqn-8">
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>A</mml:mi>
                </mml:munderover>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>C</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>f</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>≤</mml:mo>
                <mml:mi>γ</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>C</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>f</mml:mi>
                          <mml:mi>j</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>R</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>s</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>F</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-9">
            <label>(9)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e009.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M11">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\sum\limits_{{A_k}}^A \sum\limits_{{a_i}}^{{A_k}} {C_{{a_i}}}x_{{a_i}}^F \le \gamma {C_F}\end{document}</tex-math>
              <mml:math id="mml-eqn-9">
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>A</mml:mi>
                </mml:munderover>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>C</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:msubsup>
                <mml:mo>≤</mml:mo>
                <mml:mi>γ</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>C</mml:mi>
                    <mml:mi>F</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-10">
            <label>(10)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e010.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M12">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}C = \{ U,M,S\}\end{document}</tex-math>
              <mml:math id="mml-eqn-10">
                <mml:mi>C</mml:mi>
                <mml:mo>=</mml:mo>
                <mml:mo stretchy="false" fence="false">{</mml:mo>
                <mml:mi>U</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>M</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>S</mml:mi>
                <mml:mo stretchy="false" fence="false">}</mml:mo>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>To execute applications according to the necessary QoS, the response time <italic>r<sub>A<sub>k</sub></sub></italic> of each application <italic>A</italic><sub><italic>k</italic></sub> has to be less that the declared deadline <italic>D</italic><sub><italic>Ak</italic></sub> of the application, as defined in <xref ref-type="disp-formula" rid="eqn-11">(11)</xref>. The response time <italic>r<sub>A<sub>k</sub></sub></italic> is defined as the sum of the total makespan duration <italic>m<sub>A<sub>k</sub></sub></italic> and its deployment time <italic>w<sub>A<sub>k</sub></sub></italic>, as defined in <xref ref-type="disp-formula" rid="eqn-12">(12)</xref>.</p>
        <p>
          <disp-formula id="eqn-11">
            <label>(11)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e011.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M13">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{r_{{A_k}}} \le {D_{{A_k}}},\forall {A_k} \in A\end{document}</tex-math>
              <mml:math id="mml-eqn-11">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>r</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>≤</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>D</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>A</mml:mi>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-12">
            <label>(12)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e012.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M14">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{r_{{A_k}}} = {m_{{A_k}}} + {w_{{A_k}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-12">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>r</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>w</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>The total makespan duration <italic>m<sub>A<sub>k</sub></sub></italic> consists of execution times of all single services of the application <italic>A</italic><sub><italic>k</italic></sub> accounting for the according communication delays between the head fog node and chosen for placement resources, as defined in <xref ref-type="disp-formula" rid="eqn-13">(13)</xref>–<xref ref-type="disp-formula" rid="eqn-14">(14)</xref>.</p>
        <p>
          <disp-formula id="eqn-13">
            <label>(13)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e013.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M15">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{m_{{A_k}}} = \sum\limits_{{a_i}}^{{A_k}} {L_{{a_i}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-13">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>L</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p><disp-formula id="eqn-14"><label>(14)</label><alternatives><graphic xlink:href="peerj-cs-07-588-e014.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/><tex-math id="M16">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\matrix{ {{L_{{a_i}}} = } \hfill &amp; {\sum\limits_{{f_j}}^{Re{s_{{a_i}}}(F)} d({a_i},{f_j})x_{{a_i}}^{{f_j}} + d({a_i},F)x_{{a_i}}^F + d({a_i},R)x_{{a_i}}^R} \hfill \cr }\end{document}</tex-math><mml:math id="mml-eqn-14"><mml:mtable columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:munderover><mml:mo movablelimits="false">∑</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munderover><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>F</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>R</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula><italic>d</italic>(<italic>a</italic><sub><italic>i</italic></sub>,<italic>f</italic><sub><italic>j</italic></sub>), <italic>d</italic>(<italic>a</italic><sub><italic>i</italic></sub>,<italic>F</italic>), and <italic>d</italic>(<italic>a</italic><sub><italic>i</italic></sub>,<italic>R</italic>) denote the makespan duration <italic>m<sub>a<sub>i</sub></sub></italic> of a service <italic>a</italic><sub><italic>i</italic></sub> in the case of its placement and execution on the fog cell <italic>f</italic><sub><italic>j</italic></sub>, fog node <italic>F</italic>, or cloud <italic>R</italic> respectively (<xref ref-type="disp-formula" rid="eqn-15">(15)</xref>–<xref ref-type="disp-formula" rid="eqn-17">(17)</xref>).</p>
        <p>
          <disp-formula id="eqn-15">
            <label>(15)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e015.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M17">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}d({a_i},{f_j}) = {d_{{f_j}}} + {m_{{a_i}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-15">
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>a</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>d</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>f</mml:mi>
                          <mml:mi>j</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-16">
            <label>(16)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e016.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M18">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}d({a_i},F) = {m_{{a_i}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-16">
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>a</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi>F</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-17">
            <label>(17)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e017.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M19">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}d({a_i},R) = 2{d_R} + {m_{{a_i}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-17">
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>a</mml:mi>
                    <mml:mi>i</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi>R</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>d</mml:mi>
                    <mml:mi>R</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p><italic>Example</italic>. Let the application <italic>A</italic><sub>1</sub> = {<italic>a</italic><sub>1</sub>,<italic>a</italic><sub>2</sub>,<italic>a</italic><sub>3</sub>,<italic>a</italic><sub>4</sub>} be distributed between a fog colony and the cloud (see <xref ref-type="fig" rid="fig-8">Fig. 8</xref>). To find the response time of an application <italic>r</italic><sub>1</sub>, the makespan of each service <italic>m<sub>a<sub>i</sub></sub></italic> is added to the delay and summed as in <xref ref-type="disp-formula" rid="eqn-18">(18)</xref>. In this example, we assume that the application had no previous deployment time, so that <italic>w<sub>A<sub>1</sub></sub></italic> = 0.</p>
        <fig id="fig-8" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-8</object-id>
          <label>Figure 8</label>
          <caption>
            <title>Example of a response time calculation.</title>
          </caption>
          <graphic xlink:href="peerj-cs-07-588-g008"/>
        </fig>
        <p>
          <disp-formula id="eqn-18">
            <label>(18)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e018.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M20">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{r_1} = d({f_{11}}) + {m_{a1}} + {m_{a2}} + 2d(R) + {m_{a3}} + d({f_{12}}) + {m_{a4}}\end{document}</tex-math>
              <mml:math id="mml-eqn-18">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>r</mml:mi>
                    <mml:mn>1</mml:mn>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mrow>
                      <mml:mn>11</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mn>2</mml:mn>
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>R</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mn>3</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mrow>
                      <mml:mn>12</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>m</mml:mi>
                    <mml:mrow>
                      <mml:mi>a</mml:mi>
                      <mml:mn>4</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>The application deployment time <italic>w<sub>A<sub>k</sub></sub></italic> from the <xref ref-type="disp-formula" rid="eqn-12">Eq. (12)</xref> accounts for the time spent by the application before all its services are placed on the chosen resources. In the case when one of the services <italic>a</italic><sub><italic>i</italic></sub>∈ <italic>A</italic><sub><italic>k</italic></sub> cannot be placed in the current fog colony, the whole application needs to be delegated to the neighbor fog colony. Therefore, additional expected deployment time <inline-formula id="ieqn-2"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i003.jpg"/><tex-math id="M21">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t\end{document}</tex-math><mml:math id="mml-ieqn-2"><mml:msubsup><mml:mover><mml:mi>T</mml:mi><mml:mo accent="false">¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> can appear. To define whether this additional deployment time affects <italic>w<sub>A<sub>k</sub></sub></italic> or not, we introduce the auxiliary variable <italic>y<sub>A<sub>k</sub></sub></italic>. Let <italic>y<sub>A<sub>k</sub></sub></italic> = 0 if all services can be successfully placed in the current fog colony, and <italic>y<sub>A<sub>k</sub></sub></italic> = 1 if at least one service <italic>a</italic><sub><italic>i</italic></sub> ∈ <italic>A</italic><sub><italic>k</italic></sub> cannot be placed in the current fog colony, and the whole application needs to be delegated. Therefore, the application deployment time <italic>w<sub>A<sub>k</sub></sub></italic> is defined as follows:</p>
        <p>
          <disp-formula id="eqn-19">
            <label>(19)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e019.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M22">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{w_{{A_k}}} = w_{{A_k}}^t + \overline T _{{w_N}}^t{y_{{A_k}}}\end{document}</tex-math>
              <mml:math id="mml-eqn-19">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>w</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:msubsup>
                  <mml:mi>w</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msubsup>
                <mml:mo>+</mml:mo>
                <mml:msubsup>
                  <mml:mover>
                    <mml:mi>T</mml:mi>
                    <mml:mo accent="false">¯</mml:mo>
                  </mml:mover>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>w</mml:mi>
                        <mml:mi>N</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msubsup>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>It is clear that <inline-formula id="ieqn-3"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i004.jpg"/><tex-math id="M23">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t\end{document}</tex-math><mml:math id="mml-ieqn-3"><mml:msubsup><mml:mover><mml:mi>T</mml:mi><mml:mo accent="false">¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> affects the application deployment time only when <italic>y<sub>A<sub><italic>k</italic></sub></sub></italic> = 1. The closest neighbor fog node has own service placement which can either place all services <italic>a</italic><sub><italic>i</italic></sub> ∈ <italic>A</italic><sub><italic>k</italic></sub> in its fog colony or further postpone the execution of the application <italic>A</italic><sub><italic>k</italic></sub> by delegating it further in the fog landscape. To avoid a ping-pong with an application between the two closest fog colonies, additional criteria can be considered, for example, the rate of successful service execution, free capacities, or a percentage of load on a fog colony. In the current work, if the application cannot be deployed in a fog colony or in a neighbor fog colony before a stated deadline, it is either deployed in the cloud if the service types allow that, or not deployed at all. To calculate the expected deployment time in the closest neighbor colony, <inline-formula id="ieqn-4"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i005.jpg"/><tex-math id="M24">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t\end{document}</tex-math><mml:math id="mml-ieqn-4"><mml:msubsup><mml:mover><mml:mi>T</mml:mi><mml:mo accent="false">¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> requires to view forward in time. Therefore, we estimate <inline-formula id="ieqn-5"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i006.jpg"/><tex-math id="M25">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t\end{document}</tex-math><mml:math id="mml-ieqn-5"><mml:msubsup><mml:mover><mml:mi>T</mml:mi><mml:mo accent="false">¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> relying on historical data. <inline-formula id="ieqn-6"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i007.jpg"/><tex-math id="M26">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t\end{document}</tex-math><mml:math id="mml-ieqn-6"><mml:msubsup><mml:mover><mml:mi>T</mml:mi><mml:mo accent="false">¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mi>t</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> is obtained as the moving average on the latest sampled deployment time <inline-formula id="ieqn-7"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i008.jpg"/><tex-math id="M27">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}T_{{w_N}}^{t - \tau }\end{document}</tex-math><mml:math id="mml-ieqn-7"><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>τ</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> per service delegated to the closest neighbor fog colony as defined in <xref ref-type="disp-formula" rid="eqn-20">(20)</xref>, where 1 − <italic>α</italic>, <italic>α</italic> ∈ [0,1] denotes the discount factor of the moving average, <inline-formula id="ieqn-8"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i009.jpg"/><tex-math id="M28">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}T_{{w_N}}^{t - \tau }\end{document}</tex-math><mml:math id="mml-ieqn-8"><mml:msubsup><mml:mi>T</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>τ</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> is the already passed deployment time of the service delegated to the neighbor fog node <italic>N</italic> during the time <italic>t</italic> − <italic>τ</italic> , and <inline-formula id="ieqn-9"><alternatives><inline-graphic xlink:href="peerj-cs-07-588-i010.jpg"/><tex-math id="M29">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^{t - \tau }\end{document}</tex-math><mml:math id="mml-ieqn-9"><mml:msubsup><mml:mover><mml:mi>T</mml:mi><mml:mo accent="false">¯</mml:mo></mml:mover><mml:mrow><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>τ</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> stands for the average deployment time in <italic>N</italic> as estimated in <italic>t</italic> − <italic>τ</italic>.</p>
        <p>
          <disp-formula id="eqn-20">
            <label>(20)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e020.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M30">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\overline T _{{w_N}}^t = \alpha T_{{w_N}}^{t - \tau } + (1 - \alpha )\overline T _{{w_N}}^{t - \tau }\end{document}</tex-math>
              <mml:math id="mml-eqn-20">
                <mml:msubsup>
                  <mml:mover>
                    <mml:mi>T</mml:mi>
                    <mml:mo accent="false">¯</mml:mo>
                  </mml:mover>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>w</mml:mi>
                        <mml:mi>N</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>t</mml:mi>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:mi>α</mml:mi>
                <mml:msubsup>
                  <mml:mi>T</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>w</mml:mi>
                        <mml:mi>N</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>τ</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>+</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:mi>α</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:msubsup>
                  <mml:mover>
                    <mml:mi>T</mml:mi>
                    <mml:mo accent="false">¯</mml:mo>
                  </mml:mover>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>w</mml:mi>
                        <mml:mi>N</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>t</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>τ</mml:mi>
                  </mml:mrow>
                </mml:msubsup>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>Next, the container capacity meaning the number of deployed containers, should not be more than <italic>K<sub>f<sub>j</sub></sub></italic> containers for each of the fog cells and <italic>K</italic><sub><italic>F</italic></sub> for fog nodes as defined in <xref ref-type="disp-formula" rid="eqn-21">(21)</xref> and <xref ref-type="disp-formula" rid="eqn-22">(22)</xref>, because that may cause overload.</p>
        <p>
          <disp-formula id="eqn-21">
            <label>(21)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e021.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M31">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\sum\limits_{{A_k}}^A \sum\limits_{{a_i}}^{{A_k}} x_{{a_i}}^{{f_j}} \le \gamma {K_{{f_j}}},\forall {f_j} \in Re{s_{{a_i}}}(F)\end{document}</tex-math>
              <mml:math id="mml-eqn-21">
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>A</mml:mi>
                </mml:munderover>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>f</mml:mi>
                        <mml:mi>j</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:msubsup>
                <mml:mo>≤</mml:mo>
                <mml:mi>γ</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>K</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>f</mml:mi>
                          <mml:mi>j</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>f</mml:mi>
                    <mml:mi>j</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>R</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>s</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>a</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>F</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-22">
            <label>(22)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e022.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M32">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}\sum\limits_{{A_k}}^A \sum\limits_{{a_i}}^{{A_k}} x_{{a_i}}^F \le \gamma {K_F}\end{document}</tex-math>
              <mml:math id="mml-eqn-22">
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>A</mml:mi>
                </mml:munderover>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:msubsup>
                  <mml:mi>x</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:msubsup>
                <mml:mo>≤</mml:mo>
                <mml:mi>γ</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>K</mml:mi>
                    <mml:mi>F</mml:mi>
                  </mml:msub>
                </mml:mrow>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>We have to provide the condition that in the case when any of the services in an application cannot be placed in the current fog colony, the application request has to be sent to the neighbor colony as has been described in “Application Management”. For that, we first calculate the number of services placed in the current fog colony and in the cloud:</p>
        <p>
          <disp-formula id="eqn-23">
            <label>(23)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e023.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M33">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{n_{{A_k}}} = \sum\limits_{{a_i}}^{{A_k}} \left( {\sum\limits_{{f_j}}^{Re{s_{{a_i}}}(F)} x_{{a_i}}^{{f_j}} + x_{{a_i}}^F + x_{{a_i}}^R} \right),\forall {A_k} \in A\end{document}</tex-math>
              <mml:math id="mml-eqn-23">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>n</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:munderover>
                  <mml:mo movablelimits="false">∑</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>a</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>A</mml:mi>
                        <mml:mi>k</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:munderover>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:munderover>
                      <mml:mo movablelimits="false">∑</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>f</mml:mi>
                            <mml:mi>j</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>R</mml:mi>
                        <mml:mi>e</mml:mi>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>s</mml:mi>
                            <mml:mrow>
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mi>a</mml:mi>
                                  <mml:mi>i</mml:mi>
                                </mml:msub>
                              </mml:mrow>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>F</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:munderover>
                    <mml:msubsup>
                      <mml:mi>x</mml:mi>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>f</mml:mi>
                            <mml:mi>j</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                    </mml:msubsup>
                    <mml:mo>+</mml:mo>
                    <mml:msubsup>
                      <mml:mi>x</mml:mi>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>F</mml:mi>
                    </mml:msubsup>
                    <mml:mo>+</mml:mo>
                    <mml:msubsup>
                      <mml:mi>x</mml:mi>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>a</mml:mi>
                            <mml:mi>i</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mi>R</mml:mi>
                    </mml:msubsup>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>A</mml:mi>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>Next, if the total number of services placed in the current colony and in the cloud is less than the total number of services in the application, that means if <italic>n</italic><sub><italic>A</italic><sub><italic>k</italic></sub></sub>&lt;|<italic>A</italic><sub><italic>k</italic></sub>|, then the application request has to be sent to the closest neighbor colony, namely, <italic>y<sub>A<sub>k</sub></sub></italic> = 1, else <italic>y<sub>A<sub>k</sub></sub></italic> = 0. This conditional constraint is formulated using big-M coefficients (<xref rid="ref-27" ref-type="bibr">Hooker &amp; Osorio, 1999</xref>), and is represented in <xref ref-type="disp-formula" rid="eqn-24">(24)</xref> and <xref ref-type="disp-formula" rid="eqn-25">(25)</xref>, respectively:</p>
        <p>
          <disp-formula id="eqn-24">
            <label>(24)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e024.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M34">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{n_{{A_k}}} - |{A_k}| \le M(1 - {y_{{A_k}}}) - 1,\forall {A_k} \in A\end{document}</tex-math>
              <mml:math id="mml-eqn-24">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>n</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>−</mml:mo>
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                </mml:mrow>
                <mml:mo>≤</mml:mo>
                <mml:mi>M</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>−</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>A</mml:mi>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>
          <disp-formula id="eqn-25">
            <label>(25)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e025.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M35">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}|{A_k}| - {n_{{A_k}}} \le M{y_{{A_k}}} - 1,\forall {A_k} \in A\end{document}</tex-math>
              <mml:math id="mml-eqn-25">
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                </mml:mrow>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                </mml:mrow>
                <mml:mo>−</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>n</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>≤</mml:mo>
                <mml:mi>M</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>A</mml:mi>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p>Finally, we define that each service <italic>a</italic><sub><italic>i</italic></sub> can be placed in exactly one computational resource <italic>f</italic><sub><italic>j</italic></sub>, <italic>F</italic>, <italic>N</italic>, or in the cloud <italic>R</italic>, or the whole application request has to be sent to the closest neighbor fog colony:</p>
        <p>
          <disp-formula id="eqn-26">
            <label>(26)</label>
            <alternatives>
              <graphic xlink:href="peerj-cs-07-588-e026.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
              <tex-math id="M36">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{n_{{A_k}}} + {y_{{A_k}}} = 1,\forall {A_k} \in A\end{document}</tex-math>
              <mml:math id="mml-eqn-26">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>n</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>+</mml:mo>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>A</mml:mi>
                          <mml:mi>k</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="normal">∀</mml:mi>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>A</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:msub>
                </mml:mrow>
                <mml:mo>∈</mml:mo>
                <mml:mi>A</mml:mi>
              </mml:math>
            </alternatives>
          </disp-formula>
        </p>
        <p><italic>Example</italic>. To provide an estimation of the number of variables and constraints in the service placement problem, we consider the following example: An application <italic>A</italic><sub>1</sub> with 10 services <italic>a</italic><sub>1</sub>…<italic>a</italic><sub>10</sub> is submitted for execution to a fog colony with a head fog node <italic>F</italic> and two fog cells <italic>f</italic><sub>1</sub> and <italic>f</italic><sub>2</sub>. In this example, the assumption is that the both fog cells <italic>f</italic><sub>1</sub> and <italic>f</italic><sub>2</sub> and the head fog node <italic>F</italic> are able to execute all service types to which the services belong. For this setting, a service placement problem consists of making a decision for in total 41 decision variables, which are:<list list-type="bullet"><list-item><p>Ten decision variables <italic>x</italic><sup><italic>f</italic><sub>1</sub></sup><sub><italic>a</italic><sub>1</sub><sub>…</sub><sub><italic>a</italic><sub>10</sub></sub></sub> corresponding to the placement decision of each of the services <italic>a</italic><sub>1</sub>…<italic>a</italic><sub>10</sub> on the fog cell <italic>f</italic><sub>1</sub> and accordingly another ten decision variables <italic>x</italic><sup><italic>f</italic><sub>2</sub></sup><sub><italic>a</italic><sub>1</sub><sub>…</sub><sub><italic>a</italic><sub>10</sub></sub></sub> of each service <italic>a</italic><sub>1</sub>…<italic>a</italic><sub>10</sub> on the fog cell <italic>f</italic><sub>2</sub>.</p></list-item><list-item><p>Ten decision variables <italic>x</italic><sup><italic>F</italic></sup><sub><italic>a</italic><sub>1</sub><sub>…</sub><sub><italic>a</italic><sub>10</sub></sub></sub> corresponding to the placement of each service <italic>a</italic><sub>1</sub>…<italic>a</italic><sub>10</sub> placed on the head fog node <italic>F</italic>.</p></list-item><list-item><p>Ten decision variables <italic>x</italic><sup><italic>R</italic></sup><sub><italic>a</italic><sub>1</sub><sub>…</sub><sub><italic>a</italic><sub>10</sub></sub></sub> corresponding to a propagation decision of each service <italic>a</italic><sub>1</sub>…<italic>a</italic><sub>10</sub> to the cloud resources <italic>R</italic>.</p></list-item><list-item><p>One decision variable <italic>y</italic><sub>A<sub>1</sub></sub> denoting whether the whole application needs to be delegated to the neighbor fog colony.</p></list-item></list></p>
        <p>With regard to the constraints, the first set of constraints deal with CPU, RAM and storage capacities of each device according to <xref ref-type="disp-formula" rid="eqn-8">(8)</xref>–<xref ref-type="disp-formula" rid="eqn-10">(10)</xref>, meaning three constraints for each computation device <italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub>, and <italic>F</italic>. Secondly, the response time constraint is only one according to the calculations <xref ref-type="disp-formula" rid="eqn-11">(11)</xref>–<xref ref-type="disp-formula" rid="eqn-20">(20)</xref> corresponding to one application <italic>A</italic><sub>1</sub>. Next, there are three container capacity constraints according to <xref ref-type="disp-formula" rid="eqn-21">(21)</xref>–<xref ref-type="disp-formula" rid="eqn-22">(22)</xref> per each <italic>f</italic><sub>1</sub>, <italic>f</italic><sub>2</sub>, and <italic>F</italic>. Afterwards, to calculate whether the application <italic>A</italic><sub>1</sub> can be placed in the current fog colony or needs to be delegated to the neighbor fog colony, two additional constraints per application, that is in our case only one application, need to be calculated according to <xref ref-type="disp-formula" rid="eqn-23">(23)</xref>–<xref ref-type="disp-formula" rid="eqn-25">(25)</xref>. And the last set of constraints ensures that each service can be placed only on one resource, that means one constraint according to <xref ref-type="disp-formula" rid="eqn-26">(26)</xref>. To summarize, the number of variables and constraints depends on the number of resources in the fog landscape, the number of applications requested for execution, and the number of services to be deployed in each application.</p>
      </sec>
    </sec>
    <sec>
      <title>Greedy algorithm</title>
      <p>As mentioned above, we provide two service placement algorithms as examples in FogFrame. The greedy algorithm implemented in the framework (see <xref rid="table-5" ref-type="table">Algorithm 1</xref>) is based on finding a first fit device for each service request (<xref rid="ref-62" ref-type="bibr">Xu, Tian &amp; Buyya, 2017</xref>). The idea is to walk over sorted fog devices according to their service types, available resource capacities, and incoming service requests, and check whether a fog device is able to host and deploy a service according to the device’s utilization. If any service in the application cannot be deployed, the whole application is delegated to the neighbor colony. The main benefit of greedy algorithms is that they produce fast and feasible solution (<xref rid="ref-62" ref-type="bibr">Xu, Tian &amp; Buyya, 2017</xref>).</p>
      <table-wrap id="table-5" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/table-5</object-id>
        <label>Algorithm 1</label>
        <caption>
          <title>Greedy Algorithm.</title>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-cs-07-588-g017"/>
          <table frame="hsides" rules="groups" content-type="text">
            <colgroup span="1">
              <col span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1"><bold>Input:</bold> Set&lt;Fogdevice&gt; <italic>fogDevices</italic>, Set&lt;TaskRequest&gt; <italic>requests</italic></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1"><bold>Output:</bold> List&lt;TaskAssignment&gt; <italic>assignments</italic>, List&lt;TaskRequest&gt; <italic>openRequests</italic></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">1 <italic>assignments</italic> ← []; <italic>round</italic> = 0;</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">2 <italic>sortedRequests</italic> ← sortByServiceType(requests)</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">3 <italic>sortedFogDevices</italic> ← sortByServiceType(fogDevices)</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">4 <bold>for</bold>
<italic>fogDevice</italic> ∈ <italic>sortedFogDevices</italic>
<bold>do</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">5  <bold>for</bold>
<italic>serviceType</italic> ∈ <italic>fogDevice.serviceTypes</italic>
<bold>do</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">6   <bold>for</bold>
<italic>request</italic> ∈ <italic>sortedRequests</italic>
<bold>do</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">7    <bold>if</bold>
<italic>serviceType</italic> == <italic>request.serviceType</italic>
<bold>then</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">8     <italic>utilization</italic> ← getUtilization(<italic>fogDevice</italic>);</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">9     <italic>containers </italic>← getContainerCount(<italic>f ogDevice</italic>);</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">10     <bold>if</bold>
<italic>checkRules</italic>(<italic>utilization</italic>) &amp; <italic>containers</italic> &lt; <italic>MAX CONTAINERS</italic>
<bold>then</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">11      <italic>container</italic> ← sendDeploymentRequest(<italic>fogDevice</italic>, <italic>request</italic>);</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">12      assignments.add(<italic>fogDevice</italic>, <italic>request</italic>,<italic>container</italic>);</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">13      sortedRequests.remove(<italic>request</italic>);</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">14     <bold>end</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">15    <bold>end</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">16   <bold>end</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">17  <bold>end</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">18  <bold>if</bold> !<italic>sortedFogDevices.hasNext</italic>() &amp; <italic>round</italic> &lt; <italic>ROUNDS</italic> &amp; <italic>sortedRequests.size</italic>() &gt; 0 <bold>then</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">19   <italic>round</italic> = <italic>round</italic>+1;</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">20   sortedFogDevices.reStart();</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">21  <bold>end</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">22 <bold>end</bold></td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">23 <italic>openRequests</italic> ← sortedRequests;</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">24 <bold>return</bold>
<italic>assignments</italic>, <italic>openRequests</italic></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>The algorithm takes the set of fog devices in the fog colony and the incoming service requests as inputs. Line 1 of <xref rid="table-5" ref-type="table">Algorithm 1</xref> initializes an empty assignments list and a new counter parameter. This counter enables several tries to place a service in the algorithm. This counter is necessary to account for released resources in the case when the execution of already deployed services has been finished at the time of service placement. Lines 2 and 3 sort according sets by service type in order to assign sensor-related services to fog cells with the highest priority because sensor equipment is available only there, for example, a service sensing temperature can be placed only on the device with a temperature sensor attached. If any service can be executed both on the fog device and in the cloud, the service is assigned to the fog device if available.</p>
      <p>Lines 4 to 6 start the loops over the sorted fog devices and service requests. These loops ensure the placement of equipment-specific services on fog cells first, and if they can be placed, an attempt to place all other services is performed. Otherwise, the whole application has to be delegated to the neighbor fog colony. Line 7 checks if the service type of the service request corresponds to the service types of the fog device. This is necessary because a constraint on matching service types of a service and device is the main constraint in the service placement, otherwise the assignment is not possible. In Lines 8 and 9, the utilization and the number of already deployed containers is requested from the fog device in order to check if there are enough resources in the fog device. This is done in order to check the utilization constraints in Line 10, where the utilization parameters and the number of deployed services are compared to predefined monitoring rules, for example, CPU utilization &lt;80%.</p>
      <p>If those parameters are satisfied, a fog device is able to host a service, and a deployment request is sent to the fog device in Line 11. In the event of successful service deployment, the fog device sends the detailed information about the deployed container to the fog node. In Line 12, an assignment consisting of the fog device, service request, and the identifier of the deployed container is created. With this assignment, it becomes possible to keep track of all the deployed services and according containers in a fog colony. A successfully executed service request is removed from the input set in Line 13 making sure the service is deployed exactly once.</p>
      <p>Line 18 checks if the outer-most fog device cycle is finished, the provisioning round counter is smaller than the maximal defined number of tries, and if there are still opened service requests. If this is the case, the round counter is increased and the fog device iterator is re-initialized to restart the provisioning with the remaining service requests (Lines 19 and 20). After all the requests are handled or the maximum number of provisioning rounds is exceeded, the created assignments and the open requests are returned (Line 23 and 24). If the open requests list is not empty, then the according application requests are sent to the neighbor fog colony and already deployed services from those applications are stopped.</p>
    </sec>
    <sec>
      <title>Genetic algorithm</title>
      <p>The choice to use a genetic algorithm for service placement is based on the popularity of genetic algorithms to solve similar allocation and scheduling problems in cloud environments (<xref rid="ref-5" ref-type="bibr">Arunarani, Manjula &amp; Sugumaran, 2019</xref>; <xref rid="ref-71" ref-type="bibr">Zhang et al., 2019</xref>; <xref rid="ref-45" ref-type="bibr">Reddy et al., 2020</xref>), their lightweight nature, which helps to run genetic algorithms on resource-constrained devices at the edge of the network, as well as our own positive experience with using genetic algorithms to find solutions to service placement problems in fog computing (<xref rid="ref-50" ref-type="bibr">Skarlat et al., 2017a</xref>).</p>
      <p>Genetic algorithms allow to browse a large search space and provide a viable qualitative solution in polynomial time (<xref rid="ref-69" ref-type="bibr">Yoo, 2009</xref>; <xref rid="ref-70" ref-type="bibr">Yu, Buyya &amp; Ramamohanarao, 2009</xref>; <xref rid="ref-64" ref-type="bibr">Ye, Zhou &amp; Bouguettaya, 2011</xref>). One iteration of a genetic algorithm applies the genetic operators of selection, crossover, and mutation on a generation of solutions of an optimization problem (<xref rid="ref-60" ref-type="bibr">Whitley, 1994</xref>). In our case, the optimization problem is to make a decision about service placement on fog resources, i.e., to produce a service placement plan. A generation consists of individuals represented by their chromosomes. Each chromosome denotes one solution to the considered problem, in our case a chromosome is one service placement plan. The genetic algorithm starts with the process of selection of individuals for reproduction. For that the fitness function of each chromosome is calculated based on the goal function and constraints of the service placement problem, and the best chromosomes are selected. To create an offspring from the selected individuals, the crossover operator swaps genes of each two chromosomes. In order not to lose the best-performing candidate solutions, some individuals with the highest fitness values of their chromosomes are forwarded to the next generation unaltered, they do not participate in crossover, becoming the elite individuals. After that in order to ensure diversity of the population, the mutation operator changes a random number of genes in some of the chromosomes. As a result, a new generation is evolved consisting from the elite and offspring individuals. The algorithm repeats this process until activation of defined stopping conditions. Different approaches can be applied as stopping conditions, for example, the total number of evolved generations, a tolerance value of the fitness function, or elapsed time. In the following, we describe the concrete implementation of the genetic algorithm in FogFrame.</p>
      <p>The chromosome representation is a vector corresponding to a service placement plan (see <xref ref-type="fig" rid="fig-9">Fig. 9</xref>). The length of this vector equals to the total number of services in the requested application. Each gene in a chromosome is an integer number corresponding to the identifier of a fog device or the cloud. When a service cannot be placed at any of the devices in the fog colony or in the cloud, it remains unassigned. In this case, the whole corresponding application will be delegated to the closest neighbor colony. This chromosome representation ensures the placement of all services, meaning that there are no invalid chromosomes. Additionally, the chromosome representation stores necessary data to estimate utilization of devices that includes CPU, RAM, and storage resources of fog devices, and estimated response time of the application.</p>
      <fig id="fig-9" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-9</object-id>
        <label>Figure 9</label>
        <caption>
          <title>Chromosome representation.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g009"/>
      </fig>
      <p>In the fitness function, we encourage the chromosome if it fulfills the constraints of the system model presented in “System Model” and apply penalties if the constraints are violated (<xref rid="ref-65" ref-type="bibr">Yeniay, 2005</xref>). The constraints of the optimization problem have been divided into three sets which affect the fitness function to different degrees: (i) a set <italic>ψ</italic> of constraints on capacities of CPU, RAM and storage resources of fog devices, (ii) a set <italic>γ</italic> of implicit binary constraints derived from the goal function: conformance to service types, indications if cloud or fog colony resources have to be used, and prioritization of own fog colony resources, and (iii) a set υ causing the death penalty of the chromosome if the service types, container capacities in devices, or deadlines are violated.</p>
      <p>Let <italic>c</italic> denote a chromosome. For constraints ∀<italic>β</italic><sub><italic>p</italic></sub> ∈ <italic>ψ</italic>, if <italic>β</italic><sub><italic>p</italic></sub>(<italic>c</italic>)≤ 0, the constraints are satisfied. If <italic>β</italic><sub><italic>p</italic></sub>(<italic>c</italic>)&gt; 0, then the constraints are not satisfied. These conditions are formalized in <xref ref-type="disp-formula" rid="eqn-27">(27)</xref>.</p>
      <p>
        <disp-formula id="eqn-27">
          <label>(27)</label>
          <alternatives>
            <graphic xlink:href="peerj-cs-07-588-e027.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
            <tex-math id="M37">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}{\delta _{{\beta _p}(c)}} = \left\{ {\matrix{ {0,}  {\quad if{\beta _p}(c) \le 0} \cr {1,}  {\quad if{\beta _p}(c) \gt 0} } } \right.\end{document}</tex-math>
            <mml:math id="mml-eqn-27">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>δ</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>β</mml:mi>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>c</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo>=</mml:mo>
              <mml:mrow>
                <mml:mo>{</mml:mo>
                <mml:mrow>
                  <mml:mtable columnspacing="1em" rowspacing="4pt">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mrow>
                          <mml:mn>0</mml:mn>
                          <mml:mo>,</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd>
                        <mml:mrow>
                          <mml:mspace width="1em"/>
                          <mml:mi>i</mml:mi>
                          <mml:mi>f</mml:mi>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>β</mml:mi>
                              <mml:mi>p</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>c</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>≤</mml:mo>
                          <mml:mn>0</mml:mn>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>,</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                      <mml:mtd>
                        <mml:mrow>
                          <mml:mspace width="1em"/>
                          <mml:mi>i</mml:mi>
                          <mml:mi>f</mml:mi>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>β</mml:mi>
                              <mml:mi>p</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>c</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>&gt;</mml:mo>
                          <mml:mn>0</mml:mn>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:mrow>
                <mml:mo stretchy="true" fence="true" symmetric="true"/>
              </mml:mrow>
            </mml:math>
          </alternatives>
        </disp-formula>
      </p>
      <p>Similarly, for the Γ set of constraints, if <italic>β</italic><sub><italic>γ</italic></sub>(<italic>c</italic>) = 0, then the constraints are satisfied. If <italic>β</italic><sub><italic>γ</italic></sub>(<italic>c</italic>) = 1, the constraints are not satisfied. For the ϒ constraints, the penalty distance from the satisfaction of ϒ constraints for <italic>c</italic> is defined in <xref ref-type="disp-formula" rid="eqn-28">(28)</xref>, where <italic>β</italic><sub><italic>υ</italic></sub> denotes a constraint, and <italic>δ</italic><sub>β<sub><italic>υ</italic></sub></sub>(<italic>c</italic>) indicates whether a constraint has been violated in the current chromosome <italic>c</italic>: <italic>δ</italic><sub>β<sub><italic>υ</italic></sub></sub>(<italic>c</italic>) = 1.</p>
      <p>
        <disp-formula id="eqn-28">
          <label>(28)</label>
          <alternatives>
            <graphic xlink:href="peerj-cs-07-588-e028.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
            <tex-math id="M38">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}D(c) = \sum\limits_{{\beta _\upsilon } \in \Upsilon } {\delta _{{\beta _\upsilon }(c)}}\end{document}</tex-math>
            <mml:math id="mml-eqn-28">
              <mml:mi>D</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo movablelimits="false">∑</mml:mo>
                <mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>β</mml:mi>
                      <mml:mi>υ</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="normal">Υ</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>δ</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>β</mml:mi>
                        <mml:mi>υ</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>c</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
            </mml:math>
          </alternatives>
        </disp-formula>
      </p>
      <p>The fitness function is calculated according to <xref ref-type="disp-formula" rid="eqn-29">(29)</xref>, where <italic>ω</italic><sub>β<sub><italic>p</italic>(<italic>c</italic>)</sub></sub> is the weight factor of <italic>β</italic><sub><italic>p</italic></sub> ∈ <italic>ψ</italic>, <italic>ω</italic><sub>β<sub><italic>p</italic>(<italic>c</italic>)</sub></sub> is the weight factor of <italic>β</italic><sub><italic>γ</italic></sub> ∈ Γ, and <italic>ω</italic><sub><italic>p</italic></sub> is the penalty weight factor for constraints in <italic>ϒ</italic>. If constraints <italic>β</italic><sub><italic>p</italic></sub> or <italic>β</italic><sub><italic>γ</italic></sub> are satisfied in <italic>c</italic>, then <italic>δ</italic><sub>β<sub><italic>p</italic>(<italic>c</italic>)</sub></sub> and <italic>δ</italic><sub>β<sub><italic>γ</italic>(<italic>c</italic>)</sub></sub> become 0, and the according values within the first and the second terms of <xref ref-type="disp-formula" rid="eqn-29">(29)</xref> are added to the fitness function. When the constraints are not satisfied, <italic>δ</italic><sub>β<sub><italic>p</italic>(<italic>c</italic>)</sub></sub> and <italic>δ</italic><sub>β<sub><italic>γ</italic>(<italic>c</italic>)</sub></sub> become 1, and the according values resulting from the first and second terms are subtracted from the fitness function. The third term in the fitness function ensures death penalty <italic>ω</italic><sub><italic>p</italic></sub><italic>D</italic>(<italic>c</italic>) for having <italic>D</italic>(<italic>c</italic>) other than 0, where the penalty factor <italic>ω</italic><sub><italic>p</italic></sub> has to be big enough to forbid participation of the worst chromosomes to perform crossover and to create the next generation of individuals. The weight values allow to change the impact of constraints on the fitness function. In this work, weights equal to 1, and the death penalty weight equals to 100,000. When the genetic algorithm is running, the fitness value of chromosomes increases. This happens because less penalties are applied to the chromosomes (<xref rid="ref-65" ref-type="bibr">Yeniay, 2005</xref>).</p>
      <p>
        <disp-formula id="eqn-29">
          <label>(29)</label>
          <alternatives>
            <graphic xlink:href="peerj-cs-07-588-e029.jpg" mimetype="image" mime-subtype="png" position="float" orientation="portrait"/>
            <tex-math id="M39">\documentclass[12pt]{minimal}
\usepackage{amsmath}
\usepackage{wasysym} 
\usepackage{amsfonts} 
\usepackage{amssymb} 
\usepackage{amsbsy}
\usepackage{upgreek}
\usepackage{mathrsfs}
\setlength{\oddsidemargin}{-69pt}
\begin{document}
}{}F(c) = \sum\limits_{{\beta _p} \in \Psi } {\omega _{{\beta _p}}}(1 - 2{\delta _{{\beta _p}(c)}}) + \sum\limits_{{\beta _\gamma } \in \Gamma } {\omega _{{\beta _\gamma }}}(1 - 2{\delta _{{\beta _\gamma }(c)}}) - {\omega _p}D(c)\end{document}</tex-math>
            <mml:math id="mml-eqn-29">
              <mml:mi>F</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:munder>
                <mml:mo movablelimits="false">∑</mml:mo>
                <mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>β</mml:mi>
                      <mml:mi>p</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="normal">Ψ</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>ω</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>β</mml:mi>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>δ</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>β</mml:mi>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>c</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>+</mml:mo>
              <mml:munder>
                <mml:mo movablelimits="false">∑</mml:mo>
                <mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>β</mml:mi>
                      <mml:mi>γ</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>∈</mml:mo>
                  <mml:mi mathvariant="normal">Γ</mml:mi>
                </mml:mrow>
              </mml:munder>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>ω</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>β</mml:mi>
                        <mml:mi>γ</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mn>1</mml:mn>
              <mml:mo>−</mml:mo>
              <mml:mn>2</mml:mn>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>δ</mml:mi>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>β</mml:mi>
                        <mml:mi>γ</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>c</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:msub>
              </mml:mrow>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>−</mml:mo>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>ω</mml:mi>
                  <mml:mi>p</mml:mi>
                </mml:msub>
              </mml:mrow>
              <mml:mi>D</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>c</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
            </mml:math>
          </alternatives>
        </disp-formula>
      </p>
      <p>The genetic operators were determined based on pre-experiments presented in (<xref rid="ref-50" ref-type="bibr">Skarlat et al., 2017a</xref>): We use a 80%-uniform crossover because the genes are integer values, a crossover mixing ratio of 0.5, tournament selection with the arity 2, random gene mutation with a 2% mutation rate, a 20% elitism rate, and a population size of 1,000 individuals.</p>
      <p>Regarding the stopping condition, different options exist. Obviously, the fitness value of the fittest individual in the generation has to be a positive number, since a positive fitness value means that there are no death penalties applied to the individual. Time-based stopping conditions of a number of iterations or execution time of the algorithm are not clear to define (<xref rid="ref-9" ref-type="bibr">Bhandari, Murthy &amp; Pal, 2012</xref>). A stopping condition based on improving the variance of fitness function over generations is identified as assuring the algorithm’s convergence.</p>
      <p>We use a tolerance value of the fitness function as the stopping condition of the algorithm. It is calculated by dividing the incremental variance of the fitness function values by the maximum fitness value over generations (<xref rid="ref-9" ref-type="bibr">Bhandari, Murthy &amp; Pal, 2012</xref>). The tolerance value of the fitness function is set to <italic>ε</italic> = 0.01, which is enough to obtain the solution and not to converge in local maxima.</p>
      <p>With either of the two service placement algorithms presented in “Greedy Algorithm” and “Genetic Algorithm” in place, we are now able to compute a service placement plan in fog nodes in FogFrame.</p>
    </sec>
  </sec>
  <sec sec-type="evaluation">
    <title>Evaluation</title>
    <p>In this section, we perform a testbed-based evaluation of FogFrame aiming to show (i) how deployment times of services differ at the edge and in the cloud, (ii) how the services are distributed in the fog landscape by the service placement algorithms according to different service request arrival patterns, and (iii) how much time is spent on producing a service placement plan.</p>
    <sec>
      <title>Implementation and experimental setup</title>
      <p>In our evaluation scenario, Raspberry Pi computers are used as fog devices (see <xref ref-type="fig" rid="fig-10">Fig. 10</xref>). Raspberry Pis are based on an ARM processor architecture, which is also used in mobile phones, smart phones, and digital television, to name just some examples. In general, nearly 60% of all mobile devices use ARM chips (<xref rid="ref-67" ref-type="bibr">Yi et al., 2016</xref>). Therefore, Raspberry Pis can be considered as representative when building a fog landscape (<xref rid="ref-30" ref-type="bibr">Isakovic et al., 2019</xref>). Fog nodes and fog cells are deployed on Raspberry Pi 3b+ units (Quadcore 64-bit ARM, 1 GB of RAM), which run with the Hypriot operating system. The detailed setup configuration of FogFrame is described in (<xref rid="ref-6" ref-type="bibr">Bachmann, 2017</xref>). The fog controller is deployed with a Docker container in an Ubuntu 18.04 LTS virtual machine with a 2-Core CPU, 4 GB RAM, which is running on a notebook with Intel Core i7-5600U CPU 2.6 GHz, and 8 GB RAM. The design of the fog controller allows to deploy it in the same manner as fog nodes and fog cells on Raspberry Pis. For public cloud resources, we use Amazon AWS EC2 services, specifically t2.micro VMs with the CoreOS operating system which has a Docker environment setup by default (see <xref ref-type="fig" rid="fig-11">Fig. 11</xref>).</p>
      <fig id="fig-10" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-10</object-id>
        <label>Figure 10</label>
        <caption>
          <title>Experimental setup.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g010"/>
      </fig>
      <fig id="fig-11" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-11</object-id>
        <label>Figure 11</label>
        <caption>
          <title>Deployment in the cloud.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g011"/>
      </fig>
      <p>The FogFrame framework is implemented by means of Java 8 in combination with the Spring Boot framework which provides a convenient persistence handling with Spring Data and Java Persistence API. The framework is available as open source software at Github (<uri xlink:href="https://github.com/softls/FogFrame-2.0">https://github.com/softls/FogFrame-2.0</uri>). Fog cells and fog nodes are by themselves services running inside their own Docker containers in a Docker runtime environment which is provided by the host operating system of Raspberry Pi units or cloud VMs. Therefore, during service deployment, a problem appears when trying to instantiate other Docker containers in the Docker runtime from inside the Docker containers of the running fog cells and fog nodes. To make it possible for fog cells and fog nodes to start and to stop further Docker containers on the host device, a Docker hook is implemented. The Docker hook provides a communication mechanism from inside the fog cell’s and fog node’s Docker containers into the Docker environment of the operating system of the Raspberry Pi.</p>
      <p>Fog nodes <italic>FN</italic><sub>1</sub> and <italic>FN</italic><sub>2</sub> are connected to the fog controller. The fog colony controlled and orchestrated by <italic>FN</italic><sub>1</sub> consists of two fog cells <italic>FC</italic><sub>1</sub> and <italic>FC</italic><sub>2</sub>, which are within the coverage area of <italic>FN</italic><sub>1</sub>. The fog colony controlled and orchestrated by <italic>FN</italic><sub>2</sub> has one connected fog cell <italic>FC</italic><sub>3</sub>. Temperature and humidity sensors are installed on the Raspberry Pis of corresponding fog cells by the means of GrovePi sensor boards (<uri xlink:href="https://www.dexterindustries.com/grovepi/">https://www.dexterindustries.com/grovepi/</uri>).</p>
      <p>Services of FogFrame intercommunicate via REST APIs. The communication within the testbed is done via a WLAN private network provided by a Linksys Smart WiFi 2.4GHz access point. This access point also acts as a gateway to connect every Raspberry Pi to the Internet. Every component needs to be connected to the Internet since the fog services require the ability to download Docker image data in order to create and deploy services. The private network in which our fog landscape operates is deemed to be secure, and all components of the fog landscape communicate via dedicated API endpoints on certain ports and IP addresses specified in the framework. It is a matter of future work to research other appropriate security mechanisms for fog computing (<xref rid="ref-55" ref-type="bibr">Tange et al., 2020</xref>).</p>
      <p>Regarding the virtualization technology, cloud resources are virtualized by the means of VMs. As discussed in “Introduction”, VMs are not a good choice for fog devices, so for them, we use Docker containers instead. The implemented service deployment and execution mechanisms for the cloud resources and fog colonies are different, since the hardware used in these environments differs. In order to use Docker containers in fog colonies, the base images of containers have to be compatible with the ARM processor architecture of Raspberry Pis, and accordingly in order to use Docker containers in cloud resources, the base images of those containers have to be compatible with the processor architecture of the cloud-based VMs.</p>
      <p>To store the images of the single services, we apply different independent storage solutions. Service images of services to be executed in the cloud are stored in an online repository Docker Hub (<uri xlink:href="https://hub.docker.com/">https://hub.docker.com/</uri>), which is accessible by cloud VMs. For service images of services to be executed in fog colonies, we implement a shared storage that contains the shared service registry (see “System Architecture”). Such distribution is necessary because in order to be executed on specific fog devices or in the cloud, each service image has to be compiled according to the processor architecture of that computational resource. In the case when services need to be executed in the cloud, they are downloaded via a link provided with a service request. This is necessary because we do not consider having a pre-configured pool of idle cloud resources with already stored service images. In the case when services need to be executed on fog devices, service images are sent to a fog node together with the initial application request. In fog colonies, applications (or more precisely: their services) are distributed between different fog devices, therefore every device needs access to the service images. This is ensured by the <italic>shared storage</italic> (see <xref ref-type="fig" rid="fig-12">Fig. 12</xref>). It has to be noted that there is no limitation on where to host a shared storage because direct IP communication is established in the framework.</p>
      <fig id="fig-12" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-12</object-id>
        <label>Figure 12</label>
        <caption>
          <title>Components of fog devices.</title>
        </caption>
        <graphic xlink:href="peerj-cs-07-588-g012"/>
      </fig>
      <p>In our experimental setup, each application consists of a number of services of certain service types, and is characterized by its makespan duration and a deadline on the deployment and execution time, as has been formally described in “Service Placement”. For that, we have defined and implemented three possible service types: Services of type <italic>t</italic><sub>1</sub> get data from temperature and humidity sensors and are executable only on fog cells because services of this type need sensor equipment; services of type <italic>t</italic><sub>2</sub> and <italic>t</italic><sub>3</sub> simulate processor load and are executable either on fog devices or in the cloud. We have also developed a dedicated service to be deployed and executed in the cloud which receives sensor readings and writes them to a cloud database.</p>
    </sec>
    <sec>
      <title>Metrics</title>
      <p>To assess how much time is spent on deployment in the cloud and at the edge of the network, we calculate the service deployment time. This metric is separately evaluated for the cloud and for fog colonies. The service deployment time in the cloud depends on whether there have already been free VMs running, or if a new VM has to be started. Furthermore, the deployment time depends on the availability of the required service image. In case no free VM is available, the service deployment time in the cloud equals the sum of the VM booting time, the time to pull the service image, and the startup time of the Docker container in that VM. If a free VM is available but the service image has to be pulled, the service deployment time in the cloud equals the sum of the time to pull the service image and the startup time of the Docker container, meaning a cold start of the container. When both a free VM and the required service image are available, the service deployment time in the cloud equals the startup time of the Docker container.</p>
      <p>The service deployment times in fog colonies differ from the ones in the cloud because in the fog colonies no VMs have to be started before deploying the service containers. If a service image is not available locally on the according fog device, the deployment time equals the sum of the time to pull the service image and the startup time of the Docker container. If a service image is available, the service deployment time equals the startup time of the Docker container.</p>
      <p>In order to show how services are distributed in the fog landscape by different service placement algorithms, we record the number of deployed services (containers) in each device in fog colonies and in the cloud. We also record the total deployment time of each scenario. Furthermore, we record the computational time of producing a service placement plan depending on the number of service requests.</p>
      <p>In order to show how services are recovered in the case of a failure or migrated in the case of device overload, we record average metrics of recovery time per service and time to migrate a service due to a device overload. We also record how fast the framework reacts to a new device appearing in the fog landscape and deploys services on it.</p>
      <p>In the area of cloud computing and accordingly in fog computing, experiments are prone to variations due to a multitude of factors, for example, hardware differences and network quality. Some of the factors cannot be mitigated, instead, a sufficient number of repetitions of experiments ensures that their results are not received due to a chance, but have a sound statistical confidence (<xref rid="ref-43" ref-type="bibr">Papadopoulos et al., 2019</xref>). In order to record the mentioned metrics and show the distribution of results, we execute each experiment ten times. Through ten repetitions per experiment it was noted that the results did not show large variations, and it is a reasonable figure for the number of repetitions.</p>
    </sec>
    <sec>
      <title>Experiments</title>
      <sec>
        <title>Assessment of deployment time</title>
        <p>In this experiment, we show how deployment times of services differ in the cloud and fog colonies. The application used for this scenario is a cloud-edge data processing application with an equal number of 15 service requests to be deployed in the cloud and on the fog devices. The makespan duration of the application is 1 min. The experiment is repeated ten times.</p>
      </sec>
      <sec>
        <title>Service placement with different arrival patterns</title>
        <p>In this experiment, we show how services are placed on different fog devices in time. For this experiment, we use applications with different numbers of service requests according to different service request arrival patterns: constant, pyramid and random walk (see <xref ref-type="fig" rid="fig-13">Fig. 13</xref>). Each application has a makespan duration of 1 min and a deadline on deployment and execution times of 3 min. The arrival patterns are shown along with the representative results of experiments. We evaluate the two service placement algorithms presented in “Service Placement”—the greedy algorithm and the genetic algorithm. One VM and one Docker container with the service to write sensor data into the cloud database are started before the experiment to receive sensor data. The experiment is repeated 10 times.</p>
        <fig id="fig-13" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-13</object-id>
          <label>Figure 13</label>
          <caption>
            <title>Results of experiments with different placement algorithms and arrival patterns.</title>
          </caption>
          <graphic xlink:href="peerj-cs-07-588-g013"/>
        </fig>
      </sec>
      <sec>
        <title>Computational time</title>
        <p>In this experiment, we submit applications with different numbers of service requests to fog node <italic>FN</italic><sub>1</sub>, and observe how much time is needed for the genetic algorithm to produce a service placement plan in each case. The experiment is repeated ten times for 5, 10, 15, 25, 50, 100, 200 and 400 services, in order to show how the genetic algorithm’s computational time increases if the number of services grows.</p>
        <p>Computational times are recorded only for the genetic algorithm because, as has been described in “Greedy Algorithm”, in the greedy algorithm the deployment happens immediately when appropriate edge devices are checked for placement, while in the genetic algorithm a service placement plan is generated, and only afterwards the services are deployed.</p>
      </sec>
      <sec>
        <title>Migration of services</title>
        <p>In this set of experiments, we implement a set of instructions and submit them to the fog colony with the head <italic>FN</italic><sub>1</sub>. As a first step, an application is submitted to the fog node, undergoes the service placement, and is deployed in the fog colony. Fog cell <italic>FC</italic><sub>1</sub> in the fog colony experiences a failure and loses its connection, which is simulated by executing a command of stopping the corresponding Docker container of the fog cell. This event triggers the device failure service to calculate a new service placement of all services that were deployed in the failed fog cell. Some services are redeployed on <italic>FC</italic><sub>2</sub> and some are delegated to the cloud. Afterwards, <italic>FC</italic><sub>1</sub> is restarted as a new fog cell <italic>FC</italic>′<sub>1</sub> to simulate device discovery in the fog colony. When the discovery service detects this new fog cell, it immediately triggers a new service placement to migrate all the services that are running in the cloud and some services from the devices in the fog colony loaded to the maximum capacity. The corresponding VM in the cloud becomes free of services and therefore is automatically stopped. In order to simulate overload of a fog device, we open several SSH connections to the fog cell <italic>FC</italic><sub>2</sub> each running resource-intensive tasks. The device overload service detects this event and migrates one by one randomly-chosen services from the fog cell to another resource in the fog colony (to fog cell <italic>FC</italic>′<sub>1</sub>) until the overload is eliminated. The experiment is repeated 10 times.</p>
      </sec>
    </sec>
    <sec sec-type="results|discussion">
      <title>Results and Discussion</title>
      <sec>
        <title>Assessment of deployment time</title>
        <p>In the application executed in this experiment (see “Assessment of Deployment Time”), there are 30 service requests. Out of these, 15 need to be deployed in the cloud, and 15 need to be deployed in the fog colonies. When services have to be deployed in the cloud, in addition to the high start-up times of VMs, VMs do not have previously stored or cached data, for example, previously used service images. Therefore, for the cloud VMs, Docker images need to be pulled every time. In contrast, fog devices download service images only once and then reuse them whenever needed as the images have been cached. As can be seen in <xref rid="table-2" ref-type="table">Table 2</xref>, there is a significant difference between the measured service deployment times at the edge and in the cloud. The average total deployment time at the edge is at about 29.76 s (<italic>σ</italic> = 4.08), whereas the average total deployment time in the cloud is 209.42 s (<italic>σ</italic> = 20.41). The Docker image pull times of the VMs have been also recorded in this experiment. It takes on average 32 s (<italic>σ</italic> = 0.01) to pull and start the docker container in the cloud (see <xref rid="table-2" ref-type="table">Table 2</xref>).</p>
        <table-wrap id="table-2" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.7717/peerj-cs.588/table-2</object-id>
          <label>Table 2</label>
          <caption>
            <title>Assessment of deployment time (in seconds).</title>
          </caption>
          <alternatives>
            <graphic xlink:href="peerj-cs-07-588-g018"/>
            <table frame="hsides" rules="groups" content-type="text">
              <colgroup span="1">
                <col span="1"/>
                <col span="1"/>
                <col span="1"/>
                <col span="1"/>
                <col span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <th rowspan="1" colspan="1"/>
                  <th rowspan="1" colspan="1">max</th>
                  <th rowspan="1" colspan="1">min</th>
                  <th rowspan="1" colspan="1">
                    <italic>μ</italic>
                  </th>
                  <th rowspan="1" colspan="1">
                    <italic>σ</italic>
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td rowspan="1" colspan="1">Total (edge)</td>
                  <td rowspan="1" colspan="1">41.78</td>
                  <td rowspan="1" colspan="1">27.22</td>
                  <td rowspan="1" colspan="1">29.76</td>
                  <td rowspan="1" colspan="1">4.08</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Per service (edge)</td>
                  <td rowspan="1" colspan="1">2.78</td>
                  <td rowspan="1" colspan="1">1.81</td>
                  <td rowspan="1" colspan="1">1.98</td>
                  <td rowspan="1" colspan="1">0.27</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Total (cloud)</td>
                  <td rowspan="1" colspan="1">251.03</td>
                  <td rowspan="1" colspan="1">180.75</td>
                  <td rowspan="1" colspan="1">209.42</td>
                  <td rowspan="1" colspan="1">20.41</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Per service (cloud)</td>
                  <td rowspan="1" colspan="1">16.74</td>
                  <td rowspan="1" colspan="1">12.05</td>
                  <td rowspan="1" colspan="1">13.96</td>
                  <td rowspan="1" colspan="1">1.36</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">VM startup</td>
                  <td rowspan="1" colspan="1">72</td>
                  <td rowspan="1" colspan="1">40</td>
                  <td rowspan="1" colspan="1">48</td>
                  <td rowspan="1" colspan="1">12</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Image pull (start)</td>
                  <td rowspan="1" colspan="1">33</td>
                  <td rowspan="1" colspan="1">32</td>
                  <td rowspan="1" colspan="1">32</td>
                  <td rowspan="1" colspan="1">0.01</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Total</td>
                  <td rowspan="1" colspan="1">278.94</td>
                  <td rowspan="1" colspan="1">210.42</td>
                  <td rowspan="1" colspan="1">239.18</td>
                  <td rowspan="1" colspan="1">18.77</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
        </table-wrap>
        <p>To summarize the outcome of this experiment, we compared the deployment times in the cloud and in fog colonies. The deployment time in the cloud is higher than the deployment times in the fog colonies because of additional latency, VM start-up time, and service image download time before instantiating according containers. In fog colonies, the shared service registry ensures caching of all available service images at the time fog devices enter the fog colony. In the already running VMs in the cloud all necessary service images are already cached and can be reused. However, each additional new VM in the cloud requires according instantiation time and service image download time and caching time. Having a pre-configured pool of idle cloud resources with cached service images in the same manner as the shared service registry in fog colonies would negate the whole concept of on-demand resources of the cloud. Therefore, cloud resources can be an on-demand addition to the fog landscape, but is not suited to be the only computational resource for latency-sensitive IoT applications.</p>
      </sec>
      <sec>
        <title>Service placement with different arrival patterns</title>
        <p>If applying the greedy algorithm presented in “Greedy Algorithm” and different arrival patterns (see <xref ref-type="fig" rid="fig-13">Fig. 13</xref>), services are placed on fog cells to the maximum capacity according to the available utilization parameters. If both fog cells in the first fog colony (see <xref ref-type="fig" rid="fig-10">Fig. 10</xref>) are loaded to the maximum capacity, and a new application request arrives with some services which need sensor equipment, the deployment in the own fog colony becomes impossible, and therefore such a request is delegated to the closest neighbor fog colony.</p>
        <p>In the genetic algorithm discussed in “Genetic Algorithm”, the requested applications are distributed in a more balanced way between fog colonies and the cloud. Fog devices are loaded less than to the maximum capacity. By delegating applications between the colonies and distributing single services on different fog devices, the genetic algorithm placement spreads the load on the resources in fog colonies more efficiently, which may be crucial if additional application requests are submitted and their services need specific equipment, for example, temperature and humidity sensors.</p>
        <p>In the pyramid and random walk arrival patterns, both algorithms perform almost alike due to the fact that even if the greedy algorithm loads one fog cell for all services in the application request, in most of the application requests the workload is less than the maximum capacity of the available fog devices. However, as can be seen in <xref ref-type="fig" rid="fig-13">Fig. 13</xref>, the load on fog devices is nevertheless more distributed if the genetic algorithm is used to compute a service placement plan.</p>
        <p>To summarize the results of this experiment, the genetic algorithm performs better with regard to distributing service requests within fog colonies. This makes it possible for newly requested applications to be placed on the necessary resources. While the greedy placement does not involve cloud resources, the genetic algorithm spreads the load between the fog colonies and the cloud. In the closest neighbor fog colony, the deployment time per service is longer as there is only one fog cell connected, the fog node’s resources also execute services, and services are deployed sequentially. One particular positive aspect in the genetic algorithm’s placement plan is that the resources in the fog landscape are not close to overload, which gives more opportunities for newly requested services to be deployed. The results of the experiment are summarized in <xref rid="table-3" ref-type="table">Table 3</xref>.</p>
        <table-wrap id="table-3" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.7717/peerj-cs.588/table-3</object-id>
          <label>Table 3</label>
          <caption>
            <title>Experiment results overview.</title>
          </caption>
          <alternatives>
            <graphic xlink:href="peerj-cs-07-588-g019"/>
            <table frame="hsides" rules="groups" content-type="text">
              <colgroup span="1">
                <col span="1"/>
                <col span="1"/>
                <col span="1"/>
                <col span="1"/>
                <col span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <th rowspan="1" colspan="1">Metrics</th>
                  <th rowspan="1" colspan="1">Algorithm</th>
                  <th rowspan="1" colspan="1">Constant</th>
                  <th rowspan="1" colspan="1">Pyramid</th>
                  <th rowspan="1" colspan="1">Random</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td rowspan="4" colspan="1">Deployment time per scenario (sec)</td>
                  <td rowspan="2" colspan="1">Greedy</td>
                  <td rowspan="1" colspan="1">694.10</td>
                  <td rowspan="1" colspan="1">643.50</td>
                  <td rowspan="1" colspan="1">663.67</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 70.92)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 9.54)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 19.99)</td>
                </tr>
                <tr>
                  <td rowspan="2" colspan="1">Genetic</td>
                  <td rowspan="1" colspan="1">684.00</td>
                  <td rowspan="1" colspan="1">644.88</td>
                  <td rowspan="1" colspan="1">654.90</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 16.34)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 9.00)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 7.06)</td>
                </tr>
                <tr>
                  <td rowspan="4" colspan="1">Service deployment time (sec)</td>
                  <td rowspan="2" colspan="1">Greedy</td>
                  <td rowspan="1" colspan="1">3.67</td>
                  <td rowspan="1" colspan="1">2.18</td>
                  <td rowspan="1" colspan="1">2.90</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 1.85)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.25)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 1.43)</td>
                </tr>
                <tr>
                  <td rowspan="2" colspan="1">Genetic</td>
                  <td rowspan="1" colspan="1">2.08</td>
                  <td rowspan="1" colspan="1">2.12</td>
                  <td rowspan="1" colspan="1">2.00</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.32)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.27)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.21)</td>
                </tr>
                <tr>
                  <td rowspan="4" colspan="1">Service deployment time in the neighbor fog colony (sec)</td>
                  <td rowspan="2" colspan="1">Greedy</td>
                  <td rowspan="1" colspan="1">2.52</td>
                  <td rowspan="1" colspan="1">2.50</td>
                  <td rowspan="1" colspan="1">2.98</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.60)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.24)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.30)</td>
                </tr>
                <tr>
                  <td rowspan="2" colspan="1">Genetic</td>
                  <td rowspan="1" colspan="1">2.12</td>
                  <td rowspan="1" colspan="1">2.23</td>
                  <td rowspan="1" colspan="1">2.38</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.13)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.27)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.56)</td>
                </tr>
                <tr>
                  <td rowspan="2" colspan="1">Service deployment time, cloud (sec)</td>
                  <td rowspan="2" colspan="1">Genetic</td>
                  <td rowspan="1" colspan="1">3.25</td>
                  <td rowspan="1" colspan="1">3.97</td>
                  <td rowspan="1" colspan="1">3.19</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.18)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.13)</td>
                  <td rowspan="1" colspan="1">(<italic>σ</italic> = 0.92)</td>
                </tr>
                <tr>
                  <td rowspan="2" colspan="1">Number of services delegated</td>
                  <td rowspan="1" colspan="1">Greedy</td>
                  <td rowspan="1" colspan="1">18 (<italic>σ</italic> = 4)</td>
                  <td rowspan="1" colspan="1">24 (<italic>σ</italic> = 4)</td>
                  <td rowspan="1" colspan="1">16 (<italic>σ</italic> = 6)</td>
                </tr>
                <tr>
                  <td rowspan="1" colspan="1">Genetic</td>
                  <td rowspan="1" colspan="1">24 (<italic>σ</italic> = 9)</td>
                  <td rowspan="1" colspan="1">22 (<italic>σ</italic> = 4)</td>
                  <td rowspan="1" colspan="1">13 (<italic>σ</italic> = 4)</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
        </table-wrap>
      </sec>
      <sec>
        <title>Computational time</title>
        <p>The measurements in this experiment show that the computational time of producing a service placement plan using the genetic algorithm is less than a second on average in all the cases below 50 service requests (see <xref ref-type="fig" rid="fig-14">Fig. 14</xref>). After that, an increase is observed, however, that increase is still within reasonable boundaries: a service placement plan for 200 and 400 service requests is produced on average in 2.26 s (<italic>σ</italic> = 0.16) and 3.64 s (<italic>σ</italic> = 0.19), respectively.</p>
        <fig id="fig-14" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-14</object-id>
          <label>Figure 14</label>
          <caption>
            <title>Computational time of producing a service placement plan by the genetic algorithm.</title>
          </caption>
          <graphic xlink:href="peerj-cs-07-588-g014"/>
        </fig>
        <p>The relatively small spread of whiskers and box sizes in <xref ref-type="fig" rid="fig-14">Fig. 14</xref> show that the computational time is rather stable for the specified number of services. The results mean that increasing considerably the number of services to be deployed affects the computational time, as the genetic algorithm calculates fitness values for each chromosome in each population as well as estimations to response times of applications and fog landscape resource utilization.</p>
      </sec>
      <sec>
        <title>Migration of services</title>
        <p>In this scenario, we consider four distinct events: (1) successful deployment and operation of an experimental application consisting of 15 services: Five services of each type <italic>t</italic><sub>1</sub>, <italic>t</italic><sub>2</sub> and <italic>t</italic><sub>3</sub>, (2) failure of <italic>FC</italic><sub>1</sub> and as a consequence recovery of all the services which were running on <italic>FC</italic><sub>1</sub> to <italic>FC</italic><sub>2</sub> and cloud, (3) discovery of the new fog cell <italic>FC</italic>′<sub>1</sub> and migration of services from the cloud and <italic>FC</italic><sub>2</sub> to <italic>FC</italic>′<sub>1</sub>, and (4) overload of <italic>FC</italic><sub>2</sub> and as a consequence migration of services from <italic>FC</italic><sub>2</sub> to other resources one by one until the overload is eliminated. The execution of the scenario is shown in <xref ref-type="fig" rid="fig-15">Fig. 15</xref>. During the execution, we recorded the average time-to-recover after failure per service, time-to-redeploy during the overload, and time of device discovery of how fast the device is detected in the fog colony and necessary services are migrated onto this device. The insights received from this experiment show that the main setback in the scenarios relying on the cloud is the could itself, namely as a result of request timeouts: connection timeout, request timeout, and read timeout. These parameters of requests to the cloud and the number of retries need to be fine-tuned according to the application needs. When such timeouts occur, the time for leasing and releasing of cloud resources can be affected. These problems have been mitigated in the fog controller’s cloud connector. The results of the execution are: After the failure of <italic>FC</italic><sub>1</sub>, all 10 services that were deployed there are successfully recovered in the cloud and in <italic>FC</italic><sub>2</sub>. The average total time-to-recover of 10 services is 23.652 s (<italic>σ</italic> = 1.49). The average of the time-to-recover per service after the failure is 2.35 s (<italic>σ</italic> = 0.14). The average discovery time of a new fog cell from the point of time it is detected by the discovery service until all necessary services are migrated is 18.79 s (<italic>σ</italic> = 2.78). The average time-to-redeploy a service after the device overload is 5.37 s (<italic>σ</italic> = 2.07).</p>
        <fig id="fig-15" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.7717/peerj-cs.588/fig-15</object-id>
          <label>Figure 15</label>
          <caption>
            <title>Deployment and migration of services to different resources due to the runtime events.</title>
          </caption>
          <graphic xlink:href="peerj-cs-07-588-g015"/>
        </fig>
      </sec>
    </sec>
    <sec>
      <title>Opportunities for future work</title>
      <p>While the conducted experiments have shown that FogFrame is able to serve its purpose to provide coordinated control for a fog landscape and to execute applications, there are nevertheless some limitations with regard to the evaluation and the framework itself.</p>
      <p>Currently, we do not consider delegating a single service from an application to a neighbor fog colony. This is done in order to avoid high intra-application latency and because of the necessary coordination between fog colonies on the level of service requests. It remains a matter of future work to identify approaches to perform service execution tracking in a complete fog landscape.</p>
      <p>In the evaluation, we implemented the types of services to be executable in the framework as described in “Implementation and Experimental Setup”. In reality, service types can be different depending on their purpose and necessary equipment. Nevertheless, the applied service types already show how different types can be deployed in the cloud and in the fog by applying FogFrame.</p>
      <p>A considerable limitation is that software to be executed on fog devices, meaning that both internal services of FogFrame and applications submitted by the users, have to be adapted or reimplemented according to the processor architecture of the according hardware, for example, according to the ARM processor architecture in a Raspberry Pi. For example, dynamic programming solvers which can be used in service placement, for example, IBM CPLEX solver, JAVA ILP, or Gurobi, do not provide library distributions runnable on the devices with the ARM processor architecture so far. This problem is not specific to our work, but is a common problem when using fog infrastructure.</p>
      <p>In this work, we have considered one fog landscape and communication and application execution within and between its fog colonies and the cloud. However, it is a promising research topic to investigate a meta control layer in the fog to allow not only communication between fog colonies, but also between multiple fog landscapes. This would allow optimization of the topologies of the fog landscapes with regard to proximity, efficiency, and volatility of fog resources.</p>
      <p>According to state-of-the-art surveys (<xref rid="ref-32" ref-type="bibr">Kashani, Ahmadzadeh &amp; Mahdipour, 2020</xref>; <xref rid="ref-3" ref-type="bibr">Afzal &amp; Kavitha, 2019</xref>), other methods for service placement and migration could be implemented to tackle the volatility of the fog landscape (<xref rid="ref-40" ref-type="bibr">Nair &amp; Somasundaram, 2019</xref>).</p>
      <p>Since fog computing is still a quite recent and developing research area, proper security mechanisms remain a challenge. In this particular work, the private network in which the fog landscape operates is deemed to be secure, and all components of the fog landscape communicate via dedicated API endpoints on certain ports and IP addresses specified in the framework. Additionally, ingress and egress rules can be set up on each device allowing only specific framework-related interactions. Other software and hardware security mechanisms for fog computing need to be further investigated (<xref rid="ref-55" ref-type="bibr">Tange et al., 2020</xref>).</p>
      <p>Another promising improvement is adopting the recent ETSI standard on context information management and NSGI-LD API metadata (<xref rid="ref-19" ref-type="bibr">ETSI GS CIM 009, 2019</xref>) within the implemented API of the FogFrame framework. This would allow to unambiguously use geographic location queries, temporal data, and linked data coming from different sources.</p>
    </sec>
  </sec>
  <sec sec-type="work">
    <title>Related Work</title>
    <p>To the best of our knowledge, already existing contributions in the area of fog computing are often evaluated by the means of simulators along with artificially generated data, since there is still a lack of research testbeds which could be used to evaluate different mechanisms in fog computing. Also, with regard to service placement, many existing approaches simply assume that a fog landscape is already available and can be used. Therefore, in this section, we focus on the works which provide concrete implementations of fog architectures. After that, we devote our attention to different service placement methods.</p>
    <sec>
      <title>Architectures</title>
      <p><xref rid="ref-7" ref-type="bibr">Battulga, Miorandi &amp; Tedeschi (2020)</xref> introduce the <italic>FogGuru</italic> platform for fog computing implemented via a real-world testbed. Their representative fog landscape is built out of five Raspberry Pis united in a cluster cloud tier. The cloud is utilized to host a static service to process sensor data. Their system utilizes a publish-subscribe mechanism to push sensor data through a stream processing system and further into the cloud tier. For orchestration purposes, Docker Swarm is used, and one of the five Raspberry Pi units is used as a Swarm Manager. Unlike our work, the work of Battulga et al. shows how to utilize a publish-subscribe mechanism in fog computing. Their testbed is static, unlike ours, where we explicitly tackle runtime operation events in the fog landscape and migrate necessary services when needed.</p>
      <p>In the work of <xref rid="ref-35" ref-type="bibr">Mahmud, Ramamohanarao &amp; Buyya (2019)</xref>, alongside with a simulated environment via iFogSim, the authors implement a small static testbed of eight smartphones as IoT devices and five standard computers that act together as a fog cluster of resources interconnected with LAN. This fog cluster operates within their framework called <italic>FogBus</italic>. Service placement is based on a time-optimized QoS-based policy and follows application deadlines. For this, a heuristic evolutionary algorithm to create a placement map of applications onto available resources in the fog cluster is applied. To address possible failures of resources within the fog cluster, in their work a replication mechanism is provided. Compared to their work, our proposed framework ensures cooperation between different fog colonies. The fog landscape automatically detects if devices appear or disappear from the fog landscape, and places, migrates, and optimizes services accordingly.</p>
      <p>Another Raspberry Pi-based testbed called <italic>piFogBed</italic> is presented by <xref rid="ref-63" ref-type="bibr">Xu &amp; Zhang (2019)</xref>. Their system has a coordinator deployed on a standard computer that contains user management functionality, a device allocator for service placement of user applications, a container manager to save service images to DockerHub, a network simulator and an application execution controller. Fog nodes are deployed on four Raspberry Pi units and execute applications. Service placement is implemented in a set of policies that ensure the utilization of closest fog nodes until their capacities reach a certain threshold and taking into account bandwidth and delay constraints. Their work is a good example of holistic and detailed experiments. Compared to the work of Xu and Zhang, we consider multiple fog colonies that utilize a decentralized service placement for application execution.</p>
      <p>An interesting combination of blockchain and fog computing technologies is proposed in the work of <xref rid="ref-14" ref-type="bibr">Cech, Großmann &amp; Krieger (2019)</xref>. Their decentralized architecture is based on MultiChain nodes embedded in more powerful fog cells and a P2P network. This P2P network overlay provides a distributed data store to share sensor data between resources in the fog landscape. The authors implemented a testbed with three Raspberry Pi units connected to a standard computer. Docker Swarm was used for orchestration of applications. Blockchain functionality is implemented by a Docker image of blockchain based on the MultiChain framework. In our work, we focus on the fog landscape itself, on how it is formed, how the communication is performed between different fog colonies, and how the volatility is tackled. The promising mechanism of Cech and Krieger could be applied for a distributed data store, as well as to enable tracking of application execution around the fog landscape.</p>
      <p><xref rid="ref-24" ref-type="bibr">He et al. (2018)</xref> propose a simulated fog computing model introducing static dedicated and volatile <italic>opportunistic</italic> fog landscapes as well as fog masters and fog workers as the main entities in fog landscapes resembling our fog nodes and fog cells. Similarly to our approach, the presented model enables multiple fog masters in one fog environment. In the pairing mechanism, He et al. consider invitations from fog workers in order to enter the fog landscape, while in our work fog cells and fog nodes perform self-announcement. Even though their system is simulated, He et al. provide very interesting insights on interactions within different fog environments.</p>
      <p><xref rid="ref-56" ref-type="bibr">Tsai et al. (2017)</xref> implement a distributed analytics platform based on Raspberry Pis using TensorFlow and Kubernetes. Their testbed consists of a centralized server and up to four fog devices connected by an Ethernet switch. The applications are split into small operators by TensorFlow, which is comparable to the way we assume applications to be composed out of services. Kubernetes controls and monitors the fog landscape, checks the available resources, and deploys Docker containers of operators on-demand. In contrast, in our work, we have developed an own distributed management system for the fog landscape which is not centralized like Kubernetes. Fog nodes are lightweight compared to Kubernetes, nevertheless they perform all necessary functionalities in own fog colonies, namely, monitoring, management and orchestration of own fog colonies.</p>
      <p><xref rid="ref-68" ref-type="bibr">Yigitoglu et al. (2017)</xref> introduce the fog computing framework <italic>Foggy</italic>. Comparable to FogFrame, the according testbed is implemented based on four Raspberry Pi units. Compared to our work, Yigitoglu et al. do not consider multiple fog colonies and a hierarchical fog landscape. Resource provisioning in their work is performed by an orchestration server, which runs on every node in the network, and implements a first fit provisioning method. In our work, we consider forming decentralized fog colonies and communication between them, and adjust service placement to account for the volatile nature of the fog landscape, for example, device discovery, failures and overloads.</p>
      <p>We provide a summary of the findings from the related fog computing architectures in <xref rid="table-4" ref-type="table">Table 4</xref>. This table provides the insights for each considered work of whether it is implemented or simulated, makes use of VMs and containers, is a centralized solution or distributed, accounts for the communication within the dedicated fog computing environment, and considers the communication between multiple fog landscapes.</p>
      <table-wrap id="table-4" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.7717/peerj-cs.588/table-4</object-id>
        <label>Table 4</label>
        <caption>
          <title>Overview of implementations of fog architectures.</title>
        </caption>
        <alternatives>
          <graphic xlink:href="peerj-cs-07-588-g020"/>
          <table frame="hsides" rules="groups" content-type="text">
            <colgroup span="1">
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
              <col span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Work</th>
                <th rowspan="1" colspan="1">Implemented</th>
                <th rowspan="1" colspan="1">VMs</th>
                <th rowspan="1" colspan="1">Containers</th>
                <th rowspan="1" colspan="1">Centralized reasoning</th>
                <th rowspan="1" colspan="1">Distributed reasoning</th>
                <th rowspan="1" colspan="1">Intra-fog communication</th>
                <th rowspan="1" colspan="1">Inter-fog communication</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-7" ref-type="bibr">Battulga, Miorandi &amp; Tedeschi (2020)</xref>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-35" ref-type="bibr">Mahmud, Ramamohanarao &amp; Buyya (2019)</xref>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-63" ref-type="bibr">Xu &amp; Zhang (2019)</xref>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-14" ref-type="bibr">Cech, Großmann &amp; Krieger (2019)</xref>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-24" ref-type="bibr">He et al. (2018)</xref>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-56" ref-type="bibr">Tsai et al. (2017)</xref>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">
                  <xref rid="ref-68" ref-type="bibr">Yigitoglu et al. (2017)</xref>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">FogFrame</td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1"/>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>✓</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
    <sec>
      <title>Service placement</title>
      <p>So far, we have discussed contributions to the management and communication in fog landscapes. In the following, we consider related work in the area of resource provisioning and service placement in the fog. Notably, literally hundreds of studies on service placement in the fog have been presented in recent years (<xref rid="ref-8" ref-type="bibr">Bellendorf &amp; Mann, 2020</xref>; <xref rid="ref-46" ref-type="bibr">Salaht, Desprez &amp; Lebre, 2020</xref>; <xref rid="ref-26" ref-type="bibr">Hong &amp; Varghese, 2019</xref>). An interesting systematic review has recently been presented by <xref rid="ref-32" ref-type="bibr">Kashani, Ahmadzadeh &amp; Mahdipour (2020)</xref>. It provides comprehensive descriptions, advantages and disadvantages of approximate, exact, fundamental, and hybrid methods of load balancing in fog computing. Most of the methods mentioned in the survey are simulated, and it is promising to implement the mentioned methods in a real-world fog computing environment. Also, some of the cloud computing resource provisioning methods can be adapted onto fog computing. In another recent survey by <xref rid="ref-3" ref-type="bibr">Afzal &amp; Kavitha (2019)</xref>, advantages and limitations of existing load balancing methods in cloud computing are considered. These methods can be implemented within the fog controller’s reasoning mechanisms to manage additional cloud resources for fog colonies. Because of the large number of existing approaches, we will focus on the content-wise closest work in the next paragraphs.</p>
      <p><xref rid="ref-12" ref-type="bibr">Brogi &amp; Forti (2017)</xref> introduce the <italic>FogTorch</italic> tool which aims to perform resource provisioning in fog landscapes. FogTorch accepts a fog landscape infrastructure and application specifications as inputs, and calculates a deployment model. The basis for the deployment is QoS-aware service placement. The placement approach preprocesses all input requests to search a map of available resources for each service in each request, backtracks the results of preprocessing to guarantee the deployment of all services, and applies a heuristic fail-first algorithm to ensure the deployment of those services having fewer compatible nodes and more demands in resources. In contrast, in our work, we implement FogFrame along with our own resource provisioning mechanisms, and apply it in a real-world Raspberry Pi testbed. The integration of FogFrame with FogTorch may become a good opportunity in the future to deal with the reoptimization of network topologies of fog landscapes.</p>
      <p><xref rid="ref-61" ref-type="bibr">Xiao &amp; Krunz (2017)</xref> consider an offloading problem in fog computing. Optimization is performed based on power consumption and Quality of Experience (QoE) parameters. Their approach is called <italic>offload forwarding</italic>. In contrast to our work, the authors use different criteria for optimization, namely, QoE and power consumption. This is an interesting approach, and our model may be extended to take into account power efficiency of the fog landscape and QoE inputs from users.</p>
      <p><xref rid="ref-42" ref-type="bibr">Ni et al. (2017)</xref> propose a resource allocation technique for fog computing which is based on Priced Timed Petri nets. In the application model used in their work, a fog application is orchestrated from single services. The time and price for execution of these services differ for each device. The resources for allocation are chosen by the users depending on the information received from the Petri net and their own demands. In our approach, users are not involved in the orchestration component, and the reasoning service reacts to application requests automatically.</p>
      <p><xref rid="ref-48" ref-type="bibr">Saurez et al. (2016)</xref> propose to allocate resources and migrate services in the fog based on two possible triggers: (i) meeting latency constraints and (ii) resolving resource pressure. In contrast, in our work, apart from latency and resource constraints, we take into account QoS parameters, namely, deadlines on deployment and execution of applications.</p>
      <p><xref rid="ref-41" ref-type="bibr">Nardelli et al. (2019)</xref> introduce several heuristic approaches to efficiently identify service placement considering the volatility of computing resources. They simulate different network topologies and sizes of fog infrastructure. In their work, several meta-heuristic algorithms are implemented: a greedy first fit, tabu search and local search algorithms. According to findings of Nardelli et al., the greedy first fit algorithm is the fastest, however with the worst quality, whereas the local search heuristics shows the best performance trade-off. In our work, we apply two heuristic algorithms – a greedy and a genetic algorithm, for service placement in a real-world fog landscape. We also introduce different placement mechanisms to account for device discovery, failures and overloads.</p>
      <p><xref rid="ref-39" ref-type="bibr">Mseddi et al. (2019)</xref> introduce service placement implemented by the means of particle-swarm optimization, a greedy algorithm, and an exact optimization. The goal of their placement is to maximize the number of executed applications adhering to their time constraints. According to their results, Mseddi et al. state that the particle-swarm optimization yields high resolution times and is not viable in fog computing environments. Their greedy algorithm aims to minimize the distance and delay between used fog resources taking into account their utilization. In contrast, our greedy algorithm aims to maximally utilize a fog colony adhering to QoS and capacities of available resources as well as to the types of services. In general, the service placement approach in our work differs from the work of Mseddi et al.: it considers multiple fog colonies and offloading of applications as well as contains separate policies to tackle operational events in a fog landscape.</p>
      <p>In the work of <xref rid="ref-2" ref-type="bibr">Abedi &amp; Pourkiani (2020)</xref>, the authors introduce a service placement algorithm based on an artificial neural network aimed to minimize response times of applications while distributing them in the fog landscape. Their approach is simulated with MATLAB, and therefore it is not clear how long it takes to produce such a neural network in the real world. It has to be noted, that this approach, as well as any other machine learning (ML) model, requires considerable volume of training data. This means that before any neural network can be created, other placement algorithms or service placement policies have to be used to historically record those placement decisions to receive a viable training dataset.</p>
      <p><xref rid="ref-38" ref-type="bibr">Mostafa, Ridhawi &amp; Aloqaily (2018)</xref> also implement an artificial neural network in a simulated environment to make placement predictions based on historical placement data. The algorithms in our work could provide a basis for training data and eventually be substituted by ML models. An interesting recent survey (<xref rid="ref-1" ref-type="bibr">Abdulkareem et al., 2019</xref>) discusses these problems and in general areas where ML can be applied in fog computing: ML for specific IoT service implementations and ML for decision making in resource provisioning.</p>
      <p>In general, the considered contributions differ from our work in terms of the system model for service placement in the fog landscape, parameters which are included in this model, and algorithms to provide a solution for this model.</p>
      <p>In our previous work (<xref rid="ref-52" ref-type="bibr">Skarlat et al., 2016</xref>; <xref rid="ref-50" ref-type="bibr">Skarlat et al., 2017a</xref>, <xref rid="ref-51" ref-type="bibr">Skarlat et al., 2017b</xref>), we model a conceptual fog landscape and an IoT application to be executed by the means of fog resources. Based on these preliminaries, we formulate the fog service placement problem, which aims to maximize the utilization of fog resources and the adherence to QoS parameters. We simulate a fog landscape by the means of <italic>CloudSim</italic> and <italic>iFogSim</italic> (<xref rid="ref-23" ref-type="bibr">Gupta et al., 2017</xref>) and solve the fog service placement problem by a first fit algorithm, a genetic algorithm, and an exact optimization method. In more recent work (<xref rid="ref-49" ref-type="bibr">Skarlat et al., 2018</xref>), a high-level overview of the architecture of FogFrame is presented.</p>
      <p>In contrast, in this paper, we provide the design details and the workflows in a fog landscape, eliminate the usage of simulators and implement a representative real-world Raspberry Pi-based testbed with the FogFrame framework. The framework (i) introduces mechanisms to create a fog landscape and account for its volatile nature, (ii) provides decentralized application execution in multiple fog colonies, (iii) discusses communication mechanisms between different fog colonies, (iv) introduces a service placement problem formulation to account for practical issues dealing with delegating and deployment of applications, (v) implements a greedy algorithm and a genetic algorithm to solve the service placement problem, and (vi) reacts to runtime events in the fog landscape and migrates necessary services to balance workload between resources. We extensively evaluate the framework with regard to deployment times of services and utilization of resources.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusion</title>
    <p>In this work, we have designed and developed the fog computing framework FogFrame. The foundation for the framework are lightweight container technologies and loosely-coupled components to provide a stable and fault-tolerant distributed system. In the course of the implementation, we identified and resolved technical issues of how to create a real-world fog landscape based on Raspberry Pi units, which are considered as representative devices for fog computing. We investigated how to instantiate containers in different computing environments and how to store images of services and share those images within the available infrastructure. A considerable part of this work has been devoted to the problem of how to effectively distribute services in a fog landscape. Therefore, we formalized a system model, and implemented a genetic algorithm as well as a greedy algorithm for service placement.</p>
    <p>Experiments were conducted to assess deployment times of applications, behavior of service placement algorithms with different arrival patterns of service requests, and computational time depending on the workload to be processed. The genetic algorithm placement distributes services in a balanced way, while the greedy algorithm loads each of the fog devices with the maximum available resource capacity. If there are no sufficient resources in the current fog colony, applications are delegated to the closest neighbor fog colony. The computational time of the genetic algorithm is stable for the specified number of services, however with the considerably increasing number of services to be deployed, the genetic algorithm performs accordingly more computational operations to evaluate each possible solution. Services are successfully recovered and redeployed when fog cells fail or experience overload. Device discovery ensures efficient balancing and horizontal scalability in the fog landscape as well as allows to release cloud resources and other fog cells, which may be intensively used in the fog colony, by migrating necessary services onto discovered devices.</p>
    <p>In this paper, we instantiate and work with one arbitrary fog landscape. However, it is a promising research topic to investigate a meta control layer to allow not only communication between fog colonies, but also between multiple fog landscapes. In future work, various components of FogFrame can be substituted or extended, for example, the resource provisioning and service placement methods, or pairing methods. FogFrame has intentionally been designed and implemented in a loosely-coupled manner in order to allow for this. A particular issue to address in the future work is how to scan and reconfigure the fog landscape structure based on different runtime events: device discovery, overloads, and failures. When devices appear and disappear in the fog landscape, the resulting network constellation may become not optimal in terms of latency, bandwidth, network hops, location mapping, and connection preservation. Therefore, optimizing fog landscape topologies is another research challenge. For this, different resource provisioning methods can be developed and integrated into FogFrame. The framework is publicly available (<uri xlink:href="https://github.com/softls/FogFrame-2.0">https://github.com/softls/FogFrame-2.0</uri>), and is provided to the research community for further extensions and experiments.</p>
  </sec>
</body>
<back>
  <sec sec-type="additional-information">
    <title>Additional Information and Declarations</title>
    <fn-group content-type="competing-interests">
      <title>Competing Interests</title>
      <fn fn-type="COI-statement" id="conflict-1">
        <p>Stefan Schulte is an Academic Editor for PeerJ.</p>
      </fn>
    </fn-group>
    <fn-group content-type="author-contributions">
      <title>Author Contributions</title>
      <fn fn-type="con" id="contribution-1">
        <p><xref ref-type="contrib" rid="author-1">Olena Skarlat</xref> conceived and designed the experiments, performed the experiments, analyzed the data, performed the computation work, prepared figures and/or tables, authored or reviewed drafts of the paper, and approved the final draft.</p>
      </fn>
      <fn fn-type="con" id="contribution-2">
        <p><xref ref-type="contrib" rid="author-2">Stefan Schulte</xref> conceived and designed the experiments, authored or reviewed drafts of the paper, and approved the final draft.</p>
      </fn>
    </fn-group>
    <fn-group content-type="other">
      <title>Data Availability</title>
      <fn id="addinfo-1">
        <p>The following information was supplied regarding data availability:</p>
        <p>The code and configuration files are available at GitHub: <uri xlink:href="https://github.com/softls/FogFrame-2.0">https://github.com/softls/FogFrame-2.0</uri>.</p>
      </fn>
    </fn-group>
  </sec>
  <ref-list content-type="authoryear">
    <title>References</title>
    <ref id="ref-1">
      <label>Abdulkareem et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abdulkareem</surname>
            <given-names>KH</given-names>
          </name>
          <name>
            <surname>Mohammed</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Gunasekaran</surname>
            <given-names>SS</given-names>
          </name>
          <name>
            <surname>Al-Mhiqani</surname>
            <given-names>MN</given-names>
          </name>
          <name>
            <surname>Mutlag</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Mostafa</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Ali</surname>
            <given-names>NS</given-names>
          </name>
          <name>
            <surname>Ibrahim</surname>
            <given-names>DA</given-names>
          </name>
        </person-group>
        <article-title>A review of fog computing and machine learning: concepts, applications, challenges, and open issues</article-title>
        <source>IEEE Access Journal</source>
        <year>2019</year>
        <volume>7</volume>
        <fpage>153123</fpage>
        <lpage>153140</lpage>
        <pub-id pub-id-type="doi">10.1109/ACCESS.2019.2947542</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-2">
      <label>Abedi &amp; Pourkiani (2020)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Abedi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pourkiani</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Resource allocation in combined fog-cloud scenarios by using artificial intelligence</article-title>
        <year>2020</year>
        <conf-name>5th IEEE International Conference on Fog and Mobile Edge Computing (FMEC’20)</conf-name>
        <publisher-loc>Paris, France</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>218</fpage>
        <lpage>222</lpage>
      </element-citation>
    </ref>
    <ref id="ref-3">
      <label>Afzal &amp; Kavitha (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Afzal</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kavitha</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Load balancing in cloud computing: a hierarchical taxonomical classification</article-title>
        <source>Journal of Cloud Computing</source>
        <year>2019</year>
        <volume>8</volume>
        <issue>22</issue>
        <fpage>1</fpage>
        <lpage>24</lpage>
        <pub-id pub-id-type="doi">10.1186/s13677-019-0146-7</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-4">
      <label>Amarante et al. (2013)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Amarante</surname>
            <given-names>SRM</given-names>
          </name>
          <name>
            <surname>Roberto</surname>
            <given-names>FM</given-names>
          </name>
          <name>
            <surname>Cardoso</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Celestino</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Using the multiple knapsack problem to model the problem of virtual machine allocation in cloud computing</article-title>
        <year>2013</year>
        <conf-name>16th IEEE International Conference on Computational Science and Engineering (CSE’13)</conf-name>
        <publisher-loc>Syndey, Australia</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>476</fpage>
        <lpage>483</lpage>
      </element-citation>
    </ref>
    <ref id="ref-5">
      <label>Arunarani, Manjula &amp; Sugumaran (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Arunarani</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Manjula</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Sugumaran</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>Task scheduling techniques in cloud computing: A literature survey</article-title>
        <source>Future Generation Computer Systems</source>
        <year>2019</year>
        <volume>91</volume>
        <issue>4</issue>
        <fpage>407</fpage>
        <lpage>415</lpage>
        <pub-id pub-id-type="doi">10.1016/j.future.2018.09.014</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-6">
      <label>Bachmann (2017)</label>
      <element-citation publication-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Bachmann</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Design and implementation of a fog computing framework</article-title>
        <year>2017</year>
        <comment>TU Wien, Master thesis</comment>
        <uri xlink:href="http://www.infosys.tuwien.ac.at/staff/sschulte/paper/Bachmann_Master.pdf">http://www.infosys.tuwien.ac.at/staff/sschulte/paper/Bachmann_Master.pdf</uri>
      </element-citation>
    </ref>
    <ref id="ref-7">
      <label>Battulga, Miorandi &amp; Tedeschi (2020)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Battulga</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Miorandi</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tedeschi</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>FogGuru: a fog computing platform based on Apache Flink</article-title>
        <year>2020</year>
        <conf-name>23rd IEEE Conference on Innovation in Clouds, Internet and Networks and Workshops (ICIN’20)</conf-name>
        <publisher-loc>Paris, France</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>156</fpage>
        <lpage>158</lpage>
      </element-citation>
    </ref>
    <ref id="ref-8">
      <label>Bellendorf &amp; Mann (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bellendorf</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Mann</surname>
            <given-names>ZA</given-names>
          </name>
        </person-group>
        <article-title>Classification of optimization problems in fog computing</article-title>
        <source>Future Generation Computer Systems</source>
        <year>2020</year>
        <volume>107</volume>
        <issue>5</issue>
        <fpage>158</fpage>
        <lpage>176</lpage>
        <pub-id pub-id-type="doi">10.1016/j.future.2020.01.036</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-9">
      <label>Bhandari, Murthy &amp; Pal (2012)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bhandari</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Murthy</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pal</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Variance as a stopping criterion for genetic algorithms with elitist model</article-title>
        <source>Fundamenta Informaticae</source>
        <year>2012</year>
        <volume>120</volume>
        <issue>2</issue>
        <fpage>145</fpage>
        <lpage>164</lpage>
        <pub-id pub-id-type="doi">10.3233/FI-2012-754</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-10">
      <label>Bonomi et al. (2014)</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bonomi</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Milito</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Natarajan</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Bessis</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Dobre</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Fog computing: a platform for Internet of Things and analytics</article-title>
        <source>Big Data and Internet of Things: A Roadmap for Smart Environments—Studies in Computational Intelligence</source>
        <year>2014</year>
        <volume>546</volume>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>169</fpage>
        <lpage>186</lpage>
      </element-citation>
    </ref>
    <ref id="ref-11">
      <label>Botta et al. (2016)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Botta</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>De Donato</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Persico</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Pescape</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Integration of cloud computing and Internet of Things: a survey</article-title>
        <source>Future Generation Computer Systems</source>
        <year>2016</year>
        <volume>56</volume>
        <issue>7</issue>
        <fpage>684</fpage>
        <lpage>700</lpage>
        <pub-id pub-id-type="doi">10.1016/j.future.2015.09.021</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-12">
      <label>Brogi &amp; Forti (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brogi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Forti</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>QoS-aware deployment of IoT applications through the fog</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2017</year>
        <volume>4</volume>
        <issue>5</issue>
        <fpage>1185</fpage>
        <lpage>1192</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2017.2701408</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-13">
      <label>Catarinucci et al. (2015)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Catarinucci</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>De Donno</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Mainetti</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Palano</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Patrono</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Stefanizzi</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>Tarricone</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>An IoT-aware architecture for smart healthcare systems</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2015</year>
        <volume>2</volume>
        <issue>6</issue>
        <fpage>515</fpage>
        <lpage>526</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2015.2417684</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-14">
      <label>Cech, Großmann &amp; Krieger (2019)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Cech</surname>
            <given-names>HL</given-names>
          </name>
          <name>
            <surname>Großmann</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Krieger</surname>
            <given-names>UR</given-names>
          </name>
        </person-group>
        <article-title>A fog computing architecture to share sensor data by means of blockchain functionality</article-title>
        <year>2019</year>
        <conf-name>IEEE International Conference on Fog Computing (ICFC’19)</conf-name>
        <publisher-loc>Prague, Czech Republic</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>31</fpage>
        <lpage>40</lpage>
      </element-citation>
    </ref>
    <ref id="ref-15">
      <label>Celesti et al. (2016)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Celesti</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Mulfari</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Fazio</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Villari</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Puliafito</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Exploring container virtualization in IoT clouds</article-title>
        <year>2016</year>
        <conf-name>2th IEEE International Conference on Smart Computing (SMARTCOMP’16)</conf-name>
        <publisher-loc>Missouri</publisher-loc>
        <publisher-name>St.-Louis</publisher-name>
        <fpage>1</fpage>
        <lpage>6</lpage>
      </element-citation>
    </ref>
    <ref id="ref-16">
      <label>Compare, Baraldi &amp; Zio (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Compare</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Baraldi</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Zio</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Challenges to IoT-enabled predictive maintenance for industry 4.0</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2020</year>
        <volume>7</volume>
        <issue>5</issue>
        <fpage>4585</fpage>
        <lpage>4597</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2019.2957029</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-17">
      <label>Dastjerdi et al. (2016)</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Dastjerdi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Gupta</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Calheiros</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Ghosh</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Buyya</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fog computing: principles, architectures, and applications</article-title>
        <source>Internet of Things: Principles and Paradigms, Chapter 4</source>
        <year>2016</year>
        <publisher-loc>Burlington</publisher-loc>
        <publisher-name>Morgan Kaufmann</publisher-name>
        <fpage>61</fpage>
        <lpage>75</lpage>
        <uri xlink:href="https://arxiv.org/abs/1601.02752">https://arxiv.org/abs/1601.02752</uri>
      </element-citation>
    </ref>
    <ref id="ref-18">
      <label>Detti (2009)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Detti</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>A polynomial algorithm for the multiple knapsack problem with divisible item sizes</article-title>
        <source>Information Processing Letters</source>
        <year>2009</year>
        <volume>109</volume>
        <issue>11</issue>
        <fpage>582</fpage>
        <lpage>584</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ipl.2009.02.003</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-19">
      <label>ETSI GS CIM 009 (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>
            <institution>ETSI GS CIM 009</institution>
          </collab>
        </person-group>
        <article-title>ETSI GS CIM 009 V1.1.1—context information management (CIM); NGSI-LD API</article-title>
        <year>2019</year>
        <uri xlink:href="https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.01.01_60/gs_CIM009v010101p.pdf">https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.01.01_60/gs_CIM009v010101p.pdf</uri>
      </element-citation>
    </ref>
    <ref id="ref-20">
      <label>Froiz-Mí­sguez et al. (2018)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Froiz-Mí­sguez</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Fernández-Caramés</surname>
            <given-names>TM</given-names>
          </name>
          <name>
            <surname>Fraga-Lamas</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Castedo</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Design, implementation and practical evaluation of an iot home automation system for fog computing applications based on mqtt and zigbee-wifi sensor nodes</article-title>
        <source>IEEE Sensors Journal</source>
        <year>2018</year>
        <volume>18</volume>
        <issue>2660</issue>
        <fpage>1</fpage>
        <lpage>42</lpage>
        <pub-id pub-id-type="doi">10.1109/JSEN.2018.2870228</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-21">
      <label>Gharaibeh et al. (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gharaibeh</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Salahuddin</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Hussini</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Khreishah</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Khalil</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Guizani</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Al-Fuqaha</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Smart cities: a survey on data management, security, and enabling technologies</article-title>
        <source>IEEE Communications Surveys &amp; Tutorials</source>
        <year>2017</year>
        <volume>19</volume>
        <issue>4</issue>
        <fpage>2456</fpage>
        <lpage>2501</lpage>
        <pub-id pub-id-type="doi">10.1109/COMST.2017.2736886</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-22">
      <label>Giang et al. (2015)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Giang</surname>
            <given-names>NK</given-names>
          </name>
          <name>
            <surname>Blackstock</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lea</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Leung</surname>
            <given-names>VC</given-names>
          </name>
        </person-group>
        <article-title>Developing IoT applications in the fog: a distributed dataflow approach</article-title>
        <year>2015</year>
        <conf-name>5th IEEE International Conference on the Internet of Things (IoT’15)</conf-name>
        <publisher-loc>Seoul, Korea</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>155</fpage>
        <lpage>162</lpage>
      </element-citation>
    </ref>
    <ref id="ref-23">
      <label>Gupta et al. (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gupta</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Dastjerdi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ghosh</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Buyya</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>iFogSim: a toolkit for modeling and simulation of resource management techniques in the Internet of Things, edge and fog computing environments</article-title>
        <source>Software: Practice and Experience</source>
        <year>2017</year>
        <volume>47</volume>
        <issue>9</issue>
        <fpage>1275</fpage>
        <lpage>1296</lpage>
        <pub-id pub-id-type="doi">10.1002/spe.2509</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-24">
      <label>He et al. (2018)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>He</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wei</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Multitier fog computing with large-scale IoT data analytics for smart cities</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2018</year>
        <volume>5</volume>
        <issue>2</issue>
        <fpage>677</fpage>
        <lpage>686</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2017.2724845</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-25">
      <label>Hochreiner et al. (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hochreiner</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Voegler</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schulte</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dustdar</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Cost-efficient enactment of stream processing topologies</article-title>
        <source>PeerJ Computer Science</source>
        <year>2017</year>
        <volume>3</volume>
        <elocation-id>e141</elocation-id>
        <pub-id pub-id-type="doi">10.7717/peerj-cs.141</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-26">
      <label>Hong &amp; Varghese (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hong</surname>
            <given-names>C-H</given-names>
          </name>
          <name>
            <surname>Varghese</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Resource management in fog/edge computing: a survey on architectures, infrastructure, and algorithms</article-title>
        <source>ACM Computing Surveys</source>
        <year>2019</year>
        <volume>52</volume>
        <issue>5</issue>
        <fpage>1</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="doi">10.1145/3326066</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-27">
      <label>Hooker &amp; Osorio (1999)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hooker</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Osorio</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Mixed logical-linear programming</article-title>
        <source>Discrete Applied Mathematics</source>
        <year>1999</year>
        <volume>96-97</volume>
        <fpage>395</fpage>
        <lpage>442</lpage>
        <pub-id pub-id-type="doi">10.1016/S0166-218X(99)00100-6</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-28">
      <label>Hu et al. (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hu</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Dhelim</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ning</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Qiu</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Survey on Fog Computing: Architecture, Key Technologies, Applications and Open Issues</article-title>
        <source>Journal of Network and Computer Applications</source>
        <year>2017</year>
        <volume>98</volume>
        <issue>3</issue>
        <fpage>27</fpage>
        <lpage>42</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jnca.2017.09.002</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-29">
      <label>IEEE 1934 (2018)</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <collab>
            <institution>IEEE 1934</institution>
          </collab>
        </person-group>
        <source>
          <italic toggle="yes">IEEE 1934–2018—IEEE standard for adoption of OpenFog reference architecture for fog computing</italic>
        </source>
        <year>2018</year>
        <uri xlink:href="https://standards.ieee.org/standard/1934-2018.html">https://standards.ieee.org/standard/1934-2018.html</uri>
      </element-citation>
    </ref>
    <ref id="ref-30">
      <label>Isakovic et al. (2019)</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Isakovic</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Ratasich</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Hirsch</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Platzer</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wally</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Rausch</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Nickovic</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Krenn</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Kappel</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Dustdar</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Grosu</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Chamberlain</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Taha</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Törngren</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Cps/iot ecosystem: a platform for research and education</article-title>
        <source>Cyber Physical Systems: Model-Based Design—CyPhy 2018, WESE 2018—Lecture Notes in Computer Science</source>
        <year>2019</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>206</fpage>
        <lpage>213</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-030-23703-5_12</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-31">
      <label>Karagiannis &amp; Schulte (2021)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Karagiannis</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Schulte</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Comparison of alternative architectures in fog computing</article-title>
        <year>2021</year>
        <conf-name>4th IEEE International Conference on Fog and Edge Computing (ICFEC’20)</conf-name>
        <publisher-loc>Melbourne, Australia</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>19</fpage>
        <lpage>29</lpage>
      </element-citation>
    </ref>
    <ref id="ref-32">
      <label>Kashani, Ahmadzadeh &amp; Mahdipour (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kashani</surname>
            <given-names>MH</given-names>
          </name>
          <name>
            <surname>Ahmadzadeh</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Mahdipour</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Load balancing mechanisms in fog computing: a systematic review</article-title>
        <source>arXiv</source>
        <year>2020</year>
        <uri xlink:href="https://arxiv.org/abs/2011.14706">https://arxiv.org/abs/2011.14706</uri>
      </element-citation>
    </ref>
    <ref id="ref-33">
      <label>Katona &amp; Panfilov (2018)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Katona</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Panfilov</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Building predictive maintenance framework for smart environment application systems</article-title>
        <year>2018</year>
        <conf-name>29th International DAAAM Symposi Intelligent Manufacturing and Automation</conf-name>
        <volume>29</volume>
        <publisher-loc>Zadar, Croatia</publisher-loc>
        <publisher-name>DAAAM International</publisher-name>
        <fpage>460</fpage>
        <lpage>470</lpage>
      </element-citation>
    </ref>
    <ref id="ref-34">
      <label>Kougka &amp; Gounaris (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kougka</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Gounaris</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Optimization of data flow execution in a parallel environment</article-title>
        <source>Distributed and Parallel Databases Journal</source>
        <year>2019</year>
        <volume>37</volume>
        <issue>3</issue>
        <fpage>385</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="doi">10.1007/s10619-018-7243-3</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-35">
      <label>Mahmud, Ramamohanarao &amp; Buyya (2019)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Mahmud</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Ramamohanarao</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Buyya</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Edge affinity-based management of applications in fog computing environments</article-title>
        <year>2019</year>
        <conf-name>12th IEEE/ACM International Conference Utility and Cloud Computing (UCC’19)</conf-name>
        <publisher-loc>Auckland, New Zealand</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>61</fpage>
        <lpage>70</lpage>
      </element-citation>
    </ref>
    <ref id="ref-36">
      <label>Maurer, Brandic &amp; Sakellariou (2013)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Maurer</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Brandic</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Sakellariou</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Adaptive resource configuration for Cloud infrastructure management</article-title>
        <source>Future Generation Computer Systems</source>
        <year>2013</year>
        <volume>29</volume>
        <issue>2</issue>
        <fpage>472</fpage>
        <lpage>487</lpage>
        <pub-id pub-id-type="doi">10.1016/j.future.2012.07.004</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-37">
      <label>Morabito et al. (2018)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morabito</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Cozzolino</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Ding</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Beijar</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Ott</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Consolidate IoT edge computing with lightweight virtualization</article-title>
        <source>IEEE Network</source>
        <year>2018</year>
        <volume>32</volume>
        <issue>1</issue>
        <fpage>102</fpage>
        <lpage>111</lpage>
        <pub-id pub-id-type="doi">10.1109/MNET.2018.1700175</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-38">
      <label>Mostafa, Ridhawi &amp; Aloqaily (2018)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Mostafa</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Ridhawi</surname>
            <given-names>IA</given-names>
          </name>
          <name>
            <surname>Aloqaily</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Fog resource selection using historical executions</article-title>
        <year>2018</year>
        <conf-name>3rd IEEE International Conference on Fog and Mobile Edge Computing (FMEC’18)</conf-name>
        <publisher-loc>Barcelona, Spain</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>272</fpage>
        <lpage>276</lpage>
      </element-citation>
    </ref>
    <ref id="ref-39">
      <label>Mseddi et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mseddi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Jaafar</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Elbiaze</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Ajib</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Joint container placement and task provisioning in dynamic fog computing</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2019</year>
        <volume>6</volume>
        <issue>6</issue>
        <fpage>10028</fpage>
        <lpage>10040</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2019.2935056</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-40">
      <label>Nair &amp; Somasundaram (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nair</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Somasundaram</surname>
            <given-names>MSB</given-names>
          </name>
        </person-group>
        <article-title>Overload prediction and avoidance for maintaining optimal working condition in a fog node</article-title>
        <source>Computers &amp; Electrical Engineering</source>
        <year>2019</year>
        <volume>77</volume>
        <issue>1</issue>
        <fpage>147</fpage>
        <lpage>162</lpage>
        <pub-id pub-id-type="doi">10.1016/j.compeleceng.2019.05.011</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-41">
      <label>Nardelli et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nardelli</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Cardellini</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Grassi</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Presti</surname>
            <given-names>FL</given-names>
          </name>
        </person-group>
        <article-title>Efficient operator placement for distributed data stream processing applications</article-title>
        <source>IEEE Transactions on Parallel and Distributed Systems</source>
        <year>2019</year>
        <volume>30</volume>
        <issue>8</issue>
        <fpage>1753</fpage>
        <lpage>1767</lpage>
        <pub-id pub-id-type="doi">10.1109/TPDS.2019.2896115</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-42">
      <label>Ni et al. (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ni</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Yan</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Resource allocation strategy in fog computing based on priced timed petri nets</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2017</year>
        <volume>4</volume>
        <issue>5</issue>
        <fpage>1216</fpage>
        <lpage>1228</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2017.2709814</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-43">
      <label>Papadopoulos et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Papadopoulos</surname>
            <given-names>AV</given-names>
          </name>
          <name>
            <surname>Versluis</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Herbst</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Von Kistowski</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ali-eldin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Abad</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Amaral</surname>
            <given-names>JN</given-names>
          </name>
          <name>
            <surname>Tůma</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Iosup</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Methodological principles for reproducible performance evaluation in cloud computing</article-title>
        <comment>In: IEEE Transactions on Software Engineering</comment>
        <year>2019</year>
        <pub-id pub-id-type="doi">10.1109/TSE.2019.2927908</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-44">
      <label>Puliafito et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Puliafito</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Mingozzi</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Longo</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Puliafito</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rana</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>Fog computing for the Internet of Things: a survey</article-title>
        <source>ACM Transactions on Internet Technology</source>
        <year>2019</year>
        <volume>19</volume>
        <issue>2</issue>
        <fpage>18:1</fpage>
        <lpage>18:41</lpage>
        <pub-id pub-id-type="doi">10.1145/3301443</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-45">
      <label>Reddy et al. (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Reddy</surname>
            <given-names>KHK</given-names>
          </name>
          <name>
            <surname>Luhach</surname>
            <given-names>AK</given-names>
          </name>
          <name>
            <surname>Pradhan</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Dash</surname>
            <given-names>JK</given-names>
          </name>
          <name>
            <surname>Roy</surname>
            <given-names>DS</given-names>
          </name>
        </person-group>
        <article-title>A genetic algorithm for energy efficient fog layer resource management in context-aware smart cities</article-title>
        <source>Sustainable Cities and Society</source>
        <year>2020</year>
        <volume>63</volume>
        <fpage>102428</fpage>
        <pub-id pub-id-type="doi">10.1016/j.scs.2020.102428</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-46">
      <label>Salaht, Desprez &amp; Lebre (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salaht</surname>
            <given-names>FA</given-names>
          </name>
          <name>
            <surname>Desprez</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Lebre</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>An overview of service placement problem in fog and edge computing</article-title>
        <source>ACM Computing Surveys</source>
        <year>2020</year>
        <volume>53</volume>
        <issue>3</issue>
        <fpage>1</fpage>
        <lpage>35</lpage>
        <pub-id pub-id-type="doi">10.1145/3391196</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-47">
      <label>Santos et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Santos</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wauters</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Volckaert</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>De Turck</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Resource provisioning in fog computing: from theory to practice</article-title>
        <source>Sensors</source>
        <year>2019</year>
        <volume>19</volume>
        <issue>10</issue>
        <fpage>1</fpage>
        <lpage>25</lpage>
        <pub-id pub-id-type="doi">10.3390/s19102238</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-48">
      <label>Saurez et al. (2016)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Saurez</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Hong</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lillethun</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Ramachandran</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Ottenwaelder</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Incremental deployment and migration of geo-distributed situation awareness applications in the fog</article-title>
        <year>2016</year>
        <conf-name>10th ACM International Conference on Distributed and Event-based Systems (DEBS’16)</conf-name>
        <publisher-loc>Irvine, California</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>258</fpage>
        <lpage>269</lpage>
      </element-citation>
    </ref>
    <ref id="ref-49">
      <label>Skarlat et al. (2018)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Skarlat</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Karagiannis</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Rausch</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Bachmann</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Schulte</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>A framework for optimization, service placement, and runtime operation in the fog</article-title>
        <year>2018</year>
        <conf-name>11th IEEE/ACM Int. Conf. on Utility and Cloud Computing (UCC’18)</conf-name>
        <publisher-loc>Zurich, Switzerland</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>164</fpage>
        <lpage>173</lpage>
      </element-citation>
    </ref>
    <ref id="ref-50">
      <label>Skarlat et al. (2017a)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Skarlat</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Nardelli</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schulte</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Borkowski</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Leitner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Optimized IoT service placement in the fog</article-title>
        <source>Service Oriented Computing and Applications</source>
        <year>2017a</year>
        <volume>11</volume>
        <issue>4</issue>
        <fpage>1</fpage>
        <lpage>17</lpage>
        <pub-id pub-id-type="doi">10.1007/s11761-017-0219-8</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-51">
      <label>Skarlat et al. (2017b)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Skarlat</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Nardelli</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schulte</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dustdar</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Towards QoS-aware fog service placement</article-title>
        <year>2017b</year>
        <conf-name>1st IEEE International Conference on Fog and Edge Computing (ICFEC’17)</conf-name>
        <publisher-loc>Madrid, Spain</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>89</fpage>
        <lpage>96</lpage>
      </element-citation>
    </ref>
    <ref id="ref-52">
      <label>Skarlat et al. (2016)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Skarlat</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Schulte</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Borkowski</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Leitner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Resource provisioning for IoT services in the fog</article-title>
        <year>2016</year>
        <conf-name>9th IEEE International Conference on Service Oriented Computing and Applications (SOCA’16)</conf-name>
        <publisher-loc>Hong Kong, China</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>32</fpage>
        <lpage>39</lpage>
      </element-citation>
    </ref>
    <ref id="ref-53">
      <label>Smimite &amp; Afdel (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smimite</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Afdel</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Containers placement and migration on cloud system</article-title>
        <source>International Journal of Computer Applications</source>
        <year>2020</year>
        <volume>176</volume>
        <issue>35</issue>
        <fpage>9</fpage>
        <lpage>18</lpage>
        <uri xlink:href="https://arxiv.org/abs/2007.08695">https://arxiv.org/abs/2007.08695</uri>
      </element-citation>
    </ref>
    <ref id="ref-54">
      <label>Stojmenovic (2014)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Stojmenovic</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>Fog computing: a cloud to the ground support for smart things and machine-to-machine networks</article-title>
        <year>2014</year>
        <conf-name>Australasian Telecommunication Networks and Applications Conference (ATNAC’14)</conf-name>
        <publisher-loc>Melbourne, Australia</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>117</fpage>
        <lpage>122</lpage>
      </element-citation>
    </ref>
    <ref id="ref-55">
      <label>Tange et al. (2020)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tange</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>De Donno</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Fafoutis</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Dragoni</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>A systematic survey of industrial Internet of Things security: requirements and fog computing opportunities</article-title>
        <source>IEEE Communications Surveys &amp; Tutorials</source>
        <year>2020</year>
        <volume>22</volume>
        <issue>4</issue>
        <fpage>2489</fpage>
        <lpage>2520</lpage>
        <pub-id pub-id-type="doi">10.1109/COMST.2020.3011208</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-56">
      <label>Tsai et al. (2017)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Tsai</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Hong</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Cheng</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hsu</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Distributed analytics in fog computing platforms using Tensorflow and Kubernetes</article-title>
        <year>2017</year>
        <conf-name>19th Asia-Pacific Network Operations and Management Symposi (APNOMS’17)</conf-name>
        <publisher-loc>Seoul, Korea</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>145</fpage>
        <lpage>150</lpage>
      </element-citation>
    </ref>
    <ref id="ref-57">
      <label>Vaquero &amp; Rodero-Merino (2014)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vaquero</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Rodero-Merino</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Finding your way in the fog: towards a comprehensive definition of fog computing</article-title>
        <source>ACM SIGCOMM Computer Communication Review</source>
        <year>2014</year>
        <volume>44</volume>
        <issue>5</issue>
        <fpage>27</fpage>
        <lpage>32</lpage>
        <pub-id pub-id-type="doi">10.1145/2677046.2677052</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-58">
      <label>Varghese &amp; Buyya (2018)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Varghese</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Buyya</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Next generation cloud computing: new trends and research directions</article-title>
        <source>Future Generation Computer Systems</source>
        <year>2018</year>
        <volume>79</volume>
        <issue>6</issue>
        <fpage>849</fpage>
        <lpage>861</lpage>
        <pub-id pub-id-type="doi">10.1016/j.future.2017.09.020</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-59">
      <label>Varshney &amp; Simmhan (2017)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Varshney</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Simmhan</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Demystifying fog computing: characterizing architectures, applications and abstractions</article-title>
        <year>2017</year>
        <conf-name>1st IEEE International Conference on Fog and Edge Computing (ICFEC’17)</conf-name>
        <publisher-loc>Madrid, Spain</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>115</fpage>
        <lpage>124</lpage>
      </element-citation>
    </ref>
    <ref id="ref-60">
      <label>Whitley (1994)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Whitley</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>A genetic algorithm tutorial</article-title>
        <source>Statistics and Computing</source>
        <year>1994</year>
        <volume>4</volume>
        <issue>2</issue>
        <fpage>65</fpage>
        <lpage>85</lpage>
        <pub-id pub-id-type="doi">10.1007/BF00175354</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-61">
      <label>Xiao &amp; Krunz (2017)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Xiao</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Krunz</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>QoE and power efficiency tradeoff for fog computing networks with fog node cooperation</article-title>
        <year>2017</year>
        <conf-name>IEEE Conference on Computer Communications (INFOCOM’17)</conf-name>
        <publisher-loc>Atlanta, GA, USA</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>1</fpage>
        <lpage>9</lpage>
      </element-citation>
    </ref>
    <ref id="ref-62">
      <label>Xu, Tian &amp; Buyya (2017)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Xu</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tian</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Buyya</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>A survey on load balancing algorithms for virtual machines placement in cloud computing</article-title>
        <source>Concurrency and Computation: Practice and Experience</source>
        <year>2017</year>
        <volume>29</volume>
        <issue>12</issue>
        <fpage>1</fpage>
        <lpage>16</lpage>
        <pub-id pub-id-type="doi">10.1002/cpe.4123</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-63">
      <label>Xu &amp; Zhang (2019)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Xu</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>piFogBed: a fog computing testbed based on raspberry pi</article-title>
        <year>2019</year>
        <conf-name>38th IEEE International Performance Computing and Communications Conference (IPCCC’19)</conf-name>
        <publisher-loc>London, England</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>1</fpage>
        <lpage>8</lpage>
      </element-citation>
    </ref>
    <ref id="ref-64">
      <label>Ye, Zhou &amp; Bouguettaya (2011)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Ye</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Zhou</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Bouguettaya</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Genetic algorithm based QoS-aware service compositions in cloud computing</article-title>
        <year>2011</year>
        <conf-name>16th International Conference on Database Systems for Advanced Applications (DASFAA’11)</conf-name>
        <volume>6588</volume>
        <publisher-loc>Hong Kong, China</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>321</fpage>
        <lpage>334</lpage>
      </element-citation>
    </ref>
    <ref id="ref-65">
      <label>Yeniay (2005)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yeniay</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>Penalty function methods for constrained optimization with genetic algorithms</article-title>
        <source>Mathematical and Computational Applications</source>
        <year>2005</year>
        <volume>10</volume>
        <issue>1</issue>
        <fpage>45</fpage>
        <lpage>56</lpage>
        <pub-id pub-id-type="doi">10.3390/mca10010045</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-66">
      <label>Yi, Li &amp; Li (2015)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Yi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Q</given-names>
          </name>
        </person-group>
        <article-title>A survey of fog computing: concepts, applications and issues</article-title>
        <year>2015</year>
        <conf-name>16th ACM International Simposium on Mobile Ad Hoc Networking and Computing (MobiHoc’15)</conf-name>
        <publisher-loc>Hangzhou, China</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>37</fpage>
        <lpage>42</lpage>
      </element-citation>
    </ref>
    <ref id="ref-67">
      <label>Yi et al. (2016)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Yi</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Shi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Research and design of embedded microprocessor based on ARM architecture</article-title>
        <year>2016</year>
        <conf-name>13th International Conference on Wavelet Active Media Technology and Information Processing (ICCWAMTIP’16)</conf-name>
        <publisher-loc>Chengdu, China</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>463</fpage>
        <lpage>467</lpage>
      </element-citation>
    </ref>
    <ref id="ref-68">
      <label>Yigitoglu et al. (2017)</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Yigitoglu</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Mohamed</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Ludwig</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Foggy: a framework for continuous automated IoT application deployment in fog computing</article-title>
        <year>2017</year>
        <conf-name>IEEE International Conference on AI Mobile Services (AIMS’17)</conf-name>
        <publisher-loc>Honolulu, Hawaii, USA</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>38</fpage>
        <lpage>45</lpage>
      </element-citation>
    </ref>
    <ref id="ref-69">
      <label>Yoo (2009)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yoo</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Real-time task scheduling by multiobjective genetic algorithm</article-title>
        <source>Journal of Systems and Software</source>
        <year>2009</year>
        <volume>82</volume>
        <issue>4</issue>
        <fpage>619</fpage>
        <lpage>628</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jss.2008.08.039</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-70">
      <label>Yu, Buyya &amp; Ramamohanarao (2009)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Buyya</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Ramamohanarao</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Workflow scheduling algorithms for grid computing</article-title>
        <source>Studies in Computational Intelligence</source>
        <year>2009</year>
        <volume>146</volume>
        <fpage>173</fpage>
        <lpage>214</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-540-69277-5_7</pub-id>
      </element-citation>
    </ref>
    <ref id="ref-71">
      <label>Zhang et al. (2019)</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Haider</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>St-Hilaire</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Makaya</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Model and algorithms for the planning of fog computing networks</article-title>
        <source>IEEE Internet of Things Journal</source>
        <year>2019</year>
        <volume>6</volume>
        <issue>2</issue>
        <fpage>3873</fpage>
        <lpage>3884</lpage>
        <pub-id pub-id-type="doi">10.1109/JIOT.2019.2892940</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
