<?properties open_access?>
<?properties no_embargo?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title>Bioinformatics</journal-title>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1460-2059</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2682523</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btp236</article-id>
    <article-id pub-id-type="publisher-id">btp236</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CloudBurst: highly sensitive read mapping with MapReduce</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Schatz</surname>
          <given-names>Michael C.</given-names>
        </name>
        <xref ref-type="corresp" rid="COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff>Center for Bioinformatics and Computational Biology, University of Maryland, College Park MD 20742, USA</aff>
    <author-notes>
      <corresp id="COR1">*To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: Alfenso Valencia</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>1</day>
      <month>6</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>8</day>
      <month>4</month>
      <year>2009</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>8</day>
      <month>4</month>
      <year>2009</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
			<pub-date pub-type="epub"/>. -->
    <volume>25</volume>
    <issue>11</issue>
    <fpage>1363</fpage>
    <lpage>1369</lpage>
    <history>
      <date date-type="received">
        <day>25</day>
        <month>11</month>
        <year>2008</year>
      </date>
      <date date-type="rev-recd">
        <day>12</day>
        <month>3</month>
        <year>2009</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>4</month>
        <year>2009</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2009 The Author(s)</copyright-statement>
      <copyright-year>2009</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">
        <p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">http://creativecommons.org/licenses/by-nc/2.0/uk/</ext-link>) which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Next-generation DNA sequencing machines are generating an enormous amount of sequence data, placing unprecedented demands on traditional single-processor read-mapping algorithms. CloudBurst is a new parallel read-mapping algorithm optimized for mapping next-generation sequence data to the human genome and other reference genomes, for use in a variety of biological analyses including SNP discovery, genotyping and personal genomics. It is modeled after the short read-mapping program RMAP, and reports either all alignments or the unambiguous best alignment for each read with any number of mismatches or differences. This level of sensitivity could be prohibitively time consuming, but CloudBurst uses the open-source Hadoop implementation of MapReduce to parallelize execution using multiple compute nodes.</p>
      <p><bold>Results:</bold> CloudBurst's running time scales linearly with the number of reads mapped, and with near linear speedup as the number of processors increases. In a 24-processor core configuration, CloudBurst is up to 30 times faster than RMAP executing on a single core, while computing an identical set of alignments. Using a larger remote compute cloud with 96 cores, CloudBurst improved performance by &gt;100-fold, reducing the running time from hours to mere minutes for typical jobs involving mapping of millions of short reads to the human genome.</p>
      <p><bold>Availability:</bold> CloudBurst is available open-source as a model for parallelizing algorithms with MapReduce at <ext-link ext-link-type="uri" xlink:href="http://cloudburst-bio.sourceforge.net/">http://cloudburst-bio.sourceforge.net/</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>mschatz@umiacs.umd.edu</email>
      </p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>Next-generation high-throughput DNA sequencing technologies from 454 Life Sciences, Illumina, Applied Biosystems and others are changing the scale and scope of genomics. These machines sequence more DNA in a few days than a traditional Sanger sequencing machine could in an entire year, and at a significantly lower cost (Shaffer, <xref ref-type="bibr" rid="B15">2007</xref>). James Watson's genome was recently sequenced (Wheeler <italic>et al.</italic>, <xref ref-type="bibr" rid="B20">2008</xref>) using technology from 454 Life Sciences in just 2 months, whereas previous efforts to sequence the human genome required several years and hundreds of machines (Venter <italic>et al.</italic>, <xref ref-type="bibr" rid="B18">2001</xref>). If this trend continues, an individual will be able to have their DNA sequenced in only a few days and perhaps for as little as $1000.</p>
    <p>The data from the new machines consists of millions of short sequences of DNA (25–250 bp) called reads, collected randomly from the target genome. After sequencing, researchers often map the reads to a reference genome to find the locations where each read occurs, allowing for a small number of differences. This information can be used to catalog differences in one person's genome relative to a reference human genome, or compare the genomes of closely related species. For example, this approach was recently used to analyze the genomes of an African (Bentley <italic>et al.</italic>, <xref ref-type="bibr" rid="B3">2008</xref>) and an Asian (Wang <italic>et al.</italic>, <xref ref-type="bibr" rid="B19">2008</xref>) individual by mapping 4.0 and 3.3 billion 35 bp reads, respectively, to the reference human genome. These comparisons are used for a wide variety of biological analyses including SNP discovery, genotyping, gene expression, comparative genomics and personal genomics. Even a single base pair difference can have a significant biological impact, so researchers require highly sensitive mapping algorithms to analyze the reads. As such, researchers are generating sequence data at an incredible rate and need highly scalable algorithms to analyze their data.</p>
    <p>Many of the currently used read-mapping programs, including BLAST (Altschul <italic>et al.</italic>, <xref ref-type="bibr" rid="B1">1990</xref>), SOAP (Li <italic>et al.</italic>, <xref ref-type="bibr" rid="B12">2008b</xref>), MAQ (Li, <italic>et al.</italic>, <xref ref-type="bibr" rid="B11">2008a</xref>), RMAP (Smith <italic>et al.</italic>, <xref ref-type="bibr" rid="B17">2008</xref>) and ZOOM (Lin <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008</xref>), use an algorithmic technique called <italic>seed-and-extend</italic> to accelerate the mapping process. These programs first find sub-strings called seeds that exactly match in both the reads and the reference sequences, and then extend the shared seeds into longer, inexact alignments using a more sensitive algorithm that allows for mismatches or gaps. These programs use a variety of methods for finding and extending the seeds, and have different features and performance. However, each of these programs is designed for execution on a single computing node, and as such requires a long running time or limits the sensitivity of the alignments they find.</p>
    <p><italic>CloudBurst</italic> is a new highly sensitive parallel seed-and-extend read-mapping algorithm optimized for mapping single-end next generation sequence data to reference genomes. It reports all alignments for each read with up to a user-specified number of differences including both mismatches and indels. <italic>CloudBurst</italic> can optionally filter the alignments to report the single best non-ambiguous alignment for each read, and produce output identical to RMAPM (RMAP using mismatch scores). As such <italic>CloudBurst</italic> can replace RMAP in a data analysis pipeline without changing the results, but provides much greater performance by using the open-source implementation of the distributed programming framework <italic>MapReduce</italic> called <italic>Hadoop</italic> (<ext-link ext-link-type="uri" xlink:href="http://hadoop.apache.org">http://hadoop.apache.org</ext-link>). The results presented below show that <italic>CloudBurst</italic> is highly scalable: the running times scale linearly as the number of reads increases, and with near linear speed improvements over a serial execution of RMAP for sensitive searches. Furthermore, <italic>CloudBurst</italic> can scale to run on large remote compute clouds, and thus map virtually any number of reads with high sensitivity in relatively little time.</p>
    <sec id="SEC1.1">
      <title>1.1 MapReduce and Hadoop</title>
      <p><italic>MapReduce</italic> (Dean <italic>et al.</italic>, <xref ref-type="bibr" rid="B6">2008</xref>) is the software framework developed and used by Google™ to support parallel distributed execution of their data intensive applications. Google uses this framework internally to execute thousands of <italic>MapReduce</italic> applications per day, processing petabytes of data, all on commodity hardware. Unlike other parallel computing frameworks, which require application developers explicitly manage inter-process communication, computation in <italic>MapReduce</italic> is divided into two major phases called <italic>map</italic> and <italic>reduce</italic>, separated by an internal <italic>shuffle</italic> phase of the intermediate results (<xref ref-type="fig" rid="F1">Fig. 1</xref>), and the framework automatically executes those functions in parallel over any number of processors.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>Schematic overview of MapReduce. The input file(s) are automatically partitioned into chunks depending on their size and the desired number of mappers. Each mapper (shown here as <italic>m</italic><sub>1</sub> and <italic>m</italic><sub>2</sub>) executes a user-defined function on a chunk of the input and emits key–value pairs. The shuffle phase creates a list of values associated with each key (shown here as <italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub> and <italic>k</italic><sub><italic>n</italic></sub>). The reducers (shown here as <italic>r</italic><sub>1</sub> and <italic>r</italic><sub>2</sub>) evaluate a user-defined function for their subset of the keys and associated list of values, to create the set of output files.</p></caption><graphic xlink:href="btp236f1"/></fig>
</p>
      <p>The <italic>map</italic> function computes key–value pairs from the input data, based on any relationship applicable to the problem, including computing multiple pairs from a single input. For example, the map function of a program that counts the number of occurrences of all length k substrings (k-mers) in a set of DNA sequences could emit the key–value pair (<italic>k-mer</italic>, 1) for each k-mer. If the input is large, many instances of the map function can execute in parallel on different portions of the input and divide the running time by the number of processors available. Once the mappers are complete, <italic>MapReduce</italic> shuffles the pairs so all values with the same key are grouped together into a single list. The grouping of key–value pairs effectively creates a large distributed hash table indexed by the key, with a list of values for each key. In the k-mer counter example, the framework creates a list of 1s for each k-mer in the input, corresponding to each instance of that k-mer. The reduce function evaluates a user-defined function on each key–value list. The reduce function can be arbitrarily complex, but must be commutative, since the order of elements in the key–value list is unstable. In the k-mer counting example, the reduce function is called once for each k-mer with its associated list of 1s, and simply adds the 1s together to compute the total number of occurrences for that k-mer. Each instance of the reduce function executes independently, so there can be as many reduce functions executing in parallel as there are distinct keys, i.e. k-mers in the input.</p>
      <p>As an optimization, <italic>MapReduce</italic> allows reduce-like functions called <italic>combiners</italic> to execute in-memory immediately after the <italic>map</italic> function. <italic>Combiners</italic> are not possible in every application because they evaluate on a subset of the values for a given key, but when possible, reduce the amount of data processed in the shuffle and reduce phases. In the k-mer counting example, the <italic>combiner</italic> emits a partial sum from the subset of 1s it evaluates, and the <italic>reduce</italic> function sums over the list of partial sums.</p>
      <p>Computations in <italic>MapReduce</italic> are independent, so the wall clock running time should scale linearly with the number of processor cores available, i.e. a 10-core execution should take 1/10th the time of a 1-core execution creating a 10× speedup with complete parallel efficiency. In practice, perfect linear speedup is difficult to achieve because serial overhead limits the maximum speedup possible as described by Amdahl's law (Krishnaprasad, <xref ref-type="bibr" rid="B7">2001</xref>). For example, if an application has just 10% non-parallelizable overhead, then the maximum possible end-to-end speedup is only 10× regardless of the number of cores used. High speedup also requires the computation is evenly divided over all processors to maximize the benefit of parallel computation. Otherwise the wall clock running time will be limited to the time for the longest running task, and reduce overall efficiency. <italic>MapReduce</italic> tries to balance the workload by assigning each <italic>reducer</italic> ∼1/<italic>N</italic> of the total key space, where <italic>N</italic> is the number of cores. If certain keys require substantially more time than others, however, it may be necessary to rebalance the workload using a custom partition function or adjusting how keys are emitted.</p>
      <p><italic>MapReduce</italic> is designed for computations with extremely large datasets, far beyond what can be stored in RAM. Instead it uses files for storing and transferring intermediate results, including the inter-machine communication between <italic>map</italic> and <italic>reduce</italic> functions. This could become a severe bottleneck, so Google developed the robust distributed Google File System (GFS) (Ghemawat <italic>et al.</italic>, <xref ref-type="bibr" rid="B4">2003</xref>) to efficiently support <italic>MapReduce</italic>. GFS is designed to provide very high-bandwidth for <italic>MapReduce</italic> by replicating and partitioning files across many physical disks. Files in the GFS are automatically partitioned into large chunks (64 MB by default), which are replicated to several physical disks (three by default) attached to the compute nodes. Therefore, aggregate I/O performance can greatly exceed the performance of an individual memory storage device (e.g. a disk drive), and chunk redundancy ensures reliability even when used with commodity drives with relatively high-failure rates. <italic>MapReduce</italic> is also ‘data aware’: it attempts to schedule computation at a compute node that has the required data instead of moving the data across the network.</p>
      <p><italic>Hadoop</italic> and the <italic>Hadoop Distributed File System</italic> (<italic>HDFS</italic>) are open source versions of <italic>MapReduce</italic> and the GFS implemented in Java and sponsored by Amazon™, Yahoo™, Google, IBM™ and other major vendors. Like Google's proprietary <italic>MapReduce</italic> framework, applications developers need only write custom <italic>map</italic> and <italic>reduce</italic> functions, and the <italic>Hadoop</italic> framework automatically executes those functions in parallel. <italic>Hadoop</italic> and <italic>HDFS</italic> are used to manage production clusters with 10 000+nodes and petabytes of data, including computation supporting every Yahoo search result. A Hadoop cluster of 910 commodity machines recently set a performance record by sorting 1 TB of data (10 billion 100 bytes records) in 209 s (<ext-link ext-link-type="uri" xlink:href="http://www.hpl.hp.com/hosted/sortbenchmark/">http://www.hpl.hp.com/hosted/sortbenchmark/</ext-link>).</p>
      <p>In addition to in-house <italic>Hadoop</italic> usage, <italic>Hadoop</italic> is becoming a <italic>de facto</italic> standard for cloud computing where compute resources are accessed generically as a service, without regard for physical location or specific configuration. The generic nature of cloud computing allows resources to be purchased on-demand, especially to augment local resources for specific large or time-critical tasks. Several organizations offer cloud compute cycles that can be accessed via <italic>Hadoop</italic>. Amazon's Elastic Compute Cloud (EC2) (<ext-link ext-link-type="uri" xlink:href="http://aws.amazon.com">http://aws.amazon.com</ext-link>) contains tens of thousands of virtual machines, and supports <italic>Hadoop</italic> with minimal effort. In EC2, there are five different classes of virtual machines available providing different levels of CPU, RAM and disk resources with price ranging from $0.10 to $0.80 per hour per virtual machine. Amazon offers preconfigured disk images and launches scripts for initializing a <italic>Hadoop</italic> cluster, and once initialized, users copy data into the newly created HDFS and execute their jobs as if the cluster was dedicated for their use. For very large datasets, the time required for the initial data transfer can be substantial, and will depend on the bandwidth of the cloud provider. Once transferred into the cloud, though, the cloud nodes generally have very high-internode bandwidth. Furthermore, Amazon has begun mirroring portions of Ensembl and GenBank for use within EC2 without additional storage costs, thereby minimizing the time and cost to run a large-scale analysis of these data.</p>
    </sec>
    <sec id="SEC1.2">
      <title>1.2 Read mapping</title>
      <p>After sequencing DNA, researchers often map the reads to a reference genome to find the locations where each read occurs. The read-mapping algorithm reports one or more alignments for each read within a scoring threshold, commonly expressed as the minimal acceptable significance of the alignment, or the maximum acceptable number of differences between the read and the reference genome. The algorithms generally allow 1–10% of the read length to differ from the reference, although higher levels may be necessary when aligning to more distantly related genomes, or when aligning longer reads with higher error rates. Read-mapping algorithms can allow mismatch (mutation) errors only, or they can allow insertion or deletion (indel) errors, for both true genetic variations and artificial sequencing errors. The number of mismatches between a pair of sequences can be computed with a simple scan of the sequences, whereas computing the edit distance (allowing for indels) requires a more sophisticated algorithm such as the Smith–Waterman sequence alignment algorithm (Smith <italic>et al.</italic>, <xref ref-type="bibr" rid="B16">1981</xref>), whose runtime is proportional to the product of the sequence lengths. In either case, the computation for a single pair of short sequences is fast, but becomes costly as the number or size of sequences increases.</p>
      <p>When aligning millions of reads generated from a next-generation sequencing machine, read-mapping algorithms often use a technique called <italic>seed-and-extend</italic> to accelerate the search for highly similar alignments. This technique is based on the observation that there must be a significant exact match for an alignment to be within the scoring threshold. For example, for a 30 bp read to map to a reference with only one difference, there must be at least 15 consecutive bases, called a seed, that match exactly regardless of where the difference occurs. In general, a full-length end-to-end alignment of an <italic>m</italic> bp read with at most <italic>k</italic> differences must contain at least one exact alignment of <italic>m</italic>/(<italic>k</italic>+1) consecutive bases (Baeza-yates <italic>et al.</italic>, <xref ref-type="bibr" rid="B2">1992</xref>). Similar arguments can be made when designing spaced seeds of non-consecutive bases to guarantee finding all alignments with up to a certain numbers of errors (Lin <italic>et al.</italic>, <xref ref-type="bibr" rid="B13">2008</xref>). Spaced seeds have the advantage of allowing longer seeds at the same level of sensitivity, although multiple spaced seeds may be needed to reach full sensitivity.</p>
      <p>In all <italic>seed-and-extend</italic> algorithms, regions that do not contain any matching seeds are filtered without further examination, since those regions are guaranteed to not contain any high-quality alignments. For example, BLAST uses a hash table of all fixed length k-mers in the reference to find seeds, and a banded version of the Smith–Waterman algorithm to compute high-scoring gapped alignments. RMAP uses a hash table of non-overlapping k-mers of length <italic>m</italic>/(<italic>k</italic>+1) in the reads to find seeds, while SOAP, MAQ and ZOOM use spaced seeds. In the extension phase, RMAP, MAQ, SOAP and ZOOM align the reads to allow up to a fixed number of mismatches, and SOAP can alternatively allow for one continuous gap. Other approaches to mapping include using suffix trees (Kurtz <italic>et al.</italic>, <xref ref-type="bibr" rid="B8">2004</xref>; Schatz <italic>et al.</italic>, <xref ref-type="bibr" rid="B14">2007</xref>) to quickly find short exact alignments to seed longer inexact alignments, and Bowtie (Langmead <italic>et al.</italic>, <xref ref-type="bibr" rid="B10">2009</xref>) uses the Burrows–Wheeler transform (BWT), to find exact matches coupled with a backtracking algorithm to allow for mismatches. Some BWT-based aligners are reporting extremely fast runtimes, especially in configurations that restrict the sensitivity of the alignments or limit the number of alignments reported per read. For example, in their default high-speed configuration, SOAP2 (<ext-link ext-link-type="uri" xlink:href="http://soap.genomics.org.cn/">http://soap.genomics.org.cn/</ext-link>), BWA (<ext-link ext-link-type="uri" xlink:href="http://maq.sourceforge.net">http://maq.sourceforge.net</ext-link>) and Bowtie allow at most two differences in the beginning of the read, and report a single alignment per read selected randomly from the set of acceptable alignments. In more sensitive or verbose configurations, the programs can be considerably slower (<ext-link ext-link-type="uri" xlink:href="http://bowtie-bio.sourceforge.net/manual.shtml">http://bowtie-bio.sourceforge.net/manual.shtml</ext-link>).</p>
      <p>After computing end-to-end alignments, some of these programs use the edit distance or read quality values to score the mappings. In a systematic study allowing up to 10 mismatches, Smith <italic>et al.</italic> (<xref ref-type="bibr" rid="B17">2008</xref>) determined allowing more than two mismatches is necessary for accurately mapping longer reads, and incorporating quality values also improves accuracy. Several of these programs, including RMAPQ (RMAP with quality), MAQ, ZOOM and Bowtie, use quality values in their scoring algorithm, and all are more lenient of errors in the low-quality 3' ends of the reads by trimming the reads or discounting low-quality errors.</p>
      <p>Consecutive or spaced seeds dramatically accelerate the computation by focusing computation to regions with potential to have a high-quality alignment. However, to increase sensitivity the length of the seeds must decrease (consecutive seeds) or the number of seeds used must increase (spaced seeds). In either case, increasing sensitivity increases the number of randomly matching seeds and increases the total execution time. Decreasing the seed length can be especially problematic because a seed of length <italic>s</italic> is expected to occur ∼ <italic>L</italic>/4<sup><italic>s</italic></sup> times in a reference of length <italic>L</italic>, and each occurrence must be evaluated using the slower inexact alignment algorithm. Therefore, many of the new short read mappers restrict the maximum number of differences allowed, or limit the number of alignments reported for each read.</p>
    </sec>
  </sec>
  <sec id="SEC2">
    <title>2 ALGORITHM</title>
    <p><italic>CloudBurst</italic> is a <italic>MapReduce</italic>-based read-mapping algorithm modeled after RMAP, but runs in parallel on multiple machines with <italic>Hadoop</italic>. It is optimized for mapping many short reads from next-generation sequencing machines to a reference genome allowing for a user specified number of mismatches or differences. Like RMAP, it is a <italic>seed-and-extend</italic> algorithm that indexes the non-overlapping k-mers in the reads as seeds. The seed size <italic>s</italic>=<italic>m</italic>/(<italic>k</italic>+1) is computed from the minimum length of the reads (<italic>m</italic>) and the maximum number of differences or mismatches (<italic>k</italic>). Like RMAP, it attempts to extend the exact seeds to count the number of mismatches in an end-to-end alignment using that seed, and reports alignments with at most <italic>k</italic> mismatches. Alternatively, like BLAST, it can extend the exact seed matches into end-to-end gapped alignments using a dynamic programming algorithm. For this step, <italic>CloudBurst</italic> uses a variation of the Landau–Vishkin <italic>k</italic>-difference alignment algorithm (Landau <italic>et al.</italic>, <xref ref-type="bibr" rid="B9">1986</xref>), a dynamic programming algorithm for aligning two strings with at most <italic>k</italic> differences in O(<italic>km</italic>) time where <italic>m</italic> is the minimum length of the two strings. See Gusfield's (<xref ref-type="bibr" rid="B5">1997</xref>) classical text on sequence alignment for more details.</p>
    <p>As a <italic>MapReduce</italic> algorithm, <italic>CloudBurst</italic> is split into <italic>map</italic>, <italic>shuffle</italic> and <italic>reduce</italic> phases (<xref ref-type="fig" rid="F2">Fig. 2</xref>). The <italic>map</italic> function emits k-mers of length <italic>s</italic> as seeds from the reads and reference sequences. The <italic>shufffle</italic> phase groups together k-mers shared between the read and reference sequences. Finally, the <italic>reduce</italic> function extends the shared seeds into end-to-end alignments allowing both mismatches and indels. The input to the application is a multi-fasta file containing the reads and a multi-fasta file containing one or more reference sequences. These files are first converted to binary <italic>Hadoop</italic> SequenceFiles and copied into the HDFS. The DNA sequences are stored as the key–value pairs (<italic>id</italic>, <italic>SeqInfo</italic>), where <italic>SeqInfo</italic> is the tuple (<italic>sequence</italic>, <italic>start</italic>_<italic>offset</italic>) and <italic>sequence</italic> is the sequence of bases starting at the specified offset. By default, the reference sequences are partitioned into chunks of 65 kb overlapping by 1 kb, but the overlap can be increased to support reads longer than 1 kb.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Overview of the CloudBurst algorithm. The map phase emits k-mers as keys for every k-mer in the reference, and for all non-overlapping k-mers in the reads. The shufle phase groups together the k-mers shared between the reads and the reference. The reduce phase extends the seeds into end-to-end alignments allowing for a fixed number of mismatches or indels. Here, two grey reference seeds are compared with a single read creating one alignment with two errors and one alignment with zero errors, while the black shared seed is extended to an alignment with three errors.</p></caption><graphic xlink:href="btp236f2"/></fig>
</p>
    <sec id="SEC2.1">
      <title>2.1 Map: extract K-mers</title>
      <p>The map function scans the input sequences and emits key–value pairs (<italic>seed</italic>, <italic>MerInfo</italic>) where <italic>seed</italic> is a sequence of length <italic>s</italic>, and <italic>MerInfo</italic> is the tuple (<italic>id</italic>, <italic>position</italic>, <italic>isRef</italic>, <italic>isRC</italic>, <italic>left</italic>_<italic>flank</italic>, <italic>right</italic>_<italic>flank</italic>). If the input sequence is a reference sequence, then a pair is emitted for every k-mer in the sequence, with <italic>isRef</italic> = 1, <italic>isRC</italic> = 0, and position set as the offset of the k-mer in the original sequence. If the given input sequence is a read, then i<italic>sRef</italic> = 0, and a pair is emitted for the non-overlapping k-mers with appropriate <italic>position</italic>. Seeds are also emitted for the non-overlapping k-mers of the reverse complement sequence with <italic>isRC</italic> = 1. The flanking sequences [up to (<italic>m</italic> – <italic>s</italic> + <italic>k</italic>) bp) are included in the fields <italic>left</italic>_<italic>flank</italic> and <italic>right</italic>_<italic>flank</italic>. The seeds are represented with a 2 bit/bp encoding to represent the four DNA characters (ACGT), while the flanking sequences are represented with a 4 bit/bp encoding, which also allows for representing an unknown base (<italic>N</italic>), and a separator character (.).</p>
      <p><italic>CloudBurst</italic> parallelizes execution by seed, so each reducer evaluates all potential alignments for approximately 1/<italic>N</italic> of the 4<sup><italic>s</italic></sup> seeds, where <italic>N</italic> is the number of reducers. Overall this balances the workload well, and each reducer is assigned approximately the same number of alignments and runs for approximately the same duration. However, low-complexity seeds (defined as seeds composed of a single DNA character) occur a disproportionate number of times in the read and reference datasets, and the reducers assigned these high-frequency seeds require substantially more execution time than the others. Therefore, <italic>CloudBurst</italic> can rebalance low-complexity seeds by emitting redundant copies of each occurrence in the reference and randomly assigning occurrences in the reads to one of the redundant copies. For example, if the redundancy is set to 4, each instance of the seed <italic>AAAA</italic> in the reference will be redundantly emitted as seeds <italic>AAAA</italic>-0, <italic>AAAA</italic>-1, <italic>AAAA</italic>-2 and <italic>AAAA</italic>-3, and each instance of AAAA from the reads will be randomly assigned to seed <italic>AAAA</italic>-<italic>R</italic> with 0≤R≤3. The total number of alignments considered will be the same as if there were no redundant copies, but different subsets of the alignments can be evaluated in parallel in different reducers, and thus improve the overall load balance.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Shuffle: collect shared seeds</title>
      <p>Once all mappers have completed, <italic>Hadoop</italic> shuffles the key–value pairs, and groups all values with the same key into a single list. Since the key is a k-mer from either the read or reference sequences, this has the effect of cataloging seeds that are shared between the reads and the reference.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Reduce: extend seeds</title>
      <p>The reduce function extends the exact alignment seeds into longer inexact alignments. For a given <italic>seed</italic> and <italic>MerInfo</italic> list, it first partitions the <italic>MerInfo</italic> tuples into the set <italic>R</italic> from the reference and set <italic>Q</italic> from the reads. Then it attempts to extend each pair of tuples from the Cartesian product <italic>R</italic> × <italic>Q</italic> using either a scan of the flanking bases to count mismatches, or the Landau–Vishkin <italic>k</italic>-difference algorithm for gapped alignments. The evaluation proceeds block-wise across subsets of <italic>R</italic> and <italic>Q</italic> to maximize cache reuse, and using the bases flanking the shared seeds stored in the <italic>MerInfo</italic> tuples. If an end-to-end alignment with at most <italic>k</italic> mismatches or <italic>k</italic> differences is found, it is then checked to determine if it is a duplicate alignment. This is necessary because multiple exact seeds may be present within the same alignment. For example, a perfectly matching end-to-end alignment has <italic>k</italic> +1 exact seeds, and is computed <italic>k</italic> +1 times. If another exact seed with smaller offset exists in the read the alignment is filtered as a duplicate, otherwise the alignment is recorded. The value for <italic>k</italic> is small, so only a small number of alignments are discarded.</p>
      <p>The output from <italic>CloudBurst</italic> is a set of binary files containing every alignment of every read with at most <italic>k</italic> mismatches or differences. These files can be converted into a standard tab-delimited text file of the alignments using the same format as RMAP or post-processed with the bundled tools.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Alignment filtration</title>
      <p>In some circumstances, only the unambiguous best alignment for each read is required, rather than the full catalog of all alignments. If so, the alignments can be filtered to report the best alignment for each read, meaning the one with the fewest mismatches or differences. If a read has multiple best alignments, then no alignments are reported exactly as implemented in RMAPM. The filtering is implemented as a second <italic>MapReduce</italic> algorithm run immediately after the alignments are complete. The map function reemits the end-to-end alignments as key–value pairs with the read identifier as the key and the alignment information as the value. During the shuffle phase, all alignments for a given read are grouped together. The reduce function scans the list of alignments for each read and records the best alignment if an unambiguous best alignment exists. As an optimization, the reducers in the main alignment algorithm report the top two best alignments for each read. Also, the filtration algorithm uses a <italic>combiner</italic> to filter alignments in memory and reports just the top two best alignments from its subset of alignments for a given read. These optimizations improve performance without changing the results.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="SEC3">
    <title>3 RESULTS</title>
    <p><italic>CloudBurst</italic> was evaluated in a variety of configurations for the task of mapping random subsets of 7.06 million publicly available Illumina/Solexa sequencing reads from the 1000 Genomes Project (accession SRR001113) to portions of the human genome (NCBI Build 36) allowing up to four mismatches. All reads were exactly 36 bp long. The test cluster has 12 compute nodes, each with a 32 bit dual core 3.2 GHz Intel Xeon (24 cores total) and 250 GB of local disk space. The compute nodes were running RedHat Linux AS Release 3 Update 4, and <italic>Hadoop</italic> 0.15.3 set to execute two tasks per node (24 simultaneous tasks total). In the results below, the time to convert and load the data into the HDFS is excluded, since this time was the same for all tasks, and once loaded the data was reused for multiple analyses.</p>
    <p>The first test explored how <italic>CloudBurst</italic> scales as the number of reads increases and as the sensitivity of the alignment increases. In this test, sub-sets of the reads were mapped to the full human genome (2.87 Gbp), chromosome 1 (247.2 Mbp) or chromosome 22 (49.7 Mbp). To improve load balance across the cores, the number of mappers was set to 240, the number of reducers was set to 48, and the redundancy for low-complexity seeds was set to 16. The redundancy setting was used because the low-complexity seeds required substantially more running time than the other seeds (&gt;1 h compared with &lt;1 min), and the redundancy allows their alignments to be processed in parallel in different reducers. <xref ref-type="fig" rid="F3">Figure 3</xref> shows the running time of these tasks averaged over three runs, and shows that <italic>CloudBurst</italic> scales linearly in execution time as the number of reads increases, as expected. Aligning all 7M reads to the full genome with four mismatches failed to complete after reporting ∼25 billion mappings due to lack of available disk space. Even allowing zero mismatches created 771M end-to-end perfect matches from the full 7M read set, but most other tools would report just one match per read. Allowing more mismatches increases the runtime superlinearly, because higher sensitivity requires shorter seeds with more chance occurrences. The expected number of occurrences of a seed length <italic>s</italic> in a sequence of length <italic>L</italic> is (<italic>L</italic> − <italic>s</italic> + 1)/4<sup><italic>s</italic></sup>, so a random 18 bp sequence (<italic>k</italic> = 1) is expected to occur ∼0.04, ∼0.003 and ∼0.001 times in the full genome and chromosomes 1 and 22, respectively, while a 7 bp sequence (<italic>k</italic> =4) is expected to occur &gt;17 500, &gt;15 000 and &gt;3000 times, respectively. Consequently, short seeds have drastically more chance occurrences and correspondingly more running time even though most chance occurrences will fail to extend into end-to-end matches.
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Evaluation of CloudBurst running time while scaling the number of reads and sensitive for mapping to the (<bold>A</bold>) full human genome; (<bold>B</bold>) chromosomes 1; and (<bold>C</bold>) 22 on the local cluster with 24 cores. Tinted lines indicate timings allowing 0 (fastest) through four (slowest) mismatches between a read and the reference. As the number of reads increases, the running time increases linearly. As the number of allowed mismatches increases, the running time increases superlinearly from the exponential increase in seed instances. The four mismatch computation against the full human genome failed to complete due to lack of available disk space after reporting ∼25 billion end-to-end alignments.</p></caption><graphic xlink:href="btp236f3"/></fig>
</p>
    <p>The second test compared the performance <italic>CloudBurst</italic> on 24 processor cores with a serial execution of <italic>RMAPM</italic> (version 0.41) on 1 core with the full read set to chromosomes 1 and 22. <italic>RMAP</italic> requires a 64 bit operating system, so it was run on 1 core of a 64 bit dual core 2.4 GHz AMD Opteron 250 with 8 GB of RAM running RedHat Enterprise Linux AS Release 3 Update 9. <italic>CloudBurst</italic> was configured as before, except with the alignment filtration option enabled so only a single alignment was reported for each read identical to those reported by <italic>RMAPM</italic>. <xref ref-type="fig" rid="F4">Figure 4</xref> shows the results of the test, and plots the speedup of <italic>CloudBurst</italic> over <italic>RMAP</italic> for the different levels of sensitivity. The expected speedup is 24, since <italic>CloudBurst</italic> runs in parallel on 24 cores, but <italic>CloudBurst</italic>'s speedup over <italic>RMAP</italic> varies between 2× and 33× depending on the level of sensitivity and reference sequence. At low sensitivity (especially <italic>k</italic> =0), the overhead of shuffling and distributing the data over the network overwhelms the parallel computation compared with the in-memory lookup and evaluation in <italic>RMAP</italic>. As the sensitivity increases, the overhead becomes proportionally less until the time spent evaluating alignments in the reduce phase dominates the running time. The speedup beyond 24× for high-sensitivity mapping is due to implementation differences between <italic>RMAP</italic> and <italic>CloudBurst</italic>, and the additional compute resources available in the parallel environment (cache, disk IO, RAM, etc.). The speedup when mapping to the full genome did not improve as the level of sensitivity increased because of the increased overhead from the increased data size. This effect can be minimized by aligning more reads to the genome in a single batch, and thus better amortize the time spent emitting and shuffling all of the k-mers in the genome.
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>CloudBurst running time compared with <italic>RMAP</italic> for 7M reads, showing the speedup of CloudBurst running on 24 cores compared with <italic>RMAP</italic> running on 1 core. As the number of allowed mismatches increases, the relative overhead decreases allowing CloudBurst to meet and exceed 24× linear speedup.</p></caption><graphic xlink:href="btp236f4"/></fig>
</p>
    <p>The next experiment compared CloudBurst with an <italic>ad hoc</italic> parallelization scheme for RMAP, in which the reads are split into multiple files, and then RMAP is executed on each file. In the experiment, the full read set was split into 24 files, each containing 294k reads, and each file was separately mapped to chromosome 22. The runtimes were just for executing RMAP, and do not consider any overhead of partitioning the files, remotely launching the program, or monitoring the progress, and thus the expected speedup should be a perfect 24×. However, the runtimes of the different files varied considerably depending on which reads were present, and the corresponding speedup is computed based on the runtime for the longest running file: between 18 and 41 s with a 12× speedup for zero mismatches, 26–67 s with a 14× speedup for one mismatch, 34–98 s with a 16× speedup for two mismatches, 132–290 s with a 21× speedup for three mismatches and 1379–1770 s with a 29× speedup for four mismatches. The superlinear speedup for four mismatches was because the total computation time after splitting the read set was less than the time for the full batch at once, presumably because of better cache performance for RMAP with fewer reads. This experiment shows the <italic>ad hoc</italic> scheme works well with speedups similar to CloudBurst, but fails to reach perfect linear speedup in most cases because it makes no special considerations for load balance. In addition, an <italic>ad hoc</italic> parallelization scheme is more fragile as it would not benefit from the inherent advantages of Hadoop: data-aware scheduling, monitoring and restart and the high-performance file system.</p>
  </sec>
  <sec id="SEC4">
    <title>4 AMAZON CLOUD RESULTS</title>
    <p><italic>CloudBurst</italic> was next evaluated on the Amazon EC2. This environment provides unique opportunities for evaluating <italic>CloudBurst</italic>, because the performance and size of the cluster are configurable. The first test compared two different EC2 virtual machine classes with the local dedicated 24-core <italic>Hadoop</italic> cluster described above. In all three cases, the number of cores available was held constant at 24, and the task was mapping all 7M reads to human chromosome 22 with up to four mismatches, with runtimes averaged over three runs. The first configuration had 24 ‘Small Instance’ slaves running <italic>Hadoop</italic> 0.17.0, priced at $0.10 per hour per instance and provides one virtual core with approximately the performance of a 1.0–1.2 GHz 2007 Xeon processor. The second configuration had 12 ‘High-CPU Medium Instance’ slaves, also running <italic>Hadoop</italic> 0.17.0 and priced at $0.20 per hour per instance, but offers two virtual cores per machine and have been benchmarked to have a total performance approximately five times the small instance type. The running time for the ‘High-CPU Medium Instance’ class was 1667 s, and was substantially better per dollar than the ‘Small Instance’ class at 3805 s, and even exceeds the performance of the local dedicated cluster at 1921 s.</p>
    <p>The final experiment evaluated <italic>CloudBurst</italic> as the size of the cluster increases for a fixed problem. In this experiment, the number of ‘High-CPU Medium Instance’ cores varied between 24, 48, 72 and 96 virtual cores for the task of mapping all 7M reads to human chromosome 22. <xref ref-type="fig" rid="F5">Figure 5</xref> shows the running time with these clusters averaged over three runs. The results show <italic>CloudBurst</italic> scales very well as the number of cores increases: the 96-core cluster was 3.5 times faster than the 24-core cluster and reduced the running time of the serial RMAP execution from &gt;14 h to ∼8 min (&gt;100× speedup). The main limiting factor towards reaching perfect speedups in the large clusters was that the load imbalance caused a minority of the reducers running longer than the others. This effect was partially solved by reconfiguring the parallelization settings: the number of reducers was increased to 60 and the redundancy of the low-complexity seeds was increased to 24 for the 48-core evaluation, 144 and 72 for the 72-core evaluation and 196 and 72 for the 96-core evaluation. With these settings, the computation had better balance across the virtual machines and decreased the wall clock time of the execution.
<fig id="F5" position="float"><label>Fig. 5.</label><caption><p>Comparison of CloudBurst running time (in seconds) while scaling size of the cluster for mapping 7M reads to human chromosome 22 with at most four mismatches on the EC2 Cluster. The 96-core cluster is 3.5× faster than the 24-core cluster.</p></caption><graphic xlink:href="btp236f5"/></fig>
</p>
  </sec>
  <sec sec-type="discussion" id="SEC5">
    <title>5 DISCUSSION</title>
    <p><italic>CloudBurst</italic> is a new parallel read-mapping algorithm optimized for next-generation sequence data. It uses <italic>seed-and-extend</italic> alignment techniques modeled after RMAP to efficiently map reads with any number of mismatches or differences. It uses the <italic>Hadoop</italic> implementation of <italic>MapReduce</italic> to efficiently execute in parallel on multiple compute nodes, thus making it feasible to perform highly sensitive alignments on large read sets. The results described here show <italic>CloudBurst</italic> scales linearly as the number of reads increases, and with near linear parallel speedup as the size of the cluster increases. This high level of performance enables computation of extremely large numbers of highly sensitive alignments in dramatically reduced time, and is complementary to new BWT-based aligners that excel at quickly reporting a small number of alignments per read.</p>
    <p><italic>CloudBurst</italic>'s superior performance is made possible by the efficiency and power of <italic>Hadoop</italic>. This framework makes it straightforward to create highly scalable applications with many aspects of parallel computing automatically provided. <italic>Hadoop</italic>'s ability to deliver high performance, even in the face of extremely large datasets, is a perfect match for many problems in computational biology. <italic>Seed-and-extend</italic> style algorithms, in particular, are a natural fit for <italic>MapReduce</italic>, and any of the hash-table based seed-and-extend alignment algorithms including BLAST, SOAP, MAQ or ZOOM could be implemented with <italic>MapReduce</italic>. Future work for CloudBurst is to incorporate quality values in the mapping and scoring algorithms and to enhance support for paired reads. We are also exploring the possibility of integrating <italic>CloudBurst</italic> into RNA-seq analysis pipeline, which can also model gene splice sites. Algorithms that do not use a hash table, such as the BWT based short-read aligners, can also use <italic>Hadoop</italic> to parallelize execution and the HDFS.</p>
    <p>Implementing algorithms to run in parallel with <italic>Hadoop</italic> has many advantages, including scalability, redundancy, automatic monitoring and restart and high-performance distributed file access. In addition, no single machine needs to have the entire index in memory, and the computation requires only a single scan of the reference and query files. Consequently, <italic>Hadoop</italic> based implementations of other algorithms in computational biology might offer similar high levels of performance. These massively parallel applications, running on large compute clouds with thousands of nodes, will drastically change the scale and scope of computational biology, and allow researchers to cheaply perform analyses that are otherwise impossible.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>I would like to thank Jimmy Lin for introducing me to <italic>Hadoop</italic>; Steven Salzberg for reviewing the manuscript; and Arthur Delcher, Cole Trapnell and Ben Langmead for their helpful discussions. I would also like to thank the generous hardware support of IBM and Google via the Academic Cloud Computing Initiative used in the development of <italic>CloudBurst</italic>, and the Amazon Web Services <italic>Hadoop</italic> Testing Program for providing access to the EC2.</p>
    <p><italic>Funding</italic>: <grant-sponsor>National Institutes of Health</grant-sponsor> (grant <grant-num>R01 LM006845</grant-num>); Department of Homeland Security award NBCH207002.</p>
    <p><italic>Conflicts of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Baeza-yates</surname>
            <given-names>RA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fast and practical approximate string matching</article-title>
        <source>Proceedings of the Combinatorial Pattern Matching, Third Annual Symposium.</source>
        <year>1992</year>
        <publisher-loc>Tucson, AZ</publisher-loc>
        <fpage>185</fpage>
        <lpage>192</lpage>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bentley</surname>
            <given-names>DR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Accurate whole human genome sequencing using reversible terminator chemistry</article-title>
        <source>Nature</source>
        <year>2008</year>
        <volume>456</volume>
        <fpage>53</fpage>
        <lpage>59</lpage>
        <pub-id pub-id-type="pmid">18987734</pub-id>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ghemawat</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The Google file system</article-title>
        <source>Proceedings of the Nineteenth ACM Symposium on Operating Systems Principles.</source>
        <year>2003</year>
        <publisher-loc>Bolton Landing, NY, USA</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>29</fpage>
        <lpage>43</lpage>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <source>Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology.</source>
        <year>1997</year>
        <publisher-loc>England</publisher-loc>
        <publisher-name>Cambridge University Press</publisher-name>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dean</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>MapReduce: simplified data processing on large clusters</article-title>
        <source>Commun. ACM</source>
        <year>2008</year>
        <volume>51</volume>
        <fpage>107</fpage>
        <lpage>113</lpage>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Krishnaprasad</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Uses and abuses of Amdahl's law</article-title>
        <source>J. Comput. Small Coll.</source>
        <year>2001</year>
        <volume>17</volume>
        <fpage>288</fpage>
        <lpage>293</lpage>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Versatile and open software for comparing large genomes</article-title>
        <source>Genome Biol.</source>
        <year>2004</year>
        <volume>5</volume>
        <fpage>R12</fpage>
        <pub-id pub-id-type="pmid">14759262</pub-id>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Landau</surname>
            <given-names>GM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Introducing efficient parallelism into approximate string matching and a new serial algorithm</article-title>
        <source>Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing.</source>
        <year>1986</year>
        <publisher-loc>Berkeley, CA, USA</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>220</fpage>
        <lpage>230</lpage>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores</article-title>
        <source>Genome Res.</source>
        <year>2008a</year>
        <volume>18</volume>
        <fpage>1851</fpage>
        <lpage>1858</lpage>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SOAP: short oligonucleotide alignment program</article-title>
        <source>Bioinformatics</source>
        <year>2008b</year>
        <volume>24</volume>
        <fpage>713</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="pmid">18227114</pub-id>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ZOOM! zillions of oligos mapped</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <fpage>2431</fpage>
        <lpage>2437</lpage>
        <pub-id pub-id-type="pmid">18684737</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-throughput sequence alignment using Graphics Processing Units</article-title>
        <source>BMC Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>474</fpage>
        <pub-id pub-id-type="pmid">18070356</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shaffer</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Next-generation sequencing outpaces expectations</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2007</year>
        <volume>25</volume>
        <fpage>149</fpage>
        <pub-id pub-id-type="pmid">17287734</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>AD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Using quality scores and longer reads improves accuracy of Solexa read mapping</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>128</fpage>
        <pub-id pub-id-type="pmid">18307793</pub-id>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Venter</surname>
            <given-names>JC</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The sequence of the human genome</article-title>
        <source>Science</source>
        <year>2001</year>
        <volume>291</volume>
        <fpage>1304</fpage>
        <lpage>1351</lpage>
        <pub-id pub-id-type="pmid">11181995</pub-id>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The diploid genome sequence of an Asian individual</article-title>
        <source>Nature</source>
        <year>2008</year>
        <volume>456</volume>
        <fpage>60</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">18987735</pub-id>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wheeler</surname>
            <given-names>DA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The complete genome of an individual by massively parallel DNA sequencing</article-title>
        <source>Nature</source>
        <year>2008</year>
        <volume>452</volume>
        <fpage>872</fpage>
        <lpage>876</lpage>
        <pub-id pub-id-type="pmid">18421352</pub-id>
      </citation>
    </ref>
  </ref-list>
</back>
