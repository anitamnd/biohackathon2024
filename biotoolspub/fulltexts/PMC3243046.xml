<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3243046</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-11-546</article-id>
    <article-id pub-id-type="pmid">21050468</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-11-546</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Optimizing transformations for automated, high throughput analysis of flow cytometry data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Finak</surname>
          <given-names>Greg</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>gfinak@fhcrc.org</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Perez</surname>
          <given-names>Juan-Manuel</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>juan-manuel.perez@ircm.qc.ca</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Weng</surname>
          <given-names>Andrew</given-names>
        </name>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>aweng@bccrc.ca</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A4">
        <name>
          <surname>Gottardo</surname>
          <given-names>Raphael</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>rgottard@fhcrc.org</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Vaccine and Infectious Disease Division, Fred Hutchinson Cancer Research Center, 1100 Fariview Ave N, Seattle, WA, 98109, USA</aff>
    <aff id="I2"><label>2</label>Computational Biology Unit, Institut de Recherches Cliniques de Montréal, 110 Pine Ave West, Montreal, QC, H2W 1R7, Canada</aff>
    <aff id="I3"><label>3</label>Terry Fox Laboratory, 675 West 10th Avenue Vancouver, BC, V5Z 1L3, Canada</aff>
    <pub-date pub-type="collection">
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>4</day>
      <month>11</month>
      <year>2010</year>
    </pub-date>
    <volume>11</volume>
    <fpage>546</fpage>
    <lpage>546</lpage>
    <history>
      <date date-type="received">
        <day>28</day>
        <month>5</month>
        <year>2010</year>
      </date>
      <date date-type="accepted">
        <day>4</day>
        <month>11</month>
        <year>2010</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2010 Finak et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2010</copyright-year>
      <copyright-holder>Finak et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/11/546"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>In a high throughput setting, effective flow cytometry data analysis depends heavily on proper data preprocessing. While usual preprocessing steps of quality assessment, outlier removal, normalization, and gating have received considerable scrutiny from the community, the influence of data transformation on the output of high throughput analysis has been largely overlooked. Flow cytometry measurements can vary over several orders of magnitude, cell populations can have variances that depend on their mean fluorescence intensities, and may exhibit heavily-skewed distributions. Consequently, the choice of data transformation can influence the output of automated gating. An appropriate data transformation aids in data visualization and gating of cell populations across the range of data. Experience shows that the choice of transformation is data specific. Our goal here is to compare the performance of different transformations applied to flow cytometry data in the context of automated gating in a high throughput, fully automated setting. We examine the most common transformations used in flow cytometry, including the generalized hyperbolic arcsine, biexponential, linlog, and generalized Box-Cox, all within the BioConductor <italic>flowCore </italic>framework that is widely used in high throughput, automated flow cytometry data analysis. All of these transformations have adjustable parameters whose effects upon the data are non-intuitive for most users. By making some modelling assumptions about the transformed data, we develop maximum likelihood criteria to optimize parameter choice for these different transformations.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We compare the performance of parameter-optimized and default-parameter (in <italic>flowCore</italic>) data transformations on real and simulated data by measuring the variation in the locations of cell populations across samples, discovered via automated gating in both the scatter and fluorescence channels. We find that parameter-optimized transformations improve visualization, reduce variability in the location of discovered cell populations across samples, and decrease the misclassification (mis-gating) of individual events when compared to default-parameter counterparts.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Our results indicate that the preferred transformation for fluorescence channels is a parameter- optimized biexponential or generalized Box-Cox, in accordance with current best practices. Interestingly, for populations in the scatter channels, we find that the optimized hyperbolic arcsine may be a better choice in a high-throughput setting than current standard practice of no transformation. However, generally speaking, the choice of transformation remains data-dependent. We have implemented our algorithm in the BioConductor package, flowTrans, which is publicly available.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Flow cytometry (FCM) is increasingly moving to-wards automated methods to deal with the quantities of data generated by high throughput, high-content screening [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B11">11</xref>]. An appropriate, auto-mated data pre-processing pipeline, including automated gating and matching of corresponding cell populations across replicated or similar samples is important for the accuracy of downstream analysis. However, accurate automated gating of FCM data is complicated by asymmetric and overlapping cell populations, frequent outlier events, cell populations whose variance depend on their mean fluorescence intensity, and multiplicative errors in the fluorescence channels. All of these characteristics can influence the output of both manual and automated gating, and subsequent downstream analysis. Data transformation plays an important role in mitigating some of these effects, both in manual and automated analysis setting. In a manual analysis setting, a transformation is typically chosen to facilitate cell population visualization for the purposes of gating. Generally, a set of common transformation parameters are chosen across multiple samples to ensure that they are on a common scale and facilitate comparison. Carefully chosen data transformations and corresponding parameters have been suggested to overcome some of the problems surrounding manual FCM analysis and gating [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>]. Data transformation plays an even more important role in an automated, high throughput setting since the scale and distribution of the transformed data can influence downstream analysis procedures. Some automated gating methods include data transformation as part of the gating algorithm [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B10">10</xref>]. Other methods function under the assumption that the data have been appropriately transformed prior to the gating step [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B9">9</xref>]. Methods for inter-sample normalization in downstream preprocessing steps can allow for different data transformations per sample. By loosening the requirements of a common transformation across samples, we can explore the optimization of data transformations for automated gating. In such a setting, the impact of data transformation has received relatively little attention [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B15">15</xref>]. Lo <italic>et al</italic>. propose the estimation of a generalized Box-Cox transformation embedded within a mixture modelling framework to simultaneously gate and transform skewed cell populations [<xref ref-type="bibr" rid="B6">6</xref>]. Their approach works very well in practice, but FCM data are generally still subjected to a global transformation prior to automated gating. What is clear is that the choice of transformation is data-driven and involves multiple considerations. The underpinning principle is to choose a transformation that facilitates cell population gating, visualization, and inter-sample comparison, by obtaining a representation wherein cell populations are well resolved across the full range of the data [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B15">15</xref>-<xref ref-type="bibr" rid="B17">17</xref>].</p>
    <p>There are many transformations in common use for flow cytometry data, including the logarithm and related transformations such as the linear-logarithmic and hyperlog transforms, power transformations such as the generalized Box-Cox, which includes the logarithm as a special case, and the biexponential and related transformations such as the logicle and generalized arcsinh [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B17">17</xref>]. The log transformation can often stabilize the variance of cell populations in the fluorescence channels across nearly the full range of intensities but cannot represent negative data values of unstained cell populations, leading to compression of data against the axes and poor visual representation of low intensity or unstained populations [<xref ref-type="bibr" rid="B12">12</xref>]. To deal with this, other transformations have been suggested, including the linear-logarithmic (linlog) transformation, the biexponential (logicle), and generalized arcsinh transformations. These all improve upon the log by allowing negative values, providing a linear representation of data around zero and a logarithmic representation of the data at higher intensity values, with a smooth transition between the two extremes. The hyperlog has been proposed specifically for compensated data and is also capable of dealing with non-positive values [<xref ref-type="bibr" rid="B13">13</xref>]. The biexponential transform provides additional flexibility by allowing the linear portion of the scale to be asymmetric around zero; the logarithmic scale can similarly be tuned by adjustable parameters. The generalized Box-Cox has been adapted and applied to FCM data in the context of automated gating within a multivariate-<italic>t </italic>mixture modelling framework [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B18">18</xref>]. Lo <italic>et al</italic>. proposed to select the generalized Box-Cox transformation parameter maximizing the likelihood of individual cell populations being generated by a mixture of multivariate-<italic>t </italic>or multivariate-normal distributions on the transformed scale [<xref ref-type="bibr" rid="B6">6</xref>]. All of these transformations have one or more parameters (with the exception of the log) that can be adjusted in a data-dependent manner to modify the representation of the data. We perform our analysis within the <italic>flowCore </italic>framework in BioConductor, which is the predominant tool set in use for automated, high throughput flow data analysis. The default parameters of the transformations within <italic>flowCore </italic>are rarely adjusted in practice, and are almost certainly not the best possible parameter choices for all data sets. Here we examine the impact of the chosen transformation and its parameters upon the accuracy of automated gating as well as the ability to match gated cell populations across samples.</p>
    <p>We make several important comments about notation. In this paper we refer frequently to transformations and inverse transformations. Mathematically, a function and its inverse are denoted <italic>f</italic>(.) and <italic>f </italic><sup>-1</sup>(.), respectively. However, in FCM data, the biexponential <italic>transformation </italic>is actually the inverse of <italic>f</italic>(<italic>y</italic>) = <italic>a </italic>exp(<italic>b</italic>(<italic>y </italic>- <italic>w</italic>)) - <italic>c </italic>exp(-<italic>d</italic>(<italic>y </italic>- <italic>w</italic>)) + <italic>f</italic>, where <italic>f</italic>(<italic>y</italic>) is the biexponential <italic>function</italic>. For clarity of exposition, in this paper, we will refer to the biexponential transformation as <italic>f </italic><sup>-1</sup>(<italic>y</italic>) above, and the inverse-biexponential transformation as <italic>f</italic>(<italic>y</italic>), above. Although counter-intuitive to the mathematical definition of the biexponential <italic>function</italic>, this nomenclature is accepted in the FCM community [<xref ref-type="bibr" rid="B12">12</xref>]. The notation in Table <xref ref-type="table" rid="T1">1</xref> is in accordance with this nomenclature.</p>
    <table-wrap id="T1" position="float">
      <label>Table 1</label>
      <caption>
        <p>Summary of transformations</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <th align="left">Transformation</th>
            <th align="center">Mathematical Definition<break/><italic>f</italic>(<italic>y</italic>;<italic>θ</italic>), <italic>f</italic><sup>-1 </sup>(<italic>x</italic>; <italic>θ</italic>)</th>
            <th align="center">Jacobian <italic>J<sub>θ </sub></italic>(<italic>y</italic>)</th>
            <th align="center">Parameter Bounds and Constraints</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">Linlog</td>
            <td align="center">
              <inline-formula>
                <mml:math id="M1" name="1471-2105-11-546-i1" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>f</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi>θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mrow>
                          <mml:mo>{</mml:mo>
                          <mml:mtable columnalign="left">
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>y</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>/</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>log</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>;</mml:mo>
                                <mml:mtext/>
                                <mml:mi>y</mml:mi>
                                <mml:mo>≤</mml:mo>
                                <mml:mi>θ</mml:mi>
                              </mml:mtd>
                            </mml:mtr>
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mi>log</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>y</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>;</mml:mo>
                                <mml:mtext/>
                                <mml:mi>y</mml:mi>
                                <mml:mo> &gt;</mml:mo>
                                <mml:mi>θ</mml:mi>
                              </mml:mtd>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msup>
                          <mml:mi>f</mml:mi>
                          <mml:mrow>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>x</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi>θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mrow>
                          <mml:mo>{</mml:mo>
                          <mml:mtable columnalign="left">
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mi>θ</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>x</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>log</mml:mi>
                                <mml:mi>θ</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>;</mml:mo>
                                <mml:mi>x</mml:mi>
                                <mml:mo> &lt;</mml:mo>
                                <mml:mi>log</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mtd>
                            </mml:mtr>
                            <mml:mtr>
                              <mml:mtd>
                                <mml:mi>exp</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>x</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>;</mml:mo>
                                <mml:mi>x</mml:mi>
                                <mml:mo>≥</mml:mo>
                                <mml:mi>log</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mtd>
                            </mml:mtr>
                          </mml:mtable>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
            <td align="center">
              <inline-formula>
                <mml:math id="M2" name="1471-2105-11-546-i2" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mn>1</mml:mn>
                        <mml:mo>/</mml:mo>
                        <mml:mi>θ</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mtext> </mml:mtext>
                        <mml:mi>y</mml:mi>
                        <mml:mo>≤</mml:mo>
                        <mml:mi>θ</mml:mi>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mn>1</mml:mn>
                        <mml:mo>/</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mtext> </mml:mtext>
                        <mml:mi>y</mml:mi>
                        <mml:mo> &gt;</mml:mo>
                        <mml:mi>θ</mml:mi>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
            <td align="center">
              <inline-formula>
                <mml:math id="M3" name="1471-2105-11-546-i3" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>θ</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mo stretchy="false">[</mml:mo>
                        <mml:mi>min</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>,</mml:mo>
                        <mml:mi>max</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo stretchy="false">]</mml:mo>
                        <mml:mo>,</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>θ</mml:mi>
                        <mml:mo>≥</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">Generalized Arcsinh</td>
            <td align="center">
              <inline-formula>
                <mml:math id="M4" name="1471-2105-11-546-i4" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>f</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi mathvariant="bold-italic">θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi>log</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mi>y</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:msqrt>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>a</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>b</mml:mi>
                                <mml:mi>y</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                              <mml:mn>2</mml:mn>
                            </mml:msup>
                            <mml:mo>+</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msqrt>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>+</mml:mo>
                        <mml:mi>c</mml:mi>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msup>
                          <mml:mi>f</mml:mi>
                          <mml:mrow>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>x</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi mathvariant="bold-italic">θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mfrac>
                          <mml:mn>1</mml:mn>
                          <mml:mn>2</mml:mn>
                        </mml:mfrac>
                        <mml:mrow>
                          <mml:mo>(</mml:mo>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mi>e</mml:mi>
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>x</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>c</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:msup>
                            <mml:mo>−</mml:mo>
                            <mml:msup>
                              <mml:mi>e</mml:mi>
                              <mml:mrow>
                                <mml:mo>−</mml:mo>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>x</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mi>c</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:msup>
                          </mml:mrow>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
            <td align="center">
              <inline-formula>
                <mml:math id="M5" name="1471-2105-11-546-i5" overflow="scroll">
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:mi>b</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mfrac>
                          <mml:mn>1</mml:mn>
                          <mml:mn>2</mml:mn>
                        </mml:mfrac>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>2</mml:mn>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mi>a</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:msup>
                          <mml:mi>b</mml:mi>
                          <mml:mn>2</mml:mn>
                        </mml:msup>
                        <mml:mi>y</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:msup>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>a</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>b</mml:mi>
                                <mml:mi>y</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                              <mml:mn>2</mml:mn>
                            </mml:msup>
                            <mml:mo>+</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>/</mml:mo>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mi>a</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mi>y</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:msqrt>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>a</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>b</mml:mi>
                                <mml:mi>y</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                              <mml:mn>2</mml:mn>
                            </mml:msup>
                            <mml:mo>+</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msqrt>
                      </mml:mrow>
                    </mml:mfrac>
                  </mml:mrow>
                </mml:math>
              </inline-formula>
            </td>
            <td align="center">
              <inline-formula>
                <mml:math id="M6" name="1471-2105-11-546-i6" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi mathvariant="bold-italic">θ</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mo>{</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>c</mml:mi>
                        <mml:mo>}</mml:mo>
                        <mml:mo>;</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>c</mml:mi>
                        <mml:mo>≥</mml:mo>
                        <mml:mn>0</mml:mn>
                        <mml:mo>;</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>b</mml:mi>
                        <mml:mo> &gt;</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">Biexponential</td>
            <td align="center">
              <inline-formula>
                <mml:math id="M7" name="1471-2105-11-546-i7" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>f</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi mathvariant="bold-italic">θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mtext>no closed form</mml:mtext>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msup>
                          <mml:mi>f</mml:mi>
                          <mml:mrow>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>x</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi mathvariant="bold-italic">θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:msup>
                          <mml:mi>e</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>b</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>x</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mi>w</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>−</mml:mo>
                        <mml:mi>c</mml:mi>
                        <mml:msup>
                          <mml:mi>e</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mo>−</mml:mo>
                            <mml:mi>d</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>x</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mi>w</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>+</mml:mo>
                        <mml:mtext>f</mml:mtext>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
            <td align="center">1 = (<italic>abe</italic><sup><italic>b</italic>(<italic>x-w</italic>)</sup>+ <italic>cde</italic><sup>-<italic>d</italic>(<italic>x-w</italic>)</sup>)</td>
            <td align="center">
              <inline-formula>
                <mml:math id="M8" name="1471-2105-11-546-i8" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi mathvariant="bold-italic">θ</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mo>{</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>c</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>d</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mtext>f</mml:mtext>
                        <mml:mo>,</mml:mo>
                        <mml:mi>w</mml:mi>
                        <mml:mo>}</mml:mo>
                        <mml:mo>;</mml:mo>
                        <mml:mi>a</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>c</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mn>0</mml:mn>
                        <mml:mo>,</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo stretchy="false">]</mml:mo>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mtext>f</mml:mtext>
                        <mml:mo>=</mml:mo>
                        <mml:mn>0</mml:mn>
                        <mml:mo>,</mml:mo>
                        <mml:mi>w</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mi>ℝ</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>b</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>d</mml:mi>
                        <mml:mo>≥</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">Generalized Box-Cox</td>
            <td align="center">
              <inline-formula>
                <mml:math id="M9" name="1471-2105-11-546-i9" overflow="scroll">
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mi>f</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>y</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi>θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mtable>
                          <mml:mtr>
                            <mml:mtd>
                              <mml:mrow>
                                <mml:mfrac>
                                  <mml:mrow>
                                    <mml:mi>sgn</mml:mi>
                                    <mml:mo stretchy="false">(</mml:mo>
                                    <mml:mi>y</mml:mi>
                                    <mml:mo stretchy="false">)</mml:mo>
                                    <mml:mo>|</mml:mo>
                                    <mml:mi>y</mml:mi>
                                    <mml:msup>
                                      <mml:mo>|</mml:mo>
                                      <mml:mi>θ</mml:mi>
                                    </mml:msup>
                                    <mml:mo>−</mml:mo>
                                    <mml:mn>1</mml:mn>
                                  </mml:mrow>
                                  <mml:mi>θ</mml:mi>
                                </mml:mfrac>
                                <mml:mo>;</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo>∈</mml:mo>
                                <mml:mi>ℝ</mml:mi>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msup>
                          <mml:mi>f</mml:mi>
                          <mml:mrow>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>x</mml:mi>
                        <mml:mo>;</mml:mo>
                        <mml:mi>θ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mtable>
                          <mml:mtr>
                            <mml:mtd>
                              <mml:mrow>
                                <mml:mi>sgn</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mi>x</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>|</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mi>x</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:msup>
                                  <mml:mo>|</mml:mo>
                                  <mml:mrow>
                                    <mml:mfrac>
                                      <mml:mn>1</mml:mn>
                                      <mml:mi>θ</mml:mi>
                                    </mml:mfrac>
                                  </mml:mrow>
                                </mml:msup>
                                <mml:mo>;</mml:mo>
                                <mml:mi>θ</mml:mi>
                                <mml:mo>∈</mml:mo>
                                <mml:mi>ℝ</mml:mi>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
              </inline-formula>
            </td>
            <td align="center">|<italic>y</italic>|<sup><italic>θ</italic>-1</sup></td>
            <td align="center"><italic>θ </italic>∈ ℝ</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <p>Summary of transformations for flow cytometry. The transformations examined in this study, together with their inverses, Jacobians and parameter restrictions. <italic>f</italic>(<italic>y</italic>; <bold><italic>θ</italic></bold>) is the transformation function typicallly applied to untransformed flow cytometry data, y, whereas <italic>f</italic><sup>-1</sup>(<italic>x</italic>; <bold><italic>θ</italic></bold>) is its inverse. For the biexponential, the transformation <italic>f</italic>(.) has no closed form and must be solved numerically. Consequently, the Jacobian of the biexponential transformation is given by the reciprocal of the Jacobian of the inverse transformation, and therefore depends directly on the transformed data, <italic>x</italic>. sgn is the signum function, also known as the sign function, which extracts the sign of a real number.</p>
      </table-wrap-foot>
    </table-wrap>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Parameter Estimation</title>
      <p>We use maximum likelihood methods to estimate the parameters of each transformation (generalized arcsinh, generalized Box-Cox, linlog, and biexponential) following established methods [<xref ref-type="bibr" rid="B19">19</xref>]. If <bold>Y </bold>is an <italic>n </italic>× <italic>d </italic>data matrix, we represent the data as a sequence of <italic>n </italic><italic>d</italic>-dimensional vectors <bold>Y</bold><italic><sub>i </sub></italic>={<italic>y</italic><sub><italic>i</italic>, 1</sub>,..., <italic>y<sub>i, d</sub></italic>} and the transformed data as <inline-formula><mml:math id="M10" name="1471-2105-11-546-i10" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="bold">Y</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="bold-italic">θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>f </italic>is the transformation function, and <bold><italic>θ </italic></bold>is the vector of transformation parameters. For simplicity we model the transformed data by a multivariate normal distribution <bold>Y</bold><sup>(<bold><italic>θ</italic></bold>) </sup>~ <italic>N<sub>d</sub></italic>(<bold><italic>μ</italic></bold>, <bold>Σ</bold>|<bold><italic>θ</italic></bold>). The likelihood of the parameters, given the data and a fixed <bold><italic>θ </italic></bold>is<disp-formula id="bmcM1"><label>(1)</label><graphic xlink:href="1471-2105-11-546-i11.gif"/></disp-formula></p>
      <p>where <inline-formula><mml:math id="M11" name="1471-2105-11-546-i12" overflow="scroll"><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi mathvariant="bold">Y</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mfrac><mml:mrow><mml:mo>∂</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">θ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>∂</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> is the Jacobian term that accounts for the change of scale under different transformation parameters. It follows that for a fixed <bold><italic>θ</italic></bold>, the mean and covariance of the transformed data can be estimated by the sample mean and sample covariance, as follows,</p>
      <p>
        <disp-formula>
          <mml:math id="M12" name="1471-2105-11-546-i13" overflow="scroll">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold-italic">μ</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mi>n</mml:mi>
                  </mml:mfrac>
                  <mml:mstyle displaystyle="true">
                    <mml:munderover>
                      <mml:mo mathvariant="bold">∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                      <mml:mi>n</mml:mi>
                    </mml:munderover>
                    <mml:mrow>
                      <mml:msubsup>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi mathvariant="bold">Y</mml:mi>
                        </mml:mstyle>
                        <mml:mi>i</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi mathvariant="bold-italic">θ</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:msubsup>
                    </mml:mrow>
                  </mml:mstyle>
                  <mml:mo>=</mml:mo>
                  <mml:mover accent="true">
                    <mml:mrow>
                      <mml:msup>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi mathvariant="bold">Y</mml:mi>
                        </mml:mstyle>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi mathvariant="bold-italic">θ</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                    <mml:mo stretchy="true">¯</mml:mo>
                  </mml:mover>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mover accent="true">
                    <mml:mi mathvariant="bold-italic">Σ</mml:mi>
                    <mml:mo>^</mml:mo>
                  </mml:mover>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mi>n</mml:mi>
                  </mml:mfrac>
                  <mml:mstyle displaystyle="true">
                    <mml:munder>
                      <mml:mo mathvariant="bold-italic">∑</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:munder>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msubsup>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi mathvariant="bold">Y</mml:mi>
                        </mml:mstyle>
                        <mml:mi>i</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi mathvariant="bold-italic">θ</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:msubsup>
                      <mml:mo>−</mml:mo>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:msup>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi mathvariant="bold">Y</mml:mi>
                            </mml:mstyle>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>θ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:msup>
                        </mml:mrow>
                        <mml:mo stretchy="true">¯</mml:mo>
                      </mml:mover>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msubsup>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi mathvariant="bold">Y</mml:mi>
                            </mml:mstyle>
                            <mml:mi>i</mml:mi>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>θ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:msubsup>
                          <mml:mo>−</mml:mo>
                          <mml:mover accent="true">
                            <mml:mrow>
                              <mml:msup>
                                <mml:mstyle mathvariant="bold" mathsize="normal">
                                  <mml:mi mathvariant="bold">Y</mml:mi>
                                </mml:mstyle>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mi mathvariant="bold-italic">θ</mml:mi>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:msup>
                            </mml:mrow>
                            <mml:mo stretchy="true">¯</mml:mo>
                          </mml:mover>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:msup>
                    </mml:mrow>
                  </mml:mstyle>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
      </p>
      <p>Now we can substitute these two expressions into (1) and maximize over <bold><italic>θ </italic></bold>After some simple algebra, it can be shown that it is equivalent to minimizing:</p>
      <p>
        <disp-formula>
          <mml:math id="M13" name="1471-2105-11-546-i14" overflow="scroll">
            <mml:mrow>
              <mml:mi>S</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi mathvariant="bold-italic">θ</mml:mi>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:mo stretchy="false">|</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mstyle displaystyle="true">
                    <mml:msub>
                      <mml:mo>∑</mml:mo>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msubsup>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi mathvariant="bold">Y</mml:mi>
                        </mml:mstyle>
                        <mml:mi>i</mml:mi>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi mathvariant="bold-italic">θ</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:msubsup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:msubsup>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi mathvariant="bold">Y</mml:mi>
                            </mml:mstyle>
                            <mml:mi>i</mml:mi>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi mathvariant="bold-italic">θ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:msubsup>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:msup>
                      <mml:mo>/</mml:mo>
                      <mml:mi>n</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mover accent="true">
                        <mml:mrow>
                          <mml:msubsup>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi mathvariant="bold">Y</mml:mi>
                            </mml:mstyle>
                            <mml:mi>i</mml:mi>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi mathvariant="bold-italic">θ</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:msubsup>
                        </mml:mrow>
                        <mml:mo stretchy="true">¯</mml:mo>
                      </mml:mover>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mover accent="true">
                            <mml:mrow>
                              <mml:msubsup>
                                <mml:mstyle mathvariant="bold" mathsize="normal">
                                  <mml:mi mathvariant="bold">Y</mml:mi>
                                </mml:mstyle>
                                <mml:mi>i</mml:mi>
                                <mml:mrow>
                                  <mml:mo stretchy="false">(</mml:mo>
                                  <mml:mi mathvariant="bold-italic">θ</mml:mi>
                                  <mml:mo stretchy="false">)</mml:mo>
                                </mml:mrow>
                              </mml:msubsup>
                            </mml:mrow>
                            <mml:mo stretchy="true">¯</mml:mo>
                          </mml:mover>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mi>T</mml:mi>
                      </mml:msup>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo stretchy="false">|</mml:mo>
                    </mml:mrow>
                  </mml:mstyle>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>G</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi mathvariant="bold-italic">θ</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
          </mml:math>
        </disp-formula>
      </p>
      <p>where <inline-formula><mml:math id="M14" name="1471-2105-11-546-i15" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="bold-italic">θ</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mo mathvariant="bold">∏</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:msub><mml:mi>J</mml:mi><mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi mathvariant="bold">Y</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the geometric mean of the squared Jacobian terms. Thus explicit derivation of the functions to be minimized for each transformation, <bold>S</bold>(<bold><italic>θ</italic></bold>), only involve deriving the Jacobian of the transformation. These transformations, their inverses, and their Jacobians are summarized in Table <xref ref-type="table" rid="T1">1</xref>, and presented in Additional File <xref ref-type="supplementary-material" rid="S1">1</xref> with common parameter values. When no closed form exists, we use numerical optimization routines in R to optimize (1) over <bold><italic>θ </italic></bold>[<xref ref-type="bibr" rid="B20">20</xref>]. We note that the translation parameter is fixed at <italic>f </italic>= 0 in the biexponential transformation in order to resolve identifiability issues with the full parameterization (see Additional File <xref ref-type="supplementary-material" rid="S2">2</xref>). The decision to model the <italic>transformed </italic>data as a multivariate Gaussian distribution is motivated by the implicit assumption of a common error model across all cells when performing a global data transformation. We note that the form of this implicit error model is not known. The multivariate Gaussian assumption is strictly a computationally convenient choice that has the effect of making the marginal distribution of the data more symmetric and reducing the influence of outliers at the subsequent gating step. For the purposes of gating, however, flow cytometry data is better represented as a mixture of distributions, which is done explicitly by <italic>flowClust </italic>and <italic>flowMerge</italic>.</p>
    </sec>
    <sec>
      <title>Follicular Lymphoma Data Set</title>
      <p>We examined a subset of a clinical FCM data set derived from lymph node biopsies from 10 individuals diagnosed with follicular lymphoma. Each sample was five-dimensional, labeled with CD5, CD19, and CD3, in addition to the FSC (forward scatter) and SSC (side scatter) channels. The ten individuals sampled consisted of five males and five females, of median age 59.5 years, (range 40-82). Five individuals had stage 4 disease, three had stage 3 disease, and two had stage 1 disease. Overall survival for the group ranged from 0.45 years to 14.66 years.</p>
    </sec>
    <sec>
      <title>Evaluating the Suitability of a Data Transformation</title>
      <p>To evaluate the performance of different transformations, we measured the variation in the location of cell populations identified by automated gating using the flowClust/flowMerge frameworks [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B6">6</xref>]. The variation in the position of gated cell populations was measured across biological replicates, and compared for each transformation.</p>
      <p>The FSC and SSC channels were analyzed separately from the fluorescence channels, according to procedures established elsewhere [<xref ref-type="bibr" rid="B6">6</xref>]. Data was normalized on the scale on which it would be visualized, therefore the scatter channels were normalized prior to transformation, whereas the fluorescence channels were normalized after data transformation (Figure <xref ref-type="fig" rid="F1">1a</xref> and <xref ref-type="fig" rid="F1">1b</xref>) [<xref ref-type="bibr" rid="B21">21</xref>]. In the scatter channels, parameter-optimized transformations (generalized arcsinh, generalized Box-Cox, linlog, biexponential) were compared against default-parameter counterparts (generalized arcsinh and biexponential), as well as the standard procedure of no transformation (Figure <xref ref-type="fig" rid="F1">1a</xref> path 1 and 2). For fluorescence channels, default and optimized parameter transformation were compared against together with the log transformation (Figure <xref ref-type="fig" rid="F1">1b</xref>, path 1 and 2). Populations in the scatter and fluorescence channels were automatically gated using the <italic>flowClust </italic>and <italic>flowMerge </italic>framework [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B6">6</xref>]. These discovered populations were metaclustered, and intracluster variability was compared either on the transformed scale (fluorescence channels), or on the original scale (scatter channels).</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Flowchart of the analysis pipeline</bold>. Flowchart describing our analysis pipeline. a) Procedure for analyzing FSC vs SSC channels. Standard data analysis procedures are depicted by path 1, whereas procedures applying parameter-optimized transformations are depicted by path 2. b) Procedure for analyzing fluorescence channels. Standard procedures are depicted by path 1). Procedures utilizing optimized transformations are depicted by path 2. The default transformation depicted in 1) is the generalized arcsinh with default parameters (a = 1, b = 1, c = 0), as defined in the <italic>flowCore </italic>package. Normalization follows transformation in b) to ensure that the transformed data are on a common scale.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-546-1"/>
      </fig>
    </sec>
    <sec>
      <title>Cell Population Identification, Metaclustering and Metrics</title>
      <p>Automated gating was performed using the <italic>flowClust </italic>and <italic>flowMerge </italic>packages in BioConductor [<xref ref-type="bibr" rid="B4">4</xref>,<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B22">22</xref>]. Lymphocyte cell populations were identified manually from among the gated populations, and corresponded to the most dense clusters of cells in the FSC vs SSC dimensions. We evaluated the performance of each transformation by examining the variation in the position of the lymphocyte cell populations across biological replicates. The variation was measured as the sum of squared deviations from the mean lymphocyte cell population position across the samples. Cell populations identified in the fluorescence channels by automated gating were matched across samples using a <italic>metaclustering </italic>approach. This involved a modified single linkage agglomerative clustering approach to group corresponding populations across samples [<xref ref-type="bibr" rid="B23">23</xref>]. We provide an informal description of the algorithm, followed by a formal definition. Informally, we assume that cell populations in each sample are unique, therefore no more than one population from a sample can belong to a metacluster. We choose the sample with the largest number of cell populations and assign each population to unique metacluster. We then iterate through each cell population in the remaining samples and assign it to its nearest metacluster (measured by the Mahalanobis distance), with the restriction that no more than one cell population from a sample may belong to the same metacluster.</p>
      <p>More formally, we let <italic>S </italic>= {<italic>s</italic><sub>1</sub>, . . , <italic>s<sub>n</sub></italic>, . . , <italic>s<sub>N </sub></italic>} be the set of all samples, indexed by <italic>n</italic>. Following automated gating, a sample is clustered into some number, π<italic><sub>n</sub></italic>, of <italic>discovered cell populations</italic>. We let <inline-formula><mml:math id="M15" name="1471-2105-11-546-i16" overflow="scroll"><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mi>n</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mn>..</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:msub><mml:mi>π</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the set of discovered cell populations within the <italic>n</italic>th sample, such that the cardinality of <italic>P<sup>n </sup></italic>is |<italic>P<sup>n</sup></italic>| = π<italic><sub>n</sub></italic>. On the transformed scale, each discovered cell population is summarized by a multivariate-<italic>t </italic>distribution. The parameters of the multivariate-t distribution representing the <italic>i</italic>th cell population from the <italic>n</italic>th sample are <inline-formula><mml:math id="M16" name="1471-2105-11-546-i17" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">μ</mml:mi><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mi mathvariant="bold-italic">n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, the <italic>d</italic>-dimensional vector of means, <inline-formula><mml:math id="M17" name="1471-2105-11-546-i18" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi mathvariant="bold">Σ</mml:mi><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mi mathvariant="bold-italic">n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, the <italic>d </italic>× <italic>d </italic>covariance matrix, and <inline-formula><mml:math id="M18" name="1471-2105-11-546-i19" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>ν</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, the degrees of freedom, as defined in Lo et. al. [<xref ref-type="bibr" rid="B6">6</xref>].</p>
      <p>The set of metaclusters is denoted ℳ = {<italic>M</italic><sub>1</sub>, <italic>M</italic><sub>2</sub>, ..., <italic>M<sub>K</sub></italic>}. Each metacluster is itself a set of populations with the constraint that no metacluster can contain more than one population from a given sample. For each population, <inline-formula><mml:math id="M19" name="1471-2105-11-546-i20" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, we define a label <inline-formula><mml:math id="M20" name="1471-2105-11-546-i21" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> which can take a value between 1 and <italic>K</italic>, where <italic>K </italic>= max<italic><sub>n</sub></italic>(<italic>π<sub>n</sub></italic>). If <inline-formula><mml:math id="M21" name="1471-2105-11-546-i21" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> = <italic>k</italic>, population <inline-formula><mml:math id="M22" name="1471-2105-11-546-i20" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> belongs to metacluster <italic>k</italic>. Additionally the distance between a metacluster <italic>M<sub>k </sub></italic>and a population <inline-formula><mml:math id="M23" name="1471-2105-11-546-i22" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is denoted <inline-formula><mml:math id="M24" name="1471-2105-11-546-i23" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, which is the minimum distance between population <inline-formula><mml:math id="M25" name="1471-2105-11-546-i22" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and all populations that are already assigned to metacluster <italic>k</italic>. To enforce the one sample per metacluster constraint we set <inline-formula><mml:math id="M26" name="1471-2105-11-546-i24" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="M27" name="1471-2105-11-546-i25" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> for some <italic>m</italic>. We define the distance between population <italic>i </italic>in the <italic>n</italic>th sample and population <italic>j </italic>in the <italic>m</italic>th sample as <inline-formula><mml:math id="M28" name="1471-2105-11-546-i26" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>m</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">μ</mml:mi><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mi mathvariant="bold-italic">n</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">μ</mml:mi><mml:mi mathvariant="bold-italic">j</mml:mi><mml:mi mathvariant="bold-italic">m</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi mathvariant="bold">T</mml:mi></mml:mstyle></mml:msup><mml:msubsup><mml:mi mathvariant="bold">Σ</mml:mi><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">μ</mml:mi><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mi mathvariant="bold-italic">n</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi mathvariant="bold-italic">μ</mml:mi><mml:mi mathvariant="bold-italic">j</mml:mi><mml:mi mathvariant="bold-italic">m</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msqrt></mml:mrow></mml:math></inline-formula>, which is the <italic>Mahalanobis </italic>distance, assuming that the first argument (<inline-formula><mml:math id="M29" name="1471-2105-11-546-i20" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>) is a population assigned to metacluster <italic>k </italic>[<xref ref-type="bibr" rid="B24">24</xref>].</p>
      <p>To construct the metaclusters we:</p>
      <p>1. Set the number of metaclusters to <italic>K </italic>= max<italic><sub>n</sub></italic>(π<italic><sub>n</sub></italic>)</p>
      <p>2. Initialize the metaclusters with the <italic>K </italic>populations from sample <inline-formula><mml:math id="M30" name="1471-2105-11-546-i27" overflow="scroll"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> where <italic>n</italic><sub>0 </sub>= arg max<italic><sub>n</sub></italic>(π<italic><sub>n</sub></italic>). If there is more than one such sample, pick the one with the best likelihood or best separation of clusters (entropy).</p>
      <p>3. Let <inline-formula><mml:math id="M31" name="1471-2105-11-546-i28" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>arg</mml:mi><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:msub><mml:mi mathvariant="italic">D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>n</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, assign <inline-formula><mml:math id="M32" name="1471-2105-11-546-i29" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mi>j</mml:mi><mml:mi>n</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> to metacluster <italic>k</italic>.</p>
      <p>4. Repeat until each population is assigned to a metacluster.</p>
    </sec>
    <sec>
      <title>Simulation Study</title>
      <p>To further test our algorithm, we simulated ten data sets of <italic>N </italic>= 15000 events in three-dimensions from nine cell populations modeled as a multivariate-<italic>t </italic>mixture distribution with four degrees of freedom, following the approach of Lo <italic>et al</italic>., and fixed proportions drawn from a Dirichlet distribution with parameter <italic>α </italic>= (1, 1, 1, 1, 1, 1, 1, 1, 10) [<xref ref-type="bibr" rid="B6">6</xref>]. The population proportions were,</p>
      <p>
        <disp-formula id="bmcM2">
          <label>(2)</label>
          <mml:math id="M33" name="1471-2105-11-546-i30" overflow="scroll">
            <mml:mtable columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi mathvariant="bold">p</mml:mi>
                  </mml:mstyle>
                  <mml:mo>=</mml:mo>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mn>0.0477</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.0351</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.0101</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.0678</mml:mn>
                  <mml:mo>,</mml:mo>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mtext/>
                  <mml:mn>0.0756</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.0730</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.1330</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.0677</mml:mn>
                  <mml:mo>,</mml:mo>
                  <mml:mn>0.490</mml:mn>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
      </p>
      <p>Eight cell populations were distributed in three dimensional space at the eight corners of a cube, with one cell population located in the center of the cube (Figure <xref ref-type="fig" rid="F2">2a</xref>, top row). Real FCM data frequently contain one cell population that has higher density than the other cell populations in the mixture. We simulated this characteristic of FCM data by as-signing higher weight to the central population in our simulated data and it is reflected in the parameters of the Dirichlet. Simulated cell population locations ranged from zero to seven in arbitrary units, and corresponding populations has variance <italic>σ</italic><sup>2 </sup>= 0.25 across the ten data sets. The simulated data were transformed (Figure <xref ref-type="fig" rid="F2">2a</xref>, bottom row) by the inverse biexponential using different, randomly chosen transformation parameters for each sample ({<italic>a</italic>, <italic>c</italic>} ~ <italic>U</italic>(0, 1) and {<italic>b</italic>, <italic>d</italic>} <italic>U</italic>(0, 2)), where {<italic>X</italic>, <italic>Y</italic>} ~ <italic>U</italic>(<italic>p</italic>, <italic>q</italic>) denotes that variables <italic>X </italic>and <italic>Y </italic>are independently drawn from a Uniform distribution over the interval [<italic>p</italic>, <italic>q</italic>]. We applied our algorithm to this inverse-transformed data, optimizing transformation parameters for the generalized arcsinh, biexponential, generalized Box-Cox, and linlog transforms in order to recover <bold>Y</bold><sup>(<bold><italic>θ</italic></bold>)</sup>. We then compared the output of these transformations against the default-parameter versions of the biexponential and generalized arcsinh transforms, as well as the original untransformed data. To assess the performance of different transformations the data were normalized, gated using flowClust/flowMerge, and the discovered populations were clustered across data sets (metaclustered) [<xref ref-type="bibr" rid="B21">21</xref>]. We then measured the resulting intra-metacluster variability as well as the misclassification rate for individual events in the discovered populations, relative to their true class membership (Figure <xref ref-type="fig" rid="F2">2b-d</xref>) [<xref ref-type="bibr" rid="B4">4</xref>].</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Simulation study results</bold>. Results of transformations on simulated data. a) A single simulated sample is shown as a series of bivariate dot plot projections. Data are presented on the original scale (top row), and on the scale of the inverse biexponential transform (bottom row). Points represent individual events. b) Boxplots representing the distribution of misclassification rates of <italic>flowMerge </italic>models with K = 9 components fitted to the simulated data set under different transformations. c) Intra-cluster variability measured as the total sum of squared deviations for metaclustered populations identified by <italic>flowMerge </italic>under different transformations. d) Example bivariate projections of metaclusters for untransformed data (top row), default biexponential (second row), optimized biexponential (third row), optimized generalized arcsinh (fourth row), and default generalized arcsinh (fifth row). Corresponding metaclusters were selected where possible. Metaclusters are labeled as +/+, -/-, -/+ for artificial markers A and B. Ellipses represent 90th quantile contours of subpopulations.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-546-2"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <sec>
      <title>Follicular Lymphoma Data</title>
      <p>Our approach to data analysis of fluorescence and scatter data differs slightly, in that scatter data are normalized prior to transformation, while fluorescence data are normalized post-transformation, in accordance with common practice (Figure <xref ref-type="fig" rid="F1">1a-b</xref>). We examined the effects of parameter-optimized transformations compared to their default-parameter counterparts on visualization of cell populations in the scatter and fluorescence channels (Figure <xref ref-type="fig" rid="F3">3a, b</xref>). For scatter channels, differences between parameter-optimized, default, and untransformed data are clearly visible (Figure <xref ref-type="fig" rid="F3">3a</xref>). The optimized version of the biexponential, generalized arcsinh, and generalized Box-Cox, all provide improved visualization of cell populations than the default-parameter biexponential, generalized arcsinh, or the untransformed data. For the fluorescence channels, the data are put on a common scale following transformation (see Materials and Methods), and distinct differences can be seen between the optimized and default transformations (Figure <xref ref-type="fig" rid="F3">3b</xref>). Populations are better resolved following some transformations than others. The optimized biexponential improves visualization of cell populations compared to the biexponential with default parameters, while there is no observable difference between the default and optimized generalized arcsinh transformation. Other transformation show similarly variable results. Although differences between optimized and default transformations are subtle under visual inspection, these subtleties can have significant effects on model fitting and model selection during automated gating if they lead to violations of model assumptions (Figure <xref ref-type="fig" rid="F4">4a, b</xref>). For example, small deviations from symmetry in the shape of cell subpopulations can lead to selection of models with more components, more parameters, or different degrees of freedom, leading to different final gates.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Visualization of FCM data under different transformations</bold>. Visualization of flow cytometry data under different transformations. a) The FSC and SSC dimensions of a representative sample transformed using the biexponential, generalized arcsinh, generalized Box-Cox, and linlog transformations with optimized parameters. Untransformed and default-parameter generalized arcsinh and biexponential transformed data are shown for comparison. Some parameter-optimized trans-formations (biexponential and generalized Box-Cox in this example) improve visualization and resolution of the lymphocyte cell population when compared to default or untransformed data. b) Comparison of a fluorescence channel data under different parameter optimized and default transformations. In this example, the optimized biexponential and optimized linlog improve the resolution of the two populations in the CD19 vs CD5 channels, compared to the default generalized arcsinh or default biexponential. Points represent individual events, contours represent the two-dimensional kernel density estimate of the data.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-546-3"/>
      </fig>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Variation in cell subpopulation locations</bold>. Variation in population location measured as the sum of squared distances between population centers for a) lymphocyte populations in the FSC vs SSC channels. b) metaclusters of cell populations in the fluorescence channels.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-546-4"/>
      </fig>
      <p>To obtain a quantitative measure of the effect of different transformations on the automated analysis of real-world flow cytometry data, we proceeded to perform automated gating populations in the scatter and fluorescence channels, as described in the Methods. We measured the variability between discovered populations by metaclustering them across samples, and measuring the intra-metacluster variability as the sum of squared deviations (Figure <xref ref-type="fig" rid="F4">4a, b</xref>). There were minimal differences in the variability of the lymphocyte populations between different transformations applied to the scatter channels (Figure <xref ref-type="fig" rid="F4">4a</xref>). The optimized generalized arcsinh and optimized generalized Box-Cox transformations had the lowest variation in metaclusters, performing better than the default generalized arcsinh, or the standard of no transformation. In contrast, larger differences in variability were observed between transformations for populations in the fluorescence channels (Figure <xref ref-type="fig" rid="F4">4b</xref>). The optimized biexponential, optimized generalized Box-Cox, and default biexponential exhibited the lowest intra-metacluster variation, whereas the optimized linlog, log, and default generalized arcsinh exhibited the highest intra-metacluster variation. However, on the scale of the scatter data, it appears that the differences between transformations are not large.</p>
      <p>The differences between lymphocyte metaclusters in the scatter dimensions are readily seen to be minimal when visualizing the metaclusters directly on the original scale (Figure <xref ref-type="fig" rid="F5">5</xref>, contour show's 90th percentile of the population). Each metacluster contains all ten lymphocyte populations from the ten samples in the data set. Similarly, metaclusters in the fluorescence channels are visualized directly on the transformed scale (Figure <xref ref-type="fig" rid="F6">6a-g</xref>, contours show 90th percentile of the populations). The metaclusters of the primary cell populations in the samples are shown (CD3-/CD19+/CD5+ and CD3+/CD19-/CD5-), represented as a series of bivariate projections for each transformation examined. Interestingly, with the exception of the default biexponential transform, all metaclusters contain representative cell populations from all samples in the data set. Additionally, the total number of metaclusters varies between transformations (shown in brackets), indicating that the principal source of variation in the metaclustering is due to cell populations represented as outliers in the flowClust/flowMerge gating, rather than due differences in the well-defined, primary cell populations in the samples.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Metaclusters in the scatter channels</bold>. Metaclusters of lymphocyte populations in the FSC and SSC dimensions for four optimized and three default transformations. We observe little difference between the transformations in the forward and side scatter dimensions for gating lymphocyte populations, suggesting that the primary benefit in the FSC vs SSC dimensions is for data visualization. Contours represent the 90th quantiles of the cell subpopulation distributions.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-546-5"/>
      </fig>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Metaclusters in the fluorescence channels</bold>. Metaclusters of cell populations defined in the fluorescence channels of the lymphoma data under different transformations. Only the primary cell populations are shown for comparison (CD19+/CD3-/CD5+ and CD19-/CD3+/CD5-). The number of metaclusters for the transformed data is shown in brackets. The number of cell populations in a metacluster is shown above the plot. Contours represent the 90th percentiles of the cell subpopulation distributions.</p>
        </caption>
        <graphic xlink:href="1471-2105-11-546-6"/>
      </fig>
    </sec>
    <sec>
      <title>Simulation</title>
      <p>Simulated data allows access to the "true" class memberships of individual events that are not available with real-world data, and can help to better understand the effects of transformation and parameter selection on automated gating. We again briefly describe our approach here. We simulated ten data sets, transforming each with the inverse of the biexponential transform using randomly chosen parameter values, as described in the methods (Figure <xref ref-type="fig" rid="F2">2a</xref>). We then applied our algorithm to the inverse transformed data to estimate optimal parameters under different transformations and again transformed the inverse-transformed data using those estimated parameters and the appropriate transformation. The data output by this process, which should reflect the distribution of the original data, was subjected to automated gating. By comparing the true class membership of events in the original data against the class membership of events gated by flowClust/flowMerge, we computed the misclassification rate of the gating model under different optimized and default transformations (Figure <xref ref-type="fig" rid="F2">2b</xref>). When the optimized transformation was of the same family as the inverse transformation (i.e. generalized arcsinh or biexponential) we observed misclassification rates comparable to the rates obtained for the untransformed data (i.e. the gold standard data transformed using the correct transformation parameters) (mean misclassification rate of 10.7%, 10.0% and 10.1% for untransformed data, optimized biexponential and optimized generalized arcsinh, respectively) (Figure <xref ref-type="fig" rid="F2">2b</xref>). In contrast, the optimized generalized Box-Cox, optimized linlog, as well as the default generalized arcsinh and biexponential had considerably increased misclassification rates with higher variability across the simulated samples (mean misclassification rate of 23.3%, 11.8%, 12.7%, and 13.2% for optimized generalized Box-Cox, optimized linlog and default generalized arcsinh, default biexponential, respectively) (Figure <xref ref-type="fig" rid="F2">2b</xref>). The poor performance of the optimized generalized Box-Cox is not surprising in this case, since the biexponential inverse-transformation applied to the data was quite different from the generalized Box-Cox transform. This demonstrates that optimization of the transformation parameters together with selection of an appropriate transformation can lead to significant improvements in model fitting during automated gating that compare favourably to results obtained for the untransformed data. Furthermore, the estimated transformation parameters compare favourable with the true transformation parameters (Additional File <xref ref-type="supplementary-material" rid="S3">3</xref>), demonstrating that our assumption of a global multivariate Gaussian distribution is acceptable for the purpose of transformation.</p>
      <p>Following extraction of discovered cell populations and metaclustering, we observed the lowest intra-cluster variability for the optimized generalized arcsinh and optimized biexponential transformations, followed by the baseline of no data transformation, indicating that parameter optimization can reduce inter-sample variability and aid population matching (Figure <xref ref-type="fig" rid="F2">2c</xref>). The largest inter-sample variability following meta-clustering was observed for the optimized generalized Box-Cox, default generalized arcsinh, and optimized linlog transformations (Figure <xref ref-type="fig" rid="F2">2c</xref>). Selected metaclusters obtained from default and parameter-optimized transformations demonstrate that parameter optimized transformations can lead to better population identification in the automated gating step, and consequently lower variability metaclusters (Figure <xref ref-type="fig" rid="F2">2d</xref>).</p>
    </sec>
    <sec>
      <title>Software and Availability</title>
      <p>We have implemented parameter-optimization routines for the biexponential, linlog, generalized arcsinh, and generalized Box-Cox transformations in the R package, <italic>flowTrans</italic>. This package integrates with the existing FCM data analysis tools in BioConductor and uses existing data structures data manipulation paradigms from the <italic>flowCore </italic>framework [<xref ref-type="bibr" rid="B22">22</xref>,<xref ref-type="bibr" rid="B25">25</xref>]. The package is freely available at <ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org/packages/release/bioc/html/flowTrans.html">http://www.bioconductor.org/packages/release/bioc/html/flowTrans.html</ext-link>.</p>
    </sec>
  </sec>
  <sec>
    <title>Discussion</title>
    <p>Ideally, all cell subpopulations in an FCM sample would be well-separated to facilitate gating. In practice, this is rarely, if ever the case. Real flow data typically consists of a mixture of complicated distributions that are asymmetric, frequently overlapping, with cell populations whose variances are dependent on their mean fluorescence intensities. A variety of automated gating algorithms have been proposed to identify distinct cell sub-populations [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B6">6</xref>-<xref ref-type="bibr" rid="B10">10</xref>]. Most of these automated approaches function under the assumption that the data has been transformed prior to the automated gating step. Others even include data transformation as part of the gating procedure [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B10">10</xref>]. The global data transformation step treats all cells and cell subpopulations equally, and hides an implicit assumption of a common error model across all cells and cell subpopulations. The problem is that we do not know what the correct error model is for FCM data, and so it is simply ignored. In this paper, our approach to parameter optimization attempts to make this assumption more explicit. We assume that, on the transformed scale, the global data distribution can be approximated by a multivariate Gaussian distribution. Although the data are clearly not multivariate normal, as typical FCM data are multimodal and best represent by a mixture model, we transform the data towards normality to make the distribution more symmetric, mitigate the impact of outliers, and to have an objective criterion to use for estimating transformation parameters. Our simulation study shows that our assumption of a common Gaussian distribution allows us to obtain reasonable estimates of the optimal transformation parameters even when the Gaussian assumption is violated. Only subsequently do we take on the task accurately modelling the data using a model-based automated gating algorithm. We leave the work of fitting a mixture model to resulting transformed data to the automated gating algorithm.</p>
    <p>We have examined the impact of the choice of transformation and its corresponding parameters on the automated gating procedure. Transforming the data towards normality reduces the influence of outlier events and our simulations have shown that optimizing transformation parameters in this way can improve gating and cell subpopulation discovery when compared to applying a naive transformation with default parameter values. Optimization of the parameters leads to lower misclassification rates, improved cell population identification, lower inter-sample variability and fewer outliers than blindly applying default transformation parameters. In our simulations, data were transformed with the biexponential function using randomly chosen parameters. Only parameter-optimized transformations from the same family (optimized generalized arcsinh and optimized biexponential) regenerated a data distribution similar to the untransformed data, as exhibited by comparable gating misclassification rates (Figure <xref ref-type="fig" rid="F2">2b</xref>). The optimized linlog and generalized Box-Cox transformations did not have the flexibility to transform the data back to the original distribution, leading to biases in the automated gating step. Although the differences in misclassification rate are only a few percent, they could introduce significant variation on downstream analysis, especially in large-sample situations, where many data sets need to be analyzed in an automated manner.</p>
    <p>Our analysis of a subset of real-world flow cytometry data set derived from lymph node biopsies of individuals with follicular lymphoma demonstrated similar results to those obtained using simulated data. Optimizing transformation parameters in order to make the transformed FCM data more normal-like can improve data visualization and cell subpopulation identification in certain cases. However the improvement in performance is data- dependent, and it is unclear how to determine in advance which samples benefit from such an approach as compared to applying a standard FCM transformation. Addressing this problem is the subject of future work. In the cases examined in this study, transformation of the scatter dimensions via a parameter-optimized generalized arcsinh or biexponential transformation generally improves cell subpopulation visualization (Figure <xref ref-type="fig" rid="F3">3</xref>). Therefore, in situations where scatter data are to be gated manually we argue in favour of such an approach. However, we note that under an automated gating scheme, the differences between transformations are marginal on the scale of the data, and the benefits are minimal, particularly when FSC and SSC cell populations are well defined. This is in accordance with what is typically seen in FCM data analysis [<xref ref-type="bibr" rid="B14">14</xref>].</p>
    <p>Cell subpopulation identification in the fluorescence channels benefits more from parameter- optimized transformation than in the scatter channels. However, again the choice of transformation is data-dependent. While the greatest improvement in metacluster variability was observed for the parameter-optimized generalized arcsinh transformation in the case of scatter channels, here the greatest improvement is observed for the parameter-optimized biexponential transformation and parameter-optimized generalized Box-Cox transformation. The intra-metacluster variation for these transforms is lower than for the log transformation, but only marginally lower than for the default- parameter biexponential transformation. Despite this, closer examination of the metaclusters generated from the default biexponential transformed data shows that one of the CD3-/CD5+/CD19+ cell subpopulations was not captured by the CD3-/CD5+/CD19+ metacluster. Additionally, the default biexponential transformed data leads to seven metaclusters, compared to six metaclusters obtained for the optimized biexponential transformed data. These additional metaclusters capture outlier cell populations which are not of interest in this particular experiment. In general, the metaclusters representing the primary cell subpopulations in this data all capture representatives from each of the ten samples. The predominant source of intra-metacluster variability is derived from the metaclusters corresponding to outlier cell populations. Therefore, in situations where an automated gating and analysis approach is undertaken, we recommend applying a parameter-optimized data transformation such as the optimized biexponential, rather than the default biexponential, since it has the potential to improve cell subpopulation discovery and matching across multiple samples. This is likely to be a greater concern in large-sample situations than when a small number of samples are to be analyzed manually.</p>
    <p>Our metaclustering approach has been designed to work specifically for data gated using the <italic>flowClust/flowMerge </italic>algorithms. The constraint limiting each metacluster to one cell population per sample is predicated on the assumption that the gating algorithm (<italic>flowMerge </italic>in our case) represents each distinct cell population by a unique mixture component. Generally speaking, this is a safe assumption in the case of the <italic>flowMerge </italic>algorithm, which has been designed to identify and represent distinct cell populations by unique mixture components [<xref ref-type="bibr" rid="B4">4</xref>]. However, the metaclustering algorithm would have to be modified if the gating algorithm were changed.</p>
    <p>We explored alternative approaches to parameter estimation that included preselection of a sub-population of events and optimizing transformation parameters with respect to the subpopulation. How-ever, this approach proved ineffective, since preselection effectively removed outlier events. It is these outliers that cause problems for downstream automated gating approaches, and thus should be considered in the transformation step. The decision to transform the data towards a multivariate Gaussian distribution is supported by our ability to accurately recover the true transformation parameters in our simulation study, even though the original data distribution is clearly derived from a multivariate mixture model. Our approach could be extended in a number of ways analogous to <italic>flowClust</italic>, either by embedding the transformations within the gating step, thus selecting transformation parameters maximize the likelihood of a K-component mixture rather than a single component density, or by modelling the data with a more robust distribution such as the multivariate-<italic>t</italic>. This approach could have the benefit of generating less variable parameter estimates, though likely at the expense of computation time.</p>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>Although the idea of optimizing transformations for FCM data is not new, to date, there has been no systematic comparison of FCM data transformations examining their performance in an automated data analysis setting [<xref ref-type="bibr" rid="B6">6</xref>]. We have developed criteria for optimizing the parameters of transformations commonly used for preprocessing and visualization of FCM data, designed to transform the data towards a more multivariate normal and symmetric global data distribution. We have shown that these parameter-optimized transformations can improve data visualization, population discovery, and metaclustering, relative to their default-parameter counterparts in certain sample-specific cases. Parameter optimization of the generalized Box-Cox transform has been previously implemented within an automated gating framework implementing a mixture modelling approach (<italic>flowClust</italic>) [<xref ref-type="bibr" rid="B6">6</xref>]. While it would be of interest to implement a similar strategy for the other commonly used flow cytometry data transformations, our goal here has been to examine the influence of global transformation on the automated gating step of high throughput FCM analysis. Our software allows the user to quickly examine the effects of different parameter-optimized transformations on the data, and defer the computation-intensive gating step to downstream analysis. Our findings showed that the optimized generalized arcsinh transformation had the lowest intra-sample variability between populations for the scatter channels. However, substantive differences in variation were subtle and rare across the different transformations in the scatter channels. In contrast, the optimized biexponential transform had the lowest variability for the fluorescence channels. This transformation is in accordance with current best practices. Therefore we would recommend, in the absence of additional knowledge to suggest a given data transformation, the parameter-optimized versions of the biexponential transform for fluorescence channel data, over the default-parameter counterpart. In situations where many samples need to be processed in an automated manner, the parameter-optimized generalized arcsinh may be a better choice over the current standard practice of not transforming the scatter data, thus reaping the benefits of occasional improvements in the automated gating step. Due to its simplicity, our optimization algorithm could be readily implemented in other widely available tools such as <italic>FlowJo </italic>and <italic>WinList</italic>, and indeed, efforts are currently underway to tie <italic>FlowJo </italic>more closely to the <italic>R </italic>computing environment [<xref ref-type="bibr" rid="B11">11</xref>].</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>GF designed experiments, performed analysis, and contributed to manuscript preparation. RG designed experiments and contributed to manuscript preparation. JMP contributed to manuscript preparation. AW contributed the clinical FCM data.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Examples of common transformations with typical parameters</bold>. Examples of the generalized Box-Cox (blue, <italic>θ </italic>= 0.158), linlog (red, <italic>θ </italic>= 56.9), biexponential (black, <italic>a </italic>= 0.49, <italic>b </italic>= 0.99, <italic>c </italic>= 1, <italic>d </italic>= 0.01, <italic>f </italic>= 0, <italic>w </italic>= 2.3), and generalized arcsinh (green, <italic>a </italic>= 1, <italic>b </italic>= 0.052) transformations using common parameter values. The chosen parameters are selected from an optimized fit of each transformation to FSC vs SSC follicular lymphoma data.</p>
      </caption>
      <media xlink:href="1471-2105-11-546-S1.EPS" mimetype="application" mime-subtype="postscript">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p><bold>The biexponential transformation is weakly identifiable</bold>. The biexponential transformation with full parameterization is weakly identifiable. a) A bivariate normal distribution on the original scale. b) Original data transformed with the inverse-biexponential using parameters <italic>a </italic>= 1, <italic>b </italic>= 1, <italic>c </italic>= 1, <italic>d </italic>= 1 10<sup>-10</sup>, <italic>f </italic>= 0, <italic>w </italic>= 0. c) Inverse-transformed data transformed with the biexponential using the true parameters <italic>a </italic>= 1; <italic>b </italic>= 1, <italic>c </italic>= 1, <italic>d </italic>= 1 × 10<sup>-10</sup>, <italic>f </italic>= 0, <italic>w </italic>= 0. d) Inverse-transformed data transformed with the biexponential using alternate parameters <italic>c' </italic>= 1 × 10<sup>-10</sup>, <italic>d' </italic>= 1 × 10<sup>-10</sup>, <italic>f' </italic>= -1. When parameters <italic>c' </italic>and <italic>d' </italic>are near zero, if <italic>f' </italic>≈ <italic>c </italic>and <italic>d' </italic>is near zero, the two transformations are virtually indistinguishable.</p>
      </caption>
      <media xlink:href="1471-2105-11-546-S2.EPS" mimetype="application" mime-subtype="postscript">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S3">
      <caption>
        <title>Additional file 3</title>
        <p><bold>Residuals of estimated biexponential parameters</bold>. Boxplots showing the difference between true and estimated biexponential parameters on ten simulated data sets. Although the optimized estimates are variable for parameters b, d, the misclassification rates of fitted models demonstrate that this bias doesn't negatively impact the subsequent gating.</p>
      </caption>
      <media xlink:href="1471-2105-11-546-S3.EPS" mimetype="application" mime-subtype="postscript">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>The authors wish to acknowledge the help of Dr. Randy Gascoyne and Ryan Brinkman for providing the lymphoma data set. This work was funded by a CIHR bridge funding, NIH grant R01-EB008400 and an establishment grant from the Fonds de la recherche en santé du Quebec (FRSQ). We thank Drs. Thomas Lumley and Ryan Brinkman for their feedback during manuscript preparation. We also sincerely thank the reviewers for their comments and suggestions towards improving the manuscript.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="other">
        <name>
          <surname>Walther</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Zimmerman</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Moore</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Parks</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Meehan</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Belitskaya</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Pan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Herzenberg</surname>
          <given-names>L</given-names>
        </name>
        <article-title>Automatic clustering of flow cytometry data with density-based merging</article-title>
        <source>Adv Bioinformatics</source>
        <year>2009</year>
        <fpage>686759</fpage>
        <pub-id pub-id-type="pmid">20069107</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pyne</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Rossin</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>TI</given-names>
        </name>
        <name>
          <surname>Maier</surname>
          <given-names>LM</given-names>
        </name>
        <name>
          <surname>Baecher-Allan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>McLachlan</surname>
          <given-names>GJ</given-names>
        </name>
        <name>
          <surname>Tamayo</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Hafler</surname>
          <given-names>DA</given-names>
        </name>
        <name>
          <surname>Jager</surname>
          <given-names>PLD</given-names>
        </name>
        <name>
          <surname>Mesirov</surname>
          <given-names>JP</given-names>
        </name>
        <article-title>Automated high-dimensional flow cytometric data analysis</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2009</year>
        <volume>106</volume>
        <issue>21</issue>
        <fpage>8519</fpage>
        <lpage>24</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.0903028106</pub-id>
        <pub-id pub-id-type="pmid">19443687</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="other">
        <name>
          <surname>Rogers</surname>
          <given-names>WT</given-names>
        </name>
        <name>
          <surname>Holyst</surname>
          <given-names>HA</given-names>
        </name>
        <article-title>FlowFP: A Bioconductor Package for Fingerprinting Flow Cytometric Data</article-title>
        <source>Adv Bioinformatics</source>
        <year>2009</year>
        <fpage>193947</fpage>
        <pub-id pub-id-type="pmid">19956416</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="other">
        <name>
          <surname>Finak</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Bashashati</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gottardo</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Merging mixture components for cell population identification in flow cytometry</article-title>
        <source>Advances in Bioinformatics</source>
        <year>2009</year>
        <fpage>247646</fpage>
        <pub-id pub-id-type="pmid">20049161</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gottardo</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>RR</given-names>
        </name>
        <name>
          <surname>Luta</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Wand</surname>
          <given-names>MP</given-names>
        </name>
        <article-title>Recent bioinformatics advances in the analysis of high throughput flow cytometry data</article-title>
        <source>Adv Bioinformatics</source>
        <year>2009</year>
        <fpage>461763</fpage>
        <pub-id pub-id-type="pmid">20169120</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lo</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gottardo</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Automated gating of flow cytometry data via robust model-based clustering</article-title>
        <source>Cytometry Part A</source>
        <year>2008</year>
        <volume>73</volume>
        <issue>4</issue>
        <fpage>321</fpage>
        <pub-id pub-id-type="doi">10.1002/cyto.a.20531</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Boedigheimer</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Ferbas</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Mixture modeling approach to flow cytometry data</article-title>
        <source>Cytometry A</source>
        <year>2008</year>
        <volume>73</volume>
        <issue>5</issue>
        <fpage>421</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="pmid">18383311</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Naumann</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Luta</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Wand</surname>
          <given-names>MP</given-names>
        </name>
        <article-title>The curvHDR method for gating flow cytometry samples</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>44</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-11-44</pub-id>
        <pub-id pub-id-type="pmid">20096119</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="other">
        <name>
          <surname>Rogers</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Moser</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Holyst</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Bantly</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Cytometric fingerprinting: Quantitative characterization of multivariate distributions</article-title>
        <source>Cytometry</source>
        <year>2008</year>
        <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/18383310">http://www.ncbi.nlm.nih.gov/pubmed/18383310</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Naumann</surname>
          <given-names>U</given-names>
        </name>
        <name>
          <surname>Wand</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Automation in high-content flow cytometry screening</article-title>
        <source>Cytometry Part A</source>
        <year>2009</year>
        <volume>75</volume>
        <fpage>789A797</fpage>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gosink</surname>
          <given-names>JJ</given-names>
        </name>
        <name>
          <surname>Means</surname>
          <given-names>GD</given-names>
        </name>
        <name>
          <surname>Rees</surname>
          <given-names>WA</given-names>
        </name>
        <name>
          <surname>Su</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Rand</surname>
          <given-names>HA</given-names>
        </name>
        <article-title>Bridging the Divide between Manual Gating and Bioinformatics with the Bioconductor Package flowFlowJo</article-title>
        <source>Adv Bioinformatics</source>
        <year>2009</year>
        <fpage>809469</fpage>
        <pub-id pub-id-type="pmid">19956421</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Parks</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Roederer</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Moore</surname>
          <given-names>W</given-names>
        </name>
        <article-title>A new" Logicle" display method avoids deceptive effects of logarithmic scaling for low signals and compensated data</article-title>
        <source>Cytometry Part A</source>
        <year>2006</year>
        <volume>69</volume>
        <issue>6</issue>
        <fpage>541</fpage>
        <pub-id pub-id-type="doi">10.1002/cyto.a.20258</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bagwell</surname>
          <given-names>C</given-names>
        </name>
        <article-title>Hyperlog-a flexible log-like transform for negative, zero, and positive valued data</article-title>
        <source>Cytometry A</source>
        <year>2005</year>
        <volume>64</volume>
        <fpage>34</fpage>
        <lpage>42</lpage>
        <pub-id pub-id-type="pmid">15700280</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="other">
        <name>
          <surname>Bashashati</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>RR</given-names>
        </name>
        <article-title>A survey of flow cytometry data analysis methods</article-title>
        <source>Adv Bioinformatics</source>
        <year>2009</year>
        <fpage>584603</fpage>
        <pub-id pub-id-type="pmid">20049163</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Novo</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Wood</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Flow cytometry histograms: transformations, resolution, and display</article-title>
        <source>Cytometry-Part A</source>
        <year>2008</year>
        <volume>73</volume>
        <issue>8</issue>
        <fpage>685</fpage>
        <lpage>692</lpage>
        <pub-id pub-id-type="doi">10.1002/cyto.a.20592</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Herzenberg</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Tung</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Moore</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Herzenberg</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Parks</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Interpreting flow cytometry data: a guide for the perplexed</article-title>
        <source>Nature Immunology</source>
        <year>2006</year>
        <volume>7</volume>
        <issue>7</issue>
        <fpage>681</fpage>
        <pub-id pub-id-type="doi">10.1038/ni0706-681</pub-id>
        <pub-id pub-id-type="pmid">16785881</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dvorak</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Banks</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Modified box-cox transform for modulating the dynamic range of flow cytometry data</article-title>
        <source>Cytometry Part B: Clinical Cytometry</source>
        <year>1989</year>
        <volume>10</volume>
        <issue>6</issue>
        <fpage>811</fpage>
        <lpage>813</lpage>
        <pub-id pub-id-type="doi">10.1002/cyto.990100622</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lo</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Hahne</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gottardo</surname>
          <given-names>R</given-names>
        </name>
        <article-title>flowClust: a Bioconductor package for automated gating of flow cytometry data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>145</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-10-145</pub-id>
        <pub-id pub-id-type="pmid">19442304</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Box</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Cox</surname>
          <given-names>D</given-names>
        </name>
        <article-title>An analysis of transformations</article-title>
        <source>Journal of the Royal Statistical Society. Series B (Methodological)</source>
        <year>1964</year>
        <volume>26</volume>
        <issue>2</issue>
        <fpage>211</fpage>
        <lpage>252</lpage>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ihaka</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gentleman</surname>
          <given-names>R</given-names>
        </name>
        <article-title>R: A language for data analysis and graphics</article-title>
        <source>Journal of computational and graphical statistics</source>
        <year>1996</year>
        <volume>5</volume>
        <issue>3</issue>
        <fpage>299</fpage>
        <lpage>314</lpage>
        <pub-id pub-id-type="doi">10.2307/1390807</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="other">
        <name>
          <surname>Hahne</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Khodabakhshi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Bashashati</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Gascoyne</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Weng</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Seyfert-Margolis</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Bourcier</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Asare</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lumley</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Gentleman</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Per-channel basis normalization methods for flow cytometry data</article-title>
        <source>Cytometry A</source>
        <year>2009</year>
        <ext-link ext-link-type="uri" xlink:href="http://www.google.ca/search?client=safari&amp;rls=en-us&amp;q=Per-channel+basis+normalization+methods+for+flow+cytometry+data&amp;ie=UTF-8&amp;oe=UTF-8&amp;redir_esc=&amp;ei=vYi8S4fpEYmC9ASLqaH0Bw">http://www.google.ca/search?client=safari&amp;rls=en-us&amp;q=Per-channel+basis+normalization+ methods+for+flow+cytometry+data&amp;ie=UTF-8&amp;oe=UTF-8&amp;redir_esc=&amp;ei=vYi8S4fpEYmC9ASLqaH0Bw</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gentleman</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Carey</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Bates</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Bolstad</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Dettling</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Dudoit</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ellis</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Gautier</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Ge</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Gentry</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Bioconductor: open software development for computational biology and bioinformatics</article-title>
        <source>Genome Biol</source>
        <year>2004</year>
        <volume>5</volume>
        <issue>10</issue>
        <fpage>R80</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2004-5-10-r80</pub-id>
        <pub-id pub-id-type="pmid">15461798</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Johnson</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Hierarchical clustering schemes</article-title>
        <source>Psychometrika</source>
        <year>1967</year>
        <volume>32</volume>
        <issue>3</issue>
        <fpage>241</fpage>
        <lpage>254</lpage>
        <pub-id pub-id-type="doi">10.1007/BF02289588</pub-id>
        <pub-id pub-id-type="pmid">5234703</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mahalanobis</surname>
          <given-names>P</given-names>
        </name>
        <article-title>On the generalized distance in statistics</article-title>
        <source>Proceedings of the National Institute of Science, Calcutta</source>
        <year>1936</year>
        <volume>12</volume>
        <fpage>49</fpage>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hahne</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>LeMeur</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Brinkman</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Ellis</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Haaland</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Sarkar</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Spidlen</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Strain</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Gentleman</surname>
          <given-names>R</given-names>
        </name>
        <article-title>flowCore: a Bioconductor package for high throughput flow cytometry</article-title>
        <source>BMC Bioinformatics</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>106</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-10-106</pub-id>
        <pub-id pub-id-type="pmid">19358741</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
