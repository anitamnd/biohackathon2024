<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10318387</article-id>
    <article-id pub-id-type="pmid">37354496</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad399</article-id>
    <article-id pub-id-type="publisher-id">btad399</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>S-leaping: an efficient downsampling method for large high-throughput sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-5333-6729</contrib-id>
        <name>
          <surname>Kuwahara</surname>
          <given-names>Hiroyuki</given-names>
        </name>
        <aff><institution>Computer, Electrical and Mathematical Sciences and Engineering Division (CEMSE), Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology (KAUST)</institution>, Thuwal 23955-6900, <country country="SA">Saudi Arabia</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-7108-3574</contrib-id>
        <name>
          <surname>Gao</surname>
          <given-names>Xin</given-names>
        </name>
        <aff><institution>Computer, Electrical and Mathematical Sciences and Engineering Division (CEMSE), Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology (KAUST)</institution>, Thuwal 23955-6900, <country country="SA">Saudi Arabia</country></aff>
        <xref rid="btad399-cor1" ref-type="corresp"/>
        <!--xin.gao@kaust.edu.sa-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Alkan</surname>
          <given-names>Can</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad399-cor1">Corresponding author. Computer, Electrical and Mathematical Sciences and Engineering Division (CEMSE), Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology (KAUST), Thuwal 23955-6900, Saudi Arabia. E-mail: <email>xin.gao@kaust.edu.sa</email> (X.G.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-24">
      <day>24</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>7</issue>
    <elocation-id>btad399</elocation-id>
    <history>
      <date date-type="received">
        <day>13</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>19</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>23</day>
        <month>6</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>03</day>
        <month>7</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad399.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Sequencing coverage is among key determinants considered in the design of omics studies. To help estimate cost-effective sequencing coverage for specific downstream analysis, downsampling, a technique to sample subsets of reads with a specific size, is routinely used. However, as the size of sequencing becomes larger and larger, downsampling becomes computationally challenging.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Here, we developed an approximate downsampling method called s-leaping that was designed to efficiently and accurately process large-size data. We compared the performance of s-leaping with state-of-the-art downsampling methods in a range of practical omics-study downsampling settings and found s-leaping to be up to 39% faster than the second-fastest method, with comparable accuracy to the exact downsampling methods. To apply s-leaping on FASTQ data, we developed a light-weight tool called fadso in C. Using whole-genome sequencing data with 208 million reads, we compared fadso’s performance with that of a commonly used FASTQ tool with the same downsampling feature and found fadso to be up to 12% faster with 21% lower memory usage, suggesting fadso to have up to 40% higher throughput in a parallel computing setting.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The C source code for s-leaping, as well as the fadso package is freely available at <ext-link xlink:href="https://github.com/hkuwahara/sleaping" ext-link-type="uri">https://github.com/hkuwahara/sleaping</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>King Abdullah University of Science and Technology</institution>
            <institution-id institution-id-type="DOI">10.13039/501100004052</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>FCC/1/1976-44-01</award-id>
        <award-id>FCC/1/1976-45-01</award-id>
        <award-id>URF/1/4663-01-01</award-id>
        <award-id>REI/1/5202-01-01</award-id>
        <award-id>REI/1/4940-01-01</award-id>
        <award-id>RGC/3/4816-01-01</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Downsampling is a valuable technique that is routinely used to evaluate the design of high-throughput sequencing (HTS) studies. Be it whole-genome sequencing (WGS), RNA sequencing, or DNA methylation sequencing, researchers can use downsampling to conveniently and economically sample HTS data with various sizes. Among recent use cases of downsampling is low-coverage WGS (lcWGS), an emergent alternative to SNP genotyping arrays in population genetics, thanks to a steady decrease in sequencing costs. Indeed, because downsampling can efficiently generate lcWGS data from WGS data, it has been used to evaluate the performance of genotype imputation methods—inference methods that increase genotype density by predicting unobserved genotypes (<xref rid="btad399-B5" ref-type="bibr">Gilly <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad399-B10" ref-type="bibr">Li <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="btad399-B12" ref-type="bibr">Lou <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="btad399-B14" ref-type="bibr">Rubinacci <italic toggle="yes">et al.</italic> 2021</xref>)—and to determine cost-effective sequencing coverage rates for a range of computational medicine applications (<xref rid="btad399-B6" ref-type="bibr">Goldfeder <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad399-B7" ref-type="bibr">Homburger <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad399-B1" ref-type="bibr">Davies <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="btad399-B15" ref-type="bibr">Sun <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>There are a number of downsampling tools available for HTS data, but with different specifications. For example, the downsampling features in picard, GATK (<xref rid="btad399-B13" ref-type="bibr">McKenna <italic toggle="yes">et al.</italic> 2010</xref>), and SAMtools (<xref rid="btad399-B9" ref-type="bibr">Li <italic toggle="yes">et al.</italic> 2009</xref>) select reads at an equal probability. Although this type of downsampling is computationally efficient with a very small memory footprint, the user cannot ensure that the obtained data have a desired number of reads. Another type of downsampling is reservoir sampling, which makes a single pass through an HTS file and unbiasedly samples the specific number of reads without having to know the total number of reads. This downsampling approach is used in seqtk (<ext-link xlink:href="https://github.com/lh3/seqtk" ext-link-type="uri">https://github.com/lh3/seqtk</ext-link>), a most commonly used tool to downsample FASTQ data. Because reservoir sampling allows sampling of exactly <italic toggle="yes">k</italic> elements from a population of unknown size <italic toggle="yes">n</italic> in a single pass, this article focuses on this type of downsampling.</p>
    <p>Numerous algorithms have been proposed for reservoir sampling. Waterman developed the direct approach called Algorithm R (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>) that scans and processes each element for random selection. Although this algorithm is simple, it demands the generation of one unit uniform random variate per element, which becomes inefficient when selecting small subsets of the data. To deal with such cases, a different type of reservoir sampling was developed to focus on the number of steps it takes to select the next element, rather than processing every single element (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>). To process large HTS datasets, with hundreds of millions, or even billions, of reads per sample, however, the use of the existing reservoir-sampling methods is found to be inefficient, rendering the development of a more computationally efficient method not only essential but also necessary.</p>
    <p>Here, we developed s-leaping, a method that focuses on downsampling of large datasets by approximating reservoir sampling. By applying the concept of leaping to downsampling, s-leaping simplifies the sampling procedure and reduces the average number of random numbers it requires. Comparing s-leaping’s performance with that of several exact reservoir-sampling methods for a task of selecting 10–40 million elements from a population of 100–500 million, we found s-leaping to be up to 39% faster than the most efficient exact method, while showing no sign of deteriorating accuracy. We implemented s-leaping in a tool called fadso that specializes in downsampling of FASTQ data, compared its efficiency against that of seqtk, and found fadso to be more efficient in terms of computation time and memory usage than seqtk.</p>
  </sec>
  <sec>
    <title>2 Results</title>
    <sec>
      <title>2.1 Theoretical evaluation of reservoir-sampling methods</title>
      <p>We define reservoir sampling as a task to randomly and unbiasedly choose <italic toggle="yes">k</italic> elements from a file holding elements of unknown size <italic toggle="yes">n</italic> in a single pass. In Algorithm R, the reservoir initially comprises the first <italic toggle="yes">k</italic> elements, and for all <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, the <italic toggle="yes">i-</italic>th element is selected at probability <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> to replace a randomly selected element in the reservoir. At the end of <italic toggle="yes">j-</italic>th step (<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>), Algorithm R ensures that each element in the reservoir has an equal probability (i.e. <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>) of being selected and kept in the reservoir (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>). Another type of reservoir sampling focuses on the number of steps it takes to select the next element, which we call next selection method. A next selection method randomly makes two decisions per selected element: the step size to the next selection and the index of an element to be replaced in the reservoir.</p>
      <p>Both approaches have pros and cons. Computation-wise, the selection operation is simpler in Algorithm R than the next selection method. Indeed, direct sampling of step size in the next selection method is complicated and existing algorithms often use rejection sampling with easier envelope functions (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>). Selection-wise, after processing the first <italic toggle="yes">k</italic> elements, Algorithm R requires one random number per element, whereas the next selection method demands at least two random numbers per selection. However, when the probability of selection is small (i.e. <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>≪</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), the next selection method can skip many elements, whereas Algorithm R still needs to process every single element. To process <italic toggle="yes">n</italic> elements, Algorithm R requires <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> random numbers, whereas the optimum next selection method is expected to need approximately <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We estimated an optimal next selection method to demand fewer random numbers than Algorithm R when <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>0.3</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Overview of s-leaping</title>
      <p>S-leaping is a hybrid method that combines Algorithm R and an efficient approximate next selection method. It follows Algorithm R for the first <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>-th elements—when the probability of selecting each element is at least 0.5 (i.e. <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula>). From the <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th element onward, it devises an approximate next selection that simplifies the sampling of the next step size by introducing a leaping interval, <italic toggle="yes">s</italic>.</p>
      <p>To sample the step size in s-leaping, we assume that the selection probability does not change within <italic toggle="yes">s</italic>: for all <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, the probability of selecting the <italic toggle="yes">i-</italic>th element is approximated by <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This assumption allows us to simplify the step-size distribution substantially and sample the step size from a geometric distribution with <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This simplified distribution approximates the true step-size distribution well when the lower bound of <italic toggle="yes">m</italic> (i.e. <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) is much larger than <italic toggle="yes">s</italic>. In the case of downsampling for HTS data, which easily comprise hundreds of millions of reads, we assume this condition to be met safely even when the leap size is in the order of thousands.</p>
    </sec>
    <sec>
      <title>2.3 Optimization of the number of random numbers</title>
      <p>In s-leaping, the use of Algorithm R to process the first <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> elements serves two objectives: to increase the step-size sampling accuracy by making <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, as described in the previous section, and to reduce the number of random numbers needed in the method. For the first <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> elements, s-leaping requires <italic toggle="yes">k</italic> random numbers; for the rest of the elements, approximately <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> random numbers on average. After algebraic manipulations, these make <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>ln</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> in total, implying that s-leaping requires approximately <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.39</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> fewer random numbers than the optimum next selection method.</p>
      <p>To compare s-leaping with Algorithm R in terms of the required number of random numbers, let us first consider the selection after the 2<italic toggle="yes">k</italic>-th element. Because the step size is sampled from a geometric distribution with <italic toggle="yes">p</italic> &lt; .5, s-leaping is expected to generate step sizes larger than two. Although s-leaping requires two random numbers per selection, this expected step size implies that s-leaping requires on average fewer than one random number per element after the 2<italic toggle="yes">k</italic>-th element, which in turn implies that s-leaping is expected to require fewer random numbers than Algorithm R when <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Because s-leaping is guaranteed to have the same number of random numbers as Algorithm R for all <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, the number of random numbers that s-leaping demands is always fewer than or equal to that of Algorithm R.</p>
      <p>To analyze how the relative size of <italic toggle="yes">k</italic> with respect to <italic toggle="yes">n</italic> affects the number of required random numbers in each method, we expressed as functions of a proportional size factor the ratio of the random numbers required in s-leaping and the optimal next selection method over the random numbers required in Algorithm R (<xref rid="btad399-F1" ref-type="fig">Fig. 1</xref>). This shows that the efficiency of the optimum next selection method decreases more drastically than that of s-leaping as the reservoir-size proportional factor increases: when <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, s-leaping is 110% more efficient and the optimum next selection method is 100% more efficient than Algorithm R; when <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, s-leaping, 15% more efficient, the optimum next selection method, 3% less efficient; and when <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.4</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, s-leaping, 4% more efficient, the optimum next selection method, 18% less efficient.</p>
      <fig position="float" id="btad399-F1">
        <label>Figure 1.</label>
        <caption>
          <p>A theoretical comparison of estimates of random numbers required for each method. The <italic toggle="yes">x</italic>-axis is the proportion of the reservoir size to the total size; the <italic toggle="yes">y</italic>-axis is the ratio of an estimated number of random numbers needed in each method to the number of random numbers required in Algorithm R.</p>
        </caption>
        <graphic xlink:href="btad399f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.4 Accuracy evaluation of s-leaping</title>
      <p>As a proof-of-concept, we implemented s-leaping, along with three downsampling methods, Algorithms R, L, and Z (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>, <xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>), in C. Algorithms L and Z are both next selection methods, but with widely different algorithmic designs for step-size sampling. Algorithm L requires three random numbers per selection, but with a simpler step-size sampling procedure; Algorithm Z requires two random numbers per selection, but with a more complex step-size sampling procedure.</p>
      <p>In this experiment, we chose <italic toggle="yes">n</italic> to be 100, 300, or 500 million, while varying <italic toggle="yes">k</italic> to have four values: 10, 20, 30, and 40 million. (Note that although the value of <italic toggle="yes">n</italic> was decided in prior, this information was used only for the performance evaluation purpose only.) These numbers are within the realm of biological relevance: with 300 bp read-pair length, these numbers roughly correspond to downsampling from 9×, 27×, and 45× coverage data to 0.9×, 1.8×, 2.7×, and 3.6× coverage data in the human genome. These settings also allowed us to evaluate the performance in a reasonable range of <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>—from 0.02 to 0.4. For each combination of <italic toggle="yes">k</italic> and <italic toggle="yes">n</italic>, we ran each method 10 times with different random seeds. In s-leaping, we fixed the leap-size factor to be 0.005 (i.e. <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). Because it devises an approximated next-selection method, s-leaping, along with Algorithms L and Z, is referred to as a next selection-based method.</p>
      <p>First, we analyzed how efficient the three next selection-based methods were in comparison with Algorithm R. To this end, we computed the ratio of the average runtime of each next selection-based method to that of Algorithm R. In this setup, thus, a runtime ratio less than 1 indicates that a next selection-based method has better computational efficiency than Algorithm R. As expected, all the next selection-based methods had a trend to increase efficiency as the <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> ratio decreased (<xref rid="btad399-F2" ref-type="fig">Fig. 2</xref>); however, they had widely different conditions under which to outperform Algorithm R. S-leaping was more efficient than Algorithm R when <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>≤</mml:mo><mml:mn>0.2</mml:mn></mml:mrow></mml:math></inline-formula> and they were comparable when <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is 0.3 [1.02, 95% confidence interval (CI): 0.98–1.06] and 0.4 (1.04, 95% CI: 1.00–1.09). Algorithm Z was more efficient than Algorithm R when <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>0.133</mml:mn></mml:mrow></mml:math></inline-formula>, and they were comparable when <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is 0.2 [1.03, 95% CI: 0.99–1.06], whereas Algorithm L was more efficient than Algorithm R only when <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>0.02</mml:mn></mml:mrow></mml:math></inline-formula>. Among the three next selection-based methods, s-leaping was consistently the fastest, outperforming Algorithm R in most of our <italic toggle="yes">k</italic>−<italic toggle="yes">n</italic> settings; Algorithm Z, the second; Algorithm L, the distant third. Although s-leaping and Algorithm Z both showed strong competitive advantages over Algorithm R when the <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> ratio was smaller, s-leaping demonstrated higher efficiency than Algorithm Z. For example, when <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>500</mml:mn></mml:mrow></mml:math></inline-formula> million, s-leaping was 20% faster than Algorithm Z with <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula> million (s-leaping, 0.70, 95% CI: 0.68–0.72; Algorithm Z, 0.85, 95% CI: 0.82–0.87) and it was 39% faster with <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> million (s-leaping, 0.38, 95% CI: 0.37–0.39; Algorithm Z, 0.53, 95% CI: 0.52–0.53).</p>
      <fig position="float" id="btad399-F2">
        <label>Figure 2.</label>
        <caption>
          <p>A comparison of runtime among the four downsampling methods. The <italic toggle="yes">x</italic>-axis is the reservoir size; the <italic toggle="yes">y</italic>-axis is the average runtime relative to that of Algorithm R. Error bars indicate 95% confidence level by a second-order Taylor approximation. (a) The runtime results from downsampling of 100 million elements; (b) 300 million; (c) 500 million. Here, leap indicates s-leaping; algo_R, Algorithm R; algo_L, Algorithm L; algo_Z, Algorithm Z.</p>
        </caption>
        <graphic xlink:href="btad399f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.5 Accuracy evaluation of s-leaping</title>
      <p>Next, because s-leaping is an approximated downsampling method, we evaluated its ability to generate unbiased samples. To this end, we used the maximum D—the maximum discrepancy between the cumulative distributions of two samples that the Kolmogorov–Smirnov test uses as the test statistic. We measured the maximum D between the selected <italic toggle="yes">k</italic> elements and the unit uniform distribution, allowing us to evaluate the degree of uniformity in the selected elements. We computed the maximum D for each downsampling run from the experiment described in the previous section and measured the maximum D distribution for each method.</p>
      <p>We found that the maximum D values from s-leaping (mean <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.75</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mn>7.46</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) were distributed similarly to those from Algorithms R (mean <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.72</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mn>7.49</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) and L (mean <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.78</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mn>8.78</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>), showing no evidence of s-leaping with lower accuracy than those methods (<xref rid="btad399-F3" ref-type="fig">Fig. 3</xref>). In fact, s-leaping had more consistent and lower maximum D measures than those from Algorithm Z (mean <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.84</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.15</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>), suggesting that s-leaping had a better goodness-of-fit than Algorithm Z. To further evaluate the accuracy of s-leaping (i.e. the goodness of fit to a uniform distribution), we computed the critical value at the significance level <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>—the value at which the probability to reject the null hypothesis is 0.999 in the Kolmogorov–Smirnov test—and compared the maximum D values with this critical value. The critical value was found to be <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.63</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>; this value was substantially higher than all the maximum D values from s-leaping, along with the other methods (<xref rid="btad399-F3" ref-type="fig">Fig. 3</xref>).</p>
      <fig position="float" id="btad399-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Results from analysis of goodness-of-fit to uniform distribution. The <italic toggle="yes">x</italic>-axis is the four downsampling methods; the <italic toggle="yes">y</italic>-axis is the maximum D measure against the uniform distribution. A violin plot shows the distribution of maximum D samples from a downsampling method. The dashed horizontal line indicates the threshold level of the Kolmogorov–Smirnov test at <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>. Here, sleap indicates s-leaping; algo_R, Algorithm R; algo_L, Algorithm L; algo_Z, Algorithm Z.</p>
        </caption>
        <graphic xlink:href="btad399f3" position="float"/>
      </fig>
      <p>We have thus far set the leap size <italic toggle="yes">s</italic> to be proportional to <italic toggle="yes">k</italic> with a fixed proportion, <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> (e.g. when <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 10 million, <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 50 000). Our results indicated that this leap-size proportional factor was small enough to have accuracy comparable to that of the exact reservoir-sampling methods. To further evaluate the accuracy of s-leaping, we analyzed the extent to which the accuracy of s-leaping changes with respect to the leap-size factor. To this end, we set <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 20 million and <italic toggle="yes">n</italic> to be 100, 300, or 500 million, we ran s-leaping 10 times for each setup, and computed maximum D for each leap-size factor value. We set the leap-size factor to take nine values ranging from 0.001 to 0.5 (i.e. <italic toggle="yes">s</italic> ranges from 20 000 to 1 million).</p>
      <p>We had expected maximum D to be an increasing function of leap-size factor and a decreasing function of <italic toggle="yes">n</italic>—i.e. the accuracy of s-leaping becomes worse with a larger leap size and smaller total size. Indeed, we observed this pattern, but only to a limited extent: maximum D showed clear positive relation patterns only for large leap-size factor values (from 0.1 to 0.5) with <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 100 and 300 million (<xref rid="btad399-F4" ref-type="fig">Fig. 4</xref>). Regardless of the value of <italic toggle="yes">n</italic>, we found maximum D to have similarly small values below <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mn>4.0</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> for leap-size factor ranging from 0.001 to 0.1, indicating that within this range, the accuracy of s-leaping is high and independent of the leap size. For example, when the leap-size factor is 0.1 (i.e. <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn><mml:mo>,</mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula>), the mean maximum D was <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.39</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (sd <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mn>5.63</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) with <italic toggle="yes">n</italic> = 100 million; <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.79</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (sd <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.49</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) with <italic toggle="yes">n</italic> = 300 million; and <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.06</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (sd <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mn>5.08</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) with <italic toggle="yes">n</italic> = 500 million. Under all the settings we studied, we found the maximum D values to be well below the critical value at significance level <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>, demonstrating high levels of accuracy in a wide range of conditions.</p>
      <fig position="float" id="btad399-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Comparison of downsampling accuracy with respect to different leap size factor values. The maximum D distributions of nine different leap size factor values are compared. The reservoir size <italic toggle="yes">k</italic> is set to 20 million, while the population size <italic toggle="yes">n</italic> is changed to have three different values: (a) <italic toggle="yes">n</italic> = 100 million; (b) 300 million; and (c) 500 million. The <italic toggle="yes">x</italic>-axis is the leap-size factor; the <italic toggle="yes">y</italic>-axis is the maximum D measure against the uniform distribution. Each distribution is generated from 10 samples.</p>
        </caption>
        <graphic xlink:href="btad399f4" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.6 Fadso: an implementation of s-leaping for FASTQ downsampling</title>
      <p>To apply s-leaping on FASTQ data, we have developed fadso (FAstq DownSampling Optimizer), a command-line tool that downsamples FASTQ data to have the user-specified read size. This tool takes either gzipped or plain FASTQ files, downsamples single- or paired-end reads, and implements s-leaping, along with Algorithm L (<xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>), Algorithm R (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>), and Algorithm Z (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>).</p>
      <p>To evaluate the performance of fadso, we compared its speed and memory usage with those of seqtk, an efficient and lightweight tool for processing sequencing data in the FASTQ format, with a downsampling feature to output a desired number of reads. To this end, we selected s-leaping as the downsampler in fadso. Through source-code inspection, we found that seqtk implemented Algorithm R for downsampling of FASTQ data with a specific target size. Note that both fadso and seqtk are single-threaded programs written in C.</p>
      <p>To measure the downsampling performance, we used the forward-read set of ERR174310 from the Illumina Platinum genome project (<xref rid="btad399-B2" ref-type="bibr">Eberle <italic toggle="yes">et al.</italic> 2017</xref>) that has 208 million 101 bp reads. We downsampled this read set to target sizes ranging from 5 to 20 million with the 5 million-size increment and repeated this procedure for five times with different random seeds. We evaluated the downsampling performance by measuring the runtime and peak memory usage of the programs.</p>
      <p>Fadso consistently outperformed seqtk in terms of speed: fadso averaged 12% speedup for the 5 million downsampling size; 8% for the 10 million size; 12% for the 15 million size; and 10% for the 20 million size (<xref rid="btad399-F5" ref-type="fig">Fig. 5a</xref>). The results from the peak memory usage showed fadso to consistently have smaller memory footprints than seqtk, reducing the memory requirement by around 21% in each downsampling size setting (<xref rid="btad399-F5" ref-type="fig">Fig. 5b</xref>).</p>
      <fig position="float" id="btad399-F5">
        <label>Figure 5.</label>
        <caption>
          <p>Performance comparison of FASTQ downsampling tools. The <italic toggle="yes">x</italic>-axis is the target read count; the <italic toggle="yes">y</italic>-axis is the performance measure (<inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> for each setting). (a) Runtime was measured in seconds; (b) peak memory usage, in gigabytes. Bars indicate sample average from five runs; the error bars, sample standard deviations.</p>
        </caption>
        <graphic xlink:href="btad399f5" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>3 Discussion</title>
    <p>Our results demonstrated s-leaping to be highly efficient, while achieving accurate downsampling—with no sign of deteriorating accuracy, comparable to exact reservoir-sampling methods. The high performance of s-leaping arose from the assumption that the selection probability changes negligibly within a relatively small interval compared with the reservoir size. Not only did this leaping assumption simplify the sampling of next selections, but it also accelerated the calculation of the selection probability. These improved the runtime efficiency especially when <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≫</mml:mo><mml:mi>k</mml:mi><mml:mo>≫</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
    <p>This type of “leaping” strategies to accelerate the runtime by sacrificing the exactness is not new; indeed, in the field of stochastic chemical kinetics, an approximate simulation method called tau-leaping (<xref rid="btad399-B4" ref-type="bibr">Gillespie 2001</xref>) was shown to improve the time efficiency over an exact method called Gillespie’s stochastic simulation algorithm (<xref rid="btad399-B3" ref-type="bibr">Gillespie 1976</xref>)—which simulates every single reaction event in a well-stirred chemically reacting system governed by a continuous-time jump Markov process. By assuming reaction rates to change negligibly within a specified time interval, the tau-leaping method allows the system to leap along each interval. Although the basis of the speedup is different between s-leaping and tau-leaping, they both stem from the same underlying concept, which sacrifices miniature differences from the exact solution within subintervals to increase computational efficiency. Our study provided evidence for a successful application of a leaping strategy for an important task in omics research—downsampling of large HTS data.</p>
    <p>To apply s-leaping to downsampling of FASTQ data, we developed fadso, a downsampling tool implementing s-leaping for FASTQ data. In terms of both runtime and memory usage, fadso was more efficient than seqtk, the leading FASTQ processing tool implementing Algorithm R to downsample FASTQ data. However, considering the performance results of s-leaping with respect to Algorithm R, we found fadso’s speedup improvement to be lower than expected. This can be explained by the computational overhead involved in reading, uncompressing, and parsing compressed FASTQ files that might have weakened the effects of the algorithmic speedup of s-leaping. Another possibility could be that the implementation of seqtk to parse compressed FASTQ files could be more efficient than that of fadso, which in turn might have overtaken some of s-leaping’s algorithmic advantage, suggesting that fadso could have some room to further increase its efficiency with a more efficient FASTQ parser in the future. Nevertheless, given fadso’s superior performance in memory usage, our results suggest the current version of fadso to process large FASTQ datasets at up to 40% higher throughput rate than seqtk in parallel computing settings.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>Here, we introduced s-leaping, a novel downsampling algorithm tailored to downsample large data by approximating the next step-size probability using the concept of leaping, and developed fadso, a downsampling tool for FASTQ that implements s-leaping. We have shown that the accuracy of s-leaping is on par with exact reservoir-sampling methods and that the Fadso was deposited in Github. Its package is available to download at <ext-link xlink:href="https://github.com/hkuwahara/sleaping" ext-link-type="uri">https://github.com/hkuwahara/sleaping</ext-link>.</p>
  </sec>
  <sec>
    <title>5 Methods</title>
    <sec>
      <title>5.1 Algorithm R</title>
      <p>Reservoir sampling sequentially reads a streaming file and randomly samples <italic toggle="yes">k</italic> elements with the equal probability from the population of unknown size <italic toggle="yes">n</italic>. Waterman developed a direct approach of reservoir sampling called Algorithm R in the 1970s (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>). Algorithm R first places the first <italic toggle="yes">k</italic> elements in the selection set called “reservoir” of size <italic toggle="yes">k</italic>, and for all <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, it selects the <italic toggle="yes">i-</italic>th element at probability <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> to replace a randomly picked element in the reservoir. At the end of <italic toggle="yes">j-</italic>th step (<inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>), each element in the reservoir is guaranteed to have probability <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> in the reservoir. This algorithm is simple and requires only one random variate per element, requiring <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> random variates in total.</p>
    </sec>
    <sec>
      <title>5.2 Next selection method</title>
      <p>We define the next selection method as another type of reservoir sampling that focuses on the number of steps it takes to select the next element. Just like Algorithm R, the next selection method first fills the reservoir with the first <italic toggle="yes">k</italic> elements. For all <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, it then randomly makes two decisions per selected element: the step size to the next selection and the index of an element in the reservoir to be replaced. Its sampling distribution can be derived from the probability to select the <italic toggle="yes">i-</italic>th element, <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. Let us first define <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be the probability that it takes exactly <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> steps to select the next element for the reservoir after the <italic toggle="yes">i-</italic>th element is processed. Then, we can express <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as
where <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability of selecting the (<inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)-th element.</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>p</mml:mi>
                </mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:msub>
            </mml:mrow>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mo>ν</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mo>ν</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mrow>
              <mml:munderover>
                <mml:mo>∏</mml:mo>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>ν</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:munderover>
            </mml:mrow>
            <mml:mrow>
              <mml:mrow>
                <mml:mo>[</mml:mo>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:mi>p</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>j</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>]</mml:mo>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mfrac>
                <mml:mi>k</mml:mi>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mo>ν</mml:mo>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mrow>
              <mml:munderover>
                <mml:mo>∏</mml:mo>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>ν</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:munderover>
            </mml:mrow>
            <mml:mrow>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Vitter developed Algorithm Z that faithfully samples <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> using this distribution or using the rejection-acceptance sampling with an easier envelop (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>). <xref rid="btad399-B11" ref-type="bibr">Li (1994)</xref> developed Algorithm L that treats the reservoir-sampling problem as a task of selecting indices of <italic toggle="yes">k</italic> smallest numbers from <italic toggle="yes">n</italic> randomly drawn numbers. Although the approach to select the next element can be widely different among different algorithms, the next selection method in general places the first <italic toggle="yes">k</italic> elements in the reservoir and for all <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, selects on average <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>≈</mml:mo><mml:mi>k</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> elements at the <italic toggle="yes">n-</italic>th elements. The time complexity of the next selection method, including Algorithms L and Z, was thus reported to be <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>).</p>
    </sec>
    <sec>
      <title>5.3 Next selection sampling in s-leaping</title>
      <p>To derive the step-size sampling used in s-leaping, we start from the definition of <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Direct sampling of <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> from <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is complicated and s-leaping uses an approximation. To approximate <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we first define a leap size <italic toggle="yes">s</italic> that is much smaller than the reservoir size (i.e. <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≪</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). Within this relatively small leap subinterval, we assume that differences in <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are insignificant and that for all <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is well approximated by <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This allows us to approximate <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by the geometric distribution with <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>:
</p>
      <disp-formula id="E2">
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>p</mml:mi>
                </mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:msub>
            </mml:mrow>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mo>ν</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>≈</mml:mo>
            <mml:mrow>
              <mml:mfrac>
                <mml:mi>k</mml:mi>
                <mml:mrow>
                  <mml:mi>m</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>0.5</mml:mn>
                  <mml:mi>s</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mrow>
              <mml:msup>
                <mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>k</mml:mi>
                            <mml:mrow>
                              <mml:mi>m</mml:mi>
                              <mml:mo>+</mml:mo>
                              <mml:mn>0.5</mml:mn>
                              <mml:mi>s</mml:mi>
                            </mml:mrow>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>ν</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Thus, with the inverse transform sampling, we can sample a geometric random variate <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> as follows:
where <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">u</italic> is a unit uniform random variate. The sampling of <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> requires only one unit uniform random variate, demanding only two unit uniform random variates per selection step. In addition, because the distribution of <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> is fixed within each leap subinterval, the sampling of <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> can be streamlined by reusing <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mo>λ</mml:mo></mml:math></inline-formula>.</p>
      <disp-formula id="E3">
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mo>ν</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mo>⌊</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>ln</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>u</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mo>λ</mml:mo>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>⌋</mml:mo>
            </mml:mrow>
            <mml:mo>+</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>5.4 S-leaping algorithm</title>
      <p>Below shows the algorithm of s-leaping with zero-based numbering:<boxed-text id="btad399-BOX1" position="float"><caption><p>Require: <italic toggle="yes">k</italic> the reservoir size; <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> the leap-size factor;</p></caption><p>1: for <italic toggle="yes">i</italic> from 0 to <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, select elements using Algorithm R;</p><p>2: set <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>←</mml:mo><mml:mo>ϵ</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>;</p><p>3: <bold>while</bold> not end of file <bold>do</bold></p><p>4:   set <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>←</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>←</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>;</p><p>5:   <bold>while</bold> True <bold>do</bold></p><p>6:    set <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> a unit uniform random variate; <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mo>ν</mml:mo><mml:mo>←</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mo>λ</mml:mo></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>;</p><p>7:    update <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>←</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mo>ν</mml:mo></mml:mrow></mml:math></inline-formula>;</p><p>8:    <bold>if</bold><inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p><p>9:     update <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, and break from the loop;</p><p>10:    <bold>end if</bold></p><p>11:    <bold>if</bold> end of file <bold>then</bold></p><p>12:    terminate;</p><p>13:    <bold>end if</bold></p><p>14:    set <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> a discrete uniform random variate in <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>;</p><p>15:    update the <italic toggle="yes">r</italic>-th reservoir element by the (<inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)-th element;</p><p>16:   <bold>end while</bold></p><p>17: <bold>end while</bold></p></boxed-text>The leap-size factor <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> needs to be small in order to have reasonable accuracy. We used 0.005 as the default value of <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>5.5 Estimation of the number of random numbers needed in the next selection method</title>
      <p>First, we estimated the average number of selected elements after processing <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> elements in the next selection method, ignoring the first <italic toggle="yes">k</italic> elements that were used to fill the reservoir initially. Because the probability to select the <italic toggle="yes">i</italic>-th element is <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, the average number of selected elements can be expressed by a harmonic series and approximated using the natural logarithm:
</p>
      <disp-formula id="E4">
        <label>(1)</label>
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi>k</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:munderover>
            </mml:mrow>
            <mml:mrow>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mfrac>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>≈</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mrow>
              <mml:mrow>
                <mml:msubsup>
                  <mml:mo>∫</mml:mo>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:msubsup>
              </mml:mrow>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mi>x</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
                <mml:mi>d</mml:mi>
                <mml:mi>x</mml:mi>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mi>ln</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mi>n</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>≈</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mi>ln</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mi>n</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Let <italic toggle="yes">t</italic> be the average number of random numbers needed to select the next element per selection step. Then because each selected element needs to replace a randomly picked element in the reservoir, we can approximate the average number of random numbers needed in the next selection method as follows:
</p>
      <disp-formula id="E5">
        <label>(2)</label>
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>k</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mi>t</mml:mi>
                <mml:mo>+</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mi>ln</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mi>n</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Because every step-size sampling demands <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, its lowest number of random numbers required to process <italic toggle="yes">n</italic> elements is <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Because the probability to select 2<italic toggle="yes">k</italic>-th element is 0.5, the average number of random numbers needed for this element is the same between Algorithm R and the optimal next selection method. Thus, up until 2<italic toggle="yes">k</italic>-th element, Algorithm R is expected to generate fewer random numbers than the optimal next selection method. To estimate the proportional difference of the random numbers needed in Algorithm R with respect to the optimal next selection method, we have
for <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≫</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Thus, Algorithm R generates 28% fewer random numbers than the best next selection method.</p>
      <disp-formula id="E6">
        <label>(3)</label>
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:mfrac>
                <mml:mi>k</mml:mi>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                  <mml:mi>k</mml:mi>
                  <mml:mi>ln</mml:mi>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                            <mml:mi>k</mml:mi>
                          </mml:mrow>
                          <mml:mi>k</mml:mi>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mfrac>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                  <mml:mi>ln</mml:mi>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mo>≈</mml:mo>
            <mml:mn>0.72.</mml:mn>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>5.6 Estimation of the number of random numbers needed in s-leaping</title>
      <p>Because s-leaping uses Algorithm R to process the first 2<italic toggle="yes">k</italic> elements, it generates exactly <italic toggle="yes">k</italic> random numbers for the first 2<italic toggle="yes">k</italic> elements. After this point, s-leaping demands two random numbers per selection step, the lowest of the next selection method. Thus, the total number of random numbers generated in s-leaping to process <italic toggle="yes">n</italic> elements is expected to be
</p>
      <disp-formula id="E7">
        <label>(4)</label>
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mrow>
                      <mml:munderover>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:munderover>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mfrac>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mo>≈</mml:mo>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>n</mml:mi>
                            <mml:mrow>
                              <mml:mn>2</mml:mn>
                              <mml:mi>k</mml:mi>
                            </mml:mrow>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>n</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>≈</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>n</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>0.39</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mo>.</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Because the optimal next selection method requires <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to process <italic toggle="yes">n</italic> elements, s-leaping is expected to require 0.39<italic toggle="yes">k</italic> fewer random numbers than the optimal next selection method in total.</p>
    </sec>
    <sec>
      <title>5.7 Runtime measure of the four reservoir-sampling methods</title>
      <p>We implemented s-leaping and Algorithms R, L, and Z in C. To measure the CPU time of each method, we called the clock function right before and after the downsampling function call. We then converted the CPU clock count into the time unit of seconds to obtain the runtime. For each combination of <italic toggle="yes">k</italic> and <italic toggle="yes">n</italic>, the ratio of the average runtime of each next selection-based method to that of Algorithm R was sampled using 10 data points. To obtain the 95% confidence interval of the relative runtime, we assumed that runtime of each next selection method is independent of that of Algorithm R and used the second-order Taylor approximation method with zero covariance.</p>
    </sec>
    <sec>
      <title>5.8 Computation of maximum D</title>
      <p>For each combination of <italic toggle="yes">k</italic> and <italic toggle="yes">n</italic>, we performed downsampling 10 times, making the number of runs 120 for each method in total. In this downsampling, each reservoir element contained an index of a selected element, which is a number between 0 and <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. The <italic toggle="yes">k</italic> selected numbers were then sorted and partitioned into 1000 bins to measure the empirical cumulative distribution at the permille resolution. We then computed the maximum D measure of the empirical cumulative distribution against the unit uniform distribution using the 1000 data points. The violin plots were generated from 40 maximum D samples for each method.</p>
    </sec>
    <sec>
      <title>5.9 Leap-size factor in fadso</title>
      <p>S-leaping has one tuning parameter, the leap-size factor <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula>. In fadso, we fixed this value to be 0.005. This value was determined so as to make the maximum discrepancy of the approximated selection probability reasonably small under a wide range of settings. The selection probability of the <italic toggle="yes">i</italic>-th element is <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>; hence, the maximum discrepancy between s-leaping and the exact reservoir sampling occurs when <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, with the relative difference being
</p>
      <disp-formula id="E8">
        <label>(5)</label>
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mi>s</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>−</mml:mo>
                          <mml:mi>k</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>s</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>s</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mo>+</mml:mo>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>0.5</mml:mn>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>.</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>With <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϵ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn></mml:mrow></mml:math></inline-formula>, this upper limit becomes 0.00125.</p>
    </sec>
    <sec>
      <title>5.10 Performance measurement of the FASTQ downsampling tools</title>
      <p>The forward read FASTQ file of ERR174310 from the Illumina Platinum Sequencing project (study accession: PRJEB3246) was downloaded from European Nucleotide Archive. This FASTQ dataset contained 208M 200 bp read-pairs and to evaluate the performance of FASTQ downsampling tools, it was downsampled to have read counts ranging from 5 to 20 M with 5 M increment. For each downsampling size, five single-threaded runs were performed, and the CPU time and peak memory size from each run were measured using the GNU time program. The runtime was computed by adding the user CPU time and the system CPU time; the peak memory size was computed from the maximum resident set size.</p>
    </sec>
    <sec>
      <title>5.11 Runtime environment information</title>
      <p>All of the runs were carried out on an Intel Xeon Gold 6130 machine with 132 GB of RAM.</p>
    </sec>
  </sec>
</body>
<back>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This publication is based upon work supported by the King Abdullah University of Science and Technology (KAUST) Office of Research Administration (ORA) under Award Nos FCC/1/1976-44-01, FCC/1/1976-45-01, URF/1/4663-01-01, REI/1/5202-01-01, REI/1/4940-01-01, and RGC/3/4816-01-01.</p>
  </sec>
  <sec>
    <title>Code availability</title>
    <p>The C source code to run s-leaping, Algorithms R, L, and Z, as well as the fadso package is available at <ext-link xlink:href="https://github.com/hkuwahara/sleaping" ext-link-type="uri">https://github.com/hkuwahara/sleaping</ext-link>. The fadso tool depends on the zlib library. And to compile the source and generate an executable, cmake is used.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The WGS sample from the Illumina Platinum genome project that we used to evaluate the performance of fadso is available with accession number ERR174310 from European Nucleotide Archive.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad399-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Davies</surname><given-names>RW</given-names></string-name>, <string-name><surname>Kucka</surname><given-names>M</given-names></string-name>, <string-name><surname>Su</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Rapid genotype imputation from sequence with reference panels</article-title>. <source>Nat Genet</source><year>2021</year>;<volume>53</volume>:<fpage>1104</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">34083788</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Eberle</surname><given-names>MA</given-names></string-name>, <string-name><surname>Fritzilas</surname><given-names>E</given-names></string-name>, <string-name><surname>Krusche</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><article-title>A reference data set of 5.4 million phased human variants validated by genetic inheritance from sequencing a three-generation 17-member pedigree</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>157</fpage>–<lpage>64</lpage>.<pub-id pub-id-type="pmid">27903644</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gillespie</surname><given-names>DT.</given-names></string-name></person-group><article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title>. <source>J Comput Phys</source><year>1976</year>;<volume>22</volume>:<fpage>403</fpage>–<lpage>34</lpage>.</mixed-citation>
    </ref>
    <ref id="btad399-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gillespie</surname><given-names>DT.</given-names></string-name></person-group><article-title>Approximate accelerated stochastic simulation of chemically reacting systems</article-title>. <source>J Chem Phys</source><year>2001</year>;<volume>115</volume>:<fpage>1716</fpage>–<lpage>33</lpage>.</mixed-citation>
    </ref>
    <ref id="btad399-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gilly</surname><given-names>A</given-names></string-name>, <string-name><surname>Southam</surname><given-names>L</given-names></string-name>, <string-name><surname>Suveges</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Very low-depth whole-genome sequencing in complex trait association studies</article-title>. <source>Bioinformatics (Oxford, England)</source><year>2019</year>;<volume>35</volume>:<fpage>2555</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">30576415</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goldfeder</surname><given-names>RL</given-names></string-name>, <string-name><surname>Priest</surname><given-names>JR</given-names></string-name>, <string-name><surname>Zook</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Medical implications of technical accuracy in genome sequencing</article-title>. <source>Genome Med</source><year>2016</year>;<volume>8</volume>:<fpage>24</fpage>.<pub-id pub-id-type="pmid">26932475</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Homburger</surname><given-names>JR</given-names></string-name>, <string-name><surname>Neben</surname><given-names>CL</given-names></string-name>, <string-name><surname>Mishne</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Low coverage whole genome sequencing enables accurate assessment of common variants and calculation of genome-wide polygenic scores</article-title>. <source>Genome Med</source><year>2019</year>;<volume>11</volume>:<fpage>74</fpage>.<pub-id pub-id-type="pmid">31771638</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Knuth</surname><given-names>DE.</given-names></string-name></person-group><source>The Art of Computer Programming, Vol. 2: Seminumerical Algorithms</source>, <edition>3rd edn.</edition><publisher-loc>Boston</publisher-loc>: <publisher-name>Addison-Wesley</publisher-name>, <year>1997</year>.</mixed-citation>
    </ref>
    <ref id="btad399-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Handsaker</surname><given-names>B</given-names></string-name>, <string-name><surname>Wysoker</surname><given-names>A</given-names></string-name></person-group>, <etal>et al</etal><article-title>The sequence alignment/map format and SAMtools</article-title>. <source>Bioinformatics (Oxford, England)</source><year>2009</year>;<volume>25</volume>:<fpage>2078</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>JH</given-names></string-name>, <string-name><surname>Mazur</surname><given-names>CA</given-names></string-name>, <string-name><surname>Berisa</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Low-pass sequencing increases the power of GWAS and decreases measurement error of polygenic risk scores compared to genotyping arrays</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>529</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">33536225</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>K-H.</given-names></string-name></person-group><article-title>Reservoir-sampling algorithms of time complexity</article-title><inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <source>ACM Trans Math Softw</source><year>1994</year>;<volume>20</volume>:<fpage>481</fpage>–<lpage>93</lpage>.</mixed-citation>
    </ref>
    <ref id="btad399-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lou</surname><given-names>RN</given-names></string-name>, <string-name><surname>Jacobs</surname><given-names>A</given-names></string-name>, <string-name><surname>Wilder</surname><given-names>AP</given-names></string-name></person-group><etal>et al</etal><article-title>A beginner’s guide to low-coverage whole genome sequencing for population genomics</article-title>. <source>Mol Ecol</source><year>2021</year>;<volume>30</volume>:<fpage>5966</fpage>–<lpage>93</lpage>.<pub-id pub-id-type="pmid">34250668</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McKenna</surname><given-names>A</given-names></string-name>, <string-name><surname>Hanna</surname><given-names>M</given-names></string-name>, <string-name><surname>Banks</surname><given-names>E</given-names></string-name></person-group><etal>et al</etal><article-title>The genome analysis toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data</article-title>. <source>Genome Res</source><year>2010</year>;<volume>20</volume>:<fpage>1297</fpage>–<lpage>303</lpage>.<pub-id pub-id-type="pmid">20644199</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rubinacci</surname><given-names>S</given-names></string-name>, <string-name><surname>Ribeiro</surname><given-names>DM</given-names></string-name>, <string-name><surname>Hofmeister</surname><given-names>RJ</given-names></string-name></person-group><etal>et al</etal><article-title>Efficient phasing and imputation of low-coverage sequencing data using large reference panels</article-title>. <source>Nat Genet</source><year>2021</year>;<volume>53</volume>:<fpage>120</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">33414550</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>Y</given-names></string-name>, <string-name><surname>Liu</surname><given-names>F</given-names></string-name>, <string-name><surname>Fan</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Characterizing sensitivity and coverage of clinical wgs as a diagnostic test for genetic disorders</article-title>. <source>BMC Med Genomics</source><year>2021</year>;<volume>14</volume>:<fpage>102</fpage>.<pub-id pub-id-type="pmid">33849535</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vitter</surname><given-names>JS.</given-names></string-name></person-group><article-title>Random sampling with a reservoir</article-title>. <source>ACM Trans Math Softw</source><year>1985</year>;<volume>11</volume>:<fpage>37</fpage>–<lpage>57</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10318387</article-id>
    <article-id pub-id-type="pmid">37354496</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad399</article-id>
    <article-id pub-id-type="publisher-id">btad399</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>S-leaping: an efficient downsampling method for large high-throughput sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-5333-6729</contrib-id>
        <name>
          <surname>Kuwahara</surname>
          <given-names>Hiroyuki</given-names>
        </name>
        <aff><institution>Computer, Electrical and Mathematical Sciences and Engineering Division (CEMSE), Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology (KAUST)</institution>, Thuwal 23955-6900, <country country="SA">Saudi Arabia</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-7108-3574</contrib-id>
        <name>
          <surname>Gao</surname>
          <given-names>Xin</given-names>
        </name>
        <aff><institution>Computer, Electrical and Mathematical Sciences and Engineering Division (CEMSE), Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology (KAUST)</institution>, Thuwal 23955-6900, <country country="SA">Saudi Arabia</country></aff>
        <xref rid="btad399-cor1" ref-type="corresp"/>
        <!--xin.gao@kaust.edu.sa-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Alkan</surname>
          <given-names>Can</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad399-cor1">Corresponding author. Computer, Electrical and Mathematical Sciences and Engineering Division (CEMSE), Computational Bioscience Research Center (CBRC), King Abdullah University of Science and Technology (KAUST), Thuwal 23955-6900, Saudi Arabia. E-mail: <email>xin.gao@kaust.edu.sa</email> (X.G.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-24">
      <day>24</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>7</issue>
    <elocation-id>btad399</elocation-id>
    <history>
      <date date-type="received">
        <day>13</day>
        <month>2</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>19</day>
        <month>5</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>23</day>
        <month>6</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>03</day>
        <month>7</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad399.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Sequencing coverage is among key determinants considered in the design of omics studies. To help estimate cost-effective sequencing coverage for specific downstream analysis, downsampling, a technique to sample subsets of reads with a specific size, is routinely used. However, as the size of sequencing becomes larger and larger, downsampling becomes computationally challenging.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Here, we developed an approximate downsampling method called s-leaping that was designed to efficiently and accurately process large-size data. We compared the performance of s-leaping with state-of-the-art downsampling methods in a range of practical omics-study downsampling settings and found s-leaping to be up to 39% faster than the second-fastest method, with comparable accuracy to the exact downsampling methods. To apply s-leaping on FASTQ data, we developed a light-weight tool called fadso in C. Using whole-genome sequencing data with 208 million reads, we compared fadso’s performance with that of a commonly used FASTQ tool with the same downsampling feature and found fadso to be up to 12% faster with 21% lower memory usage, suggesting fadso to have up to 40% higher throughput in a parallel computing setting.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The C source code for s-leaping, as well as the fadso package is freely available at <ext-link xlink:href="https://github.com/hkuwahara/sleaping" ext-link-type="uri">https://github.com/hkuwahara/sleaping</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>King Abdullah University of Science and Technology</institution>
            <institution-id institution-id-type="DOI">10.13039/501100004052</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>FCC/1/1976-44-01</award-id>
        <award-id>FCC/1/1976-45-01</award-id>
        <award-id>URF/1/4663-01-01</award-id>
        <award-id>REI/1/5202-01-01</award-id>
        <award-id>REI/1/4940-01-01</award-id>
        <award-id>RGC/3/4816-01-01</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Downsampling is a valuable technique that is routinely used to evaluate the design of high-throughput sequencing (HTS) studies. Be it whole-genome sequencing (WGS), RNA sequencing, or DNA methylation sequencing, researchers can use downsampling to conveniently and economically sample HTS data with various sizes. Among recent use cases of downsampling is low-coverage WGS (lcWGS), an emergent alternative to SNP genotyping arrays in population genetics, thanks to a steady decrease in sequencing costs. Indeed, because downsampling can efficiently generate lcWGS data from WGS data, it has been used to evaluate the performance of genotype imputation methods—inference methods that increase genotype density by predicting unobserved genotypes (<xref rid="btad399-B5" ref-type="bibr">Gilly <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad399-B10" ref-type="bibr">Li <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="btad399-B12" ref-type="bibr">Lou <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="btad399-B14" ref-type="bibr">Rubinacci <italic toggle="yes">et al.</italic> 2021</xref>)—and to determine cost-effective sequencing coverage rates for a range of computational medicine applications (<xref rid="btad399-B6" ref-type="bibr">Goldfeder <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad399-B7" ref-type="bibr">Homburger <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad399-B1" ref-type="bibr">Davies <italic toggle="yes">et al.</italic> 2021</xref>, <xref rid="btad399-B15" ref-type="bibr">Sun <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>There are a number of downsampling tools available for HTS data, but with different specifications. For example, the downsampling features in picard, GATK (<xref rid="btad399-B13" ref-type="bibr">McKenna <italic toggle="yes">et al.</italic> 2010</xref>), and SAMtools (<xref rid="btad399-B9" ref-type="bibr">Li <italic toggle="yes">et al.</italic> 2009</xref>) select reads at an equal probability. Although this type of downsampling is computationally efficient with a very small memory footprint, the user cannot ensure that the obtained data have a desired number of reads. Another type of downsampling is reservoir sampling, which makes a single pass through an HTS file and unbiasedly samples the specific number of reads without having to know the total number of reads. This downsampling approach is used in seqtk (<ext-link xlink:href="https://github.com/lh3/seqtk" ext-link-type="uri">https://github.com/lh3/seqtk</ext-link>), a most commonly used tool to downsample FASTQ data. Because reservoir sampling allows sampling of exactly <italic toggle="yes">k</italic> elements from a population of unknown size <italic toggle="yes">n</italic> in a single pass, this article focuses on this type of downsampling.</p>
    <p>Numerous algorithms have been proposed for reservoir sampling. Waterman developed the direct approach called Algorithm R (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>) that scans and processes each element for random selection. Although this algorithm is simple, it demands the generation of one unit uniform random variate per element, which becomes inefficient when selecting small subsets of the data. To deal with such cases, a different type of reservoir sampling was developed to focus on the number of steps it takes to select the next element, rather than processing every single element (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>). To process large HTS datasets, with hundreds of millions, or even billions, of reads per sample, however, the use of the existing reservoir-sampling methods is found to be inefficient, rendering the development of a more computationally efficient method not only essential but also necessary.</p>
    <p>Here, we developed s-leaping, a method that focuses on downsampling of large datasets by approximating reservoir sampling. By applying the concept of leaping to downsampling, s-leaping simplifies the sampling procedure and reduces the average number of random numbers it requires. Comparing s-leaping’s performance with that of several exact reservoir-sampling methods for a task of selecting 10–40 million elements from a population of 100–500 million, we found s-leaping to be up to 39% faster than the most efficient exact method, while showing no sign of deteriorating accuracy. We implemented s-leaping in a tool called fadso that specializes in downsampling of FASTQ data, compared its efficiency against that of seqtk, and found fadso to be more efficient in terms of computation time and memory usage than seqtk.</p>
  </sec>
  <sec>
    <title>2 Results</title>
    <sec>
      <title>2.1 Theoretical evaluation of reservoir-sampling methods</title>
      <p>We define reservoir sampling as a task to randomly and unbiasedly choose <italic toggle="yes">k</italic> elements from a file holding elements of unknown size <italic toggle="yes">n</italic> in a single pass. In Algorithm R, the reservoir initially comprises the first <italic toggle="yes">k</italic> elements, and for all <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, the <italic toggle="yes">i-</italic>th element is selected at probability <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> to replace a randomly selected element in the reservoir. At the end of <italic toggle="yes">j-</italic>th step (<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>), Algorithm R ensures that each element in the reservoir has an equal probability (i.e. <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>) of being selected and kept in the reservoir (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>). Another type of reservoir sampling focuses on the number of steps it takes to select the next element, which we call next selection method. A next selection method randomly makes two decisions per selected element: the step size to the next selection and the index of an element to be replaced in the reservoir.</p>
      <p>Both approaches have pros and cons. Computation-wise, the selection operation is simpler in Algorithm R than the next selection method. Indeed, direct sampling of step size in the next selection method is complicated and existing algorithms often use rejection sampling with easier envelope functions (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>). Selection-wise, after processing the first <italic toggle="yes">k</italic> elements, Algorithm R requires one random number per element, whereas the next selection method demands at least two random numbers per selection. However, when the probability of selection is small (i.e. <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>≪</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>), the next selection method can skip many elements, whereas Algorithm R still needs to process every single element. To process <italic toggle="yes">n</italic> elements, Algorithm R requires <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> random numbers, whereas the optimum next selection method is expected to need approximately <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We estimated an optimal next selection method to demand fewer random numbers than Algorithm R when <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>0.3</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.2 Overview of s-leaping</title>
      <p>S-leaping is a hybrid method that combines Algorithm R and an efficient approximate next selection method. It follows Algorithm R for the first <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>-th elements—when the probability of selecting each element is at least 0.5 (i.e. <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi><mml:mo>≥</mml:mo><mml:mn>0.5</mml:mn></mml:mrow></mml:math></inline-formula>). From the <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-th element onward, it devises an approximate next selection that simplifies the sampling of the next step size by introducing a leaping interval, <italic toggle="yes">s</italic>.</p>
      <p>To sample the step size in s-leaping, we assume that the selection probability does not change within <italic toggle="yes">s</italic>: for all <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, the probability of selecting the <italic toggle="yes">i-</italic>th element is approximated by <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This assumption allows us to simplify the step-size distribution substantially and sample the step size from a geometric distribution with <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This simplified distribution approximates the true step-size distribution well when the lower bound of <italic toggle="yes">m</italic> (i.e. <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) is much larger than <italic toggle="yes">s</italic>. In the case of downsampling for HTS data, which easily comprise hundreds of millions of reads, we assume this condition to be met safely even when the leap size is in the order of thousands.</p>
    </sec>
    <sec>
      <title>2.3 Optimization of the number of random numbers</title>
      <p>In s-leaping, the use of Algorithm R to process the first <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> elements serves two objectives: to increase the step-size sampling accuracy by making <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>≥</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, as described in the previous section, and to reduce the number of random numbers needed in the method. For the first <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> elements, s-leaping requires <italic toggle="yes">k</italic> random numbers; for the rest of the elements, approximately <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> random numbers on average. After algebraic manipulations, these make <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>ln</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> in total, implying that s-leaping requires approximately <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.39</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> fewer random numbers than the optimum next selection method.</p>
      <p>To compare s-leaping with Algorithm R in terms of the required number of random numbers, let us first consider the selection after the 2<italic toggle="yes">k</italic>-th element. Because the step size is sampled from a geometric distribution with <italic toggle="yes">p</italic> &lt; .5, s-leaping is expected to generate step sizes larger than two. Although s-leaping requires two random numbers per selection, this expected step size implies that s-leaping requires on average fewer than one random number per element after the 2<italic toggle="yes">k</italic>-th element, which in turn implies that s-leaping is expected to require fewer random numbers than Algorithm R when <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Because s-leaping is guaranteed to have the same number of random numbers as Algorithm R for all <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, the number of random numbers that s-leaping demands is always fewer than or equal to that of Algorithm R.</p>
      <p>To analyze how the relative size of <italic toggle="yes">k</italic> with respect to <italic toggle="yes">n</italic> affects the number of required random numbers in each method, we expressed as functions of a proportional size factor the ratio of the random numbers required in s-leaping and the optimal next selection method over the random numbers required in Algorithm R (<xref rid="btad399-F1" ref-type="fig">Fig. 1</xref>). This shows that the efficiency of the optimum next selection method decreases more drastically than that of s-leaping as the reservoir-size proportional factor increases: when <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.1</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, s-leaping is 110% more efficient and the optimum next selection method is 100% more efficient than Algorithm R; when <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.3</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, s-leaping, 15% more efficient, the optimum next selection method, 3% less efficient; and when <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0.4</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, s-leaping, 4% more efficient, the optimum next selection method, 18% less efficient.</p>
      <fig position="float" id="btad399-F1">
        <label>Figure 1.</label>
        <caption>
          <p>A theoretical comparison of estimates of random numbers required for each method. The <italic toggle="yes">x</italic>-axis is the proportion of the reservoir size to the total size; the <italic toggle="yes">y</italic>-axis is the ratio of an estimated number of random numbers needed in each method to the number of random numbers required in Algorithm R.</p>
        </caption>
        <graphic xlink:href="btad399f1" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.4 Accuracy evaluation of s-leaping</title>
      <p>As a proof-of-concept, we implemented s-leaping, along with three downsampling methods, Algorithms R, L, and Z (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>, <xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>), in C. Algorithms L and Z are both next selection methods, but with widely different algorithmic designs for step-size sampling. Algorithm L requires three random numbers per selection, but with a simpler step-size sampling procedure; Algorithm Z requires two random numbers per selection, but with a more complex step-size sampling procedure.</p>
      <p>In this experiment, we chose <italic toggle="yes">n</italic> to be 100, 300, or 500 million, while varying <italic toggle="yes">k</italic> to have four values: 10, 20, 30, and 40 million. (Note that although the value of <italic toggle="yes">n</italic> was decided in prior, this information was used only for the performance evaluation purpose only.) These numbers are within the realm of biological relevance: with 300 bp read-pair length, these numbers roughly correspond to downsampling from 9×, 27×, and 45× coverage data to 0.9×, 1.8×, 2.7×, and 3.6× coverage data in the human genome. These settings also allowed us to evaluate the performance in a reasonable range of <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>—from 0.02 to 0.4. For each combination of <italic toggle="yes">k</italic> and <italic toggle="yes">n</italic>, we ran each method 10 times with different random seeds. In s-leaping, we fixed the leap-size factor to be 0.005 (i.e. <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). Because it devises an approximated next-selection method, s-leaping, along with Algorithms L and Z, is referred to as a next selection-based method.</p>
      <p>First, we analyzed how efficient the three next selection-based methods were in comparison with Algorithm R. To this end, we computed the ratio of the average runtime of each next selection-based method to that of Algorithm R. In this setup, thus, a runtime ratio less than 1 indicates that a next selection-based method has better computational efficiency than Algorithm R. As expected, all the next selection-based methods had a trend to increase efficiency as the <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> ratio decreased (<xref rid="btad399-F2" ref-type="fig">Fig. 2</xref>); however, they had widely different conditions under which to outperform Algorithm R. S-leaping was more efficient than Algorithm R when <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>≤</mml:mo><mml:mn>0.2</mml:mn></mml:mrow></mml:math></inline-formula> and they were comparable when <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is 0.3 [1.02, 95% confidence interval (CI): 0.98–1.06] and 0.4 (1.04, 95% CI: 1.00–1.09). Algorithm Z was more efficient than Algorithm R when <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>0.133</mml:mn></mml:mrow></mml:math></inline-formula>, and they were comparable when <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is 0.2 [1.03, 95% CI: 0.99–1.06], whereas Algorithm L was more efficient than Algorithm R only when <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>0.02</mml:mn></mml:mrow></mml:math></inline-formula>. Among the three next selection-based methods, s-leaping was consistently the fastest, outperforming Algorithm R in most of our <italic toggle="yes">k</italic>−<italic toggle="yes">n</italic> settings; Algorithm Z, the second; Algorithm L, the distant third. Although s-leaping and Algorithm Z both showed strong competitive advantages over Algorithm R when the <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> ratio was smaller, s-leaping demonstrated higher efficiency than Algorithm Z. For example, when <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>500</mml:mn></mml:mrow></mml:math></inline-formula> million, s-leaping was 20% faster than Algorithm Z with <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula> million (s-leaping, 0.70, 95% CI: 0.68–0.72; Algorithm Z, 0.85, 95% CI: 0.82–0.87) and it was 39% faster with <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> million (s-leaping, 0.38, 95% CI: 0.37–0.39; Algorithm Z, 0.53, 95% CI: 0.52–0.53).</p>
      <fig position="float" id="btad399-F2">
        <label>Figure 2.</label>
        <caption>
          <p>A comparison of runtime among the four downsampling methods. The <italic toggle="yes">x</italic>-axis is the reservoir size; the <italic toggle="yes">y</italic>-axis is the average runtime relative to that of Algorithm R. Error bars indicate 95% confidence level by a second-order Taylor approximation. (a) The runtime results from downsampling of 100 million elements; (b) 300 million; (c) 500 million. Here, leap indicates s-leaping; algo_R, Algorithm R; algo_L, Algorithm L; algo_Z, Algorithm Z.</p>
        </caption>
        <graphic xlink:href="btad399f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.5 Accuracy evaluation of s-leaping</title>
      <p>Next, because s-leaping is an approximated downsampling method, we evaluated its ability to generate unbiased samples. To this end, we used the maximum D—the maximum discrepancy between the cumulative distributions of two samples that the Kolmogorov–Smirnov test uses as the test statistic. We measured the maximum D between the selected <italic toggle="yes">k</italic> elements and the unit uniform distribution, allowing us to evaluate the degree of uniformity in the selected elements. We computed the maximum D for each downsampling run from the experiment described in the previous section and measured the maximum D distribution for each method.</p>
      <p>We found that the maximum D values from s-leaping (mean <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.75</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mn>7.46</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) were distributed similarly to those from Algorithms R (mean <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.72</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mn>7.49</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) and L (mean <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.78</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mn>8.78</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>), showing no evidence of s-leaping with lower accuracy than those methods (<xref rid="btad399-F3" ref-type="fig">Fig. 3</xref>). In fact, s-leaping had more consistent and lower maximum D measures than those from Algorithm Z (mean <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.84</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, sd <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.15</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>), suggesting that s-leaping had a better goodness-of-fit than Algorithm Z. To further evaluate the accuracy of s-leaping (i.e. the goodness of fit to a uniform distribution), we computed the critical value at the significance level <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>—the value at which the probability to reject the null hypothesis is 0.999 in the Kolmogorov–Smirnov test—and compared the maximum D values with this critical value. The critical value was found to be <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.63</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>; this value was substantially higher than all the maximum D values from s-leaping, along with the other methods (<xref rid="btad399-F3" ref-type="fig">Fig. 3</xref>).</p>
      <fig position="float" id="btad399-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Results from analysis of goodness-of-fit to uniform distribution. The <italic toggle="yes">x</italic>-axis is the four downsampling methods; the <italic toggle="yes">y</italic>-axis is the maximum D measure against the uniform distribution. A violin plot shows the distribution of maximum D samples from a downsampling method. The dashed horizontal line indicates the threshold level of the Kolmogorov–Smirnov test at <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>. Here, sleap indicates s-leaping; algo_R, Algorithm R; algo_L, Algorithm L; algo_Z, Algorithm Z.</p>
        </caption>
        <graphic xlink:href="btad399f3" position="float"/>
      </fig>
      <p>We have thus far set the leap size <italic toggle="yes">s</italic> to be proportional to <italic toggle="yes">k</italic> with a fixed proportion, <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> (e.g. when <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 10 million, <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 50 000). Our results indicated that this leap-size proportional factor was small enough to have accuracy comparable to that of the exact reservoir-sampling methods. To further evaluate the accuracy of s-leaping, we analyzed the extent to which the accuracy of s-leaping changes with respect to the leap-size factor. To this end, we set <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 20 million and <italic toggle="yes">n</italic> to be 100, 300, or 500 million, we ran s-leaping 10 times for each setup, and computed maximum D for each leap-size factor value. We set the leap-size factor to take nine values ranging from 0.001 to 0.5 (i.e. <italic toggle="yes">s</italic> ranges from 20 000 to 1 million).</p>
      <p>We had expected maximum D to be an increasing function of leap-size factor and a decreasing function of <italic toggle="yes">n</italic>—i.e. the accuracy of s-leaping becomes worse with a larger leap size and smaller total size. Indeed, we observed this pattern, but only to a limited extent: maximum D showed clear positive relation patterns only for large leap-size factor values (from 0.1 to 0.5) with <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo></mml:mrow></mml:math></inline-formula> 100 and 300 million (<xref rid="btad399-F4" ref-type="fig">Fig. 4</xref>). Regardless of the value of <italic toggle="yes">n</italic>, we found maximum D to have similarly small values below <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mn>4.0</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> for leap-size factor ranging from 0.001 to 0.1, indicating that within this range, the accuracy of s-leaping is high and independent of the leap size. For example, when the leap-size factor is 0.1 (i.e. <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn><mml:mo>,</mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula>), the mean maximum D was <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.39</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (sd <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mn>5.63</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) with <italic toggle="yes">n</italic> = 100 million; <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.79</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (sd <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.49</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) with <italic toggle="yes">n</italic> = 300 million; and <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.06</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> (sd <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mn>5.08</mml:mn><mml:mo>×</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>) with <italic toggle="yes">n</italic> = 500 million. Under all the settings we studied, we found the maximum D values to be well below the critical value at significance level <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>=</mml:mo><mml:mn>0.999</mml:mn></mml:mrow></mml:math></inline-formula>, demonstrating high levels of accuracy in a wide range of conditions.</p>
      <fig position="float" id="btad399-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Comparison of downsampling accuracy with respect to different leap size factor values. The maximum D distributions of nine different leap size factor values are compared. The reservoir size <italic toggle="yes">k</italic> is set to 20 million, while the population size <italic toggle="yes">n</italic> is changed to have three different values: (a) <italic toggle="yes">n</italic> = 100 million; (b) 300 million; and (c) 500 million. The <italic toggle="yes">x</italic>-axis is the leap-size factor; the <italic toggle="yes">y</italic>-axis is the maximum D measure against the uniform distribution. Each distribution is generated from 10 samples.</p>
        </caption>
        <graphic xlink:href="btad399f4" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.6 Fadso: an implementation of s-leaping for FASTQ downsampling</title>
      <p>To apply s-leaping on FASTQ data, we have developed fadso (FAstq DownSampling Optimizer), a command-line tool that downsamples FASTQ data to have the user-specified read size. This tool takes either gzipped or plain FASTQ files, downsamples single- or paired-end reads, and implements s-leaping, along with Algorithm L (<xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>), Algorithm R (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>), and Algorithm Z (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>).</p>
      <p>To evaluate the performance of fadso, we compared its speed and memory usage with those of seqtk, an efficient and lightweight tool for processing sequencing data in the FASTQ format, with a downsampling feature to output a desired number of reads. To this end, we selected s-leaping as the downsampler in fadso. Through source-code inspection, we found that seqtk implemented Algorithm R for downsampling of FASTQ data with a specific target size. Note that both fadso and seqtk are single-threaded programs written in C.</p>
      <p>To measure the downsampling performance, we used the forward-read set of ERR174310 from the Illumina Platinum genome project (<xref rid="btad399-B2" ref-type="bibr">Eberle <italic toggle="yes">et al.</italic> 2017</xref>) that has 208 million 101 bp reads. We downsampled this read set to target sizes ranging from 5 to 20 million with the 5 million-size increment and repeated this procedure for five times with different random seeds. We evaluated the downsampling performance by measuring the runtime and peak memory usage of the programs.</p>
      <p>Fadso consistently outperformed seqtk in terms of speed: fadso averaged 12% speedup for the 5 million downsampling size; 8% for the 10 million size; 12% for the 15 million size; and 10% for the 20 million size (<xref rid="btad399-F5" ref-type="fig">Fig. 5a</xref>). The results from the peak memory usage showed fadso to consistently have smaller memory footprints than seqtk, reducing the memory requirement by around 21% in each downsampling size setting (<xref rid="btad399-F5" ref-type="fig">Fig. 5b</xref>).</p>
      <fig position="float" id="btad399-F5">
        <label>Figure 5.</label>
        <caption>
          <p>Performance comparison of FASTQ downsampling tools. The <italic toggle="yes">x</italic>-axis is the target read count; the <italic toggle="yes">y</italic>-axis is the performance measure (<inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> for each setting). (a) Runtime was measured in seconds; (b) peak memory usage, in gigabytes. Bars indicate sample average from five runs; the error bars, sample standard deviations.</p>
        </caption>
        <graphic xlink:href="btad399f5" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>3 Discussion</title>
    <p>Our results demonstrated s-leaping to be highly efficient, while achieving accurate downsampling—with no sign of deteriorating accuracy, comparable to exact reservoir-sampling methods. The high performance of s-leaping arose from the assumption that the selection probability changes negligibly within a relatively small interval compared with the reservoir size. Not only did this leaping assumption simplify the sampling of next selections, but it also accelerated the calculation of the selection probability. These improved the runtime efficiency especially when <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>≫</mml:mo><mml:mi>k</mml:mi><mml:mo>≫</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
    <p>This type of “leaping” strategies to accelerate the runtime by sacrificing the exactness is not new; indeed, in the field of stochastic chemical kinetics, an approximate simulation method called tau-leaping (<xref rid="btad399-B4" ref-type="bibr">Gillespie 2001</xref>) was shown to improve the time efficiency over an exact method called Gillespie’s stochastic simulation algorithm (<xref rid="btad399-B3" ref-type="bibr">Gillespie 1976</xref>)—which simulates every single reaction event in a well-stirred chemically reacting system governed by a continuous-time jump Markov process. By assuming reaction rates to change negligibly within a specified time interval, the tau-leaping method allows the system to leap along each interval. Although the basis of the speedup is different between s-leaping and tau-leaping, they both stem from the same underlying concept, which sacrifices miniature differences from the exact solution within subintervals to increase computational efficiency. Our study provided evidence for a successful application of a leaping strategy for an important task in omics research—downsampling of large HTS data.</p>
    <p>To apply s-leaping to downsampling of FASTQ data, we developed fadso, a downsampling tool implementing s-leaping for FASTQ data. In terms of both runtime and memory usage, fadso was more efficient than seqtk, the leading FASTQ processing tool implementing Algorithm R to downsample FASTQ data. However, considering the performance results of s-leaping with respect to Algorithm R, we found fadso’s speedup improvement to be lower than expected. This can be explained by the computational overhead involved in reading, uncompressing, and parsing compressed FASTQ files that might have weakened the effects of the algorithmic speedup of s-leaping. Another possibility could be that the implementation of seqtk to parse compressed FASTQ files could be more efficient than that of fadso, which in turn might have overtaken some of s-leaping’s algorithmic advantage, suggesting that fadso could have some room to further increase its efficiency with a more efficient FASTQ parser in the future. Nevertheless, given fadso’s superior performance in memory usage, our results suggest the current version of fadso to process large FASTQ datasets at up to 40% higher throughput rate than seqtk in parallel computing settings.</p>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>Here, we introduced s-leaping, a novel downsampling algorithm tailored to downsample large data by approximating the next step-size probability using the concept of leaping, and developed fadso, a downsampling tool for FASTQ that implements s-leaping. We have shown that the accuracy of s-leaping is on par with exact reservoir-sampling methods and that the Fadso was deposited in Github. Its package is available to download at <ext-link xlink:href="https://github.com/hkuwahara/sleaping" ext-link-type="uri">https://github.com/hkuwahara/sleaping</ext-link>.</p>
  </sec>
  <sec>
    <title>5 Methods</title>
    <sec>
      <title>5.1 Algorithm R</title>
      <p>Reservoir sampling sequentially reads a streaming file and randomly samples <italic toggle="yes">k</italic> elements with the equal probability from the population of unknown size <italic toggle="yes">n</italic>. Waterman developed a direct approach of reservoir sampling called Algorithm R in the 1970s (<xref rid="btad399-B8" ref-type="bibr">Knuth 1997</xref>). Algorithm R first places the first <italic toggle="yes">k</italic> elements in the selection set called “reservoir” of size <italic toggle="yes">k</italic>, and for all <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, it selects the <italic toggle="yes">i-</italic>th element at probability <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> to replace a randomly picked element in the reservoir. At the end of <italic toggle="yes">j-</italic>th step (<inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>), each element in the reservoir is guaranteed to have probability <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> in the reservoir. This algorithm is simple and requires only one random variate per element, requiring <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> random variates in total.</p>
    </sec>
    <sec>
      <title>5.2 Next selection method</title>
      <p>We define the next selection method as another type of reservoir sampling that focuses on the number of steps it takes to select the next element. Just like Algorithm R, the next selection method first fills the reservoir with the first <italic toggle="yes">k</italic> elements. For all <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, it then randomly makes two decisions per selected element: the step size to the next selection and the index of an element in the reservoir to be replaced. Its sampling distribution can be derived from the probability to select the <italic toggle="yes">i-</italic>th element, <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. Let us first define <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be the probability that it takes exactly <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> steps to select the next element for the reservoir after the <italic toggle="yes">i-</italic>th element is processed. Then, we can express <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as
where <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability of selecting the (<inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)-th element.</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>p</mml:mi>
                </mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:msub>
            </mml:mrow>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mo>ν</mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>p</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mo>ν</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mrow>
              <mml:munderover>
                <mml:mo>∏</mml:mo>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>ν</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:munderover>
            </mml:mrow>
            <mml:mrow>
              <mml:mrow>
                <mml:mo>[</mml:mo>
                <mml:mrow>
                  <mml:mn>1</mml:mn>
                  <mml:mo>−</mml:mo>
                  <mml:mi>p</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>j</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
                <mml:mo>]</mml:mo>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mfrac>
                <mml:mi>k</mml:mi>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mo>ν</mml:mo>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mrow>
              <mml:munderover>
                <mml:mo>∏</mml:mo>
                <mml:mrow>
                  <mml:mi>j</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>ν</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:munderover>
            </mml:mrow>
            <mml:mrow>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>k</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Vitter developed Algorithm Z that faithfully samples <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> using this distribution or using the rejection-acceptance sampling with an easier envelop (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>). <xref rid="btad399-B11" ref-type="bibr">Li (1994)</xref> developed Algorithm L that treats the reservoir-sampling problem as a task of selecting indices of <italic toggle="yes">k</italic> smallest numbers from <italic toggle="yes">n</italic> randomly drawn numbers. Although the approach to select the next element can be widely different among different algorithms, the next selection method in general places the first <italic toggle="yes">k</italic> elements in the reservoir and for all <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, selects on average <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>≈</mml:mo><mml:mi>k</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> elements at the <italic toggle="yes">n-</italic>th elements. The time complexity of the next selection method, including Algorithms L and Z, was thus reported to be <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (<xref rid="btad399-B16" ref-type="bibr">Vitter 1985</xref>, <xref rid="btad399-B11" ref-type="bibr">Li 1994</xref>).</p>
    </sec>
    <sec>
      <title>5.3 Next selection sampling in s-leaping</title>
      <p>To derive the step-size sampling used in s-leaping, we start from the definition of <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Direct sampling of <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> from <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is complicated and s-leaping uses an approximation. To approximate <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we first define a leap size <italic toggle="yes">s</italic> that is much smaller than the reservoir size (i.e. <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≪</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>). Within this relatively small leap subinterval, we assume that differences in <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are insignificant and that for all <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is well approximated by <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This allows us to approximate <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>ν</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by the geometric distribution with <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>:
</p>
      <disp-formula id="E2">
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>p</mml:mi>
                </mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:msub>
            </mml:mrow>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mo>ν</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo>|</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>≈</mml:mo>
            <mml:mrow>
              <mml:mfrac>
                <mml:mi>k</mml:mi>
                <mml:mrow>
                  <mml:mi>m</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>0.5</mml:mn>
                  <mml:mi>s</mml:mi>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mrow>
              <mml:msup>
                <mml:mrow>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mn>1</mml:mn>
                        <mml:mo>−</mml:mo>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>k</mml:mi>
                            <mml:mrow>
                              <mml:mi>m</mml:mi>
                              <mml:mo>+</mml:mo>
                              <mml:mn>0.5</mml:mn>
                              <mml:mi>s</mml:mi>
                            </mml:mrow>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mo>ν</mml:mo>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
              </mml:msup>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Thus, with the inverse transform sampling, we can sample a geometric random variate <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> as follows:
where <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">u</italic> is a unit uniform random variate. The sampling of <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> requires only one unit uniform random variate, demanding only two unit uniform random variates per selection step. In addition, because the distribution of <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> is fixed within each leap subinterval, the sampling of <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mo>ν</mml:mo></mml:math></inline-formula> can be streamlined by reusing <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mo>λ</mml:mo></mml:math></inline-formula>.</p>
      <disp-formula id="E3">
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mo>ν</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mo>⌊</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>ln</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>u</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mo>λ</mml:mo>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>⌋</mml:mo>
            </mml:mrow>
            <mml:mo>+</mml:mo>
            <mml:mn>1</mml:mn>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>5.4 S-leaping algorithm</title>
      <p>Below shows the algorithm of s-leaping with zero-based numbering:<boxed-text id="btad399-BOX1" position="float"><caption><p>Require: <italic toggle="yes">k</italic> the reservoir size; <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> the leap-size factor;</p></caption><p>1: for <italic toggle="yes">i</italic> from 0 to <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, select elements using Algorithm R;</p><p>2: set <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>←</mml:mo><mml:mo>ϵ</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>;</p><p>3: <bold>while</bold> not end of file <bold>do</bold></p><p>4:   set <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>←</mml:mo><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>0.5</mml:mn><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>←</mml:mo><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>;</p><p>5:   <bold>while</bold> True <bold>do</bold></p><p>6:    set <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> a unit uniform random variate; <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mo>ν</mml:mo><mml:mo>←</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mo>λ</mml:mo></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>;</p><p>7:    update <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>←</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mo>ν</mml:mo></mml:mrow></mml:math></inline-formula>;</p><p>8:    <bold>if</bold><inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>≥</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p><p>9:     update <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, and break from the loop;</p><p>10:    <bold>end if</bold></p><p>11:    <bold>if</bold> end of file <bold>then</bold></p><p>12:    terminate;</p><p>13:    <bold>end if</bold></p><p>14:    set <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> a discrete uniform random variate in <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>;</p><p>15:    update the <italic toggle="yes">r</italic>-th reservoir element by the (<inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>)-th element;</p><p>16:   <bold>end while</bold></p><p>17: <bold>end while</bold></p></boxed-text>The leap-size factor <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> needs to be small in order to have reasonable accuracy. We used 0.005 as the default value of <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>5.5 Estimation of the number of random numbers needed in the next selection method</title>
      <p>First, we estimated the average number of selected elements after processing <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> elements in the next selection method, ignoring the first <italic toggle="yes">k</italic> elements that were used to fill the reservoir initially. Because the probability to select the <italic toggle="yes">i</italic>-th element is <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>, the average number of selected elements can be expressed by a harmonic series and approximated using the natural logarithm:
</p>
      <disp-formula id="E4">
        <label>(1)</label>
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:munderover>
                <mml:mo>∑</mml:mo>
                <mml:mrow>
                  <mml:mi>i</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:mi>k</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>1</mml:mn>
                </mml:mrow>
                <mml:mi>n</mml:mi>
              </mml:munderover>
            </mml:mrow>
            <mml:mrow>
              <mml:mrow>
                <mml:mfrac>
                  <mml:mi>k</mml:mi>
                  <mml:mi>i</mml:mi>
                </mml:mfrac>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>≈</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mrow>
              <mml:mrow>
                <mml:msubsup>
                  <mml:mo>∫</mml:mo>
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                  <mml:mi>n</mml:mi>
                </mml:msubsup>
              </mml:mrow>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mi>x</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
                <mml:mi>d</mml:mi>
                <mml:mi>x</mml:mi>
              </mml:mrow>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mi>ln</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mi>n</mml:mi>
                    <mml:mrow>
                      <mml:mi>k</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>≈</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mi>ln</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mi>n</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Let <italic toggle="yes">t</italic> be the average number of random numbers needed to select the next element per selection step. Then because each selected element needs to replace a randomly picked element in the reservoir, we can approximate the average number of random numbers needed in the next selection method as follows:
</p>
      <disp-formula id="E5">
        <label>(2)</label>
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>k</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mi>t</mml:mi>
                <mml:mo>+</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mi>ln</mml:mi>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mrow>
                  <mml:mfrac>
                    <mml:mi>n</mml:mi>
                    <mml:mi>k</mml:mi>
                  </mml:mfrac>
                </mml:mrow>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>.</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Because every step-size sampling demands <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, its lowest number of random numbers required to process <italic toggle="yes">n</italic> elements is <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Because the probability to select 2<italic toggle="yes">k</italic>-th element is 0.5, the average number of random numbers needed for this element is the same between Algorithm R and the optimal next selection method. Thus, up until 2<italic toggle="yes">k</italic>-th element, Algorithm R is expected to generate fewer random numbers than the optimal next selection method. To estimate the proportional difference of the random numbers needed in Algorithm R with respect to the optimal next selection method, we have
for <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≫</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Thus, Algorithm R generates 28% fewer random numbers than the best next selection method.</p>
      <disp-formula id="E6">
        <label>(3)</label>
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mrow>
              <mml:mfrac>
                <mml:mi>k</mml:mi>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                  <mml:mi>k</mml:mi>
                  <mml:mi>ln</mml:mi>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mn>2</mml:mn>
                            <mml:mi>k</mml:mi>
                          </mml:mrow>
                          <mml:mi>k</mml:mi>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mfrac>
                <mml:mn>1</mml:mn>
                <mml:mrow>
                  <mml:mn>2</mml:mn>
                  <mml:mi>ln</mml:mi>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:mo>≈</mml:mo>
            <mml:mn>0.72.</mml:mn>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>5.6 Estimation of the number of random numbers needed in s-leaping</title>
      <p>Because s-leaping uses Algorithm R to process the first 2<italic toggle="yes">k</italic> elements, it generates exactly <italic toggle="yes">k</italic> random numbers for the first 2<italic toggle="yes">k</italic> elements. After this point, s-leaping demands two random numbers per selection step, the lowest of the next selection method. Thus, the total number of random numbers generated in s-leaping to process <italic toggle="yes">n</italic> elements is expected to be
</p>
      <disp-formula id="E7">
        <label>(4)</label>
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mrow>
                      <mml:munderover>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mi>n</mml:mi>
                      </mml:munderover>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mfrac>
                          <mml:mi>k</mml:mi>
                          <mml:mi>i</mml:mi>
                        </mml:mfrac>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mo>≈</mml:mo>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>n</mml:mi>
                            <mml:mrow>
                              <mml:mn>2</mml:mn>
                              <mml:mi>k</mml:mi>
                            </mml:mrow>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mi>k</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>n</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>≈</mml:mo>
                    <mml:mn>2</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mi>ln</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mrow>
                          <mml:mfrac>
                            <mml:mi>n</mml:mi>
                            <mml:mi>k</mml:mi>
                          </mml:mfrac>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>0.39</mml:mn>
                    <mml:mi>k</mml:mi>
                    <mml:mo>.</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Because the optimal next selection method requires <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mi>ln</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to process <italic toggle="yes">n</italic> elements, s-leaping is expected to require 0.39<italic toggle="yes">k</italic> fewer random numbers than the optimal next selection method in total.</p>
    </sec>
    <sec>
      <title>5.7 Runtime measure of the four reservoir-sampling methods</title>
      <p>We implemented s-leaping and Algorithms R, L, and Z in C. To measure the CPU time of each method, we called the clock function right before and after the downsampling function call. We then converted the CPU clock count into the time unit of seconds to obtain the runtime. For each combination of <italic toggle="yes">k</italic> and <italic toggle="yes">n</italic>, the ratio of the average runtime of each next selection-based method to that of Algorithm R was sampled using 10 data points. To obtain the 95% confidence interval of the relative runtime, we assumed that runtime of each next selection method is independent of that of Algorithm R and used the second-order Taylor approximation method with zero covariance.</p>
    </sec>
    <sec>
      <title>5.8 Computation of maximum D</title>
      <p>For each combination of <italic toggle="yes">k</italic> and <italic toggle="yes">n</italic>, we performed downsampling 10 times, making the number of runs 120 for each method in total. In this downsampling, each reservoir element contained an index of a selected element, which is a number between 0 and <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. The <italic toggle="yes">k</italic> selected numbers were then sorted and partitioned into 1000 bins to measure the empirical cumulative distribution at the permille resolution. We then computed the maximum D measure of the empirical cumulative distribution against the unit uniform distribution using the 1000 data points. The violin plots were generated from 40 maximum D samples for each method.</p>
    </sec>
    <sec>
      <title>5.9 Leap-size factor in fadso</title>
      <p>S-leaping has one tuning parameter, the leap-size factor <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula>. In fadso, we fixed this value to be 0.005. This value was determined so as to make the maximum discrepancy of the approximated selection probability reasonably small under a wide range of settings. The selection probability of the <italic toggle="yes">i</italic>-th element is <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>/</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>; hence, the maximum discrepancy between s-leaping and the exact reservoir sampling occurs when <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, with the relative difference being
</p>
      <disp-formula id="E8">
        <label>(5)</label>
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mtable>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mi>s</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mo>−</mml:mo>
                          <mml:mi>k</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>s</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>/</mml:mo>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>s</mml:mi>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mi>s</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mo>+</mml:mo>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mn>0.5</mml:mn>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mi>k</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mn>0.5</mml:mn>
                          <mml:mo>ϵ</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                    <mml:mo>.</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>With <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mo>ϵ</mml:mo><mml:mo>=</mml:mo><mml:mn>0.005</mml:mn></mml:mrow></mml:math></inline-formula>, this upper limit becomes 0.00125.</p>
    </sec>
    <sec>
      <title>5.10 Performance measurement of the FASTQ downsampling tools</title>
      <p>The forward read FASTQ file of ERR174310 from the Illumina Platinum Sequencing project (study accession: PRJEB3246) was downloaded from European Nucleotide Archive. This FASTQ dataset contained 208M 200 bp read-pairs and to evaluate the performance of FASTQ downsampling tools, it was downsampled to have read counts ranging from 5 to 20 M with 5 M increment. For each downsampling size, five single-threaded runs were performed, and the CPU time and peak memory size from each run were measured using the GNU time program. The runtime was computed by adding the user CPU time and the system CPU time; the peak memory size was computed from the maximum resident set size.</p>
    </sec>
    <sec>
      <title>5.11 Runtime environment information</title>
      <p>All of the runs were carried out on an Intel Xeon Gold 6130 machine with 132 GB of RAM.</p>
    </sec>
  </sec>
</body>
<back>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This publication is based upon work supported by the King Abdullah University of Science and Technology (KAUST) Office of Research Administration (ORA) under Award Nos FCC/1/1976-44-01, FCC/1/1976-45-01, URF/1/4663-01-01, REI/1/5202-01-01, REI/1/4940-01-01, and RGC/3/4816-01-01.</p>
  </sec>
  <sec>
    <title>Code availability</title>
    <p>The C source code to run s-leaping, Algorithms R, L, and Z, as well as the fadso package is available at <ext-link xlink:href="https://github.com/hkuwahara/sleaping" ext-link-type="uri">https://github.com/hkuwahara/sleaping</ext-link>. The fadso tool depends on the zlib library. And to compile the source and generate an executable, cmake is used.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The WGS sample from the Illumina Platinum genome project that we used to evaluate the performance of fadso is available with accession number ERR174310 from European Nucleotide Archive.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad399-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Davies</surname><given-names>RW</given-names></string-name>, <string-name><surname>Kucka</surname><given-names>M</given-names></string-name>, <string-name><surname>Su</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Rapid genotype imputation from sequence with reference panels</article-title>. <source>Nat Genet</source><year>2021</year>;<volume>53</volume>:<fpage>1104</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">34083788</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Eberle</surname><given-names>MA</given-names></string-name>, <string-name><surname>Fritzilas</surname><given-names>E</given-names></string-name>, <string-name><surname>Krusche</surname><given-names>P</given-names></string-name></person-group><etal>et al</etal><article-title>A reference data set of 5.4 million phased human variants validated by genetic inheritance from sequencing a three-generation 17-member pedigree</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>157</fpage>–<lpage>64</lpage>.<pub-id pub-id-type="pmid">27903644</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gillespie</surname><given-names>DT.</given-names></string-name></person-group><article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title>. <source>J Comput Phys</source><year>1976</year>;<volume>22</volume>:<fpage>403</fpage>–<lpage>34</lpage>.</mixed-citation>
    </ref>
    <ref id="btad399-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gillespie</surname><given-names>DT.</given-names></string-name></person-group><article-title>Approximate accelerated stochastic simulation of chemically reacting systems</article-title>. <source>J Chem Phys</source><year>2001</year>;<volume>115</volume>:<fpage>1716</fpage>–<lpage>33</lpage>.</mixed-citation>
    </ref>
    <ref id="btad399-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gilly</surname><given-names>A</given-names></string-name>, <string-name><surname>Southam</surname><given-names>L</given-names></string-name>, <string-name><surname>Suveges</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Very low-depth whole-genome sequencing in complex trait association studies</article-title>. <source>Bioinformatics (Oxford, England)</source><year>2019</year>;<volume>35</volume>:<fpage>2555</fpage>–<lpage>61</lpage>.<pub-id pub-id-type="pmid">30576415</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Goldfeder</surname><given-names>RL</given-names></string-name>, <string-name><surname>Priest</surname><given-names>JR</given-names></string-name>, <string-name><surname>Zook</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Medical implications of technical accuracy in genome sequencing</article-title>. <source>Genome Med</source><year>2016</year>;<volume>8</volume>:<fpage>24</fpage>.<pub-id pub-id-type="pmid">26932475</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Homburger</surname><given-names>JR</given-names></string-name>, <string-name><surname>Neben</surname><given-names>CL</given-names></string-name>, <string-name><surname>Mishne</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Low coverage whole genome sequencing enables accurate assessment of common variants and calculation of genome-wide polygenic scores</article-title>. <source>Genome Med</source><year>2019</year>;<volume>11</volume>:<fpage>74</fpage>.<pub-id pub-id-type="pmid">31771638</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B8">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Knuth</surname><given-names>DE.</given-names></string-name></person-group><source>The Art of Computer Programming, Vol. 2: Seminumerical Algorithms</source>, <edition>3rd edn.</edition><publisher-loc>Boston</publisher-loc>: <publisher-name>Addison-Wesley</publisher-name>, <year>1997</year>.</mixed-citation>
    </ref>
    <ref id="btad399-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Handsaker</surname><given-names>B</given-names></string-name>, <string-name><surname>Wysoker</surname><given-names>A</given-names></string-name></person-group>, <etal>et al</etal><article-title>The sequence alignment/map format and SAMtools</article-title>. <source>Bioinformatics (Oxford, England)</source><year>2009</year>;<volume>25</volume>:<fpage>2078</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">19505943</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>JH</given-names></string-name>, <string-name><surname>Mazur</surname><given-names>CA</given-names></string-name>, <string-name><surname>Berisa</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Low-pass sequencing increases the power of GWAS and decreases measurement error of polygenic risk scores compared to genotyping arrays</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>529</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">33536225</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>K-H.</given-names></string-name></person-group><article-title>Reservoir-sampling algorithms of time complexity</article-title><inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <source>ACM Trans Math Softw</source><year>1994</year>;<volume>20</volume>:<fpage>481</fpage>–<lpage>93</lpage>.</mixed-citation>
    </ref>
    <ref id="btad399-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lou</surname><given-names>RN</given-names></string-name>, <string-name><surname>Jacobs</surname><given-names>A</given-names></string-name>, <string-name><surname>Wilder</surname><given-names>AP</given-names></string-name></person-group><etal>et al</etal><article-title>A beginner’s guide to low-coverage whole genome sequencing for population genomics</article-title>. <source>Mol Ecol</source><year>2021</year>;<volume>30</volume>:<fpage>5966</fpage>–<lpage>93</lpage>.<pub-id pub-id-type="pmid">34250668</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McKenna</surname><given-names>A</given-names></string-name>, <string-name><surname>Hanna</surname><given-names>M</given-names></string-name>, <string-name><surname>Banks</surname><given-names>E</given-names></string-name></person-group><etal>et al</etal><article-title>The genome analysis toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data</article-title>. <source>Genome Res</source><year>2010</year>;<volume>20</volume>:<fpage>1297</fpage>–<lpage>303</lpage>.<pub-id pub-id-type="pmid">20644199</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rubinacci</surname><given-names>S</given-names></string-name>, <string-name><surname>Ribeiro</surname><given-names>DM</given-names></string-name>, <string-name><surname>Hofmeister</surname><given-names>RJ</given-names></string-name></person-group><etal>et al</etal><article-title>Efficient phasing and imputation of low-coverage sequencing data using large reference panels</article-title>. <source>Nat Genet</source><year>2021</year>;<volume>53</volume>:<fpage>120</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">33414550</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sun</surname><given-names>Y</given-names></string-name>, <string-name><surname>Liu</surname><given-names>F</given-names></string-name>, <string-name><surname>Fan</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Characterizing sensitivity and coverage of clinical wgs as a diagnostic test for genetic disorders</article-title>. <source>BMC Med Genomics</source><year>2021</year>;<volume>14</volume>:<fpage>102</fpage>.<pub-id pub-id-type="pmid">33849535</pub-id></mixed-citation>
    </ref>
    <ref id="btad399-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Vitter</surname><given-names>JS.</given-names></string-name></person-group><article-title>Random sampling with a reservoir</article-title>. <source>ACM Trans Math Softw</source><year>1985</year>;<volume>11</volume>:<fpage>37</fpage>–<lpage>57</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
