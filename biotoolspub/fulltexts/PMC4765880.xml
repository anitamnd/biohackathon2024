<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4765880</article-id>
    <article-id pub-id-type="pmid">26072505</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btv264</article-id>
    <article-id pub-id-type="publisher-id">btv264</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2015 Proceedings Papers Committee July 10 to July 14, 2015, Dublin, Ireland</subject>
        <subj-group subj-group-type="heading">
          <subject>Data</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Protein (multi-)location prediction: utilizing interdependencies via a generative model</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Simha</surname>
          <given-names>Ramanuja</given-names>
        </name>
        <xref ref-type="aff" rid="btv264-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Briesemeister</surname>
          <given-names>Sebastian</given-names>
        </name>
        <xref ref-type="aff" rid="btv264-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Kohlbacher</surname>
          <given-names>Oliver</given-names>
        </name>
        <xref ref-type="aff" rid="btv264-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Shatkay</surname>
          <given-names>Hagit</given-names>
        </name>
        <xref ref-type="aff" rid="btv264-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btv264-AFF1">
          <sup>3</sup>
        </xref>
        <xref ref-type="aff" rid="btv264-AFF1">
          <sup>4</sup>
        </xref>
        <xref ref-type="corresp" rid="btv264-COR1">*</xref>
      </contrib>
      <aff id="btv264-AFF1"><sup>1</sup>Department of Computer and Information Sciences, University of Delaware, Newark, DE, USA, <sup>2</sup>Applied Bioinformatics, Center for Bioinformatics, University of Tuebingen, Germany, <sup>3</sup>Center for Bioinformatics and Computational Biology, University of Delaware, Newark, DE, USA and <sup>4</sup>School of Computing, Queen’s University, Kingston, ON, Canada</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btv264-COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>10</day>
      <month>6</month>
      <year>2015</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>31</volume>
    <issue>12</issue>
    <fpage>i365</fpage>
    <lpage>i374</lpage>
    <permissions>
      <copyright-statement>© The Author 2015. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Proteins are responsible for a multitude of vital tasks in all living organisms. Given that a protein’s function and role are strongly related to its subcellular location, protein location prediction is an important research area. While proteins move from one location to another and can localize to multiple locations, most existing location prediction systems assign only a single location per protein. A few recent systems attempt to predict multiple locations for proteins, however, their performance leaves much room for improvement. Moreover, such systems do not capture dependencies among locations and usually consider locations as independent. We hypothesize that a multi-location predictor that captures location inter-dependencies can improve location predictions for proteins.</p>
      <p><bold>Results</bold>: We introduce a <italic>probabilistic generative model</italic> for protein localization, and develop a system based on it—which we call <italic>MDLoc</italic>—that utilizes inter-dependencies among locations to predict multiple locations for proteins. The model captures location inter-dependencies using Bayesian networks and represents dependency between features and locations using a mixture model. We use iterative processes for learning model parameters and for estimating protein locations. We evaluate our classifier MDLoc, on a dataset of single- and multi-localized proteins derived from the DBMLoc dataset, which is the most comprehensive protein multi-localization dataset currently available. Our results, obtained by using MDLoc, significantly improve upon results obtained by an initial simpler classifier, as well as on results reported by other top systems.</p>
      <p><bold>Availability and implementation:</bold> MDLoc is available at: <ext-link ext-link-type="uri" xlink:href="http://www.eecis.udel.edu/~compbio/mdloc">http://www.eecis.udel.edu/∼compbio/mdloc</ext-link>.</p>
      <p><bold>Contact: </bold><email>shatkay@udel.edu</email>.</p>
    </abstract>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Proteins are responsible for a multitude of diverse vital tasks in all living organisms (<xref rid="btv264-B28" ref-type="bibr">Rost <italic>et al.,</italic> 2003</xref>). Given that a protein’s function and role are strongly related to its subcellular location, protein location prediction is an important research area (<xref rid="btv264-B1" ref-type="bibr">Alberts <italic>et al.,</italic> 2002</xref>; <xref rid="btv264-B25" ref-type="bibr">Nair and Rost, 2008</xref>). Furthermore, the location of a protein helps understand the protein’s prospective utility as a drug target (<xref rid="btv264-B2" ref-type="bibr">Bakheet and Doig, 2009</xref>). Methods for determining protein locations include experimental as well as high-throughput computational ones. The experimental methods accurately determine protein locations, but are typically time consuming and are typically not cost effective for finding locations for a large number of proteins. Such methods include mass spectrometry (<xref rid="btv264-B12" ref-type="bibr">Dreger, 2003</xref>) and green fluorescence detection (<xref rid="btv264-B34" ref-type="bibr">Simpson <italic>et al.,</italic> 2000</xref>). On the other hand, the computational methods are fast, and can potentially predict locations for proteins whose actual locations have not yet been experimentally determined. Most of the prediction systems represent proteins using sequence-derived features and utilize machine learning methods (e.g. <xref rid="btv264-B4" ref-type="bibr">Blum <italic>et al.,</italic> 2009</xref>; <xref rid="btv264-B13" ref-type="bibr">Emanuelsson <italic>et al.,</italic> 2000</xref>; <xref rid="btv264-B26" ref-type="bibr">Nakai and Kanehisa, 1991</xref>; <xref rid="btv264-B32" ref-type="bibr">Shatkay <italic>et al.,</italic> 2007</xref>).</p>
    <p>Proteins move from one location to another and localize to multiple subcellular compartments (<xref rid="btv264-B24" ref-type="bibr">Murphy, 2010</xref>; <xref rid="btv264-B27" ref-type="bibr">Pohlschroder <italic>et al.,</italic> 2005</xref>). For instance, the enzyme <italic>TREX1</italic>, which assists in DNA repair, is primarily present in the cytoplasm but is also transported to the nucleus in response to DNA damage (<xref rid="btv264-B37" ref-type="bibr">Tomicic <italic>et al.,</italic> 2013</xref>). Thus, predicting multiple locations for proteins is important, as protein movement across locations enables the protein to serve multiple distinct functions. Nevertheless, all prediction systems mentioned earlier and most current systems assign only a single location per protein. Since proteins localize systematically, and translocation occurs only among specific locations for the purpose of a particular subcellular function, our hypothesis is that modeling inter-depedencies among locations can assist in predicting locations of proteins more accurately.</p>
    <p>Posing the problem using computational, machine-learning terms, assigning multiple locations to proteins is a <italic>multi-label classification</italic> task. Traditional single-label classification assigns a single <italic>label</italic> (location) to each <italic>instance</italic> (protein), and is addressed by methods such as Support Vector Machines (<xref rid="btv264-B31" ref-type="bibr">Scholkopf and Smola, 2002</xref>), naïve Bayes or neural networks (<xref rid="btv264-B29" ref-type="bibr">Russell and Norvig, 2010</xref>). Multi-label classification, on the other hand, aims to associate each instance with possibly multiple classes. Some of the simplest and commonly used approaches transform the multi-label classification task into one or more single-label classification task(s) (<xref rid="btv264-B38" ref-type="bibr">Tsoumakas <italic>et al.,</italic> 2010</xref>); such approaches do not capture label inter-dependencies. More sophisticated multi-label classification approaches attempt to capture label inter-dependencies and incorporate them into the classification process. Such multi-label classification methods have not yet been employed in the context of protein location prediction.</p>
    <p>In this article, we present a new, dependency-based probabilistic generative model for eukaryotic protein localization, and develop a multi-location prediction system—which we call <italic>MDLoc</italic>, to predict locations of multiply localized proteins. As was done before (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>; <xref rid="btv264-B21" ref-type="bibr">King and Guda, 2007</xref>; <xref rid="btv264-B22" ref-type="bibr">Li <italic>et al.,</italic> 2012</xref>), we use sequence-derived features and Gene Ontology (GO) terms to represent proteins. Here we introduce a new model using Bayesian networks to directly address and capture inter-dependencies among locations. Furthermore, we present the concept of <italic>location dependency sets</italic> and use a mixture model to represent <italic>feature dependency on location-combinations</italic>. The new system uses a generative model and an iterative procedure for estimating its parameters, and effectively improves the estimation process of multi-locations. Our method is based on iteratively learning parameters of the location-Bayesian-network and the mixture model, while re-inferring the location estimates of the proteins in each iteration. This improves on our preliminary system, which comprised a collection of Bayesian network classifiers, where location inter-dependencies were not learnt as part of the model but rather captured based on simple estimates of location values (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>).</p>
    <p>We evaluate MDLoc on a dataset derived from the DBMLoc dataset (<xref rid="btv264-B39" ref-type="bibr">Zhang <italic>et al.,</italic> 2008</xref>), which is the most comprehensive protein multi-localization dataset currently available, using multiple runs of 5-fold cross-validation. We show that the performance of MDLoc on multi-localized proteins improves over earlier results for a top performing system, YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). The improved results obtained by MDLoc demonstrate the advantage of utilizing location inter-dependencies and feature dependencies on locations in the prediction process.</p>
    <p>The rest of the article proceeds as follows: Section 2 surveys methods for protein multi-location prediction. In Section 3, we introduce the concept of <italic>location dependency sets</italic> and provide relevant notations; we also present our new probabilistic generative model for protein localization, which captures dependencies between protein-features and locations. In Section 4, we discuss the model parameters, the learning procedure used for finding them, and the inference technique used for predicting multiple protein locations. Experiments and results are presented in Section 5, followed by conclusions and future directions.</p>
  </sec>
  <sec id="SEC2">
    <title>2 Related work</title>
    <p>A number of recent location prediction systems attempt to predict multiple locations for proteins, however their performance leaves much room for improvement. While most use sequence-derived features (e.g. amino acid composition) and GO terms to represent proteins and to predict protein locations, a few are based solely on sequence-based similarity. The former class of methods incorporate one or more of the following classifiers: <italic>k</italic>-nearest neighbors (<italic>k</italic>-NN, <xref rid="btv264-B9" ref-type="bibr">Chou <italic>et al.,</italic> 2011</xref>), Support Vector Machines (<xref rid="btv264-B22" ref-type="bibr">Li <italic>et al.,</italic> 2012</xref>), naïve Bayes (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>) and neural networks (<xref rid="btv264-B13" ref-type="bibr">Emanuelsson <italic>et al.,</italic> 2000</xref>). KnowPred<sub>site</sub> (<xref rid="btv264-B23" ref-type="bibr">Lin <italic>et al.,</italic> 2009</xref>) is an example of the latter, similarity based, class of methods.</p>
    <p>Systems that use <italic>k</italic>-NN adaptations to predict multiple locations for proteins include WoLF PSORT (<xref rid="btv264-B19" ref-type="bibr">Horton <italic>et al.,</italic> 2007</xref>), Euk-mPLoc (<xref rid="btv264-B10" ref-type="bibr">Chou and Shen, 2007</xref>), iLoc-Euk (<xref rid="btv264-B9" ref-type="bibr">Chou <italic>et al.,</italic> 2011</xref>) and an ensemble system (<xref rid="btv264-B22" ref-type="bibr">Li <italic>et al.,</italic> 2012</xref>). WoLF PSORT outputs for a query protein the location-combination that is most frequent among the protein’s <italic>k</italic>-NN in the training set; the predictions are thus restricted to location-combinations already present in the set. Both iLoc-Euk and Euk-mPLoc compute a score for each candidate location, based on the query protein; iLoc-Euk outputs locations having the highest scores; the number of locations is the same as that associated with the query protein’s nearest neighbor in the dataset; Euk-mPLoc assigns the protein to locations whose score lies within a certain deviation from the highest score.</p>
    <p>All the methods described thus far treat locations as <italic>independent</italic> from one another and do not utilize possible inter-dependencies among locations in the prediction process. A few systems, however, have tried to make use of location inter-dependencies to predict multiple locations for proteins. For example, the classifier by <xref rid="btv264-B17" ref-type="bibr">He <italic>et al.</italic> (2012)</xref> attempts to use pairwise location- <italic>correlation</italic> in the prediction process, but does not use more complex inter-dependencies. YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>) introduces a new class for each location-combination represented in the training dataset and uses a naïve Bayes classifier to predict a probability distribution over these new classes. Thus, each classifier prediction is restricted to location-combinations in the training set. YLoc<sup>+</sup>’s performance was evaluated using the most comprehensive protein multi-localization dataset and is the highest among current multi-location prediction systems. In our earlier preliminary work (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>), we used a collection of Bayesian network classifiers to predict multiple locations of proteins. The simplified model used did not incorporate location-interdependencies into the iterative learning process, but rather utilized one-time estimates of location values to establish interdependencies. The performance of that classifier was comparable to that of YLoc<sup>+</sup> when using the same dataset, but did not improve on it.</p>
    <p>In the next section, we present a new probabilistic generative model for protein localization that directly incorporates the learning of location inter-dependencies into the iterative learning process. Additionally, we introduce the concept of <italic>location dependency sets</italic>, which enables us to capture feature dependencies on location-combinations in a mixture model setting. The resulting system <italic>MDLoc</italic>, shows significant improvement, according to all evaluation metrics, compared with previously reported performance for protein multi-location prediction.</p>
  </sec>
  <sec id="SEC3">
    <title>3 A probabilistic generative model for protein localization</title>
    <p>As we and others have done before (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>; <xref rid="btv264-B15" ref-type="bibr">Garg and Raghava, 2008</xref>; <xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>), we represent each protein <italic>P</italic> as a weighted feature vector, <inline-formula><mml:math id="MM1"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mn>1</mml:mn><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>d</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> where <italic>d</italic> is the number of features. Let <inline-formula><mml:math id="MM2"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the set of <italic>q</italic> subcellular components in the cell. Each protein <italic>P</italic> localizes to at least one—and possibly more than one—location. The locations of each protein <italic>P</italic> are represented by a location indicator vector, <inline-formula><mml:math id="MM3"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mtext>1</mml:mtext><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>q</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> of 0/1 values, where <inline-formula><mml:math id="MM4"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if <italic>P</italic> localizes to <italic>s</italic><sub><italic>i</italic></sub>, and <inline-formula><mml:math id="MM5"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. We view each location indicator <inline-formula><mml:math id="MM6"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> as a value taken by a random variable <italic>L</italic><sub><italic>i</italic></sub> and each feature <inline-formula><mml:math id="MM7"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> as a value taken by a random variable <italic>F</italic><sub><italic>j</italic></sub>. Given a protein <italic>P</italic>, represented as a vector <inline-formula><mml:math id="MM8"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, the multi-localization task amounts to assigning a (correct) 0/1 value to each of the entries <inline-formula><mml:math id="MM9"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
    <sec id="SEC3.1">
      <title>3.1 Modeling location inter-dependency</title>
      <p>We use Bayesian networks to model inter-dependencies among subcellular locations. A Bayesian network consists of a directed acyclic graph <inline-formula><mml:math id="MM10"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> whose set of nodes <italic>L</italic> corresponds to random variables and set of edges <italic>E</italic> indicates dependencies among the variables. In our case, nodes represent location variables denoted <inline-formula><mml:math id="MM11"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Each variable <italic>L<sub><italic>i</italic></sub></italic> corresponds to a location <italic>s</italic><sub><italic>i</italic></sub> within the cell and takes on a 0/1 value. <xref ref-type="fig" rid="btv264-F1">Figure 1</xref> shows an example Bayesian network we learn over location variables. A directed edge, for instance, from <italic>membrane</italic> to <italic>cytoplasm</italic> represents the assertion that knowing that a protein localizes to the <italic>membrane</italic> influences the level of belief about the protein localizing to the <italic>cytoplasm</italic>. According to the conditional independence relationship encoded in the Bayesian network, each variable <italic>L</italic><sub><italic>i</italic></sub> is conditionally independent of its non-descendants given its parents <inline-formula><mml:math id="MM12"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (for additional details see <xref rid="btv264-B29" ref-type="bibr">Russell and Norvig, 2010</xref>). The joint distribution of the location variables can thus be calculated as: 
<disp-formula id="btv264-M1"><label>(1)</label><mml:math id="MM13"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
<fig id="btv264-F1" position="float"><label>Fig. 1.</label><caption><p>An example location-Bayesian-network that we learn. Directed edges represent dependencies between the connected nodes. The location associated with each variable is shown below the corresponding node</p></caption><graphic xlink:href="btv264f1p"/></fig>
</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Capturing location-feature dependency</title>
      <p>The value of each feature represents a certain characteristic of a protein, such as the relative abundance of each amino acid in the protein’s amino-acid composition (<xref rid="btv264-B21" ref-type="bibr">King and Guda, 2007</xref>). In our experiments, we use the exact same features used by <xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.</italic> (2010a)</xref>, as explained in Section 5.1. For the purpose of predicting locations for a protein, we view a protein as though it was generated through a stochastic process, in which each of its feature values was determined. The value of each feature variable <italic>F</italic><sub><italic>j</italic></sub> (<inline-formula><mml:math id="MM14"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>) is assigned based on the values taken by one or more location random variables; that is, each feature value may <italic>depend on multiple locations and not just on one</italic>. For instance, consider a feature capturing the abundance of <italic>tryptophan (</italic><italic>Trp)</italic> residues in the amino acid composition of a protein; we denote the random variable associated with this feature by <italic>F</italic><sub>Trp</sub>. The value of this feature varies greatly between proteins known to localize to the <italic>membrane</italic> vs. those that are known to localize to both the <italic>membrane</italic> and the <italic>cytoplasm</italic>. Specifically, the probability of a <italic>membrane</italic> protein to have more than three <italic>Trp</italic> residues (formally denoted as the conditional probability: <inline-formula><mml:math id="MM15"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mtext>Trp</mml:mtext></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>Mem</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>), is 0.36 [this high probability agrees with the well-established importance of <italic>Trp</italic>’s role in membrane proteins (<xref rid="btv264-B30" ref-type="bibr">Schiffer <italic>et al.,</italic> 1992</xref>)]. In contrast, the probability of proteins known to be multi-localized to both the <italic>membrane</italic> and the <italic>cytoplasm</italic> to have more than three <italic>Trp</italic> residues (<inline-formula><mml:math id="MM16"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mtext>Trp</mml:mtext></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>Mem</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>Cyt</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>), is only 0.15 (the probability values are calculated based on the dataset described in Section 5.1). Thus, the feature value depends on more than a single location value. To accurately capture the dependency between protein features and location-combinations, we view each feature value as depending on a <italic>set of location indicator values</italic>.</p>
      <p>Recall that we view a protein as represented by (i.e. comprised of) a set of features. As such, we view each possible location of a protein <italic>P</italic> as depending on a set of locations to which proteins with similar feature values (including <italic>P</italic> itself) are likely to be localized. We thus introduce the concept of <italic>location dependency sets</italic>. For a location <italic>s</italic><sub><italic>i</italic></sub>, its <italic>dependency set</italic> comprises the minimal set of locations <inline-formula><mml:math id="MM17"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mtext>1</mml:mtext></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mtext>m</mml:mtext></mml:msub></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> such that the likelihood of a protein to localize to <italic>s<sub><italic>i</italic></sub></italic> depends on (i.e is correlated or anti-correlated with) its likelihood of to localize to each of <inline-formula><mml:math id="MM18"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mtext>1</mml:mtext></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mtext>m</mml:mtext></mml:msub></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Using the Bayesian network framework, we note that a dependency as described above between the locations <inline-formula><mml:math id="MM19"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>s</italic><sub><italic>i</italic></sub> can be represented as a directed edge from the graph node <inline-formula><mml:math id="MM20"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:msub><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to <italic>L</italic><sub><italic>i</italic></sub>. Given a Bayesian network that represents the dependencies among locations in this way, we can thus denote the <italic>location dependency set</italic> for each location variable <italic>L</italic><sub><italic>i</italic></sub> as the parents of <italic>L</italic><sub><italic>i</italic></sub> in the Bayesian network. As such, we define <italic>q</italic> location dependency sets, one set per location,
<disp-formula id="btv264-M2"><label>(2)</label><mml:math id="MM21"><mml:mrow><mml:mi>L</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="MM22"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM23"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>) denotes the parents of location variable <italic>L</italic><sub><italic>i</italic></sub> in a Bayesian network.</p>
      <p>Given a Bayesian network <italic>G</italic>, the steps involved in protein generation are discussed in the rest of this section. We use a <italic>coin-toss model</italic> to set location indicator values, and two <italic>die-roll processes</italic> to set feature values. For each feature, one die roll is used to select a location dependency set, and another to assign the actual feature value. We next describe each of the steps in detail.</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Setting location values</title>
      <p>As part of the generative process for a protein <italic>P</italic>, we view the value of a location indicator <inline-formula><mml:math id="MM24"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM25"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>) as set by tossing a coin <italic>C</italic><sub><italic>i</italic></sub>; if the coin comes up <italic>Heads</italic>, the location indicator <inline-formula><mml:math id="MM26"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set to 1; otherwise <inline-formula><mml:math id="MM27"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. The probability of <italic>C</italic><sub><italic>i</italic></sub> to come up <italic>Heads</italic> is: <inline-formula><mml:math id="MM28"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>|</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Values comprising the location indicator vector <inline-formula><mml:math id="MM29"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> are thus set by tossing the location-specific coins in a sequence one after the other. We assume that there is a specific order in which the coins are tossed. To establish the order, we use a topological ordering of location variables in the Bayesian network <italic>G</italic> denoted as <inline-formula><mml:math id="MM30"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>t1</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mrow><mml:mtext>tq</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where each parent in the network appears before its descendant; an example of such an ordering of nodes based on the network in <xref ref-type="fig" rid="btv264-F1">Figure 1</xref> is <inline-formula><mml:math id="MM31"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Consequently, coin <inline-formula><mml:math id="MM32"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>t1</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is tossed first, and based on its outcome, the location indicator value <inline-formula><mml:math id="MM33"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>t1</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set, then <inline-formula><mml:math id="MM34"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>t2</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is tossed and <inline-formula><mml:math id="MM35"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>t2</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set, and so on, until <italic>C</italic><sub>tq</sub> is tossed and <inline-formula><mml:math id="MM36"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>tq</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set.</p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Setting feature values</title>
      <p>We further view each feature value <inline-formula><mml:math id="MM37"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="MM38"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as selected from among <italic>n<sub><italic>j</italic></sub></italic> possible distinct values by adhering to the following steps:
<list list-type="order"><list-item><p><italic>A dependency set is selected:</italic> A location dependency set is chosen based on a probability distribution over <italic>q</italic> such sets [see <xref ref-type="disp-formula" rid="btv264-M2">Equation (2)</xref> for the sets definitions]. For each feature <italic>F</italic><sub><italic>j</italic></sub>, let <inline-formula><mml:math id="MM39"><mml:mrow><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> be a random variable that takes on the values <inline-formula><mml:math id="MM40"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>, where a value <italic>i</italic> (<inline-formula><mml:math id="MM41"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>) indicates that the <italic>i</italic>th location dependency set is selected. We denote the event of selecting the <italic>i</italic>th set, LS<sub><italic>i</italic></sub>, by <inline-formula><mml:math id="MM42"><mml:mrow><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. Given a location indicator vector <inline-formula><mml:math id="MM43"><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:math></inline-formula> (selected in the previous step), to select a location dependency set, a die <inline-formula><mml:math id="MM44"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> with <italic>q</italic> faces is rolled. If the die <inline-formula><mml:math id="MM45"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> lands with the <italic>i</italic>th face up, the set LS<sub><italic>i</italic></sub> is selected. The probability of <inline-formula><mml:math id="MM46"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> to come up as <italic>i</italic> is: <inline-formula><mml:math id="MM47"><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>i</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>|</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p><italic>A feature-value is assigned:</italic> Based on the values taken by variables in a selected location set, the feature value is chosen. Given that the set LS<sub><italic>k</italic></sub> was selected, we assume that a die <inline-formula><mml:math id="MM48"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> with <italic>n</italic><sub><italic>j</italic></sub> faces is rolled to pick a value for feature <italic>F</italic><sub><italic>j</italic></sub>. If the die <inline-formula><mml:math id="MM49"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> lands with the <italic>v</italic><sub><italic>j</italic></sub>th face up, the feature value is set to <italic>v</italic><sub><italic>j</italic></sub>. The probability of <inline-formula><mml:math id="MM50"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> to come up as <italic>v</italic><sub><italic>j</italic></sub> is: <inline-formula><mml:math id="MM51"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>F</italic><sub><italic>j</italic></sub> is the random variable associated with the <italic>j</italic>th feature.</p></list-item></list>
</p>
      <p>Based on this model, each feature value <inline-formula><mml:math id="MM52"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set independently of other features to construct the complete feature vector of the protein <italic>P</italic>, <inline-formula><mml:math id="MM53"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mtext>1</mml:mtext><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>d</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>The generative process for a protein <italic>P</italic> is summarized as shown in <xref ref-type="fig" rid="btv264-F2">Figure 2</xref>: First, the <italic>location coins</italic> are tossed in the order <inline-formula><mml:math id="MM54"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>t1</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>t2</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>tq</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>—as shown on the left side of the figure. If the coin <italic>C</italic><sub>ti</sub> (<inline-formula><mml:math id="MM55"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>) comes up <italic>Heads</italic>, the location indicator <inline-formula><mml:math id="MM56"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>ti</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set to 1; otherwise <inline-formula><mml:math id="MM57"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>ti</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Collectively, this results in choosing the location indicator vector <inline-formula><mml:math id="MM58"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. Next, for each feature <italic>F</italic><sub><italic>j</italic></sub> (<inline-formula><mml:math id="MM59"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>), the <italic>location vector die</italic>
<inline-formula><mml:math id="MM60"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> is rolled; if the die lands with the <italic>k</italic>th face up, the set LS<sub><italic>k</italic></sub> is selected—as shown on the top-right side of the figure. Based on the selected set LS<sub><italic>k</italic></sub>, the <italic>feature die</italic>
<inline-formula><mml:math id="MM61"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> is rolled; if the die lands with the <italic>v</italic><sub><italic>j</italic></sub>th face up, the feature value <inline-formula><mml:math id="MM62"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is set to <italic>v</italic><sub><italic>j</italic></sub>—as shown on the bottom-right side of the figure.
<fig id="btv264-F2" position="float"><label>Fig. 2.</label><caption><p>The generative process for a protein <italic>P</italic>. First, location coins, <inline-formula><mml:math id="MM63"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>t1</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mtext>tq</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, are tossed (top left); based on the outcomes, location indicator values, <inline-formula><mml:math id="MM64"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>t1</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mrow><mml:mtext>tq</mml:mtext></mml:mrow><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, are chosen (bottom left). Collectively, these values make up the location indicator vector <inline-formula><mml:math id="MM65"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>. For each feature <italic>F</italic><sub><italic>j</italic></sub>, the die <inline-formula><mml:math id="MM66"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> is then tossed to select a location dependency set (top right); based on the selected set LS<sub><italic>k</italic></sub>, the feature die <inline-formula><mml:math id="MM67"><mml:mrow><mml:msubsup><mml:mi>D</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> is tossed to pick the feature-value <inline-formula><mml:math id="MM68"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (bottom right)</p></caption><graphic xlink:href="btv264f2p"/></fig>
</p>
      <p>We note that our generative model makes the following two <italic>independence assumptions</italic>:
<list list-type="order"><list-item><p>The feature values <inline-formula><mml:math id="MM69"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mtext>1</mml:mtext><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>d</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> of a protein <italic>P</italic>, are <italic>conditionally independent</italic> of each other given the protein’s location indicator vector <inline-formula><mml:math id="MM70"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, formally:
<disp-formula id="btv264-M3"><label>(3)</label><mml:math id="MM71"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
While this assumption may oversimplify the underlying biological mechanisms, it works well in practice and has proven useful before (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). Moreover, our model carefully accounts for inter-dependencies among locations, as well as among locations and features, thus indirectly capturing interdependencies among features.</p></list-item><list-item><p>Given the values taken by a location variable <italic>L</italic><sub><italic>k</italic></sub> and its parents <inline-formula><mml:math id="MM72"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in a <italic>selected</italic> location dependency set LS<sub><italic>k</italic></sub>, the feature value for a protein, <inline-formula><mml:math id="MM73"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, is <italic>conditionally independent</italic> of all other location values, formally:
<disp-formula id="btv264-M4"><label>(4)</label><mml:math id="MM74"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mtext>1</mml:mtext><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>q</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>k</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p></list-item></list>
</p>
      <p><xref ref-type="fig" rid="btv264-F3">Figure 3</xref> shows the protein generation process using the standard notation of a probabilistic graphical model. Nodes represent random variables and directed edges represent dependencies among variables. The values of location and feature random variables are governed by a probability distribution and as such are denoted using circles. In contrast, the value of each location dependency set variable LS<sub><italic>k</italic></sub> is assigned deterministically based on the values of the location variable L<sub><italic>k</italic></sub> and its parents <inline-formula><mml:math id="MM75"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and is denoted as a square. The variables representing locations, features, and location dependency sets are <italic>observed</italic> and hence are shown as shaded; the rest of the variables are <italic>latent</italic> and are shown unshaded. The latent variable <inline-formula><mml:math id="MM76"><mml:mrow><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> takes on a value <italic>k</italic>, indicating the selection of the location set LS<sub><italic>k</italic></sub>, with a probability <inline-formula><mml:math id="MM77"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As was shown in <xref ref-type="fig" rid="btv264-F1">Figure 1</xref>, edges among location variables capture inter-dependencies among locations. The rectangular plate notation is used to represent replication of feature and location set variables with the same dependencies. The lack of feature–feature edges captures the conditional independencies among features given location sets.
<fig id="btv264-F3" position="float"><label>Fig. 3.</label><caption><p>The probabilistic graphical model for the generation of protein features. Directed edges represent dependencies between nodes. Locations and features are shown as circles and location sets as squares. Shaded nodes represent observed variables and unshaded nodes represent latent variables. The variable <inline-formula><mml:math id="MM78"><mml:mrow><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> takes on a value <italic>k</italic>, indicating the selection of the set LS<sub><italic>k</italic></sub>, with a probability <inline-formula><mml:math id="MM79"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The rectangular plate notation is used to represent replication of features and location sets with the same dependencies</p></caption><graphic xlink:href="btv264f3p"/></fig>
</p>
      <p>Under the independence assumptions and the structure of our model described earlier, the joint probability of the location indicator vector <inline-formula><mml:math id="MM80"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> and the feature vector <inline-formula><mml:math id="MM81"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is expressed as:
<disp-formula id="btv264-M5"><label>(5)</label><mml:math id="MM82"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>k</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
</p>
      <p>where each term corresponds to a parameter of the generative model as described below:
<list list-type="alpha-lower"><list-item><p><inline-formula><mml:math id="MM83"><mml:mrow><mml:mstyle displaystyle="false"><mml:msubsup><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:msubsup><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the factorization of the joint probability <inline-formula><mml:math id="MM84"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mtext>1</mml:mtext><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>q</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, over the individual <italic>q</italic> location indicator values;</p></list-item><list-item><p><inline-formula><mml:math id="MM85"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the conditional probability of a feature value <inline-formula><mml:math id="MM86"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM87"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, where <italic>d</italic> is the total number of features), given the values taken by a location variable <italic>L</italic><sub><italic>k</italic></sub> and its parents <inline-formula><mml:math id="MM88"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> comprising the location dependency set LS<sub><italic>k</italic></sub> (under the current model <italic>G</italic>);</p></list-item><list-item><p><inline-formula><mml:math id="MM89"><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the probability that the location dependency set LS<sub><italic>k</italic></sub> was selected for a given feature <italic>F<sub><italic>j</italic></sub></italic> and a location indicator vector <inline-formula><mml:math id="MM90"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>.</p></list-item></list>
</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 Model learning and protein multi-location prediction</title>
    <p>In this section, we introduce the procedure used for learning the structure and the parameters of our generative model and for predicting multiple locations for proteins. We present an expectation maximization (EM) algorithm to estimate the hidden parameters and explain the inference technique used for multi-location prediction.</p>
    <p>As our goal is to predict multiple locations for proteins, we use the probabilistic generative model presented in Section 3 to predict a 0/1 value for each location variable <italic>L</italic><sub><italic>i</italic></sub>. To obtain the model, we use an iterative process (see <xref ref-type="fig" rid="btv264-F4">Fig. 4</xref>) in which the structure of a Bayesian network and the parameters of the generative model [shown in <xref ref-type="disp-formula" rid="btv264-M5">Equation (5)</xref>] are learned. Each iteration consists of first learning a network structure and estimating its parameters, and following the learning by performance assessment of the resulting model by using it to infer the locations of proteins in the training dataset. This process is continued until a stopping criterion is met, namely, until the prediction performance of the learned model on the proteins from the training-set does not improve between two successive iterations. Typically the process does not require more than ten iterations to complete. To measure prediction performance in each iteration, we use the <italic>F</italic><sub>1</sub>-score metric, which is formally defined later in Section 5.2. We next discuss the procedures used for learning the structure and the parameters of our model.
<fig id="btv264-F4" position="float"><label>Fig. 4.</label><caption><p>A summary of our model-learning process. The rectangular boxes represent steps in the learning process, the diamond indicates checking for a stopping criterion, and the oval represents the output, which in our case is the learned model. Directed edges indicate the order among steps</p></caption><graphic xlink:href="btv264f4p"/></fig>
</p>
    <sec id="SEC4.1">
      <title>4.1 Model learning</title>
      <p>In each iteration of the learning process, we obtain a Bayesian network structure of locations using the software package BANJO (<xref rid="btv264-B35" ref-type="bibr">Smith <italic>et al.,</italic> 2006</xref>) and estimate the model parameters shown in the previous section in <xref ref-type="disp-formula" rid="btv264-M5">Equation (5)</xref>. The initial Bayesian network structure is learned from protein locations in the training set, and iteratively updated to reflect the most-recently estimated locations.</p>
      <p>To estimate the model parameters described in components (a) and (b) of <xref ref-type="disp-formula" rid="btv264-M5">Equation (5)</xref>, we calculate the maximum likelihood estimates from frequency counts in the training dataset. As for component (c) there, the location set probability <inline-formula><mml:math id="MM91"><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a given location indicator vector <inline-formula><mml:math id="MM92"><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:math></inline-formula> and a feature <italic>F</italic><sub><italic>j</italic></sub> cannot be directly computed from the dataset. We thus use an EM algorithm (<xref rid="btv264-B11" ref-type="bibr">Dempster <italic>et al.,</italic> 1977</xref>) to estimate the <italic>hidden</italic> parameter <inline-formula><mml:math id="MM93"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>θ</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, as described next.</p>
      <p>In the <italic>E-step</italic>, for each protein <italic>P</italic> and each of its feature values <inline-formula><mml:math id="MM94"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> in the training set, we compute the probability of a location set LS<sub><italic>k</italic></sub> to be used to determine the protein’s feature value as:
<disp-formula id="btv264-M6"><label>(6)</label><mml:math id="MM95"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>λ</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>k</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>k</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>In <xref ref-type="disp-formula" rid="btv264-M6">Equation (6)</xref>, for each location indicator vector <inline-formula><mml:math id="MM96"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> and feature <italic>F</italic><sub><italic>j</italic></sub>, the distribution <inline-formula><mml:math id="MM97"><mml:mrow><mml:msup><mml:mover><mml:mi>θ</mml:mi><mml:mo>→</mml:mo></mml:mover><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> over <italic>q</italic> location sets is initialized as uniform; thus initially <inline-formula><mml:math id="MM98"><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula> for all <italic>k</italic>, <inline-formula><mml:math id="MM99"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>). The conditional probability, <inline-formula><mml:math id="MM100"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>k</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, of a feature value <inline-formula><mml:math id="MM101"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> given the location set LS<sub><italic>k</italic></sub> (where <inline-formula><mml:math id="MM102"><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>∪</mml:mo><mml:mi>P</mml:mi><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) is initialized to the maximum likelihood estimate computed using the training dataset.</p>
      <p>In the <italic>M-step</italic>, we re-estimate all the model parameters. For each location indicator vector <inline-formula><mml:math id="MM103"><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:math></inline-formula> and feature <italic>F</italic><sub><italic>j</italic></sub>, the probability of a location dependency set LS<sub><italic>k</italic></sub> is re-estimated as:
<disp-formula id="btv264-M7"><label>(7)</label><mml:math id="MM104"><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mo>,</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>q</mml:mi></mml:munderover><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mo>,</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>v</italic><sub><italic>j</italic></sub> is a feature value of <italic>F</italic><sub><italic>j</italic></sub> and <italic>k</italic> denotes the selection of the dependency set LS<sub><italic>k</italic></sub>. That is, in the numerator, for each feature, <italic>F</italic><sub><italic>j</italic></sub>, we go over all feature values <italic>v</italic><sub><italic>j</italic></sub> that <italic>F</italic><sub><italic>j</italic></sub> takes, and all proteins in the set that have this feature value; we sum the probability of having used the dependency set LS<sub><italic>k</italic></sub> to generate feature value <italic>v</italic><sub><italic>j</italic></sub>—weighted by the probability of observing that feature value. The denominator is a normalization factor ensuring that probabilities sum to 1. The probability of a set LS<sub><italic>k</italic></sub> to be selected for determining <inline-formula><mml:math id="MM105"><mml:mrow><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is calculated in the <italic>E-step</italic> [see <xref ref-type="disp-formula" rid="btv264-M6">Equation (6)</xref>]. Note that <inline-formula><mml:math id="MM106"><mml:mrow><mml:msubsup><mml:mi>θ</mml:mi><mml:mi>k</mml:mi><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is computed separately for each feature since feature-values are determined independently of each other during protein generation.</p>
      <p>To re-estimate the conditional probability <inline-formula><mml:math id="MM107"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we introduce the notation <inline-formula><mml:math id="MM108"><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>P</mml:mi></mml:msubsup></mml:math></inline-formula> to denote the <italic>restriction</italic> of the location indicator vector <inline-formula><mml:math id="MM109"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> to only those locations that are members in the location dependency set LS<sub><italic>k</italic></sub>. The conditional probability is then calculated as:
<disp-formula><mml:math id="MM110"><mml:mrow><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>LS</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mfrac><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>P</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mo>,</mml:mo><mml:mi>f</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mtext>=v</mml:mtext></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mi>P</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi><mml:mi>S</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mo>,</mml:mo><mml:mi>f</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:msub><mml:mrow><mml:mtext>=v</mml:mtext></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mi>Pr</mml:mi></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>λ</mml:mi><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>k</mml:mi><mml:mo>|</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>f</mml:mi><mml:mi>j</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
</p>
      <p>This re-estimation formula is similar to the one shown in <xref ref-type="disp-formula" rid="btv264-M7">Equation (7)</xref>, but taking into account only those proteins in the training set that are localized to the locations included in the dependency set LS<sub><italic>k</italic></sub>.</p>
      <p>The process of alternating between the E-step and the M-step is carried out until convergence is reached, i.e. until changes to the hidden parameter values between iterations are no greater than 0.05. Throughout the estimation process, we use Laplace smoothing to avoid overfitting, by adding fractional pseudocounts to observed counts of events (<xref rid="btv264-B29" ref-type="bibr">Russell and Norvig, 2010</xref>). The smoothing parameter (<italic>α</italic>) is set to 0.5, which is close to the count of rare events and almost insignificant compared with counts of frequent ones. We next present the inference procedure that we use for predicting protein locations.</p>
    </sec>
    <sec id="SEC4.2">
      <title>4.2 Multiple location prediction</title>
      <p>Given a protein <italic>P</italic>, represented as a feature vector <inline-formula><mml:math id="MM111"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, our task is to predict its location indicator vector <inline-formula><mml:math id="MM112"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, i.e. we need to assign a 0/1 value to each of its location indicators <inline-formula><mml:math id="MM113"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="MM114"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Under the Bayesian network model, this task translates to inferring the value of the random variable <italic>L</italic><sub><italic>i</italic></sub>, which in turn depends on the values of its parent nodes <inline-formula><mml:math id="MM115"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We thus infer the values of the location dependency set <inline-formula><mml:math id="MM116"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The inference procedure aims to assign values to <italic>L<sub><italic>i</italic></sub></italic> and to <inline-formula><mml:math id="MM117"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> such that the conditional probability, <inline-formula><mml:math id="MM118"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is maximized.</p>
      <p>To infer these values, we follow an iterative process. We start by initializing all location indicators in <inline-formula><mml:math id="MM119"><mml:mrow><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>l</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> to 0. For any value-assignment, <italic>l</italic><sub><italic>i</italic></sub> to <italic>L</italic><sub><italic>i</italic></sub>, we denote by <inline-formula><mml:math id="MM120"><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>Pa</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the values assigned to all parents of <italic>L</italic><sub><italic>i</italic></sub>. We also denote by <inline-formula><mml:math id="MM121"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>L</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> the current value assignment for all location random variables in the network other than <italic>L</italic><sub><italic>i</italic></sub> and <inline-formula><mml:math id="MM122"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In each iteration, we consider in turn each of the random variables <italic>L</italic><sub><italic>i</italic></sub>. For all possible value assignments, <italic>l</italic><sub><italic>i</italic></sub>, <inline-formula><mml:math id="MM123"><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>Pa</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, to <italic>L</italic><sub><italic>i</italic></sub> and <inline-formula><mml:math id="MM124"><mml:mrow><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively, we calculate the conditional probability, <inline-formula><mml:math id="MM125"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>Pa</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mstyle displaystyle="true"><mml:mover><mml:mi>Pa</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mstyle displaystyle="true"><mml:mover><mml:mi>f</mml:mi><mml:mo>→</mml:mo></mml:mover></mml:mstyle><mml:mi>P</mml:mi></mml:msup><mml:mo>,</mml:mo><mml:msub><mml:mover accent="true"><mml:mi>L</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The value assignment to <italic>L</italic><sub><italic>i</italic></sub> that produces the highest probability is the one used as the current estimate for <italic>L</italic><sub><italic>i</italic></sub>. As noted earlier, the process typically requires about ten iterations to reach convergence.</p>
      <p>We next describe our experiments and the results obtained using the protein generation model.</p>
    </sec>
  </sec>
  <sec id="SEC5">
    <title>5 Experiments and results</title>
    <p>We implemented our algorithms for learning parameters of the generative model and for inferring locations using Python. We have applied our system MDLoc to the largest available dataset of multi-localized proteins, previously used for training YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). Next, we describe the dataset and the evaluation methods we use, followed by experiments and results obtained using MDLoc. We also provide several specific examples demonstrating the utility of incorporating location inter-dependencies into the prediction process.</p>
    <sec id="SEC5.1">
      <title>5.1 Data</title>
      <p>In our experiments, we use a dataset first constructed for an extensive comparison of multi-location prediction systems as part of the evaluation of YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). It contains 5447 single-localized proteins, originally published by <xref rid="btv264-B18" ref-type="bibr">Höglund <italic>et al.</italic> (2006)</xref>, and 3056 multi-localized proteins, originally published as part of the DBMLoc dataset (<xref rid="btv264-B39" ref-type="bibr">Zhang <italic>et al.,</italic> 2008</xref>). As in a true prediction scenario it is not known a priori whether a protein may localize to a single or to multiple locations, we train our system on the combined set of proteins, thus enabling it to handle the actual prediction task. The dataset is already homology-reduced, i.e. proteins sharing &gt;80% sequence identity with another protein in the dataset were removed. We compare the performance of our system to that of others using only multi-localized proteins (3056 proteins) because the only results publicly available for the other systems were obtained on this dataset (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). The single-localized proteins are from the following locations (abbreviations and number of proteins per location are given in parentheses): cytoplasm (<italic>cyt</italic>, 1411 proteins); endoplasmic reticulum (<italic>ER</italic>, 198); extra cellular space (<italic>ex</italic>, 843); golgi apparatus (<italic>gol</italic>, 150); lysosome (<italic>lys</italic>, 103); mitochondrion (<italic>mi</italic>, 510); nucleus (<italic>nuc</italic>, 837); membrane (mem, 1238); peroxisome (<italic>per</italic>, 157). The multi-localized proteins are from the following pairs of locations: <italic>cyt_nuc</italic>: 1882 proteins; <italic>ex_mem</italic>: 334; <italic>cyt_mem</italic>: 252; <italic>cyt_mi</italic>: 240; <italic>nuc_mi</italic>: 120; <italic>ER_ex</italic>: 115; <italic>ex_nuc</italic>: 113. Note that all the multi-location subsets used have over 100 representative proteins. We use the exact same representation of a 30-dimensional feature vector as used for evaluating YLoc<sup>+</sup> (for further details see <xref rid="btv264-B6" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010b</xref>): (i) thirteen features derived directly from the protein sequence data; (ii) nine features constructed using pseudo-amino acid composition (<xref rid="btv264-B8" ref-type="bibr">Chou, 2001</xref>); (iii) two <italic>annotation-based</italic> features constructed using two distinct groups of PROSITE patterns; (iv) six <italic>annotation-based</italic> features based on GO-annotations.</p>
    </sec>
    <sec id="SEC5.2">
      <title>5.2 Experimental setting and performance measures</title>
      <p>We compare the performance of MDLoc to that of our preliminary system (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>) and to other systems, specifically, YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>), Euk-mPLoc (<xref rid="btv264-B10" ref-type="bibr">Chou and Shen, 2007</xref>), WoLF PSORT (<xref rid="btv264-B19" ref-type="bibr">Horton <italic>et al.,</italic> 2007</xref>) and KnowPred<sub>site</sub> (<xref rid="btv264-B23" ref-type="bibr">Lin <italic>et al.,</italic> 2009</xref>), whose results on the multi-localized proteins are described in a previously published comprehensive study by <xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.</italic> (2010a)</xref>. The comparison uses the exact same dataset from that study, and employs multiple runs of stratified 5-fold cross-validation. That is, we ran 5-fold-cross-validation five complete times (25 runs in total), using a different five-way split each time. The use of multiple runs with multiple splits helps validate the stability and the significance of the results. The total training time for our system for the 25 training experiments is about 8 hours (wall-clock), when running on a standard Dell Poweredge machine with 32 AMD Opteron 6276 processors.</p>
      <p>To formally define the evaluation measures we use, let <italic>D</italic> be a dataset containing proteins. For a given protein <italic>P</italic>, let <inline-formula><mml:math id="MM126"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM127"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the set of locations to which protein <italic>P</italic> localizes according to the dataset, and let <inline-formula><mml:math id="MM128"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:msubsup><mml:mover accent="true"><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM129"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>q</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be the set of locations that a classifier predicts for <italic>P</italic>, where <inline-formula><mml:math id="MM130"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>l</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>i</mml:mi><mml:mi>P</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is the 0/1 prediction obtained for location <italic>s</italic><sub><italic>i</italic></sub>. We use <italic>adapted</italic> measures of multi-label precision and recall denoted <inline-formula><mml:math id="MM131"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM132"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and defined as follows (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>):
<disp-formula><mml:math id="MM133"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:munder></mml:mstyle><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>∩</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mo>;</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="MM134"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>}</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mo>×</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup></mml:mrow></mml:munder></mml:mstyle><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>∩</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
We also use the <italic>adapted</italic> measure of <italic>accuracy</italic> proposed by <xref rid="btv264-B38" ref-type="bibr">Tsoumakas <italic>et al.</italic> (2010)</xref> for evaluating multi-label classification. Some of these measures have also been previously used for multi-location evaluation (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>; <xref rid="btv264-B17" ref-type="bibr">He <italic>et al.,</italic> 2012</xref>). The multi-label accuracy and the <italic>F</italic><sub>1</sub>-<italic>label</italic> score used for the evaluation of YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>) are computed as:
<disp-formula><mml:math id="MM135"><mml:mrow><mml:mtext>Acc</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mi>D</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>∩</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mi>P</mml:mi></mml:msup><mml:mo>∪</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mi>P</mml:mi></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle><mml:mtext>and</mml:mtext><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>-</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
Finally, to evaluate the correctness of predictions made for each location <italic>s</italic><sub><italic>i</italic></sub>, we use the <italic>standard precision</italic> and <italic>recall</italic> measures, denoted by Pre-<inline-formula><mml:math id="MM136"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and Rec-<inline-formula><mml:math id="MM137"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and defined as: <inline-formula><mml:math id="MM138"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext><mml:mi>-</mml:mi><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FP</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM139"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext><mml:mi>-</mml:mi><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext>FN</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>TP</italic> (<italic>true positives</italic>) denotes the number of proteins that localize to <italic>s</italic><sub><italic>i</italic></sub> and are predicted to localize to <italic>s</italic><sub><italic>i</italic></sub>, <italic>FP</italic> (<italic>false positives</italic>) denotes the number of proteins that do not localize to <italic>s</italic><sub><italic>i</italic></sub> but are predicted to localize to <italic>s</italic><sub><italic>i</italic></sub>, and <italic>FN</italic> (<italic>false negatives</italic>) denotes the number of proteins that localize to <italic>s</italic><sub><italic>i</italic></sub> but are not predicted to localize to <italic>s</italic><sub><italic>i</italic></sub>. The <italic>F</italic><sub>1</sub>-score for location <italic>s</italic><sub><italic>i</italic></sub> is defined as:
<disp-formula><mml:math id="MM140"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>-</mml:mi><mml:mtext>score</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext><mml:mi>-</mml:mi><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext><mml:mi>-</mml:mi><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext><mml:mi>-</mml:mi><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext><mml:mi>-</mml:mi><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
    </sec>
    <sec id="SEC5.3">
      <title>5.3 Classification results</title>
      <p>In this section, we compare the performance of our system with that of existing location prediction systems over the commonly used set of multi-localized proteins. We also report experiments using the <italic>combined set</italic> of single and multi-localized proteins as mentioned in Section 5.1. Our analysis includes an examination of the per-location break-up of the results. Additionally, we focus on several specific examples demonstrating the benefit of incorporating location interdependency into our prediction system.</p>
      <p><xref ref-type="table" rid="btv264-T1">Table 1</xref>A shows the <italic>F</italic><sub>1</sub>-<italic>label</italic> score and the <italic>accuracy</italic> obtained by our current system MDLoc compared with those obtained by other multi-location predictors [YLoc<sup>+</sup>, Euk-mPLoc, WoLF PSORT and KnowPred<sub>site</sub> as reported by <xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.</italic> (2010a)</xref> in <xref ref-type="table" rid="btv264-T3">Table 3</xref>] and by our preliminary system (Bayesian network classifiers, denoted BNCs, <xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>), using the same set of multi-localized proteins and evaluation measures. The table shows that MDLoc performs better than the existing top-systems, including YLoc<sup>+</sup> which has the best performance reported so far and whose predictions are based only on location-combinations in the training set. In contrast, MDLoc is not limited to the location-combinations in the training set, as it represents dependency of features on location-combinations in a generalizable manner, and directly captures inter-dependencies among locations. The only other system that attempts to capture such dependencies is our preliminary system BNCs.
<table-wrap id="btv264-T1" position="float"><label>Table 1.</label><caption><p>Multi-location prediction results, averaged over 25 runs of 5-fold cross-validation, for <italic>multi-localized</italic> proteins only</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="center" colspan="7" rowspan="1">(A)</th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">MDLoc</th><th rowspan="1" colspan="1">BNCs</th><th rowspan="1" colspan="1"><inline-formula><mml:math id="MM141"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>Y</mml:mi><mml:mi>L</mml:mi><mml:mi>o</mml:mi></mml:mstyle><mml:msup><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>c</mml:mi></mml:mstyle><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula></th><th rowspan="1" colspan="1">Euk-mPLoc</th><th rowspan="1" colspan="1">WoLF PSORT</th><th rowspan="1" colspan="1">KnowPred<sub>site</sub></th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM142"><mml:mrow><mml:msub><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>F</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle></mml:msub></mml:mrow></mml:math></inline-formula>-<bold><italic>label</italic></bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.71 (± 0.02)</bold></td><td align="char" char="." rowspan="1" colspan="1">0.66 (± 0.02)</td><td align="char" char="." rowspan="1" colspan="1">0.68</td><td align="char" char="." rowspan="1" colspan="1">0.44</td><td align="char" char="." rowspan="1" colspan="1">0.53</td><td align="char" char="." rowspan="1" colspan="1">0.66</td></tr><tr><td rowspan="1" colspan="1"><bold><italic>Acc</italic></bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.68 (± 0.01)</bold></td><td align="char" char="." rowspan="1" colspan="1">0.63 (± 0.01)</td><td align="char" char="." rowspan="1" colspan="1">0.64</td><td align="char" char="." rowspan="1" colspan="1">0.41</td><td align="char" char="." rowspan="1" colspan="1">0.43</td><td align="char" char="." rowspan="1" colspan="1">0.63</td></tr></tbody></table><table frame="hsides" rules="groups"><thead align="left"><tr><th align="center" colspan="12" rowspan="1">(B)</th></tr><tr><th align="center" colspan="2" rowspan="1"/><th rowspan="1" colspan="1"><bold>cyt (2374)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>nuc (2115)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>mem (586)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>ex (562)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>mi (360)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th></tr></thead><tbody align="left"><tr><td rowspan="2" colspan="1"><bold>Rec</bold><sub><bold>si</bold></sub></td><td rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.750 (±0.012)</bold></td><td rowspan="2" align="char" char="." colspan="1">≪0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.776 (±0.014)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM144"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1">0.527 (±0.022)</td><td rowspan="2" align="char" char="." colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">0.547 (±0.035)</td><td rowspan="2" align="char" char="." colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">0.519 (±0.026)</td><td rowspan="2" align="char" char="." colspan="1">0.04</td></tr><tr><td rowspan="1" colspan="1">YLoc<sup>+</sup></td><td align="char" char="." rowspan="1" colspan="1">0.712 (±0.009)</td><td align="char" char="." rowspan="1" colspan="1">0.728 (±0.011)</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.543 (±0.018)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.573 (±0.026)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.536 (±0.031)</bold></td></tr><tr><td rowspan="2" colspan="1"><bold>Pre</bold><sub><bold>si</bold></sub></td><td rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.911 (±0.008)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM146"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.929 (±0.008)</bold></td><td rowspan="2" align="char" char="." colspan="1">0.03</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.807 (±0.036)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM147"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.833 (±0.044)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM148"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.832 (±0.042)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM149"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td></tr><tr><td rowspan="1" colspan="1">YLoc<sup>+</sup></td><td align="char" char="." rowspan="1" colspan="1">0.893 (±0.010)</td><td align="char" char="." rowspan="1" colspan="1">0.924 (±0.008)</td><td align="char" char="." rowspan="1" colspan="1">0.764 (±0.029)</td><td align="char" char="." rowspan="1" colspan="1">0.740 (±0.053)</td><td align="char" char="." rowspan="1" colspan="1">0.765 (±0.033)</td></tr><tr><td rowspan="2" colspan="1"><bold>Rec-Std</bold><sub><bold>si</bold></sub></td><td rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.817 (±0.021)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM152"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.746 (±0.028)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM153"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1">0.588 (±0.042)</td><td rowspan="2" align="char" char="." colspan="1">0.04</td><td align="char" char="." rowspan="1" colspan="1">0.385 (±0.058)</td><td rowspan="2" align="char" char="." colspan="1">0.3</td><td align="char" char="." rowspan="1" colspan="1">0.388 (±0.062)</td><td rowspan="2" align="char" char="." colspan="1">0.03</td></tr><tr><td rowspan="1" colspan="1">YLoc<sup>+</sup></td><td align="char" char="." rowspan="1" colspan="1">0.786 (±0.020)</td><td align="char" char="." rowspan="1" colspan="1">0.684 (±0.015)</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.614 (±0.042)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.401 (±0.037)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.429 (±0.060)</bold></td></tr><tr><td rowspan="2" colspan="1"><bold>Prec-Std</bold><sub><bold>si</bold></sub></td><td rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.942 (±0.009)</bold></td><td rowspan="2" align="char" char="." colspan="1">0.01</td><td align="char" char="." rowspan="1" colspan="1">0.904 (±0.014)</td><td rowspan="2" align="char" char="." colspan="1">0.02</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.794 (±0.039)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM156"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.830 (±0.046)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM157"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.784 (±0.057)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM158"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td></tr><tr><td rowspan="1" colspan="1">YLoc<sup>+</sup></td><td align="char" char="." rowspan="1" colspan="1">0.935 (±0.009)</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.914 (±0.014)</bold></td><td align="char" char="." rowspan="1" colspan="1">0.730 (±0.047)</td><td align="char" char="." rowspan="1" colspan="1">0.771 (±0.055)</td><td align="char" char="." rowspan="1" colspan="1">0.670 (±0.055)</td></tr><tr><td colspan="12" rowspan="1"/></tr></tbody></table><table-wrap-foot><fn id="btv264-TF1"><p>Standard deviations are shown in parentheses (if available). The highest values are shown in boldface. <bold>(A)</bold> Overall <italic>F</italic><sub>1</sub>-<italic>label</italic> scores and overall accuracy (<italic>Acc</italic>) obtained using our current system MDLoc, our preliminary system (denoted BNCs, <xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>), YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>), Euk-mPLoc (<xref rid="btv264-B10" ref-type="bibr">Chou and Shen, 2007</xref>), WoLF PSORT (<xref rid="btv264-B19" ref-type="bibr">Horton <italic>et al.,</italic> 2007</xref>) and KnowPred<sub>site</sub> (<xref rid="btv264-B23" ref-type="bibr">Lin <italic>et al.,</italic> 2009</xref>). The four rightmost columns are taken directly from <xref ref-type="table" rid="btv264-T3">Table 3</xref> in the article by <xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.</italic> (2010a)</xref>. <bold>(B)</bold> Per location scores: <italic>Multilabel-Precision</italic> (<inline-formula><mml:math id="MM159"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) and <italic>Recall</italic> (<inline-formula><mml:math id="MM160"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), as well as <italic>standard precision</italic> (Pre-<inline-formula><mml:math id="MM161"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) and <italic>recall</italic> (Rec-<inline-formula><mml:math id="MM162"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>), for each location <italic>s</italic><sub><italic>i</italic></sub>, for MDLoc and YLoc<sup>+</sup>. Results for YLoc<sup>+</sup> were reproduced using our five-way splits. The <italic>p</italic>-values indicate the statistical significance of the differences between the values obtained from MDLoc and from YLoc<sup>+</sup>.</p></fn></table-wrap-foot></table-wrap></p>
      <p>To illustrate the use of interdependency, consider the protein <italic>Securin</italic> which is included in our dataset and localizes to both the cytoplasm (<italic>cyt</italic>) and the nucleus (<italic>nuc</italic>). <italic>Securin</italic>, initially present in the cytoplasm, translocates to the nucleus in response to DNA damage (<xref rid="btv264-B20" ref-type="bibr">Kim <italic>et al.,</italic> 2007</xref>). While MDLoc assigns it to both the <italic>cyt</italic> and the <italic>nuc</italic>, YLoc<sup>+</sup> assigns it to the <italic>nuc</italic> only. Our system utilizes the dependency between <italic>nuc</italic> and <italic>cyt</italic> (represented by a directed edge between the two locations, see <xref ref-type="fig" rid="btv264-F1">Fig. 1</xref>) to make an accurate multi-location prediction. Location dependencies reflect intrinsic relationships that locations share with each other, and in this case, it is well-known that proteins shuttle continuously between the nucleus and the cytoplasm to control a variety of functions such as cell cycle progression (<xref rid="btv264-B14" ref-type="bibr">Gama-Carvalho and Carmo-Fonseca, 2001</xref>). MDLoc’s benefit from capturing the interdependency between <italic>cyt</italic> and <italic>nuc</italic> is also reflected in its significantly higher <italic>Multilabel-Precision</italic> and <italic>Multilabel-Recall</italic> (<inline-formula><mml:math id="MM163"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM164"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, respectively) for the <italic>cyt</italic> and the <italic>nuc</italic> as shown in <xref ref-type="table" rid="btv264-T1">Table 1</xref>B. As another example, consider <italic>Protransforming growth factor alpha (</italic><italic>TGF-alpha)</italic>, a protein that assists in cell growth (See NCBI’s Gene database, <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/gene/7039">http://www.ncbi.nlm.nih.gov/gene/7039</ext-link>), localizes to both the extracellular space (<italic>ex</italic>) and the plasma membrane (<italic>mem</italic>), and is correctly assigned by MDLoc to both. Here MDLoc employs the well-known dependency between the extracellular space and the plasma membrane, as reflected for instance in the exocytic trafficking pathway (<xref rid="btv264-B36" ref-type="bibr">Tokarev <italic>et al.,</italic> 2000</xref>), and in the transition of proteins such as <italic>hsp 90-alpha</italic> (initiated by <italic>TGF-alpha</italic>) from the extracellular space to the plasma membrane in response to stress (<xref rid="btv264-B7" ref-type="bibr">Cheng <italic>et al.,</italic> 2008</xref>). Again, the value of utilizing interdependencies is demonstrated in MDLoc’s significantly improved precision in terms of <italic>Multilabel-Precision</italic> (<inline-formula><mml:math id="MM165"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) on the <italic>ex</italic> and <italic>mem</italic> proteins (while still retaining a similar level of recall, <inline-formula><mml:math id="MM166"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, to that of YLoc<sup>+</sup>).</p>
      <p>As an example for MDLoc’s ability to handle proteins whose <italic>location-combination</italic> is not included in the training set, consider <italic>Transmembrane emp24 domain-containing protein 7 (</italic><italic>emp24)</italic>. It localizes to the ER and transports secretory proteins to the golgi complex (<italic>gol</italic>) (<xref rid="btv264-B3" ref-type="bibr">Belden and Barlowe, 1996</xref>). (The tables shown do not include <italic>ER</italic> and <italic>gol</italic> proteins, as the number of proteins from either of these locations in the dataset is very small.) MDLoc assigns <italic>emp24</italic> to both the <italic>ER</italic> and the <italic>gol</italic>, whereas YLoc<sup>+</sup> assigns it to the <italic>ER</italic> only. As indicated before, MDLoc makes use of the dependency which captures the relationship between the <italic>ER</italic> and the <italic>gol</italic>, both of which act as components in the exocytic trafficking pathway (<xref rid="btv264-B36" ref-type="bibr">Tokarev <italic>et al.,</italic> 2000</xref>). We thus see that MDLoc is not restricted to predicting only pre-defined location-combinations.</p>
      <p><xref ref-type="table" rid="btv264-T1">Table 1</xref>B shows the per-location prediction results for multi-localized proteins obtained by MDLoc compared with those obtained by YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). Per-location predictions for the other systems are not shown here as they are not publicly available. Results are shown for the five locations with the largest number of associated proteins. For each location s<sub><italic>i</italic></sub>, we show <italic>Multilabel-Precision</italic> (<inline-formula><mml:math id="MM167"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Pre</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) and <italic>Multilabel-Recall</italic> (<inline-formula><mml:math id="MM168"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Rec</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) as well as <italic>standard precision</italic> (Pre-<inline-formula><mml:math id="MM169"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) and <italic>recall</italic> (Rec-<inline-formula><mml:math id="MM170"><mml:mrow><mml:msub><mml:mrow><mml:mtext>Std</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>). For the cytoplasm and the nucleus, which have a large number of proteins, the precision and recall values obtained using MDLoc are significantly higher in most cases than those obtained using YLoc<sup>+</sup>. For locations with much fewer proteins, while the recall values when using MDLoc are marginally lower than when using YLoc<sup>+</sup>, MDLoc’s precision values are typically significantly higher than those of YLoc<sup>+</sup>. We note that YLoc<sup>+</sup> assigns each protein to <italic>all</italic> the locations whose probability exceeds a pre-defined threshold; as such, the number of locations it assigns exceeds that to which the protein actually localizes resulting in a lower precision. In contrast, MDLoc does not simply assign a protein to each location whose probability is higher, but rather, it simultaneously considers a <italic>set</italic> of locations and assigns each protein to the set whose overall probability is high, leading to a higher precision.</p>
      <p><xref ref-type="table" rid="btv264-T2">Table 2</xref> shows the per-location prediction results on the <italic>combined dataset of both single- and multi-localized proteins</italic> obtained by MDLoc, in comparision to those obtained by BNCs (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>). While MDLoc’s precision values are somewhat lower than those of BNCs, MDLoc’s recall is typically higher. MDLoc simultaneously infers the probability of a <italic>set</italic> of locations; in contrast, BNCs uses an independent Bayesian network structure to infer the probability of each location separately. As such, the likelihood of BNCs to correctly assign the combination of several locations to a protein is much lower than its probability to correctly assign a single location, which directly translates into a relatively low recall measure. When using MDLoc, the increase in recall values for almost all cases is higher than the decrease in the precision values, except in the case of the extracellular space (<italic>ex)</italic>. Notably, proteins in the extracellular space all originate from or are bound toward another location within the cell and as such predicting them as extracellular is challenging for most prediction systems.
<table-wrap id="btv264-T2" position="float"><label>Table 2.</label><caption><p>Multi-location prediction results, per location, averaged over 25 runs of 5-fold cross-validation, for the <italic>combined set</italic> of single- and multi-localized proteins</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="center" colspan="2" rowspan="1"/><th rowspan="1" colspan="1"><bold>cyt (3785)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>nuc (2952)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>ex (1405)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>mem (1824)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th><th rowspan="1" colspan="1"><bold>mi (870)</bold></th><th rowspan="1" colspan="1"><italic>p</italic>-value</th></tr></thead><tbody align="left"><tr><td rowspan="2" colspan="1"><inline-formula><mml:math id="MM171"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi><mml:mi>e</mml:mi></mml:mstyle><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>c</mml:mi></mml:mstyle><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>s</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>i</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="char" char="." rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.825 (±0.009)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM172"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.830 (±0.010)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM173"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.780 (±0.020)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM174"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.822 (±0.012)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM175"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.773 (±0.013)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM176"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="." rowspan="1" colspan="1">0.795 (±0.011)</td><td align="char" char="." rowspan="1" colspan="1">0.784 (±0.017)</td><td align="char" char="." rowspan="1" colspan="1">0.737 (±0.022)</td><td align="char" char="." rowspan="1" colspan="1">0.780 (±0.014)</td><td align="char" char="." rowspan="1" colspan="1">0.730 (±0.025)</td></tr><tr><td rowspan="2" colspan="1"><inline-formula><mml:math id="MM177"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>e</mml:mi></mml:mstyle><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>s</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>i</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="char" char="." rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.819 (±0.013)</bold></td><td rowspan="2" align="char" char="." colspan="1">0.03</td><td align="char" char="." rowspan="1" colspan="1">0.822 (±0.014)</td><td rowspan="2" align="char" char="." colspan="1">0.02</td><td align="char" char="." rowspan="1" colspan="1">0.864 (±0.020)</td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM178"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1">0.872 (±0.014)</td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM179"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1">0.861 (±0.024)</td><td rowspan="2" align="char" char="." colspan="1">0.001</td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="." rowspan="1" colspan="1">0.809 (±0.018)</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.832 (±0.013)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.912 (±0.019)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.900 (±0.012)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.885 (±0.023)</bold></td></tr><tr><td rowspan="2" colspan="1"><inline-formula><mml:math id="MM180"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mstyle></mml:mrow></mml:math></inline-formula>-<inline-formula><mml:math id="MM181"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi><mml:mi>t</mml:mi></mml:mstyle><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>d</mml:mi></mml:mstyle><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>s</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>i</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="char" char="." rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.867 (±0.015)</bold></td><td rowspan="2" align="char" char="." colspan="1">0.1</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.808 (±0.021)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM182"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.715 (±0.030)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM183"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.842 (±0.017)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM184"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.719 (±0.028)</bold></td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM185"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="." rowspan="1" colspan="1">0.861 (±0.014)</td><td align="char" char="." rowspan="1" colspan="1">0.736 (±0.031)</td><td align="char" char="." rowspan="1" colspan="1">0.652 (±0.024)</td><td align="char" char="." rowspan="1" colspan="1">0.805 (±0.017)</td><td align="char" char="." rowspan="1" colspan="1">0.664 (±0.034)</td></tr><tr><td rowspan="2" colspan="1"><inline-formula><mml:math id="MM186"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>P</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mstyle></mml:mrow></mml:math></inline-formula>-<inline-formula><mml:math id="MM187"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi><mml:mi>t</mml:mi></mml:mstyle><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>d</mml:mi></mml:mstyle><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>s</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>i</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></td><td align="char" char="." rowspan="1" colspan="1">MDLoc</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.854 (±0.014)</bold></td><td rowspan="2" align="char" char="." colspan="1">0.001</td><td align="char" char="." rowspan="1" colspan="1">0.783 (±0.020)</td><td rowspan="2" align="char" char="." colspan="1">0.6</td><td align="char" char="." rowspan="1" colspan="1">0.839 (±0.028)</td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM188"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1">0.882 (±0.014)</td><td rowspan="2" align="char" char="." colspan="1"><inline-formula><mml:math id="MM189"><mml:mo>≪</mml:mo></mml:math></inline-formula>0.001</td><td align="char" char="." rowspan="1" colspan="1">0.843 (±0.026)</td><td rowspan="2" align="char" char="." colspan="1">0.001</td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="." rowspan="1" colspan="1">0.840 (±0.011)</td><td align="char" char="." rowspan="1" colspan="1"><bold>0.786 (±0.026)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.906 (±0.022)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.900 (±0.015)</bold></td><td align="char" char="." rowspan="1" colspan="1"><bold>0.873 (±0.034)</bold></td></tr></tbody></table><table-wrap-foot><fn id="btv264-TF3"><p>The table shows the same measures used in <xref ref-type="table" rid="btv264-T1">Table 1</xref>B obtained over the combined dataset using our current system MDLoc, and using our preliminary system (denoted BNCs) (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>). The highest values are shown in boldface. The <italic>p</italic>-values indicate the statistical significance of the differences between the values obtained from MDLoc and those obtained from BNCs. Standard deviations are shown in parentheses.</p></fn></table-wrap-foot></table-wrap></p>
      <p>Moreover, MDLoc assigns some proteins hitherto known to localize only to a single location into multiple locations. It is likely that at least some of these additional predicted locations are indeed correct and can be the subject of an experimental validation. For instance, <italic>Calreticulin (</italic><italic>Cal)</italic> is currently annotated by SwissProt as localized to the <italic>ER</italic> only. However, MDLoc assigns it to both the <italic>ER</italic> and the <italic>ex</italic>, and work by <xref rid="btv264-B16" ref-type="bibr">Gold <italic>et al.</italic> (2010)</xref> suggests that it indeed relocates from the <italic>ER</italic> to the <italic>ex</italic>.</p>
      <p>We also examine the statistically significant differences in the <italic>Multilabel-Recall</italic> for the location with the highest number of multi-localized proteins (cytoplasm, 2374 proteins) and the location with the lowest number (endoplasmic reticulum, 115 proteins). The <italic>Multilabel-Recall</italic> for cytoplasm (Rec<sub>cyt</sub>) increases from 0.80 when classifying using BNCs, to 0.83 when using MDLoc. Similarly, the <italic>Multilabel-Recall</italic> for endoplasmic reticulum (Rec<sub>ER</sub>, not shown in <xref ref-type="table" rid="btv264-T2">Table 2</xref>) increases from 0.64 to 0.69. This analysis demonstrates the advantage of using MDLoc for predicting protein locations, not just for locations that have a large number of associated proteins but also for locations that are associated with relatively few proteins.</p>
      <p><xref ref-type="table" rid="btv264-T3">Table 3</xref> shows the prediction results obtained using MDLoc in contrast to those obtained using BNCs (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>) for all location-combinations, using multi-localized proteins only. For each location combination in the dataset, we show the number of proteins with correct predictions for both locations, as well as for the first of the two locations, and for the second, separately. For almost all combinations, the number of proteins whose location is correctly predicted by MDLoc is significantly higher than the corresponding number when using BNCs. We examine the predictions for the location-combination with the highest number of proteins (cytoplasm and nucleus—1882 proteins) and its constituent locations (cytoplasm—1411 and nucleus—837 proteins). As can be seen from the table, the number of <italic>multi-localized</italic> proteins whose combined-location is correctly predicted increases significantly from 976 when classifying using BNCs, to 1253 when using MDLoc. The increase shows that location inter-dependencies learnt using MDLoc help to improve predictions for multi-localized proteins.
<table-wrap id="btv264-T3" position="float"><label>Table 3.</label><caption><p>Multi-location prediction results, <italic>per location-combination</italic>, obtained using one run of 5-fold cross-validation, for multi-localized proteins only</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="center" colspan="2" rowspan="1"/><th rowspan="1" colspan="1"><bold>cyt_nuc (1882)</bold></th><th rowspan="1" colspan="1"><bold>ex_mem (334)</bold></th><th rowspan="1" colspan="1"><bold>cyt_mem (252)</bold></th><th rowspan="1" colspan="1"><bold>cyt_mi (240)</bold></th><th rowspan="1" colspan="1"><bold>nuc_mi (120)</bold></th><th rowspan="1" colspan="1"><bold>ER_ex (115)</bold></th><th rowspan="1" colspan="1"><bold>ex_nuc (113)</bold></th></tr></thead><tbody align="left"><tr><td rowspan="2" colspan="1"><bold><italic>Both locations correct</italic></bold></td><td align="char" char="(" rowspan="1" colspan="1">MDLoc</td><td align="char" char="(" rowspan="1" colspan="1"><bold>1253 (66.6%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>34 (10.2%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>31 (12.3%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>36 (15%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>15 (12.5%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>35 (30.4%)</bold></td><td align="char" char="(" rowspan="1" colspan="1">51 (45.1%)</td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="(" rowspan="1" colspan="1">976 (51.9%)</td><td align="char" char="(" rowspan="1" colspan="1">16 (4.8%)</td><td align="char" char="(" rowspan="1" colspan="1">15 (6%)</td><td align="char" char="(" rowspan="1" colspan="1">25 (10.4%)</td><td align="char" char="(" rowspan="1" colspan="1">11 (9.2%)</td><td align="char" char="(" rowspan="1" colspan="1">16 (13.9%)</td><td align="char" char="(" rowspan="1" colspan="1"><bold>54 (47.8%)</bold></td></tr><tr><td rowspan="2" colspan="1"><bold><italic>First location correct</italic></bold></td><td align="char" char="(" rowspan="1" colspan="1">MDLoc</td><td align="char" char="(" rowspan="1" colspan="1"><bold>1603 (85.2%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>87 (26%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>186 (73.8%)</bold></td><td align="char" char="(" rowspan="1" colspan="1">164 (68.3%)</td><td align="char" char="(" rowspan="1" colspan="1"><bold>43 (35.8%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>66 (57.4%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>73 (64.6%)</bold></td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="(" rowspan="1" colspan="1">1578 (83.8%)</td><td align="char" char="(" rowspan="1" colspan="1">60 (18%)</td><td align="char" char="(" rowspan="1" colspan="1">174 (69%)</td><td align="char" char="(" rowspan="1" colspan="1"><bold>165 (68.8%)</bold></td><td align="char" char="(" rowspan="1" colspan="1">37 (30.8%)</td><td align="char" char="(" rowspan="1" colspan="1"><bold>66 (57.4%)</bold></td><td align="char" char="(" rowspan="1" colspan="1">68 (60.2%)</td></tr><tr><td rowspan="2" colspan="1"><bold><italic>Second location correct</italic></bold></td><td align="char" char="(" rowspan="1" colspan="1">MDLoc</td><td align="char" char="(" rowspan="1" colspan="1"><bold>1481 (78.7%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>258 (77.2%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>82 (32.5%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>99 (41.3%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>67 (55.8%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>51 (44.3%)</bold></td><td align="char" char="(" rowspan="1" colspan="1"><bold>72 (63.7%)</bold></td></tr><tr><td rowspan="1" colspan="1">BNCs</td><td align="char" char="(" rowspan="1" colspan="1">1240 (65.9%)</td><td align="char" char="(" rowspan="1" colspan="1">246 (73.7%)</td><td align="char" char="(" rowspan="1" colspan="1">68 (27%)</td><td align="char" char="(" rowspan="1" colspan="1">85 (35.4%)</td><td align="char" char="(" rowspan="1" colspan="1">64 (53.3%)</td><td align="char" char="(" rowspan="1" colspan="1">27 (23.5%)</td><td align="char" char="(" rowspan="1" colspan="1">68 (60.2%)</td></tr></tbody></table><table-wrap-foot><fn id="btv264-TF2"><p>For each combination, the table shows the number of proteins with correct predictions for both locations, for the first of the two locations, and for the second of the two locations, using MDLoc and using our preliminary system (BNCs, <xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>). The highest values are shown in boldface.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
  </sec>
  <sec>
    <title>6 Conclusion and future work</title>
    <p>We presented a new probabilistic generative model for protein localization based on Bayesian networks and a mixture model, and developed a system MDLoc, to predict multiple locations for proteins. MDLoc takes advantage of the location inter-dependencies and location-feature dependency to provide a generalizable method for predicting multiple locations for proteins. Our results demonstrate the utility of using location inter-dependencies in the prediction process, and show that the performance of MDLoc improves over current state-of-the-art reported results.</p>
    <p>MDLoc significantly improves over our own preliminary method which used a relatively simple collection of Bayesian network classifiers (<xref rid="btv264-B33" ref-type="bibr">Simha and Shatkay, 2014</xref>) whose performance was on par with that of YLoc<sup>+</sup> (<xref rid="btv264-B5" ref-type="bibr">Briesemeister <italic>et al.,</italic> 2010a</xref>). In our previous method, location inter-dependencies were not learnt as part of the model but rather captured based on simple estimates of location values. In contrast, MDLoc uses a generative model comprising Bayesian networks to directly address and capture inter-dependencies among locations, and a mixture model to represent <italic>feature dependency on location-combinations</italic>. We iteratively learn a Bayesian network over location variables while estimating the locations using expectation maximization.</p>
    <p>Our future work includes exploring alternative ways to learn the mixture model parameters, to evaluate the model learned in each iteration of our current process, and to perform multi-location inference. We will also conduct experiments testing our system’s performance on more complex location-combinations. Having a larger set of multi-localized proteins from plant-, fungi- and animal-specific organelles will also enable us to explore the possibility of building a model for each taxonomic group.</p>
    <p>As another direction, we will also experiment with features other than the ones previously used by YLoc<sup>+</sup>, utilizing multiple data-sources, which is likely to be more appropriate for representing proteins in the context of multi-location prediction.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We are grateful to J. Simmons, C. Shannon and H. Wei for assisting us with the development of a website to enable web access for MDLoc.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btv264-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Alberts</surname><given-names>B.</given-names></name><etal/></person-group> (<year>2002</year>) <source>Molecular Biology of the Cell</source><italic>.</italic>
<volume>Vol. 4</volume>
<publisher-name>Garland Science</publisher-name>, 
<publisher-loc>New York</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btv264-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bakheet</surname><given-names>T.</given-names></name><name><surname>Doig</surname><given-names>A.</given-names></name></person-group> (<year>2009</year>) 
<article-title>Properties and identification of human protein drug targets</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>25</volume>, <fpage>451</fpage>–<lpage>457</lpage>.<pub-id pub-id-type="pmid">19164304</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Belden</surname><given-names>W.</given-names></name><name><surname>Barlowe</surname><given-names>C.</given-names></name></person-group> (<year>1996</year>) 
<article-title>Erv25p, a component of copii-coated vesicles, forms a complex with Emp24p that is required for efficient endoplasmic reticulum to golgi transport</article-title>. <source>J. Biol. Chem.</source><italic>,</italic>
<volume>271</volume>, <fpage>26939</fpage>–<lpage>26946</lpage>.<pub-id pub-id-type="pmid">8900179</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Blum</surname><given-names>T.</given-names></name><etal/></person-group><italic>.</italic> (<year>2009</year>) 
<article-title>MultiLoc2: integrating phylogeny and Gene Ontology terms improves subcellular protein localization prediction</article-title>. <source>BMC Bioinformatics</source><italic>,</italic>
<volume>10</volume>, <fpage>274</fpage>.<pub-id pub-id-type="pmid">19723330</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Briesemeister</surname><given-names>S.</given-names></name><etal/></person-group><italic>.</italic> (<year>2010a</year>) 
<article-title>Going from where to why – interpretable prediction of protein subcellular localization</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>26</volume>, <fpage>1232</fpage>–<lpage>1238</lpage>.<pub-id pub-id-type="pmid">20299325</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Briesemeister</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2010b</year>). 
<article-title>YLoc—an interpretable web server for predicting subcellular localization</article-title>. <source>Nucleic Acids Res</source><italic>.,</italic>
<volume>38</volume>(<issue>Web Server issue</issue>), <fpage>W497</fpage>–<lpage>W502</lpage>.<pub-id pub-id-type="pmid">20507917</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cheng</surname><given-names>C.</given-names></name><etal/></person-group><italic>.</italic> (<year>2008</year>) 
<article-title>Transforming growth factor alpha (TGFalpha)-stimulated secretion of HSP90alpha: using the receptor LRP-1/CD91 to promote human skin cell migration against a TGFbeta-rich environment during wound healing</article-title>. <source>Mol. Cell. Biol.</source><italic>,</italic>
<volume>28</volume>, <fpage>3344</fpage>–<lpage>3358</lpage>.<pub-id pub-id-type="pmid">18332123</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chou</surname><given-names>K.</given-names></name></person-group> (<year>2001</year>) 
<article-title>Prediction of protein cellular attributes using pseudo-amino acid composition</article-title>. <source>Cell Mol. Life Sci.</source><italic>,</italic>
<volume>43</volume>, <fpage>246</fpage>–<lpage>255</lpage>.</mixed-citation>
    </ref>
    <ref id="btv264-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chou</surname><given-names>K.</given-names></name><etal/></person-group><italic>.</italic> (<year>2011</year>) 
<article-title>iLoc-Euk: a multi-label classifier for predicting the subcellular localization of singleplex and multiplex eukaryotic proteins</article-title>. <source>PLoS One</source><italic>,</italic>
<volume>6</volume>, <fpage>e18258</fpage>.<pub-id pub-id-type="pmid">21483473</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chou</surname><given-names>K.</given-names></name><name><surname>Shen</surname><given-names>H.</given-names></name></person-group> (<year>2007</year>) 
<article-title>Euk-mPLoc: a fusion classifier for large-scale eukaryotic protein subcellular location prediction by incorporating multiple sites</article-title>. <source>J. Proteome Res.</source><italic>,</italic>
<volume>6</volume>, <fpage>1728</fpage>–<lpage>1734</lpage>.<pub-id pub-id-type="pmid">17397210</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dempster</surname><given-names>A.</given-names></name><etal/></person-group><italic>.</italic> (<year>1977</year>) 
<article-title>Maximum likelihood from incomplete data via the EM algorithm</article-title>. <source>J. R. Stat. Soc. Series B</source><italic>,</italic>
<volume>39</volume>, <fpage>1</fpage>–<lpage>38</lpage>.</mixed-citation>
    </ref>
    <ref id="btv264-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dreger</surname><given-names>M.</given-names></name></person-group> (<year>2003</year>) 
<article-title>Proteome analysis at the level of subcellular structures</article-title>. <source>Eur. J. Biochem.</source><italic>,</italic>
<volume>270</volume>, <fpage>589</fpage>–<lpage>599</lpage>.<pub-id pub-id-type="pmid">12581199</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Emanuelsson</surname><given-names>O.</given-names></name><etal/></person-group><italic>.</italic> (<year>2000</year>) 
<article-title>Predicting subcellular localization of proteins based on their N-terminal amino acid sequence</article-title>. <source>J. Mol. Biol.</source><italic>,</italic>
<volume>300</volume>, <fpage>1005</fpage>–<lpage>1016</lpage>.<pub-id pub-id-type="pmid">10891285</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gama-Carvalho</surname><given-names>M.</given-names></name><name><surname>Carmo-Fonseca</surname><given-names>M.</given-names></name></person-group> (<year>2001</year>) 
<article-title>The rules and roles of nucleocytoplasmic shuttling proteins</article-title>. <source>FEBS Lett.</source><italic>,</italic>
<volume>498</volume>, <fpage>157</fpage>–<lpage>163</lpage>.<pub-id pub-id-type="pmid">11412848</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Garg</surname><given-names>A.</given-names></name><name><surname>Raghava</surname><given-names>G.</given-names></name></person-group> (<year>2008</year>) 
<article-title>ESLpred2: Improved method for predicting subcellular localization of eukaryotic proteins</article-title>. <source>BMC Bioinformatics</source><italic>,</italic>
<volume>9</volume>, <fpage>503</fpage>.<pub-id pub-id-type="pmid">19038062</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gold</surname><given-names>L.</given-names></name><etal/></person-group><italic>.</italic> (<year>2010</year>) 
<article-title>Calreticulin: non-endoplasmic reticulum functions in physiology and disease</article-title>. <source>FASEB J.</source><italic>,</italic>
<volume>24</volume>, <fpage>665</fpage>–<lpage>683</lpage>.<pub-id pub-id-type="pmid">19940256</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>He</surname><given-names>J.</given-names></name><etal/></person-group><italic>.</italic> (<year>2012</year>) 
<article-title>Imbalanced multi-modal multi-label learning for subcellular localization prediction of human proteins with both single and multiple sites</article-title>. <source>PLoS One</source><italic>,</italic>
<volume>7</volume>, <fpage>e37155</fpage>.<pub-id pub-id-type="pmid">22715364</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Höglund</surname><given-names>A.</given-names></name><etal/></person-group><italic>.</italic> (<year>2006</year>) 
<article-title>MultiLoc: prediction of protein subcellular localization using N-terminal targeting sequences, sequence motifs, and amino acid composition</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>22</volume>, <fpage>1158</fpage>–<lpage>1165</lpage>.<pub-id pub-id-type="pmid">16428265</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Horton</surname><given-names>P.</given-names></name><etal/></person-group><italic>.</italic> (<year>2007</year>) 
<article-title>WoLF PSORT: protein localization predictor</article-title>. <source>Nucleic Acids Res.</source><italic>,</italic>
<volume>35</volume> (<issue>Web Server issue</issue>), <fpage>W585</fpage>–<lpage>W587</lpage>.<pub-id pub-id-type="pmid">17517783</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Kim</surname><given-names>D.</given-names></name><etal/></person-group> (<year>2007</year>). 
<article-title>Securin induces genetic instability in colorectal cancer by inhibiting double-stranded DNA repair activity</article-title>. <source>Carcinogenesis</source><italic>,</italic>
<volume>28</volume>, <fpage>749</fpage>–<lpage>759</lpage>.<pub-id pub-id-type="pmid">17071631</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>King</surname><given-names>B.</given-names></name><name><surname>Guda</surname><given-names>C.</given-names></name></person-group> (<year>2007</year>) 
<article-title>ngLOC: an n-gram-based Bayesian method for estimating the subcellular proteomes of eukaryotes</article-title>. <source>Genome Biol.</source><italic>,</italic>
<volume>8</volume>, <fpage>R68</fpage>.<pub-id pub-id-type="pmid">17472741</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>L.</given-names></name><etal/></person-group><italic>.</italic> (<year>2012</year>) 
<article-title>Prediction of protein subcellular multi-localization based on the general form of Chou’s pseudo amino acid composition</article-title>. <source>Protein Pept. Lett.</source><italic>,</italic>
<volume>19</volume>, <fpage>375</fpage>–<lpage>387</lpage>.<pub-id pub-id-type="pmid">22185507</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lin</surname><given-names>H.</given-names></name><etal/></person-group><italic>.</italic> (<year>2009</year>) 
<article-title>Protein subcellular localization prediction of eukaryotes using a knowledge-based approach</article-title>. <source>BMC Bioinformatics</source><italic>,</italic>
<volume>10</volume> (<issue>Suppl. 15</issue>), <fpage>8</fpage>.<pub-id pub-id-type="pmid">19128505</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Murphy</surname><given-names>R.</given-names></name></person-group> (<year>2010</year>) 
<article-title>Communicating subcellular distributions</article-title>. <source>Cytometry A.</source>, <volume>77</volume>, <fpage>686</fpage>–<lpage>692</lpage>.<pub-id pub-id-type="pmid">20552685</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nair</surname><given-names>R.</given-names></name><name><surname>Rost</surname><given-names>B.</given-names></name></person-group> (<year>2008</year>) 
<article-title>Protein subcellular localization prediction using artificial intelligence technology</article-title>. <source>Funct. Proteomics</source><italic>,</italic>
<volume>484</volume>, <fpage>435</fpage>–<lpage>463</lpage>.</mixed-citation>
    </ref>
    <ref id="btv264-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Nakai</surname><given-names>K.</given-names></name><name><surname>Kanehisa</surname><given-names>M.</given-names></name></person-group> (<year>1991</year>) 
<article-title>Expert system for predicting protein localization sites in gram-negative bacteria</article-title>. <source>Proteins</source><italic>,</italic>
<volume>11</volume>, <fpage>95</fpage>–<lpage>110</lpage>.<pub-id pub-id-type="pmid">1946347</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Pohlschroder</surname><given-names>M.</given-names></name><etal/></person-group><italic>.</italic> (<year>2005</year>) 
<article-title>Diversity and evolution of protein translocation</article-title>. <source>Annu. Rev. Microbiol.</source><italic>,</italic>
<volume>59</volume>, <fpage>91</fpage>–<lpage>111</lpage>.<pub-id pub-id-type="pmid">16153164</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rost</surname><given-names>B.</given-names></name><etal/></person-group><italic>.</italic> (<year>2003</year>) 
<article-title>Automatic prediction of protein function</article-title>. <source>Cell Mol. Life Sci.</source><italic>,</italic>
<volume>60</volume>, <fpage>2637</fpage>–<lpage>2650</lpage>.<pub-id pub-id-type="pmid">14685688</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B29">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Russell</surname><given-names>S.</given-names></name><name><surname>Norvig</surname><given-names>P.</given-names></name></person-group> (<year>2010</year>) <source>Artificial Intelligence—A Modern Approach</source><italic>,</italic>
<edition>3rd edn</edition><italic>.</italic>
<publisher-name>Pearson Education</publisher-name>, 
<publisher-loc>New Jersey, USA</publisher-loc>, <edition>3rd edition</edition>.</mixed-citation>
    </ref>
    <ref id="btv264-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Schiffer</surname><given-names>M.</given-names></name><etal/></person-group><italic>.</italic> (<year>1992</year>) 
<article-title>The function of tryptophan residues in membrane proteins</article-title>. <source>Protein Eng.</source><italic>,</italic>
<volume>5</volume>, <fpage>213</fpage>–<lpage>214</lpage>.<pub-id pub-id-type="pmid">1409540</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B31">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Scholkopf</surname><given-names>B.</given-names></name><name><surname>Smola</surname><given-names>A.</given-names></name></person-group> (<year>2002</year>) <source>Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond</source><italic>.</italic>
<publisher-name>MIT Press</publisher-name>, 
<publisher-loc>MA, USA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btv264-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shatkay</surname><given-names>H.</given-names></name><etal/></person-group><italic>.</italic> (<year>2007</year>) 
<article-title>SherLoc: high-accuracy prediction of protein subcellular localization by integrating text and protein sequence data</article-title>. <source>Bioinformatics</source><italic>,</italic>
<volume>23</volume>, <fpage>1410</fpage>–<lpage>1417</lpage>.<pub-id pub-id-type="pmid">17392328</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Simha</surname><given-names>R.</given-names></name><name><surname>Shatkay</surname><given-names>H.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Protein (multi-)location prediction: using location inter-dependencies in a probabilistic framework</article-title>. <source>Algorithm Mol. Biol</source><italic>,</italic>
<volume>9</volume>, <fpage>8</fpage>.</mixed-citation>
    </ref>
    <ref id="btv264-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Simpson</surname><given-names>J.</given-names></name><etal/></person-group><italic>.</italic> (<year>2000</year>) 
<article-title>Systematic subcellular localization of novel proteins identified by large-scale cDNA sequencing</article-title>. <source>EMBO Rep.</source><italic>,</italic>
<volume>1</volume>, <fpage>287</fpage>–<lpage>292</lpage>.<pub-id pub-id-type="pmid">11256614</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>A.</given-names></name><etal/></person-group><italic>.</italic> (<year>2006</year>) 
<article-title>Computational inference of neural information flow networks</article-title>. <source>PLoS Comput. Biol.</source><italic>,</italic>
<volume>2</volume>, <fpage>e161</fpage>.<pub-id pub-id-type="pmid">17121460</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B36">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tokarev</surname><given-names>A.</given-names></name><etal/></person-group><italic>.</italic> (<year>2000</year>) 
<article-title>Overview of Intracellular Compartments and Trafficking Pathways</article-title><italic>.</italic>
<source>Landes Bioscience</source>, 
<publisher-name>Texas, USA</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btv264-B37">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tomicic</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2013</year>) 
<article-title>Human three prime exonuclease TREX1 is induced by genotoxic stress and involved in protection of glioma and melanoma cells to anticancer drugs</article-title>. <source>Biochim. Biophys. Acta</source>
<volume>1833</volume>, <fpage>1832</fpage>–<lpage>1843</lpage>.<pub-id pub-id-type="pmid">23578789</pub-id></mixed-citation>
    </ref>
    <ref id="btv264-B38">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tsoumakas</surname><given-names>G.</given-names></name><etal/></person-group> (<year>2010</year>). 
<article-title>Mining multi-label data</article-title>. In: <person-group person-group-type="editor"><name><surname>Maimon</surname><given-names>O.</given-names></name><name><surname>Rokach</surname><given-names>L.</given-names></name></person-group> (eds). <source>Data Mining and Knowledge Discovery Handbook</source><italic>,</italic>
<edition>2nd edn</edition>
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Heidelberg</publisher-loc>, <fpage>667</fpage>–<lpage>685</lpage>.</mixed-citation>
    </ref>
    <ref id="btv264-B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zhang</surname><given-names>S.</given-names></name><etal/></person-group><italic>.</italic> (<year>2008</year>) 
<article-title>DBMLoc: a database of proteins with multiple subcellular localizations</article-title>. <source>BMC Bioinformatics</source><italic>,</italic>
<volume>9</volume>, <fpage>127</fpage>.<pub-id pub-id-type="pmid">18304364</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
