<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Evol Bioinform Online</journal-id>
    <journal-id journal-id-type="publisher-id">101256319</journal-id>
    <journal-title>Evolutionary Bioinformatics Online</journal-title>
    <issn pub-type="epub">1176-9343</issn>
    <publisher>
      <publisher-name>Libertas Academica</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2658875</article-id>
    <article-id pub-id-type="publisher-id">ebo-01-37</article-id>
    <article-id pub-id-type="pmid">19325851</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast Structural Search in Phylogenetic Databases</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Jason T. L.</given-names>
        </name>
        <xref ref-type="aff" rid="af1-ebo-01-37">1</xref>
        <xref ref-type="corresp" rid="c1-ebo-01-37"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Shan</surname>
          <given-names>Huiyuan</given-names>
        </name>
        <xref ref-type="aff" rid="af2-ebo-01-37">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Shasha</surname>
          <given-names>Dennis</given-names>
        </name>
        <xref ref-type="aff" rid="af3-ebo-01-37">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Piel</surname>
          <given-names>William H.</given-names>
        </name>
        <xref ref-type="aff" rid="af4-ebo-01-37">4</xref>
      </contrib>
    </contrib-group>
    <aff id="af1-ebo-01-37"><label>1</label> Department of Computer Science, New Jersey Institute of Technology, University Heights, Newark, NJ, USA</aff>
    <aff id="af2-ebo-01-37"><label>2</label> Department of Computer Science, New Jersey Institute of Technology, University Heights, Newark, NJ, USA</aff>
    <aff id="af3-ebo-01-37"><label>3</label> Courant Institute of Mathematical Sciences, New York University, New York, NY, USA</aff>
    <aff id="af4-ebo-01-37"><label>4</label> Department of Biological Sciences, State University of New York at Buffalo, Buffalo, NY, USA</aff>
    <author-notes>
      <corresp id="c1-ebo-01-37">Correspondence: Jason T. L. Wang, email:
<email>wangj@njit.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>20</day>
      <month>2</month>
      <year>2007</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2005</year>
    </pub-date>
    <volume>1</volume>
    <fpage>37</fpage>
    <lpage>46</lpage>
    <permissions>
      <copyright-statement>Copyright © 2005 The authors.</copyright-statement>
      <copyright-year>2005</copyright-year>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/3.0">
        <p><!--CREATIVE COMMONS-->This article is published under the Creative Commons Attribution By licence. For further information go to: <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0">http://creativecommons.org/licenses/by/3.0.</ext-link></p>
      </license>
    </permissions>
    <abstract>
      <p>As the size of phylogenetic databases grows, the need for efficiently searching these databases arises. Thanks to previous and ongoing research, searching by attribute value and by text has become commonplace in these databases. However, searching by topological or physical structure, especially for large databases and especially for approximate matches, is still an art. We propose structural search techniques that, given a query or pattern tree P and a database of phylogenies D, find trees in D that are sufficiently close to P. The “closeness” is a measure of the topological relationships in P that are found to be the same or similar in a tree D in D. We develop a filtering technique that accelerates searches and present algorithms for rooted and unrooted trees where the trees can be weighted or unweighted. Experimental results on comparing the similarity measure with existing tree metrics and on evaluating the efficiency of the search techniques demonstrate that the proposed approach is promising.</p>
    </abstract>
    <kwd-group>
      <kwd>Structural pattern matching</kwd>
      <kwd>structural search and retrieval</kwd>
      <kwd>tree search strategies</kwd>
      <kwd>phylogenetic trees</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro">
    <title>Introduction</title>
    <p>Scientists model phylogenetic relations using unordered labeled trees and develop methods for constructing these trees (<xref ref-type="bibr" rid="b1-ebo-01-37">Berry and Bryant 1999</xref>; <xref ref-type="bibr" rid="b6-ebo-01-37">Camin and Sokal 1965</xref>; <xref ref-type="bibr" rid="b10-ebo-01-37">Felsenstein 2003</xref>; <xref ref-type="bibr" rid="b11-ebo-01-37">Gusfield 1997</xref>; <xref ref-type="bibr" rid="b13-ebo-01-37">Kannan et al. 1990</xref>; <xref ref-type="bibr" rid="b32-ebo-01-37">Wang et al. 2000</xref>). Different theories concerning the phylogenetic relationship of the same set of species often result in different phylogenetic trees. Even the same phylogenetic theory may yield different trees for different orthologous genes. With the unprecedented number of phylogenetic trees constructed based on these various theories, the need to analyze the trees and manage phylogenetic databases is urgent and great (<xref ref-type="bibr" rid="b23-ebo-01-37">Piel et al. 2003</xref>). One important problem in this domain is to be able to compare the trees, thus possibly determining how much two hypotheses have in common (<xref ref-type="bibr" rid="b4-ebo-01-37">Bryant et al. 2000</xref>; <xref ref-type="bibr" rid="b7-ebo-01-37">Cole et al. 2000</xref>; <xref ref-type="bibr" rid="b8-ebo-01-37">DasGupta et al. 1998</xref>; <xref ref-type="bibr" rid="b14-ebo-01-37">Kannan et al. 1995</xref>; <xref ref-type="bibr" rid="b28-ebo-01-37">Thorley and Page 2000</xref>). The common portion of two trees may represent added support for the phylogenetic relationship of the corresponding species.</p>
    <p>Our motivation for studying the tree matching problem comes from the development of tools for analyzing the phylogenetic data. One particular tool we are developing is a system for searching phylogenetic trees. Given a query or pattern tree P and a set of data trees D, this structural search engine is able to find near neighbors of P in D where the similarity scores between those neighboring trees and P are greater than or equal to a user-specified value σ. Central to our search engine is an algorithm for computing the similarity score from P to each data tree D in D.</p>
    <p>Our data consists of the phylogenetic trees stored within the widely used phylogenetic information system TreeBASE (<xref ref-type="bibr" rid="b23-ebo-01-37">Piel et al. 2003</xref>; <xref ref-type="bibr" rid="b24-ebo-01-37">Sanderson et al. 1994</xref>), accessible at <ext-link ext-link-type="uri" xlink:href="http://www.treebase.org">http://www.treebase.org</ext-link>. These trees model the evolution history among life forms. The sampled life forms, whose biological characteristics are used to infer their evolutionary history, usually appear as leaf nodes. Each internal node of one such tree represents an inferred ancestor organism of the organisms represented by its child nodes. There can be multiple levels of ancestors, with multiple organisms sharing the same ancestors.</p>
    <p>In <xref ref-type="bibr" rid="b29-ebo-01-37">Wang et al. (2003)</xref> we introduced a similarity measure to compare phylogenetic trees that satisfy the following properties:</p>
    <list list-type="bullet">
      <list-item>
        <p>Each tree is rooted and unordered, i.e., the order among siblings is unimportant, and no weight is assigned to any edge of the tree.</p>
      </list-item>
      <list-item>
        <p>Each leaf node has a label and that label appears only once in the tree, though it may appear in other trees.</p>
      </list-item>
      <list-item>
        <p>Each non-leaf node either has a label that appears nowhere else in the tree or has no label. An unlabeled internal node stands for an unnamed evolutionary unit.</p>
      </list-item>
      <list-item>
        <p>Each unlabeled internal node has at least two children.</p>
      </list-item>
    </list>
    <p>These properties characterize many trees in Tree-BASE and those generated by modern tree reconstruction programs.</p>
    <p>In this paper we extend the work in <xref ref-type="bibr" rid="b29-ebo-01-37">Wang <italic>et al</italic>. (2003)</xref> to compare unrooted phylogenetic trees as well as weighted trees, i.e., trees whose edges have weights. We first review the similarity measure and search algorithms introduced in <xref ref-type="bibr" rid="b29-ebo-01-37">Wang <italic>et al</italic>. (2003)</xref> for rooted trees. We then discuss their extensions for unrooted trees and weighted trees. Next we compare the proposed similarity measures with existing tree metrics. Finally we present performance results for near neighbor searching and conclude the paper.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Up and Down Operations</title>
      <p>Unless otherwise stated, trees discussed here refer to rooted unordered trees satisfying the four properties described in the Introduction section. We consider two types of operations, <italic>up</italic> and <italic>down</italic>, between any two nodes in a tree. These operations are intended to capture the hierarchical structure in the tree. If <italic>v</italic> is a child node of <italic>u</italic>, we use <italic>v</italic> ↑ <italic>u</italic> to represent an up operation from <italic>v</italic> to <italic>u</italic>, and use <italic>u</italic> ↓ <italic>v</italic> to represent a down operation from <italic>u</italic> to <italic>v</italic>. Then, for any pair of nodes <italic>m</italic>, <italic>n</italic> in the tree <italic>T</italic>, one can count the number of up and down operations to move, say a token, from <italic>m</italic> to <italic>n.</italic></p>
      <p>For example, consider the tree in <xref ref-type="fig" rid="f1-ebo-01-37">Figure 1</xref> and the two nodes “fox” and “rabbit” in the tree. It takes two up operations (“fox” ↑ “carnivore” and “carnivore” ↑ “mammal”) and one down operation (“mammal” ↓ “rabbit”) to go from “fox” to “rabbit” in the tree. As another example, it takes one up operation “dog” ↑ “carnivore”) and one down operation (“carnivore” ↓ “fox”) to go from “dog” to “fox” in the tree.</p>
    </sec>
    <sec>
      <title>Updown Matrix</title>
      <p>Given a tree <italic>T</italic>, we can now build two matrices, referred to as the <italic>Up matrix U</italic> and the <italic>Down matrix D</italic>, of integer values where <italic>U</italic> [<italic>u</italic>, <italic>v</italic>] represents the number of up operations from node <italic>u</italic> to node <italic>v</italic> and <italic>D</italic> [<italic>u</italic>, <italic>v</italic>] represents the number of down operations from <italic>u</italic> to v in the shortest path connecting <italic>u</italic> and <italic>v</italic> in <italic>T.</italic> Obviously <italic>U</italic> [<italic>u</italic>, <italic>u</italic>] = <italic>D</italic> [<italic>u</italic>, <italic>u</italic>] = 0 for any node <italic>u in T.</italic></p>
      <p><xref ref-type="fig" rid="f2-ebo-01-37">Figure 2</xref> shows a tree and its Up and Down matrices. Notice that one of the internal nodes, namely the parent of <italic>b</italic> and <italic>c</italic>, does not have a label. The unlabeled node does not appear in the matrices. It is easy to see that from matrix <italic>U</italic>, we can obtain matrix <italic>D</italic>, and vice versa. <italic>D</italic> is the transpose of <italic>U</italic> (or vice versa). We will therefore only use matrix <italic>U</italic> throughout the paper and refer to it as the Updown matrix. The Updown matrix of a tree <italic>T</italic> describes the structure of <italic>T.</italic> Computing the Updown matrix for a tree <italic>T</italic> requires <bold>O</bold>(<italic>N</italic><sup>2</sup>) time where <italic>N</italic> is the number of nodes <italic>in T.</italic></p>
    </sec>
    <sec>
      <title>Updown Distance</title>
      <p>In general, when using a search engine, if the user inputs a query tree with three nodes “fox”, “dog” and “tiger” plus their parent node “mammal”, the user often expects to see data trees in search results containing these nodes. If the user doesn’t want to see a search result containing, for example, a node “tiger”, he or she can simply input a query tree having “fox”, “dog” and “mammal” only. This implies that in designing a search engine and a similarity or distance measure, the following two criteria should be considered together:</p>
      <list list-type="order">
        <list-item>
          <p>Whether all, or at least most of, the labeled nodes of the query tree <italic>P</italic> occur in a data tree <italic>D</italic>;</p>
        </list-item>
        <list-item>
          <p>To which extent the query tree <italic>P</italic> is (dis)-similar to the data tree <italic>D</italic> in structure.</p>
        </list-item>
      </list>
      <p>With these criteria in mind, we seek nodes in <italic>D</italic> that match nodes in <italic>P</italic> when comparing <italic>P</italic> with <italic>D.</italic> Specifically, let <italic>V</italic><italic><sub>P</sub></italic> be the set of labeled nodes in <italic>P</italic> and let V<italic><sub>D</sub></italic> be the set of labeled nodes in <italic>D.</italic> Let <italic>U</italic><italic><sub>P</sub></italic> represent the Updown matrix of <italic>P</italic> and let <italic>U</italic><italic><sub>D</sub></italic> represent the Updown matrix of <italic>D.</italic> Let <italic>I</italic> denote the intersection of <italic>V</italic><italic><sub>P</sub></italic> and <italic>V</italic><italic><sub>D</sub></italic>; let <italic>J</italic> denote <italic>V</italic><italic><sub>D</sub></italic>−<italic>V</italic><italic><sub>D</sub></italic>.</p>
      <p>We define the <italic>Updown distance</italic> from <italic>P</italic> to <italic>D</italic>, denoted <italic>Updown dist</italic> (<italic>P</italic>, <italic>D</italic>), as</p>
      <disp-formula>
        <label>(1)</label>
        <mml:math id="M1">
          <mml:mtable columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>U</mml:mi>
                <mml:mi>p</mml:mi>
                <mml:mi>d</mml:mi>
                <mml:mi>o</mml:mi>
                <mml:mi>w</mml:mi>
                <mml:mi>n</mml:mi>
                <mml:mo>_</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mi>i</mml:mi>
                <mml:mi>s</mml:mi>
                <mml:mi>t</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>D</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>u</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mtext>I</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>v</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mtext>I</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>|</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>U</mml:mi>
                  </mml:mrow>
                  <mml:mi>P</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>u</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo>-</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>U</mml:mi>
                  </mml:mrow>
                  <mml:mi>D</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>u</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo>|</mml:mo>
              </mml:mtd>
            </mml:mtr>
            <mml:mtr>
              <mml:mtd>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>u</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mtext>J</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>v</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mtext>J</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>U</mml:mi>
                  </mml:mrow>
                  <mml:mi>P</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>u</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>The similarity score from P to D, denoted <italic>USim</italic> (<italic>P</italic>, <italic>D</italic>), is calculated by</p>
      <disp-formula>
        <label>(2)</label>
        <mml:math id="M2">
          <mml:mrow>
            <mml:mi>U</mml:mi>
            <mml:mi>S</mml:mi>
            <mml:mi>i</mml:mi>
            <mml:mi>m</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>P</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mi>D</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mo>-</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>U</mml:mi>
                    <mml:mi>p</mml:mi>
                    <mml:mi>d</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>w</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mo>_</mml:mo>
                    <mml:mi>d</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>s</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>D</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>u</mml:mtext>
                        <mml:mo>∈</mml:mo>
                        <mml:mi> </mml:mi>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mtext>v</mml:mtext>
                          </mml:mrow>
                          <mml:mtext>P</mml:mtext>
                        </mml:msub>
                      </mml:mrow>
                    </mml:msub>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>v</mml:mtext>
                        <mml:mo>∈</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mtext>v</mml:mtext>
                          </mml:mrow>
                          <mml:mtext>P</mml:mtext>
                        </mml:msub>
                      </mml:mrow>
                    </mml:msub>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>U</mml:mi>
                      </mml:mrow>
                      <mml:mi>P</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">[</mml:mo>
                    <mml:mi>u</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>v</mml:mi>
                    <mml:mo stretchy="false">]</mml:mo>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>×</mml:mo>
            <mml:mn>100</mml:mn>
            <mml:mo>%</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The similarity score from <italic>P</italic> to <italic>D</italic> is a measure of the topological relationships in <italic>P</italic> that are found to be the same or similar in <italic>D</italic>. If <italic>P</italic> and <italic>D</italic> are the same or if one can find a substructure in <italic>D</italic> that exactly matches <italic>P</italic>, then <italic>USim</italic> (<italic>P</italic>, <italic>D</italic>) = 100%. On the other hand, if <italic>P</italic> and <italic>D</italic> do not have any labeled node in common, then <italic>USim</italic> (<italic>P</italic>, <italic>D</italic>) = 0. The time complexity of the algorithm for computing <italic>USim</italic> (<italic>P</italic>, <italic>D</italic>) is <bold>O</bold>(<italic>M</italic><sup>2</sup> + <italic>N</italic>) where <italic>M</italic> is the number of nodes in <italic>P</italic>, and <italic>N</italic> is the number of nodes in <italic>D.</italic></p>
    </sec>
  </sec>
  <sec>
    <title>Tree Reduction</title>
    <p><xref ref-type="fig" rid="f3-ebo-01-37">Figure 3</xref> shows a query tree <italic>P</italic> and a data tree <italic>D</italic> that satisfy the four properties described in the Introduction section. In the biological sense, when comparing <italic>P</italic> with <italic>D</italic>, the similarity score <italic>USim</italic> (<italic>P</italic>, <italic>D</italic>) should be 100%. Motivated by this example, we incorporate a <italic>data tree reduction</italic> technique into our structural searching algorithm, which works as follows.</p>
    <p>Consider a query tree <italic>P</italic> and a data tree <italic>D</italic> and their Updown matrices. Find the column and row indexes of the nodes in the intersection of <italic>V</italic><italic><sub>P</sub></italic> and <italic>V</italic><italic><sub>D</sub></italic>. Mark those matching nodes in <italic>D</italic> with asterisks. If two distinct nodes of <italic>D</italic> are marked, then their least common ancestor is also marked. We then consider the reduced data tree <italic>D</italic>′ <italic>of D</italic> that contains only the marked nodes. Equivalently, we remove unmarked nodes having only one neighbor (this must preserve connectedness). The above removal might yield additional unmarked nodes with one neighbor, which themselves will be removed. If an unmarked node <italic>n</italic> is connected to two other nodes <italic>m</italic><sub>1</sub> and m<sub>2</sub>, then remove <italic>n</italic> and link <italic>m</italic><sub>1</sub> and <italic>m</italic><sub>2</sub>. This too preserves connectedness. Continue doing these two operations until neither can be done. The node removal operation is similar to the “degree-2 delete” operation defined in <xref ref-type="bibr" rid="b30-ebo-01-37">Wang <italic>et al</italic>. (2002)</xref> where a node can be deleted when the node’s degree is less than or equal to 2. Notice that after reduction, the Updown matrices will change, and we use the new matrices to calculate the Updown distance and similarity score from <italic>P</italic> to <italic>D.</italic></p>
    <p><xref ref-type="fig" rid="f4-ebo-01-37">Figure 4</xref> presents an example. In the figure, (i) shows a query tree, (ii) shows a data tree in which some nodes are marked, and (iii) shows the reduced tree of the data tree in (ii). In performing a structural search, our algorithm first applies the tree reduction technique to a data tree <italic>D</italic>, and then calculates the similarity score from the given query tree <italic>P</italic> to the reduced tree of <italic>D</italic> using the formula in Equation (2). The resulting value is then presented as the similarity score from <italic>P</italic> to <italic>D.</italic></p>
    <p>For example, in <xref ref-type="fig" rid="f4-ebo-01-37">Figure 4</xref>, the similarity score from the query tree in (i) to the reduced data tree in (iii) is 68.42%. Hence, our algorithm displays the data tree in (ii) and indicates that the similarity score from the query tree to the data tree is 68.42%. This matching technique yields a similar effect as tree matching with variable length don’t cares (<xref ref-type="bibr" rid="b20-ebo-01-37">Page 2005b</xref>; <xref ref-type="bibr" rid="b25-ebo-01-37">Shasha <italic>et al</italic>. 2002</xref>), though the proposed approach does not require the user to explicitly specify the don’t cares in the query tree.</p>
    <sec>
      <title>A Filter</title>
      <p>Given a query or pattern tree <italic>P</italic> and a database of phylogenies <italic>D</italic>, our goal is to find near neighbors of <italic>P</italic> in <italic>D</italic> where the similarity scores between the near neighbors and P are greater than or equal to a user-specified threshold σ. We develop a filter to speed up the search, which works as follows. For the database of trees, we create a hash table keyed by pair of node labels and each hash bin contains tree identification numbers. The pair can be in alphabetical order because <italic>U</italic> [<italic>u</italic>, <italic>v</italic>] = <italic>D</italic> [<italic>v</italic>, <italic>u</italic>] for any pair of node labels (<italic>u</italic>, <italic>v</italic>). Now given the query tree <italic>P</italic>, we consider each pair of node labels in P and see which trees of the database the pair is in. (This requires time independent of the size of the database.) Sort the data trees by the number of hits.</p>
      <p>When evaluating a data tree <italic>D</italic>, we get a lower bound on the Updown distance from <italic>P</italic> to <italic>D</italic> by looking at <italic>U</italic><italic><sub>P</sub></italic> [<italic>u</italic>, <italic>v</italic>] where <italic>U</italic><italic><sub>P</sub></italic> is the Updown matrix of <italic>P</italic> and (<italic>u</italic>, <italic>v</italic>) is a pair in <italic>P</italic> that is missing from <italic>D.</italic> The lower bound, denoted <italic>Low</italic>, is computed by summing up <italic>U</italic><italic><sub>P</sub></italic>[<italic>u</italic>, <italic>v</italic>] for all pairs of (<italic>u</italic>, <italic>v</italic>) <italic>of P</italic> that are missing from <italic>D.</italic> From the lower bound, we can calculate an upper bound, denoted <italic>U</italic><italic><sub>PP</sub></italic>, on the similarity score from <italic>P</italic> to <italic>D</italic>, where and <italic>V</italic><italic><sub>P</sub></italic> is the set of labelled nodes <italic>in P.</italic></p>
      <disp-formula>
        <label>(3)</label>
        <mml:math id="M3">
          <mml:mrow>
            <mml:mi>U</mml:mi>
            <mml:mi>p</mml:mi>
            <mml:mi>p</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mo>-</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>L</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>w</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mtext>u</mml:mtext>
                        <mml:mo>∈</mml:mo>
                        <mml:mi> </mml:mi>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mtext>V</mml:mtext>
                          </mml:mrow>
                          <mml:mtext>P</mml:mtext>
                        </mml:msub>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mtext>v</mml:mtext>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mtext>V</mml:mtext>
                            </mml:mrow>
                            <mml:mtext>P</mml:mtext>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>U</mml:mi>
                          </mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:msub>
                        <mml:mo stretchy="false">[</mml:mo>
                        <mml:mi>u</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>v</mml:mi>
                        <mml:mo stretchy="false">]</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>×</mml:mo>
            <mml:mn>100</mml:mn>
            <mml:mo>%</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>If the upper bound is already smaller than the user-specified value σ, we can eliminate <italic>D</italic> from consideration without calculating the similarity score from <italic>P</italic> to <italic>D.</italic> Furthermore, if a data tree <italic>D</italic> has a set <italic>S</italic> of <italic>k</italic> hits and it is decided <italic>D</italic> doesn’t qualify to be a solution after calculating the similarity score from <italic>P</italic> to <italic>D</italic>, then any data tree <italic>D</italic>′ that only has S′ of <italic>k</italic>′ hits, where <italic>k</italic>′ &lt; <italic>k</italic> and <italic>S</italic>′ is a subset of <italic>S</italic>, will not be a solution and hence can be eliminated from consideration. As our experimental results show later, this filtering technique works well in practice.</p>
    </sec>
    <sec>
      <title>Extensions to Weighted and Unrooted Trees</title>
      <p>Some tree reconstruction methods provide information to build a weighted tree where the weight on an edge represents the estimated evolutionary distance between the two nodes connected by the edge (<xref ref-type="bibr" rid="b22-ebo-01-37">Page and Holmes 1998</xref>). In extending our approach for weighted trees, we associate each up and down operation with a weight that equals the weight of the corresponding edge. Instead of having <italic>U</italic> [<italic>u</italic>, <italic>v</italic>] represent the number of up operations from node <italic>u</italic> to node <italic>v</italic>, we use <italic>U</italic> [<italic>u</italic>, <italic>v</italic>] to represent the sum of weights associated with the up operations from <italic>u</italic> to <italic>v</italic>. Likewise, we use <italic>D</italic> [<italic>u</italic>, <italic>v</italic>] to represent the sum of weights associated with the down operations from <italic>u</italic> to <italic>v</italic>. The similarity score between two weighted trees is then calculated in the same way as in Equation (2).</p>
      <p>Some phylogenetic tree reconstruction methods may produce unrooted unordered trees, or free trees. An unrooted tree is one that specifies only kinship relationships among taxa without specifying ancestry relationships. The common ancestor of all taxa is unknown. Each edge in an unrooted tree can be weighted or unweighted. Let <italic>T be</italic> an unrooted unordered tree. We define the <italic>Additive matrix A</italic> for <italic>T</italic> where each entry <italic>A</italic> [<italic>u</italic>, <italic>v</italic>] is the sum of the edge weights on the shortest path connecting <italic>u</italic> and <italic>v</italic> in <italic>T.</italic> If <italic>T</italic> is not weighted, then <italic>A</italic> [<italic>u</italic>, <italic>v</italic>] is simply the number of edges on the shortest path connecting <italic>u</italic> and <italic>v</italic> in <italic>T</italic> (reminiscent of the additive distance for an unrooted tree described in <xref ref-type="bibr" rid="b1-ebo-01-37">Berry and Bryant 1999</xref>; <xref ref-type="bibr" rid="b5-ebo-01-37">Buneman 1971</xref>; <xref ref-type="bibr" rid="b31-ebo-01-37">Wang and Gusfield 1998</xref>). Notice that when a rooted tree is treated as unrooted, we have <italic>U</italic> [<italic>u</italic>, <italic>v</italic>] + <italic>U</italic> [<italic>v</italic>, <italic>u</italic>] = <italic>A</italic>[<italic>u</italic>, <italic>v</italic>] for all pairs of (<italic>u</italic>, <italic>v</italic>) in the tree, where <italic>U</italic> and <italic>A</italic> are the Updown and Additive matrices respectively. Therefore, matrix <italic>A</italic> can be obtained from <italic>U</italic> (the converse is not true). As matrix <italic>A</italic> is an additive matrix, the four-point condition (<xref ref-type="bibr" rid="b5-ebo-01-37">Buneman 1971</xref>; <xref ref-type="bibr" rid="b34-ebo-01-37">Zaretskii 1965</xref>) applies. Hence, an Updown matrix corresponds to a unique Additive matrix which corresponds to a unique tree. This holds for both weighted and unweighted trees.</p>
      <p>Now let <italic>A</italic><italic><sub>P</sub></italic> represent the Additive matrix of the query tree <italic>P</italic> and let <italic>A</italic><italic><sub>D</sub></italic> represent the Additive matrix of a data tree <italic>D.</italic> Let <italic>V</italic><italic><sub>P</sub></italic> <italic>be</italic> the set of labelled nodes in <italic>P</italic> and let <italic>V</italic><italic><sub>D</sub></italic> <italic>be</italic> the set of labelled nodes in <italic>D.</italic> Let <italic>I</italic> be the intersection of <italic>V</italic><italic><sub>P</sub></italic> <italic>and V</italic><italic><sub>D</sub></italic>; let <italic>J</italic> denote <italic>V</italic><italic><sub>P</sub></italic>−<italic>V</italic><italic><sub>D</sub></italic>. We define the Additive distance from <italic>P</italic> to <italic>D</italic>, denoted <italic>Add_dist</italic> (<italic>P</italic>, <italic>D</italic>), as follows (reminiscent of the measure defined in <xref ref-type="bibr" rid="b33-ebo-01-37">Williams and Clifford 1971</xref>):</p>
      <disp-formula>
        <label>(4)</label>
        <mml:math id="M4">
          <mml:mtable columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:mi>A</mml:mi>
                <mml:mi>d</mml:mi>
                <mml:mi>d</mml:mi>
                <mml:mo>_</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mi>i</mml:mi>
                <mml:mi>s</mml:mi>
                <mml:mi>t</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>D</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>u</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mtext>I</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>v</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mi>I</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>|</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>A</mml:mi>
                  </mml:mrow>
                  <mml:mi>P</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>u</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo>-</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>A</mml:mi>
                  </mml:mrow>
                  <mml:mi>D</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>u</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
                <mml:mo>|</mml:mo>
              </mml:mtd>
            </mml:mtr>
            <mml:mtr>
              <mml:mtd>
                <mml:mo>+</mml:mo>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>u</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mtext>J</mml:mtext>
                  </mml:mrow>
                </mml:msub>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi mathvariant="normal">Σ</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mtext>v</mml:mtext>
                    <mml:mo>∈</mml:mo>
                    <mml:mi>J</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo stretchy="false">[</mml:mo>
                <mml:mi>u</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>v</mml:mi>
                <mml:mo stretchy="false">]</mml:mo>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>The similarity score from <italic>P</italic> to <italic>D</italic>, denoted <italic>ASim</italic> (<italic>P</italic>, <italic>D</italic>), is calculated by</p>
      <disp-formula>
        <label>(5)</label>
        <mml:math id="M5">
          <mml:mrow>
            <mml:mi>A</mml:mi>
            <mml:mi>S</mml:mi>
            <mml:mi>i</mml:mi>
            <mml:mi>m</mml:mi>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi>P</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mi>D</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mo>(</mml:mo>
              <mml:mrow>
                <mml:mn>1</mml:mn>
                <mml:mo>-</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>A</mml:mi>
                    <mml:mi>d</mml:mi>
                    <mml:mi>d</mml:mi>
                    <mml:mo>_</mml:mo>
                    <mml:mi>d</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>s</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>D</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>u</mml:mtext>
                        <mml:mo>∈</mml:mo>
                        <mml:mi> </mml:mi>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mtext>v</mml:mtext>
                          </mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:msub>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi mathvariant="normal">Σ</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mtext>v</mml:mtext>
                        <mml:mo>∈</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mtext>v</mml:mtext>
                          </mml:mrow>
                          <mml:mi>P</mml:mi>
                        </mml:msub>
                      </mml:mrow>
                    </mml:msub>
                    <mml:msub>
                      <mml:mrow>
                        <mml:mi>A</mml:mi>
                      </mml:mrow>
                      <mml:mi>P</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">[</mml:mo>
                    <mml:mi>u</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>v</mml:mi>
                    <mml:mo stretchy="false">]</mml:mo>
                  </mml:mrow>
                </mml:mfrac>
              </mml:mrow>
              <mml:mo>)</mml:mo>
            </mml:mrow>
            <mml:mo>×</mml:mo>
            <mml:mn>100</mml:mn>
            <mml:mo>%</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The time complexity of the algorithm for computing <italic>ASim</italic> (<italic>P</italic>, <italic>D</italic>) is <bold>O</bold>(<italic>M</italic><sup>2</sup> + <italic>N</italic>) where <italic>M</italic> is the number of nodes in <italic>P</italic>, and <italic>N</italic> is the number of nodes in <italic>D.</italic> It can be shown that for two unrooted trees <italic>P</italic> and <italic>D</italic>, whether they are weighted or unweighted, <italic>P</italic> and <italic>D</italic> are identical if and only if the similarity score from <italic>P</italic> to <italic>D</italic> is 100%. This property holds for rooted trees as well.</p>
    </sec>
  </sec>
  <sec sec-type="results">
    <title>Experiments and Results</title>
    <sec>
      <title>Comparison of (Dis)similarity Measures</title>
      <p>To evaluate the quality of the proposed similarity measures, we compared <italic>USim</italic> defined in Equation (2) with four widely used tree metrics implemented in the COMPONENT tool (<xref ref-type="bibr" rid="b19-ebo-01-37">Page 2005a</xref>). These tree metrics include partition metric (PAR), nearest neighbour interchange metric (NNI), quartet metric (QUA) and maximum agreement subtree metric (MAST). Specifically, we compared the distribution of the metric values on 945 unweighted rooted trees generated by the COMPONENT tool. The query tree was generated randomly; the 945 data trees covered the entire tree space of unweighted rooted trees with 6 labels. We compared the query tree with each data tree to obtain a metric or (dis)similarity value. For PAR, the metric value equals the number of edges in the query tree for which there is no equivalent (in the sense of creating the same partitions) edge in the data tree. For NNI, the metric value equals the number of nearest neighbour interchange operations needed to transform the query tree to the data tree. For QUA, the metric value equals the proportion of quartets that are shared in the query tree and the data tree. For MAST, the metric value equals the number of leaves removed to obtain a maximum agreement subtree of the query tree and the data tree.</p>
      <p><xref ref-type="fig" rid="f5-ebo-01-37">Figures 5</xref>–<xref ref-type="fig" rid="f9-ebo-01-37">9</xref> summarize the experimental results. In each figure, the X-axis shows different metric values. For each specified value on the X-axis, the figure shows the number of data trees whose metric/(dis)similarity value from the query tree equals the specified value. The pattern in <xref ref-type="fig" rid="f5-ebo-01-37">Figures 5</xref> and <xref ref-type="fig" rid="f8-ebo-01-37">8</xref> agrees with the finding reported in <xref ref-type="bibr" rid="b26-ebo-01-37">Steel and Penny (1993)</xref>, which presented a similar simulation. We see from <xref ref-type="fig" rid="f5-ebo-01-37">Figures 5</xref>–<xref ref-type="fig" rid="f9-ebo-01-37">9</xref> that the proposed similarity measure has a good distribution of values, unlike partition metric (PAR) and maximum agreement subtree metric (MAST). It should be pointed out that each tree metric has its own advantages and shortcomings. As far as structural search is concerned, it is desirable to have a tree metric with a wide range of values. This would produce a sensible, ranked list of search results. We have also tested additional query trees. The distributions of metric values depend on the tested query trees, though the qualitative conclusion obtained from these additional experiments remains the same.</p>
      <p><xref ref-type="table" rid="t1-ebo-01-37">Table 1</xref> shows an in-depth comparison between the four widely used tree metrics and the proposed similarity measures <italic>USim</italic> and <italic>ASim</italic>, collectively referred to as WSSP. In the table, a “Y” value in the “Polynomial computable” column means that there is a polynomial time algorithm for computing the corresponding tree metric and an “N” value means that computing the corresponding tree metric has been shown to be NP-hard. From <xref ref-type="table" rid="t1-ebo-01-37">Table 1</xref> it can be seen that the running time of WSSP is better than NNI (nearest neighbour interchange metric). WSSP can be applied to weighted trees and unweighted trees where trees can be fully resolved or unresolved. It can be used to compare two trees whose internal nodes have labels and whose leaves have different taxa as shown in <xref ref-type="table" rid="t1-ebo-01-37">Table 1</xref>. The bottom line is that WSSP could be a useful metric in addition to the other excellent ones available.</p>
    </sec>
    <sec>
      <title>Efficiency of the Filter and Search Method</title>
      <p>We have also tested our filter technique on synthetic data. One thousand unweighted rooted trees were randomly generated, each tree having 100 nodes. The string labels of nodes were randomly chosen from a dictionary of size 500. The threshold value σ was set to 60%. In each run, a tree was selected and modified into the query tree and the other trees were used as data trees. 1,000 runs were tested and the average was plotted. <xref ref-type="fig" rid="f10-ebo-01-37">Figure 10</xref> shows the results for varying query tree sizes. It can be seen from the figure that the proposed filter speeds up searches considerably. It was also observed that the running time drops as the user-specified threshold value σ increases. This happens because fewer data trees survive the filter when σ becomes larger. <xref ref-type="fig" rid="f11-ebo-01-37">Figure 11</xref> shows that the proposed search method scales up well – its running time increases linearly with increasing number of trees. These results are consistent with those for real phylogenetic trees.</p>
    </sec>
    <sec>
      <title>A Structural Search Engine</title>
      <p>The proposed search method for unweighted rooted trees has been implemented into a Web-based system connected with TreeBASE. <xref ref-type="fig" rid="f12-ebo-01-37">Figure 12</xref> shows the system’s main screen and query interface (the upper left window), a query tree (the lower left window), and the query tree’s nearest neighbor in TreeBASE (the right window). In the main screen, the query tree is expressed in the parenthesized string notation; in the other two windows this same query tree and the nearest neighboring tree are viewed in the dendrogram format.</p>
      <p><xref ref-type="fig" rid="f12-ebo-01-37">Figure 12</xref> displays data trees in TreeBASE where the similarity score, <italic>USim</italic>, of each data tree to the query tree is greater than or equal to the user-specified threshold, 60%. Among the data trees, Tree1411 is ranked highest, which is the nearest neighbor of the query tree with a 100% similarity score. It should be pointed out that after applying the tree reduction technique to Tree1411, the reduced tree is exactly the same as the query tree. (The matched taxa between the query tree and Tree 1411 are highlighted with a bullet and underscored in the figure.) Consequently the similarity score for Tree1411 is 100%.</p>
      <p>This structural search engine is implemented using Java, HTML, Perl, CGI, and C. It is fully operational and is accessible at <ext-link ext-link-type="uri" xlink:href="http://aria.njit.edu/~biotool/nnsearch.html">http://aria.njit.edu/~biotool/nnsearch.html</ext-link>. As of June 2005, about 600 users worldwide have accessed the search engine over 8,000 times totally. Most submitted query trees are small trees with 20 or fewer nodes. With these query trees, a moderate similarity score (e.g. 60%), and the approximately 1,600 unweighted rooted trees in TreeBASE, the system can perform a search in about one second on a SUN Ultra 20 workstation.</p>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <p>Unlike many existing metrics (<xref ref-type="bibr" rid="b2-ebo-01-37">Brodal <italic>et al</italic>. 2001</xref>; <xref ref-type="bibr" rid="b3-ebo-01-37">Brown and Day 1984</xref>; <xref ref-type="bibr" rid="b7-ebo-01-37">Cole <italic>et al</italic>. 2000</xref>; <xref ref-type="bibr" rid="b9-ebo-01-37">Day 1985</xref>; <xref ref-type="bibr" rid="b12-ebo-01-37">Hein <italic>et al</italic>. 1996</xref>; <xref ref-type="bibr" rid="b15-ebo-01-37">Kao <italic>et al</italic>. 1997</xref>; <xref ref-type="bibr" rid="b16-ebo-01-37">Kubicka <italic>et al</italic>. 1995</xref>; <xref ref-type="bibr" rid="b17-ebo-01-37">Lam <italic>et al</italic>. 1996</xref>; <xref ref-type="bibr" rid="b18-ebo-01-37">Page 1989</xref>; <xref ref-type="bibr" rid="b21-ebo-01-37">Page and Charleston 1998</xref>), designed for comparing two trees possibly with some constraints (e.g. the two trees must have the same set of leaves), the similarity scores described in the paper are mainly developed for near neighbor searching in phylogenetic databases. The similarity scores are not symmetric, i.e. <italic>USim</italic>(<italic>X</italic>, <italic>Y</italic>) ≠ <italic>USim</italic>(<italic>Y</italic>, <italic>X</italic>), <italic>ASim</italic>(<italic>X</italic>, <italic>Y</italic>) ≠ <italic>ASim</italic>(<italic>Y</italic>, <italic>X</italic>), for any two trees <italic>X</italic> and <italic>Y.</italic> The non-symmetry property is good in query-driven phylogenetic information retrieval; it distinguishes between the situation in which <italic>X</italic> is a query and <italic>Y</italic> is a data tree and the situation in which <italic>Y</italic> is a query and <italic>X</italic> is a data tree.</p>
    <p>It should be pointed out that when a substructure in a data tree <italic>D</italic> exactly matches a query tree <italic>P</italic>, <italic>USim</italic>(<italic>P</italic>, <italic>D</italic>) = 100%, but the converse is not true. For example, if <italic>P</italic> = ((a, <italic>b</italic>), (<italic>c</italic>, <italic>d</italic>)) and <italic>D</italic> = ((a, <italic>b</italic>), <italic>c</italic>), the similarity score will be smaller than 100% despite the fact that a substructure of <italic>P</italic> exactly matches <italic>D.</italic> On the other hand, if <italic>D</italic> = ((<italic>a</italic>, <italic>b</italic>), (<italic>c</italic>, <italic>d</italic>)) and <italic>P</italic> = ((a, <italic>b</italic>), <italic>c</italic>), then the similarity score yields 100%. Moreover, the similarity score from <italic>P</italic> to <italic>D</italic> strongly depends on the size of the subset of taxa that are in the query tree but not in the data tree—the larger this subset, the smaller the similarity.</p>
    <p>We have analyzed about 1,000 typical query trees submitted to our search engine by users around the world. Most query trees are small trees with 20 or fewer nodes and they may not have the same taxa as the data trees in TreeBASE. The users expect to see that a top ranked data tree in search results should be close to a query tree both in structure and in the number of overlapping taxa. Based on the user feedback, we designed the proposed similarity measure and ranking algorithm. On the other hand, if the user is only interested in evolutionary relations between species (i.e., tree topologies), the overlap between the taxa set of a query tree and that of a data tree is less important. In situations where the query tree and the data tree have the same set of taxa, the lower and upper bound that define the proposed filter would be 0 and 100% respectively, yielding a less efficient filter method.</p>
    <p>In summary, we have presented a new approach to near neighbor searching for phylogenetic trees. Given a query or pattern tree <italic>P</italic> and a database of trees <italic>D</italic>, the proposed approach finds data trees <italic>D</italic> in <italic>D</italic> where the similarity score <italic>of P</italic> to <italic>D</italic> is greater than or equal to a user-specified threshold value. We developed similarity measures for comparing rooted and unrooted trees where the trees can be weighted or unweighted. The proposed algorithms have been used for analyzing the structures of phylogenetic trees and for performing structure-based searches in TreeBASE.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgement</title>
    <p>We would like to thank the anonymous reviewers for their thoughtful comments that helped to improve both the presentation and the content of this paper. This work was supported in part by NSF grants IIS-9988345, IIS-9988636, MCB-0209754 and NIH grant GM32877.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="b1-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Berry</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Bryant</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <year>1999</year>
        <article-title>Faster reliable phylogenetic analysis</article-title>
        <conf-name>Proceedings of the 3rd Annual International Conference on Computational Molecular Biology</conf-name>
        <fpage>59</fpage>
        <lpage>68</lpage>
      </citation>
    </ref>
    <ref id="b2-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Brodal</surname>
            <given-names>GS</given-names>
          </name>
          <name>
            <surname>Fagerberg</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Pedersen</surname>
            <given-names>CNS</given-names>
          </name>
        </person-group>
        <year>2001</year>
        <article-title>Computing the quartet distance between evolutionary trees in time <italic>O</italic>(<italic>nlog</italic><italic><sup>2</sup></italic><italic>n</italic>). In </article-title>
        <conf-name>Proceedings of the 12th Annual International Symposium on Algorithms and Computation</conf-name>
        <fpage>731</fpage>
        <lpage>742</lpage>
      </citation>
    </ref>
    <ref id="b3-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brown</surname>
            <given-names>EK</given-names>
          </name>
          <name>
            <surname>Day</surname>
            <given-names>WHE</given-names>
          </name>
        </person-group>
        <year>1984</year>
        <article-title>A computationally efficient approximation to the nearest neighbor interchange metric</article-title>
        <source>Journal of Classification</source>
        <volume>1</volume>
        <fpage>93</fpage>
        <lpage>124</lpage>
      </citation>
    </ref>
    <ref id="b4-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Bryant</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tsang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kearney</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2000</year>
        <article-title>Computing the quartet distance between evolutionary trees</article-title>
        <conf-name>Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms</conf-name>
      </citation>
    </ref>
    <ref id="b5-ebo-01-37">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Buneman</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <year>1971</year>
        <article-title>The recovery of trees from measures of dissimilarity</article-title>
        <source>Mathematics in Archaeological and Historical Sciences</source>
        <publisher-loc>Edinburgh</publisher-loc>
        <publisher-name>University Press</publisher-name>
        <fpage>387</fpage>
        <lpage>395</lpage>
      </citation>
    </ref>
    <ref id="b6-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Camin</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Sokal</surname>
            <given-names>RR</given-names>
          </name>
        </person-group>
        <year>1965</year>
        <article-title>A method for deducing branching sequences in phylogeny</article-title>
        <source>Evolution</source>
        <volume>19</volume>
        <fpage>311</fpage>
        <lpage>326</lpage>
      </citation>
    </ref>
    <ref id="b7-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cole</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Farach-Colton</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hariharan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Przytycka</surname>
            <given-names>TM</given-names>
          </name>
          <name>
            <surname>Thorup</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <year>2000</year>
        <article-title>An <italic>O(nlogn)</italic> algorithm for the maximum agreement subtree problem for binary trees</article-title>
        <source>SIAM J. Comput</source>
        <volume>30</volume>
        <issue>5</issue>
        <fpage>1385</fpage>
        <lpage>1404</lpage>
      </citation>
    </ref>
    <ref id="b8-ebo-01-37">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>DasGupta</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>He</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tromp</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Du</surname>
            <given-names>DZ</given-names>
          </name>
          <name>
            <surname>Pardalos</surname>
            <given-names>PM</given-names>
          </name>
        </person-group>
        <year>1998</year>
        <article-title>Computing distances between evolutionary trees</article-title>
        <source>Handbook of Combinatorial Optimization</source>
        <publisher-name>Kluwer Academic Publishers</publisher-name>
        <volume>2</volume>
        <fpage>35</fpage>
        <lpage>76</lpage>
      </citation>
    </ref>
    <ref id="b9-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Day</surname>
            <given-names>WHE</given-names>
          </name>
        </person-group>
        <year>1985</year>
        <article-title>Optimal algorithms for comparing trees with labeled leaves</article-title>
        <source>Journal of Classification</source>
        <volume>2</volume>
        <fpage>7</fpage>
        <lpage>28</lpage>
      </citation>
    </ref>
    <ref id="b10-ebo-01-37">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <year>2003</year>
        <source>Inferring Phylogenies</source>
        <publisher-name>Sinauer Associates, Inc., Publishers</publisher-name>
        <publisher-loc>Sunderland, MA</publisher-loc>
      </citation>
    </ref>
    <ref id="b11-ebo-01-37">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <year>1997</year>
        <source>Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</source>
        <publisher-name>Cambridge University Press</publisher-name>
        <publisher-loc>New York</publisher-loc>
      </citation>
    </ref>
    <ref id="b12-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hein</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <year>1996</year>
        <article-title>On the complexity of comparing evolutionary trees</article-title>
        <source>Discrete Applied Mathematics</source>
        <volume>71</volume>
        <fpage>153</fpage>
        <lpage>169</lpage>
      </citation>
    </ref>
    <ref id="b13-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Kannan</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lawler</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Warnow</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <year>1990</year>
        <article-title>Determining the evolutionary tree</article-title>
        <conf-name>Proceedings of the 1st Annual ACM-SIAM Symposium on Discrete Algorithms</conf-name>
        <fpage>475</fpage>
        <lpage>484</lpage>
      </citation>
    </ref>
    <ref id="b14-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Kannan</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Warnow</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Yooseph</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <year>1995</year>
        <article-title>Computing the local consensus of trees</article-title>
        <conf-name>Proceedings of the 6th Annual ACM-SIAM Symposium on Discrete Algorithms</conf-name>
        <fpage>68</fpage>
        <lpage>77</lpage>
      </citation>
    </ref>
    <ref id="b15-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Kao</surname>
            <given-names>MY</given-names>
          </name>
          <name>
            <surname>Lam</surname>
            <given-names>TW</given-names>
          </name>
          <name>
            <surname>Przytycka</surname>
            <given-names>TM</given-names>
          </name>
          <name>
            <surname>Sung</surname>
            <given-names>WK</given-names>
          </name>
          <name>
            <surname>Ting</surname>
            <given-names>HF</given-names>
          </name>
        </person-group>
        <year>1997</year>
        <article-title>General techniques for comparing unrooted evolutionary trees</article-title>
        <conf-name>Proceedings of the 29th Annual ACM Symposium on Theory of Computing</conf-name>
        <fpage>54</fpage>
        <lpage>65</lpage>
      </citation>
    </ref>
    <ref id="b16-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kubicka</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kubicki</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>McMorris</surname>
            <given-names>FR</given-names>
          </name>
        </person-group>
        <year>1995</year>
        <article-title>An algorithm to find agreement subtrees</article-title>
        <source>Journal of Classification</source>
        <volume>12</volume>
        <issue>1</issue>
        <fpage>91</fpage>
        <lpage>99</lpage>
      </citation>
    </ref>
    <ref id="b17-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Sung</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Ting</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <year>1996</year>
        <article-title>Computing the unrooted maximum agreement subtree in subquadratic time</article-title>
        <conf-name>Proceedings of the 5th Scandinavian Workshop on Algorithm Theory</conf-name>
        <fpage>124</fpage>
        <lpage>135</lpage>
      </citation>
    </ref>
    <ref id="b18-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
        </person-group>
        <year>1989</year>
        <article-title>Comments on component-compatibility in historical biogeography</article-title>
        <source>Cladistics</source>
        <volume>5</volume>
        <fpage>167</fpage>
        <lpage>182</lpage>
      </citation>
    </ref>
    <ref id="b19-ebo-01-37">
      <citation citation-type="web">
        <person-group person-group-type="author">
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
        </person-group>
        <year>2005a</year>
        <ext-link ext-link-type="uri" xlink:href="http://taxonomy.zoology.gla.ac.uk/rod/cpw.html">http://taxonomy.zoology.gla.ac.uk/rod/cpw.html</ext-link>
      </citation>
    </ref>
    <ref id="b20-ebo-01-37">
      <citation citation-type="web">
        <person-group person-group-type="author">
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
        </person-group>
        <year>2005b</year>
        <ext-link ext-link-type="uri" xlink:href="http://darwin.zoology.gla.ac.uk/~rpage/TreeSearcher/TreeSearcher/TreeSearcher.html">http://darwin.zoology.gla.ac.uk/~rpage/TreeSearcher/TreeSearcher/TreeSearcher.html</ext-link>
      </citation>
    </ref>
    <ref id="b21-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
          <name>
            <surname>Charleston</surname>
            <given-names>MA</given-names>
          </name>
        </person-group>
        <year>1998</year>
        <article-title>Trees within trees: Phylogeny and historical associations</article-title>
        <source>Trends in Ecology and Evolution</source>
        <volume>13</volume>
        <fpage>356</fpage>
        <lpage>359</lpage>
      </citation>
    </ref>
    <ref id="b22-ebo-01-37">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
          <name>
            <surname>Holmes</surname>
            <given-names>EC</given-names>
          </name>
        </person-group>
        <year>1998</year>
        <source>Molecular Evolution: A Phylogenetic Approach</source>
        <publisher-name>Blackwell Science</publisher-name>
      </citation>
    </ref>
    <ref id="b23-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Piel</surname>
            <given-names>WH</given-names>
          </name>
          <name>
            <surname>Sanderson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Donoghue</surname>
            <given-names>MJ</given-names>
          </name>
        </person-group>
        <year>2003</year>
        <article-title>The small-world dynamics of tree networks and data mining in phyloinformatics</article-title>
        <source>Bioinformatics</source>
        <volume>19</volume>
        <issue>9</issue>
        <fpage>1162</fpage>
        <lpage>1168</lpage>
        <pub-id pub-id-type="pmid">12801879</pub-id>
      </citation>
    </ref>
    <ref id="b24-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sanderson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Donoghue</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Piel</surname>
            <given-names>WH</given-names>
          </name>
          <name>
            <surname>Eriksson</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <year>1994</year>
        <article-title>TreeBASE: A prototype database of phylogenetic analyses and an interactive tool for browsing the phylogeny of life</article-title>
        <source>American Journal of Botany</source>
        <volume>81</volume>
        <issue>6</issue>
        <fpage>183</fpage>
      </citation>
    </ref>
    <ref id="b25-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Shasha</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>JTL</given-names>
          </name>
          <name>
            <surname>Giugno</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <year>2002</year>
        <article-title>Algorithmics and applications of tree and graph searching</article-title>
        <conf-name>Proceedings of the 21st ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems</conf-name>
        <fpage>39</fpage>
        <lpage>52</lpage>
      </citation>
    </ref>
    <ref id="b26-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Steel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Penny</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <year>1993</year>
        <article-title>Distributions of tree comparison metrics—some new results</article-title>
        <source>Systematic Biology</source>
        <volume>42</volume>
        <issue>2</issue>
        <fpage>126</fpage>
        <lpage>141</lpage>
      </citation>
    </ref>
    <ref id="b27-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Steel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Warnow</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <year>1993</year>
        <article-title>Kaikoura tree theorems: Computing the maximum agreement subtree</article-title>
        <source>Information Processing Letters</source>
        <volume>48</volume>
        <fpage>77</fpage>
        <lpage>82</lpage>
      </citation>
    </ref>
    <ref id="b28-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thorley</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
        </person-group>
        <year>2000</year>
        <article-title>RadCon: Phylogenetic tree comparison and consensus</article-title>
        <source>Bioinformatics</source>
        <volume>16</volume>
        <fpage>486</fpage>
        <lpage>487</lpage>
        <pub-id pub-id-type="pmid">10871273</pub-id>
      </citation>
    </ref>
    <ref id="b29-ebo-01-37">
      <citation citation-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>JTL</given-names>
          </name>
          <name>
            <surname>Shan</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Shasha</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Piel</surname>
            <given-names>WH</given-names>
          </name>
        </person-group>
        <year>2003</year>
        <article-title>TreeRank: A similarity measure for nearest neighbor searching in phylogenetic databases</article-title>
        <conf-name>Proceedings of the 15th International Conference on Scientific and Statistical Database Management</conf-name>
        <fpage>171</fpage>
        <lpage>180</lpage>
      </citation>
    </ref>
    <ref id="b30-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>JTL</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Shasha</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <year>2002</year>
        <article-title>Finding approximate patterns in undirected acyclic graphs</article-title>
        <source>Pattern Recognition</source>
        <volume>35</volume>
        <issue>2</issue>
        <fpage>473</fpage>
        <lpage>483</lpage>
      </citation>
    </ref>
    <ref id="b31-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <year>1998</year>
        <article-title>Constructing additive trees when the error is small</article-title>
        <source>Journal of Computational Biology</source>
        <volume>5</volume>
        <issue>1</issue>
        <fpage>127</fpage>
        <lpage>134</lpage>
        <pub-id pub-id-type="pmid">9541876</pub-id>
      </citation>
    </ref>
    <ref id="b32-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <year>2000</year>
        <article-title>A more efficient approximation scheme for tree alignment</article-title>
        <source>SIAM Journal on Computing</source>
        <volume>30</volume>
        <issue>1</issue>
        <fpage>283</fpage>
        <lpage>299</lpage>
      </citation>
    </ref>
    <ref id="b33-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Williams</surname>
            <given-names>WT</given-names>
          </name>
          <name>
            <surname>Clifford</surname>
            <given-names>HT</given-names>
          </name>
        </person-group>
        <year>1971</year>
        <article-title>On the comparison of two classifications on the same set of elements</article-title>
        <source>Taxon</source>
        <volume>20</volume>
        <fpage>519</fpage>
        <lpage>522</lpage>
      </citation>
    </ref>
    <ref id="b34-ebo-01-37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zaretskii</surname>
            <given-names>KA</given-names>
          </name>
        </person-group>
        <year>1965</year>
        <article-title>Constructing trees from the set of distances between pendant vertices</article-title>
        <source>Uspehi Matematicekih Nauk</source>
        <volume>20</volume>
        <fpage>90</fpage>
        <lpage>92</lpage>
      </citation>
    </ref>
  </ref-list>
</back>
<floats-wrap>
  <fig id="f1-ebo-01-37" position="float">
    <label>Figure 1</label>
    <caption>
      <p>illustration of up and down operations between two nodes in a tree.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g001"/>
  </fig>
  <fig id="f2-ebo-01-37" position="float">
    <label>Figure 2</label>
    <caption>
      <p>a tree and its up and down matrices.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g002"/>
  </fig>
  <fig id="f3-ebo-01-37" position="float">
    <label>Figure 3</label>
    <caption>
      <p>example trees.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g003"/>
  </fig>
  <fig id="f4-ebo-01-37" position="float">
    <label>Figure 4</label>
    <caption>
      <p>example showing how the data tree reduction technique works in near neighbour searching.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g004"/>
  </fig>
  <fig id="f5-ebo-01-37" position="float">
    <label>Figure 5</label>
    <caption>
      <p>distribution of PAR metric values.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g005"/>
  </fig>
  <fig id="f6-ebo-01-37" position="float">
    <label>Figure 6</label>
    <caption>
      <p>distribution of MAST metric values.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g006"/>
  </fig>
  <fig id="f7-ebo-01-37" position="float">
    <label>Figure 7</label>
    <caption>
      <p>distribution of NNI metric values.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g007"/>
  </fig>
  <fig id="f8-ebo-01-37" position="float">
    <label>Figure 8</label>
    <caption>
      <p>distribution of QUA metric values.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g008"/>
  </fig>
  <fig id="f9-ebo-01-37" position="float">
    <label>Figure 9</label>
    <caption>
      <p>distribution of <italic>USim</italic> values.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g009"/>
  </fig>
  <fig id="f10-ebo-01-37" position="float">
    <label>Figure 10</label>
    <caption>
      <p>running times on 1,000 synthetic trees for search methods with and without the filter.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g010"/>
  </fig>
  <fig id="f11-ebo-01-37" position="float">
    <label>Figure 11</label>
    <caption>
      <p>running times of the proposed search method on different sizes of databases.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g011"/>
  </fig>
  <fig id="f12-ebo-01-37" position="float">
    <label>Figure 12</label>
    <caption>
      <p>an example query and search results displayed via the Web-based interface of the proposed search engine.</p>
    </caption>
    <graphic xlink:href="EBO-01-37-g012"/>
  </fig>
  <table-wrap id="t1-ebo-01-37" position="float">
    <label>Table 1</label>
    <caption>
      <p>comparison of the five studied tree metrics</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="left" rowspan="1" colspan="1">Metric</th>
          <th align="center" rowspan="1" colspan="1">Weighted trees</th>
          <th align="center" rowspan="1" colspan="1">Internal lables</th>
          <th align="center" rowspan="1" colspan="1">Unresolved trees</th>
          <th align="center" rowspan="1" colspan="1">Different taxa</th>
          <th align="center" rowspan="1" colspan="1"/>
          <th align="center" rowspan="1" colspan="1">Polynomial computable</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" rowspan="1" colspan="1">PAR</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">(<xref ref-type="bibr" rid="b19-ebo-01-37">Page 2005a</xref>)</td>
        </tr>
        <tr>
          <td align="center" rowspan="1" colspan="1">MAST</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">(<xref ref-type="bibr" rid="b27-ebo-01-37">Steel and Warnow 1993</xref>)</td>
        </tr>
        <tr>
          <td align="center" rowspan="1" colspan="1">NNI</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">(DasGupta et al 1995)</td>
        </tr>
        <tr>
          <td align="center" rowspan="1" colspan="1">QUA</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">N</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">(<xref ref-type="bibr" rid="b4-ebo-01-37">Bryant et al 2000</xref>)</td>
        </tr>
        <tr>
          <td align="center" rowspan="1" colspan="1">WSSP</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1">Y</td>
          <td align="center" rowspan="1" colspan="1"/>
        </tr>
      </tbody>
    </table>
  </table-wrap>
</floats-wrap>
