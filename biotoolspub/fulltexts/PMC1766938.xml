<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">1766938</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-7-542</article-id>
    <article-id pub-id-type="pmid">17187677</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-7-542</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>HaploRec: efficient and accurate large-scale reconstruction of haplotypes</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Eronen</surname>
          <given-names>Lauri</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>lauri.eronen@cs.helsinki.fi</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Geerts</surname>
          <given-names>Floris</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>fgeerts@inf.ed.ac.uk</email>
      </contrib>
      <contrib id="A3" contrib-type="author">
        <name>
          <surname>Toivonen</surname>
          <given-names>Hannu</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>hannu.toivonen@cs.helsinki.fi</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>HIIT-BRU, Department of Computer Science, University of Helsinki, Finland</aff>
    <aff id="I2"><label>2</label>Laboratory for Foundations of Computer Science, University of Edinburgh, UK</aff>
    <aff id="I3"><label>3</label>Department of Computer Science, University of Freiburg, Germany</aff>
    <pub-date pub-type="collection">
      <year>2006</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>22</day>
      <month>12</month>
      <year>2006</year>
    </pub-date>
    <volume>7</volume>
    <fpage>542</fpage>
    <lpage>542</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/7/542"/>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>6</month>
        <year>2006</year>
      </date>
      <date date-type="accepted">
        <day>22</day>
        <month>12</month>
        <year>2006</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2006 Eronen et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2006</copyright-year>
      <copyright-holder>Eronen et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Eronen
               Lauri
               
               lauri.eronen@cs.helsinki.fi
            </dc:author><dc:title>
            HaploRec: efficient and accurate large-scale reconstruction of haplotypes
         </dc:title><dc:date>2006</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 7(1): 542-. (2006)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2006)7:1&#x0003c;542&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Haplotypes extracted from human DNA can be used for gene mapping and other analysis of genetic patterns within and across populations. A fundamental problem is, however, that current practical laboratory methods do not give haplotype information. Estimation of phased haplotypes of unrelated individuals given their unphased genotypes is known as the haplotype reconstruction or phasing problem.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We define three novel statistical models and give an efficient algorithm for haplotype reconstruction, jointly called HaploRec. HaploRec is based on exploiting local regularities conserved in haplotypes: it reconstructs haplotypes so that they have maximal local coherence. This approach – not assuming statistical dependence for remotely located markers – has two useful properties: it is well-suited for sparse marker maps, such as those used in gene mapping, and it can actually take advantage of long maps.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>Our experimental results with simulated and real data show that HaploRec is a powerful method for the large scale haplotyping needed in association studies. With sample sizes large enough for gene mapping it appeared to be the best compared to all other tested methods (Phase, fastPhase, PL-EM, Snphap, Gerbil; simulated data), with small samples it was competitive with the best available methods (real data). HaploRec is several orders of magnitude faster than Phase and comparable to the other methods; the running times are roughly linear in the number of subjects and the number of markers. HaploRec is publicly available at <ext-link ext-link-type="uri" xlink:href="http://www.cs.helsinki.fi/group/genetics/haplotyping.html"/>.</p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>The problem we consider is <italic>haplotype reconstruction</italic>: given the genotypes of a sample of individuals, the task is to predict the most likely haplotype pair for each individual. Computational haplotype reconstruction methods are based on statistical dependency between closely located markers, known as <italic>linkage disequilibrium</italic>. Many computational methods have been developed for the reconstruction of haplotypes. Some of these methods do not rely on the statistical modeling of the haplotypes [<xref ref-type="bibr" rid="B1">1</xref>-<xref ref-type="bibr" rid="B3">3</xref>], but most of them, like our proposed algorithm HaploRec, do [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B10">10</xref>]. For a review of these and other haplotyping methods we refer to [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B13">13</xref>]. Laboratory techniques are being developed for direct molecular haplotyping (see, e.g., [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B15">15</xref>]), but these techniques are not mature yet, and are currently time consuming and expensive.</p>
    <p>The need for a new haplotyping method is motivated by high throughput association analysis, where the goal is to locate a disease susceptibility gene by finding a haplotype fragment that is associated with the disease being studied. More and more often gene mapping studies use a large marker map spread over a long genomic region. A typical strategy for computationally haplotyping a long map is to first divide the map to small, overlapping windows, to reconstruct the haplotypes in each window separately, and then to combine haplotypes from the windows [<xref ref-type="bibr" rid="B16">16</xref>]. HaploRec is aimed to have the following important properties. First, increasing the window size should give relatively more accurate results since large windows contain more information, i.e., adding markers should improve accuracy (in the phases between the markers that already were there), whether the new markers are added between the old ones or not [<xref ref-type="bibr" rid="B17">17</xref>]. Second, the time complexity of the algorithm should be close to linear in the number of markers, in order to avoid unnecessary compromises when choosing the window size, and also close to linear in the number of genotypes to allow sample sizes of hundreds to thousands of individuals, as required by association analysis [<xref ref-type="bibr" rid="B18">18</xref>]. HaploRec produces accurate haplotype reconstructions, and scales to long marker maps (or windows) that span long genetic regions.</p>
    <p>While the statistical models of HaploRec are novel, some of the algorithmic principles are similar to earlier work. HaploRec follows a likelihood-based expectation-maximization (EM) haplotype inference strategy which was introduced in [<xref ref-type="bibr" rid="B4">4</xref>]. PL-EM [<xref ref-type="bibr" rid="B5">5</xref>,<xref ref-type="bibr" rid="B6">6</xref>] overcomes the computational complexity of the basic EM approach by using a a pruning strategy on the possible haplotype resolutions, called Partition-Ligation (PL). The Snphap algorithm of Clayton [<xref ref-type="bibr" rid="B19">19</xref>] is also based on the EM algorithm, but uses a sequential pruning strategy; HaploRec also uses a similar pruning approach. The PL strategy is also used in the current version of Phase [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>]. PL-EM and Snphap are based on a multinomial haplotype probability model with a uniform Dirichlet prior. Phase, however, uses a prior distribution based on coalescent theory (see [<xref ref-type="bibr" rid="B20">20</xref>] for a review) and uses Bayesian inference implemented with Gibbs sampling instead of EM. The underlying idea for our statistical models for haplotypes is that we derive an overall probability for a haplotype from the probabilities of its local fragments. We propose three probability models based on this idea: high-order Markov chains, variable-order Markov chains, and a segmentation-based model. Moreover, a novelty is that the lengths of the haplotype fragments utilized in the models vary, governed by a <italic>frequency threshold</italic>. In contrast to most other approaches, long-range dependencies between markers are not required for the methods to work, but they can be utilized where they do exist. Thus all these models scale naturally to the long and sparse marker maps often used in gene mapping.</p>
    <p>Our segmentation-based model bears some resemblance to methods which combine haplotype block finding and haplotyping [<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B10">10</xref>]. However, whereas these models place universal block boundaries across the whole population, our model averages over all possible segmentations for each haplotype, without any fixed block boundaries.</p>
    <p>Quite recently, Scheet and Stephens [<xref ref-type="bibr" rid="B21">21</xref>] introduced fastPhase, which models the population with a set of founder haplotypes (or clusters); the cluster memberships are allowed to change continuously along the chromosome, according to a hidden Markov model. Similar to our models, fastPhase allows for both "block-like" patterns and gradual decline of linkage disequilibrium with distance.</p>
    <p>In our extensive experimental evaluation in the Results section we will compare HaploRec with Phase, fastPhase, PL-EM, Snphap, and Gerbil [<xref ref-type="bibr" rid="B10">10</xref>]. In the simulated settings, where sample sizes (number of subjects) are large enough for gene mapping, we observe the concrete benefits of the ability of HaploRec to improve its performance by haplotyping more markers at a time. The models we describe are relatively simple and are slightly outperformed by Phase when the number of markers is small, but when our method is given a longer map to be haplotyped, it can actually utilize the information contained in the additional markers to outperform Phase. HaploRec is in practice several orders of magnitude faster than Phase and has running times comparable to the other methods.</p>
    <p>We next define the necessary notation.</p>
    <sec>
      <title>Notation and problem statement</title>
      <p>We assume a set (map, or window) <italic>M </italic>of ℓ markers 1,...,ℓ and denote the set of all observed alleles of marker <italic>i </italic>by <italic>A</italic><sub><italic>i</italic></sub>. A <italic>haplotype H </italic>over <italic>M </italic>is then a vector of alleles: <italic>H </italic>∈ Π<sub><italic>i </italic>= 1,...,ℓ </sub><italic>A</italic><sub><italic>i</italic></sub>. A <italic>genotype G </italic>over <italic>M </italic>is a vector of (unordered) allele pairs: <italic>G </italic>∈ Π<sub><italic>i </italic>= 1,...,ℓ</sub>{{<italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>} | <italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2 </sub>∈ <italic>A</italic><sub><italic>i</italic></sub>}. For SNP markers, |<italic>A</italic><sub><italic>i</italic></sub>| = 2. Assuming that alleles are labeled "1" and "2", SNP haplotypes are vectors in {1, 2}<sup>ℓ </sup>and SNP genotypes are vectors in {{1, 1}, {1, 2}, {2, 2}}<sup>ℓ</sup>.  We thus use terms haplotype and genotype to refer to data over the whole marker map, and not e.g. to just one marker.</p>
      <p>The allele of haplotype <italic>H </italic>at marker <italic>i </italic>is denoted by <italic>H</italic>(<italic>i</italic>). Similarly, the unordered allele pair of a genotype <italic>G </italic>at marker <italic>i </italic>is denoted by <italic>G</italic>(<italic>i</italic>). Given a pair of haplotypes {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} and a genotype <italic>G </italic>such that <italic>G</italic>(<italic>i</italic>) = {<italic>H</italic><sub>1</sub>(<italic>i</italic>), <italic>H</italic><sub>2</sub>(<italic>i</italic>)} for all <italic>i</italic>, we say that {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} is <italic>compatible </italic>with <italic>G</italic>, or that {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} is a (possible) <italic>haplotype configuration </italic>for genotype <italic>G</italic>. Two haplotypes determine a unique compatible genotype in the obvious way. A genotype, on the other hand, can have several compatible haplotype configurations. For a genotype <italic>G </italic>with <italic>k heterozygous </italic>markers (i.e., <italic>k </italic>= |{<italic>G</italic>(<italic>i</italic>) = {<italic>a</italic><sub>1</sub>, <italic>a</italic><sub>2</sub>} | <italic>a</italic><sub>1 </sub>≠ <italic>a</italic><sub>2</sub>}|; a marker is <italic>homozygous </italic>if it is not heterozygous), there are 2<sup><italic>k </italic>- 1 </sup>different haplotype configurations. The set of all haplotype configurations for a genotype <italic>G </italic>is denoted by <italic>C</italic><sub><italic>G</italic></sub>, with |<italic>C</italic><sub><italic>G</italic></sub>| = 2<sup><italic>k </italic>- 1</sup>. A single haplotype <italic>H </italic>is said to be compatible with a genotype <italic>G</italic>, if there exists a haplotype H' such that {H, H'} is compatible with <italic>G</italic>. The set of input genotypes is denoted by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-7-542-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFge=raaa@382D@</mml:annotation></mml:semantics></mml:math></inline-formula>. The haplotype reconstruction problem is now defined as finding for each genotype <italic>G </italic>∈ <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-7-542-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFge=raaa@382D@</mml:annotation></mml:semantics></mml:math></inline-formula> the most plausible haplotype configuration {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} ∈ <italic>C</italic><sub><italic>G</italic></sub>. Here, the interpretation of "most plausible" depends on each different haplotyping method; in most methods the most plausible haplotype configuration is the one with the highest estimated probability under the prior assumptions made by the method. In the case that multiple haplotype configurations are equally probable, we simply select one randomly.</p>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <sec>
      <title>Haplotype probability models</title>
      <p>Our focus is on data sets with a large number of relatively sparsely spaced markers. Under these conditions, recombinations between markers are common, and linkage disequilibrium between distant markers is weak. In this case it cannot be expected that complete haplotypes are shared between subjects; instead we aim to discover and utilize local regularities, or <italic>patterns </italic>in the haplotypes. We restrict our attention to a simple class of patterns: a <italic>haplotype fragment </italic>is a haplotype restricted to a (continuous) sub-range of the original marker map. The idea is to model local linkage disequilibrium by estimating the frequencies of haplotype fragments, and to combine those frequencies into a probability model for complete haplotypes. We here very briefly describe three different haplotype probability models based on this idea; full specifications are given in the Methods section. We introduced the ideas for two of them (the Markovian models) in a preliminary conference paper [<xref ref-type="bibr" rid="B22">22</xref>], one (the segmentation model) is completely novel. The actual haplotyping algorithm has also been greatly improved, resulting in significantly more accurate results and reduced running times, while scaling to much larger data sets. An overview of the algorithm is given in the Methods section; a detailed description with pseudo-code and complexity analysis is given in <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>.</p>
      <p>Let <italic>H</italic>(<italic>i</italic>, <italic>j</italic>) denote the sequence, or haplotype fragment, from the <italic>i</italic>th to the <italic>j</italic>th marker in a given haplotype <italic>H</italic>. In the <italic>variable-order Markov model </italic>the conditional probabilities at each marker <italic>i </italic>are estimated from fragments <italic>H</italic>(<italic>s</italic><sub><italic>i</italic></sub>, i - 1) of varying length:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1471-2105-7-542-i2" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mn>...</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mi>ℓ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>s</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>.</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpcqWGqbaucqGGOaakcqWGibascqGGOaakcqaIXaqmcqGGPaqkcqGGPaqkdaqeqbqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdMgaPjabcMcaPiabcYha8jabdIeaijabcIcaOiabdohaZnaaBaaaleaacqWGPbqAaeqaaOGaeiilaWIaemyAaKMaeyOeI0IaeGymaeJaeiykaKIaeiykaKcaleaacqWGPbqAcqGH9aqpcqaIYaGmcqGGSaalcqGGUaGlcqGGUaGlcqGGUaGlcqGGSaalcqWItecBaeqaniabg+GivdGccqGGUaGlcaWLjaGaaCzcamaabmaabaGaeGymaedacaGLOaGaayzkaaaaaa@5A4D@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>The length of the context <italic>H</italic>(<italic>s</italic><sub><italic>i</italic></sub>, <italic>i </italic>- 1), and thus the order of the Markov chain, is individually adjusted for each position and each haplotype by choosing the longest matching context that has a predetermined minimum frequency.</p>
      <p>The <italic>segmentation model </italic>considers each haplotype as a sequence of independent, non-overlapping fragments, and defines the probability of a haplotype to be the product of fragment probabilities. A robust estimate is obtained by averaging over the set <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1471-2105-7-542-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">S</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFse=uaaa@3845@</mml:annotation></mml:semantics></mml:math></inline-formula> of all possible segmentations of <italic>H </italic>into frequent fragments:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1471-2105-7-542-i4" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:msup>
                  <mml:mi>C</mml:mi>
                  <mml:mrow>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:msup>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:mi>S</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mi mathvariant="script">S</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mi>q</mml:mi>
                      <mml:mrow>
                        <mml:mo>|</mml:mo>
                        <mml:mi>S</mml:mi>
                        <mml:mo>|</mml:mo>
                        <mml:mo>−</mml:mo>
                        <mml:mn>1</mml:mn>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>⋅</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>s</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mi>e</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>∈</mml:mo>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>s</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>e</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>,</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>2</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpcqWGdbWqdaahaaWcbeqaaiabgkHiTiabigdaXaaakmaaqafabaGaemyCae3aaWbaaSqabeaacqGG8baFcqWGtbWucqGG8baFcqGHsislcqaIXaqmaaaabaGaem4uamLaeyicI4mcdaGae8NeXpfabeqdcqGHris5aOGaeyyXIC9aaebuaeaacqWGqbaucqGGOaakcqWGibascqGGOaakcqWGZbWCdaWgaaWcbaGaemyAaKgabeaakiabcYcaSiabdwgaLnaaBaaaleaacqWGPbqAaeqaaOGaeiykaKIaeiykaKcaleaacqGGOaakcqWGZbWCdaWgaaadbaGaemyAaKgabeaaliabcYcaSiabdwgaLnaaBaaameaacqWGPbqAaeqaaSGaeiykaKIaeyicI4Saem4uamfabeqdcqGHpis1aOGaeiilaWIaaCzcaiaaxMaadaqadaqaaiabikdaYaGaayjkaiaawMcaaaaa@6D77@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>where <italic>S </italic>is a segmentation of <italic>H </italic>into (non-overlapping) segments (<italic>s</italic><sub><italic>i</italic></sub>, <italic>e</italic><sub><italic>i</italic></sub>), <italic>q </italic>is a parameter for penalizing large numbers of segments, |<italic>S</italic>| is the number of segments in segmentation <italic>S</italic>, and <italic>C </italic>is a normalization factor,</p>
      <p>As a simpler alternative, we also consider <italic>d-order Markov models </italic>with</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1471-2105-7-542-i5" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>d</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mn>...</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mi>ℓ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>d</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>.</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>3</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpcqWGqbaucqGGOaakcqWGibascqGGOaakcqaIXaqmcqGGSaalcqWGKbazcqGGPaqkcqGGPaqkdaqeqbqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdMgaPjabcMcaPiabcYha8jabdIeaijabcIcaOiabdMgaPjabgkHiTiabdsgaKjabcYcaSiabdMgaPjabgkHiTiabigdaXiabcMcaPiabcMcaPaWcbaGaemyAaKMaeyypa0JaemizaqMaey4kaSIaeGymaeJaeiilaWIaeiOla4IaeiOla4IaeiOla4IaeiilaWIaeS4eHWgabeqdcqGHpis1aOGaeiOla4IaaCzcaiaaxMaadaqadaqaaiabiodaZaGaayjkaiaawMcaaaaa@5F4C@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>More details on each of these models are given in the Methods section.</p>
    </sec>
    <sec>
      <title>Experimental setting</title>
      <sec>
        <title>Data simulation</title>
        <p>Our main target application is data sets involving a large number of subjects (hundreds or thousands) and markers (hundreds or thousands per chromosome), because these are needed for association-based gene mapping [<xref ref-type="bibr" rid="B18">18</xref>]. Such data is not yet publicly available for benchmarking, and thus our experiments are based mainly on simulated data. Real data from the HapMap project [<xref ref-type="bibr" rid="B23">23</xref>] is used to validate the general observations from simulations, and to test the method in slightly different settings, especially with small sample sizes.</p>
        <p>We used Hudson's coalescence simulator [<xref ref-type="bibr" rid="B24">24</xref>] to simulate data sets of 1000 genotypes. Our simulated settings range from 5 to 500 markers, with average marker spacings between 6.6 and 166 kb and map lengths between 166 kb and 16.6 Mb. These marker distances correspond to genome-wide studies with 500 k to 20 k markers; the average linkage disequilibrium between neighboring markers, measured with Lewontins |<italic>D'</italic>| measure, ranges respectively from 0.88 to 0.36 (Table <xref ref-type="table" rid="T1">1</xref>). More details on the data simulation procedure are given in the Methods section.</p>
        <table-wrap position="float" id="T1">
          <label>Table 1</label>
          <caption>
            <p>Correspondence between marker spacing and linkage disequilibrium.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <td align="left">Marker spacing (kb)</td>
                <td align="center">|<italic>D'</italic>|</td>
                <td align="center">number of markers</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">6.6 kb</td>
                <td align="center">0.88</td>
                <td align="center">500 k</td>
              </tr>
              <tr>
                <td align="left">20 kb</td>
                <td align="center">0.73</td>
                <td align="center">166 k</td>
              </tr>
              <tr>
                <td align="left">33 kb</td>
                <td align="center">0.64</td>
                <td align="center">100 k</td>
              </tr>
              <tr>
                <td align="left">100 kb</td>
                <td align="center">0.45</td>
                <td align="center">33 k</td>
              </tr>
              <tr>
                <td align="left">166 kb</td>
                <td align="center">0.36</td>
                <td align="center">20 k</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Average marker distance, average linkage disequilibrium (|D'|) between adjacent markers, and the corresponding number of markers in a genome-wide study; simulated data.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>All experiments are run separately for 10 independently simulated data sets, and we report average results over them. Results from the different replicates are quite similar: while there is some variance in the accuracy between the different replicas, the relative performances of different methods are extremely similar. (See <xref ref-type="supplementary-material" rid="S2">Additional file 2</xref> for example results from all 10 replicas.) Unless otherwise stated, 100 markers were used in the experiments with HaploRec alone, and 30 markers in comparisons to other methods, in order to keep running times of some of the other methods reasonable.</p>
      </sec>
      <sec>
        <title>Performance measure</title>
        <p>As an accuracy measure, we primarily use relative switch accuracy, which is defined as the fraction of neighboring phases (between each pair of consecutive heterozygous markers) reconstructed correctly. An alternative measure would be absolute accuracy, which is the fraction of haplotype pairs reconstructed completely correctly (ignoring missing alleles). Absolute accuracy is problematic with long or sparse haplotypes, where some switch errors can be inevitable. It gives little information about the quality of a haplotype, except whether it is exactly correct or not; the switch measure is much more informative in this respect. Chromosome-wide studies search for relatively short disease-associated haplotype fragments, and switch accuracy is almost directly related to the number of fragments correctly reconstructed. However, we also give some examples of absolute errors since they are widely used in the field (for short haplotypes).</p>
      </sec>
    </sec>
    <sec>
      <title>Experimental results</title>
      <sec>
        <title>Performance across different amounts of linkage disequilibrium</title>
        <p>The three proposed haplotype probability models, Markov chain of variable order (VMM), the segmentation model (S), and as simpler baseline the Markov chain of fixed order (FMM), lead to different variants of HaploRec, subsequently abbreviated as HaploRec-VMM, HaploRec-S, and HaploRec-FMM. The most important parameter of HaploRec is the one that indirectly specifies the size of the data structure used by the model (subsequently called <italic>model complexity parameter</italic>). For the variable-order Markov model and the segmentation model this parameter is the fragment frequency threshold, with the fixed-order Markov model, it is the order of the Markov model (for details, see the Methods section).</p>
        <p>The optimal value of the model complexity parameter depends on the amount of linkage disequilibrium, so a fixed value does not give comparable results across different marker spacings. In the first experiment, we compare the proposed models to each other, by testing each model for a large range of different values (minimum frequency 1–15 for the variable-order Markov and segmentation models, order 1–17 for the fixed-order Markov model). The optimal value was then chosen for each marker spacing separately. In the experiment, the accuracy of the models under different amounts of linkage disequilibrium was tested using 100 markers with average spacing between 6.6 and 166 kb (Figure <xref ref-type="fig" rid="F1">1</xref>)</p>
        <fig position="float" id="F1">
          <label>Figure 1</label>
          <caption>
            <p><bold>Comparison of FMM, VMM and segmentation models</bold>. Switch accuracy on the left, absolute accuracy on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-1"/>
        </fig>
        <p>The segmentation model performs here best, variable-order Markov model is slightly less accurate, and the fixed-order model is clearly inferior. This and other experiments (not shown) show that the more complex models are good alternatives over the simple Markov model. For clarity of exposition, the fixed-order Markov model is excluded from the rest of the results as markedly inferior. We also considered a variant of the segmentation model where the maximum over different segmentations was used, instead of averaging over different segmentations. This alternative was slightly but consistently outperformed by the averaging model (results not shown).</p>
      </sec>
      <sec>
        <title>Default values for model complexity parameters</title>
        <p>To make later comparisons to other methods fair, we must fix the minimum frequency parameter to a fixed default value for each of the models. Consider now the accuracies and model sizes (number of stored haplotype fragments) as functions of the minimum frequency threshold, for three different marker spacings: 33, 100 and 166 kb (Figure <xref ref-type="fig" rid="F2">2</xref>). With the segmentation model, decreasing the threshold always improves results. A threshold of 1.2 was chosen for the subsequent experiments as a compromise between efficiency and accuracy (note that the frequency threshold does not need to be an integer, as frequencies of fragments are estimated from reconstructed haplotypes which may have non-integer probabilities; see Methods for more details). With the variable-order Markov model the optimal choice seems to depend more on the amount of linkage disequilibrium. For the Markov model, a threshold of 2 was chosen for the rest of the experiments.</p>
        <fig position="float" id="F2">
          <label>Figure 2</label>
          <caption>
            <p><bold>Effect of minimum frequency on the VMM and segmentation models</bold>. Switch accuracy on the left, model size on the right. (We use red color throughout this paper for HaploRec; solid line for the segmentation model and dashed line for the variable order model.)</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-2"/>
        </fig>
      </sec>
      <sec>
        <title>Comparison of HaploRec with fastPhase, Gerbil, Phase, PL-EM, and Snphap</title>
        <p>For the rest of this section we study how HaploRec performs in comparison to existing statistical haplotyping methods. Five publicly available haplotyping programs were chosen for benchmarking: fastPhase [<xref ref-type="bibr" rid="B21">21</xref>] (version 1.1.3), Gerbil [<xref ref-type="bibr" rid="B10">10</xref>] (version 1.0), Phase [<xref ref-type="bibr" rid="B7">7</xref>,<xref ref-type="bibr" rid="B8">8</xref>] (version 2.0), PL-EM [<xref ref-type="bibr" rid="B6">6</xref>] (version 1.5, kindly provided by Zhaohui S. Qin) and Snphap [<xref ref-type="bibr" rid="B19">19</xref>] (version 1.3.1). The current version of HaploRec, 2.1, was used in the experiments. FastPhase, Gerbil and Snphap were run with their default parameter values. For PL-EM, buffer size was set to 300, number of iterations to 20, and parsize to 2. For Phase, the number of iterations and burn-in iterations were both set to 100, the thinning interval was set to 1, and the recombination model introduced in version 2.0 was used. All experiments were run on PCs with a 2.8 GHz Pentium 4 processor and 1 GB of memory. All methods were tested on a range of data sets containing 5 to 100 markers with 33 kb spacing (Figure <xref ref-type="fig" rid="F3">3</xref>; Table <xref ref-type="table" rid="T2">2</xref>). HaploRec-S reaches the best accuracy, 99.0% (with windows of 100 markers), closely followed by Phase (98.1% accuracy with windows of 30 markers) and HaploRec-VMM (98.0% accuracy with windows of 100 markers); the HaploRec variants are several orders of magnitude faster. PL-EM, Snphap, and Gerbil are clearly less accurate but faster; fastPhase is both less accurate and slower than HaploRec. Phase aborted because of running out of memory (1 GB) when there were more than 40 markers.</p>
        <fig position="float" id="F3">
          <label>Figure 3</label>
          <caption>
            <p><bold>Comparison of methods, variable number of markers</bold>. Switch accuracy on the left, running times (plotted with logarithmic scale) on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-3"/>
        </fig>
        <table-wrap position="float" id="T2">
          <label>Table 2</label>
          <caption>
            <p>Comparison of methods on simulated data sets with 33 kb marker spacing.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <td align="left">Method</td>
                <td align="center">Switch accuracy</td>
                <td align="center">No. of markers</td>
                <td align="center">Time per marker (sec.)</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">HaploRec-S</td>
                <td align="center">0.990</td>
                <td align="center">100</td>
                <td align="center">19.2</td>
              </tr>
              <tr>
                <td align="left">HaploRec-VMM</td>
                <td align="center">0.980</td>
                <td align="center">100</td>
                <td align="center">5.2</td>
              </tr>
              <tr>
                <td align="left">(HaploRec-S)</td>
                <td align="center">(0.969)</td>
                <td align="center">(30)</td>
                <td align="center">(6.6)</td>
              </tr>
              <tr>
                <td align="left">(HaploRec-VMM)</td>
                <td align="center">(0.970)</td>
                <td align="center">(30)</td>
                <td align="center">(2.5)</td>
              </tr>
              <tr>
                <td align="left">Phase</td>
                <td align="center">0.981</td>
                <td align="center">30</td>
                <td align="center">1585</td>
              </tr>
              <tr>
                <td align="left">fastPhase</td>
                <td align="center">0.858</td>
                <td align="center">20</td>
                <td align="center">61.3</td>
              </tr>
              <tr>
                <td align="left">PL-EM</td>
                <td align="center">0.938</td>
                <td align="center">30</td>
                <td align="center">0.9</td>
              </tr>
              <tr>
                <td align="left">Snphap</td>
                <td align="center">0.921</td>
                <td align="center">30</td>
                <td align="center">0.4</td>
              </tr>
              <tr>
                <td align="left">Gerbil</td>
                <td align="center">0.745</td>
                <td align="center">5</td>
                <td align="center">2.6</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>For each method, the table gives the accuracy, the number of markers to be haplotyped at a time to achieve that accuracy, and the running time per marker. As 30 marker windows are optimal for many methods, results for them are given in parenthesis also for the HaploRec variants.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>An observation from this experiment is that the number of markers can have a significant effect on haplotyping accuracy. With the smallest tested numbers of markers, 5 and 10, all the methods achieve only a mediocre accuracy. When the number of markers is increased to 20 or 30, the accuracies of all methods except Gerbil improve clearly. The accuracy of both HaploRec variants increases monotonically with the number of markers. None of the other methods show this property. Phase's accuracy decreases slightly after 30 markers (and it was not able to handle more than 40 markers). Snphap and PL-EM gain less from the increase in the number of markers, and also start to actually lose accuracy when the number of markers increases over 30. FastPhase only gains little and levels after 20 markers.</p>
        <p>Snphap, the HaploRec variants, and Gerbil are relatively close to having linear running times in the number of markers (i.e., close to a horizontal line on the scale where <italic>y</italic>-axis gives the time per marker; Figure <xref ref-type="fig" rid="F3">3</xref>, right panel). Snphap is 1–2 orders of magnitude faster than PL-EM, HaploRec and Gerbil; they are an order of magnitude faster than fastPhase, which in turn is 0–2 orders of magnitude faster than Phase. For clarity of exposition and fairness of comparison, we use 30 marker windows in the rest of the experiments for all methods. Based on the results above, it is about an optimal choice for Phase, fastPhase, PL-EM, and Snphap, slightly suboptimal for HaploRec, and unfortunately bad for Gerbil. In particular, note that if a larger window size was chosen for HaploRec, HaploRec-S could in many cases have given more accurate results than Phase (cf. Table <xref ref-type="table" rid="T2">2</xref>).</p>
      </sec>
      <sec>
        <title>Effect of marker density</title>
        <p>We next evaluated the performance of the methods as a function of the amount of linkage disequilibrium, resulting from varying marker spacing between 6.6 and 166 kb (Figure <xref ref-type="fig" rid="F4">4</xref>, cf. Table <xref ref-type="table" rid="T1">1</xref>). The accuracy of all methods decreases with increasing marker spacing, as expected. Phase and the two HaploRec variants are clearly more resistant to decreasing linkage disequilibrium than the other methods. FastPhase and Gerbil have a drop in accuracy at first, but then come close to PL-EM and Snphap with the sparsest maps. Marker spacing also has a clear effect on running times for some of the methods (not shown): for Phase, PL-EM and Gerbil, the difference of running times between the densest (6.6 kb) and sparsest (133 kb) settings is approximately 40-fold. For HaploRec and Snphap, running times only vary by a factor of 1.5 – 3 (in the case of HaploRec, this is explained by the increased number of iterations needed for convergence), while fastPhase's running times are practically same for all spacings.</p>
        <fig position="float" id="F4">
          <label>Figure 4</label>
          <caption>
            <p><bold>Comparison of methods, variable marker density</bold>. Switch accuracy on the left, absolute accuracy on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-4"/>
        </fig>
      </sec>
      <sec>
        <title>Effect of sample size</title>
        <p>The available sample size obviously has an effect on the difficulty of the task. Most of the evaluations of haplotyping methods in the literature have been made on very small data sets, and thus it can be interesting to see how sample size effects different methods. Tests with sample sizes between 25 and 1000 individuals clearly show that all methods perform better with larger sample sizes, but there are marked differences between methods (Figure <xref ref-type="fig" rid="F5">5</xref>; 30 markers with 33 kb spacing). Phase, HaploRec, PL-EM and Snphap are able to benefit from larger sample sizes. FastPhase and Gerbil gain much less from larger samples: while they perform approximately equally to HaploRec with very small sample sizes, HaploRec is more accurate by a large margin with larger sample sizes. Also, Phase seems to work relatively well also with the smallest sample sizes.</p>
        <fig position="float" id="F5">
          <label>Figure 5</label>
          <caption>
            <p><bold>Effect of sample size</bold>. Switch accuracy on the left, running times (on a logarithmic scale) on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-5"/>
        </fig>
        <p>For most methods, the running times are relatively close to linear in the number of genotypes, but Phase's running times increase somewhat more rapidly. We performed some additional experiments with fastPhase, trying out different parameter values (not shown). In particular, increasing the maximum number of clusters from the default value of 15 to 20 or 30 improved the accuracy at the cost of longer running times, but the accuracies did not reach those of HaploRec.</p>
      </sec>
      <sec>
        <title>Effect of missing alleles and genotyping errors</title>
        <p>Two sets of experiments were performed to see how up to 5% missing alleles or up to 5% genotyping errors affect the accuracy. According to our experience, such numbers are typical for current high-quality genotypes. The number of markers was again fixed to 30 and marker spacing was 33 kb (Figure <xref ref-type="fig" rid="F6">6</xref>). Phase failed to complete when the error fraction was more than 2%, due to increased memory usage resulting from the increased haplotype diversity. Also, the running time of Phase increased rapidly with increasing error fraction; already with 2%, Phase ran for approximately 4 days for a single replica. For this reason, results for Phase are not shown in the error fraction figure. Overall, missing alleles have only a slightly negative effect on accuracy of all tested methods. HaploRec-S seems to be slightly more sensitive to missing data than the other methods. Genotyping errors, on the other hand, have a more clear effect on accuracy. HaploRec-VMM, PL-EM and Snphap experience a clear drop in accuracy, whereas HaploRec-S, fastPhase and Gerbil are more robust against genotyping errors. In this setting, the results start to be unacceptable between about 1% (Snphap, PL-EM, fastPhase) and 2% (HaploRec) of errors.</p>
        <fig position="float" id="F6">
          <label>Figure 6</label>
          <caption>
            <p>Effect of missing alleles (left) and genotyping errors (right).</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-6"/>
        </fig>
      </sec>
      <sec>
        <title>Tests with larger data sets</title>
        <p>The applicability of the methods for larger amounts of markers and longer genomic regions was tested by varying the number of markers from 10 to 500 (with the map growing at the same time from 330 kb to 16.5 Mb, with a fixed marker spacing of 33 kb; Figure <xref ref-type="fig" rid="F7">7</xref>). When the length of haplotype fragments was not limited, HaploRec reaches the 1 GB memory limit at about 150 markers. To work with a larger number of markers, HaploRec was also run with the maximum fragment length set to 30, which significantly reduced memory usage, enabling it to handle all tested window sizes. Also some of the other methods had a practical maximum number of markers they could handle on these data sets; 200 for PL-EM and 300 for Gerbil. Phase was excluded from this experiment, as it was already observed that it was unable to handle data sets with more than 40 markers.</p>
        <fig position="float" id="F7">
          <label>Figure 7</label>
          <caption>
            <p><bold>Accuracies and running times for large data sets</bold>. Switch accuracy on the left, running times on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-7"/>
        </fig>
        <p>HaploRec-S without the maximum pattern length constraint has the best accuracy, but its high memory usage makes it unusable for the larger window sizes. On the other hand, the segmentation model does not work quite as well with the pattern length constraint. HaploRec-VMM has a fairly good accuracy, and is almost unaffected by the pattern length constraint (the lines for the two variants are indistinguishable in the figure), making it practical for large data sets. Its accuracy stays approximately constant with 100 markers or more. FastPhase and PL-EM maintain a lower but constant accuracy. Gerbil works up to 300 markers and maintains its (low) level of accuracy. While Snphap quickly loses accuracy with an increasing number of markers, it is very fast (its running times per marker are below a second). The running times of the HaploRec variants and PL-EM are slightly superlinear (i.e., approaching a horizontal line; note that the <italic>y</italic>-axis shows the time per marker) and Gerbil clearly superlinear.</p>
      </sec>
      <sec>
        <title>Experimental results with real data</title>
        <p>To complement the systematic experimental analysis with several replicates of simulated data and reasonably sized samples, the methods were also tested on publicly available real data from the HapMap project [<xref ref-type="bibr" rid="B23">23</xref>].</p>
        <p>The HapMap data we used consists of two separate populations: 30 trios from the Yoruba population in Ibadan, Nigeria, and another 30 trios from the CEPH population (Utah residents with ancestry from northern and western Europe). Both data sets (downloaded from the HapMap web site [<xref ref-type="bibr" rid="B25">25</xref>]) have the same set of 3.8 million SNPs spread over the whole genome. (For information on how HapMap data was processed for the experiments, see the Methods section.)</p>
        <p>In the following experiments with this data, HaploRec was run with the same parameter values as before, chosen based on the first experiments with large samples of simulated data (Figures <xref ref-type="fig" rid="F1">1</xref> and <xref ref-type="fig" rid="F2">2</xref>).</p>
        <p>In the first experiment, the marker spacing was fixed to 6 kb (which corresponds roughly to a genome-wide study with 500 k markers). The number of markers was varied from 10 to 100 to test the relationship between the number of markers and haplotyping accuracy (Figure <xref ref-type="fig" rid="F8">8</xref>, Yoruba data on the left, CEPH data on the right).</p>
        <fig position="float" id="F8">
          <label>Figure 8</label>
          <caption>
            <p><bold>Accuracies on HapMap data, variable number of markers</bold>. Marker spacing 6.0 kb. Yoruba on the left, CEPH on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-8"/>
        </fig>
        <p>The younger CEPH population is clearly easier than the Yoruba population for all haplotyping methods. However, for both data sets, even the best methods only achieve a relatively low accuracy, which can probably be attributed to the small sample size. For the Yoruba data, Phase performs best across the range of tests, followed by the HaploRec variants and fastPhase, which are followed by Gerbil, PL-EM and Snphap. For the CEPH data, the differences between the best methods (Phase, HaploRec-S and fastPhase) are very small.</p>
        <p>The above results show that HaploRec is competitive also on real data sets having a small sample size. On the other hand, the number of marker has a smaller effect on accuracy than in the simulated data sets. Also, increasing the number of markers to more than 40 does not improve accuracy here, unlike in the experiments with simulated data sets, where accuracy always improves with increasing number of markers. We believe the reason for this is the small sample size (60 genotypes vs. 1000 genotypes in the simulated data). In a larger sample, longer shared ancestral haplotype fragments (which are rarer than shorter ones) can be detected and utilized, leading to increased accuracy. To test this hypothesis, we ran HaploRec on (sparse) simulated data sets consisting of various numbers of genotypes and evaluated the effect of the number of markers (data not shown). The same effect was visible there as well: the improvement in accuracy gained by using more markers decreases with decreasing sample size.</p>
        <p>In a second experiment with the HapMap data, we varied marker spacing between 1.5 and 15 kb, while the number of markers was fixed to 30 (Figure <xref ref-type="fig" rid="F9">9</xref>, Yoruba data on the left, CEPH data on the right). The accuracy drops with increasing marker spacing, as expected, but the methods roughly maintain their relative performances, in the order Phase, HaploRec-S, fastPhase, HaploRec-VMM, Gerbil, PL-EM and Snphap. Again, for the CEPH data, the best three methods have practically identical accuracies.</p>
        <fig position="float" id="F9">
          <label>Figure 9</label>
          <caption>
            <p><bold>Accuracies on HapMap data, variable marker spacing</bold>. 30 markers. Yoruba on the left, CEPH on the right.</p>
          </caption>
          <graphic xlink:href="1471-2105-7-542-9"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Discussion</title>
    <p>The HaploRec models and algorithm introduced in this paper are designed for haplotyping data sets in large-scale disease association studies. The statistical models are relatively simple. Their central idea is to represent the probability of a long haplotype as a function of the probabilities of its local fragments. Our experimental results confirm that locality and simplicity were successful design choices: locality allows the models to actually benefit from large numbers of markers even when they are sparsely located, while simplicity allows an efficient implementation. In combination these properties result in a method that accurately and quickly haplotypes large windows of markers at a time.</p>
    <p>We presented three different haplotype probability models: Markov chain of a fixed order, Markov chain of a variable order (HaploRec-VMM), and a model based on segmenting each haplotype in frequent fragments (HaploRec-S). Our experimental results show that the simple fixed-order Markov chain is clearly inferior, even if its order is chosen optimally for the data set. In our results for the more flexible and "self-adjusting" variable-order and segmentation models, the segmentation model gave generally more accurate results than the variable-order Markov model both in the simulated and real data sets, with the downside of being somewhat slower. Our experiments also indicated another interesting difference between the models: while the segmentation model is more sensitive to missing data than the variable-order Markov model, it is more robust against genotyping errors.</p>
    <p>In experimental comparisons with existing haplotyping methods, the HaploRec models scale in a unique way to large data sets: Their accuracies improve both in the number of markers (Figure <xref ref-type="fig" rid="F3">3</xref>) and in the sample size (Figure <xref ref-type="fig" rid="F5">5</xref>) in an unparalleled way (Phase being an exception in some aspects), while being robust to sparse marker maps (Figure <xref ref-type="fig" rid="F4">4</xref>). This combination of properties makes HaploRec especially suitable for chromosome or genome-wide association analysis, where large numbers of sparsely located markers are analyzed for hundreds or thousands of individuals. In such settings, HaploRec can outperform Phase in accuracy while being 2–3 orders of magnitude faster. Although Phase is very accurate and can also benefit from large samples, it is computationally very intensive, restricting its usability for large data sets. The recently proposed fastPhase method scales well but for large data sets, it seems to be clearly less accurate and also clearly slower than HaploRec.</p>
    <p>The performance differences can be largely understood from the properties of the different models. Snphap and PL-EM are based on a multinomial model, which is suitable when all markers are in strong linkage disequilibrium, but does not work well when the number of markers is large or the markers are spaced far apart. Gerbil solves this problem by dividing the marker map into blocks and modeling each block by a set of common "founder" haplotypes. This approach assumes strong linkage disequilibrium within each block, and does not account for more flexible patterns of linkage disequilibrium across block boundaries. Gerbil's relatively bad performance on simulated data can probably be attributed to two factors. Firstly, it only considers a small number of common haplotypes for each block, and thus cannot utilize the rarer shared haplotypes found in large samples. Secondly, there are no recombination hot-spots in the simulated data. In fastPhase, each haplotype is a mosaic of founder haplotypes. This allows for both block-like patterns of linkage disequilibrium and gradual decay of linkage disequilibrium with distance. However, it does not account for the fact that shared haplotypes are formed also in the later stages of the population history, forming more recent (and less frequent) patterns of linkage disequilibrium. The segmentation model of HaploRec bears some resemblance to the model used in fastPhase: each haplotype is a mosaic of frequent haplotype fragments, which may now be ancestral haplotype fragments from different stages of the population history. As old haplotypes are split by recombinations and new haplotypes are formed during the population history, longer shared fragments probably are of more recent origin and have a smaller frequency than shorter ones. HaploRec is not constrained to a fixed set of founders, but can more flexibly utilize (local) patterns of linkage disequilibrium present in the data using fragments of varying lengths. Being able to utilize the information contained in rare shared fragments is one possible explanation for the good performance of HaploRec on large samples. Phase works consistently well across most settings. Also its model accounts for recombinations, which explains why it performs well also on sparser marker maps. Its good accuracy especially on small samples is probably due to its more realistic prior compared to other methods, which becomes less important with increasing sample size. The accurate model employed by Phase has the downside of being computationally very intensive. As a result, the window size (number markers) it can handle is very limited, especially when the sample size is large. In the experiments with variable window size, we also observed that Phase's accuracy decreases when increasing the number of markers above 30; this may be because its default number of iterations is not sufficient to obtain mixing for larger window sizes.</p>
    <p>Results with data from the HapMap project demonstrate that HaploRec works well also with real data (Figures <xref ref-type="fig" rid="F8">8</xref> and <xref ref-type="fig" rid="F9">9</xref>). Unlike the assumed primary applications of HaploRec, these samples are very small (only 60 genotypes). Still, HaploRec is very competitive, even with its default parameter values chosen based on the simulated, larger data sets with sparser marker spacing. Experiments with the dense Daly data [<xref ref-type="bibr" rid="B26">26</xref>] (results not shown) indicate the same: among the tested methods, HaploRec was second only to Phase and fastPhase while being fastest of all methods. Future experiments with large real data sets, as they become publicly available, will be used to test the hypothesis that HaploRec will benefit more than the competing methods from larger sample sizes and from more markers.</p>
    <p>For evaluating performance on reasonably large samples (1000 individuals), we used simulated data due to the lack of suitable public real data sets. Another option would have been to use pseudo-simulated data, by randomly combining pairs of real haplotypes to form new pseudo-individuals (as done, e.g., in [<xref ref-type="bibr" rid="B10">10</xref>]). For the genetically long marker maps of association studies, this method would generate unrealistic data: multiple copies of complete haplotypes will appear in the final sample, when in reality the haplotypes would mostly have been segmented by recombinations. Such data would be unrealistically easy to haplotype, and already a simple multinomial model can give almost completely correct solutions.</p>
    <p>Most haplotype-based association analysis methods assume haplotypes as input. There are several major fundamental issues related to this. The first questions the need to haplotype longer windows of markers maps at all, since gene mapping studies search for disease associations of relatively short genetic regions and for this it is sufficient to haplotype such a shorter segment at a time. The computational complexity can on one hand decrease – especially for methods that are not close to linear in the number of markers, such as Phase – but on the other hand there is an additional cost of redundantly haplotyping overlapping segments. Additionally, haplotyping accuracy improves with window size (cf. Figures <xref ref-type="fig" rid="F3">3</xref> and <xref ref-type="fig" rid="F8">8</xref>), indicating that too short windows should be avoided.</p>
    <p>The second issue relates to the use of estimated haplotypes in association analysis. It seems obvious that haplotype reconstruction tends to exaggerate linkage disequilibrium since haplotyping methods more or less directly aim to maximize it. It has been shown that estimated haplotypes can, indeed, lead to false positives [<xref ref-type="bibr" rid="B27">27</xref>,<xref ref-type="bibr" rid="B28">28</xref>]. On the other hand, this does not always have to be the case. A simulation study shows that in association analysis, the haplotypes produced by HaploRec can be equally powerful to the true haplotypes, despite some inevitable phasing errors [<xref ref-type="bibr" rid="B29">29</xref>]. The locality of the statistical models has a subtle role here: in the case-control settings normally used in association studies, linkage disequilibrium is increased in the cases in the vicinity of the disease gene, making this most critical part of the marker map easier to haplotype. More work is needed to identify when statistically predicted haplotypes are useful and when not.</p>
    <p>Another view to this issue is that some information is lost. As an extreme example, there may be several roughly equally likely haplotype configurations of which just one is chosen to the output. Since association analysis methods are typically based on frequencies of haplotypes (or fragments), the frequencies of different possible haplotypes – rather than the single most likely ones – should be more informative and fairly easily usable for many association methods. Most statistical haplotyping methods internally estimate haplotype frequencies; haplotype resolution can be seen as an extra step based on these frequencies. This also holds for HaploRec which actually already estimates frequencies of all haplotype fragments that have (an estimated) frequency above a small threshold. Ultimately, haplotype frequency estimation and association analysis could be combined into one model and process [<xref ref-type="bibr" rid="B27">27</xref>].</p>
    <p>There are several possible directions for future work on improving the haplotype probability models. Currently, the variable-order Markov model only uses a simple frequency threshold to determine the context lengths. The set of contexts could be pruned further using the accuracy of predicting the next allele as a selection criterion [<xref ref-type="bibr" rid="B30">30</xref>]. Another possibility for refinement is to smooth the probability over several context lengths simultaneously [<xref ref-type="bibr" rid="B31">31</xref>]. Ideas from the models of Phase and Gerbil could be used to better account for mutations and genotyping errors. A possible approach would be to allow for a small number of mismatches between the haplotype fragments and complete haplotypes in the parameter estimation step, dividing some of the probability mass to fragments that are similar, but not identical with the observed ones.</p>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>Genotyping hundreds or even thousands of subjects for hundreds of thousands of markers is becoming technologically and economically feasible. It is estimated that data sets of this size start to be sufficiently powerful for genome-wide disease association studies, depending on the disease and the population [<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B32">32</xref>]. However, many methods for association-based gene mapping assume haplotype data. It has been shown, too, that haplotypes can be more powerful than single markers [<xref ref-type="bibr" rid="B33">33</xref>].</p>
    <p>We presented models and methods for statistical haplotype reconstruction from genotypes of unrelated individuals, and specifically targeted large and sparse data sets, such as those needed in chromosome or genome-wide disease association studies. We introduced three different haplotype probability models: Markov chain of a fixed order, Markov chain of a variable order, and a model based on segmenting each haplotype into frequent fragments. In Methods we give full specifications of the models and an concise description of the HaploRec algorithm; <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref> contains a more detailed description of the algorithm and complexity analysis.</p>
    <p>Experiments with simulated and real data demonstrate that these models and methods, collectively called HaploRec, are competitive with existing methods in terms of accuracy while being several orders of magnitude faster than the most accurate competitors. Of the two HaploRec models, the segmentation model is recommended as the default choice, as it generally gives more accurate results. However, for very large data sets, or when there is much missing data, the variable-order Markov model may be a better alternative, due to its smaller computational demands and smaller sensitivity to missing data.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Haplotype probability models</title>
      <p>Recall that <italic>H</italic>(<italic>i</italic>, <italic>j</italic>) denotes the sequence (haplotype fragment) from the <italic>i</italic>th to the <italic>j</italic>th marker in a given haplotype <italic>H</italic>. We use the alternative notation <italic>frag</italic>(<italic>h</italic>, <italic>i</italic>, <italic>j</italic>) to denote a haplotype fragment from <italic>i </italic>to <italic>j</italic>, consisting of marker string <italic>h</italic>, when the fragment is not a projection from any particular haplotype <italic>H</italic>. We will denote <italic>H</italic>(<italic>i</italic>, <italic>i</italic>), a fragment consisting of a single marker, simply by <italic>H</italic>(<italic>i</italic>). Similarly, <italic>G</italic>(<italic>i</italic>, <italic>j</italic>) denotes the sequence of allele pairs from the <italic>i</italic>th to the <italic>j</italic>th marker in genotype <italic>G</italic>, called <italic>genotype fragment</italic>. Again, <italic>G</italic>(<italic>i</italic>, <italic>i</italic>) is denoted by <italic>G</italic>(<italic>i</italic>). We say that a fragment <italic>H</italic>(<italic>i</italic>, <italic>j</italic>) and a haplotype <italic>H' match </italic>if <italic>H</italic>(<italic>k</italic>) = <italic>H'</italic>(<italic>k</italic>) for all <italic>k </italic>: <italic>i </italic>≤ <italic>k </italic>≤ <italic>j</italic>. We say that a fragment <italic>H</italic>(<italic>i</italic>, <italic>j</italic>) and a genotype <italic>G match </italic>if there exists a string <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7" name="1471-2105-7-542-i6" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacuWGibasgaqeaaaa@2DDD@</mml:annotation></mml:semantics></mml:math></inline-formula> ∈ Π<sub><italic>k </italic>= <italic>i</italic>,...,<italic>j </italic></sub><italic>A</italic><sub><italic>k </italic></sub>such that {<italic>H</italic>(<italic>i</italic>, <italic>j</italic>), <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8" name="1471-2105-7-542-i6" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacuWGibasgaqeaaaa@2DDD@</mml:annotation></mml:semantics></mml:math></inline-formula>} is compatible with <italic>G</italic>(<italic>i</italic>, <italic>j</italic>). Given a set of haplotypes, the frequency of a fragment <italic>H</italic>(<italic>i</italic>, <italic>j</italic>) is defined as the number of haplotypes matching the fragment, and is denoted by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>(<italic>H</italic>(<italic>i</italic>, <italic>j</italic>)).</p>
      <p>A simple model for haplotype probability is to consider the haplotype as a (first-order) Markov chain in which the probability for a marker having a certain allele depends only on the preceding marker:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10" name="1471-2105-7-542-i8" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mn>...</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mi>ℓ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>.</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>4</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpcqWGqbaucqGGOaakcqWGibascqGGOaakcqaIXaqmcqGGPaqkcqGGPaqkdaqeqbqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdMgaPjabcMcaPiabcYha8jabdIeaijabcIcaOiabdMgaPjabgkHiTiabigdaXiabcMcaPiabcMcaPaWcbaGaemyAaKMaeyypa0JaeGOmaiJaeiilaWIaeiOla4IaeiOla4IaeiOla4IaeiilaWIaeS4eHWgabeqdcqGHpis1aOGaeiOla4IaaCzcaiaaxMaadaqadaqaaiabisda0aGaayjkaiaawMcaaaaa@5673@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>The obvious shortcoming of this model is that although linkage disequilibrium is normally strongest between neighbors, it is not limited to the immediate neighboring markers; a neighborhood of several markers is thus potentially more informative. More power in predicting the next allele can thus be obtained by increasing the order <italic>d </italic>of the Markov model:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11" name="1471-2105-7-542-i9" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo>,</mml:mo>
                <mml:mi>d</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mi>d</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mn>...</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mi>ℓ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mi>d</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>.</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>5</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpcqWGqbaucqGGOaakcqWGibascqGGOaakcqaIXaqmcqGGSaalcqWGKbazcqGGPaqkcqGGPaqkdaqeqbqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdMgaPjabcMcaPiabcYha8jabdIeaijabcIcaOiabdMgaPjabgkHiTiabdsgaKjabcYcaSiabdMgaPjabgkHiTiabigdaXiabcMcaPiabcMcaPaWcbaGaemyAaKMaeyypa0JaemizaqMaey4kaSIaeGymaeJaeiilaWIaeiOla4IaeiOla4IaeiOla4IaeiilaWIaeS4eHWgabeqdcqGHpis1aOGaeiOla4IaaCzcaiaaxMaadaqadaqaaiabiwda1aGaayjkaiaawMcaaaaa@5F50@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>With <italic>d </italic>= 1 we obviously have the standard Markov chain as a special case. Selecting a suitable value for <italic>d </italic>can be a problem. Increasing the order increases accuracy of predicting the next allele, but only to a certain extent; at some point, the conditional probability can no longer be reliably estimated from a limited sample of haplotypes. Another problem with fixing <italic>d </italic>is the fact that linkage disequilibrium may vary within the marker map; it is thus possible that no single value of <italic>d </italic>is suitable for all parts of the map. A more flexible alternative to the fixed-order Markov model is to use a variable-order Markov model, where the context is adjusted for each marker and haplotype individually. Informally, the goal is to find a flexible balance between generality and informativeness. We propose the following solution. When we estimate the probability of a haplotype <italic>H </italic>and consider the variable-order Markovian distribution at marker <italic>i</italic>, we find the longest observed fragment that (1) matches haplotype <italic>H </italic>and ends at marker <italic>i </italic>- 1, and (2) has a frequency exceeding some given threshold, <italic>minfr</italic>. The fragments whose frequency does not exceed this threshold are considered uninformative. Using a frequency threshold is motivated by the fact that it is not likely that a long fragment of haplotypes is shared by different individuals unless it is inherited from the same ancestor; thus using only frequent fragments gives increased confidence in the fragments being identical by descent.</p>
      <p>Given a frequency threshold <italic>minfr</italic>, we first compute the set of most frequent haplotype fragments, denoted by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>minfr</italic></sub>, which will determine the sizes of contexts:</p>
      <p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>minfr </italic></sub>= {<italic>frag</italic>(<italic>h</italic>, <italic>i</italic>, <italic>j</italic>) | 1 ≤ <italic>i </italic>≤ <italic>j </italic>≤ ℓ, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>(<italic>frag</italic>(<italic>h</italic>, <italic>i</italic>, <italic>j</italic>)) ≤ <italic>minfr</italic>},     (6)</p>
      <p>where <italic>h </italic>ranges over all possible fragments. Given a haplotype <italic>H</italic>, the longest matching fragments in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>minfr </italic></sub>are then used to estimate the conditional probabilities at each marker <italic>i</italic>:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16" name="1471-2105-7-542-i10" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mn>1</mml:mn>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>=</mml:mo>
                      <mml:mn>2</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mn>...</mml:mn>
                      <mml:mo>,</mml:mo>
                      <mml:mi>ℓ</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>s</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>,</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>7</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpcqWGqbaucqGGOaakcqWGibascqGGOaakcqaIXaqmcqGGPaqkcqGGPaqkdaqeqbqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdMgaPjabcMcaPiabcYha8jabdIeaijabcIcaOiabdohaZnaaBaaaleaacqWGPbqAaeqaaOGaeiilaWIaemyAaKMaeyOeI0IaeGymaeJaeiykaKIaeiykaKcaleaacqWGPbqAcqGH9aqpcqaIYaGmcqGGSaalcqGGUaGlcqGGUaGlcqGGUaGlcqGGSaalcqWItecBaeqaniabg+GivdGccqGGSaalcaWLjaGaaCzcamaabmaabaGaeG4naCdacaGLOaGaayzkaaaaaa@5A55@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>where <italic>s</italic><sub><italic>i </italic></sub>= min{<italic>s </italic>| <italic>H</italic>(<italic>s</italic>, <italic>i </italic>- 1) ∈ <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>minfr</italic></sub>}. The order of the Markov chain is thus individually adjusted for each position and each haplotype.</p>
      <p>Although both fixed and variable-order Markov models have been extensively studied and used for many applications (see [<xref ref-type="bibr" rid="B34">34</xref>] for a review of variable-order Markov models), we are not aware of any previous applications to haplotype reconstruction. There is also a subtle difference between these models and typical applications of Markov chains. The models employed here are <italic>inhomogeneous</italic>, i.e., each marker has its own states and transition probabilities, whereas usually they are not dependent on the location in the sequence. Also unlike typical applications, we are simultaneously modeling two sequences whose entries are observed together as unordered pairs.</p>
      <p>Another alternative of building a haplotype probability model from local fragments is to think of a complete haplotype as a mosaic of frequent fragments, originating from different founders or via different coalescence histories. In the segmentation model we consider non-overlapping fragments to be independent, and consequently define the probability of a haplotype to be the product of fragment probabilities:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18" name="1471-2105-7-542-i11" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>s</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mi>e</mml:mi>
                        <mml:mi>i</mml:mi>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo>∈</mml:mo>
                      <mml:mi>S</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>H</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>s</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>e</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>,</mml:mo>
                  </mml:mrow>
                </mml:mstyle>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpdaqeqbqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdohaZnaaBaaaleaacqWGPbqAaeqaaOGaeiilaWIaemyzau2aaSbaaSqaaiabdMgaPbqabaGccqGGPaqkcqGGPaqkcqGGSaalaSqaaiabcIcaOiabdohaZnaaBaaameaacqWGPbqAaeqaaSGaeiilaWIaemyzau2aaSbaaWqaaiabdMgaPbqabaWccqGGPaqkcqGHiiIZcqWGtbWuaeqaniabg+Givdaaaa@4C2F@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>where <italic>S </italic>= (<italic>s</italic><sub>1</sub>, <italic>e</italic><sub>1</sub>), (<italic>s</italic><sub>2</sub>, <italic>e</italic><sub>2</sub>),..., (<italic>s</italic><sub><italic>n</italic></sub>, <italic>e</italic><sub><italic>n</italic></sub>) is a segmentation of <italic>H </italic>into consecutive non-overlapping fragments (such that <italic>s</italic><sub>1 </sub>= 1, <italic>s</italic><sub><italic>i </italic></sub>= <italic>e</italic><sub><italic>i </italic>- 1 </sub>+ 1 for all 1 &lt;<italic>i </italic>≤ <italic>n</italic>, and <italic>e</italic><sub><italic>n </italic></sub>= ℓ).</p>
      <p>The above formula leaves open the actual segmentation used for each haplotype. As the recombination history of the haplotypes is unknown, we of course have no way of deducing the "correct" segmentation. As a solution, we propose a model which averages over all possible segmentations:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19" name="1471-2105-7-542-i12" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mstyle displaystyle="true">
                      <mml:msub>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>S</mml:mi>
                          <mml:mo>∈</mml:mo>
                          <mml:mi mathvariant="script">S</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:mstyle displaystyle="true">
                          <mml:msub>
                            <mml:mo>∏</mml:mo>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msub>
                                <mml:mi>s</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mo>,</mml:mo>
                              <mml:msub>
                                <mml:mi>e</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">)</mml:mo>
                              <mml:mo>∈</mml:mo>
                              <mml:mi>S</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mrow>
                            <mml:mi>P</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>H</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:msub>
                              <mml:mi>s</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>e</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mstyle>
                      </mml:mrow>
                    </mml:mstyle>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mo>|</mml:mo>
                    <mml:msup>
                      <mml:mi mathvariant="script">S</mml:mi>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo>|</mml:mo>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>,</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>8</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpdaWcaaqaamaaqababaWaaebeaeaacqWGqbaucqGGOaakcqWGibascqGGOaakcqWGZbWCdaWgaaWcbaGaemyAaKgabeaakiabcYcaSiabdwgaLnaaBaaaleaacqWGPbqAaeqaaOGaeiykaKIaeiykaKcaleaacqGGOaakcqWGZbWCdaWgaaadbaGaemyAaKgabeaaliabcYcaSiabdwgaLnaaBaaameaacqWGPbqAaeqaaSGaeiykaKIaeyicI4Saem4uamfabeqdcqGHpis1aaWcbaGaem4uamLaeyicI4mcdaGae8NeXpfabeqdcqGHris5aaGcbaGaeiiFaWNaf8NeXpLbauaacqGG8baFaaGaeiilaWIaaCzcaiaaxMaadaqadaqaaiabiIda4aGaayjkaiaawMcaaaaa@64EA@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20" name="1471-2105-7-542-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">S</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFse=uaaa@3845@</mml:annotation></mml:semantics></mml:math></inline-formula> is the set of all possible segmentations of <italic>H</italic>: <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21" name="1471-2105-7-542-i3" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">S</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFse=uaaa@3845@</mml:annotation></mml:semantics></mml:math></inline-formula> = {<italic>S </italic>: <italic>H</italic>(<italic>s</italic>, <italic>e</italic>) ∈ <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>minfr </italic></sub>for all(<italic>s</italic>, <italic>e</italic>) ∈ <italic>S</italic>}, and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23" name="1471-2105-7-542-i13" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:msup><mml:mi mathvariant="script">S</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacuWFse=ugaqbaaaa@3851@</mml:annotation></mml:semantics></mml:math></inline-formula> is the set of all possible segmentations of the marker map:</p>
      <p><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24" name="1471-2105-7-542-i13" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:msup><mml:mi mathvariant="script">S</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacuWFse=ugaqbaaaa@3851@</mml:annotation></mml:semantics></mml:math></inline-formula> = {<italic>S </italic>: for all(<italic>s</italic>, <italic>e</italic>) ∈ <italic>S </italic>there exists some frag(<italic>h</italic>, <italic>s</italic>, <italic>e</italic>) ∈ <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>minfr</italic></sub>} (note that the normalization factor is independent of the haplotype <italic>H</italic>). The above formula can be interpreted as having a set of all possible block models, each with a uniform prior probability, over which the probability is averaged. Note that in contrast to widely used block models, there are no preferences for shared block boundaries between individuals; instead, all possible segmentations are considered as equally viable alternatives.</p>
      <p>A potential weakness of the model defined by Equation 8 is that there are more segmentations with a large number of segments than ones with a smaller number. To favor segmentations with less and longer segments, we introduce a penalty factor (controlled by an additional parameter <italic>q</italic>) for each additional fragment included in the segmentation:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26" name="1471-2105-7-542-i14" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>H</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mstyle displaystyle="true">
                      <mml:msub>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>S</mml:mi>
                          <mml:mo>∈</mml:mo>
                          <mml:mi mathvariant="script">S</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mi>q</mml:mi>
                          <mml:mrow>
                            <mml:mo>|</mml:mo>
                            <mml:mi>S</mml:mi>
                            <mml:mo>|</mml:mo>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                        <mml:mo>.</mml:mo>
                        <mml:mstyle displaystyle="true">
                          <mml:msub>
                            <mml:mo>∏</mml:mo>
                            <mml:mrow>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:msub>
                                <mml:mi>s</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mo>,</mml:mo>
                              <mml:msub>
                                <mml:mi>e</mml:mi>
                                <mml:mi>i</mml:mi>
                              </mml:msub>
                              <mml:mo stretchy="false">)</mml:mo>
                              <mml:mo>∈</mml:mo>
                              <mml:mi>S</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mrow>
                            <mml:mi>P</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>H</mml:mi>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:msub>
                              <mml:mi>s</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>e</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mstyle>
                      </mml:mrow>
                    </mml:mstyle>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mstyle displaystyle="true">
                      <mml:msub>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>S</mml:mi>
                          <mml:mo>∈</mml:mo>
                          <mml:msup>
                            <mml:mi mathvariant="script">S</mml:mi>
                            <mml:mo>′</mml:mo>
                          </mml:msup>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mi>q</mml:mi>
                          <mml:mrow>
                            <mml:mo>|</mml:mo>
                            <mml:mi>S</mml:mi>
                            <mml:mo>|</mml:mo>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msup>
                      </mml:mrow>
                    </mml:mstyle>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>,</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mn>9</mml:mn>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaacqWGqbaucqGGOaakcqWGibascqGGPaqkcqGH9aqpdaWcaaqaamaaqababaGaemyCae3aaWbaaSqabeaacqGG8baFcqWGtbWucqGG8baFcqGHsislcqaIXaqmaaGccqGGUaGldaqeqaqaaiabdcfaqjabcIcaOiabdIeaijabcIcaOiabdohaZnaaBaaaleaacqWGPbqAaeqaaOGaeiilaWIaemyzau2aaSbaaSqaaiabdMgaPbqabaGccqGGPaqkcqGGPaqkaSqaaiabcIcaOiabdohaZnaaBaaameaacqWGPbqAaeqaaSGaeiilaWIaemyzau2aaSbaaWqaaiabdMgaPbqabaWccqGGPaqkcqGHiiIZcqWGtbWuaeqaniabg+GivdaaleaacqWGtbWucqGHiiIZimaacqWFse=uaeqaniabggHiLdaakeaadaaeqaqaaiabdghaXnaaCaaaleqabaGaeiiFaWNaem4uamLaeiiFaWNaeyOeI0IaeGymaedaaaqaaiabdofatjabgIGiolqb=jr8tzaafaaabeqdcqGHris5aaaakiabcYcaSiaaxMaacaWLjaWaaeWaaeaacqaI5aqoaiaawIcacaGLPaaaaaa@76B7@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>where 0 &lt;<italic>q </italic>≤ 1, and |<italic>S</italic>| is the number of segments in segmentation <italic>S</italic>. Setting a smaller value to <italic>q </italic>will cause segmentations with a large number of fragments to have a smaller probability. Setting <italic>q </italic>= 1 corresponds to no penalty, in which case the formulation is equivalent to Equation 8. By experimenting we found that <italic>q </italic>= 0.1 works reasonably well in different settings. This value was used in all our experiments.</p>
    </sec>
    <sec>
      <title>The HaploRec algorithm</title>
      <p>Given one of the models we defined – fixed-order Markov chain, variable-order Markov chain, or the segmentation model – and its parameters, we can compute a probability for any given haplotype.</p>
      <p>Assuming independence between the two haplotypes of an individual (<italic>Hardy-Weinberg equilibrium</italic>), the probability of any haplotype configuration for a genotype is just the product of the probabilities of its constituent haplotypes. The algorithmic problem is twofold: the haplotype reconstruction method has to simultaneously learn the model parameters and reconstruct the haplotypes of each individual.</p>
      <p>Our algorithm, HaploRec, is a modified version of the the EM algorithm introduced in [<xref ref-type="bibr" rid="B4">4</xref>]. In the EM framework, the haplotype configuration underlying each genotype is considered as a latent variable, and the goal is to find a maximum-likelihood estimate for the model parameters <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>. The likelihood of a single genotype is a sum of the probabilities of all its possible haplotype configurations (the values of latent variables), and the likelihood of the whole data is then just a product over all genotypes:</p>
      <p>
        <inline-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28" name="1471-2105-7-542-i15" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>L</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi mathvariant="script">G</mml:mi>
                <mml:mo>|</mml:mo>
                <mml:mi>ℱ</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∏</mml:mo>
                    <mml:mrow>
                      <mml:mi>G</mml:mi>
                      <mml:mo>∈</mml:mo>
                      <mml:mi mathvariant="script">G</mml:mi>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mo>{</mml:mo>
                          <mml:msub>
                            <mml:mi>H</mml:mi>
                            <mml:mn>1</mml:mn>
                          </mml:msub>
                          <mml:mo>,</mml:mo>
                          <mml:msub>
                            <mml:mi>H</mml:mi>
                            <mml:mn>2</mml:mn>
                          </mml:msub>
                          <mml:mo>}</mml:mo>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mi>C</mml:mi>
                            <mml:mi>G</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:mi>P</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mo>{</mml:mo>
                        <mml:msub>
                          <mml:mi>H</mml:mi>
                          <mml:mn>1</mml:mn>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:msub>
                          <mml:mi>H</mml:mi>
                          <mml:mn>2</mml:mn>
                        </mml:msub>
                        <mml:mo>}</mml:mo>
                        <mml:mo>|</mml:mo>
                        <mml:mi>ℱ</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mstyle>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>,</mml:mo>
                <mml:mtext>     </mml:mtext>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mn>10</mml:mn>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaacqWGmbatcqGGOaakimaacqWFge=rcqGG8baFcqWFXeIrcqGGPaqkcqGH9aqpdaqeqbqaamaaqafabaGaemiuaaLaeiikaGIaei4EaSNaemisaG0aaSbaaSqaaiabigdaXaqabaGccqGGSaalcqWGibasdaWgaaWcbaGaeGOmaidabeaakiabc2ha9jabcYha8jab=ftigjabcMcaPaWcbaGaei4EaSNaemisaG0aaSbaaWqaaiabigdaXaqabaWccqGGSaalcqWGibasdaWgaaadbaGaeGOmaidabeaaliabc2ha9jabgIGiolabdoeadnaaBaaameaacqWGhbWraeqaaaWcbeqdcqGHris5aaWcbaGaem4raCKaeyicI4Sae8NbXFeabeqdcqGHpis1aOGaeiilaWIaaCzcaiaaxMaadaqadaqaaiabigdaXiabicdaWaGaayjkaiaawMcaaaaa@66E9@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </inline-formula>
      </p>
      <p>where <italic>P</italic>({<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} | <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>) = <italic>P</italic>(<italic>H</italic><sub>1</sub>|<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>)·<italic>P</italic>(<italic>H</italic><sub>2</sub>|<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>) is the probability of the haplotype pair {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>}, given the model parameters <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>. The EM algorithm works by iteratively improving estimates of the model parameters (<italic>the M-step</italic>) and values of the latent variables (<italic>the E-step</italic>), until a (local) maximum of the likelihood is reached. The individual reconstructed haplotypes can then be obtained by just selecting, for each genotype, the compatible haplotype pair that has maximal probability according to the obtained maximum-likelihood estimate of the parameters.</p>
      <p>The original algorithm [<xref ref-type="bibr" rid="B4">4</xref>] uses a multinomial model, where parameters are the frequencies of complete haplotypes. Our modifications to the EM algorithm consist of (1) replacing the multinomial model with one of our fragment-based probability models and (2) using a sequential pruning strategy to overcome the exponential computational complexity of the E-step. Below, we give an outline of the HaploRec algorithm; a more detailed description, including pseudo-code, handling of missing data and complexity analysis, is given in <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>.</p>
      <sec>
        <title>Representation of model parameters</title>
        <p>Parameters of the three models are slightly different. In the Markov models, the parameters are the conditional allele probabilities; in the segmentation model, the parameters are the fragment probabilities. In practice, the conditional probabilities are derived from fragment probabilities as follows:</p>
        <p>
          <inline-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33" name="1471-2105-7-542-i16" overflow="scroll">
              <mml:semantics definitionURL="" encoding="">
                <mml:mrow>
                  <mml:mi>P</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>H</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi>H</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>−</mml:mo>
                  <mml:mi>d</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>−</mml:mo>
                  <mml:mn>1</mml:mn>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>ℱ</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>H</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mi>d</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>ℱ</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>H</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mi>d</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mn>1</mml:mn>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo>,</mml:mo>
                </mml:mrow>
                <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaacqWGqbaucqGGOaakcqWGibascqGGOaakcqWGPbqAcqGGPaqkcqGG8baFcqWGibascqGGOaakcqWGPbqAcqGHsislcqWGKbazcqGGSaalcqWGPbqAcqGHsislcqaIXaqmcqGGPaqkcqGGPaqkcqGH9aqpdaWcaaqaaGWaaiab=ftigjabcIcaOiabdIeaijabcIcaOiabdMgaPjabgkHiTiabdsgaKjabcYcaSiabdMgaPjabcMcaPiabcMcaPaqaaiab=ftigjabcIcaOiabdIeaijabcIcaOiabdMgaPjabgkHiTiabdsgaKjabcYcaSiabdMgaPjabgkHiTiabigdaXiabcMcaPiabcMcaPaaacqGGSaalaaa@6416@</mml:annotation>
              </mml:semantics>
            </mml:math>
          </inline-formula>
        </p>
        <p>where <italic>d </italic>is the number of previous markers conditioned on and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula>(<italic>H</italic>) denotes the estimated probability (frequency) of fragment <italic>H</italic>. As conditional probabilities can be straightforwardly derived from fragment frequencies, we always use the set of fragments as a representation for the model parameters, also in the case of the Markov models.</p>
      </sec>
      <sec>
        <title>E-step</title>
        <p>In the E-step of the EM algorithm, the aim is to calculate, for each <italic>G </italic>∈ <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35" name="1471-2105-7-542-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi mathvariant="script">G</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFge=raaa@382D@</mml:annotation></mml:semantics></mml:math></inline-formula>, and each compatible haplotype pair {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} ∈ <italic>C</italic><sub><italic>G</italic></sub>, the probability that the genotype actually consists of that haplotype pair:</p>
        <p>
          <inline-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36" name="1471-2105-7-542-i17" overflow="scroll">
              <mml:semantics definitionURL="" encoding="">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>P</mml:mi>
                    <mml:mi>t</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mo>{</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mn>1</mml:mn>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mn>2</mml:mn>
                  </mml:msub>
                  <mml:mo>}</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi>G</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mi>P</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mo>{</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mn>1</mml:mn>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mn>2</mml:mn>
                  </mml:msub>
                  <mml:mo>}</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi>G</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mi>ℱ</mml:mi>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>−</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>P</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>H</mml:mi>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>|</mml:mo>
                      <mml:msub>
                        <mml:mi>ℱ</mml:mi>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                      <mml:mi>P</mml:mi>
                      <mml:mo stretchy="false">(</mml:mo>
                      <mml:msub>
                        <mml:mi>H</mml:mi>
                        <mml:mn>2</mml:mn>
                      </mml:msub>
                      <mml:mo>|</mml:mo>
                      <mml:msub>
                        <mml:mi>ℱ</mml:mi>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo stretchy="false">)</mml:mo>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mstyle displaystyle="true">
                        <mml:msub>
                          <mml:mo>∑</mml:mo>
                          <mml:mrow>
                            <mml:mo>{</mml:mo>
                            <mml:mi>H</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mover accent="true">
                              <mml:mi>H</mml:mi>
                              <mml:mo>¯</mml:mo>
                            </mml:mover>
                            <mml:mo>}</mml:mo>
                            <mml:mo>∈</mml:mo>
                            <mml:msub>
                              <mml:mi>C</mml:mi>
                              <mml:mi>G</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mrow>
                          <mml:mi>P</mml:mi>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mi>H</mml:mi>
                          <mml:mo>|</mml:mo>
                          <mml:msub>
                            <mml:mi>ℱ</mml:mi>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                          <mml:mi>P</mml:mi>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mover accent="true">
                            <mml:mi>H</mml:mi>
                            <mml:mo>¯</mml:mo>
                          </mml:mover>
                          <mml:mo>|</mml:mo>
                          <mml:msub>
                            <mml:mi>ℱ</mml:mi>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                              <mml:mo>−</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mstyle>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo>.</mml:mo>
                </mml:mrow>
                <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaacqWGqbaudaWgaaWcbaGaemiDaqhabeaakiabcIcaOiabcUha7jabdIeainaaBaaaleaacqaIXaqmaeqaaOGaeiilaWIaemisaG0aaSbaaSqaaiabikdaYaqabaGccqGG9bqFcqGG8baFcqWGhbWrcqGGPaqkcqGH9aqpcqWGqbaucqGGOaakcqGG7bWEcqWGibasdaWgaaWcbaGaeGymaedabeaakiabcYcaSiabdIeainaaBaaaleaacqaIYaGmaeqaaOGaeiyFa0NaeiiFaWNaem4raCKaeiilaWccdaGae8xmHy0aaSbaaSqaaiabdsha0jabgkHiTiabigdaXaqabaGccqGGPaqkcqGH9aqpdaWcaaqaaiabdcfaqjabcIcaOiabdIeainaaBaaaleaacqaIXaqmaeqaaOGaeiiFaWNae8xmHy0aaSbaaSqaaiabdsha0jabgkHiTiabigdaXaqabaGccqGGPaqkcqWGqbaucqGGOaakcqWGibasdaWgaaWcbaGaeGOmaidabeaakiabcYha8jab=ftignaaBaaaleaacqWG0baDcqGHsislcqaIXaqmaeqaaOGaeiykaKcabaWaaabeaeaacqWGqbaucqGGOaakcqWGibascqGG8baFcqWFXeIrdaWgaaWcbaGaemiDaqNaeyOeI0IaeGymaedabeaakiabcMcaPiabdcfaqjabcIcaOiqbdIeaizaaraGaeiiFaWNae8xmHy0aaSbaaSqaaiabdsha0jabgkHiTiabigdaXaqabaGccqGGPaqkaSqaaiabcUha7jabdIeaijabcYcaSiqbdIeaizaaraGaeiyFa0NaeyicI4Saem4qam0aaSbaaWqaaiabdEeahbqabaaaleqaniabggHiLdaaaOGaeiOla4caaa@92E9@</mml:annotation>
              </mml:semantics>
            </mml:math>
          </inline-formula>
        </p>
        <p>The model parameters, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37" name="1471-2105-7-542-i7" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mi>ℱ</mml:mi><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIraaa@3787@</mml:annotation></mml:semantics></mml:math></inline-formula><sub><italic>t </italic>- 1</sub>, are obtained from the previous parameter estimation step. The normalization just transforms the (prior) probabilities given by the model into a (posterior) probability distribution for configurations of the single genotype <italic>G</italic>. Exhaustively going through all possible configurations is feasible only when the number of heterozygous markers is small (≅ 20 or less). With more markers, we use a pruning strategy in which the set of possible haplotype configurations (separately for each genotype) is built up marker by marker, starting from a partial configuration containing only the allele pair at the leftmost marker. At each step, all partial configurations are extended with the allele pair at the next marker (for homozygous markers, each configuration is extended with the same allele pair; for heterozygous markers, there are two possible extensions for each configuration, and only the the <italic>B </italic>most probable configurations are propagated to the next step). In the final step, the <italic>C</italic>(≤ <italic>B</italic>) most probable configurations are returned. The approach is greedy; it is not guaranteed that the set of returned configurations consists exactly of the most probable ones. In preliminary experiments it was found that <italic>B </italic>= 25 and <italic>C </italic>= 10 give a reasonable computational efficiency, while increasing the parameters beyond these values does not significantly improve accuracy. These values were used in the experiments. Using a sequential pruning strategy to implement the E-step is conceptually simple, and has already been used in [<xref ref-type="bibr" rid="B19">19</xref>]. However, implementing it efficiently for our models is not trivial. In <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, we provide a detailed description of the data structures and algorithms for implementing the E-step for each of proposed models.</p>
      </sec>
      <sec>
        <title>M-step</title>
        <p>In the M-step of the EM algorithm, the model parameters are re-estimated (based on the current haplotype estimates from the previous E-step), such that the likelihood of the data is improved from the previous iteration. The haplotype estimates from the previous E-step give the expected frequency of any haplotype in a given genotype. The estimated frequency of a haplotype fragment in a single genotype is obtained by a sum over all the haplotypes in its set of possible configurations that match the fragment, and the overall estimated frequency of a fragment <italic>h </italic>is obtained as an average over all genotypes:</p>
        <p>
          <inline-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38" name="1471-2105-7-542-i18" overflow="scroll">
              <mml:semantics definitionURL="" encoding="">
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>ℱ</mml:mi>
                    <mml:mi>t</mml:mi>
                  </mml:msub>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>h</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                      <mml:mo>|</mml:mo>
                      <mml:mi mathvariant="script">G</mml:mi>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mstyle displaystyle="true">
                    <mml:munder>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>G</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mi mathvariant="script">G</mml:mi>
                      </mml:mrow>
                    </mml:munder>
                    <mml:mrow>
                      <mml:mstyle displaystyle="true">
                        <mml:munder>
                          <mml:mo>∑</mml:mo>
                          <mml:mrow>
                            <mml:mo>{</mml:mo>
                            <mml:msub>
                              <mml:mi>H</mml:mi>
                              <mml:mn>1</mml:mn>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>H</mml:mi>
                              <mml:mn>2</mml:mn>
                            </mml:msub>
                            <mml:mo>}</mml:mo>
                            <mml:mo>∈</mml:mo>
                            <mml:msub>
                              <mml:mi>C</mml:mi>
                              <mml:mi>G</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>P</mml:mi>
                            <mml:mi>t</mml:mi>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mstyle>
                    </mml:mrow>
                  </mml:mstyle>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mo>{</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mn>1</mml:mn>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:msub>
                    <mml:mi>H</mml:mi>
                    <mml:mn>2</mml:mn>
                  </mml:msub>
                  <mml:mo>}</mml:mo>
                  <mml:mo>|</mml:mo>
                  <mml:mi>G</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:msub>
                    <mml:mi>δ</mml:mi>
                    <mml:mrow>
                      <mml:mi>h</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mo>{</mml:mo>
                      <mml:msub>
                        <mml:mi>H</mml:mi>
                        <mml:mn>1</mml:mn>
                      </mml:msub>
                      <mml:mo>,</mml:mo>
                      <mml:msub>
                        <mml:mi>H</mml:mi>
                        <mml:mn>2</mml:mn>
                      </mml:msub>
                      <mml:mo>}</mml:mo>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                </mml:mrow>
                <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIrdaWgaaWcbaGaemiDaqhabeaakiabcIcaOiabdIgaOjabcMcaPiabg2da9maalaaabaGaeGymaedabaGaeGOmaiJaeiiFaWNae8NbXFKaeiiFaWhaamaaqafabaWaaabuaeaacqWGqbaudaWgaaWcbaGaemiDaqhabeaaaeaacqGG7bWEcqWGibasdaWgaaadbaGaeGymaedabeaaliabcYcaSiabdIeainaaBaaameaacqaIYaGmaeqaaSGaeiyFa0NaeyicI4Saem4qam0aaSbaaWqaaiabdEeahbqabaaaleqaniabggHiLdaaleaacqWGhbWrcqGHiiIZcqWFge=raeqaniabggHiLdGccqGGOaakcqGG7bWEcqWGibasdaWgaaWcbaGaeGymaedabeaakiabcYcaSiabdIeainaaBaaaleaacqaIYaGmaeqaaOGaeiyFa0NaeiiFaWNaem4raCKaeiykaKccciGae4hTdq2aaSbaaSqaaiabdIgaOjabcYcaSiabcUha7jabdIeainaaBaaameaacqaIXaqmaeqaaSGaeiilaWIaemisaG0aaSbaaWqaaiabikdaYaqabaWccqGG9bqFaeqaaOGaeiilaWcaaa@75AA@</mml:annotation>
              </mml:semantics>
            </mml:math>
          </inline-formula>
        </p>
        <p>where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39" name="1471-2105-7-542-i19" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mrow><mml:msub><mml:mi>δ</mml:mi><mml:mrow><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaiiGacqWF0oazdaWgaaWcbaGaemiAaGMaeiilaWIaei4EaSNaemisaG0aaSbaaWqaaiabigdaXaqabaWccqGGSaalcqWGibasdaWgaaadbaGaeGOmaidabeaaliabc2ha9bqabaaaaa@42D4@</mml:annotation></mml:semantics></mml:math></inline-formula> = |{<italic>i </italic>∈ {1, 2} | <italic>h </italic>matches <italic>H</italic><sub><italic>i</italic></sub>}| ∈ {0, 1, 2} is the number of haplotypes in configuration {<italic>H</italic><sub>1</sub>, <italic>H</italic><sub>2</sub>} that match <italic>h</italic>. To compute the fragment frequencies, we first combine the sets of most probable haplotype configurations (from the previous E-step) from all genotypes into a weighted (multi-)set of haplotypes, where the weight of each haplotype is the sum of the probabilities of its occurrences in the reconstructed configurations (note that the weights are thus mostly non-integer). Computing the set of frequent fragments is then done by by depth-first search in the fragment containment lattice. First, all possible fragments of length one are generated, after which they are recursively extended to the right as long as the frequencies of resulting fragments stay above the given minimum frequency threshold and the fragments do not exceed a given maximum length. To improve the efficiency of the algorithm, the list of matching haplotypes is stored with each fragment during the execution of the algorithm (as depth-first search is used, this does not significantly improve memory usage, because the list can be freed when the fragment is no longer in the stack). This way, the frequency of a each fragment can be computed by only matching its last allele to the list of haplotypes matching its prefix. The algorithm is guaranteed to find all frequent fragments, as frequency decreases monotonically when a fragment is extended.</p>
      </sec>
      <sec>
        <title>Initialization</title>
        <p>The initial frequencies are computed somewhat similarly as in the parameter estimation step. The difference is that there is not yet any information about the probability of different haplotype configurations, and thus all configurations of a genotype must be considered equally likely. The number of haplotype configurations compatible with a genotype <italic>G </italic>is exponential in the number of heterozygous markers in <italic>G</italic>, and enumerating all the possible configurations in <italic>C</italic><sub><italic>G </italic></sub>is thus infeasible. Fortunately, the initial frequencies can be counted directly from the genotype data as follows, without explicitly generating the elements of <italic>C</italic><sub><italic>G</italic></sub>:</p>
        <p>
          <inline-formula>
            <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40" name="1471-2105-7-542-i20" overflow="scroll">
              <mml:semantics definitionURL="" encoding="">
                <mml:mrow>
                  <mml:mi>ℱ</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>f</mml:mi>
                  <mml:mi>r</mml:mi>
                  <mml:mi>a</mml:mi>
                  <mml:mi>g</mml:mi>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi>h</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>j</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo stretchy="false">)</mml:mo>
                  <mml:mo>=</mml:mo>
                  <mml:mfrac>
                    <mml:mn>1</mml:mn>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                      <mml:mo>|</mml:mo>
                      <mml:mi mathvariant="script">G</mml:mi>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mstyle displaystyle="true">
                    <mml:munder>
                      <mml:mo>∑</mml:mo>
                      <mml:mrow>
                        <mml:mi>G</mml:mi>
                        <mml:mo>∈</mml:mo>
                        <mml:mi mathvariant="script">G</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>G</mml:mi>
                        <mml:mtext> matches </mml:mtext>
                        <mml:mi>f</mml:mi>
                        <mml:mi>r</mml:mi>
                        <mml:mi>a</mml:mi>
                        <mml:mi>g</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>h</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:munder>
                    <mml:mrow>
                      <mml:msup>
                        <mml:mn>2</mml:mn>
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:msub>
                            <mml:mi>k</mml:mi>
                            <mml:mrow>
                              <mml:mi>G</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mi>i</mml:mi>
                              <mml:mo>,</mml:mo>
                              <mml:mi>j</mml:mi>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                  </mml:mstyle>
                  <mml:mo>,</mml:mo>
                  <mml:mtext>     </mml:mtext>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:mn>11</mml:mn>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
                <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBamrtHrhAL1wy0L2yHvtyaeHbnfgDOvwBHrxAJfwnaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaWaaeGaeaaakeaaimaacqWFXeIrcqGGOaakcqWGMbGzcqWGYbGCcqWGHbqycqWGNbWzcqGGOaakcqWGObaAcqGGSaalcqWGPbqAcqGGSaalcqWGQbGAcqGGPaqkcqGGPaqkcqGH9aqpdaWcaaqaaiabigdaXaqaaiabikdaYiabcYha8jab=zq8hjabcYha8baadaaeqbqaaiabikdaYmaaCaaaleqabaGaeGymaeJaeyOeI0Iaem4AaS2aaSbaaWqaaiabdEeahjabcIcaOiabdMgaPjabcYcaSiabdQgaQjabcMcaPaqabaaaaaWcbaGaem4raCKaeyicI4Sae8NbXFKaeiilaWIaem4raCKaeeiiaaIaeeyBa0MaeeyyaeMaeeiDaqNaee4yamMaeeiAaGMaeeyzauMaee4CamNaeeiiaaIaemOzayMaemOCaiNaemyyaeMaem4zaCMaeiikaGIaemiAaGMaeiilaWIaemyAaKMaeiilaWIaemOAaOMaeiykaKcabeqdcqGHris5aOGaeiilaWIaaCzcaiaaxMaadaqadaqaaiabigdaXiabigdaXaGaayjkaiaawMcaaaaa@7EC3@</mml:annotation>
              </mml:semantics>
            </mml:math>
          </inline-formula>
        </p>
        <p>where <italic>k</italic><sub><italic>G</italic>(<italic>i</italic>, <italic>j</italic>) </sub>is the number of heterozygous markers in genotype fragment <italic>G</italic>(<italic>i</italic>, <italic>j</italic>) (note that a homozygous genotype has two identical haplotypes both matching the fragment, and thus weight 2). Computing the initial model can be implemented by a slightly modified version of the above-described depth-first search algorithm.</p>
      </sec>
    </sec>
    <sec>
      <title>Using overlapping windows to haplotype very long marker maps</title>
      <p>The HaploRec algorithm described above is directly suitable for windows (marker maps) containing up to 500–1500 markers. This practical limit depends on the number of genotypes, amount of missing data, complexity of the haplotype distribution, program parameters and the amount of available main memory. We have extended the implementation of the method by a simple but efficient feature that allows it to handle an arbitrarily large number of markers. Briefly, the idea is to sequentially haplotype a window of <italic>w </italic>markers at a time. In each window except the first one, phased haplotypes for the first <italic>o </italic>markers are obtained from the haplotypes in the previous, overlapping window. After a window is haplotyped, <italic>r </italic>of its last markers are discarded; they are only used to get better estimates for the <italic>w </italic>- <italic>o </italic>- <italic>r </italic>markers in the middle of the window. I.e., each window has length <italic>w </italic>= <italic>o </italic>+ <italic>u </italic>+ <italic>o </italic>+ <italic>r</italic>, where <italic>u </italic>is the number of markers unique to this window, the first <italic>o </italic>represents the haplotypes obtained from the previous window and the second <italic>o </italic>those that are used by the next window. The window is moved <italic>o </italic>+ <italic>u </italic>markers at a time. In experiments with Yoruba data (results not shown), HAPLOREC had practically identical accuracies with this extension and without it, at the expense of slightly larger running times per marker resulting from the overlapping windows.</p>
    </sec>
    <sec>
      <title>Simulation of data</title>
      <p>We used Hudson's coalescence simulator [<xref ref-type="bibr" rid="B24">24</xref>] to generate chromosomes under the standard Wright-Fisher neutral model of genetic variation with recombination. A long chromosomal region with 16666666 base pairs was simulated. The probability of a mutation in each base pair was set to 10<sup>-8 </sup>per generation, and the probability of cross-over between adjacent base pairs was set to 10<sup>-8</sup>. These values give the mutation probability for the entire chromosomal region <italic>μ </italic>= 0.16666666, and cross-over probability <italic>ρ </italic>= 0.16666665. The diploid population size, <italic>N</italic><sub>0</sub>, was set to the standard 10000, giving the mutation parameter <italic>θ </italic>= 4<italic>N</italic><sub>0</sub><italic>μ </italic>= 6666.6666, and the recombination parameter <italic>r </italic>= 6666.6665. This standard model simulates recombinations with a uniform distribution. As a result of the stochastic coalescence, however, the recombinations in the final population tend not to be uniformly distributed.</p>
      <p>A sample of 2000 chromosomes was generated, and these were paired to form 1000 genotypes. On the average, one simulation produced approximately 55000 segregating sites. Markers were chosen from the segregating sites with minor allele frequency at least 5%, such that marker spacing was as uniform as possible. The actual number of markers and the position of the markers varied with different test settings. The amount of linkage disequilibrium between markers is perhaps the most important factor affecting the accuracy of population-based haplotyping methods. Under the assumption of uniform recombination the amount of linkage disequilibrium is governed by the average distance between adjacent markers. To assess haplotyping performance with different amounts of linkage disequilibrium, marker spacing was varied between 6.6 and 166 kb. The average linkage disequilibrium between neighboring markers, measured with Lewontins |<italic>D'</italic>| measure, ranges respectively from 0.88 to 0.36 (Table <xref ref-type="table" rid="T1">1</xref>). With 30 markers (the number of markers most commonly used in the following experiments), total map lengths are between 200 and 5000 kb. The largest data sets have 500 markers picked from the whole simulated region, giving an average marker spacing of 33 kb.</p>
      <p>In real data, a fraction of alleles is practically always missing, and there may be genotyping errors. Therefore, in some of the experiments, part of the alleles were masked as missing. Either both or none of the homologous alleles of each marker were masked. This was done by fixing for each allele pair (single marker of a single genotype) a probability for having missing data. Likewise, genotyping errors were simulated by randomly changing each allele according to a given probability.</p>
    </sec>
    <sec>
      <title>Processing of HapMap data</title>
      <p>We used 30 trios from the Yoruba population in Ibadan, Nigeria, and another 30 trios from the CEPH population. Both data sets were downloaded from the HapMap web site [<xref ref-type="bibr" rid="B25">25</xref>].</p>
      <p>The haplotypes of the children were inferred from the trios, and the non-transmitted parental chromosomes of each trio were combined to form additional artificial haplotype pairs (as is common in association studies if trios are available), resulting in a set of 60 genotypes for each population. Markers for which the phase could not be inferred, when all members of the trio were heterozygous, are included in the resulting data sets, but are not used in the switch accuracy calculations. In markers where only one allele was missing, the other was marked missing as well, since some of the tested programs could not handle markers where only one allele is missing. Markers with minor allele frequency less than 5% were discarded.</p>
      <p>For testing, we first sampled 50 sets of markers from distinct regions of chromosome 1. The sampling was done by systematically taking (from the set of markers fulfilling the minor allele frequency threshold) markers 1–500 to the first data set, markers 501–1000 to the second, etc. In the resulting data sets, the average marker spacing is approximately 1.5 kb and the fraction of missing alleles is approximately 3.6%. Data sets with sparser maps were obtained by sampling markers from these; e.g., an average distance of 6 kb between markers was obtained by systematically choosing every fourth marker from the original samples.</p>
      <p>For experiments with different numbers of markers, the markers were picked from the middle of each set of 500 markers. To reduce variance in results, caused by differences in the difficulty of haplotyping different markers, accuracy was always evaluated only on the 10 middlemost markers common to all the sets. This way, in each run, the test is the same and results are better comparable.</p>
      <p>The same procedures were performed separately for the Yoruba and CEPH data sets, and the same set of experiments were performed for both populations. For each population, the reported experimental results are averaged over the 50 data sets to reduce variance in the results.</p>
    </sec>
  </sec>
  <sec>
    <title>Availability and requirements</title>
    <p>• <bold>Project name: </bold>HaploRec</p>
    <p>• <bold>Project home page: </bold><ext-link ext-link-type="uri" xlink:href="http://www.cs.helsinki.fi/group/genetics/haplotyping.html"/>.</p>
    <p>• <bold>Operating system: </bold>Platform independent</p>
    <p>• <bold>Programming language: </bold>Java</p>
    <p>• <bold>Other requirements: </bold>Java 1.5 or higher</p>
    <p>• <bold>License: </bold>Free for educational, research and non-profit purposes</p>
    <p>• <bold>Any restrictions to use by non-academics: </bold>License required</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>All authors contributed to the formulation of the models and to drafting of the manuscript. LE developed the algorithms and carried out the experiments. FG participated in the design of the study. HT conceived the study and participated in its design. All authors read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p>Detailed algorithms, proof of convergence, and complexity analysis.</p>
      </caption>
      <media xlink:href="1471-2105-7-542-S1.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="S2">
      <caption>
        <title>Additional file 2</title>
        <p>Example results from the 10 data replicates.</p>
      </caption>
      <media xlink:href="1471-2105-7-542-S2.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>This research has been financially supported by the Finnish Funding Agency for Technology and Innovation (Tekes). HT has been supported also by Alexander von Humboldt Foundation.</p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Clark</surname>
            <given-names>AG</given-names>
          </name>
        </person-group>
        <article-title>Inference of haplotypes from PCR-amplified samples of diploid populations</article-title>
        <source>Molecular Biological Evolution</source>
        <year>1990</year>
        <volume>7</volume>
        <fpage>111</fpage>
        <lpage>122</lpage>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfleld</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Haplotype Inference by Pure Parsimony</article-title>
        <source>Proceedings of the 14:th Annual Symposium on Combinatorial Pattern Matching</source>
        <year>2003</year>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Ding</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Filkov</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Gusfleld</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>A Linear-Time Algorithm for the Perfect Phylogeny Haplotyping (PPH) Problem</article-title>
        <source>International Conference on Research in Computational Molecular Biology 2005 (RECOMB 2005), Volume 3500 of Lecture Notes in Computer Science, Springer</source>
        <year>2005</year>
        <fpage>585</fpage>
        <lpage>600</lpage>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Excoffier</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Slatkin</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Maximum-Likelihood estimation of molecular haplotype frequencies in a diploid population</article-title>
        <source>Molecular Biological Evolution</source>
        <year>1995</year>
        <volume>12</volume>
        <fpage>921</fpage>
        <lpage>927</lpage>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Niu</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Qin</surname>
            <given-names>ZS</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>Bayesian Haplotype Inference for Multiple Linked Single-Nucleotide Polymorphisms</article-title>
        <source>Am J Hum Genet</source>
        <year>2002</year>
        <volume>70</volume>
        <fpage>17</fpage>
        <lpage>169</lpage>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qin</surname>
            <given-names>ZS</given-names>
          </name>
          <name>
            <surname>Niu</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>Partition-Ligation-Expectation-Maximization Algorithm for Haplotype Inference with Single-Nucleotide Polymorphisms</article-title>
        <source>Am J Hum Genet</source>
        <year>2002</year>
        <volume>71</volume>
        <fpage>1242</fpage>
        <lpage>1247</lpage>
        <pub-id pub-id-type="pmid">12452179</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stephens</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>NJ</given-names>
          </name>
          <name>
            <surname>Donnelly</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>A New Statistical Method for Haplotype Reconstruction from Population Data</article-title>
        <source>Am J Hum Genet</source>
        <year>2001</year>
        <volume>68</volume>
        <fpage>978</fpage>
        <lpage>989</lpage>
        <pub-id pub-id-type="pmid">11254454</pub-id>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stephens</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Scheet</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Accounting for Decay of Linkage Disequilibrium in Haplotype Inference and Missing-Data Imputation</article-title>
        <source>Am J Hum Genet</source>
        <year>2005</year>
        <volume>76</volume>
        <fpage>449</fpage>
        <lpage>462</lpage>
        <pub-id pub-id-type="pmid">15700229</pub-id>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Greenspan</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Geiger</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Model-based inference of haplotype block variation</article-title>
        <source>Proceedings of the seventh annual international conference on Computational molecular biology</source>
        <year>2003</year>
        <publisher-name>ACM Press</publisher-name>
        <fpage>131</fpage>
        <lpage>137</lpage>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kimmel</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Shamir</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>GERBIL: Genotype resolution and block identification using likelihood</article-title>
        <source>Proceedings of the National Academy of Sciences</source>
        <year>2005</year>
        <volume>102</volume>
        <fpage>158</fpage>
        <lpage>162</lpage>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Halldórsson</surname>
            <given-names>BV</given-names>
          </name>
          <name>
            <surname>Bafna</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Edwards</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Lippert</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Yoosepth</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Istrail</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>A Survey of Computational Methods for Determining Haplotypes</article-title>
        <source>Computational Methods for SNPs and Haplotype Inference, Volume 2983 of Lecture Notes in Computer Science</source>
        <year>2004</year>
        <publisher-name>Berlin: Springer</publisher-name>
        <fpage>26</fpage>
        <lpage>47</lpage>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfleld</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>An Overview of Combinatorial Methods for Haplotype Inference</article-title>
        <source>Computational Methods for SNPs and Haplotype Inference, Volume 2983 of Lecture Notes in Computer Science</source>
        <year>2004</year>
        <publisher-name>Berlin: Springer</publisher-name>
        <fpage>9</fpage>
        <lpage>25</lpage>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salem</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Wessel</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Schork</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>A comprehensive literature review of haplotyping software and methods for use with unrelated individuals</article-title>
        <source>Human Genomics</source>
        <year>2005</year>
        <volume>2</volume>
        <fpage>39</fpage>
        <lpage>66</lpage>
        <pub-id pub-id-type="pmid">15814067</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yan</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Papadopoulos</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Marra</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Perrera</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Josef</surname>
            <given-names>JiricnyCR</given-names>
          </name>
          <name>
            <surname>Boland</surname>
            <given-names/>
          </name>
          <name>
            <surname>Lynch</surname>
            <given-names>HT</given-names>
          </name>
          <name>
            <surname>Chadwick</surname>
            <given-names>RB</given-names>
          </name>
          <name>
            <surname>de la Chapelle</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Berg</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Eshleman</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Yuan</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Markowitz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Laken</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Lengauer</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Kinzler</surname>
            <given-names>KW</given-names>
          </name>
          <name>
            <surname>Vogelstein</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Conversion of diploidy to haploidy</article-title>
        <source>Nature</source>
        <year>2000</year>
        <volume>403</volume>
        <fpage>723</fpage>
        <lpage>724</lpage>
        <pub-id pub-id-type="pmid">10693791</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Shendure</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Porreca</surname>
            <given-names>GJ</given-names>
          </name>
          <name>
            <surname>Aach</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Mitra</surname>
            <given-names>RD</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>GM</given-names>
          </name>
        </person-group>
        <article-title>Long-range polony haplotyping of individual human chromosome molecules</article-title>
        <source>Nature Genetics</source>
        <year>2006</year>
        <volume>38</volume>
        <fpage>382</fpage>
        <lpage>387</lpage>
        <pub-id pub-id-type="pmid">16493423</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eskin</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Sharan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Halperin</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>A Note on Phasing Long Genomic Regions using Local Haplotype Predictions</article-title>
        <source>Journal of Bioinformatics and Computational Biology</source>
        <year>2006</year>
        <volume>4</volume>
        <fpage>639</fpage>
        <lpage>647</lpage>
        <pub-id pub-id-type="pmid">16960967</pub-id>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Coulonges</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Delaneau</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Girard</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Do</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Adkins</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Spadoni</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Zagury</surname>
            <given-names>JF</given-names>
          </name>
        </person-group>
        <article-title>Computation of haplotypes on SNPs subsets: advantage of the "global method"</article-title>
        <source>BMC Genetics</source>
        <year>2006</year>
        <volume>7</volume>
        <fpage>50</fpage>
        <pub-id pub-id-type="pmid">17067372</pub-id>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>WY</given-names>
          </name>
          <name>
            <surname>Barratt</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Clayton</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Todd</surname>
            <given-names>JA</given-names>
          </name>
        </person-group>
        <article-title>Genome-wide association studies: theoretical and practical concerns</article-title>
        <source>Nature Reviews Genetics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>109</fpage>
        <lpage>118</lpage>
        <pub-id pub-id-type="pmid">15716907</pub-id>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Clayton</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>SNPHAP: A program for estimating frequencies of large haplotypes of SNPs</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www-gene.cimr.cam.ac.uk/clayton/software/snphap.txt"/>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hudson</surname>
            <given-names>RR</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Futuyma D, Antonovics J</surname>
          </name>
        </person-group>
        <article-title>Gene genealogies and the coalescent process</article-title>
        <source>Oxford surveys in evolutionary biology</source>
        <year>1990</year>
        <volume>7</volume>
        <publisher-name>Oxford University Press, Oxford</publisher-name>
        <fpage>1</fpage>
        <lpage>44</lpage>
      </citation>
    </ref>
    <ref id="B21">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Scheet</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Stephens</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A Fast and Flexible Statistical Model for Large-Scale Population Genotype Data: Applications to Inferring Missing Genotypes and Haplotypic Phase</article-title>
        <source>Am J Hum Genet</source>
        <year>2006</year>
        <volume>78</volume>
        <fpage>629</fpage>
        <lpage>644</lpage>
        <pub-id pub-id-type="pmid">16532393</pub-id>
      </citation>
    </ref>
    <ref id="B22">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Eronen</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Geerts</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Toivonen</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>A Markov chain approach to reconstruction of long haplotypes</article-title>
        <source>Pacific Symposium on Biocomputing 2004 (PSB 2004)</source>
        <year>2004</year>
        <publisher-name>Hawaii, USA: World Scientific</publisher-name>
        <fpage>104</fpage>
        <lpage>115</lpage>
      </citation>
    </ref>
    <ref id="B23">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <collab>The International HapMap Consortium</collab>
        </person-group>
        <article-title>The International HapMap project</article-title>
        <source>Nature</source>
        <year>2003</year>
        <volume>426</volume>
        <fpage>789</fpage>
        <lpage>796</lpage>
        <pub-id pub-id-type="pmid">14685227</pub-id>
      </citation>
    </ref>
    <ref id="B24">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hudson</surname>
            <given-names>RR</given-names>
          </name>
        </person-group>
        <article-title>Generating samples under a Wright-Fisher neutral model of genetic variation</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <fpage>337</fpage>
        <lpage>338</lpage>
        <pub-id pub-id-type="pmid">11847089</pub-id>
      </citation>
    </ref>
    <ref id="B25">
      <citation citation-type="other">
        <article-title>The HapMap database</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.hapmap.org/genotypes/2005-10/non-redundant"/>
      </citation>
    </ref>
    <ref id="B26">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Daly</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Rioux</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Schaffner</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Hudson</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Lander</surname>
            <given-names>ES</given-names>
          </name>
        </person-group>
        <article-title>High-resolution haplotype structure in the human genome</article-title>
        <source>Nature Genetics</source>
        <year>2001</year>
        <volume>29</volume>
        <fpage>229</fpage>
        <lpage>232</lpage>
        <pub-id pub-id-type="pmid">11586305</pub-id>
      </citation>
    </ref>
    <ref id="B27">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morris</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Whittaker</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Balding</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Little loss of information due to unknown phase for fine-scale linkage-disequilibrium mapping with single-nucleotide-polymorphism genotype data</article-title>
        <source>The American Journal of Human Genetics</source>
        <year>2004</year>
        <volume>74</volume>
        <fpage>945</fpage>
        <lpage>953</lpage>
      </citation>
    </ref>
    <ref id="B28">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Curtis</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Sham</surname>
            <given-names>PC</given-names>
          </name>
        </person-group>
        <article-title>Estimated Haplotype Counts from Case-Control Samples Cannot Be Treated as Observed Counts</article-title>
        <source>American Journal of Human Genetics</source>
        <year>2006</year>
        <volume>78</volume>
        <fpage>729</fpage>
        <lpage>730</lpage>
        <pub-id pub-id-type="pmid">16532404</pub-id>
      </citation>
    </ref>
    <ref id="B29">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hintsanen</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Sevon</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Onkamo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Eronen</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Toivonen</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>An empirical comparison of case – control and trio-based study designs in high-throughput association mapping</article-title>
        <source>Journal of Medical Genetics</source>
        <year>2006</year>
        <volume>43</volume>
        <fpage>617</fpage>
        <lpage>624</lpage>
        <pub-id pub-id-type="pmid">16258007</pub-id>
      </citation>
    </ref>
    <ref id="B30">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ron</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Singer</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tishby</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Cowan JD, Tesauro G, Alspector J</surname>
          </name>
        </person-group>
        <article-title>The Power of Amnesia</article-title>
        <source>Advances in Neural Information Processing Systems</source>
        <year>1994</year>
        <volume>6</volume>
        <publisher-name>Morgan Kaufmann Publishers, Inc</publisher-name>
        <fpage>176</fpage>
        <lpage>183</lpage>
      </citation>
    </ref>
    <ref id="B31">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Kermorvant</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Dupont</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Improved Smoothing for Probabilistic Suffix Trees Seen as Variable Order Markov Chains</article-title>
        <source>Proceedings of the 12th European Conference on Machine Learning, Springer</source>
        <year>2002</year>
        <fpage>185</fpage>
        <lpage>194</lpage>
      </citation>
    </ref>
    <ref id="B32">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kruglyak</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Prospects for whole-genome linkage disequilibrium mapping of common disease genes</article-title>
        <source>Nature Genetics</source>
        <year>1999</year>
        <volume>22</volume>
        <fpage>139</fpage>
        <lpage>144</lpage>
        <pub-id pub-id-type="pmid">10369254</pub-id>
      </citation>
    </ref>
    <ref id="B33">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Akey</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jin</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Xiong</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Haplotypes <italic>vs </italic>single marker linkage disequilibrium tests: what do we gain?</article-title>
        <source>European Journal of Human Genetics</source>
        <year>2001</year>
        <volume>9</volume>
        <fpage>291</fpage>
        <lpage>300</lpage>
        <pub-id pub-id-type="pmid">11313774</pub-id>
      </citation>
    </ref>
    <ref id="B34">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Begleiter</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>El-Yaniv</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Yona</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>On Prediction Using Variable Order Markov Models</article-title>
        <source>Journal of Artificial Intelligence Research</source>
        <year>2004</year>
        <volume>22</volume>
        <fpage>385</fpage>
        <lpage>421</lpage>
      </citation>
    </ref>
  </ref-list>
</back>
