<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4058940</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu280</article-id>
    <article-id pub-id-type="publisher-id">btu280</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb 2014 Proceedings Papers Committee</subject>
        <subj-group subj-group-type="heading">
          <subject>Original Papers</subject>
          <subj-group subj-group-type="heading">
            <subject>Sequence Analysis</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Ragout—a reference-assisted assembly tool for bacterial genomes</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Kolmogorov</surname>
          <given-names>Mikhail</given-names>
        </name>
        <xref ref-type="aff" rid="btu280-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu280-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Raney</surname>
          <given-names>Brian</given-names>
        </name>
        <xref ref-type="aff" rid="btu280-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Paten</surname>
          <given-names>Benedict</given-names>
        </name>
        <xref ref-type="aff" rid="btu280-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pham</surname>
          <given-names>Son</given-names>
        </name>
        <xref ref-type="aff" rid="btu280-AFF1">
          <sup>4</sup>
        </xref>
        <xref ref-type="corresp" rid="btu280-COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="btu280-AFF1"><sup>1</sup>St. Petersburg University of the Russian Academy of Sciences, <sup>2</sup>Bioinformatics Institute, St. Petersburg, Russia, <sup>3</sup>UCSC, 1156 High Street, Santa Cruz, CA and <sup>4</sup>Department of Computer Science and Engineering, UCSD, 9500 Gilman Drive, La Jolla, CA, USA</aff>
    <author-notes>
      <corresp id="btu280-COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>12</issue>
    <fpage>i302</fpage>
    <lpage>i309</lpage>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">http://creativecommons.org/licenses/by-nc/3.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Summary:</bold> Bacterial genomes are simpler than mammalian ones, and yet assembling the former from the data currently generated by high-throughput short-read sequencing machines still results in hundreds of contigs. To improve assembly quality, recent studies have utilized longer Pacific Biosciences (PacBio) reads or jumping libraries to connect contigs into larger scaffolds or help assemblers resolve ambiguities in repetitive regions of the genome. However, their popularity in contemporary genomic research is still limited by high cost and error rates. In this work, we explore the possibility of improving assemblies by using complete genomes from closely related species/strains. We present <italic>Ragout</italic>, a genome rearrangement approach, to address this problem. In contrast with most reference-guided algorithms, where only one reference genome is used, <italic>Ragout</italic> uses multiple references along with the evolutionary relationship among these references in order to determine the correct order of the contigs. Additionally, Ragout uses the assembly graph and multi-scale synteny blocks to reduce assembly gaps caused by small contigs from the input assembly. In simulations as well as real datasets, we believe that for common bacterial species, where many complete genome sequences from related strains have been available, the current high-throughput short-read sequencing paradigm is sufficient to obtain a single high-quality scaffold for each chromosome.</p>
      <p><bold>Availability:</bold> The <italic>Ragout</italic> software is freely available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/fenderglass/Ragout">https://github.com/fenderglass/Ragout</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>spham@salk.edu</email>
      </p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>The recent proliferation of next-generation sequencing with short reads has enabled many new experimental opportunities, but it has also raised formidable computational challenges in genome assembly. Even for relatively simple bacterial genomes, their assemblies from current generation of high-throughput short reads are still fragmented with hundreds of contigs. To improve the assembly’s quality, recent studies have utilized longer Pacific Biosciences (PacBio) reads or jumping libraries to connect contigs into larger scaffolds or help assemblers resolve ambiguities in repetitive regions of the genome (<xref rid="btu280-B3" ref-type="bibr">Bashir, 2012</xref>; <xref rid="btu280-B6" ref-type="bibr">Deshpande, 2013</xref>; <xref rid="btu280-B10" ref-type="bibr">Koren, 2012</xref>). However, their popularity in current genomic research is still limited by high cost and error rates.</p>
    <p>When a related genome is available, an alternative approach is to use this genome to guide the assembly of the target genome, in a method called ‘reference-assisted assembly’. The first reference-assisted assembly tools aligned contigs against the reference and ordered them according to their positions in the reference genome. While this approach is still commonly used, it introduces errors when structural variations between the reference and the assembled (target) genome are present. In an attempt to address this problem, Gaul and Blanchette (<xref rid="btu280-B8" ref-type="bibr">Gaul and Blanchette, 2006</xref>) formulated the <italic>contig ordering problem</italic>, which attempts to order contigs so that the 2-break distance (DCJ distance) (<xref rid="btu280-B1" ref-type="bibr">Alekseyev and Pevzner, 2009</xref>; <xref rid="btu280-B5" ref-type="bibr">Bergeron <italic>et al.</italic>, 2006</xref>) between the resulting scaffold and the reference genome is minimized. This formulation has been further applied in some reference-guided assembly tools (<xref rid="btu280-B15" ref-type="bibr">Richter <italic>et al.</italic>, 2007</xref>; <xref rid="btu280-B16" ref-type="bibr">Rissman <italic>et al.</italic>, 2009</xref>). Unfortunately, while the approach is theoretically sound, these tools still generate erroneous scaffolds when there are rearrangements between the target and reference genomes. This poses an important question: is a single reference genome sufficient to obtain a single scaffold (for each chromosome) without errors?</p>
    <p>Recently, <xref rid="btu280-B9" ref-type="bibr">Kim <italic>et al.</italic> (2013)</xref> introduced RACA software, which made an important step toward reliable reconstruction of the target (assembled) genome. In contrast to other tools, which use only one reference, RACA utilizes a reference as well as multiple outgroups to guide the assembly. This approach proved to be valuable, since the adjacency information in the outgroups can also help infer the adjacencies in the target assembly.</p>
    <p>Although RACA marked an important advancement in the reference-guided assembly problem, it still suffers some limitations. First, RACA uses information from outgroup genomes, but it heavily relies on a single reference. As with any genome rearrangement tools, RACA decomposes these sequences into synteny blocks. However, rather than constructing synteny blocks by considering all input sequences, RACA constructs synteny blocks based on pairwise sequence alignment against only the reference genome. This approach, in some cases, cannot detect synteny blocks (<xref rid="btu280-B14" ref-type="bibr">Pham and Pevzner, 2010</xref>) and also raises the question of what to do with assembly sequences (contigs) that do not align against the reference. Second, unlike synteny blocks constructed from complete genomes, synteny blocks constructed in the presence of contigs can be fragmented, since assemblies usually have contigs of various lengths. Constructing synteny blocks from fragmented assemblies raises a problem: on which scale should synteny blocks be constructed? If one constructs large-scale synteny blocks, then small and fragmented synteny blocks (within small contigs) are not considered, thus leading to gaps in the assembly. On the other hand, if one constructs small-scale synteny blocks, then the rearrangement analysis becomes harder, since smaller synteny blocks are more likely to exhibit structural variations and are also more susceptible to be incorrectly identified (i.e. false synteny blocks). This dilemma must be addressed in order to obtain high-quality scaffolds.</p>
    <p>In this work, we present <italic>Ragout</italic> (<italic>Reference-Assisted Genome Ordering UTility</italic>), a genome rearrangement approach for reference-assisted assembly that can produce high-quality scaffolds with a small number of misordered contigs and high genome coverage. Rather than working with a single reference, Ragout uses multiple complete genomes from closely related species/strains. In contrast with most existing tools, in which only a fixed scale of synteny blocks is used, our algorithm works iteratively with different scales of synteny blocks and also utilizes the assembly graph to improve scaffolds.</p>
    <p>We demonstrate that with multiple references, Ragout significantly improves the assembly of the target genome compared to existing tools. Through simulations as well as real datasets, we believe that for common bacterial species, for which many complete genome sequences from related strains have been made available, the current high-throughput short-read-sequencing paradigm is sufficient to assemble into a single high-quality scaffold. The Ragout software is freely available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/fenderglass/Ragout">https://github.com/fenderglass/Ragout</ext-link>.</p>
  </sec>
  <sec>
    <title>2 METHODS</title>
    <sec id="SEC2.1">
      <title>2.1 Algorithm overview</title>
      <p>Ragout takes as input:
<list list-type="bullet"><list-item><p>an assembly (a set of contigs);</p></list-item><list-item><p>a set of related genomes; and</p></list-item><list-item><p>a phylogenetic tree of all the genomes (including the target assembly).</p></list-item></list>
</p>
      <p>It outputs high-quality scaffolds in the form of ordered lists of contigs.</p>
      <p>Ragout first decomposes the input sequences into synteny blocks using Sibelia software (<xref rid="btu280-B12" ref-type="bibr">Minkin <italic>et al.</italic>, 2013</xref>). After this stage, these sequences are represented in the alphabet of synteny blocks instead of as strings of nucleotides. While each reference sequence is transformed into a single sequence of synteny blocks (a list of signed numbers), the assembly corresponds to multiple sequences of synteny blocks because the target genome has been fragmented into multiple contigs.</p>
      <p>Due to this fragmentation, some adjacency information is missing. Ragout uses a genome-rearrangement approach to infer these missing adjacencies. Initially, we filter all repetitive blocks as well as blocks that are not present in the target assembly, since these kinds of synteny blocks are hurdles in most current genome-rearrangement algorithms. From the remaining blocks, we build an <italic>incomplete multi-color breakpoint graph</italic>, in which vertices correspond to the ends of synteny blocks and edges represent adjacencies between them. Ragout further solves the <italic>Half-breakpoint State Parsimony Problem</italic> to transform this graph to the ‘normal’ multi-color breakpoint graph (<xref rid="btu280-B1" ref-type="bibr">Alekseyev and Pevzner, 2009</xref>) by recovering missing adjacencies in the target assembly. Next, contigs are assembled into scaffolds with respect to the inferred adjacencies. The above procedure is repeated multiple times with different synteny block scales, and the resulting scaffolds in these iterations are reconciled into a single set of scaffolds. Afterwards, a refinement step is performed. In this step, small and repetitive contigs are recovered and inserted back into the scaffolds by using the adjacency information from the assembly graph. The pseudocode of Ragout is described in Algorithm 1.<boxed-text id="btu280-BOX1" position="float"><caption><title><bold>Algorithm </bold><bold>1</bold> Ragout pseudocode</title></caption><p><bold>procedure</bold><sc>Ragout</sc>(<italic>references, target, phylogeny, blockSizes</italic>)</p><p> <italic>assemblies</italic>
<inline-formula><mml:math id="n1"><mml:mrow><mml:mo>←</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula></p><p> <bold>for </bold><bold>all</bold>
<italic>blockSize</italic> in <italic>blockSizes</italic>
<bold>do</bold></p><p>  <italic>synBlocks</italic> ← <sc>RunSibelia</sc>(<italic>references, target, blockSize</italic>)</p><p>  <italic>bpGraph</italic> ← <sc>BuildBreakpointGraph</sc>(<italic>synBlocks</italic>)</p><p>  <italic>weightedGraph</italic> ← <sc>EdgesScore</sc>(<italic>bpGraph, phylogeny</italic>)</p><p>  <italic>adjacencies</italic> ← <sc>MinPerfMatching</sc>(<italic>weightedGraph</italic>)</p><p>  <italic>scaffolds</italic> ← <sc>BuildScaffolds</sc>(<italic>target, adjacencies</italic>)</p><p>  <sc>Add</sc>(<italic>scaffolds, assemblies</italic>)</p><p> <bold>end for</bold></p><p> <italic>scaffolds</italic> ← <sc>MergeIterations</sc>(<italic>assemlies</italic>)</p><p> <italic>assemblyGraph</italic> ← <sc>BuildAssemblyGraph</sc>(<italic>target</italic>)</p><p> <italic>scaffolds</italic> ← <sc>RefineScaffolds</sc>(<italic>scaffolds, assemblyGraph</italic>)</p><p> <sc>OutputScaffolds</sc>(<italic>scaffolds</italic>)</p><p><bold>end procedure</bold></p></boxed-text></p>
      <p>Since the synteny block-reconstruction algorithm used in Ragout has been described in (<xref rid="btu280-B12" ref-type="bibr">Minkin <italic>et al.</italic>, 2013</xref>), we will not describe it in this article. Below, we delve into the details of Ragout algorithm, assuming that synteny blocks have already been constructed.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 A genome-rearrangement approach for recovering missing adjacencies</title>
      <p>Given reference sequences and assembly in the alphabet of synteny blocks, our task is to recover the missing adjacencies of synteny blocks in the target assembly. While breakpoint graphs best capture adjacency information, they have thus far only been defined for complete genomes. Below, we introduce <italic>incomplete multi-color breakpoint graphs</italic> for presenting synteny block adjacencies in the assembly and reference sequences.</p>
      <sec id="SEC2.2.1">
        <title>2.2.1 Incomplete multi-color breakpoint graphs</title>
        <p>Given an assembly <italic>A</italic> and <italic>k</italic> reference sequences <italic>P</italic><sub>1</sub>, … , <italic>P<sub>k</sub></italic> in the alphabet of synteny blocks <italic>B</italic>, we define the <italic>incomplete multi-color breakpoint graph BG</italic>(<italic>A</italic>, <italic>P</italic><sub>1</sub>, … , <italic>P<sub>k</sub></italic>) = (<italic>V</italic>, <italic>E</italic>), where <inline-formula><mml:math id="n10"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi></mml:msubsup><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>B</mml:mi><mml:mo>}</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> For each synteny block, there are two vertices in the graph which correspond to the tail and head of the block. Edges are undirected and colored by <italic>k</italic> + 1 colors. An edge connects vertices that correspond to heads/tails of adjacent synteny blocks and is colored by the corresponding color of the genome/assembly. To simplify the notation, we use <italic>red</italic>, <italic>P</italic><sub>1</sub>, … , <italic>P<sub>k</sub></italic> to refer to the colors of edges, where <italic>red</italic> edges represent the adjacencies of synteny blocks in the target assembly <italic>A</italic>, and <italic>P<sub>i</sub></italic> represents the adjacencies of synteny blocks in genome <italic>P<sub>i</sub></italic> (see <xref ref-type="fig" rid="btu280-F1">Fig. 1</xref>A).
<fig id="btu280-F1" position="float"><label>Fig. 1.</label><caption><p>(a) A breakpoint graph of three reference genomes and one assembly. The three reference genomes (<italic>Ref1</italic>, <italic>Ref2</italic> and <italic>Ref3</italic>) are presented as cyclic permutations of synteny blocks: <italic>Ref1</italic>(<italic>blue</italic>): + 1 +2 +3 +4 +5, <italic>Ref2</italic>(<italic>green</italic>): + 1 +3 +4 +5 and <italic>Ref3</italic>(<italic>orange</italic>): + 1 − 4 – 3 + 5, respectively. The target assembly (red) is presented as four separated permutations (corresponds to four contigs): <italic>Target Assembly</italic>: <inline-formula><mml:math id="n11"><mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mspace width=".3em"/><mml:mo stretchy="false">|</mml:mo><mml:mo>
</mml:mo><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>
</mml:mo><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mspace width=".3em"/><mml:mo stretchy="false">|</mml:mo><mml:mo>
</mml:mo><mml:mo>+</mml:mo><mml:mn>4</mml:mn><mml:mspace width=".3em"/><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mn>5.</mml:mn></mml:mrow></mml:math></inline-formula> (b) A phylogenetic tree representing the states of the <italic>half-breakpoint</italic> 5<italic><sup>h</sup></italic>. Each leaf is labeled by the state of the half-breakpoint 5<italic><sup>h</sup></italic> in the corresponding reference/target genome. (According to this tree, the state of 5<italic><sup>h</sup></italic> in the target genome is 4<italic><sup>t</sup></italic>, although the correct state of 5<italic><sup>h</sup></italic> in the target genome is unknown.)</p></caption><graphic xlink:href="btu280f1"/></fig></p>
        <p>Before constructing the graph, we filter synteny blocks from reference genomes that are not present in the target assembly, since these synteny blocks do not help to infer the adjacencies in the target genome. Also, we filter synteny blocks that have multiple copies within any sequences, since duplicated synteny blocks make further analysis in the breakpoint graph complicated.</p>
        <p>After this filtering, the constructed graph has two important properties: (i) each vertex has at most one edge of each color (since all repetitive synteny blocks are removed), and (ii) each vertex corresponds to a certain synteny block in the target genome. Therefore, if the target genome were available, the set of all <italic>red</italic> edges would define a perfect matching in the graph. However, since the genome is fragmented into contigs, the adjacency information of the target genome at the vertices that correspond to the end of contigs is missing. The main task is to infer these missing <italic>red</italic> edges in the graph using other adjacencies from the reference genomes as well as using their evolutionary relationship in the form of a phylogenetic tree.</p>
      </sec>
      <sec id="SEC2.2.2">
        <title>2.2.2 The phylogenetic tree</title>
        <p>Let <italic>T</italic> be a rooted phylogenetic tree of the genomes <italic>A</italic>, <italic>P</italic><sub>1</sub>, … , <italic>P<sub>k</sub></italic>. <italic>T</italic> consists of <italic>k</italic> + 1 leaves, (<italic>k </italic>– 1) internal nodes of degree three, and one node of degree two (called the <italic>root</italic>). Edges connecting two nodes are called <italic>branches</italic>. Branch length represents evolution time (evolution time is usually inferred from the number of nucleotide substitutions in sequence alignment).</p>
        <sec>
          <title>A parsimonious model for rearrangements</title>
          <p>Given a tree T with all of its <italic>k</italic> + 1 leaves represented as complete genomes (in the alphabet of synteny blocks), the <italic>parsimony procedure</italic> (<xref rid="btu280-B7" ref-type="bibr">Fitch, 1971</xref>; <xref rid="btu280-B17" ref-type="bibr">Sankoff, 1975</xref>) explains the descent of these various sequences from a common ancestor with the fewest number of changing operations, associated with a minimum cost value. When one of these genomes is divided into contigs, a possible formulation for recovering the target genome corresponds to finding a permutation of these contigs such that the <italic>parsimony procedure</italic> returns the lowest cost among all possible orderings of these contigs. Note that this is a double optimization. One step finds the most parsimonious explanation for a given configuration of the target genome, while the other step finds the configuration of the target genome having lowest cost. The usual (and more correct) choice for the allowed operation in the first optimization is the 2-break operation (also called a DCJ operation) since it can well approximate many real rearrangement operations (<xref rid="btu280-B1" ref-type="bibr">Alekseyev and Pevzner, 2009</xref>). However, accounting for such an operation will lead to an NP-complete problem (<xref rid="btu280-B11" ref-type="bibr">Ma <italic>et al.</italic>, 2006</xref>). In this work, rather than using the 2-break operation, we study the parsimonious approach on individual breakpoints. While considering breakpoints individually may not adequately reflect the reality of rearrangements (since each rearrangement uses at least two breakpoints), this method is computationally feasible and has been proven to be valuable in the problem of ancestral genome reconstruction (<xref rid="btu280-B11" ref-type="bibr">Ma <italic>et al.</italic>, 2006</xref>).</p>
          <p>In the breakpoint graph <italic>BG</italic>(<italic>A</italic>, <italic>P<sub>i</sub></italic>, … , <italic>P<sub>k</sub></italic>), we call each vertex a <italic>half-breakpoint</italic> (since a breakpoint involves two synteny block ends). For a given genome <italic>P<sub>i</sub></italic>, the <italic>state</italic> of a half-breakpoint <italic>v<sub>i</sub></italic> is defined as the half-breakpoint adjacent to it, i.e. the vertex <italic>v<sub>j</sub></italic>, such that the color of the edge (<italic>v<sub>i</sub></italic>, <italic>v<sub>j</sub></italic>) is <italic>P<sub>i</sub></italic> (color) in <italic>BG</italic>. Because of the first graph property described above, each <italic>half-breakpoint</italic> has at most one such state. If the synteny block corresponding to <italic>v<sub>i</sub></italic> is missing in a genome, the state <italic>v<sub>i</sub></italic> is <italic>void</italic> (see <xref ref-type="fig" rid="btu280-F1">Fig. 1</xref>B).</p>
          <p>Rather than using the parsimony procedure with 2-break operations, we study the parsimony procedure with respect to the change of half-breakpoint’s states for each vertex in the breakpoint graph. The cost associated with a state change along a branch <italic>b</italic> of length τ in the phylogenetic tree is <inline-formula><mml:math id="n12"><mml:mrow><mml:mi>W</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mi>τ</mml:mi></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Intuitively, the longer a branch, the more likely a half-breakpoint state can change along it, and therefore the smaller the corresponding cost. Next, we formulate the <italic>Half-breakpoint State Parsimony Problem</italic> in order to infer the evolutionary scenario of a particular half-breakpoint.</p>
        </sec>
      </sec>
      <sec id="SEC2.2.3">
        <title>2.2.3 Half-breakpoint state parsimony</title>
        <p>Given a half-breakpoint u and the phylogenetic tree T, each leaf of which is labeled by state(u) in each corresponding genome. Label the internal nodes of T in order to minimize the total cost needed to derive the leaves’ states from their common ancestor.</p>
        <p>Below is a linear time algorithm for solving this problem. The solution for this problem mimics Sankoff’s dynamic programming algorithm for the weighted small parsimony problem. The optimality proof is perfectly analogous to Sankoff’s proof (<xref rid="btu280-B17" ref-type="bibr">Sankoff, 1975</xref>).
<list list-type="bullet"><list-item><p><italic>Input:</italic><inline-formula><mml:math id="n13"><mml:mrow><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each leaf node of tree.</p></list-item><list-item><p><italic>Output:</italic><inline-formula><mml:math id="n14"><mml:mrow><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each internal node, along with the corresponding cost.</p></list-item><list-item><p><italic>Objective function: s<sub>t</sub></italic>(<italic>v</italic>) = minimum score of the subtree rooted at vertex <italic>v</italic> if <italic>v</italic> has state <italic>t</italic>.</p></list-item><list-item><p><italic>Initialization:</italic> for each leaf node <italic>l</italic>: <italic>s<sub>t</sub></italic>(<italic>l</italic>) = 0 if the state of leaf node is <italic>t</italic>, otherwise <italic>s<sub>t</sub></italic>(<italic>l</italic>) = <italic>∞</italic>.</p></list-item><list-item><p><italic>Recursion:</italic> The score at each vertex is based on the scores of its children:
<disp-formula><graphic xlink:href="btu280um1.jpg" position="float"/></disp-formula>
<inline-formula><mml:math id="n15"><mml:mrow><mml:mtext>where </mml:mtext><mml:msub><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mtext>
</mml:mtext><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mtext> and </mml:mtext><mml:mn>1</mml:mn><mml:mtext> otherwise.</mml:mtext></mml:mrow></mml:math></inline-formula></p></list-item></list>
<list list-type="bullet"><list-item><p><italic>Termination:</italic><inline-formula><mml:math id="n16"><mml:mrow><mml:msub><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow><mml:mi>a</mml:mi></mml:msub><mml:msub><mml:mi>s</mml:mi><mml:mi>a</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mtext>root</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><italic>Complexity: O</italic>(<italic>n·d</italic>), where <italic>n</italic> is the number of leaves and <italic>d</italic> is the number of possible states.</p></list-item></list>
</p>
        <p>When all the internal nodes of the tree have already been labeled, the cost of <italic>half-breakpoint state parsimony</italic> of the half-breakpoint <italic>u</italic> can be calculated by summing the cost in all the branches that the state changes.
<disp-formula id="btu280-M1"><label>(1)</label><mml:math id="n19"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mtext>branch</mml:mtext><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mi>W</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtext>branchlength</mml:mtext></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
</p>
      </sec>
      <sec id="SEC2.2.4">
        <title>2.2.4 Recovering missing adjacencies</title>
        <p>Since the <italic>half-breakpoint state parsimony problem</italic> can be solved efficiently, the remaining question is to recover all missing adjacencies such that <inline-formula><mml:math id="n17"><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:msub><mml:mi>P</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>—the total cost of all half-breakpoints in <italic>G</italic>—is minimal. Since we filtered all duplicated synteny blocks as well as synteny blocks that do not appear in the target assembly, adjacencies in the target genome define a perfect matching in the graph. The cost of this matching is defined to be the sum of the half-breakpoint parsimony cost of all vertices (half-breakpoints).</p>
        <p>For each vertex that is not incident to a red edge in the breakpoint graph, the Ragout algorithm finds the cost for the <italic>half-breakpoint state parsimony problem</italic> on each of its possible states. These states are chosen from the vertex’s adjacent vertices in the breakpoint graph. Since choosing a state for a particular half-breakpoint corresponds to choosing an edge incident to it, for each edge in the breakpoint graph, two such cost values are calculated. We assign the weight of each edge as the sum of these two values. As some adjacencies in the target genome are already known (vertices incident to a red edge), we can also remove those vertices from the graph before applying the Blossom algorithm to find the perfect matching with minimum cost (in <italic>O</italic>(|<italic>V</italic> |<sup>4</sup>) time) and add corresponding edges into the final matching afterwards. This matching defines the optimal adjacencies in the target genome.</p>
      </sec>
      <sec id="SEC2.2.5">
        <title>2.2.5 Building scaffolds</title>
        <p>Finally, we order contigs into scaffolds. Starting from one contig, we try to extend it in both the forward and backward directions, using the inferred adjacencies from the matching above.</p>
      </sec>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 The choice of minimum synteny block size and iterative assembly</title>
      <p>Since synteny block reconstruction is a parameter-dependent procedure, and the choice of parameters depends on the ‘synteny block scale’ required in each particular application, an important question to ask is: which scale of synteny blocks should one use for reference-assisted assembly? We argue that using a single scale of synteny blocks is not sufficient to obtain high-quality scaffolds. If one constructs large-scale synteny blocks, then small and fragmented synteny blocks (coming from small contigs and micro-rearrangements) are not considered, thus leading to gaps in the assembly. On the other hand, if one constructs small-scale synteny blocks, then rearrangement analysis becomes more difficult, since small-scale blocks are more likely to exhibit structural variations and are also more susceptible to be incorrectly identified (false synteny blocks). To resolve this dilemma, we use multiple synteny block scales in order to build multiple scaffolds and then reconcile these scaffolds.</p>
      <p>Consider two scaffolds <italic>A<sub>s</sub></italic> and <italic>A<sub>w</sub></italic> constructed from large- and small-scales of synteny blocks, respectively. A contig is called <italic>strong</italic> if it is in the scaffold <italic>A<sub>s</sub></italic> and called <italic>weak</italic> if it is in <italic>A<sub>w</sub></italic> and not in <italic>A<sub>s</sub></italic>. Two scaffolds <italic>A<sub>s</sub></italic> and <italic>A<sub>w</sub></italic> are called <italic>consistent</italic> if every pair of adjacent contigs in <italic>A<sub>s</sub></italic> is either adjacent or separated by only weak contigs in <italic>A<sub>w</sub></italic>. Although the order of contigs in <italic>A<sub>s</sub></italic> is more reliable than in <italic>A<sub>w</sub></italic>, there are many small synteny blocks that do not reveal in <italic>A<sub>s</sub></italic> and only appear in the ‘finer’ scaffold <italic>A<sub>w</sub></italic>. We therefore rely on the ‘skeleton of contigs’ in <italic>A<sub>s</sub></italic> and insert smaller contigs from <italic>A<sub>w</sub></italic> if they are consistent (see <xref ref-type="fig" rid="btu280-F2">Fig. 2</xref>).
<fig id="btu280-F2" position="float"><label>Fig. 2.</label><caption><p>Merging two scaffolds <italic>A<sub>s</sub></italic> and <italic>A<sub>w</sub></italic> built from two different synteny scales into a scaffold <italic>M</italic>. Yellow rectangles represent <italic>weak</italic> contigs. (a) <italic>A<sub>s</sub></italic> and <italic>A<sub>w</sub></italic> are consistent. (b) <italic>A<sub>s</sub></italic> and <italic>A<sub>w</sub></italic> are not consistent</p></caption><graphic xlink:href="btu280f2"/></fig></p>
      <p>The merged scaffold is therefore consistent with <italic>A<sub>s</sub></italic>. We successively apply the described procedure to scaffolds in different stages (sorted by the scale of synteny blocks) until we reach the stage with the smallest scale.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Refinement with the assembly graph</title>
      <p>While the iterative procedure attempts to maximize the number of contigs used to build the scaffold, there are still some certain types of contigs that cannot be utilized in that stage. These contigs include: (i) contigs that are shorter than minimum synteny block size that existing synteny block tools can detect (several hundred nucleotides), (ii) contigs contained only in the target genome and (iii) repetitive contigs. Such fragments are not considered in the rearrangement analysis and will therefore not appear in the merged scaffolds. To add these fragments, we need to use the assembly graph, which has been output by short-read assemblers and can also be independently constructed from input contigs. The genome traverses the graph with a certain unknown path. However, since initial scaffolds are now available, we can use these scaffolds to restore small or repetitive fragments. This problem is analogous to the problem of repeat resolution in short-read assembly. Instead of paired-read information, we have pairs of adjacent contigs built during the rearrangement analysis stage.</p>
      <p>Given an assembly graph and a set of merged scaffolds from the previous step of the algorithm, for each pair of consecutive contigs from these scaffolds we find all possible paths connecting them in the assembly graph that do not contain contigs from the scaffold. If there exists only one such path, we insert all the intermediate contigs along this path between the two contigs (see <xref ref-type="fig" rid="btu280-F3">Fig. 3</xref>). This procedure significantly improves the number of used contigs in most datasets.
<fig id="btu280-F3" position="float"><label>Fig. 3.</label><caption><p>Refinement with the assembly graph. The procedure fills scaffold gaps with small contigs. The big circles illustrate contigs with known order, while small ones correspond to contigs that were not considered in rearrangement analysis</p></caption><graphic xlink:href="btu280f3"/></fig></p>
    </sec>
  </sec>
  <sec>
    <title>3 RESULTS</title>
    <p>We benchmarked Ragout against other reference-assisted assembly tools [Mauve Contig Mover (<xref rid="btu280-B16" ref-type="bibr">Rissman <italic>et al.</italic>, 2009</xref>), OSLay (<xref rid="btu280-B15" ref-type="bibr">Richter <italic>et al.</italic>, 2007</xref>), RACA (<xref rid="btu280-B9" ref-type="bibr">Kim <italic>et al.</italic>, 2013</xref>)] on one simulated and three real bacterial datasets. Since the complete sequences of target genomes are available, we can also assess the quality of the resulting scaffolds by the number of <italic>misordered contigs</italic>, <italic>scaffold gaps</italic> and <italic>coverage</italic>.</p>
    <p>As each output scaffold is an ordered list of contigs, we define the number of <italic>misordered contigs</italic> as the minimum number of contigs in the scaffolds whose mapping positions or directions are not consistent with the mapping positions and directions of the contigs before and after them. Also, we define the number of <italic>gaps</italic> in a scaffold as the number of contig pairs that are adjacent in a scaffold, but are separated by some other contigs when we map all contigs to the reference genome. The <italic>coverage</italic> is defined as the total number of aligned bases against the reference, divided by the genome size.</p>
    <p>Mauve Contig Mover and OSLay were run with parameters recommended for bacterial genomes. For Ragout, we ran three iterations with the corresponding minimum synteny block sizes: 5000, 500, 100, as they are the default scales used in Sibelia (<xref rid="btu280-B12" ref-type="bibr">Minkin <italic>et al.</italic>, 2013</xref>) for bacterial genomes. Since RACA works with only one synteny block size, we chose the maximal synteny block scale (most reliable).</p>
    <sec id="SEC3.1">
      <title>3.1 Assembly using one closely related reference</title>
      <p>First, we benchmark these tools on an easy case in which the target and reference genomes do not exhibit any structural variations. In this situation, one reference is sufficient to obtain the correct assembly. This also allows us to compare Ragout with MCM and OSLay, which can work only with one reference.</p>
      <p>The dataset consists of two different <italic>Escherichia coli</italic> strains: <italic>DH1</italic> (NC_017625) as the reference and <italic>K-12 subs. MG1655 (NC_000913)</italic> as the target. The contigs were assembled with SPAdes assembler (<xref rid="btu280-B2" ref-type="bibr">Bankevich <italic>et al.</italic>, 2012</xref>). The results can be seen in <xref ref-type="table" rid="btu280-T1">Table 1</xref>. Ragout and MCM are able to recover one complete scaffold, while OSLay outputs eight scaffolds. The quality of Ragout’s assembly without refinement is quite similar to MCM, but with refinement Ragout uses significantly more contigs and produces fewer gaps in the final scaffolds.
<table-wrap id="btu280-T1" position="float"><label>Table 1.</label><caption><p>Comparison of different tools using one reference</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">Ragout</th><th rowspan="1" colspan="1">MCM</th><th rowspan="1" colspan="1">OSLay</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Scaffolds</td><td rowspan="1" colspan="1">1 (1)</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">8</td></tr><tr><td rowspan="1" colspan="1">Coverage</td><td rowspan="1" colspan="1">97.9 (97.6)</td><td rowspan="1" colspan="1">97.6</td><td rowspan="1" colspan="1">96.7</td></tr><tr><td rowspan="1" colspan="1">Ordered contigs</td><td rowspan="1" colspan="1">129 (79)</td><td rowspan="1" colspan="1">77</td><td rowspan="1" colspan="1">80</td></tr><tr><td rowspan="1" colspan="1">Gaps</td><td rowspan="1" colspan="1">52 (71)</td><td rowspan="1" colspan="1">73</td><td rowspan="1" colspan="1">61</td></tr><tr><td rowspan="1" colspan="1">Misordered</td><td rowspan="1" colspan="1">0 (0)</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td></tr></tbody></table><table-wrap-foot><fn id="btu280-TF1"><p>All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of the contigs is 156. Initial assembly coverage is 98.18%.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Assembly of one chromosome using multiple references</title>
      <p>Next, we want to address a more problematic case in which multiple references are available, but each of these references exhibits structural variations comparing to the target genome. The dataset contains five different <italic>Helicobacter Pylori</italic> strains: <italic>Puno120</italic> (<italic>NC_017378</italic>), <italic>ELS37</italic> (<italic>NC_017063</italic>), <italic>Gambia94/24</italic> (<italic>NC_017371</italic>) <italic>and G27</italic> (<italic>NC_011333</italic>) as references and <italic>SJM180</italic> (<italic>NC_014560</italic>) as the target. The corresponding phylogenetic tree is shown on <xref ref-type="fig" rid="btu280-F4">Figure 4</xref>A. The dot plots showing the rearrangements can be seen in <xref ref-type="fig" rid="btu280-F5">Figure 5</xref>. Contigs were assembled using ABYSS (<xref rid="btu280-B18" ref-type="bibr">Simpson <italic>et al.</italic>, 2009</xref>).
<fig id="btu280-F4" position="float"><label>Fig. 4.</label><caption><p>Phylogenetic trees. (a) <italic>Heclicobacter Pylori</italic> with <italic>SJM180</italic> as target. (b) <italic>Vibrio Cholerae</italic> with <italic>H1</italic> as target. (c) <italic>Staphylococcus Aureus</italic> with <italic>USA300</italic> as target. (d) Simulated genomes. Solid branches contain all types of rearrangements, while dashed branches contain only indels</p></caption><graphic xlink:href="btu280f4"/></fig>
<fig id="btu280-F5" position="float"><label>Fig. 5.</label><caption><p>(a−d) Dot plots of <italic>H.Pylori</italic> references versus target genomes. (e) Dot plot of Ragout’s scaffold versus the target genome showing a perfect diagonal line for visual verification</p></caption><graphic xlink:href="btu280f5"/></fig></p>
      <p>First, we run Ragout as well as OSLay and MCM on each of the available references separately to illustrate that the ‘usual’ assisted assembly with one reference is insufficient for the current case. Every tool produces a certain amount of misordered contigs, which can be explained by the structural divergence between the reference and the target (see <xref ref-type="table" rid="btu280-T2">Table 2</xref>).
<table-wrap id="btu280-T2" position="float"><label>Table 2.</label><caption><p>Comparison with MCM and OSLay using one <italic>H. Pylori</italic> reference showing misordered contigs</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Reference</th><th rowspan="1" colspan="1">Scaffolds</th><th rowspan="1" colspan="1">Ordered</th><th rowspan="1" colspan="1">Misordered</th><th rowspan="1" colspan="1">Coverage</th></tr></thead><tbody align="left"><tr><td colspan="5" rowspan="1">Mauve contig mover</td></tr><tr><td rowspan="1" colspan="1">    G27</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">53</td><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1">97.9</td></tr><tr><td rowspan="1" colspan="1">    Gambia94/24</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">54</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">97.9</td></tr><tr><td rowspan="1" colspan="1">    ELS37</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">45</td><td rowspan="1" colspan="1">9</td><td rowspan="1" colspan="1">98.0</td></tr><tr><td rowspan="1" colspan="1">    Puno120</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">56</td><td rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1">98.0</td></tr><tr><td colspan="5" rowspan="1">OSLay</td></tr><tr><td rowspan="1" colspan="1">    G27</td><td rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1">50</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">96.2</td></tr><tr><td rowspan="1" colspan="1">    Gambia94/24</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">49</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">96.4</td></tr><tr><td rowspan="1" colspan="1">    ELS37</td><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1">53</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">98.0</td></tr><tr><td rowspan="1" colspan="1">    Puno120</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">51</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">87.0</td></tr><tr><td colspan="5" rowspan="1">Ragout</td></tr><tr><td rowspan="1" colspan="1">    G27</td><td rowspan="1" colspan="1">1 (1)</td><td rowspan="1" colspan="1">91 (50)</td><td rowspan="1" colspan="1">4 (4)</td><td rowspan="1" colspan="1">97.7 (97.4)</td></tr><tr><td rowspan="1" colspan="1">    Gambia94/24</td><td rowspan="1" colspan="1">2 (2)</td><td rowspan="1" colspan="1">83 (45)</td><td rowspan="1" colspan="1">7 (7)</td><td rowspan="1" colspan="1">96.8 (96.6)</td></tr><tr><td rowspan="1" colspan="1">    ELS37</td><td rowspan="1" colspan="1">1 (1)</td><td rowspan="1" colspan="1">102 (56)</td><td rowspan="1" colspan="1">4 (3)</td><td rowspan="1" colspan="1">98.1 (97.5)</td></tr><tr><td rowspan="1" colspan="1">    Puno120</td><td rowspan="1" colspan="1">2 (2)</td><td rowspan="1" colspan="1">92 (49)</td><td rowspan="1" colspan="1">6 (6)</td><td rowspan="1" colspan="1">97.2 (96.9)</td></tr></tbody></table><table-wrap-foot><fn id="btu280-TF2"><p>All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of contigs is 183. Initial assembly coverage is 98.57%.</p></fn></table-wrap-foot></table-wrap></p>
      <p>Since OSLay and MCM can only run with one reference, we use Ragout and RACA to benchmark different sets of multiple references (see <xref ref-type="table" rid="btu280-T3">Table 3</xref>). For RACA, <italic>G27</italic> was chosen to be the reference and others were treated as outgroups. Both tools have misordered contigs when using three or fewer references. Ragout is able to infer the correct order of the contigs with the set of four references, while RACA still has some misordered contigs. Also, Ragout outputs the assembly with better coverage and fewer gaps.
<table-wrap id="btu280-T3" position="float"><label>Table 3.</label><caption><p>Comparison of Ragout and RACA on <italic>H.pylori</italic> using multiple references</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">References</th><th rowspan="1" colspan="1">Scaffolds</th><th rowspan="1" colspan="1">Coverage</th><th rowspan="1" colspan="1">Ordered</th><th rowspan="1" colspan="1">Gaps</th><th rowspan="1" colspan="1">Misordered</th></tr></thead><tbody align="left"><tr><td colspan="6" rowspan="1">Ragout</td></tr><tr><td rowspan="1" colspan="1">    G27, ELS37</td><td rowspan="1" colspan="1">2 (2)</td><td rowspan="1" colspan="1">97.8 (97.6)</td><td rowspan="1" colspan="1">95 (53)</td><td rowspan="1" colspan="1">22 (39)</td><td rowspan="1" colspan="1">1 (1)</td></tr><tr><td rowspan="1" colspan="1">    G27, Puno120, ELS37</td><td rowspan="1" colspan="1">1 (1)</td><td rowspan="1" colspan="1">97.8 (97.6)</td><td rowspan="1" colspan="1">95 (53)</td><td rowspan="1" colspan="1">21 (36)</td><td rowspan="1" colspan="1">1 (1)</td></tr><tr><td rowspan="1" colspan="1">    G27, Puno120, Gambia94/24, ELS37</td><td rowspan="1" colspan="1">1 (1)</td><td rowspan="1" colspan="1">97.6 (97.3)</td><td rowspan="1" colspan="1">93 (46)</td><td rowspan="1" colspan="1">22 (38)</td><td rowspan="1" colspan="1">0 (0)</td></tr><tr><td colspan="6" rowspan="1">RACA</td></tr><tr><td rowspan="1" colspan="1">    G27, ELS37</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">83.6</td><td rowspan="1" colspan="1">35</td><td rowspan="1" colspan="1">29</td><td rowspan="1" colspan="1">2</td></tr><tr><td rowspan="1" colspan="1">    G27, Puno120, ELS37</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">83.6</td><td rowspan="1" colspan="1">35</td><td rowspan="1" colspan="1">30</td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">    G27, Puno120, Gambia94/24, ELS37</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">83.8</td><td rowspan="1" colspan="1">35</td><td rowspan="1" colspan="1">31</td><td rowspan="1" colspan="1">1</td></tr></tbody></table><table-wrap-foot><fn id="btu280-TF3"><p>All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of contigs is 183. Initial assembly coverage is 98.57%.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Multiple chromosome assembly using multiple references</title>
      <p>The next dataset was taken from a recent study (<xref rid="btu280-B3" ref-type="bibr">Bashir <italic>et al.</italic>, 2012</xref>) in which long PacBio reads were used to obtain the complete de novo assembly of <italic>Vibrio Cholerae H1 str. (AKGH01000001)</italic>. Here we want to show that with multiple related references (even though these references and the target genome have structural variations), complete scaffolds with high quality can also be obtained from only short-read data. We used SPAdes to assemble non-paired Illumina reads with read length 40 bp. Three references were chosen so that each of them would have rearrangements in at least one chromosome compared to the target genome: <italic>O1 Biovar</italic> (<italic>AE003852</italic>), <italic>O1 Inaba</italic> (<italic>CM001785</italic>) <italic>and O395</italic> (<italic>CP001235</italic>). See <xref ref-type="fig" rid="btu280-F6">Figure 6</xref> for the dot-plots. The phylogenetic tree is shown on <xref ref-type="fig" rid="btu280-F4">Figure 4</xref>(B).
<fig id="btu280-F6" position="float"><label>Fig. 6.</label><caption><p>Dot plots of different chromosomes of <italic>V.Cholerae</italic> references (a–c) versus the corresponding chromosomes of the target genome showing rearrangements</p></caption><graphic xlink:href="btu280f6"/></fig></p>
      <p>Using three references, Ragout was able to correctly reconstruct two scaffolds that correspond to two <italic>V.</italic><italic>Cholerae</italic> chromosomes (see <xref ref-type="table" rid="btu280-T4">Table 4</xref>). Refinement with the assembly graph significantly increases the number of utilized contigs.
<table-wrap id="btu280-T4" position="float"><label>Table 4.</label><caption><p>Comparison of Ragout and RACA on <italic>V.cholerae</italic> using multiple references</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">References</th><th rowspan="1" colspan="1">Scaffolds</th><th rowspan="1" colspan="1">Coverage</th><th rowspan="1" colspan="1">Ordered</th><th rowspan="1" colspan="1">Gaps</th><th rowspan="1" colspan="1">Misordered</th></tr></thead><tbody align="left"><tr><td colspan="6" rowspan="1">Ragout</td></tr><tr><td rowspan="1" colspan="1">    O1 Inaba</td><td rowspan="1" colspan="1">3 (3)</td><td rowspan="1" colspan="1">95.3 (94.8)</td><td rowspan="1" colspan="1">317 (185)</td><td rowspan="1" colspan="1">41 (64)</td><td rowspan="1" colspan="1">5 (3)</td></tr><tr><td rowspan="1" colspan="1">    O1 Inaba, O1 biovar</td><td rowspan="1" colspan="1">2 (2)</td><td rowspan="1" colspan="1">95.5 (94.7)</td><td rowspan="1" colspan="1">305 (179)</td><td rowspan="1" colspan="1">46 (68)</td><td rowspan="1" colspan="1">6 (4)</td></tr><tr><td rowspan="1" colspan="1">    O1 Inaba, O1 biovar, O395</td><td rowspan="1" colspan="1">2 (2)</td><td rowspan="1" colspan="1">95.5 (94.7)</td><td rowspan="1" colspan="1">300 (174)</td><td rowspan="1" colspan="1">46 (66)</td><td rowspan="1" colspan="1">2 (0)</td></tr><tr><td colspan="6" rowspan="1">RACA</td></tr><tr><td rowspan="1" colspan="1">    O1 Inaba, O1 biovar</td><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1">85.8</td><td rowspan="1" colspan="1">124</td><td rowspan="1" colspan="1">51</td><td rowspan="1" colspan="1">0</td></tr><tr><td rowspan="1" colspan="1">    O1 Inaba, O1 biovar, O395</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">90.0</td><td rowspan="1" colspan="1">127</td><td rowspan="1" colspan="1">56</td><td rowspan="1" colspan="1">0</td></tr></tbody></table><table-wrap-foot><fn id="btu280-TF4"><p>All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of contigs is 1407. Initial assembly coverage is 96.89%.</p></fn></table-wrap-foot></table-wrap></p>
      <p>For RACA, <italic>O1 Inaba</italic> was chosen to be the reference and others were treated as outgroups. RACA outputs three correct scaffolds with three references and six scaffolds with two references. Ragout outperforms RACA by the quality of the assembly, both with and without refinement.</p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Assembly using structurally divergent references</title>
      <p>Finally, we want to address the case when the references have a large number of structural variations. This case requires us to perform simulations because bacterial genomes usually have few rearrangements.</p>
      <p>The phylogenetic tree that was used for simulations is shown on <xref ref-type="fig" rid="btu280-F4">Figure 4</xref>(D). For the sake of simplicity, the tree is chosen to be symmetrical and can be treated both as an unrooted tree or as a rooted one with the target branch of infinitesimal length. On each of the four outer branches (incident to references), five reversals and five translocations were simulated. Additionally, to make the dataset more complex, we have simulated 10 indels on each of the tree branches, including all inner ones. Genomes were then decomposed into synteny blocks, and then the target genome was split into contigs, where each contig represents exactly one synteny block.</p>
      <p>Our analysis includes three cases corresponding to when four, three or two of the simulated references are available. For each case, we have generated 100 different datasets. Since the phylogenetic tree is symmetric, the result does not depend on which particular reference is absent. We took <italic>E.</italic><italic>coli K-12 str. MG1655 substr.</italic> (<italic>NC_000913</italic>) as a target and the number of synteny blocks in decomposition was 112 in average.</p>
      <p>Next, we run Ragout on every dataset. The results of simulations can be seen in <xref ref-type="fig" rid="btu280-F7">Figure 7</xref>, which clearly shows that the number of misordered contigs increases when some of the references are missing from the analysis. The errors in the case when all references are available can be explained by breakpoint reuse, which makes it impossible for the algorithm to distinguish overlapping rearrangements.
<fig id="btu280-F7" position="float"><label>Fig. 7.</label><caption><p>Correspondence of the number of available references with the number of misordered contigs for Ragout</p></caption><graphic xlink:href="btu280f7"/></fig></p>
      <p>To compare Ragout and RACA, we chose two datasets with four references, since each run of RACA requires a large number of manual preparations. Results can be seen in <xref ref-type="table" rid="btu280-T5">Table 5</xref>. In both cases, Ragout produces better assemblies than RACA; one possible explanation for this phenomenon is that RACA heavily relies on one particular reference.
<table-wrap id="btu280-T5" position="float"><label>Table 5.</label><caption><p>Comparison of Ragout and RACA on simulated datasets</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" colspan="1"/><th colspan="2" rowspan="1">Dataset 1<hr/></th><th colspan="2" rowspan="1">Dataset 2<hr/></th></tr><tr><th rowspan="1" colspan="1">Ragout</th><th rowspan="1" colspan="1">RACA</th><th rowspan="1" colspan="1">Ragout</th><th rowspan="1" colspan="1">RACA</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Scaffolds</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">8</td></tr><tr><td rowspan="1" colspan="1">Coverage</td><td rowspan="1" colspan="1">95.3</td><td rowspan="1" colspan="1">83.5</td><td rowspan="1" colspan="1">94.5</td><td rowspan="1" colspan="1">75.4</td></tr><tr><td rowspan="1" colspan="1">Ordered</td><td rowspan="1" colspan="1">112</td><td rowspan="1" colspan="1">101</td><td rowspan="1" colspan="1">112</td><td rowspan="1" colspan="1">90</td></tr><tr><td rowspan="1" colspan="1">Gaps</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1">11</td><td rowspan="1" colspan="1">5</td></tr><tr><td rowspan="1" colspan="1">Misordered</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">4</td><td rowspan="1" colspan="1">2</td></tr></tbody></table><table-wrap-foot><fn id="btu280-TF5"><p>Ragout and RACA were run with synteny block size equal to 500 (the size is known from the simulations) without refinement. The total number of contigs is 114 in both cases. Initial assembly coverage is 100%.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="SEC3.5">
      <title>3.5 Parameter choice and iterative assembly</title>
      <p>We would like to benchmark Ragout with different parameters of iterative/non-iterative assembly. The dataset consists of five strains of <italic>Staphylococcus Aureus</italic> as references: COL (NC_002951), JKD6008 (NC_017341), N315 (NC_002745), RF112 (NC_007622) and <italic>USA300</italic> (<italic>NC_007793</italic>) as the target. The phylogenetic tree is shown in <xref ref-type="fig" rid="btu280-F4">Figure 4</xref>(C). Contigs were assembled from single-cell sequencing data using SPAdes.</p>
      <p>The results of benchmarking can be seen in <xref ref-type="table" rid="btu280-T6">Table 6</xref>. As expected, the smaller size of a synteny block allows the algorithm to arrange more contigs, but analysis becomes more complicated. As a result, the algorithm produces some incorrect adjacencies which leads to misordered contigs and more fragmented assembly (in number of scaffolds). Next, iterative assembly was performed in three stages (5000, 500, 100). This assembly kept the complete scaffold from the first stage, while adding some smaller contigs from the second and third stages. Even though some misordered contigs could be carried to the merged scaffolds, these errors are local and do not violate the correct ‘skeleton’ of scaffolds.
<table-wrap id="btu280-T6" position="float"><label>Table 6.</label><caption><p>Iterative assembly of <italic>S.Aureus</italic></p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">SB size</th><th rowspan="1" colspan="1">100</th><th rowspan="1" colspan="1">500</th><th rowspan="1" colspan="1">5000</th><th rowspan="1" colspan="1">Iterative</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Scaffolds</td><td rowspan="1" colspan="1">5</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">Coverage</td><td rowspan="1" colspan="1">96.7</td><td rowspan="1" colspan="1">96.3</td><td rowspan="1" colspan="1">92.0</td><td rowspan="1" colspan="1">96.7</td></tr><tr><td rowspan="1" colspan="1">Ordered</td><td rowspan="1" colspan="1">108</td><td rowspan="1" colspan="1">91</td><td rowspan="1" colspan="1">62</td><td rowspan="1" colspan="1">89</td></tr><tr><td rowspan="1" colspan="1">Gaps</td><td rowspan="1" colspan="1">75</td><td rowspan="1" colspan="1">75</td><td rowspan="1" colspan="1">56</td><td rowspan="1" colspan="1">73</td></tr><tr><td rowspan="1" colspan="1">Misordered</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td></tr></tbody></table><table-wrap-foot><fn id="btu280-TF6"><p>Ragout was run with four <italic>S.Aureus</italic> references with different minimum synteny block sizes. Iterative assembly was performed with all previous sizes combined (5000, 500, 100). The total number of contigs is 767. Initial assembly coverage is 98.4%. We did not perform refinement with the assembly graph in order to focus on the effect of synteny block size.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
  </sec>
  <sec>
    <title>4 DISCUSSION</title>
    <p>In this article, we have presented Ragout, a package for improving assemblies using multiple complete references. We demonstrated that with multiple related genomes available, one can obtain a complete and high-quality scaffold for each chromosome using only high-throughput short-read sequencing. This marks an important improvement in genome assembly of short reads and even raises a question whether long PacBio reads or long jumping libraries are needed for genomic studies of common bacteria where multiple related references have been available.</p>
    <p>The current version of Ragout uses Sibelia for synteny block reconstruction and therefore limits itself to bacterial genomes. When synteny blocks have been available, Ragout is fast and memory-efficient. We plan to make Ragout compatible with other synteny block generation tools that can work with mammalian genomes [e.g. Cactus aligner <xref rid="btu280-B13" ref-type="bibr">Paten <italic>et al.</italic> (2011)</xref>] and further extend Ragout to work with mammalian datasets. Another limitation of Ragout is that it only uses the assembly graph for recovering repetitive blocks or small contigs that could not be captured in synteny analysis. Therefore, it can make mistakes when rearrangements happened on the target branch. Since de Bruijn graphs can be transformed into breakpoint graphs and vice-versa, the de Bruijn graphs output from short-read assemblers can also be used for rearrangement analysis and we will focus on this issue in further studies.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We would like to thank Jaebum Kim for assisting us with the benchmark of RACA software. We are indebted to Phillip Compeau, Apua Paquola, Nitin Udpa, Shay Zakov, Nikolay Vyahhi and Han Do for revising the manuscript and for many helpful suggestions that significantly improve the paper.</p>
    <p><italic>Funding</italic>: <funding-source>NIH</funding-source> (grant number <award-id>1U41HG007234-01</award-id>) and <funding-source>VP Foundation</funding-source> (grant number <award-id>BI-2013-02</award-id>), in part.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu280-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Alekseyev</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
        </person-group>
        <article-title>Breakpoint graphs and ancestral genome reconstructions</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>943</fpage>
        <lpage>957</lpage>
        <pub-id pub-id-type="pmid">19218533</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bankevich</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Spades: a new genome assembly algorithm and its applications to single-cell sequencing</article-title>
        <source>J. Comput. Biol.</source>
        <year>2012</year>
        <volume>19</volume>
        <fpage>455</fpage>
        <lpage>477</lpage>
        <pub-id pub-id-type="pmid">22506599</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bashir</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A hybrid approach for the automated finishing of bacterial genomes</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2012</year>
        <volume>30</volume>
        <fpage>701</fpage>
        <lpage>707</lpage>
        <pub-id pub-id-type="pmid">22750883</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bashir</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A hybrid approach for the automated finishing of bacterial genomes</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2012</year>
        <volume>30</volume>
        <fpage>701</fpage>
        <lpage>709</lpage>
        <pub-id pub-id-type="pmid">22750883</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B5">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bergeron</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A unifying view of genome rearrangements</article-title>
        <source>Proceedings of Algorithms in Bioinformatics</source>
        <year>2006</year>
        <publisher-name>Springer</publisher-name>
        <fpage>163</fpage>
        <lpage>173</lpage>
      </element-citation>
    </ref>
    <ref id="btu280-B6">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Deshpande</surname>
            <given-names>V</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cerulean: A hybrid assembly using high throughput short and long reads</article-title>
        <source>Proceedings of Algorithms in Bioinformatics</source>
        <year>2013</year>
        <publisher-name>Springer</publisher-name>
        <fpage>349</fpage>
        <lpage>363</lpage>
      </element-citation>
    </ref>
    <ref id="btu280-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fitch</surname>
            <given-names>WM</given-names>
          </name>
        </person-group>
        <article-title>Toward defining the course of evolution: minimum change for a specific tree topology</article-title>
        <source>Syst. Biol.</source>
        <year>1971</year>
        <volume>20</volume>
        <fpage>406</fpage>
        <lpage>416</lpage>
      </element-citation>
    </ref>
    <ref id="btu280-B8">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gaul</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Blanchette</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Ordering partially assembled genomes using gene arrangements</article-title>
        <source>Proceedings of the Comparative Genomics</source>
        <year>2006</year>
        <publisher-name>Springer</publisher-name>
        <fpage>113</fpage>
        <lpage>128</lpage>
      </element-citation>
    </ref>
    <ref id="btu280-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reference-assisted chromosome assembly</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2013</year>
        <volume>110</volume>
        <fpage>1785</fpage>
        <lpage>1790</lpage>
        <pub-id pub-id-type="pmid">23307812</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Hybrid error correction and de novo assembly of single-molecule sequencing reads</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2012</year>
        <volume>30</volume>
        <fpage>693</fpage>
        <lpage>700</lpage>
        <pub-id pub-id-type="pmid">22750884</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ma</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reconstructing contiguous regions of an ancestral genome</article-title>
        <source>Genome Res.</source>
        <year>2006</year>
        <volume>16</volume>
        <fpage>1557</fpage>
        <lpage>1565</lpage>
        <pub-id pub-id-type="pmid">16983148</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B12">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Minkin</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Sibelia: A scalable and comprehensive synteny block generation tool for closely related microbial genomes</article-title>
        <source>Proceedings of Algorithms in Bioinformatics</source>
        <year>2013</year>
        <publisher-name>Springer</publisher-name>
        <fpage>215</fpage>
        <lpage>229</lpage>
      </element-citation>
    </ref>
    <ref id="btu280-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Paten</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Cactus: Algorithms for genome multiple sequence alignment</article-title>
        <source>Genome Res.</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>1512</fpage>
        <lpage>1528</lpage>
        <pub-id pub-id-type="pmid">21665927</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pham</surname>
            <given-names>SK</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
        </person-group>
        <article-title>Drimm-synteny: decomposing genomes into evolutionary conserved segments</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2509</fpage>
        <lpage>2516</lpage>
        <pub-id pub-id-type="pmid">20736338</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Richter</surname>
            <given-names>DC</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Oslay: optimal syntenic layout of unfinished assemblies</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>1573</fpage>
        <lpage>1579</lpage>
        <pub-id pub-id-type="pmid">17463020</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rissman</surname>
            <given-names>AI</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reordering contigs of draft genomes using the mauve aligner</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2071</fpage>
        <lpage>2073</lpage>
        <pub-id pub-id-type="pmid">19515959</pub-id>
      </element-citation>
    </ref>
    <ref id="btu280-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sankoff</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Minimal mutation trees of sequences</article-title>
        <source>SIAM J. Appl. Math.</source>
        <year>1975</year>
        <volume>28</volume>
        <fpage>35</fpage>
        <lpage>42</lpage>
      </element-citation>
    </ref>
    <ref id="btu280-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Abyss: A parallel assembler for short read sequence data</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
