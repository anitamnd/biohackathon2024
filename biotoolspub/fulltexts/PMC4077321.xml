<?properties open_access?>
<?properties manuscript?>
<?origin nihpa?>
<?iso-abbr Nat. Biotechnol.?>
<?submitter-system nihms?>
<?submitter-canonical-name Nature Publishing Group?>
<?submitter-canonical-id NATURE-STRUCTUR?>
<?submitter-userid 1045?>
<?submitter-authority publisher?>
<?submitter-login nature-structure?>
<?submitter-name Nature Publishing Group (obsolete)?>
<?domain nihpa?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-journal-id">9604648</journal-id>
    <journal-id journal-id-type="pubmed-jr-id">20305</journal-id>
    <journal-id journal-id-type="nlm-ta">Nat Biotechnol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nat. Biotechnol.</journal-id>
    <journal-title-group>
      <journal-title>Nature biotechnology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1087-0156</issn>
    <issn pub-type="epub">1546-1696</issn>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4077321</article-id>
    <article-id pub-id-type="pmid">24752080</article-id>
    <article-id pub-id-type="doi">10.1038/nbt.2862</article-id>
    <article-id pub-id-type="manuscript">nihpa572812</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Sailfish enables alignment-free isoform quantification from RNA-seq reads using lightweight algorithms</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Patro</surname>
          <given-names>Rob</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mount</surname>
          <given-names>Stephen M.</given-names>
        </name>
        <xref ref-type="aff" rid="A2">2</xref>
        <xref ref-type="aff" rid="A3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kingsford</surname>
          <given-names>Carl</given-names>
        </name>
        <xref ref-type="aff" rid="A1">1</xref>
        <xref ref-type="corresp" rid="CR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="A1"><label>1</label>Lane Center for Computational Biology, School of Computer Science, Carnegie Mellon University, Pittsburgh, Pennsylvania, USA</aff>
    <aff id="A2"><label>2</label>Department of Cell Biology and Molecular Genetics, University of Maryland, College Park, Maryland, USA</aff>
    <aff id="A3"><label>3</label>Center for Bioinformatics and Computational Biology, University of Maryland, College Park, Maryland, USA</aff>
    <author-notes>
      <corresp id="CR1"><label>*</label>Corresponding author <email>carlk@cs.cmu.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="nihms-submitted">
      <day>16</day>
      <month>4</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>20</day>
      <month>4</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <month>5</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>01</day>
      <month>11</month>
      <year>2014</year>
    </pub-date>
    <volume>32</volume>
    <issue>5</issue>
    <fpage>462</fpage>
    <lpage>464</lpage>
    <!--elocation-id from pubmed: 10.1038/nbt.2862-->
    <permissions>
      <license xlink:href="http://www.nature.com/authors/editorial_policies/license.html#terms">
        <license-p>Users may view, print, copy, and download text and data-mine the content in such documents, for the purposes of academic research, subject always to the full Conditions of use:<ext-link ext-link-type="uri" xlink:href="http://www.nature.com/authors/editorial_policies/license.html#terms">http://www.nature.com/authors/editorial_policies/license.html#terms</ext-link></license-p>
      </license>
    </permissions>
    <abstract>
      <p id="P1">We introduce Sailfish, a computational method for quantifying the abundance of previously annotated RNA isoforms from RNA-seq data. Because Sailfish entirely avoids mapping reads, a time-consuming step in all current methods, it provides quantification estimates much faster than do existing approaches (typically 20 times faster) without loss of accuracy. By facilitating frequent reanalysis of data and reducing the need to optimize parameters, Sailfish exemplifies the potential of lightweight algorithms for efficiently processing sequencing reads.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <p id="P2">RNA-seq has become the <italic>de facto</italic> standard technique to measure gene expression, and it is commonly the first step in an analysis of differential expression among multiple samples<sup><xref rid="R1" ref-type="bibr">1</xref></sup>. However, the throughput of technologies used to generate transcriptomic sequencing reads is accelerating faster than the speed of the computers used to analyze these data. The growing repository of data from archived experiments invites reanalysis in the light of new discoveries, but existing methods are too time-consuming to allow frequent reanalysis. The divide between data-acquisition and data-analysis capabilities will only increase as RNA-seq is adopted for clinical use<sup><xref rid="R2" ref-type="bibr">2</xref></sup>. Finally, the sensitivity of existing methods to parameter choices can affect analysis time and accuracy and can make <italic>a priori</italic> selection of the appropriate parameters difficult. We must develop efficient, lightweight algorithms with few parameters that minimize unnecessary computation.</p>
  <p id="P3">Existing approaches to abundance estimation first use read-mapping tools, such as Bowtie<sup><xref rid="R3" ref-type="bibr">3</xref></sup>, to determine potential locations from which the RNA-seq reads originated. Mapping the reads can require substantial computational resources and often leads to complicated models that try to account for read bias and error during inference, further adding to the time spent on analysis. Finally, some reads, known as multireads<sup><xref rid="R4" ref-type="bibr">4</xref>,<xref rid="R5" ref-type="bibr">5</xref></sup>, can map to multiple, sometimes many, different transcripts. This ambiguity complicates the estimation of transcript abundances. Given read alignments, some of the most accurate transcript quantification tools estimate relative abundance using expectation-maximization (EM) procedures<sup><xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R6" ref-type="bibr">6</xref>,<xref rid="R7" ref-type="bibr">7</xref></sup>, where reads are first assigned to transcripts, and these assignments are then used to estimate transcript abundances, and these steps are repeated until convergence. In practice, both steps can be time consuming. Even when exploiting the parallel nature of the problem, mapping the reads from a reasonably sized RNA-seq experiment can take hours.</p>
  <p id="P4">Recent tools, such as eXpress<sup><xref rid="R7" ref-type="bibr">7</xref></sup>, aim to reduce the computational burden of isoform quantification by substantially altering the EM algorithm. Even for such advanced approaches, performing read alignment and processing the large number of alignments that result from ambiguously mapped reads remains a bottleneck and fundamentally limits the scalability of these approaches. Read-mapping is a complex problem, and the results of existing approaches depend on a host of parameters that affect how errors, gaps, and mismatches are tolerated. These parameters are not always easily interpretable, and they can affect both the resources required for alignment and the results of downstream analysis.</p>
  <p id="P5">Sailfish, our software for isoform quantification from RNA-seq data, is based on the philosophy of lightweight algorithms, which make frugal use of data, respect constant factors and effectively use concurrent hardware by working with small units of data where possible. Sailfish avoids mapping reads entirely (<xref ref-type="fig" rid="F1">Fig. 1</xref>), resulting in large savings in time and space, and substantially reducing parametric complexity. A key technical contribution behind our approach is the observation that transcript coverage can be accurately estimated using counts of k-mers occurring in reads instead of alignments of reads. This results in the ability to obtain accurate estimates more than an order of magnitude faster than existing approaches, often in minutes instead of hours. For example, for the data described in <xref ref-type="fig" rid="F2">Figure 2</xref>, Sailfish is &gt; 25 times faster than the next fastest method while providing estimates of equal accuracy. This accuracy is possible, despite independent counting and assignment of k-mers, because of an expectation maximization procedure that introduces a statistical coupling between k-mers.</p>
  <p id="P6">Although the use of k-mers for the purpose of transcript quantification has not been reported previously, recent work<sup><xref rid="R8" ref-type="bibr">8</xref></sup> has shown that using k-mers directly for other RNA-seq-based tasks can be as or more effective than traditional approaches. By working with k-mers, we can replace computationally intensive read mapping with the much faster and simpler process of k-mer counting. We also avoid any dependence on read-mapping parameters. Yet, our approach is still able to handle sequencing errors because only the k-mers that overlap the erroneous bases will be discarded or mis-assigned, whereas the rest of the read can be processed as if it were error-free. One can view the k-mer counting mechanism as a proportional assignment of a read to a set of potential loci, with the strength of the assignment varying with the number of k-mers in the read that match the locus. Sailfish has only a single explicit parameter, the k-mer length. Longer k-mers may result in less ambiguity, which makes resolving their origin easier, but may be more affected by errors in the reads (<xref ref-type="supplementary-material" rid="SD1">Supplementary Fig. 1</xref>). Further, many of our data structures can be represented as arrays of atomic integers (Online Methods). This allows our software to be concurrent and lock-free where possible, leading to an approach that scales well with the number of available CPUs (<xref ref-type="supplementary-material" rid="SD1">Supplementary Fig. 2</xref>). Additional benefits of the Sailfish approach are discussed in <xref ref-type="supplementary-material" rid="SD1">Supplementary Note 1</xref>.</p>
  <p id="P7">Sailfish works in two phases: indexing and quantification (<xref ref-type="fig" rid="F1">Fig. 1</xref>). A Sailfish index is built from a particular set of reference transcripts (a <bold>FASTA</bold> sequence file) and a specific choice of k-mer length, <italic>k</italic>. The index consists of data structures that make counting k-mers in a set of reads and resolving their potential origin in the set of transcripts efficient (Online Methods). The most important data structure in the index is the minimal perfect hash function<sup><xref rid="R9" ref-type="bibr">9</xref></sup> that maps each k-mer in the reference transcripts to an integer identifier such that no two k-mers share an identifier. Pairing the minimum perfect hash function with an atomically updateable array of k-mer counts allows k-mers to be counted even faster than with existing advanced lock-free hashes such as that used in Jellyfish<sup><xref rid="R10" ref-type="bibr">10</xref></sup>. The index also contains a pair of look-up tables that allow fast access to the k-mers appearing in a specific transcript as well as the transcripts in which a particular k-mer appears, both in amortized constant time. The index only needs to be rebuilt when the set of reference transcripts or the choice of <italic>k</italic> changes.</p>
  <p id="P8">The quantification phase of Sailfish takes as input the above index and a set of RNA-seq reads and produces an estimate of the relative abundance of each transcript in the reference, measured in Reads Per Kilobase per Million mapped reads (RPKM), K-mers Per Kilobase per Million mapped k-mers (KPKM), and Transcripts Per Million (TPM); see Online Methods for the definitions of these measures. First, Sailfish counts the number of times each indexed k-mer occurs in the set of reads. Owing to the index, this process is efficient and scalable (<xref ref-type="supplementary-material" rid="SD1">Supplementary Fig. 2</xref>). Sailfish then applies an expectation-maximization (EM) procedure to determine maximum likelihood estimates for the relative abundance of each transcript. Conceptually, this procedure is similar to the EM algorithm used by RSEM<sup><xref rid="R6" ref-type="bibr">6</xref></sup>, except that k-mers rather than fragments are probabilistically assigned to transcripts, and a two-step variant of EM is used to speed up convergence. The estimation procedure first assigns k-mers proportionally to their occurrence in the transcripts. These initial allocations are then used to estimate the expected coverage for each transcript (Online Methods, <xref ref-type="disp-formula" rid="FD3">Eqn. 3</xref>). In turn, these expected coverage values alter the assignment probabilities of k-mers to transcripts (Online Methods, <xref ref-type="disp-formula" rid="FD1">Eqn. 1</xref>). Using these basic EM steps as a building block, we apply a globally convergent EM acceleration method, SQUAREM<sup><xref rid="R11" ref-type="bibr">11</xref></sup>, that substantially increases the convergence rate of the estimation procedure by modifying the parameter update step based on the current solution path and the estimated distance from the fixed point (Online Methods, <xref ref-type="fig" rid="F4">Alg. 2</xref>).</p>
  <p id="P9">We reduce the number of variables that need to be fit by the EM procedure by collapsing k-mers into equivalence classes, where two k-mers are equivalent if they occur in the same set of transcript sequences with the same rate (Online Methods). The idea of data reduction by equivalence classes has been explored in the context of reads<sup><xref rid="R12" ref-type="bibr">12</xref>,<xref rid="R13" ref-type="bibr">13</xref></sup>. Using k-mer equivalence classes has the added benefit that the classes can be computed based solely on the reference transcriptome without considering the read data. This reduction in variables substantially reduces the computational requirements of the EM procedure (<xref ref-type="supplementary-material" rid="SD1">Supplementary Note 1</xref>).</p>
  <p id="P10">Once the EM procedure converges, the estimated abundances are corrected for systematic errors due to sequence composition bias and transcript length using a regression approach similar to a previous method<sup><xref rid="R14" ref-type="bibr">14</xref></sup>, though using random forest regression instead of a generalized additive model. This correction is applied after initial estimates have been produced rather than at a read mapping or fragment assignment stage, requiring fewer variables to be fit during bias correction.</p>
  <p id="P11">We compared Sailfish to RSEM<sup><xref rid="R6" ref-type="bibr">6</xref></sup>, eXpress<sup><xref rid="R7" ref-type="bibr">7</xref></sup> and Cufflinks<sup><xref rid="R5" ref-type="bibr">5</xref></sup> using both real and synthetic data. Accuracy on real data was quantified by the agreement between RNA-seq–based expression estimates computed by each piece of software and qPCR measurements for the same sample (human brain tissue (HBR) in <xref ref-type="fig" rid="F2">Fig. 2</xref> and <xref ref-type="supplementary-material" rid="SD1">Supplementary Fig. 3</xref>, and universal human reference tissue (UHR) in <xref ref-type="supplementary-material" rid="SD1">Supplementary Fig. 4</xref>). The qPCR measurements for these samples were performed as part of the Microarray Quality Control Study<sup><xref rid="R15" ref-type="bibr">15</xref></sup>; RNA-seq experiments were later performed on the same samples<sup><xref rid="R23" ref-type="bibr">23</xref></sup>. Abundance measurements for qPCR are given at the resolution of genes. To compare these measurements with the transcript-level estimates, we summed the estimates for all isoforms belonging to a gene. We compare predicted abundances using correlation coefficients and, on the synthetic data, root-mean-square error (RMSE) and median percentage error (medPE) (<xref ref-type="supplementary-material" rid="SD1">Supplementary Note 2</xref>). Taken together, these results show that the speed of Sailfish does not sacrifice accuracy (<xref ref-type="fig" rid="F2">Fig. 2</xref>).</p>
  <p id="P12">To show that Sailfish is accurate at the isoform level, we generated synthetic data using the Flux Simulator<sup><xref rid="R18" ref-type="bibr">18</xref></sup>, which allows versatile modeling of various RNA-seq protocols (<xref ref-type="supplementary-material" rid="SD1">Supplementary Note 3</xref>). Unlike synthetic data used in previous work<sup><xref rid="R6" ref-type="bibr">6</xref>,<xref rid="R7" ref-type="bibr">7</xref></sup>, the procedure used by the Flux Simulator is not based on the generative model underlying our estimation procedure. Sailfish remains accurate at the isoform level (<xref ref-type="fig" rid="F2">Fig. 2</xref>, <xref ref-type="supplementary-material" rid="SD1">Supplementary Figs. 5 and 6</xref>). We also find that Sailfish is robust to differences in the underlying set of reference transcripts used for quantification (<xref ref-type="supplementary-material" rid="SD1">Supplementary Fig. 7</xref>), and that it remains accurate when applied to a collection of highly similar genes (Supplementary Table 8).</p>
  <p id="P13">Sailfish applies the idea of lightweight algorithms to the problem of isoform quantification from RNA-seq reads and in doing so achieves a breakthrough in terms of speed. By eliminating read mapping from the expression estimation pipeline, we improve the speed of the process and also simplify it considerably, eliminating the burden of choosing all but a single parameter from the user. Sailfish can be used in a <italic>de-novo</italic> setting for non-model organisms, along with other reference-free tools<sup><xref rid="R19" ref-type="bibr">19</xref>,<xref rid="R20" ref-type="bibr">20</xref></sup>, where some or all of the transcripts are assembled directly from the RNA-seq reads. The memory usage of Sailfish is similar to that of other tools, using 2–6 Gb of RAM during isoform quantification for the experiments reported here. As the size and number of RNA-seq experiments grow, we expect Sailfish and its paradigm to remain efficient for isoform quantification because the memory footprint is bounded by the size and complexity of the target transcripts not the number of reads and the only computation that grows explicitly in the number of reads — k-mer counting — has been designed to effectively exploit many CPU cores.</p>
  <p id="P14">Sailfish is free and open-source software and is available as Supplementary Data and at <ext-link ext-link-type="uri" xlink:href="http://www.cs.cmu.edu/ckingsf/software/sailfish">http://www.cs.cmu.edu/~ckingsf/software/sailfish</ext-link>.</p>
  <sec sec-type="methods" specific-use="web-only" id="S1">
    <title>Online Methods</title>
    <sec id="S2">
      <title>Indexing</title>
      <p id="P15">The first step in the Sailfish pipeline is building an index from the set of reference transcripts <italic>T</italic>. Given a k-mer length <italic>k</italic>, we compute an index <italic>I</italic><sub><italic>k</italic></sub>(<italic>T</italic>) containing four components. The first component is a minimum perfect hash function <italic>h</italic> on the set of k-mers <bold>kmers</bold>(<italic>T</italic>) contained in <italic>T</italic>. A minimum perfect hash function is a bijection between <bold>kmers</bold>(T) and the set of integers {0,1,…, |<bold>kmers</bold>(T)| - 1}. Sailfish uses the BDZ minimum perfect hash function<sup><xref rid="R9" ref-type="bibr">9</xref></sup>. The second component of the index is an array <italic>C</italic> containing a count <italic>C</italic>(<italic>s</italic><sub><italic>i</italic></sub>) for every <italic>s</italic><sub><italic>i</italic></sub>∈ <bold>kmers</bold>(<italic>T</italic>). Finally, the index contains a lookup table mapping each transcript to the multiset of k-mers that it contains, and a reverse lookup table mapping each k-mer to the set of transcripts in which it appears. The index is a product only of the reference transcripts and the choice of <italic>k</italic>, and thus needs only to be recomputed when either of these changes.</p>
    </sec>
    <sec id="S3">
      <title>Quantification</title>
      <p id="P16">The second step in the Sailfish pipeline is the quantification of relative transcript abundance; this requires the Sailfish index <italic>I</italic><sub><italic>k</italic></sub>(<italic>T</italic>) for the reference transcripts <italic>T</italic> as well as a set of RNA-seq reads <inline-formula><mml:math display="inline" id="M1" overflow="scroll"><mml:mi mathvariant="fraktur">R</mml:mi></mml:math></inline-formula>. First, we count the number of occurrences of each <inline-formula><mml:math display="inline" id="M2" overflow="scroll"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="bold">kmers</mml:mi><mml:mo>(</mml:mo><mml:mi>T</mml:mi><mml:mo>)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="bold">kmers</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="fraktur">R</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>. Since we know exactly the set of k-mers that need to be counted and already have a perfect hash function <italic>h</italic> for this set, we can perform this counting in a particularly efficient manner, even faster than efficient hash-based approaches. For example, performing concurrent 20-mer lookups using 8 threads, Jellyfish<sup><xref rid="R10" ref-type="bibr">10</xref></sup> requires an average of 0.35 μs/key while the minimal perfect hash requires an average of 0.1 μs/key. We maintain an array <inline-formula><mml:math display="inline" id="M3" overflow="scroll"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="fraktur">R</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of the appropriate size |<bold>kmers</bold>(<italic>T</italic>)|, where <inline-formula><mml:math display="inline" id="M4" overflow="scroll"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="fraktur">R</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> contains the number of times we have thus far observed <italic>s</italic><sub><italic>i</italic></sub> in <inline-formula><mml:math display="inline" id="M5" overflow="scroll"><mml:mi mathvariant="fraktur">R</mml:mi></mml:math></inline-formula>.</p>
      <p id="P17">In an unstranded protocol, sequencing reads, and hence the k-mers they contain, may originate from transcripts in either the forward or reverse direction. To account for both possibilities, we check both the forward and reverse-complement k-mers from each read and use a majority-rule heuristic to determine which of the k-mers to increment in the final array of counts <inline-formula><mml:math display="inline" id="M6" overflow="scroll"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="fraktur">R</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. If the number of k-mers appearing in <italic>h</italic> from the forward direction of the read is greater than the number of reverse-complement k-mers, then we only increment the counts for k-mers appearing in this read in the forward direction. Otherwise, only counts for k-mers appearing in the reverse-complement of this read are incremented in the array of counts. Ties are broken in favor of the forward directed reads. In a stranded RNA-seq protocol, the reads have a known orientation. Reads provided to Sailfish can be specified as originating from unstranded, forward strand or reverse strand reads, and the appropriate k-mers are counted in each case. By taking advantage of atomic integers and the compare-and-swap (CAS) operation provided by modern processors, which allows many hardware threads to efficiently update the value of a memory location without the need for explicit locking, we can stream through and update the counts in <inline-formula><mml:math display="inline" id="M7" overflow="scroll"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="fraktur">R</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in parallel while sustaining very little resource contention.</p>
      <p id="P18">We then apply an expectation-maximization algorithm to obtain estimates of the relative abundance of each transcript. We define a k-mer equivalence class as the set of all k-mers that appear in the same set of transcripts with the same frequency. In other words, let <italic>X</italic>(<italic>s</italic>) be a vector such that entry <italic>t</italic> of <italic>X</italic>(<italic>s</italic>) gives how many times k-mer <italic>s</italic> appears in transcript <italic>t</italic>∈<italic>T</italic>. Then the equivalence class of a k-mer <italic>s</italic><sub><italic>i</italic></sub> is given by [<italic>s</italic><sub><italic>i</italic></sub>] = {<italic>s</italic><sub><italic>j</italic></sub> ∈<bold>kmers</bold>(<italic>T</italic>) : <italic>X</italic>(<italic>s</italic><sub><italic>j</italic></sub>) = <italic>X</italic>(<italic>s</italic><sub><italic>i</italic></sub>)}. When performing the EM procedure, we will allocate counts to transcripts according to the set of equivalence classes rather than the full set of k-mers. We will let
<disp-formula id="FD1"><label>(1)</label><mml:math display="block" id="M8" overflow="scroll"><mml:mrow><mml:mi mathvariant="normal">L</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>C</mml:mi><mml:mi mathvariant="fraktur">R</mml:mi></mml:msub><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mi>h</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
denote the total count of k-mers in <inline-formula><mml:math display="inline" id="M9" overflow="scroll"><mml:mi mathvariant="fraktur">R</mml:mi></mml:math></inline-formula> that originate from equivalence class [<italic>s</italic><sub><italic>i</italic></sub>]. We say that transcript <italic>t</italic> contains equivalence class [<italic>s</italic>] if [<italic>s</italic>] is a subset of the multiset of k-mers of <italic>t</italic> and denote this by [<italic>s</italic>] ⊆ <italic>t</italic>.</p>
    </sec>
    <sec id="S4">
      <title>Estimating abundances via an EM algorithm</title>
      <p id="P19">The EM algorithm (<xref ref-type="fig" rid="F3">Algo. 1</xref>) alternates between estimating the fraction of counts of each observed k-mer that originates from each transcript (E-step) and estimating the relative abundances of all transcripts given this allocation (M-step). We initially allocate k-mers to transcripts proportional to their occurrences in the transcript (i.e. if a transcript is the only potential origin for a particular k-mer, then all observations of that k-mer are attributed to this transcript, whereas for a k-mer that appears once in each of <italic>n</italic> different transcripts and occurs <italic>m</italic> times in the set of reads, <italic>m</italic>/<italic>n</italic> observations are attributed to each potential transcript of origin).</p>
      <p id="P20">The E-step of the EM algorithm computes the fraction of each k-mer equivalence class' total count that is allocated to each transcript. For equivalence class [<italic>s</italic><sub><italic>j</italic></sub>] and transcript <italic>t</italic><sub><italic>i</italic></sub>, this value is computed by
<disp-formula id="FD2"><label>(2)</label><mml:math display="block" id="M10" overflow="scroll"><mml:mrow><mml:mi>α</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mi>μ</mml:mi><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mi mathvariant="normal">L</mml:mi><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>⊇</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:munder><mml:msubsup><mml:mi>μ</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where μ′<sub><italic>i</italic></sub> is the currently estimated relative abundance of transcript <italic>i</italic>. These allocations are then used in the M-step of the algorithm to compute the relative abundance of each transcript. The relative abundance of transcript <italic>i</italic> is estimated by
<disp-formula id="FD3"><label>(3)</label><mml:math display="block" id="M11" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>μ</mml:mi><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>μ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where μ<sub><italic>i</italic></sub> is
<disp-formula id="FD4"><label>(4)</label><mml:math display="block" id="M12" overflow="scroll"><mml:mrow><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>]</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mi>α</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msubsup><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
The variable <italic>l</italic><sub><italic>i</italic></sub>′ denotes the adjusted length of transcript <italic>i</italic> and is simply <italic>l</italic>′<sub><italic>i</italic></sub> = <italic>ℓ</italic><sub><italic>i</italic></sub> – <italic>k</italic> + 1 where <italic>ℓ</italic><sub><italic>i</italic></sub> is the length of transcript <italic>i</italic> in nucleotides.</p>
      <p id="P21">However, rather than perform the standard EM update steps, we perform updates according to the SQUAREM procedure<sup><xref rid="R11" ref-type="bibr">11</xref></sup> described in <xref ref-type="fig" rid="F4">Algo. 2</xref>, where μ′ = 〈μ′<sub>0</sub>, …,μ′<sub>|<italic>T</italic>|</sub>〉 is a vector of relative abundance maximum-likelihood estimates, and EM(·) is a standard iteration of the expectation-maximization procedure as outlined in <xref ref-type="fig" rid="F3">Algo. 1</xref>. For a detailed explanation of the SQUAREM procedure and its proof of convergence, see<sup><xref rid="R11" ref-type="bibr">11</xref></sup>. Intuitively, the SQUAREM procedure builds an approximation of the Jacobian of μ′ from 3 successive steps along the EM solution path, and uses the magnitude of the differences between these solutions to determine a step size ɣ by which to update the estimates according to the update rule (line 7). The procedure is then capable of making relatively large updates to the μ′ parameters, which substantially improves the speed of convergence. In Sailfish, the iterative SQUAREM procedure is repeated until a specified convergence criterion is met (by default, the procedure terminates when no transcript with a relative abundance greater than 10<sup>−7</sup> has a relative change greater than half of a percent between consecutive iterations). Additionally, a user may specify either a fixed number of iterations to perform or a required minimum relative change, ε, in transcript abundance estimates between SQUAREM iterations; if no relative change in transcript abundance exceeds ε, then the procedure is considered to have converged and the estimation procedure terminates.</p>
    </sec>
    <sec id="S5">
      <title>Bias Correction</title>
      <p id="P22">The bias correction procedure implemented in Sailfish is based on the model introduced by Zheng et al.<sup><xref rid="R14" ref-type="bibr">14</xref></sup> Briefly, it performs a regression analysis on a set of potential bias factors where the response variables are the estimated transcript abundances (KPKMs). Sailfish automatically considers transcript length, GC content and dinucleotide frequencies as potential bias factors, as this specific set of features were suggested by Zheng et al.<sup><xref rid="R14" ref-type="bibr">14</xref></sup> For each transcript, the prediction of the regression model represents the contribution of the bias factors to this transcript's estimated abundance. Hence, these regression estimates (which may be positive or negative) are subtracted from the original estimates to obtain bias-corrected KPKMs. For further details on this bias correction procedure, see<sup><xref rid="R14" ref-type="bibr">14</xref></sup>. The original method used a generalized additive model for regression; Sailfish implements the approach using random forest regression to leverage high-performance implementations of this technique. The key idea here is to do the bias correction after abundance estimation rather than earlier in the pipeline. The bias correction of Sailfish can be disabled with the --no–bias–correction command line option. Finally, we note that it is possible to include other potential features, like normalized coverage plots that can encode positional bias, into the bias correction phase. However, in the current version of Sailfish, we have not implemented or tested bias correction for these features.</p>
    </sec>
    <sec id="S6">
      <title>Computing KPKM, RPKM and TPM</title>
      <p id="P23">Sailfish outputs K-mers Per Kilobase per Million mapped k-mers (KPKM), Reads Per Kilobase per Million mapped reads (RPKM) and Transcripts Per Million (TPM) as quantities predicting the relative abundance of different isoforms. The RPKM estimate is the most commonly used, and is ideally 10<sup>9</sup> times the rate at which reads are observed at a given position, but the TPM estimate has also become somewhat common<sup><xref rid="R6" ref-type="bibr">6</xref></sup>. For Sailfish, the KPKM measure is more natural than RPKM, since the k-mer is the basic unit of transcript coverage; however, the two measures are proportional. Given the relative transcript abundances estimated by the EM procedure described above, the TPM for transcript <italic>i</italic> is given by
<disp-formula id="FD5"><label>(5)</label><mml:math display="block" id="M13" overflow="scroll"><mml:mrow><mml:msub><mml:mtext>TPM</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>6</mml:mn></mml:msup><mml:msubsup><mml:mi>μ</mml:mi><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
Let <italic>C<sub>i</sub></italic> be the number of k-mers mapped to transcript <italic>i</italic>. Then, the KPKM is given by
<disp-formula id="FD6"><label>(6)</label><mml:math display="block" id="M14" overflow="scroll"><mml:mrow><mml:msub><mml:mtext>KPKM</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mfrac><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mi>i</mml:mi><mml:mo>∕</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mrow><mml:mi>N</mml:mi><mml:mo>∕</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mn>10</mml:mn><mml:mn>9</mml:mn></mml:msup><mml:mfrac><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mi>N</mml:mi></mml:mfrac><mml:mo>≈</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mn>10</mml:mn><mml:mn>9</mml:mn></mml:msup><mml:msub><mml:mi>μ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mi>N</mml:mi></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>N</italic> is the total count of mapped (i.e. hashable) k–mers and the final equality is approximate only because we replace <italic>l<sub>i</sub></italic> with <italic>l<sub>i</sub></italic>′. The KPKM is proportional to the RPKM, which can be estimated by replacing <italic>C<sub>i</sub></italic> with the estimated number of reads mapped to transcript <italic>i</italic>, and <italic>N</italic> with the estimated number of mapped reads; these can be calculated from the mapped k-mer counts and the average read length. The Fragments Per Kilobase per Million mapped fragments (FPKM) measure is also proportional to the K/RPKM, but is meant to denote that fragments rather than reads are mapped — for single end data, the reads and fragments coincide, for paired-end data, each concordant read pair is considered a single fragment.</p>
    </sec>
    <sec id="S7">
      <title>Accuracy Metrics</title>
      <p id="P24">For all experiments, the Pearson correlation metric was computed between estimates of abundance that were log transformed. As in previous work<sup><xref rid="R6" ref-type="bibr">6</xref></sup>, this was done to prevent the most abundant transcripts from dominating the correlations, but it necessitates discarding samples that have either a true or estimated abundance of 0. Spearman correlations were computed on estimates that were not log transformed. For the synthetic data, we additionally compute the Root Mean Squared Error (RMSE) and median Percentage Error. Given the vectors <bold><italic>x</italic></bold> = 〈<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, …, <italic>x<sub>n</sub></italic>〉 of ground-truth abundances and <bold><italic>y</italic></bold> = 〈<italic>y</italic><sub>1</sub>, <italic>y</italic><sub>2</sub>, …, <italic>y<sub>n</sub></italic>〉 of estimated abundances, the RMSE is defined as
<disp-formula id="FD7"><label>(7)</label><mml:math display="block" id="M15" overflow="scroll"><mml:mrow><mml:mtext>RMSE</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">y</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:mfrac><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:mfrac></mml:msqrt><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p id="P25">The percentage error (PE) between a true abundance <italic>x<sub>i</sub></italic> and the corresponding estimate <italic>y<sub>i</sub></italic> is defined as
<disp-formula id="FD8"><label>(8)</label><mml:math display="block" id="M16" overflow="scroll"><mml:mrow><mml:mi>PE</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>100</mml:mn><mml:mo>×</mml:mo><mml:mfrac><mml:mrow><mml:mo>∣</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∣</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p id="P26">Unlike the definition presented in other work<sup><xref rid="R12" ref-type="bibr">12</xref></sup>, we do not define division by 0 when computing the percentage error. We then define the medPE as the median of the percentage error for all transcripts that have a true abundance greater than 0 (i.e. the median of the values PE(<italic>x<sub>i</sub></italic>, <italic>y<sub>i</sub></italic>) for all 1 ≤ <italic>i</italic> ≤ <italic>n</italic> where <italic>x<sub>i</sub></italic> ≠ 0).</p>
      <p id="P27">When comparing against the qPCR-based abundances, we used the KPKM estimates produced by Sailfish and FPKM estimates produced by RSEM, Cufflinks and eXpress directly. The FluxSimulator records the number of reads that were actually generated by each transcript during the simulated sequencing experiment. These read counts and the transcript lengths were used to compute the ground truth FPKMs directly using <xref ref-type="disp-formula" rid="FD6">Equation 6</xref>. However, we found that the FPKM estimates computed by RSEM, eXpress and Cufflinks appeared, for a number of transcripts, to be systematically inflated with respect to the ground truth FPKMs (this inflation persisted even when estimates were compared directly to ground truth relative transcript fractions). This appears to be due to the effective-length normalization procedures employed by these methods. Indeed, when Cufflinks was run with ––no–effective–length–correction, the RMSE and medPE decreased significantly, while the correlations with ground truth FPKMs increased marginally as well. Thus, for the synthetic tests, all Cufflinks results were computed with the ––no–effective–length–correction flag enabled. Though RSEM and eXpress do not expose such a flag directly, we computed FPKM estimates without effective-length corrections for these methods by using the estimated read counts (output directly by both methods) and the true transcript lengths using <xref ref-type="disp-formula" rid="FD6">Equation 6</xref>. Using FPKMs computed in this manner reduced the RMSE from 2083.04 to 8.83 and medPE from 19.03 to 14.06 for eXpress and reduced the RMSE from 18.77 to 8.90 and the medPE from 17.90 to 12.48 for RSEM. Sailfish computes the estimated k-mer counts and KPKMs in a consistent manner directly from the underlying transcript abundances, so there is no difference between the KPKMs provided by Sailfish and those that would be computed using the estimated k-mer counts directly.</p>
    </sec>
    <sec id="S8">
      <title>Simulated Data</title>
      <p id="P28">The simulated <italic>Homo sapiens</italic> RNA-seq data was generated by the Flux Simulator<sup><xref rid="R18" ref-type="bibr">18</xref></sup> v1.2.1 with the parameters listed in <xref ref-type="supplementary-material" rid="SD1">Supplementary Note 3</xref>. This resulted in a dataset of 75M 76bp × 2 paired-end reads. The reads produced by the Flux Simulator are grouped by their origin (i.e. reads originating from the same genomic locus appear together in the read file). However, this synthetic artifact violates the assumption made by eXpress that reads are produced in a random order. Thus, we post-process the reads generated by the Flux Simulator and shuffle them (while keeping mates appropriately paired) into a random order. The shuffled, mate-pair reads are then split into separate files. To ensure a sufficient mapping rate under the parameters used to produce alignments for eXpress and Cufflinks (–v 3 for Bowtie and –N 3 for TopHat<sup><xref rid="R21" ref-type="bibr">21</xref></sup>), the synthetic reads were quality trimmed using SICKLE (<ext-link ext-link-type="uri" xlink:href="https://github.com/najoshi/sickle">https://github.com/najoshi/sickle</ext-link>) with the default parameters. Untrimmed reads are more appropriate for RSEM's default parameters, and so RSEM was provided with untrimmed reads. While mapping rates increased significantly for the trimmed reads, the overall accuracy of the methods depended little on whether trimmed or untrimmed reads were used. RSEM, eXpress and Cufflinks were all given paired-end alignments since they make special use of this data. TopHat<sup><xref rid="R21" ref-type="bibr">21</xref></sup> was provided with the option ––mate–inner–dist 200, to adjust the expected mate-pair inner-distance to the simulated average, and Bowtie was given the option –X 800 to ensure that paired-end reads originating from all valid fragments would be considered. The untrimmed synthetic read files were provided directly to Sailfish without any extra information since the same quantification procedure is used whether single or paired-end reads are provided.</p>
    </sec>
    <sec id="S9">
      <title>Software Comparisons</title>
      <p id="P29">For eXpress, all reads were aligned with Bowtie<sup><xref rid="R3" ref-type="bibr">3</xref></sup> v0.12.9 using the parameters –a and –v 3, as suggested in the eXpress manuscript, which allows up to three mismatches per read and reports all alignments. All alignments for RSEM were computed with default parameters using the rsem–calculate–expression command, which used Bowtie v0.12.9 as the underlying aligner. To prepare alignments for Cufflinks, TopHat was run using Bowtie v0.12.9 (––bowtie1) and with options –N 3 and ––read–edit–dist 3 to allow up to three mismatches per read. For RSEM, eXpress and Cufflinks, the reported times are the sum of the times required for alignment and the times required for quantification. The time required for each method is further decomposed into the times for the alignment and quantification steps in <xref ref-type="fig" rid="F2">Fig. 2</xref>.</p>
    </sec>
    <sec id="S10">
      <title>Choice of Software Options and Effect on Runtime</title>
      <p id="P30">Most expression estimation software, including RSEM, eXpress and Cufflinks, provides a myriad of program options to the user which allow for trade-offs between various desiderata. For example, the total time required by TopHat and Cufflinks is lower when Cufflinks is run without bias correction (e.g. 1.92h as opposed to 2.27h with bias correction on the SRX016366 data). However, without bias correction, Cufflinks yields slightly lower accuracy (Pearson σ = 0.82, Spearman ρ = 0.81) than the other methods, while still taking 16 times longer to run than Sailfish. Similarly, although aligned reads can be streamed directly into eXpress via Bowtie, we empirically observed lower overall runtimes when aligning reads and quantifying expressions separately (and in serial), so these times were reported. Finally, when we provided RSEM with the alignments used by eXpress (as was done in previous work<sup><xref rid="R7" ref-type="bibr">7</xref></sup>), we observed substantially increased runtime on the qPCR datasets (46.5 hours with the alignments generated from SRX016366 and 35.6 hours with the alignments generated from SRX016367), since RSEM does not appear to handle the large number of multiple alignments that can be generated by short reads when allowing many mismatches; instead, we report timings for RSEM when the alignment is performed using its own default parameters. In general, we attempted to run each piece of software with options that would be common in a standard usage scenario. However, despite the inherent difficulty of comparing a set of tools parameterized on an array of potential options, the core thesis that Sailfish can provide accurate expression estimates much faster than any existing tool remains true, as the fastest performing alternatives, when even when sacrificing accuracy for speed, were over an order of magnitude slower than Sailfish.</p>
      <p id="P31">Sailfish version 0.6.3 was used for all experiments, and all analyses were performed with a k-mer size of <italic>k</italic> = 20 and using 16 concurrent threads (–p 16). In all experiments involving the real but not simulated data, Sailfish was run with the ––polya option, which discards k-mers consisting of <italic>k</italic> consecutive As or Ts, and bias correction was enabled. The KPKM values reported by Sailfish were used as transcript abundance estimates.</p>
      <p id="P32">RSEM<sup><xref rid="R6" ref-type="bibr">6</xref></sup> version 1.2.3 was run with the ––no–bam–output flag, and with –p 16. In the experiments involving the real data, rsem–prepare–reference was used to prepare a reference index that appended poly-A tails to all transcripts, and the quantification was performed with the ––estimate-rspd flag. For the synthetic data, RSEM was given the ––paired–end option to produce paired-end alignments from the reads. Apart from these options, RSEM was run with the default parameters for all experiments.</p>
      <p id="P33">eXpress<sup><xref rid="R7" ref-type="bibr">7</xref></sup> version 1.3.1 was used for all experiments. It was run with default parameters on the MACQ data, and without bias correction (––no–bias–correct) on the synthetic data. For the synthetic test, Bowtie was given the appropriate –1 and –2 options to compute paired-end alignments.</p>
      <p id="P34">Cufflinks<sup><xref rid="R5" ref-type="bibr">5</xref></sup> version 2.1.1 was used for experiments and was run with bias correction (–b) and multi-read recovery (–u) on the MACQ data, and with multi-read recovery (–u) and no effective-length correction (––no–effective–length–correction) on the synthetic data. For all tests, both Cufflinks and TopHat were run with with the –p 16 option to take advantage of up to 16 concurrent threads of execution.</p>
      <p id="P35">All experiments were run on a computer with 8 AMD Opteron™ 6220 processors (4 cores each) and 256Gb of RAM. For all experiments, the wall time was measured using the built-in bash time command.</p>
    </sec>
    <sec id="S11">
      <title>Implementation of Sailfish</title>
      <p id="P36">Sailfish has two basic sub-commands, index and quant. The index command initially builds a hash of all k-mers in the set of reference transcripts using the Jellyfish<sup><xref rid="R10" ref-type="bibr">10</xref></sup> software. This hash is then used to build the minimum perfect hash, count array, and look-up tables described above. The index command takes as input a k-mer size via the –k option and a set of reference transcripts in FASTA format via the –t parameter. It produces the Sailfish index described above, and it can optionally take advantage of multiple threads with the target number of threads being provided via a –p option.</p>
      <p id="P37">The quant sub-command estimates the relative abundance of transcripts given a set of reads. The quant command takes as input a Sailfish index (computed via the index command described above and provided via the –i parameter). Additionally, it requires the set of reads, provided as a list of FASTA or FASTQ files. Finally, just as can the index command, the quant command can take advantage of multiple processors, the target number of which is provided via the –p option.</p>
      <p id="P38">Sailfish is implemented in C++11 and takes advantage of several C++11 language and library features. In particular, Sailfish makes heavy use of built-in atomic data types. Parallelization across multiple threads in Sailfish is accomplished via a combination of the standard library's thread facilities and the Intel Threading Building Blocks (TBB) library<sup><xref rid="R22" ref-type="bibr">22</xref></sup>. Sailfish is available as an open-source program under the GPLv3 license, and has been developed and tested on Linux and Macintosh OS X.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="SM">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="SD1">
      <label>1</label>
      <media xlink:href="NIHMS572812-supplement-1.pdf" orientation="portrait" xlink:type="simple" id="d37e1471" position="anchor"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="S12">
    <title>Acknowledgments</title>
    <p>This work has been partially funded by National Science Foundation (CCF-1256087, CCF-1053918, and EF-0849899) and National Institutes of Health (1R21AI085376, 1R21HG006913, and R01HG007104). C.K. received support as an Alfred P. Sloan Research Fellow. We would like to thank Adam Roberts for helping to diagnose and resolve an artifact in an earlier version of this manuscript pertaining to the synthetic data generated by the Flux Simulator.</p>
  </ack>
  <fn-group>
    <fn id="FN1">
      <p id="P39"><bold>Author Contributions.</bold> R.P., S.M.M. and C.K. designed the method and algorithms, devised the experiments, and wrote the manuscript. R.P. implemented the Sailfish software.</p>
    </fn>
  </fn-group>
  <ref-list>
    <title>References</title>
    <ref id="R1">
      <label>[1]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Soneson</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Delorenzi</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A comparison of methods for differential expression analysis of RNA-seq data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>1</issue>
        <fpage>91</fpage>
        <pub-id pub-id-type="pmid">23497356</pub-id>
      </element-citation>
    </ref>
    <ref id="R2">
      <label>[2]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roychowdhury</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Iyer</surname>
            <given-names>MK</given-names>
          </name>
          <name>
            <surname>Robinson</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Lonigro</surname>
            <given-names>RJ</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>Y-M</given-names>
          </name>
          <name>
            <surname>Cao</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Kalyana-Sundaram</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Sam</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Balbin</surname>
            <given-names>OA</given-names>
          </name>
          <name>
            <surname>Quist</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Barrette</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Everett</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Siddiqui</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kunju</surname>
            <given-names>LP</given-names>
          </name>
          <name>
            <surname>Navone</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Araujo</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Troncoso</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Logothetis</surname>
            <given-names>CJ</given-names>
          </name>
          <name>
            <surname>Innis</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>DC</given-names>
          </name>
          <name>
            <surname>Lao</surname>
            <given-names>CD</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>SY</given-names>
          </name>
          <name>
            <surname>Roberts</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Gruber</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Pienta</surname>
            <given-names>KJ</given-names>
          </name>
          <name>
            <surname>Talpaz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Chinnaiyan</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Personalized oncology through integrative high-throughput sequencing: a pilot study</article-title>
        <source>Science Translational Medicine</source>
        <year>2011</year>
        <volume>3</volume>
        <issue>111</issue>
        <fpage>111ra121</fpage>
      </element-citation>
    </ref>
    <ref id="R3">
      <label>[3]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pop</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biology</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </element-citation>
    </ref>
    <ref id="R4">
      <label>[4]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mortazavi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Williams</surname>
            <given-names>BA</given-names>
          </name>
          <name>
            <surname>McCue</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Schaeffer</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Wold</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Mapping and quantifying mammalian transcriptomes by RNA-Seq</article-title>
        <source>Nature Methods</source>
        <year>2008</year>
        <volume>5</volume>
        <issue>7</issue>
        <fpage>621</fpage>
        <lpage>628</lpage>
        <pub-id pub-id-type="pmid">18516045</pub-id>
      </element-citation>
    </ref>
    <ref id="R5">
      <label>[5]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Williams</surname>
            <given-names>BA</given-names>
          </name>
          <name>
            <surname>Pertea</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Mortazavi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kwan</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>van Baren</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
          <name>
            <surname>Wold</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Transcript assembly and quantification by RNASeq reveals unannotated transcripts and isoform switching during cell differentiation</article-title>
        <source>Nature Biotechnology</source>
        <year>2010</year>
        <volume>28</volume>
        <issue>5</issue>
        <fpage>511</fpage>
        <lpage>515</lpage>
      </element-citation>
    </ref>
    <ref id="R6">
      <label>[6]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Dewey</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <issue>1</issue>
        <fpage>323</fpage>
        <pub-id pub-id-type="pmid">21816040</pub-id>
      </element-citation>
    </ref>
    <ref id="R7">
      <label>[7]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Streaming fragment assignment for real-time analysis of sequencing experiments</article-title>
        <source>Nature Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <issue>1</issue>
        <fpage>71</fpage>
        <lpage>73</lpage>
        <pub-id pub-id-type="pmid">23160280</pub-id>
      </element-citation>
    </ref>
    <ref id="R8">
      <label>[8]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Philippe</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Salson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Commes</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rivals</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>CRAC: an integrated approach to the analysis of RNA-seq reads</article-title>
        <source>Genome Biology</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>3</issue>
        <fpage>R30</fpage>
        <pub-id pub-id-type="pmid">23537109</pub-id>
      </element-citation>
    </ref>
    <ref id="R9">
      <label>[9]</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Botelho</surname>
            <given-names>FC</given-names>
          </name>
          <name>
            <surname>Pagh</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Ziviani</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Simple and space-efficient minimal perfect hash functions</article-title>
        <year>2007</year>
        <fpage>139</fpage>
        <lpage>150</lpage>
        <conf-name>Proceedings of the 10th International Workshop on Algorithms and Data Structures</conf-name>
        <conf-loc>Springer</conf-loc>
      </element-citation>
    </ref>
    <ref id="R10">
      <label>[10]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marçais</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>6</issue>
        <fpage>764</fpage>
        <lpage>770</lpage>
        <pub-id pub-id-type="pmid">21217122</pub-id>
      </element-citation>
    </ref>
    <ref id="R11">
      <label>[11]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Varadhan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Roland</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Simple and globally convergent methods for accelerating the convergence of any EM algorithm</article-title>
        <source>Scandinavian Journal of Statistics</source>
        <year>2008</year>
        <volume>35</volume>
        <issue>2</issue>
        <fpage>335</fpage>
        <lpage>353</lpage>
      </element-citation>
    </ref>
    <ref id="R12">
      <label>[12]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nicolae</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Mangul</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Mandoiu</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Zelikovsky</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Estimation of alternative splicing isoform frequencies from RNA-Seq data</article-title>
        <source>Algorithms for Molecular Biology</source>
        <year>2011</year>
        <volume>6</volume>
        <fpage>9</fpage>
        <pub-id pub-id-type="pmid">21504602</pub-id>
      </element-citation>
    </ref>
    <ref id="R13">
      <label>[13]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salzman</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jiang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>WH</given-names>
          </name>
        </person-group>
        <article-title>Statistical modeling of RNA-Seq data</article-title>
        <source>Statistical Science</source>
        <year>2011</year>
        <volume>26</volume>
        <issue>1</issue>
        <fpage>62</fpage>
        <lpage>83</lpage>
      </element-citation>
    </ref>
    <ref id="R14">
      <label>[14]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zheng</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Chung</surname>
            <given-names>LM</given-names>
          </name>
          <name>
            <surname>Zhao</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Bias detection and correction in RNA-Sequencing data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <issue>1</issue>
        <fpage>290</fpage>
        <pub-id pub-id-type="pmid">21771300</pub-id>
      </element-citation>
    </ref>
    <ref id="R15">
      <label>[15]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shi</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Reid</surname>
            <given-names>LH</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>WD</given-names>
          </name>
          <name>
            <surname>Shippy</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Warrington</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Baker</surname>
            <given-names>SC</given-names>
          </name>
          <name>
            <surname>Collins</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>De Longueville</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Kawasaki</surname>
            <given-names>ES</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>KY</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The MicroArray Quality Control (MAQC) project shows inter- and intraplatform reproducibility of gene expression measurements</article-title>
        <source>Nature Biotechnology</source>
        <year>2006</year>
        <volume>24</volume>
        <issue>9</issue>
        <fpage>1151</fpage>
        <lpage>1161</lpage>
      </element-citation>
    </ref>
    <ref id="R16">
      <label>[16]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pruitt</surname>
            <given-names>KD</given-names>
          </name>
          <name>
            <surname>Tatusova</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>GR</given-names>
          </name>
          <name>
            <surname>Maglott</surname>
            <given-names>DR</given-names>
          </name>
        </person-group>
        <article-title>NCBI Reference Sequences (RefSeq): current status, new features and genome annotation policy</article-title>
        <source>Nucleic Acids Research</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>D1</issue>
        <fpage>D130</fpage>
        <lpage>D135</lpage>
        <pub-id pub-id-type="pmid">22121212</pub-id>
      </element-citation>
    </ref>
    <ref id="R17">
      <label>[17]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flicek</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Ahmed</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Amode</surname>
            <given-names>MR</given-names>
          </name>
          <name>
            <surname>Barrell</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Beal</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Brent</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Carvalho-Silva</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Clapham</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Coates</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Fairley</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ensembl 2013</article-title>
        <source>Nucleic Acids Research</source>
        <year>2013</year>
        <volume>41</volume>
        <issue>D1</issue>
        <fpage>D48</fpage>
        <lpage>D55</lpage>
        <pub-id pub-id-type="pmid">23203987</pub-id>
      </element-citation>
    </ref>
    <ref id="R18">
      <label>[18]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Griebel</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Zacher</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ribeca</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Raineri</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Lacroix</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Guigó</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sammeth</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Modeling and simulating generic RNA-Seq experiments with the flux simulator</article-title>
        <source>Nucleic Acids Research</source>
        <year>2012</year>
        <volume>40</volume>
        <issue>20</issue>
        <fpage>10073</fpage>
        <lpage>10083</lpage>
        <pub-id pub-id-type="pmid">22962361</pub-id>
      </element-citation>
    </ref>
    <ref id="R19">
      <label>[19]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grabherr</surname>
            <given-names>MG</given-names>
          </name>
          <name>
            <surname>Haas</surname>
            <given-names>BJ</given-names>
          </name>
          <name>
            <surname>Yassour</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Levin</surname>
            <given-names>JZ</given-names>
          </name>
          <name>
            <surname>Thompson</surname>
            <given-names>DA</given-names>
          </name>
          <name>
            <surname>Amit</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Adiconis</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Fan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Raychowdhury</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Zeng</surname>
            <given-names>Q</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Full-length transcriptome assembly from RNA-Seq data without a reference genome</article-title>
        <source>Nature Biotechnology</source>
        <year>2011</year>
        <volume>29</volume>
        <issue>7</issue>
        <fpage>644</fpage>
        <lpage>652</lpage>
      </element-citation>
    </ref>
    <ref id="R20">
      <label>[20]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sacomoto</surname>
            <given-names>GA</given-names>
          </name>
          <name>
            <surname>Kielbassa</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Uricaru</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Antoniou</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Sagot</surname>
            <given-names>MF</given-names>
          </name>
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Lacroix</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>KISSPLICE: de-novo calling alternative splicing events from RNA-seq data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>Suppl 6</issue>
        <fpage>S5</fpage>
        <pub-id pub-id-type="pmid">22537044</pub-id>
      </element-citation>
    </ref>
    <ref id="R21">
      <label>[21]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>TopHat: discovering splice junctions with RNA-seq</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>9</issue>
        <fpage>1105</fpage>
        <lpage>1111</lpage>
        <pub-id pub-id-type="pmid">19289445</pub-id>
      </element-citation>
    </ref>
    <ref id="R22">
      <label>[22]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pheatt</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Intel threading building blocks</article-title>
        <source>Journal of Computing Sciences in Colleges</source>
        <year>2008</year>
        <volume>23</volume>
        <issue>4</issue>
        <fpage>298</fpage>
        <lpage>298</lpage>
      </element-citation>
    </ref>
    <ref id="R23">
      <label>[23]</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bullard</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Purdom</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Hansen</surname>
            <given-names>KD</given-names>
          </name>
          <name>
            <surname>Dudoit</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Evaluation of statistical methods for normalization and differential expression in mRNA-Seq experiments</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>1</issue>
        <fpage>94</fpage>
        <pub-id pub-id-type="pmid">20167110</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="F1" orientation="portrait" position="float">
    <label>Figure 1</label>
    <caption>
      <p>Overview of the Sailfish pipeline. Sailfish consists of an indexing phase (<bold>a</bold>) that is invoked via the command `sailfish index' and a quantification phase (<bold>b</bold>) invoked via the command `sailfish quant'. The Sailfish index has four components: (1) a perfect hash function mapping each k-mer in the transcript set to a unique integer between 0 and <italic>N</italic> – 1, where <italic>N</italic> is the number of unique k-mers in the set of transcripts; (2) an array recording the number of times each k-mer occurs in the reference set; (3) an index mapping each transcript to the multiset of k-mers that it contains; (4) an index mapping each k-mer to the set of transcripts in which it appears. The quantification phase consists of counting the indexed k-mers in the set of reads and then applying an expectation-maximization procedure to determine the maximum-likelihood estimates of relative transcript abundance.</p>
    </caption>
    <graphic xlink:href="nihms-572812-f0001"/>
  </fig>
  <fig id="F2" orientation="portrait" position="float">
    <label>Figure 2</label>
    <caption>
      <p>Speed and accuracy of Sailfish. (<bold>a</bold>) The correlation between qPCR estimates of gene abundance (x-axis) and the estimates of Sailfish. The qPCR results are taken from the microarray quality control study (MAQC)<sup><xref rid="R15" ref-type="bibr">15</xref></sup>. The results shown here are for the human brain tissue and the RNA-seq based estimates were computed using the reads from SRA accession SRX016366 (81,250,481 35bp single-end reads). The set of transcripts used in this experiment were the curated RefSeq<sup><xref rid="R16" ref-type="bibr">16</xref></sup> transcripts (accession prefix NM) from hg18 (31,148 transcripts). (<bold>b</bold>) The correlation between the ground truth FPKM in a simulated dataset (x-axis) and the abundance estimates of Sailfish. The quantification in this experiment was performed on a set of 96,520 transcript sequences taken from Ensembl<sup><xref rid="R17" ref-type="bibr">17</xref></sup> GRCh37.73. (<bold>c</bold>) The total time taken by each method, Sailfish, RSEM, eXpress and Cufflinks, to estimate isoform abundance on each dataset. The total time taken by a method is the height of the corresponding bar, and the total is further broken down into the time taken to perform read-alignment (for Sailfish, we instead measured the time taken to count the k-mers in the read set) and the time taken to quantify abundance given the aligned reads (or k-mer counts). All tools were run in multi-threaded mode (where applicable) and were allowed to use up to 16 threads. (<bold>d</bold>) Accuracy of each of the methods on human brain tissue and a synthetic dataset. Accuracy is measured by the Pearson (log-transformed) and Spearman correlation coefficients between estimated abundance values and MAQC qPCR data (for human brain tissue) or ground truth (for simulated data). Root-mean-square error (RMSE) and median percentage error (medPE) are calculated as described in the Online Methods.</p>
    </caption>
    <graphic xlink:href="nihms-572812-f0002"/>
  </fig>
  <fig id="F3" orientation="portrait" position="float">
    <label>Algorithm 1</label>
    <caption>
      <p>An EM iteration. One iteration of the expectation-maximization procedure that updates the estimated k-mer allocations α(·,·) and computes new estimates of relative transcript abundance μ′′ based on the current estimates of relative transcript abundance μ′.</p>
    </caption>
    <graphic xlink:href="nihms-572812-f0003"/>
  </fig>
  <fig id="F4" orientation="portrait" position="float">
    <label>Algorithm 2</label>
    <caption>
      <p>A SQUAREM iteration. One iteration updates the relative abundance estimates according to an accelerated EM procedure whose update direction and magnitude are dynamically computed<sup><xref rid="R11" ref-type="bibr">11</xref></sup>.</p>
    </caption>
    <graphic xlink:href="nihms-572812-f0004"/>
  </fig>
</floats-group>
