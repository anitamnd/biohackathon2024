<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Genomics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Genomics</journal-id>
    <journal-title-group>
      <journal-title>BMC Genomics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2164</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4240218</article-id>
    <article-id pub-id-type="publisher-id">1471-2164-15-S6-S10</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2164-15-S6-S10</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Explaining evolution via constrained persistent perfect phylogeny</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>Paola</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>bonizzoni@disco.unimib.it</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Carrieri</surname>
          <given-names>Anna Paola</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Della Vedova</surname>
          <given-names>Gianluca</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
      </contrib>
      <contrib contrib-type="author" id="A4">
        <name>
          <surname>Trucco</surname>
          <given-names>Gabriella</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Dipartimento di Informatica Sistemistica e Comunicazione, Università degli Studi di Milano-Bicocca, viale Sarca 336, Milano, Italy</aff>
    <aff id="I2"><label>2</label>Dipartimento di Informatica, Università degli Studi di Milano, Via Bramante 65, Crema, Italy</aff>
    <pub-date pub-type="collection">
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>10</month>
      <year>2014</year>
    </pub-date>
    <volume>15</volume>
    <issue>Suppl 6</issue>
    <supplement>
      <named-content content-type="supplement-title">Proceedings of the Twelfth Annual Research in Computational Molecular Biology (RECOMB) Satellite Workshop on Comparative Genomics</named-content>
      <named-content content-type="supplement-editor">Laxmi Parida, Gurinder Atwal and Bud Mishra</named-content>
    </supplement>
    <fpage>S10</fpage>
    <lpage>S10</lpage>
    <permissions>
      <copyright-statement>Copyright © 2014 Bonizzoni et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <copyright-holder>Bonizzoni et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0">http://creativecommons.org/licenses/by/4.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2164/15/S6/S10"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>The perfect phylogeny is an often used model in phylogenetics since it provides an efficient basic procedure for representing the evolution of genomic binary characters in several frameworks, such as for example in haplotype inference. The model, which is conceptually the simplest, is based on the infinite sites assumption, that is no character can mutate more than once in the whole tree. A main open problem regarding the model is finding generalizations that retain the computational tractability of the original model but are more flexible in modeling biological data when the infinite site assumption is violated because of e.g. back mutations. A special case of back mutations that has been considered in the study of the evolution of protein domains (where a domain is acquired and then lost) is persistency, that is the fact that a character is allowed to return back to the ancestral state. In this model characters can be gained and lost at most once. In this paper we consider the computational problem of explaining binary data by the Persistent Perfect Phylogeny model (referred as PPP) and for this purpose we investigate the problem of reconstructing an evolution where some constraints are imposed on the paths of the tree.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We define a natural generalization of the PPP problem obtained by requiring that for some pairs (character, species), neither the species nor any of its ancestors can have the character. In other words, some characters cannot be persistent for some species. This new problem is called Constrained PPP (CPPP). Based on a graph formulation of the CPPP problem, we are able to provide a polynomial time solution for the CPPP problem for matrices whose conflict graph has no edges. Using this result, we develop a parameterized algorithm for solving the CPPP problem where the parameter is the number of characters.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>A preliminary experimental analysis shows that the constrained persistent perfect phylogeny model allows to explain efficiently data that do not conform with the classical perfect phylogeny model.</p>
      </sec>
    </abstract>
    <kwd-group>
      <kwd>perfect phylogeny</kwd>
      <kwd>persistent perfect phylogeny</kwd>
      <kwd>fixed-parameter complexity</kwd>
    </kwd-group>
    <conference>
      <conf-date>19-22 October 2014</conf-date>
      <conf-name>Twelfth Annual Research in Computational Molecular Biology (RECOMB) Satellite Workshop on Comparative Genomics</conf-name>
      <conf-loc>Cold Spring Harbor, NY, USA</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Character-based phylogeny is a broad notion to represent an evolutionary history describing the ancestral relationships among extant taxa or individuals. Recent applications show that the model can be applied to study the evolution of mutations related to various genomic information, such as protein domains [<xref ref-type="bibr" rid="B1">1</xref>] or markers in tumors. Thus in our formulation, it is not important whether we are actually studying taxa or individuals or other genomic data. We will follow the usual convention of calling <italic>species </italic>the units of study. The main element of this notion is that the instance is also made of a set of <italic>characters</italic>, and each species is in a specific state for each character [<xref ref-type="bibr" rid="B2">2</xref>]. The goal is to find a phylogeny where the known species are the leaves, and the internal nodes are labeled--just as the leaves--by a state for each character. For each edge (<italic>x, y</italic>) of the phylogeny, the mutated characters along the edge are those whose states are different in <italic>x </italic>and <italic>y</italic>. The simplest case is when all characters are binary, that is only two states (0 and 1) are possible, modeling the situation when each species has or does not have a given feature, such as wings (a phenotypical trait) or the mutation encoding lactase persistence (a genotypical trait).</p>
    <p>Moreover, we are assuming a coalescent model, that is the fact that a characteristic shared by a set of species can be traced back to a single ancestral species. Assuming that the state 1 encodes the fact that a species has a given character (for example, the fact that the species has acquired a given mutation), the coalescent model implies that the phylogeny is directed. Restrictions on the type of changes from zero to one and vice versa lead to a variety of specific models [<xref ref-type="bibr" rid="B3">3</xref>].</p>
    <p>The perfect phylogeny is one of the most investigated coalescent models [<xref ref-type="bibr" rid="B2">2</xref>]. Conceptually the model is based on the infinite sites assumption, that is no character can mutate more than once in the whole tree. The binary perfect phylogeny problem has received much attention, culminating with the linear time algorithm when all data is known [<xref ref-type="bibr" rid="B4">4</xref>] and an efficient algorithm when the input data is incomplete [<xref ref-type="bibr" rid="B5">5</xref>]. While the infinite sites assumption is quite restrictive, the perfect phylogeny model turned out to be splendidly coherent within the haplotyping problem [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>], where we want to distinguish the two haplotypes present in each individual when only genotype data is given. More precisely, the interest here is in computing a set of haplotypes and a perfect phylogeny such that the haplotypes (i) label the vertices of the perfect phylogeny and (ii) explain the input set of genotypes. This context has been deeply studied in the last decade, giving rise to a number of algorithms [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>]. Still, the perfect phylogeny model and the assumptions that have been central in the previous decades cannot be employed without adaptations or improvements. A first generalization in the literature allows for more states (but keeping the infinite sites assumption). In the general case, the problem is NP-hard [<xref ref-type="bibr" rid="B10">10</xref>], but it has an algorithm parameterized by the number of states [<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B12">12</xref>]. The special cases when there are three or four possible states have more efficient algorithms [<xref ref-type="bibr" rid="B13">13</xref>-<xref ref-type="bibr" rid="B15">15</xref>].</p>
    <p>Even allowing more states cannot explain the biological complexity of real data, when homoplasy events (such as recurrent mutations or back mutations) are present. Two cases where those limitations are evident are the study of carcinogenesis and protein domains. Carcinogenesis consists of the factors and mechanisms that cause the onset of cancer; it results from many combinations of mutations, but only a few, called progression pathways, seem to account for most human tumors [<xref ref-type="bibr" rid="B16">16</xref>]. The observation that tumors are evolving cell populations leads to phylogeny-based studies. At the same time the intrinsic nature of quickly and degenerately proliferating cancer cells, results in a relative high amount of sites with multiple mutations (i.e., in violations of the infinite sites assumption). A protein domain is a part of protein sequence and structure that can evolve independently of the rest of the protein chain. Many proteins consist of several structural domains, while a domain may appear in a variety of different proteins. In this case it is quite frequent to acquire a domain and then to lose it [<xref ref-type="bibr" rid="B17">17</xref>].</p>
    <p>Thus a central goal of this paper is to find a model that is more widely applicable than the perfect phylogeny, while retaining its computational efficiency (in fact, more general models such as the Dollo and the Camin-Sokal models are NP-hard [<xref ref-type="bibr" rid="B3">3</xref>]). The problem of constructing phylogenies where the deviations from perfect phylogeny are small has been tackled under the name of near perfect phylogeny [<xref ref-type="bibr" rid="B11">11</xref>] or near perfect phylogeny haplotyping problems [<xref ref-type="bibr" rid="B18">18</xref>]. Especially the impossibility of losing a character that has been previously acquired is too restrictive, resulting in more elaborated models, such as the persistent character [<xref ref-type="bibr" rid="B1">1</xref>] and the General Character Compatibility [<xref ref-type="bibr" rid="B19">19</xref>,<xref ref-type="bibr" rid="B20">20</xref>].</p>
    <p>More precisely, the Persistent Perfect Phylogeny model [<xref ref-type="bibr" rid="B21">21</xref>] allows each character to be lost (i.e., going from state 1 to 0) in at most an edge of the phylogeny, while the General Character Compatibility imposes some restrictions on the possible mutations (that is on the possible states labeling the endpoints of an edge), while allowing the input data to be a set of possible states for each character of a species. In this paper we combine the Persistent Perfect Phylogeny (PPP) and the General Character Compatibility (GCC), introducing the Constrained Persistent Perfect Phylogeny problem (CPPP) which generalizes the PPP by adding a constraint for some characters <italic>c </italic>in the input data, given by the fact they cannot be persistent for some species <italic>s </italic>(i.e., the state of <italic>c </italic>does not go from 1 to 0 for any edge lying on the path from the root to <italic>s</italic>). Since the CPPP problem is equivalent to a case of GCC whose complexity is still open [<xref ref-type="bibr" rid="B19">19</xref>,<xref ref-type="bibr" rid="B22">22</xref>], our results also apply to GCC.</p>
    <p>Finally, we explore some algorithmic solutions for the CPPP problem. In particular, we give a polynomial time solution of the CPPP problem over matrices whose conflict graph has no edge. This result partially answer the open problem stated in [<xref ref-type="bibr" rid="B21">21</xref>] of determining the computational complexity of the PPP problem. In the paper we have run a preliminary experimental analysis showing that our method can manage successfully binary characters data incorporating back mutations. The results show that the algorithm performs efficiently on simulated matrices as well as on real data taken from the HapMap project.</p>
    <sec>
      <title>The persistent perfect phylogeny</title>
      <p>Our approach follows [<xref ref-type="bibr" rid="B21">21</xref>] to which we refer the reader for a detailed discussion of PPP, while we give here only a cursory treatment. The input of the PPP problem is an <italic>n </italic>× <italic>m </italic>binary matrix <italic>M </italic>whose columns are associated with the set <italic>C </italic>= {<italic>c</italic><sub>1</sub>, . . . , <italic>c<sub>m</sub></italic>} of characters and whose rows are associated with the set <italic>S </italic>= {<italic>s</italic><sub>1</sub>, . . . , <italic>s<sub>n</sub></italic>} of species. Then <italic>M</italic>[<italic>i, j</italic>] = 1 if and only if the species <italic>s<sub>i </sub></italic>has character <italic>c<sub>j</sub></italic>, otherwise <italic>M</italic>[<italic>i, j</italic>] = 0. The character <italic>c </italic>is <italic>gained </italic>in the only edge where its state goes from 0 to 1 or, more formally, in the edge (<italic>x, y</italic>) such that <italic>y </italic>is a child of <italic>x </italic>and <italic>c </italic>has state 0 in <italic>x </italic>and state 1 in <italic>y</italic>. In this case the edge (<italic>x, y</italic>) is labeled by <italic>c</italic><sub>+</sub>. Conversely, <italic>c </italic>is <italic>lost </italic>in the edge (<italic>x, y</italic>) if <italic>y </italic>is a child of <italic>x </italic>and the <italic>c </italic>has state 1 in <italic>x </italic>and state 0 in <italic>y</italic>. In the latter case the edge (<italic>x, y</italic>) is labeled by <italic>c<sup>−</sup></italic>. For each character <italic>c</italic>, we allow at most one edge labeled by <italic>c<sup>− </sup></italic>[<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B23">23</xref>].</p>
      <p><bold>Definition 1 </bold>(Persistent Perfect Phylogeny) Let <italic>M </italic>be an <italic>n </italic>× <italic>m </italic>binary matrix. Then a <italic>persistent perfect phylogeny</italic>, in short <italic>p-pp</italic>, for <italic>M </italic>is a rooted tree <italic>T </italic>such that:</p>
      <p>1 each node <italic>x </italic>of <italic>T </italic>is labeled by a vector <italic>l<sub>x </sub></italic>of length <italic>m</italic>;</p>
      <p>2 the root of <italic>T </italic>is labeled by a vector of all zeroes, while for each node <italic>x </italic>of <italic>T </italic>the value <italic>l<sub>x</sub></italic>[<italic>j</italic>] ∈ {0, 1} represents the state of character <italic>c<sub>j </sub></italic>in tree <italic>T</italic>;</p>
      <p>3 each edge <italic>e </italic>= (<italic>v, w</italic>) is labeled by at least a character;</p>
      <p>4 for each character <italic>c<sub>j </sub></italic>there are at most two edges <italic>e </italic>= (<italic>x, y</italic>) and <italic>e</italic>' = (<italic>u, v</italic>) such that <italic>l<sub>x</sub></italic>[<italic>j</italic>] ≠ <italic>l<sub>y</sub></italic>[<italic>j</italic>] and <italic>l<sub>u</sub></italic>[<italic>j</italic>] ≠ <italic>l<sub>v</sub></italic>[<italic>j</italic>] (representing a change in the state of <italic>c<sub>j</sub></italic>). In that case <italic>e, e</italic>' occur along the same path from the root of <italic>T </italic>to a leaf of <italic>T</italic>; if <italic>e </italic>is closer to the root than <italic>e</italic>', then <italic>l<sub>x</sub></italic>[<italic>j</italic>] = <italic>l<sub>v</sub></italic>[<italic>j</italic>] = 0, <italic>l<sub>y</sub></italic>[<italic>j</italic>] = <italic>l<sub>u</sub></italic>[<italic>j</italic>] = 1, and the edge <italic>e </italic>is labeled <inline-formula><mml:math id="M1" name="1471-2164-15-S6-S10-i1" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">+</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>, while <italic>e</italic>' is labeled <inline-formula><mml:math id="M2" name="1471-2164-15-S6-S10-i2" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">-</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>;</p>
      <p>5 each row <italic>r </italic>of <italic>M </italic>labels exactly one node <italic>x </italic>of <italic>T</italic>. Moreover the vector <italic>l<sub>x </sub></italic>is equal to the row <italic>r</italic>.</p>
      <p>Let <italic>s </italic>be a species and let <italic>c </italic>be a character such that, in a persistent perfect phylogeny <italic>T</italic>, the path from the root of <italic>T </italic>to <italic>s </italic>traverses an edge labeled <italic>c<sup>−</sup></italic>. Then <italic>c </italic>is called persistent for <italic>s </italic>in <italic>T</italic>.</p>
      <p>The Persistent Perfect Phylogeny problem asks to find, if it exists, a persistent perfect phylogeny for a given binary matrix <italic>M</italic>. We can restate the PPP problem as a variant of the Incomplete Directed Perfect Phylogeny [<xref ref-type="bibr" rid="B5">5</xref>] by transforming the complete input matrix into an incomplete matrix, called extended matrix.</p>
      <p><bold>Definition 2 </bold>(Extended Matrix) Let <italic>M </italic>be an instance of the PPP problem. The <italic>extended matrix </italic>associated with <italic>M </italic>is an <italic>n </italic>× 2<italic>m </italic>matrix <italic>M<sub>e </sub></italic>over alphabet {0, 1, ?} which is obtained by replacing each column <italic>c </italic>of <italic>M </italic>by a pair of columns (<italic>c</italic><sup>+</sup>, <italic>c<sup>−</sup></italic>), where ? means that the value of such cell is not given. Moreover for each row <italic>s </italic>of <italic>M </italic>if <italic>M</italic>[<italic>s, c</italic>] = 1, then <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = 1 and <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 0, while if <italic>M</italic>[<italic>s, c</italic>] = 0, then <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] =? and <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] =?.</p>
      <p>In this case the characters (<italic>c</italic><sup>+</sup>, <italic>c<sup>−</sup></italic>) are called conjugate. Informally, the assignment of the <italic>conjugate </italic>pair (?, ?) in a species row <italic>s </italic>for two conjugate characters (<italic>c</italic><sup>+</sup>, <italic>c<sup>−</sup></italic>) means that character <italic>c </italic>could be persistent in species <italic>s</italic>, i.e., it is first gained and then lost. On the contrary, the pair (1, 0) means that character <italic>c </italic>is only gained by the species <italic>s</italic>. A <italic>completion </italic>of a pair (?, ?) associated to a species <italic>s </italic>and characters (<italic>c</italic><sup>+</sup>, <italic>c<sup>−</sup></italic>) of <italic>M<sub>e </sub></italic>consists of forcing <italic>M<sub>e</sub></italic>[<italic>c</italic><sup>+</sup>, <italic>s</italic>] = <italic>M<sub>e</sub></italic>[<italic>c<sup>−</sup>, s</italic>] = 0 or <italic>M<sub>e</sub></italic>[<italic>c</italic><sup>+</sup>, <italic>s</italic>] = <italic>M<sub>e</sub></italic>[<italic>c<sup>−</sup>, s</italic>] = 1, while a partial <italic>completion M<sub>e </sub></italic>is a completion of some of its conjugate pairs. Notice that <italic>M </italic>admits a persistent phylogeny if and only if there exists a completion of <italic>M<sub>e </sub></italic>admitting a directed perfect phylogeny [<xref ref-type="bibr" rid="B21">21</xref>].</p>
      <p>A fundamental contribution of [<xref ref-type="bibr" rid="B21">21</xref>], building upon [<xref ref-type="bibr" rid="B5">5</xref>], is to frame the problem as a graph theory question. We briefly recall here the two graphs that are used in the description of the algorithm.</p>
      <p>Let <italic>M </italic>be a binary matrix and let <italic>c</italic><sub>1</sub>, <italic>c</italic><sub>2 </sub>be two characters of <italic>M</italic>. Then the configurations induced by the pair (<italic>c</italic><sub>1</sub>, <italic>c</italic><sub>2</sub>) in <italic>M </italic>is the set of ordered pairs (<italic>M</italic>[<italic>s, c</italic><sub>1</sub>], <italic>M</italic>[<italic>s, c</italic><sub>2</sub>]) over all species <italic>S</italic>. Two characters <italic>c</italic><sub>1 </sub>and <italic>c</italic><sub>2 </sub>of <italic>M </italic>are <italic>conflicting </italic>if and only if the configurations induced by such pair of columns is the set of all possible pairs (0, 1), (1, 1), (1, 0) and (0, 0). The <italic>conflict graph G<sub>c </sub></italic>= (<italic>C, E<sub>c </sub></italic>⊆ <italic>C </italic>× <italic>C</italic>) of a matrix <italic>M </italic>has vertices <italic>C </italic>and as edges the pairs (<italic>c<sub>i</sub>, c<sub>j</sub></italic>) of conflicting characters (see Figure 1). We also need some graph-theoretic definitions. A graph without edges is called <italic>edgeless</italic>. A connected component is called <italic>nontrivial </italic>if it has more than one vertex.</p>
      <p>The second graph used in the algorithm provides a representation of a completion of characters of an extended matrix. The <italic>red-black graph G<sub>RB </sub></italic>= (<italic>V, E</italic>) associated to an extended matrix <italic>M<sub>e </sub></italic>is the edge-colored graph where (i) the vertices are the species and the conjugate pairs of <italic>M<sub>e </sub></italic>(that is for each two conjugate characters <italic>c</italic><sup>+ </sup>and <italic>c<sup>−</sup></italic>, only <italic>c </italic>is a vertex of <italic>G<sub>RB</sub></italic>), (ii) a pair (<italic>s, c</italic>) is a black edge iff the conjugate pairs <italic>c</italic><sup>+ </sup>and <italic>c<sup>− </sup></italic>are still incomplete in matrix <italic>M<sub>e </sub></italic>and <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = 1 and <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 0, (iii) (<italic>s, c</italic>) is a red edge iff the conjugate pairs <italic>c</italic><sup>+ </sup>and <italic>c<sup>− </sup></italic>are completed as <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 1.</p>
      <p>An algorithm to compute a persistent perfect phylogeny</p>
      <p>Let <italic>T </italic>be any persistent perfect phylogeny for a matrix <italic>M </italic>and consider a depth-first visit of <italic>T</italic>, the sequence of edge labels traversed during the visit is uniquely defined. The converse also holds, that is given a sequence <italic>C </italic>of edge labels, we can reconstruct the unique persistent perfect phylogeny <italic>T </italic>(if it exists) such that <italic>C </italic>is the sequence of edge labels traversed during a depth-first visit of <italic>T </italic>[<xref ref-type="bibr" rid="B21">21</xref>].</p>
      <p>The main idea is that we associate a partial phylogeny <italic>P </italic>to each prefix of <italic>C</italic>, where each leaf <italic>x </italic>of <italic>P </italic>is labeled with the submatrix <italic>M<sub>x </sub></italic>of <italic>M<sub>e </sub></italic>such that <italic>M<sub>x </sub></italic>has exactly the species and the characters that will be in the subtree of <italic>T </italic>rooted at <italic>x</italic>. Recall that each matrix <italic>M<sub>x </sub></italic>has a graph representation given by the red-black graph. Then determining the next edge label to be added to the prefix of <italic>C </italic>is called to <italic>realize </italic>a character in the red-black graph representing <italic>M<sub>x </sub></italic>as follows.</p>
      <p>Let (<italic>c</italic><sup>+</sup>, <italic>c<sup>−</sup></italic>) be two conjugate characters of <italic>M<sub>e </sub></italic>and let <italic>G<sub>RB </sub></italic>its associated red- black graph. Let <inline-formula><mml:math id="M3" name="1471-2164-15-S6-S10-i3" overflow="scroll"><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> be the connected component of <italic>G<sub>RB </sub></italic>containing the vertex <italic>c</italic>. A character is in one of three possible states: inactive (the initial state of all characters), active, and free. The <italic>realization </italic>of a character <italic>c </italic>in <italic>G<sub>RB </sub></italic>consists of the following steps:</p>
      <p>1 if <italic>c </italic>is inactive then:</p>
      <p>(a) for each species <inline-formula><mml:math id="M4" name="1471-2164-15-S6-S10-i5" overflow="scroll"><mml:mi>s</mml:mi><mml:mo class="MathClass-rel">∉</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, pose <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 0;</p>
      <p>(b) for each species <inline-formula><mml:math id="M5" name="1471-2164-15-S6-S10-i6" overflow="scroll"><mml:mi>s</mml:mi><mml:mo class="MathClass-rel">∈</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> if (<italic>c, s</italic>) is not an edge of <italic>G<sub>RB</sub></italic>, add a red edge(<italic>c, s</italic>) and complete <italic>M<sub>e </sub></italic>by posing <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 1;</p>
      <p>(c) remove from <italic>G<sub>RB </sub></italic>all black edges (<italic>c, s</italic>) and label <italic>c active</italic>.</p>
      <p>2 else if <italic>c </italic>is active and <italic>c </italic>is connected by red edges to all species in <inline-formula><mml:math id="M6" name="1471-2164-15-S6-S10-i7" overflow="scroll"><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, then:</p>
      <p>(a) all such red edges are deleted from <italic>G<sub>RB </sub></italic>and <italic>c </italic>is labeled <italic>free</italic>;</p>
      <p>Notice that when (i) <italic>c </italic>is free, or (ii) <italic>c </italic>is active but there exists a species <inline-formula><mml:math id="M7" name="1471-2164-15-S6-S10-i8" overflow="scroll"><mml:mi>s</mml:mi><mml:mo class="MathClass-rel">∈</mml:mo><mml:mi mathvariant="script">C</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> that is not connected to <italic>c </italic>by a red edge, none of the stated conditions hold. In these cases the realization is <italic>impossible</italic>.</p>
      <p>Figures 2 and 3 illustrate the realization of characters. Moreover, isolated vertices of <italic>G<sub>RB </sub></italic>correspond to leaves of the partial phylogeny <italic>P </italic>whose associated matrix has only one species; that instance is trivially solvable, therefore isolated vertices can be removed from <italic>G<sub>RB</sub></italic>.</p>
      <p>We recall that, to obtain an algorithm for PPP, it suffices to have an algorithm that finds the edge label to be added to the prefix of <italic>C </italic>computed up to that point. The sequence <inline-formula><mml:math id="M8" name="1471-2164-15-S6-S10-i9" overflow="scroll"><mml:mtext> </mml:mtext><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> obtained by a depth-first visit of the tree is a sequence of edge labels whose realization results in an edgeless red-black graph [<xref ref-type="bibr" rid="B21">21</xref>]. Such sequence <inline-formula><mml:math id="M9" name="1471-2164-15-S6-S10-i10" overflow="scroll"><mml:mtext> </mml:mtext><mml:mi mathvariant="script">C</mml:mi></mml:math></inline-formula> is called <italic>successful c-reduction </italic>of the red-black graph.</p>
      <p>The rest of the paper is devoted to give a formal definition of the CPPP problem and to provide an efficient algorithm to solve that problem. Moreover we will test our algorithm on some instances that do not admit a perfect phylogeny, showing that we are able to quickly compute a persistent perfect phylogeny, hence giving a possible phylogenetic interpretation of those data.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>We can now formally define the Constrained Persistent Perfect Phylogeny (CPPP) problem where the fact that a pair (<italic>c, s</italic>) (i.e., a character <italic>c </italic>and a species <italic>s</italic>) is constrained means that <italic>s </italic>and all its ancestors do not have the character <italic>c</italic>. The input of the problem is a binary matrix <italic>M </italic>and a set <inline-formula><mml:math id="M10" name="1471-2164-15-S6-S10-i11" overflow="scroll"><mml:mi>F</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:mo class="MathClass-op">…</mml:mo><mml:mo class="MathClass-punc">,</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula> of constraints, such as <inline-formula><mml:math id="M11" name="1471-2164-15-S6-S10-i12" overflow="scroll"><mml:mi>M</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> for each <italic>j</italic>. A solution for such instance is a persistent perfect phylogeny <italic>T </italic>for <italic>M </italic>such that, for each constraint <inline-formula><mml:math id="M12" name="1471-2164-15-S6-S10-i13" overflow="scroll"><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, none of the edges from the root of <italic>T </italic>to the leaf labeled by <inline-formula><mml:math id="M13" name="1471-2164-15-S6-S10-i14" overflow="scroll"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></inline-formula> is labeled <inline-formula><mml:math id="M14" name="1471-2164-15-S6-S10-i15" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">+</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>. This implies that no edge from the root of <italic>T </italic>to the leaf labeled by <italic>s<sub>i</sub>j </italic>can be labeled <inline-formula><mml:math id="M15" name="1471-2164-15-S6-S10-i16" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">-</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>.</p>
    <p>The idea of the extended matrix <italic>M<sub>e </sub></italic>applies also to the CPPP problem. In this case, if <italic>M</italic>[<italic>s, c</italic>] = 1, then <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = 1 and <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 0, if <italic>M</italic>[<italic>s, c</italic>] = 0 and (<italic>c, s</italic>) is a constraint, then <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 0. Finally, if <italic>M</italic>[<italic>s, c</italic>] = 0 but (<italic>c, s</italic>) is not a constraint, then <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] =? and <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] =?. An immediate extension of the result in [<xref ref-type="bibr" rid="B21">21</xref>] shows that <italic>M<sub>e </sub></italic>has a directed perfect phylogeny if and only if (<italic>M, F</italic>) has a constrained persistent perfect phylogeny.</p>
    <p>Just as for the PPP problem, we first explore a graph formulation of the CPPP problem based on the equivalence of PPP to a problem of completing a matrix where each character <italic>c </italic>has two columns <italic>c</italic><sup>+</sup>, <italic>c<sup>−</sup></italic>, with <italic>c</italic><sup>+ </sup>(<italic>c<sup>−</sup></italic>) equal to 1 in a species <italic>s </italic>in the matrix corresponds to the fact that <italic>s </italic>has gained (lost) the character <italic>c</italic>. The graph formulation derives again by representing a completion in terms of red-black graph associated to extended matrices. Notice that there exists a 1-to-1 correspondence between completing entries of the matrix and realizing characters of the red-black graph. When considering the CPPP problem, some entries of a partially completed matrix are constrained which means that some characters in the associated red-black graph cannot be realized. On the other hand, all characters in a red-black graph for the PPP problem can be realized. Thus it is quite easy to show that the main red-black graph reduction characterization stated for the PPP problem can be extended to the constrained persistent perfect phylogeny problem, by simply adding the constraint that some characters cannot be realized in a red-black graph.</p>
    <p>Now, the red-black graph reduction turns out to be quite useful to investigate new algorithmic solutions to the PPP problem. In this paper we are able to prove that there exists a class of binary matrices that always admit a positive solution for the PPP problem, that is they admit a <italic>persistent perfect phylogeny </italic>that can be computed in polynomial time. For this special case we also provide a polynomial algorithm that works for the general CPPP problem. Based on this polynomial time algorithm we give a fixed-parameter (in the number of characters) algorithm for the CPPP, based on the search tree technique [<xref ref-type="bibr" rid="B24">24</xref>], improving the exponential time algorithm given in [<xref ref-type="bibr" rid="B21">21</xref>].</p>
    <p>We observe that the CPPP problem is a special case of the General Character Compatibility problem (GCC) [<xref ref-type="bibr" rid="B19">19</xref>]. An instance of the GCC problem is a matrix <italic>M<sub>G </sub></italic>having rows which are species and columns that are characters. Each entry of the matrix <italic>M<sub>G </sub></italic>is a subset of the states that character <italic>c </italic>may assume in species <italic>s</italic>. Another part of the instance is a specification of all allowed transitions between states in a solution. A feasible solution is a perfect phylogeny where for each species <italic>s </italic>and for each character <italic>c</italic>, the state is picked from the input set <italic>M<sub>G</sub></italic>[<italic>s, c</italic>]. Given an instance (<italic>M, F</italic>) of CPPP, we obtain a matrix <italic>M<sub>G </sub></italic>as follows. If <italic>M</italic>[<italic>s, c</italic>] = 1, then <italic>M<sub>G</sub></italic>[<italic>s, c</italic>] = {1}. If <italic>M</italic>[<italic>s, c</italic>] = 0 and (<italic>c, s</italic>) ∈ <italic>F</italic>, then <italic>M<sub>G</sub></italic>[<italic>s, c</italic>] = {0}. Finally, if <italic>M</italic>[<italic>s, c</italic>] = 0 and (<italic>c, s</italic>) ∉ <italic>F</italic>, then <italic>M<sub>G</sub></italic>[<italic>s, c</italic>] = {0, 2}. The only allowed transitions are from the state 0 to 1 and from 1 to 2. This case of GCC corresponds to cases 5 and 6 of Table <xref ref-type="table" rid="T1">1</xref> in [<xref ref-type="bibr" rid="B19">19</xref>], whose complexity is reported as open. Thus the results we give in the paper also apply to those cases.</p>
    <table-wrap id="T1" position="float">
      <label>Table 1</label>
      <caption>
        <p>Running times on unconstrained simulated instances.</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <th align="center">Species</th>
            <th align="center">Characters</th>
            <th align="center">Instances completed within 15 minutes</th>
            <th align="center">Min time (sec)</th>
            <th align="center">Max time (sec)</th>
            <th align="center">Average time (sec)</th>
            <th align="center">Standard deviation</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="center">10</td>
            <td align="center">5</td>
            <td align="right">100<italic>/</italic>100</td>
            <td align="right">0.00</td>
            <td align="right">0.01</td>
            <td align="right">0.00</td>
            <td align="right">0.00</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">7</td>
            <td align="right">100<italic>/</italic>100</td>
            <td align="right">0.00</td>
            <td align="right">0.25</td>
            <td align="right">0.01</td>
            <td align="right">0.03</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">10</td>
            <td align="right">100<italic>/</italic>100</td>
            <td align="right">0.00</td>
            <td align="right">1.93</td>
            <td align="right">0.11</td>
            <td align="right">0.30</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">12</td>
            <td align="right">94<italic>/</italic>100</td>
            <td align="right">0.00</td>
            <td align="right">12.95</td>
            <td align="right">0.84</td>
            <td align="right">1.93</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">15</td>
            <td align="right">84<italic>/</italic>100</td>
            <td align="right">0.00</td>
            <td align="right">43.89</td>
            <td align="right">5.71</td>
            <td align="right">9.80</td>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">10</td>
            <td align="right">100<italic>/</italic>100</td>
            <td align="right">0.00</td>
            <td align="right">4.72</td>
            <td align="right">0.08</td>
            <td align="right">0.47</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">15</td>
            <td align="right">97<italic>/</italic>100</td>
            <td align="right">0.02</td>
            <td align="right">18.12</td>
            <td align="right">1.15</td>
            <td align="right">2.53</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">20</td>
            <td align="right">93<italic>/</italic>100</td>
            <td align="right">0.13</td>
            <td align="right">95.03</td>
            <td align="right">10.44</td>
            <td align="right">19.14</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">25</td>
            <td align="right">79<italic>/</italic>100</td>
            <td align="right">1.09</td>
            <td align="right">253.68</td>
            <td align="right">41.98</td>
            <td align="right">60.35</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">30</td>
            <td align="right">63<italic>/</italic>100</td>
            <td align="right">3.84</td>
            <td align="right">247.03</td>
            <td align="right">59.06</td>
            <td align="right">63.81</td>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">20</td>
            <td align="right">100<italic>/</italic>100</td>
            <td align="right">0.06</td>
            <td align="right">89.02</td>
            <td align="right">2.04</td>
            <td align="right">8.93</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">30</td>
            <td align="right">98<italic>/</italic>100</td>
            <td align="right">0.99</td>
            <td align="right">156.16</td>
            <td align="right">22.03</td>
            <td align="right">33.17</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">40</td>
            <td align="right">80<italic>/</italic>100</td>
            <td align="right">7.23</td>
            <td align="right">598.32</td>
            <td align="right">128.47</td>
            <td align="right">154.92</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">50</td>
            <td align="right">45<italic>/</italic>100</td>
            <td align="right">19.14</td>
            <td align="right">585.42</td>
            <td align="right">198.81</td>
            <td align="right">146.39</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">60</td>
            <td align="right">19<italic>/</italic>100</td>
            <td align="right">50.26</td>
            <td align="right">577.1</td>
            <td align="right">319.25</td>
            <td align="right">183.10</td>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">60</td>
            <td align="center">30</td>
            <td align="right">99<italic>/</italic>100</td>
            <td align="right">0.64</td>
            <td align="right">222.79</td>
            <td align="right">14.36</td>
            <td align="right">33.21</td>
          </tr>
          <tr>
            <td align="center">60</td>
            <td align="center">45</td>
            <td align="right">90<italic>/</italic>100</td>
            <td align="right">8.76</td>
            <td align="right">590.03</td>
            <td align="right">123.05</td>
            <td align="right">148.48</td>
          </tr>
          <tr>
            <td align="center">60</td>
            <td align="center">60</td>
            <td align="right">51<italic>/</italic>100</td>
            <td align="right">37.63</td>
            <td align="right">593.06</td>
            <td align="right">252.34</td>
            <td align="right">168.92</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <p>All times are in seconds.</p>
      </table-wrap-foot>
    </table-wrap>
    <p>We recall that a main result of [<xref ref-type="bibr" rid="B21">21</xref>] is that finding a solution of PPP is equivalent to finding a successful c-reduction, that is a sequence of edge labels (corresponding to a depth-first visit of the tree) whose realization makes the red-black graph edgeless. For the CPPP problem a similar result holds, but we have to adapt the notion of reduction, so that there is a third case when the reduction is impossible; when for some species <italic>s</italic>, with (<italic>c, s</italic>) ∈ <italic>F </italic>(that is <italic>M<sub>e</sub></italic>[<italic>s, c</italic><sup>+</sup>] = <italic>M<sub>e</sub></italic>[<italic>s, c<sup>−</sup></italic>] = 0), (<italic>c, s</italic>) is also a red edge of <italic>G<sub>RB</sub></italic>. Notice that, in order to obtain an algorithm to compute a persistent perfect phylogeny, it suffices to have an algorithm that finds the edge label to be added to the prefix of <italic>C </italic>computed up to that point.</p>
    <sec>
      <title>Solving CPPP on matrices with edgeless conflict graphs</title>
      <p>In the following, we will exploit some properties of the red-black graph to show that a matrix <italic>M </italic>whose conflict graph is edgeless always admits a persistent perfect phylogeny. Moreover, we provide a polynomial time algorithm for the CPPP problem in this case.</p>
      <p>Given <italic>M </italic>a binary matrix, the <italic>partial order graph </italic>for <italic>M </italic>is the partial order <italic>P </italic>obtained by ordering columns of <italic>M </italic>under the <italic>&lt;</italic>relation which is defined as follows: given two character <italic>c </italic>and <italic>c</italic>', we will say that <italic>c &lt; c</italic>' iff <italic>M</italic>[<italic>s, c</italic>] <italic>≤ M</italic>[<italic>s, c</italic>'] for each species <italic>s</italic>. Moreover, we build a graph <italic>G </italic>= (<italic>V, E</italic>), called <italic>adjacency graph </italic>for <italic>M </italic>: <italic>V </italic>is the set of columns of <italic>M </italic>and (<italic>u, v</italic>) is an edge of <italic>G </italic>if and only if <italic>u, v </italic>are <italic>adjacent</italic>, i.e. there is a species <italic>s </italic>that is adjacent to both <italic>u </italic>and <italic>v </italic>in the red-black graph for the extended matrix <italic>M<sub>e </sub></italic>associated with <italic>M</italic>. Our algorithm for solving the CPPP problem finds a successful <italic>c</italic>-reduction by simply computing the maximal inactive characters in the poset <italic>P </italic>that can be realized in the red-black graph.</p>
      <p>In the following we give some Lemmas that are used to show that maximal characters in the poset <italic>P </italic>can be realized without inducing in the red-black graph any <italic>red-sigma graph</italic>: this is a graph of red edges consisting of a path of length four and having two characters and three species. Such a graph represents the forbidden matrix {0, 1}, {1, 0} and {1, 1} in the completion of the extended matrix <italic>M<sub>e </sub></italic>and thus whenever it is present in the red-black graph it means that the completion does not admit a directed perfect phylogeny [<xref ref-type="bibr" rid="B2">2</xref>]. In fact, by definition of red-black graph associated to a completion, a red-sigma graph corresponds to two completed characters <italic>a</italic><sup>+</sup>, <italic>b</italic><sup>+ </sup>in the extended matrix such that <italic>M<sub>e</sub></italic>[<italic>s</italic><sub>1</sub>, <italic>a</italic><sup>+</sup>] = 1 = <italic>M<sub>e</sub></italic>[<italic>s</italic><sub>2</sub>, <italic>a</italic><sup>+</sup>] and <italic>M<sub>e</sub></italic>[<italic>s</italic><sub>2</sub>, <italic>b</italic><sup>+</sup>] = 1 = <italic>M<sub>e</sub></italic>[<italic>s</italic><sub>3</sub>, <italic>b</italic><sup>+</sup>], while all other entries of <italic>M<sub>e </sub></italic>are 0 for pairs (<italic>a</italic><sup>+</sup>, <italic>s</italic><sub>3</sub>) and (<italic>b</italic><sup>+</sup>, <italic>s</italic><sub>1</sub>). The following property is easily proved by induction on the length of a path in the red-black graph connecting two maximal characters.</p>
      <p><bold>Algorithm 1: </bold>Procedure Solve-CPPP-empty-conflict</p>
      <p><bold>Input </bold>: A constrained binary matrix (<italic>M, F</italic>) whose associated conflict graph is edgeless.</p>
      <p><bold>Output </bold>: A realization <italic>S<sub>c </sub></italic>of the characters of <italic>M </italic>resulting in a constrained persistent perfect phylogeny for (<italic>M, F</italic>), if such a phylogeny exists.</p>
      <p><bold>1 </bold><italic>S<sub>c </sub>← </italic>empty sequence;</p>
      <p><bold>2 </bold><italic>P ← </italic>the partial order for <italic>M</italic>;</p>
      <p><bold>3 </bold><italic>G<sub>RB </sub>← </italic>the red-black graph for the extended matrix <italic>M<sub>e </sub></italic>of <italic>M</italic>.</p>
      <p>
        <bold>4 while </bold>
        <italic>G<sub>RB </sub>is not edgeless </italic>
        <bold>do</bold>
      </p>
      <p><bold>5 </bold><italic>C<sub>M </sub>← </italic>maximal elements in <italic>P </italic>that are in the same connected component of <italic>G<sub>RB</sub></italic>;</p>
      <p><bold>6 </bold><italic>D ← </italic>the subset of <italic>C<sub>M </sub></italic>consisting of the characters that can be realized;</p>
      <p><bold>7 if </bold><italic>D </italic>= ∅ <bold>then</bold></p>
      <p>
        <bold>8 return </bold>
        <italic>no solution</italic>
      </p>
      <p>9 else</p>
      <p><bold>10 </bold>Add to <italic>S<sub>c </sub></italic>all characters in <italic>D</italic>;</p>
      <p><bold>11 </bold>Realize the characters of <italic>D </italic>in any order, updating <italic>G<sub>RB</sub></italic>;</p>
      <p><bold>12 </bold>add to <italic>D </italic>the free characters in the graph <italic>G<sub>RB</sub></italic>;</p>
      <p><bold>Lemma 3 </bold><italic>Let M be a binary matrix with an edgeless conflict graph. Assume that the extended matrix associated with M induces a connected red-black graph and let P be the partial order graph for M. Let C<sub>M </sub>be the set of maximal elements in P. Then C<sub>M </sub>consists of elements that are pairwise adjacent in the adjacency graph for M</italic>.</p>
      <p>The following properties can be proved by as consequences of the definition of realization of characters, and assuming that the input matrix has an edgeless conflict graph.</p>
      <p><bold>Lemma 4 </bold><italic>Let M be a binary matrix that has an edgeless conflict graph. Let G<sub>RB </sub>be the red-black graph for the extended matrix associated with M. The realization of two characters a and b that are adjacent in the adjacency graph for M adds at most two disjoint components consisting of red edges. In this case one connected component has the vertex a and the other one b</italic>.</p>
      <p><bold>Lemma 5 </bold><italic>Let G<sub>RB </sub>be a connected red-black graph whose conflict graph is edgeless. Let C<sub>M </sub>be the set of maximal characters in G<sub>RB </sub>and let <inline-formula><mml:math id="M16" name="1471-2164-15-S6-S10-i17" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> be the set of maximal characters in the red-black graph <inline-formula><mml:math id="M17" name="1471-2164-15-S6-S10-i18" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> obtained after the realization of C<sub>M</sub>. Then: </italic>(<italic>1</italic>) <italic>the elements of C<sub>M </sub>are in at most two distinct connected components of <inline-formula><mml:math id="M18" name="1471-2164-15-S6-S10-i19" overflow="scroll"><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msup></mml:math></inline-formula> and </italic>(<italic>2</italic>) <italic>in each of such disjoint connected component, each maximal character <inline-formula><mml:math id="M19" name="1471-2164-15-S6-S10-i20" overflow="scroll"><mml:mi>c</mml:mi><mml:mo class="MathClass-rel">∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>′</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula> is either adjacent to all species of the component or all active characters of C<sub>M </sub>are free</italic>.</p>
      <p>Notice that, the absence of conflicts does not guarantee that a solution actually exists. However, we are able to provide an efficient algorithm (Algorithm 1) for this case, which will be a cornerstone for our algorithm for the general case.</p>
      <p>Algorithm 1 builds a successful c-reduction <italic>S<sub>c </sub></italic>by iteratively adding to <italic>S<sub>c </sub></italic>the maximal inactive characters or free characters of the red-black graph <italic>G<sub>RB</sub></italic>. Notice that the successful c-reduction provides a completion of the extended matrix that admits a perfect phylogeny. The latter can be built using the classical linear time algorithm [<xref ref-type="bibr" rid="B2">2</xref>].</p>
      <p><bold>Theorem 6 </bold><italic>Let </italic>(<italic>M, F</italic>) <italic>be a binary matrix that has an edgeless conflict graph. Then Algorithm 1 computes a successful c-reduction of the red-black graph associated to the extended matrix for M, if it exists. Moreover, if F is empty then M admits a solution</italic>.</p>
      <p><italic>Proof </italic>First observe that the correctness of Algorithm 1 is a consequence of the fact that maximal characters are realized before any character they include by the <italic>&lt;</italic>-relation. Assume that <italic>c</italic><sub>1 </sub><italic>&lt; c</italic><sub>2 </sub>and let <italic>T </italic>be a persistent perfect phylogeny. If <italic>c</italic><sub>2 </sub>is not persistent for <italic>s </italic>in <italic>T</italic>, then also <italic>c</italic><sub>1 </sub>is not persistent for <italic>s </italic>in <italic>T</italic>. In fact, assume to the contrary that <italic>c</italic><sub>1 </sub>is persistent for <italic>s </italic>in <italic>T </italic>and <italic>c</italic><sub>2 </sub>is not persistent for <italic>s</italic>. This fact implies that there exists a species <italic>s</italic>' such that has <italic>c</italic><sub>1 </sub>and <italic>s</italic>' and <italic>s </italic>share a common ancestor in the tree which is below edge labeled <italic>c</italic><sup>+</sup>. Since <italic>c</italic><sub>1 </sub><italic>&lt; c</italic><sub>2</sub>, it follows that species <italic>s</italic>' has also character <italic>c</italic><sub>2 </sub>and thus the edge labeled by <italic>c<sup>− </sup></italic>is below the edge <inline-formula><mml:math id="M20" name="1471-2164-15-S6-S10-i21" overflow="scroll"><mml:msubsup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">+</mml:mo></mml:mrow></mml:msubsup></mml:math></inline-formula>. But since <italic>s </italic>does not have character <italic>c</italic><sub>2 </sub>and <italic>c</italic><sub>2 </sub>cannot be persistent we obtain a contradiction.</p>
      <p>We show that at each iteration of Algorithm 1 each connected component <italic>G<sub>RB </sub></italic>has only black edges, or the connected components with red edges has no red-sigma graphs. Initially, by assumption, since no character is active, no red edge is in the connected components of the red-black graph. Then, by applying Lemma 3 and 4, the realization of the maximal characters <italic>C<sub>M </sub></italic>of poset <italic>P </italic>does not induce any red sigma-graph, thus proving the invariant. Now, a successive iteration of the algorithm requires to add to <italic>S<sub>c </sub></italic>the free characters or the maximal inactive characters of the red-black graph. By applying Lemma 5, the red-black graph has connected components without red edges or at most two components having red edges, since the active characters by statement 1 are in at most two components. For the first type of components, the invariant property is immediate since the component does not have any red edge. Consider now the second type of components. By Lemma 5, there are at most two such components, moreover, either each connected component has some maximal active character that are free or the maximal inactive are adjacent to all species of the connected component of the red-black graph. Assume that the active characters in the connected component having red-edges are free. Thus by definition, these active characters are removed from the red-black graph including all incident edges. Otherwise, the maximal active characters are all adjacent to all species and thus they are realized without adding new red edges. In both cases, the invariant property holds. Clearly, if all characters are in <italic>S<sub>c </sub></italic>after the application of the algorithm, it is immediate that the red-black graph is edgeless since all active characters are free (no red-sigma graph is possible, indeed). Thus <italic>S<sub>c </sub></italic>is a successful c-reduction. Observe that in case <italic>F </italic>is empty, all characters can be realized, and consequently, the sequence <italic>S<sub>c </sub></italic>after the iterations of the algorithm includes all characters of the red-black graph, thus implying that a solution always exists.   □</p>
    </sec>
    <sec>
      <title>An algorithm for CPPP</title>
      <p>In this section we propose an algorithm for the CPPP problem that is based on the procedure <bold>Solve-CPPP-empty-conflict</bold>(<italic>M</italic>). Our algorithm is based on the search tree technique [<xref ref-type="bibr" rid="B24">24</xref>], where we explore the tree of all possible c-reductions. Since in a c-reduction each signed character (<italic>c</italic><sup>+ </sup>or <italic>c<sup>−</sup></italic>) can appear at most once, the search tree has at most (2<italic>m</italic>)! leaves. Therefore we only need to describe a polynomial-time algorithm to compute an edge of the search tree (which mainly consists of realizing a signed character).</p>
      <p>Just as the algorithm in [<xref ref-type="bibr" rid="B21">21</xref>], we transform the matrix <italic>M </italic>of the instance (<italic>M, F</italic>) into an extended matrix <italic>M<sub>e </sub></italic>which is then analyzed to find a solution. In fact, (<italic>M, F</italic>) has a solution if and only if there exists a successful c-reduction for <italic>M<sub>e </sub></italic>that can be associated to a constrained perfect phylogeny. The algorithm in [<xref ref-type="bibr" rid="B21">21</xref>] explores all feasible permutations of the set of characters (feasible permutations means that <italic>c<sup>− </sup></italic>must follow <italic>c</italic><sup>+ </sup>and that all constraints are satisfied) of <italic>M<sub>e </sub></italic>in order to find one that is a successful c-reduction, if such a c-reduction exists.</p>
      <p>Clearly computing all permutation is not efficient, therefore we implicitly build a decision tree, where at each step we fix a character in a given position of the permutation. To each node <italic>x </italic>of the decision tree, we associate the matrix <italic>M<sub>e</sub></italic>(<italic>x</italic>), obtained from <italic>M<sub>e </sub></italic>by realizing the characters labeling the edges from the root to <italic>x</italic>, and its associated red-black and conflict graphs (respectively <italic>G<sub>RB</sub></italic>(<italic>x</italic>), <italic>G<sub>c</sub></italic>(<italic>x</italic>)). When <italic>G<sub>c</sub></italic>(<italic>x</italic>) is edgeless, instead of further exploring the decision tree, we apply Algorithm 1. At the same time, if <italic>G<sub>RB</sub></italic>(<italic>x</italic>) contains a red-sigma graph, then <italic>M<sub>e</sub></italic>(<italic>x</italic>) does not admit a persistent perfect phylogeny. A fortiori, in that case <italic>M<sub>e</sub></italic>(<italic>x</italic>) cannot admit a persistent perfect phylogeny, hence we can stop exploring that portion of the decision tree. Moreover, we can stop the search as soon as we find a solution, since we have no optimization criterion to discriminate between feasible solutions. In practice, all those criteria allow to avoid exploring a large part of the decision tree, as shown in our experimental analysis.</p>
    </sec>
    <sec>
      <title>Experimental analysis</title>
      <p>We have implemented our algorithm as a C++ program and we have tested it over simulated data produced by <italic>ms </italic>[<xref ref-type="bibr" rid="B25">25</xref>]. Moreover, we have tested our program on real data coming from the International HapMap project [<xref ref-type="bibr" rid="B26">26</xref>]. All tests have been performed on a standard workstation.</p>
      <p>The two different kinds of data correspond to two separate goals. The analysis on simulated data is aimed at studying the scalability of our approach for increasing numbers of species and characters. More precisely we have run our program for <italic>n </italic>= 10, 20, 40, 60 (recall that <italic>n </italic>is the number of species) and for values of <italic>m </italic>(the number of characters) ranging from <italic>n/</italic>2 to <inline-formula><mml:math id="M21" name="1471-2164-15-S6-S10-i22" overflow="scroll"><mml:mfrac><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mi>n</mml:mi></mml:math></inline-formula>. The reason for the choice of <italic>m </italic>is based on some properties of all persistent phylogenies. Let <italic>T </italic>be a persistent perfect phylogeny consistent with a <italic>n </italic>× <italic>m </italic>matrix, and assume that the input matrix has no duplicated rows or columns. Then we can prove that <italic>n/</italic>2 <italic>≤ m ≤ </italic>2<italic>n</italic>.</p>
      <p>Moreover, <italic>ms </italic>produces matrices that have a perfect phylogeny, but can have duplicated rows and columns. To introduce back mutations, we have randomly modified at most one state of each duplicated row. For each choice of the parameters <italic>n </italic>and <italic>m </italic>we have produced 100 random instances, on which we have run our program with a 15-minute timeout, without imposing any constraint. The results are represented in Table 1.</p>
      <p>Then, for the first 10 of the 100 instances of each parameter choice, we have modified the input matrices, by introducing some random constraints, in order to determine if constraining the set of feasible solutions can help in finding a persistent phylogeny. For each instance of the first phase, we have produced 10 instances with 1 or 16 random constraints. For both cases we determine when at least one of the 10 constrained instances is solved more quickly than the unconstrained instance. The goal is to determine when there is a sizable (in our case 10%) probability that introducing some random constraints can help in computing a persistent phylogeny. Moreover, we determine when the median of the 10 constrained instances is solved more quickly than the unconstrained instance. In this case the goal is to determine when there is a 50% probability that some random constraints can help in computing a persistent phylogeny.</p>
      <p>The most important result of this experiment is that for instances where our implementation requires at least a second (on average), the idea of introducing random constraints is often beneficial. This fact suggests a direction for further improvements, that is incorporating into our program some deterministic constraints, based on a cursory analysis of the conflict and of the red-black graphs. Actually, how we manage an edgeless conflict graph is as an example of this idea. Table 2 summarizes the experiment on constrained simulated instances.</p>
      <p>Finally, the algorithm has been tested on real data coming from the International HapMap project. The data are classified by type of population. In our case, we used data from the set ASW (African ancestry in Southwest USA). Each individual is described by the two haplotypes (in our application the two haplotypes correspond to two different species, i.e. two different rows of the matrix). This experiment investigates the usefulness of the constrained persistent model to manage haplotypes data that cannot be explained by the perfect phylogeny model. In fact none of those instances admits a perfect phylogeny, but our model and implementation are able to find a reasonable interpretation to the data. The data set consists of binary matrices of dimensions 10 × 10, 26 × 15, 26 × 25, and 26 × 30. For each group we considered 10 matrices. In all cases the matrices do not admit perfect phylogeny, and the number of conflicts changes from a minimum of 4 to a maximum of 138. Increasing the size of the matrix, and therefore the number of conflicts, the percentage of matrices that admit persistent perfect phylogeny decreases. More in detail, 80% of the tested matrices of size 10 × 10 admits solution, only 20% of the tested matrices of size 26 × 15 admits solution, and none of the sets 26 × 25, and 26 × 30 admits solution. The results show that haplotype data may be related by the persistent phylogeny in case they cannot be explained by the perfect model. It would be interesting to investigate the biological soundness of the persistent perfect phylogeny in this context.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>The algorithms and models discussed in the paper may have interesting applications in the construction of evolutionary trees based on the analysis of binary genetic markers, where variants of the perfect phylogeny have already been considered, such as in the study of evolution based on introns [<xref ref-type="bibr" rid="B1">1</xref>] or progression pathways using tumor markers or in discovering significant associations between phenotypes and single-nucleotide polymorphism markers [<xref ref-type="bibr" rid="B27">27</xref>] and also in haplotype analysis. In this paper we have investigated the CPPP problem, which is the general problem of computing a persistent perfect phylogeny for binary matrices where some characters may be forced not to be persistent in the tree. We provide algorithmic solutions for the problem: mainly a polynomial time algorithm when the conflict graph is edgeless and a fixed-parameter algorithm. In particular we show that when no constraint is given and the conflict graph is edgeless, a solution for PPP always exists. We experimentally show that the search tree technique, combined with the use of constraints allows to obtain efficiently solutions for matrices that otherwise would require exponential time. Future research will be devoted to experimental investigation of possible improvements based on introducing a carefully crafted set of constraints to speed up the computation. The computational complexity of the CPPP problem is open and it would be interesting to solve the problem for the unconstrained case.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>All authors have contributed equally to the paper.</p>
    <table-wrap id="T2" position="float">
      <label>Table 2</label>
      <caption>
        <p>Improvements of constrained simulated instances over unconstrained instances.</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <th align="center">Species</th>
            <th align="center">Characters</th>
            <th align="center" colspan="6">Number of added constraints</th>
          </tr>
          <tr>
            <th/>
            <th/>
            <th/>
            <th align="center">1</th>
            <th/>
            <th/>
            <th align="center">16</th>
            <th/>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td/>
            <td/>
            <td align="center">
              <bold>Fastest</bold>
            </td>
            <td/>
            <td align="center">
              <bold>Median</bold>
            </td>
            <td align="center">
              <bold>Fastest</bold>
            </td>
            <td/>
            <td align="center">
              <bold>Median</bold>
            </td>
          </tr>
          <tr>
            <td colspan="8">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">5</td>
            <td align="center">0</td>
            <td/>
            <td align="center">0</td>
            <td align="center">0</td>
            <td/>
            <td align="center">0</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">7</td>
            <td align="center">1</td>
            <td/>
            <td align="center">0</td>
            <td align="center">1</td>
            <td/>
            <td align="center">1</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">10</td>
            <td align="center">7</td>
            <td/>
            <td align="center">5</td>
            <td align="center">7</td>
            <td/>
            <td align="center">7</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">12</td>
            <td align="center">7</td>
            <td/>
            <td align="center">5</td>
            <td align="center">7</td>
            <td/>
            <td align="center">6</td>
          </tr>
          <tr>
            <td align="center">10</td>
            <td align="center">15</td>
            <td align="center">8</td>
            <td/>
            <td align="center">3</td>
            <td align="center">9</td>
            <td/>
            <td align="center">8</td>
          </tr>
          <tr>
            <td colspan="8">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">10</td>
            <td align="center">9</td>
            <td/>
            <td align="center">4</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">15</td>
            <td align="center">10</td>
            <td/>
            <td align="center">9</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">20</td>
            <td align="center">9</td>
            <td/>
            <td align="center">1</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">25</td>
            <td align="center">9</td>
            <td/>
            <td align="center">7</td>
            <td align="center">9</td>
            <td/>
            <td align="center">9</td>
          </tr>
          <tr>
            <td align="center">20</td>
            <td align="center">30</td>
            <td align="center">7</td>
            <td/>
            <td align="center">2</td>
            <td align="center">10</td>
            <td/>
            <td align="center">9</td>
          </tr>
          <tr>
            <td colspan="8">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">20</td>
            <td align="center">9</td>
            <td/>
            <td align="center">7</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">30</td>
            <td align="center">10</td>
            <td/>
            <td align="center">7</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">40</td>
            <td align="center">8</td>
            <td/>
            <td align="center">1</td>
            <td align="center">10</td>
            <td/>
            <td align="center">9</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">50</td>
            <td align="center">10</td>
            <td/>
            <td align="center">0</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">40</td>
            <td align="center">60</td>
            <td align="center">1</td>
            <td/>
            <td align="center">0</td>
            <td align="center">9</td>
            <td/>
            <td align="center">6</td>
          </tr>
          <tr>
            <td colspan="8">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="center">60</td>
            <td align="center">30</td>
            <td align="center">8</td>
            <td/>
            <td align="center">7</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">60</td>
            <td align="center">45</td>
            <td align="center">10</td>
            <td/>
            <td align="center">8</td>
            <td align="center">10</td>
            <td/>
            <td align="center">10</td>
          </tr>
          <tr>
            <td align="center">60</td>
            <td align="center">60</td>
            <td align="center">7</td>
            <td/>
            <td align="center">6</td>
            <td align="center">8</td>
            <td/>
            <td align="center">7</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <p>For each choice of the number of species and of characters, we state the number of instances where at least one of the 10 random constrained instances is solved more quickly than the unconstrained instance (columns labeled Fastest). Moreover we state the number of instances where the median of the 10 random constrained instances is solved more quickly than the unconstrained instance (columns labeled Median).</p>
      </table-wrap-foot>
    </table-wrap>
    <fig id="F1" position="float">
      <label>Figure 1</label>
      <caption>
        <p><bold>A matrix and its conflict graph</bold>.</p>
      </caption>
      <graphic xlink:href="1471-2164-15-S6-S10-1"/>
    </fig>
    <fig id="F2" position="float">
      <label>Figure 2</label>
      <caption>
        <p><bold>The figure illustrates the realization of a character in a red-black graph associated to an extended matrix</bold>. The canonical completion of the extended matrix after the graph operations is shown for the character <italic>c</italic>4.</p>
      </caption>
      <graphic xlink:href="1471-2164-15-S6-S10-2"/>
    </fig>
    <fig id="F3" position="float">
      <label>Figure 3</label>
      <caption>
        <p><bold>The figure illustrates the realization of character <italic>c</italic>3 in the red-black graph associated to an extended matrix of the previous figure</bold>. The canonical completion of the extended matrix is shown for the character <italic>c</italic>3.</p>
      </caption>
      <graphic xlink:href="1471-2164-15-S6-S10-3"/>
    </fig>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>The authors acknowledge the support of the MIUR PRIN 2010-2011 grant 2010LYA9RH (Automi e Linguaggi Formali: Aspetti Matematici e Applicativi), of the Cariplo Foundation grant 2013-0955 (Modulation of anticancer immune response by regulatory non-coding RNAs), of the FA 2013 grant (Metodi algoritmici e modelli: aspetti teorici e applicazioni in bioinformatica).</p>
  </sec>
  <sec>
    <title>Declarations</title>
    <p>Publication charges for this work was funded by MIUR PRIN 2010-2011 grant 2010LYA9RH.</p>
    <p>This article has been published as part of <italic>BMC Genomics </italic>Volume 15 Supplement 6, 2014: Proceedings of the Twelfth Annual Research in Computational Molecular Biology (RECOMB) Satellite Workshop on Comparative Genomics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcgenomics/supplements/15/S6">http://www.biomedcentral.com/bmcgenomics/supplements/15/S6</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Przytycka</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Davis</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Song</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Durand</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Graph theoretical insights into dollo parsimony and evolution of multidomain proteins</article-title>
        <source>Journal of Computational Biology</source>
        <year>2006</year>
        <volume>13</volume>
        <issue>2</issue>
        <fpage>351</fpage>
        <lpage>363</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2006.13.351</pub-id>
        <?supplied-pmid 16597245?>
        <pub-id pub-id-type="pmid">16597245</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="book">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <source>Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</source>
        <year>1997</year>
        <publisher-name>Cambridge University Press, Cambridge</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="book">
        <name>
          <surname>Felsenstein</surname>
          <given-names>J</given-names>
        </name>
        <source>Inferring Phylogenies</source>
        <year>2004</year>
        <publisher-name>Sinauer Associates, Sunderland, MA (USA)</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Efficient algorithms for inferring evolutionary trees</article-title>
        <source>Networks</source>
        <year>1991</year>
        <fpage>19</fpage>
        <lpage>28</lpage>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Peer</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Pupko</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Shamir</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Sharan</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Incomplete directed perfect phylogeny</article-title>
        <source>SIAM Journal on Computing</source>
        <year>2004</year>
        <volume>33</volume>
        <issue>3</issue>
        <fpage>590</fpage>
        <lpage>607</lpage>
        <pub-id pub-id-type="doi">10.1137/S0097539702406510</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Della Vedova</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Dondi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>J</given-names>
        </name>
        <article-title>The haplotyping problem: a view of computational models and solutions</article-title>
        <source>International Journal of Computer and Science Technology</source>
        <year>2003</year>
        <volume>18</volume>
        <fpage>675</fpage>
        <lpage>688</lpage>
        <pub-id pub-id-type="doi">10.1007/BF02945456</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Haplotyping as perfect phylogeny: Conceptual framework and efficient solutions</article-title>
        <source>Proc 6th Annual Conference on Research in Computational Molecular Biology (RECOMB 2002)</source>
        <year>2002</year>
        <fpage>166</fpage>
        <lpage>175</lpage>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>P</given-names>
        </name>
        <article-title>A linear time algorithm for the Perfect Phylogeny Haplotype problem</article-title>
        <source>Algorithmica</source>
        <year>2007</year>
        <volume>48</volume>
        <issue>3</issue>
        <fpage>267</fpage>
        <lpage>285</lpage>
        <pub-id pub-id-type="doi">10.1007/s00453-007-0094-3</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ding</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Filkov</surname>
          <given-names>V</given-names>
        </name>
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>A linear time algorithm for Perfect Phylogeny Haplotyping (pph) problem</article-title>
        <source>Journal of Computational Biology</source>
        <year>2006</year>
        <volume>13</volume>
        <issue>2</issue>
        <fpage>522</fpage>
        <lpage>553</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2006.13.522</pub-id>
        <?supplied-pmid 16597255?>
        <pub-id pub-id-type="pmid">16597255</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bodlaender</surname>
          <given-names>HL</given-names>
        </name>
        <name>
          <surname>Fellows</surname>
          <given-names>MR</given-names>
        </name>
        <name>
          <surname>Warnow</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Two strikes against perfect phylogeny</article-title>
        <source>Automata, Languages and Programming</source>
        <year>1995</year>
        <volume>937</volume>
        <fpage>17</fpage>
        <lpage>26</lpage>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fernández-Baca</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lagergren</surname>
          <given-names>J</given-names>
        </name>
        <article-title>A polynomial-time algorithm for near-perfect phylogeny</article-title>
        <source>SIAM J Comput</source>
        <year>2003</year>
        <volume>32</volume>
        <issue>5</issue>
        <fpage>1115</fpage>
        <lpage>1127</lpage>
        <pub-id pub-id-type="doi">10.1137/S0097539799350839</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kannan</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Warnow</surname>
          <given-names>T</given-names>
        </name>
        <article-title>A fast algorithm for the computation and enumeration of perfect phylogenies</article-title>
        <source>SIAM Journal on Computing</source>
        <year>1997</year>
        <volume>26</volume>
        <issue>6</issue>
        <fpage>1749</fpage>
        <lpage>1763</lpage>
        <pub-id pub-id-type="doi">10.1137/S0097539794279067</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dress</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Steel</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Convex tree realizations of partitions</article-title>
        <source>Applied Mathematics Letters</source>
        <year>1992</year>
        <volume>5</volume>
        <issue>3</issue>
        <fpage>3</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1016/0893-9659(92)90026-6</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kannan</surname>
          <given-names>SK</given-names>
        </name>
        <name>
          <surname>Warnow</surname>
          <given-names>TJ</given-names>
        </name>
        <article-title>Inferring evolutionary history from dna sequences</article-title>
        <source>SIAM Journal on Computing</source>
        <year>1994</year>
        <volume>231</volume>
        <issue>4</issue>
        <fpage>713</fpage>
        <lpage>737</lpage>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gysel</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Gusfield</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Constructing perfect phylogenies and proper triangulations for three-state characters</article-title>
        <source>Algorithms for Molecular Biology</source>
        <year>2012</year>
        <volume>7</volume>
        <issue>1</issue>
        <?supplied-pmid 23006612?>
        <pub-id pub-id-type="pmid">23006612</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Subramanian</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Shackney</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Schwartz</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Inference of tumor phylogenies from genomic assays on heterogeneous samples</article-title>
        <source>BioMed Research International</source>
        <year>2012</year>
        <volume>2012</volume>
        <?supplied-pmid 22654484?>
        <pub-id pub-id-type="pmid">22654484</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Przytycka</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Davis</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Song</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Durand</surname>
          <given-names>D</given-names>
        </name>
        <article-title>Graph theoretical insights into evolution of multidomain proteins</article-title>
        <source>Journal of computational biology</source>
        <year>2006</year>
        <volume>13</volume>
        <issue>2</issue>
        <fpage>351</fpage>
        <lpage>363</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2006.13.351</pub-id>
        <?supplied-pmid 16597245?>
        <pub-id pub-id-type="pmid">16597245</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="other">
        <name>
          <surname>Satya</surname>
          <given-names>RV</given-names>
        </name>
        <name>
          <surname>Mukherjee</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Alexe</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Parida</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Bhanot</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Constructing near-perfect phylogenies with multiple homoplasy events</article-title>
        <source>ISMB (Supplement of Bioinformatics)</source>
        <year>2006</year>
        <fpage>514</fpage>
        <lpage>522</lpage>
        <?supplied-pmid 16873515?>
        <pub-id pub-id-type="pmid">16873515</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="other">
        <name>
          <surname>Manuch</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Patterson</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gupta</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Towards a characterisation of the generalised cladistic character compatibility problem for non-branching character trees</article-title>
        <source>ISBRA</source>
        <year>2011</year>
        <fpage>440</fpage>
        <lpage>451</lpage>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="other">
        <name>
          <surname>Maňuch</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Patterson</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gupta</surname>
          <given-names>A</given-names>
        </name>
        <article-title>On the generalised character compatibility problem for non-branching character trees</article-title>
        <source>Computing and Combinatorics</source>
        <year>2009</year>
        <fpage>268</fpage>
        <lpage>276</lpage>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bonizzoni</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Braghin</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Dondi</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Trucco</surname>
          <given-names>G</given-names>
        </name>
        <article-title>The binary perfect phylogeny with persistent characters</article-title>
        <source>Theoretical computer science</source>
        <year>2012</year>
        <volume>454</volume>
        <fpage>51</fpage>
        <lpage>63</lpage>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Benham</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Kannan</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Paterson</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Warnow</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Hen's teeth and whale's feet: generalized characters and their compatibility</article-title>
        <source>Journal of Computational Biology</source>
        <year>1995</year>
        <volume>2</volume>
        <issue>4</issue>
        <fpage>515</fpage>
        <lpage>525</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.1995.2.515</pub-id>
        <?supplied-pmid 8634903?>
        <pub-id pub-id-type="pmid">8634903</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zheng</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Rogozin</surname>
          <given-names>IB</given-names>
        </name>
        <name>
          <surname>Koonin</surname>
          <given-names>EV</given-names>
        </name>
        <name>
          <surname>Przytycka</surname>
          <given-names>TM</given-names>
        </name>
        <article-title>Support for the Coelomata Clade of Animals from a Rigorous Analysis of the Pattern of Intron Conservation</article-title>
        <source>Mol Biol Evol</source>
        <year>2007</year>
        <volume>24</volume>
        <issue>11</issue>
        <fpage>2583</fpage>
        <lpage>2592</lpage>
        <pub-id pub-id-type="doi">10.1093/molbev/msm207</pub-id>
        <?supplied-pmid 17893400?>
        <pub-id pub-id-type="pmid">17893400</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="book">
        <name>
          <surname>Downey</surname>
          <given-names>RG</given-names>
        </name>
        <name>
          <surname>Fellows</surname>
          <given-names>MR</given-names>
        </name>
        <source>Parameterized Complexity</source>
        <year>1999</year>
        <publisher-name>Springer, Berlin (Germany)</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hudson</surname>
          <given-names>RR</given-names>
        </name>
        <article-title>Generating samples under a wright-fisher neutral model of 31 genetic variation</article-title>
        <source>Bioinformatics</source>
        <year>2002</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>337</fpage>
        <lpage>338</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/18.2.337</pub-id>
        <?supplied-pmid 11847089?>
        <pub-id pub-id-type="pmid">11847089</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <article-title>The International HapMap Consortium: A second generation human haplotype map of over 3.1 million SNPs</article-title>
        <source>Nature</source>
        <year>2007</year>
        <volume>449</volume>
        <issue>7164</issue>
        <fpage>851</fpage>
        <lpage>861</lpage>
        <pub-id pub-id-type="doi">10.1038/nature06258</pub-id>
        <?supplied-pmid 17943122?>
        <pub-id pub-id-type="pmid">17943122</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="other">
        <name>
          <surname>Pan</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>McMillan</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>de Villena</surname>
          <given-names>FPM</given-names>
        </name>
        <name>
          <surname>Threadgill</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Treeqa: Quantitative genome wide association mapping using local perfect phylogeny trees</article-title>
        <source>Pacific Symposium on Biocomputing</source>
        <year>2009</year>
        <fpage>415</fpage>
        <lpage>426</lpage>
        <?supplied-pmid 19209719?>
        <pub-id pub-id-type="pmid">19209719</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
