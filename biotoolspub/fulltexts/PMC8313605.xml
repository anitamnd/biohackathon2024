<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_ISCI102782 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEfx1 jpg ?>
<?FILEsi1 gif ?>
<?FILEsi2 gif ?>
<?FILEsi3 gif ?>
<?FILEsi4 gif ?>
<?FILEsi5 gif ?>
<?FILEsi6 gif ?>
<?FILEsi7 gif ?>
<?FILEsi8 gif ?>
<?FILEsi9 gif ?>
<?FILEsi10 gif ?>
<?FILEsi11 gif ?>
<?FILEsi12 gif ?>
<?FILEsi13 gif ?>
<?FILEsi14 gif ?>
<?FILEsi15 gif ?>
<?FILEsi16 gif ?>
<?FILEsi17 gif ?>
<?FILEsi18 gif ?>
<?FILEsi19 gif ?>
<?FILEsi20 gif ?>
<?FILEsi21 gif ?>
<?FILEsi22 gif ?>
<?FILEsi23 gif ?>
<?FILEsi24 gif ?>
<?FILEsi25 gif ?>
<?FILEsi26 gif ?>
<?FILEsi27 gif ?>
<?FILEsi28 gif ?>
<?FILEsi29 gif ?>
<?FILEsi30 gif ?>
<?FILEsi31 gif ?>
<?FILEsi32 gif ?>
<?FILEsi33 gif ?>
<?FILEsi34 gif ?>
<?FILEsi35 gif ?>
<?FILEsi36 gif ?>
<?FILEsi37 gif ?>
<?FILEsi38 gif ?>
<?FILEsi39 gif ?>
<?FILEsi40 gif ?>
<?FILEsi41 gif ?>
<?FILEsi42 gif ?>
<?FILEsi43 gif ?>
<?FILEsi44 gif ?>
<?FILEsi45 gif ?>
<?FILEsi46 gif ?>
<?FILEsi47 gif ?>
<?FILEsi48 gif ?>
<?FILEsi49 gif ?>
<?FILEsi50 gif ?>
<?FILEsi51 gif ?>
<?FILEsi52 gif ?>
<?FILEsi53 gif ?>
<?FILEsi54 gif ?>
<?FILEsi55 gif ?>
<?FILEsi56 gif ?>
<?FILEsi57 gif ?>
<?FILEsi58 gif ?>
<?FILEsi59 gif ?>
<?FILEsi60 gif ?>
<?FILEsi61 gif ?>
<?FILEsi62 gif ?>
<?FILEsi63 gif ?>
<?FILEsi64 gif ?>
<?FILEsi65 gif ?>
<?FILEsi66 gif ?>
<?FILEsi67 gif ?>
<?FILEsi68 gif ?>
<?FILEsi69 gif ?>
<?FILEsi70 gif ?>
<?FILEsi71 gif ?>
<?FILEsi72 gif ?>
<?FILEsi73 gif ?>
<?FILEsi74 gif ?>
<?FILEsi75 gif ?>
<?FILEsi76 gif ?>
<?FILEsi77 gif ?>
<?FILEsi78 gif ?>
<?FILEsi79 gif ?>
<?FILEsi80 gif ?>
<?FILEsi81 gif ?>
<?FILEsi82 gif ?>
<?FILEsi83 gif ?>
<?FILEsi84 gif ?>
<?FILEsi85 gif ?>
<?FILEsi86 gif ?>
<?FILEsi87 gif ?>
<?FILEsi88 gif ?>
<?FILEsi89 gif ?>
<?FILEsi90 gif ?>
<?FILEsi91 gif ?>
<?FILEsi92 gif ?>
<?FILEsi93 gif ?>
<?FILEsi94 gif ?>
<?FILEsi95 gif ?>
<?FILEsi96 gif ?>
<?FILEsi97 gif ?>
<?FILEsi98 gif ?>
<?FILEsi99 gif ?>
<?FILEsi100 gif ?>
<?FILEsi101 gif ?>
<?FILEsi102 gif ?>
<?FILEsi103 gif ?>
<?FILEsi104 gif ?>
<?FILEsi105 gif ?>
<?FILEsi106 gif ?>
<?FILEsi107 gif ?>
<?FILEsi108 gif ?>
<?FILEsi109 gif ?>
<?FILEsi110 gif ?>
<?FILEsi111 gif ?>
<?FILEsi112 gif ?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">iScience</journal-id>
    <journal-id journal-id-type="iso-abbrev">iScience</journal-id>
    <journal-title-group>
      <journal-title>iScience</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2589-0042</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8313605</article-id>
    <article-id pub-id-type="pii">S2589-0042(21)00750-1</article-id>
    <article-id pub-id-type="doi">10.1016/j.isci.2021.102782</article-id>
    <article-id pub-id-type="publisher-id">102782</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Raptor: A fast and space-efficient pre-filter for querying very large collections of nucleotide sequences</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au1">
        <name>
          <surname>Seiler</surname>
          <given-names>Enrico</given-names>
        </name>
        <email>enrico.seiler@fu-berlin.de</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="aff2" ref-type="aff">2</xref>
        <xref rid="cor1" ref-type="corresp">∗</xref>
      </contrib>
      <contrib contrib-type="author" id="au2">
        <name>
          <surname>Mehringer</surname>
          <given-names>Svenja</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">1</xref>
      </contrib>
      <contrib contrib-type="author" id="au3">
        <name>
          <surname>Darvish</surname>
          <given-names>Mitra</given-names>
        </name>
        <xref rid="aff2" ref-type="aff">2</xref>
      </contrib>
      <contrib contrib-type="author" id="au4">
        <name>
          <surname>Turc</surname>
          <given-names>Etienne</given-names>
        </name>
        <xref rid="aff3" ref-type="aff">3</xref>
      </contrib>
      <contrib contrib-type="author" id="au5">
        <name>
          <surname>Reinert</surname>
          <given-names>Knut</given-names>
        </name>
        <email>knut.reinert@fu-berlin.de</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="fn1" ref-type="fn">4</xref>
        <xref rid="cor2" ref-type="corresp">∗∗</xref>
      </contrib>
      <aff id="aff1"><label>1</label>Department of Mathematics and Computer Science, Freie Universität Berlin, Berlin, Germany</aff>
      <aff id="aff2"><label>2</label>Efficient Algorithms for Omics Data, Max Planck Institute for Molecular Genetics, Berlin, Germany</aff>
      <aff id="aff3"><label>3</label>ENSTA, Paris, France</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><label>∗</label>Corresponding author <email>enrico.seiler@fu-berlin.de</email></corresp>
      <corresp id="cor2"><label>∗∗</label>Corresponding author <email>knut.reinert@fu-berlin.de</email></corresp>
      <fn id="fn1">
        <label>4</label>
        <p id="ntpara0010">Lead contact</p>
      </fn>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>6</month>
      <year>2021</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <day>23</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>6</month>
      <year>2021</year>
    </pub-date>
    <volume>24</volume>
    <issue>7</issue>
    <elocation-id>102782</elocation-id>
    <history>
      <date date-type="received">
        <day>1</day>
        <month>4</month>
        <year>2021</year>
      </date>
      <date date-type="rev-recd">
        <day>7</day>
        <month>6</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>6</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 The Authors</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).</license-p>
      </license>
    </permissions>
    <abstract id="abs0010">
      <title>Summary</title>
      <p>We present Raptor, a system for approximately searching many queries such as next-generation sequencing reads or transcripts in large collections of nucleotide sequences. Raptor uses winnowing minimizers to define a set of representative <italic>k</italic>-mers, an extension of the interleaved Bloom filters (IBFs) as a set membership data structure and probabilistic thresholding for minimizers. Our approach allows compression and partitioning of the IBF to enable the effective use of secondary memory. We test and show the performance and limitations of the new features using simulated and real datasets. Our data structure can be used to accelerate various core bioinformatics applications. We show this by re-implementing the distributed read mapping tool DREAM-Yara.</p>
    </abstract>
    <abstract abstract-type="graphical" id="abs0015">
      <title>Graphical abstract</title>
      <fig id="undfig1" position="anchor">
        <graphic xlink:href="fx1"/>
      </fig>
    </abstract>
    <abstract abstract-type="author-highlights" id="abs0020">
      <title>Highlights</title>
      <p>
        <list list-type="simple" id="ulist0010">
          <list-item id="u0010">
            <label>•</label>
            <p id="p0010">Raptor is a tool to search through large collections of genomic texts</p>
          </list-item>
          <list-item id="u0015">
            <label>•</label>
            <p id="p0015">Raptor is 12-144 times faster and uses up to 30 times less RAM than COBS or Mantis</p>
          </list-item>
          <list-item id="u0020">
            <label>•</label>
            <p id="p0020">The Raptor index is 6-50 times faster to build</p>
          </list-item>
          <list-item id="u0025">
            <label>•</label>
            <p id="p0025">The use of minimizers and Bloom filters makes Raptor very space-efficient</p>
          </list-item>
        </list>
      </p>
    </abstract>
    <abstract abstract-type="teaser" id="abs0025">
      <p>Genetics; bioinformatics; high-performance computing in bioinformatics</p>
    </abstract>
    <kwd-group id="kwrds0010">
      <title>Subject areas</title>
      <kwd>genetics</kwd>
      <kwd>bioinformatics</kwd>
      <kwd>high-performance computing in bioinformatics</kwd>
    </kwd-group>
  </article-meta>
  <notes>
    <p id="misc0010">Published: July 23, 2021</p>
  </notes>
</front>
<body>
  <sec id="sec1">
    <title>Introduction</title>
    <p id="p0030">The recent improvements of full genome sequencing technologies, commonly subsumed under the term NGS (next-generation sequencing), have tremendously increased the sequencing throughput. Within 10 years, it rose from 21 billion base pairs (<xref rid="bib23" ref-type="bibr">Venter et al., 2001</xref>; <xref rid="bib12" ref-type="bibr">International Human Genome Sequencing Consortium, 2001</xref>) collected over months to about 400 billion base pairs per day (current throughput of Illumina's HiSeq 4000). The costs for producing one million base pairs could also be reduced from many thousands of dollars to a few cents. As a result of this dramatic development, the number of new data submissions, generated by various biotechnological protocols (ChIP-Seq, RNA-Seq, etc.), to genomic databases has grown dramatically and is expected to continue to increase faster than the cost and capacity of storage devices can keep up. Ongoing projects like the 100,000 Genome Project (<xref rid="bib6" ref-type="bibr">Caulfield et al., 2019</xref>) or the American 1,000,000 Genome Project (<xref rid="bib1" ref-type="bibr">All of Us (NIH), 2020</xref>) will easily produce data in the range of several petabases. This growth not only challenges the storage infrastructures and the processing pipelines of public databases because of the sheer data throughput but also challenges algorithm engineers to improve the efficiency of sequence analysis pipelines and develop new strategies for compression, data parallelism, and concurrent computing.</p>
    <p id="p0035">The main task in analyzing NGS data is to search sequencing reads or short sequence patterns (e.g., read mapping and variant calling) or analyzing expression profiles in large collections of sequences (i.e. a database). Searching the <italic>entirety</italic> of such databases mentioned above is usually only possible by searching the metadata or a set of results initially obtained from the experiment. Searching (approximately) for specific genomic sequence in all the data has not been possible in reasonable computational time. The demand for solutions can be seen by the various attempts toward enabling sequence searches on large databases (see (<xref rid="bib16" ref-type="bibr">Marchet et al., 2019</xref>) for an overview). While the NIH SRA provides a sequence search functionality, the search is restricted to a limited number of experiments. Full-text indexing data structures, such as the FM-index, are currently unable to mine data of this scale. Word-based indices, such as those used by internet search engines, are not directly appropriate for edit-distance-based biological sequence searches (<xref rid="bib3" ref-type="bibr">Bingmann et al., 2019</xref>). The sequence-specific solution CaBLAST (<xref rid="bib2" ref-type="bibr">Berger and Peng, 2013</xref>) and its variants require an index of known genomes, genes or proteins, and thus cannot search for novel phenomena in raw sequencing files. This holds also true in the field of mapping-based metagenomic binning and quantitation where the relevant microbial databases grow about as fast as the sequence archives. The NCBI Refseq database of prokaryotic genomes contains about 30 GiB of sequence, still small enough to build an FM-index for the genomes, which takes about 24 hr time and about 50 GiB memory (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>). However, including the draft genomes into the analysis increases the database to 380 GiB. Building a single search structure like an FM-index for this amount of data is infeasible.</p>
    <sec id="sec1.1">
      <title>Related work</title>
      <p id="p0040">The problem of approximately searching queries in ultra-large databases has recently been addressed by several groups, focusing on different applications, but all using methods based on the <italic>k</italic>-mer content of the databases. In the field of alignment-free metagenomic analysis, which focuses on <italic>k</italic>-mer based analysis, the size of the data also becomes slowly prohibitive. For example, Kraken (<xref rid="bib24" ref-type="bibr">Wood and Salzberg, 2014</xref>) needs <inline-formula><mml:math id="M1" altimg="si1.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mn>147</mml:mn></mml:mrow></mml:math></inline-formula> GiB RAM for indexing 380 GBases. For analyzing RNA-Seq data, some groups aimed at searching the raw files directly for a set of transcripts ((<xref rid="bib21" ref-type="bibr">Solomon and Kingsford, 2016</xref>) and shortly afterward (<xref rid="bib22" ref-type="bibr">Sun et al., 2017</xref>)). They propose novel solutions to the problem of searching a transcript of interest in all relevant RNA-Seq experiments. Up until recently, these searches were only based on the sequences itself; the tool REINDEER (<xref rid="bib17" ref-type="bibr">Marchet et al., 2020</xref>) is the first approach to also account for the sequence abundances.</p>
      <p id="p0045">As a benchmark, all three publications use a dataset of <inline-formula><mml:math id="M2" altimg="si2.gif"><mml:mrow><mml:mn>2,652</mml:mn></mml:mrow></mml:math></inline-formula> RNA-seq sequencing runs of human blood, breast and brain tissue (a total of <inline-formula><mml:math id="M3" altimg="si3.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mn>6.5</mml:mn></mml:mrow></mml:math></inline-formula> TiB) in which they search for <inline-formula><mml:math id="M4" altimg="si4.gif"><mml:mrow><mml:mn>214,293</mml:mn></mml:mrow></mml:math></inline-formula> known transcripts. For a <italic>single</italic> query their methods need in the range of <inline-formula><mml:math id="M5" altimg="si5.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula> minutes, which is a tremendous improvement and a speedup of orders of magnitude compared to previous methods. Although a breakthrough, the methods presented by the groups need 4 and <inline-formula><mml:math id="M6" altimg="si6.gif"><mml:mrow><mml:mn>0.3</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> days for processing the above set of <inline-formula><mml:math id="M7" altimg="si4.gif"><mml:mrow><mml:mn>214,293</mml:mn></mml:mrow></mml:math></inline-formula> queries, respectively. Very recently, this time was improved by the Patro group with the tool Mantis in (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>) to 82 min. Moreover, Bradley et al. (<xref rid="bib5" ref-type="bibr">Bradley et al., 2019</xref>) propose a Bloom filter based solution that can index about 170 TiB of (repetitive) raw sequence into an index of 1.5 TiB. However, searching, for example, 220 MiB of plasmid sequence takes 11 days using 8 cores. The same group followed up with a newer approach called COBS (<xref rid="bib3" ref-type="bibr">Bingmann et al., 2019</xref>). Finally, the construction time of an index build on top of 170 TiB of input data was further improved by the tool RAMBO (<xref rid="bib10" ref-type="bibr">Gupta et al., 2019</xref>) which only needs 14 hr on a cluster of 100 nodes.</p>
      <p id="p0050">Taken together, all approaches are still very demanding in terms of memory consumption and run time.</p>
    </sec>
    <sec id="sec1.2">
      <title>Our contribution</title>
      <p id="p0055">In this paper, we propose a data structure, called <italic>binning directory</italic>, that can distribute approximate search queries based on an extension of the recently introduced Interleaved Bloom Filters (IBFs) (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>). A <italic>binning directory</italic> combines a so called <italic>x</italic>-partitioned IBF (<italic>x</italic>-PIBF) with winnowing minimizers and probabilistic thresholding that takes into account the varying number of minimizers in each read. We present our implementation, called <italic>Raptor</italic>, discuss its capabilities and limitations, and compare it with the state-of-the-art methods Mantis and COBS. Our comparison shows that Raptor is up to times faster than the competitors in answering approximate string searches with full sensitivity and a very good specificity. In addition, we only use a fraction of the memory and can further trade run time for main memory consumption.</p>
    </sec>
  </sec>
  <sec id="sec2">
    <title>Results</title>
    <sec id="sec2.1">
      <title>General method</title>
      <p id="p0060">Raptor stores a <italic>representative</italic> transformation of the <italic>k</italic>-mer content of the database that is divided up into a number of bins, typically a few hundred to a few thousand (see <xref rid="sec5" ref-type="sec">STAR Methods</xref> section for details). The term <italic>representative</italic> indicates that the <italic>k</italic>-mer content could be transformed by a function which reduces its size and distribution (for example, using winnowing minimizers on the text and its reverse complement or using gapped <italic>k</italic>-mers). In this work, we use ungapped <inline-formula><mml:math id="M8" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><italic>-minimizers</italic> for computing representative <italic>k</italic>-mers (see also <xref rid="bib7" ref-type="bibr">Chikhi et al. (2016)</xref>). A <inline-formula><mml:math id="M9" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizer is essentially the lexicographically minimal <italic>k</italic>-mer of all <italic>k</italic>-mers and their reverse complements in a window of size <italic>w</italic>. The same transformation is applied to the <italic>k</italic>-mers of the query (see <xref rid="fig1" ref-type="fig">Figure 1</xref> for an example and details). Raptor uses a set membership data structure, the <italic>x</italic>-PIBF, to retrieve <italic>binning bitvectors</italic> indicating whether a representative <italic>k</italic>-mer is in a bin or not. It then combines the binning bitvectors of all representative <italic>k</italic>-mers in a query into a <italic>counting vector</italic> and applies a thresholding step to determine the membership of a query in a bin. The process is illustrated in <xref rid="fig2" ref-type="fig">Figure 2</xref>, <xref rid="fig3" ref-type="fig">Figure 3</xref>, <xref rid="fig4" ref-type="fig">Figure 4</xref>.<fig id="fig1"><label>Figure 1</label><caption><p>Examples of (<italic>w,k</italic>)-minimizers</p><p>(A) and (B) show the same <italic>k</italic> for different window sizes, the former with a window size <inline-formula><mml:math id="M10" altimg="si46.gif"><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> and the latter with a larger window of 8. Note that the reverse complemented sequences, shown in lower case, have to be read from right to left. The window width is indicated by a dash and the minimizing <italic>k</italic>-mer is placed within the window. Subsequent windows often share the same minimizer which we illustrated by showing those as well, although they are only stored once.</p></caption><graphic xlink:href="gr1"/></fig></p>
    </sec>
    <sec id="sec2.2">
      <title>Evaluation</title>
      <p id="p0065">In the following, we report our computational experiments for Raptor. First, we will use an artificial dataset to discuss the limitations of binning directories, the impact of compression, the impact of the use of <inline-formula><mml:math id="M11" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers for different window sizes, and the time/space trade-off when using different partition sizes. We will also compare different binning directories with Mantis and COBS using this dataset.</p>
      <p id="p0070">Secondly, we will evaluate Raptor using a real data set used by several groups to determine the membership of transcripts in RNA-Seq files (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>) and compare Raptor with Mantis (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>) and COBS (<xref rid="bib3" ref-type="bibr">Bingmann et al., 2019</xref>).</p>
      <p id="p0075">Lastly, we evaluated the use of Raptor in conjunction with the distributed read-mapper DREAM-Yara (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>).</p>
      <p id="p0080">All experiments were conducted on a Dell PowerEdge T640 with an Intel Xeon Gold 6248 CPU using 32 threads and 1 TiB of main memory. All file I/O for the artificial dataset was performed to and from a memory mapped file system (/dev/shm) to eliminate I/O effects, i.e., disk caching, from the measurements. Unless otherwise stated, all other I/O was performed to and from hard disk drives.</p>
    </sec>
    <sec id="sec2.3">
      <title>Datasets</title>
      <p id="p0085">We created a random DNA sequence of 4 GiB size and divided it into <italic>b</italic> bins which would correspond to <italic>b</italic> different genomes in, e.g., a metagenomic data set. Using the Mason genome variator (<xref rid="bib11" ref-type="bibr">Holtgrewe, 2010</xref>), we then generated 16 similar genomes in each bin which differ about <inline-formula><mml:math id="M12" altimg="si8.gif"><mml:mrow><mml:mn>1</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula> from each other on average. This could be seen as bins containing the genomes for a very homologous species. The total sequence length is hence 64 GiB, however, containing <italic>b</italic> groups of highly similar sequences. Finally, we uniformly sampled a total of <inline-formula><mml:math id="M13" altimg="si9.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>20</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> reads of length 100 bp from the genomes and introduced 2 errors in each read to simulate a sequencing experiment. This artificial dataset is very balanced, which is the ideal case for the <italic>x</italic>-PIBF, since its overall size is dependent on the largest bin. We will discuss this issue in the discussion section.</p>
      <p id="p0090">On this data set, we use <inline-formula><mml:math id="M14" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers and <inline-formula><mml:math id="M15" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers in conjunction with thresholds derived by the <italic>k</italic>-mer Lemma or our probabilistic thresholding for determining which bin contains the query. The value <inline-formula><mml:math id="M16" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula> was chosen to make random occurrences seldom (see <xref rid="sec5" ref-type="sec">STAR Methods</xref> for a detailed discussion).</p>
      <p id="p0095">In order to evaluate our method on real data, we took the dataset from (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>) which consists of <inline-formula><mml:math id="M17" altimg="si13.gif"><mml:mrow><mml:mn>2,568</mml:mn></mml:mrow></mml:math></inline-formula> RNA-Seq experiments. Similarly to (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>), we excluded all experiments that have an average read length below <inline-formula><mml:math id="M18" altimg="si14.gif"><mml:mrow><mml:mn>50</mml:mn><mml:mi>b</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> because reads shorter than that are rarely relevant in practice. Furthermore, this allowed us to test the minimizer approach with a broader window size. This left us with <inline-formula><mml:math id="M19" altimg="si15.gif"><mml:mrow><mml:mn>1,742</mml:mn></mml:mrow></mml:math></inline-formula> RNA-Seq experiments which have a size of around 6 TiB (gzipped FASTQ files). All tools were tested on this dataset using <inline-formula><mml:math id="M20" altimg="si16.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula>, a value used in the competitors' publications which also results in an effective text ratio near 1 (see <xref rid="tbl8" ref-type="table">Table 8</xref>).<table-wrap position="float" id="tbl8"><label>Table 8</label><caption><p>Effective text ratios <inline-formula><mml:math id="M21" altimg="si51.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></p></caption><table frame="hsides" rules="groups"><thead><tr><th>b,k</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th></tr></thead><tbody><tr><td>64</td><td align="char">62.84</td><td align="char">40.52</td><td align="char">14.19</td><td align="char">3.96</td><td align="char">1.57</td><td align="char">1.13</td><td align="char">1.03</td><td align="char">1.01</td><td align="char">1.00</td></tr><tr><td>1,024</td><td align="char">225.98</td><td align="char">62.19</td><td align="char">15.92</td><td align="char">4.08</td><td align="char">1.58</td><td align="char">1.13</td><td align="char">1.03</td><td align="char">1.01</td><td align="char">1.00</td></tr></tbody></table><table-wrap-foot><fn><p>For 64 and <inline-formula><mml:math id="M22" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins and different values of <italic>k</italic> for the artificial data set. Values are rounded.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0100">For the evaluation of DREAM-Yara, we downloaded the NCBI RefSeq for both archaea and bacteria as of February 14th 2021 and applied TaxSBP to create a taxonomic clustering of the dataset into 64 and 1024 bins. We split the RefSeq according to the clustering into 64 and 1024 gzipped FASTA files containing the sequence information of the respective clusters. Similarly to the artificial dataset experiment, we sampled <inline-formula><mml:math id="M23" altimg="si9.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>20</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> reads uniformly from the bins. Within a bin, the reads were uniformly sampled from the existing sequences. We sampled reads of length 250, and introduced 2 errors in each read.</p>
    </sec>
    <sec id="sec2.4">
      <title>Speed and space consumption of raptor with <inline-formula><mml:math id="M24" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers</title>
      <p id="p0105">We start by investigating the false positive (FP) count for different IBF sizes, which in turn affects the size of the individual Bloom filters in the IBF. A Bloom filter has a FP rate (FPR) depending on the ratio of stored elements to its size. For a fixed number of elements stored, it holds that the less space we allocate, the more FPs will occur. In our experiment this will lead to overcounting <italic>k</italic>-mers and hence lead to FP assignments of reads to bins. While one can easily compute the FPR for each individual Bloom filter (i.e. bin) of an IBF, it is harder to evaluate when a high Bloom filter FPR results in the FP assignment (FP) of a read to a bin. To evaluate this effect, we allocated IBFs of <inline-formula><mml:math id="M25" altimg="si17.gif"><mml:mrow><mml:mn>1,2,4</mml:mn></mml:mrow></mml:math></inline-formula> and 8 GiB size and report the used RAM, construction time, search time and FP bin assignments for <inline-formula><mml:math id="M26" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M27" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins for uncompressed and compressed vectors using <inline-formula><mml:math id="M28" altimg="si20.gif"><mml:mrow><mml:mi>h</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> hash functions. Also, we use <inline-formula><mml:math id="M29" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers and the traditional <italic>k</italic>-mer counting lemma threshold in one experiment and <inline-formula><mml:math id="M30" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers in conjunction with a new probabilistic threshold in a second experiment. The results are shown in <xref rid="tbl1" ref-type="table">Table 1</xref>.<table-wrap position="float" id="tbl1"><label>Table 1</label><caption><p>Run time and memory consumption of Raptor using differently sized IBF for <inline-formula><mml:math id="M31" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M32" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula></p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="3">IBF</th><th rowspan="3"/><th colspan="11">64<hr/></th></tr><tr><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th><th rowspan="2"/><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th></tr></thead><tbody><tr><td rowspan="2">1 GiB</td><td><inline-formula><mml:math id="M33" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">10:47</td><td>3,626</td><td align="char">0.95</td><td>1,236</td><td>604,533</td><td><inline-formula><mml:math id="M34" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">10:14</td><td>3,577</td><td align="char">0.92</td><td>1,238</td><td>28,438</td></tr><tr><td><inline-formula><mml:math id="M35" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">11:28</td><td>4,456</td><td align="char">5.54</td><td>3,382</td><td>604,533</td><td><inline-formula><mml:math id="M36" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">10:50</td><td>3,570</td><td align="char">1.80</td><td>1,986</td><td>28,438</td></tr><tr><td rowspan="2">2 GiB</td><td><inline-formula><mml:math id="M37" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">11:37</td><td>4,693</td><td align="char">0.91</td><td>2,260</td><td>189</td><td><inline-formula><mml:math id="M38" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">10:51</td><td>4,564</td><td align="char">0.93</td><td>2,254</td><td>197</td></tr><tr><td><inline-formula><mml:math id="M39" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">12:29</td><td>6,688</td><td align="char">4.98</td><td>4,592</td><td>189</td><td><inline-formula><mml:math id="M40" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">11:25</td><td>4,593</td><td align="char">1.56</td><td>2,365</td><td>197</td></tr><tr><td rowspan="2">4 GiB</td><td><inline-formula><mml:math id="M41" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">12:13</td><td>6,706</td><td align="char">0.93</td><td>4,310</td><td>189</td><td><inline-formula><mml:math id="M42" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">11:05</td><td>6,703</td><td align="char">0.92</td><td>4,310</td><td>189</td></tr><tr><td><inline-formula><mml:math id="M43" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">13:03</td><td>10,000</td><td align="char">4.64</td><td>5,857</td><td>189</td><td><inline-formula><mml:math id="M44" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">11:52</td><td>6,924</td><td align="char">1.66</td><td>2,750</td><td>189</td></tr><tr><td rowspan="2">8 GiB</td><td><inline-formula><mml:math id="M45" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">12:54</td><td>10,791</td><td align="char">0.85</td><td>8,404</td><td>189</td><td><inline-formula><mml:math id="M46" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">11:28</td><td>10,711</td><td align="char">0.89</td><td>8,406</td><td>189</td></tr><tr><td><inline-formula><mml:math id="M47" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">13:51</td><td>15,318</td><td align="char">3.91</td><td>7,072</td><td>189</td><td><inline-formula><mml:math id="M48" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">12:22</td><td>11,351</td><td align="char">1.67</td><td>3,112</td><td>189</td></tr></tbody></table><table frame="hsides" rules="groups"><thead><tr><th colspan="2" rowspan="3"/><th colspan="11">1,024<hr/></th></tr><tr><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th><th rowspan="2"/><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th></tr></thead><tbody><tr><td rowspan="2">1 GiB</td><td><inline-formula><mml:math id="M49" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">4:08</td><td>6,803</td><td align="char">3.41</td><td>1,230</td><td>9,696,884</td><td><inline-formula><mml:math id="M50" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">2:48</td><td>6,918</td><td align="char">0.98</td><td>1,235</td><td>445,968</td></tr><tr><td><inline-formula><mml:math id="M51" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">4:46</td><td>6,879</td><td align="char">37.29</td><td>3,381</td><td>9,696,884</td><td><inline-formula><mml:math id="M52" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">3:28</td><td>6,853</td><td align="char">12.12</td><td>1,982</td><td>445,968</td></tr><tr><td rowspan="2">2 GiB</td><td><inline-formula><mml:math id="M53" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">5:02</td><td>7,798</td><td align="char">2.29</td><td>2,260</td><td>0</td><td><inline-formula><mml:math id="M54" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">3:04</td><td>7,775</td><td align="char">0.94</td><td>2,260</td><td>141</td></tr><tr><td><inline-formula><mml:math id="M55" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">5:48</td><td>7,807</td><td align="char">25.39</td><td>4,592</td><td>0</td><td><inline-formula><mml:math id="M56" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">3:46</td><td>7,797</td><td align="char">8.15</td><td>2,373</td><td>141</td></tr><tr><td rowspan="2">4 GiB</td><td><inline-formula><mml:math id="M57" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">5:40</td><td>9,964</td><td align="char">1.92</td><td>4,308</td><td>0</td><td><inline-formula><mml:math id="M58" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">3:12</td><td>9,914</td><td align="char">0.92</td><td>4,308</td><td>0</td></tr><tr><td><inline-formula><mml:math id="M59" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">6:36</td><td>9,999</td><td align="char">18.46</td><td>5,854</td><td>0</td><td><inline-formula><mml:math id="M60" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">3:58</td><td>9,870</td><td align="char">5.80</td><td>2,742</td><td>0</td></tr><tr><td rowspan="2">8 GiB</td><td><inline-formula><mml:math id="M61" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">6:04</td><td>13,908</td><td align="char">1.61</td><td>8,403</td><td>0</td><td><inline-formula><mml:math id="M62" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">3:21</td><td>13,999</td><td align="char">0.94</td><td>8,404</td><td>0</td></tr><tr><td><inline-formula><mml:math id="M63" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">7:08</td><td>15,318</td><td align="char">12.95</td><td>7,075</td><td>0</td><td><inline-formula><mml:math id="M64" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">4:13</td><td>14,044</td><td align="char">4.59</td><td>3,112</td><td>0</td></tr></tbody></table><table-wrap-foot><fn><p>On the left are the numbers for <inline-formula><mml:math id="M65" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers (IBF), on the right for <inline-formula><mml:math id="M66" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers (MIBF). Compressed versions are denoted by the suffix ’c’. Construction times are in MM:SS, search times in SS.ss. RAM represents the memory peak in MiB during the construction and search, respectively. A total of 1,048,576 reads were processed, allowing for up to 2 errors. False positives (FP) are reads originating from bin <italic>i</italic> assigned to a bin <inline-formula><mml:math id="M67" altimg="si48.gif"><mml:mrow><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, neglecting the fact that the read may match with bin <italic>j</italic> when allowing for 2 errors.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0110">Our experiments show that allocating only 1 GiB for an IBF using <inline-formula><mml:math id="M68" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers results in a high number of FPs for all values <italic>b</italic> - we would have to conduct about <inline-formula><mml:math id="M69" altimg="si21.gif"><mml:mrow><mml:mn>6</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>5</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M70" altimg="si22.gif"><mml:mrow><mml:mn>9.6</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> wrong verifications for the IBF for <inline-formula><mml:math id="M71" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M72" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula>, respectively. For <inline-formula><mml:math id="M73" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, the numbers are over one order of magnitude smaller (<inline-formula><mml:math id="M74" altimg="si23.gif"><mml:mrow><mml:mn>2.8</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>4</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M75" altimg="si24.gif"><mml:mrow><mml:mn>4.4</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>5</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>). This is to be expected since we store a smaller set of representative <italic>k</italic>-mers. By doubling the size of the IBF, the number of FPs is already heavily reduced for <inline-formula><mml:math id="M76" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers. Indeed, there are no more FPs caused by the Bloom filter. Note that the 189 FP for <inline-formula><mml:math id="M77" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> are reads whose minimizer composition actually occurs in a different bin than its original bin by chance. Since distributing the <italic>k</italic>-mers to more bins reduces the chance of the same minimizer composition being present in different bins, the FP count for <inline-formula><mml:math id="M78" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> is 0. For <inline-formula><mml:math id="M79" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, we can still see <inline-formula><mml:math id="M80" altimg="si25.gif"><mml:mrow><mml:mn>197</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>189</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula> FP induced by the Bloom filter for <inline-formula><mml:math id="M81" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and 141 for <inline-formula><mml:math id="M82" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula>. This indicates that the distribution of the <inline-formula><mml:math id="M83" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers is not completely uniform or that our probabilistic threshold for the counting lemma introduced a few FP. In general, the effect of using minimizers on the FP rate is negligible. For larger sized IBF, no FP searches induced by the Bloom filter occur for both minimizer sets. The FP counts are obviously the same if we apply lossless compression to the bitvector.</p>
      <p id="p0115">Next, we look at the time and space usage for index construction. The construction time for <inline-formula><mml:math id="M84" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> is between 11 and 13 min and for <inline-formula><mml:math id="M85" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> between 4 and 6 min. For <inline-formula><mml:math id="M86" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins, the wall clock time is smaller, since we can easily parallelize the construction (in chunks of 64), which is not possible for 64 bins. The time for 64 bins is larger than for 1024 bins since we insert more data in a single bin than in the case for 1024 bins. The space needed for construction is the size of the IBF and thread-local storage for the input sequences. In order to compress the IBF, both the uncompressed and compressed version must be in memory for a short amount of time, resulting in an increased memory peak.</p>
      <p id="p0120">For <inline-formula><mml:math id="M87" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, the construction time is generally lower since we insert fewer representative <italic>k</italic>-mers. While for <inline-formula><mml:math id="M88" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>, the times are comparable, the IBF can be built almost twice as fast for <inline-formula><mml:math id="M89" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> compared to <inline-formula><mml:math id="M90" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers.</p>
      <p id="p0125">Now we discuss the time and space usage for the search. For <inline-formula><mml:math id="M91" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>, Raptor needs about 1 s to search for the <inline-formula><mml:math id="M92" altimg="si9.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>20</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> reads for all IBF sizes. This holds true for both minimizer sets. Although Raptor searches fewer representative <italic>k</italic>-mers in case of the <inline-formula><mml:math id="M93" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, we need to compute the minimizers of the query beforehand, which is additional work. For <inline-formula><mml:math id="M94" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> we need between 2.2 s for a 2 GiB IBF and 1.6 s for an 8 GiB IBF. The increase for larger <italic>b</italic> is to be expected since we need to check for all bits in the binning bitvector. This takes longer for larger binning bitvectors. For <inline-formula><mml:math id="M95" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, we only see a slight increase and still need about 1 s. The benefit of querying fewer <italic>k</italic>-mers becomes pronounced and the IBF is up to twice as fast as the IBF for <inline-formula><mml:math id="M96" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers.</p>
      <p id="p0130">When searching, it is also interesting how large the memory footprint is if we use compressed bitvectors. For <inline-formula><mml:math id="M97" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M98" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, we see for the IBF that compression actually <italic>increases</italic> the memory footprint until we use ann IBF of 8 GiB. This means that the bitvectors are not sparse and that the space overhead of the compression algorithm outweighs the benefit of compressing the data.</p>
      <p id="p0135">In addition, the search time increases by a factor of about 4 for <inline-formula><mml:math id="M99" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and about <inline-formula><mml:math id="M100" altimg="si27.gif"><mml:mrow><mml:mn>8</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>11</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="M101" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula>, which makes compression here unattractive.</p>
      <p id="p0140">This changes for <inline-formula><mml:math id="M102" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers. For <inline-formula><mml:math id="M103" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>, the search time increases from about 1 s to only 1.6 s while we can compress the bitvector from 4.3 to 2.7 GiB or from 8.4 to 3.1 GiB. For <inline-formula><mml:math id="M104" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula>, the compression is similar since we store the same number of <italic>k</italic>-mers, but the run time increases by a factor of <inline-formula><mml:math id="M105" altimg="si28.gif"><mml:mrow><mml:mn>5</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula>. This is due to the need to decompress the <inline-formula><mml:math id="M106" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bit long binning bitvector which takes longer than for the 64 bit long bitvector. Still, for <inline-formula><mml:math id="M107" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers and smaller <italic>b</italic>, using compression offers an attractive time/space trade-off. For querying, we can observe that, in general, a sparser bitvector returns the results faster.</p>
      <p id="p0145">Finally, we investigated the impact of partitioning the IBF into <inline-formula><mml:math id="M108" altimg="si29.gif"><mml:mrow><mml:mi>x</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,2,4,8</mml:mn></mml:mrow></mml:math></inline-formula> parts. Since Raptor cannot directly evaluate the counting vector for each read after having looked at one part, we need to store the intermediate results and check if we match the threshold after having counted the <italic>k</italic>-mers in all parts of the partition. To do this, Raptor allocates a buffer vector of size <inline-formula><mml:math id="M109" altimg="si30.gif"><mml:mrow><mml:msup><mml:mn>10</mml:mn><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> where each position holds a vector of <italic>b</italic> bits that is assigned to one of the reads. After counting the occurrences of the <italic>k</italic>-mers of a read in one partition, we can add the result to the vector and use the vector for the next batch of reads. We report on the construction and search time, as well as on the maximum memory allocated by the resulting <italic>x</italic>-PIBF, for <inline-formula><mml:math id="M110" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M111" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins. We use an 8 GiB IBF in these experiments. The results are shown in <xref rid="tbl2" ref-type="table">Table 2</xref>.<table-wrap position="float" id="tbl2"><label>Table 2</label><caption><p>Construction and search time for partitioned IBF of size 8 GiB</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="2" rowspan="3">IBF</th><th colspan="11">64<hr/></th></tr><tr><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th><th rowspan="2"/><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th></tr></thead><tbody><tr><td rowspan="2">1-IBF</td><td><inline-formula><mml:math id="M112" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">13:03</td><td>10,823</td><td align="char">0.92</td><td>8,398</td><td align="char">189</td><td><inline-formula><mml:math id="M113" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">11:23</td><td>10,773</td><td align="char">0.89</td><td>8,405</td><td align="char">189</td></tr><tr><td><inline-formula><mml:math id="M114" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">13:10</td><td>15,318</td><td align="char">4.47</td><td>7,072</td><td align="char">189</td><td><inline-formula><mml:math id="M115" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">12:04</td><td>11,351</td><td align="char">1.41</td><td>3,112</td><td align="char">189</td></tr><tr><td rowspan="2">2-IBF</td><td><inline-formula><mml:math id="M116" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">16:49</td><td>6,757</td><td align="char">1.56</td><td>4,470</td><td align="char">189</td><td><inline-formula><mml:math id="M117" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">14:34</td><td>6,804</td><td align="char">1.18</td><td>4,478</td><td align="char">189</td></tr><tr><td><inline-formula><mml:math id="M118" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">18:38</td><td>7,853</td><td align="char">7.74</td><td>4,118</td><td align="char">189</td><td><inline-formula><mml:math id="M119" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">15:08</td><td>6,888</td><td align="char">2.37</td><td>2,071</td><td align="char">189</td></tr><tr><td rowspan="2">4-IBF</td><td><inline-formula><mml:math id="M120" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">19:59</td><td>4,814</td><td align="char">2.56</td><td>2,427</td><td align="char">189</td><td><inline-formula><mml:math id="M121" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">19:31</td><td>4,796</td><td align="char">1.75</td><td>2,422</td><td align="char">189</td></tr><tr><td><inline-formula><mml:math id="M122" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">18:43</td><td>5,055</td><td align="char">12.86</td><td>2,339</td><td align="char">189</td><td><inline-formula><mml:math id="M123" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">19:21</td><td>4,869</td><td align="char">4.16</td><td>1,284</td><td align="char">189</td></tr><tr><td rowspan="2">8-IBF</td><td><inline-formula><mml:math id="M124" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">22:35</td><td>3,930</td><td align="char">4.27</td><td>1,405</td><td align="char">189</td><td><inline-formula><mml:math id="M125" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">29:34</td><td>3,918</td><td align="char">2.68</td><td>1,406</td><td align="char">190</td></tr><tr><td><inline-formula><mml:math id="M126" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">23:37</td><td>3,969</td><td align="char">23.06</td><td>1,336</td><td align="char">189</td><td><inline-formula><mml:math id="M127" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">27:47</td><td>3,934</td><td align="char">6.90</td><td>857</td><td align="char">190</td></tr></tbody></table><table frame="hsides" rules="groups"><thead><tr><th colspan="2" rowspan="3"/><th colspan="11">1,024<hr/></th></tr><tr><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th><th rowspan="2"/><th colspan="2">Construct<hr/></th><th colspan="3">Search<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>FP</th></tr></thead><tbody><tr><td rowspan="2">1-IBF</td><td><inline-formula><mml:math id="M128" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">6:09</td><td>13,992</td><td align="char">1.69</td><td>8,398</td><td align="char">0</td><td><inline-formula><mml:math id="M129" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">3:24</td><td>14,094</td><td align="char">0.93</td><td>8,404</td><td align="char">0</td></tr><tr><td><inline-formula><mml:math id="M130" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">7:10</td><td>15,318</td><td align="char">12.44</td><td>7,071</td><td align="char">0</td><td><inline-formula><mml:math id="M131" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">4:13</td><td>14,107</td><td align="char">4.57</td><td>3,112</td><td align="char">0</td></tr><tr><td rowspan="2">2-IBF</td><td><inline-formula><mml:math id="M132" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">6:32</td><td>10,548</td><td align="char">3.48</td><td>6,396</td><td align="char">0</td><td><inline-formula><mml:math id="M133" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">4:10</td><td>10,642</td><td align="char">1.51</td><td>6,396</td><td align="char">0</td></tr><tr><td><inline-formula><mml:math id="M134" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">7:36</td><td>10,542</td><td align="char">24.94</td><td>6,037</td><td align="char">0</td><td><inline-formula><mml:math id="M135" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">5:01</td><td>10,646</td><td align="char">8.70</td><td>4,079</td><td align="char">0</td></tr><tr><td rowspan="2">4-IBF</td><td><inline-formula><mml:math id="M136" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">6:48</td><td>8,490</td><td align="char">6.29</td><td>4,348</td><td align="char">0</td><td><inline-formula><mml:math id="M137" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">5:32</td><td>8,572</td><td align="char">2.61</td><td>4,350</td><td align="char">0</td></tr><tr><td><inline-formula><mml:math id="M138" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">7:52</td><td>8,489</td><td align="char">47.10</td><td>4,259</td><td align="char">0</td><td><inline-formula><mml:math id="M139" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">6:23</td><td>8,572</td><td align="char">16.48</td><td>3,204</td><td align="char">0</td></tr><tr><td rowspan="2">8-IBF</td><td><inline-formula><mml:math id="M140" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">7:51</td><td>7,631</td><td align="char">11.70</td><td>3,318</td><td align="char">0</td><td><inline-formula><mml:math id="M141" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF</td><td align="char">8:25</td><td>7,512</td><td align="char">4.62</td><td>3,318</td><td align="char">8</td></tr><tr><td><inline-formula><mml:math id="M142" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBFc</td><td align="char">8:39</td><td>7,432</td><td align="char">92.77</td><td>3,278</td><td align="char">0</td><td><inline-formula><mml:math id="M143" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBFc</td><td align="char">9:19</td><td>7,512</td><td align="char">32.07</td><td>2,772</td><td align="char">8</td></tr></tbody></table><table-wrap-foot><fn><p>The IBF is partitioned into 1 to 8 parts. On the left are the numbers for <inline-formula><mml:math id="M144" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers (IBF), on the right for <inline-formula><mml:math id="M145" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers (MIBF). Compressed versions are denoted by the suffix ’c’. Construction times are in MM:SS, search times in SS.ss. RAM represents the memory peak in MiB during the construction and search, respectively. Raptor processes a total of 1,048,576 reads, allowing for up to 2 errors. False positives (FP) are reads originating from bin <italic>i</italic> assigned to a bin <inline-formula><mml:math id="M146" altimg="si48.gif"><mml:mrow><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, neglecting the fact that the read may match with bin <italic>j</italic> when allowing for 2 errors.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0150">In general, we observe for all minimizers that the construction and query times grow higher the more parts Raptor uses. For <inline-formula><mml:math id="M147" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, the build time increases from about 13 min to 23 min for <inline-formula><mml:math id="M148" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>, while for <inline-formula><mml:math id="M149" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> it increases from about 6 to 8 min. For <inline-formula><mml:math id="M150" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>, the search time for the IBF increases from about 1 s for a 1-PIBF to 4.3 s for an 8-PIBF. When using more parts, the run time increases, but the space needed to hold a single part in memory decreases. While we need 8 GiB memory to use a 1-PIBF, we only need 1.4 GiB if we use an 8-PIBF. When using <inline-formula><mml:math id="M151" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, we see similar trends for <inline-formula><mml:math id="M152" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula>. Furthermore, like in the unpartitioned case, the search time is faster. Indeed, for an 8-PIBF we need only 2.68 s for the query and for an 8-PIBFc only 6.9 s while using only 857 MiB peak memory.</p>
      <p id="p0155">For <inline-formula><mml:math id="M153" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M154" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, the search times for the IBF increases from 1.69 s to 11.7 s for ann 8-PIBF. As before, compression is unattractive for this case, while it pays off for the <inline-formula><mml:math id="M155" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizer version.</p>
      <p id="p0160">In general, the construction time of Raptor's index increases, the more parts we create, since we have to stream over our input <italic>x</italic> times and store <italic>x</italic> parts on the disk. However, we observe that this increase has a lower rate than the increase in the parts, as both constructing and querying an <italic>x</italic>-PIBF do take less than <italic>x</italic> times the time of a 1-PIBF. The reason for this is that we do not have to access the bitvector for <italic>k</italic>-mers that are not in the current part.</p>
    </sec>
    <sec id="sec2.5">
      <title>Impact of probabilistic thresholding on false negatives</title>
      <p id="p0165">In this section, we show that our probabilistic thresholding is crucial in avoiding false negatives. When we use <inline-formula><mml:math id="M156" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, the <italic>k</italic>-mer lemma ensures that we have no false negatives, but this is no longer true when using minimizers with <inline-formula><mml:math id="M157" altimg="si31.gif"><mml:mrow><mml:mi>w</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. This is apparent since the <italic>number</italic> and <italic>distribution</italic> of <inline-formula><mml:math id="M158" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers is sequence dependent and hence leads to a different threshold for each read. In the methods section, we describe how we derived a method to compute, for a given maximal number of errors, a threshold depending on the parameters <italic>w</italic>, <italic>k</italic> and the number of minimizers a query has.</p>
      <p id="p0170">Tools like Mantis and COBS, which use a simple percentage cutoff, would suffer in a similar increase in false negatives if they used minimizers. However, they could use our results to adapt their thresholding. In our dataset, the number of minimizers for each read ranges from 15 to 35 while our thresholds range from 4 to 13.</p>
      <p id="p0175">For example, for a query of length 100 with 20 minimizers the threshold is 6, which is lower than <inline-formula><mml:math id="M159" altimg="si32.gif"><mml:mrow><mml:mn>0.41</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:mn>20</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>8.2</mml:mn></mml:mrow></mml:math></inline-formula>. Using our threshold avoids falsely filtering out the query. In general, the percentage of minimizers that need to be present ranges from <inline-formula><mml:math id="M160" altimg="si33.gif"><mml:mrow><mml:mn>26</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M161" altimg="si34.gif"><mml:mrow><mml:mn>38</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula>. This shows that applying a single threshold is not sufficient. <xref rid="tbl3" ref-type="table">Table 3</xref> shows the resulting FPs and FNs of our adapted Lemma for various IBF sizes.<table-wrap position="float" id="tbl3"><label>Table 3</label><caption><p>False positives (FPs) and false negatives for differently sized <inline-formula><mml:math id="M162" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-MIBF using the adapted k-mer lemma (Lemma 2 in extra content)</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">IBF</th><th colspan="2">64<hr/></th><th colspan="2">1,024<hr/></th></tr><tr><th>FP</th><th>FN</th><th>FP</th><th>FN</th></tr></thead><tbody><tr><td>1 GiB</td><td align="char">309</td><td align="char">796</td><td align="char">1803</td><td align="char">753</td></tr><tr><td>2 GiB</td><td align="char">189</td><td align="char">1803</td><td align="char">0</td><td align="char">1696</td></tr><tr><td>4 GiB</td><td align="char">189</td><td align="char">2270</td><td align="char">0</td><td align="char">2172</td></tr><tr><td>8 GiB</td><td align="char">189</td><td align="char">2422</td><td align="char">0</td><td align="char">2308</td></tr></tbody></table><table-wrap-foot><fn><p>The resulting threshold is <inline-formula><mml:math id="M163" altimg="si49.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mn>41</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula>. False positives are reads originating from bin <italic>i</italic> assigned to a bin <inline-formula><mml:math id="M164" altimg="si48.gif"><mml:mrow><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, neglecting the fact that the read may match with bin <italic>j</italic> when allowing for 2 errors. False negatives are reads originating from bin <italic>i</italic> not assigned to bin <italic>i</italic>.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="sec2.6">
      <title>Comparison with other tools</title>
      <p id="p0180">In the following, we compare Raptor with the state-of-the-art tools Mantis (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>) and COBS (<xref rid="bib3" ref-type="bibr">Bingmann et al., 2019</xref>) using the artificial data set and a real data set of <inline-formula><mml:math id="M165" altimg="si15.gif"><mml:mrow><mml:mn>1,742</mml:mn></mml:mrow></mml:math></inline-formula> RNA-Seq experiments also used in (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>) as described earlier. Note that the computational experiments for the real data set only use one thread for all tools, the same as it was done in the competitors' publications. The effect of parallelization was tested using the artificial data set where we used 32 threads.</p>
      <p id="p0185">We built an index over the artificial dataset (separated in 64 and <inline-formula><mml:math id="M166" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins) with COBS and Mantis for a <italic>k</italic>-mer size of 19. Afterward, we queried the same reads we have already searched with Raptor using BDs. Both COBS and Mantis consider a transcript found if the amount of <italic>k</italic>-mers found is more or equal to a given threshold. Instead of using the default threshold of 80 percent, we determined a threshold according to the standard <italic>k</italic>-mer counting lemma, which was 53 percent.</p>
      <p id="p0190">Moreover, we had to adapt our input for the index construction of Mantis by adding random quality scores to our FASTA files because Mantis only accepts FASTQ files as input. But even with this adaptation, Mantis, or more precisely the helper tool Squeaker, resulted in a segmentation fault for the artificial dataset separated in 64 bins, thus we only present result for Mantis with <inline-formula><mml:math id="M167" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins.</p>
      <p id="p0195">As can be seen in <xref rid="tbl4" ref-type="table">Table 4</xref>, the construction of COBS and Mantis takes at least three times longer than for Raptor. Furthermore, searching with Raptor only needs a fraction of the space (about <inline-formula><mml:math id="M168" altimg="si28.gif"><mml:mrow><mml:mn>5</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula> GiB vs. 20 GiB) COBS and Mantis need, while being as accurate. The most striking difference is the search time. For <inline-formula><mml:math id="M169" altimg="si10.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>19,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, Raptor needs between 0.9 s for <inline-formula><mml:math id="M170" altimg="si18.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> and 1.6 s for <inline-formula><mml:math id="M171" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula>. This is about 144 times faster than COBS and (for <inline-formula><mml:math id="M172" altimg="si19.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula>) about 30 times faster than Mantis.<table-wrap position="float" id="tbl4"><label>Table 4</label><caption><p>Comparison COBS and Mantis for the artificial dataset with 64 and 1,024 bins</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="2" rowspan="2">IBF</th><th colspan="3">Construct<hr/></th><th colspan="3">Search<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>Space</th><th>Time</th><th>RAM</th><th>FP</th></tr></thead><tbody><tr><td rowspan="2">64</td><td>COBS</td><td>89:06</td><td>20,654</td><td align="char">21</td><td align="char">130.8</td><td>20,492</td><td align="char">125</td></tr><tr><td>Mantis</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td><td>–</td></tr><tr><td rowspan="2">1,024</td><td>COBS</td><td>26:37</td><td>20,657</td><td align="char">21</td><td align="char">134.33</td><td>20,470</td><td align="char">0</td></tr><tr><td>Mantis</td><td>78:33 (+49:12)</td><td>36,048</td><td align="char">21</td><td align="char">46.81</td><td>21,018</td><td align="char">0</td></tr></tbody></table><table-wrap-foot><fn><p>Construction times are in MM:SS and search times in SS.ss. The construction time in brackets for Mantis is the additional time the preprocessing tool Squeaker needs. The used disk space is in GiB, the maximum RAM in MiB. All approaches are built for <inline-formula><mml:math id="M173" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula>.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0200">Next, we evaluated the tools on the real dataset. We built an index over the dataset (that means for <inline-formula><mml:math id="M174" altimg="si15.gif"><mml:mrow><mml:mn>1,742</mml:mn></mml:mrow></mml:math></inline-formula> bins) with COBS, Mantis, and Raptor using a binning directory for a <italic>k</italic>-mer size of 20 (since this value was used in (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>)). For Raptor, we created two versions, one using a binning directory with an IBF with <inline-formula><mml:math id="M175" altimg="si35.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>20,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers and one version using a binning directory with an IBF with <inline-formula><mml:math id="M176" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers. Mantis uses a cutoff in order to sort out low-frequency <italic>k</italic>-mers that probably resulted from sequencing errors (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>). In order to be comparable, Raptor applied the same cutoffs for both versions of the binning directories. The results are shown in <xref rid="tbl5" ref-type="table">Table 5</xref>.<table-wrap position="float" id="tbl5"><label>Table 5</label><caption><p>Comparison of raptor, COBS, and Mantis</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">IBF</th><th colspan="3">Construct<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>Space</th></tr></thead><tbody><tr><td><inline-formula><mml:math id="M177" altimg="si35.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>20,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td>34</td><td align="char">8.1</td><td>8</td></tr><tr><td><inline-formula><mml:math id="M178" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td>2</td><td align="char">0.9</td><td>0.8</td></tr><tr><td>COBS</td><td>4,620</td><td align="char">702.6</td><td>4,265</td></tr><tr><td>Mantis</td><td>135</td><td align="char">29.7</td><td>17</td></tr></tbody></table><table-wrap-foot><fn><p>Construction times are in minutes. The used disk space and the maximum RAM are given in GiB. All approaches are built for <inline-formula><mml:math id="M179" altimg="si16.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula>.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0205">Raptor's construction time of the binning directory is faster than Mantis and COBS. The space consumption drops to only 5% of that of Mantis when using <inline-formula><mml:math id="M180" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers. COBS's construction time and space consumption is nowhere near the other two applications, because COBS has no preprocessing step and does not use cutoffs to filter out erroneous <italic>k</italic>-mers. Therefore, further comparisons to COBS are omitted.</p>
      <p id="p0210">In order to compare the query times, three differently sized sets (100, <inline-formula><mml:math id="M181" altimg="si37.gif"><mml:mrow><mml:mn>1,000</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M182" altimg="si38.gif"><mml:mrow><mml:mn>10,000</mml:mn></mml:mrow></mml:math></inline-formula> transcripts) were used. Each set was created by randomly picking human gene transcripts. The lengths varied between 46 bp and <inline-formula><mml:math id="M183" altimg="si39.gif"><mml:mrow><mml:mn>101,518</mml:mn></mml:mrow></mml:math></inline-formula> bp.</p>
      <p id="p0215">The FPR was determined by comparing Raptor's results to Mantis, assuming Mantis correctly finds all experiments as it claims to be exact. A similar evaluation was applied in (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>). Also, the definition of a found transcript is based on the evaluation of (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>). Therefore, both Mantis and Raptor consider a transcript found in an experiment if <inline-formula><mml:math id="M184" altimg="si40.gif"><mml:mrow><mml:mn>80</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula> of its representative <italic>k</italic>-mers are found.</p>
      <p id="p0220">As shown in <xref rid="tbl6" ref-type="table">Table 6</xref>, Raptor using a BD with <inline-formula><mml:math id="M185" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers is significantly faster (<inline-formula><mml:math id="M186" altimg="si41.gif"><mml:mrow><mml:mn>12</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>58</mml:mn></mml:mrow></mml:math></inline-formula> times) than Mantis and uses only a fraction of main memory while still being specific with a low FP rate of about 0.017. Even when using <inline-formula><mml:math id="M187" altimg="si35.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>20,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, Raptor outperforms Mantis in space and time consumption.<table-wrap position="float" id="tbl6"><label>Table 6</label><caption><p>Comparison of raptor and Mantis</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="2" rowspan="2">Transcripts</th><th colspan="3">Search<hr/></th></tr><tr><th>Time</th><th>RAM</th><th>FPR</th></tr></thead><tbody><tr><td rowspan="3">100</td><td><inline-formula><mml:math id="M188" altimg="si35.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>20,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">7</td><td align="char">8</td><td align="char">0.025</td></tr><tr><td><inline-formula><mml:math id="M189" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">1</td><td align="char">0.8</td><td align="char">0.015</td></tr><tr><td>Mantis</td><td align="char">12</td><td align="char">18.7</td><td align="char">0.0</td></tr><tr><td rowspan="3">1,000</td><td><inline-formula><mml:math id="M190" altimg="si35.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>20,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">10</td><td align="char">8</td><td align="char">0.03</td></tr><tr><td><inline-formula><mml:math id="M191" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">1</td><td align="char">0.8</td><td align="char">0.016</td></tr><tr><td>Mantis</td><td align="char">30</td><td align="char">19</td><td align="char">0.0</td></tr><tr><td rowspan="3">10,000</td><td><inline-formula><mml:math id="M192" altimg="si35.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>20,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">46</td><td align="char">8</td><td align="char">0.031</td></tr><tr><td><inline-formula><mml:math id="M193" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-IBF</td><td align="char">4</td><td align="char">0.8</td><td align="char">0.017</td></tr><tr><td>Mantis</td><td align="char">232</td><td align="char">23.3</td><td align="char">0.0</td></tr></tbody></table><table-wrap-foot><fn><p>Search times are in seconds, RAM is given in GiB. All approaches are built for <inline-formula><mml:math id="M194" altimg="si16.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>20</mml:mn></mml:mrow></mml:math></inline-formula>.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="sec2.7">
      <title>Biological case study</title>
      <p id="p0225">To evaluate the use of Raptor in conjunction with other bioinformatics applications, we re-implemented the distributed read mapping tool DREAM-Yara (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>). These changes consisted of changing to the IBF implementation used in Raptor as well as the incorporation of minimizers. Additionally, smaller changes to address inconsistencies in command line usage and bugs where applied to both the original and new DREAM-Yara.</p>
      <p id="p0230">We will compare the original DREAM-Yara using 19-mers to the new DREAM-Yara using 19-mers and both <inline-formula><mml:math id="M195" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>- and <inline-formula><mml:math id="M196" altimg="si42.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>31,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers for different IBF sizes.</p>
      <p id="p0235">The steps involved building the FM-indices used by DREAM-Yara were not affected by the adaptations, hence the build time and memory consumption for the FM-Index in DREAM-Yara are for both new and original around 40 min and 85 GiB, respectively, for 1024 bins and 5 hr 20 min and 89 GiB, respectively, for 64 bins.</p>
      <p id="p0240">As can be seen in <xref rid="tbl7" ref-type="table">Table 7</xref>, the memory consumption of both versions of DREAM-Yara is virtually the same when using 19-mers and an IBF of size 16 GiB. The IBF build step uses around 17.1 GiB and 17.4 GiB of memory while the mapping requires approximately 30 and 23 GiB for 64 and 1024 bins, respectively. The new DREAM-Yara shows a performance improvement regarding run time, reducing the time needed to build the IBF from 9:17 to 7:3 and 9:14 to 7:49 for 64 and 1024 bins, respectively. The mapping time similarly decreased from 5:15 to 3:26 min and from 7:39 to 6:18 min. While the original version already had 255 (64 bins) and 220 (1024 bins) unmapped reads, the new version increased this by a handful of reads to 257 and 234, respectively.<table-wrap position="float" id="tbl7"><label>Table 7</label><caption><p>Comparison of DREAM-Yara with and without minimizers</p></caption><table frame="hsides" rules="groups"><thead><tr><th rowspan="2">IBF</th><th colspan="2"><hr/></th><th colspan="3">IBF<hr/></th><th colspan="3">Mapper<hr/></th></tr><tr><th>w</th><th>k</th><th>Size</th><th>Time</th><th>RAM</th><th>Time</th><th>RAM</th><th>Unmapped reads</th></tr></thead><tbody><tr><td rowspan="4">64</td><td>–</td><td align="char">19</td><td align="char">16</td><td align="char">9:17</td><td>17,129</td><td align="char">5:15</td><td>29,913</td><td align="char">255</td></tr><tr><td align="char">19</td><td align="char">19</td><td align="char">16</td><td align="char">7:37</td><td>17,148</td><td align="char">3:26</td><td>30,087</td><td align="char">257</td></tr><tr><td align="char">23</td><td align="char">19</td><td align="char">4</td><td align="char">4:15</td><td>4,858</td><td align="char">3:54</td><td>17,516</td><td align="char">257</td></tr><tr><td align="char">31</td><td align="char">19</td><td align="char">2</td><td align="char">2:15</td><td>2,820</td><td align="char">4:24</td><td>15,200</td><td align="char">257</td></tr><tr><td rowspan="4">1024</td><td>–</td><td align="char">19</td><td align="char">16</td><td align="char">9:14</td><td>17,404</td><td align="char">7:39</td><td>23,091</td><td align="char">220</td></tr><tr><td align="char">19</td><td align="char">19</td><td align="char">16</td><td align="char">7:49</td><td>17,400</td><td align="char">6:18</td><td>23,037</td><td align="char">234</td></tr><tr><td align="char">23</td><td align="char">19</td><td align="char">4</td><td align="char">4:12</td><td>5,082</td><td align="char">6:59</td><td>10,865</td><td align="char">234</td></tr><tr><td align="char">31</td><td align="char">19</td><td align="char">2</td><td align="char">2:18</td><td>3,051</td><td align="char">6:52</td><td>8,988</td><td align="char">234</td></tr></tbody></table><table-wrap-foot><fn><p>IBF sizes are in GiB, times in MM:SS, and RAM in MiB. Both the original (the <italic>w</italic> column contains a <inline-formula><mml:math id="M197" altimg="si50.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo></mml:mrow></mml:math></inline-formula>) and new version of DREAM-Yara were used to build an index of the NCBI RefSeq and search for <inline-formula><mml:math id="M198" altimg="si9.gif"><mml:mrow><mml:msup><mml:mn>2</mml:mn><mml:mn>20</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> reads. All approaches use a <italic>k</italic> of 19, and the new DREAM-Yara additionally uses minimizers with a window length of 23 and 31, to build an IBF of a given size. Shown are the time and memory consumption for building the IBF and mapping the reads.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0245">Applying minimizers allows using smaller IBFs, for <inline-formula><mml:math id="M199" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, a 4 GiB IBF is sufficient, and for <inline-formula><mml:math id="M200" altimg="si42.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>31,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, even 2 GiB are enough. This decreases the memory consumption by around the amount of memory saved by the smaller IBF, resulting in needing around 5 and 3 GiB required to build the IBF. The memory consumption of the mapping step decreases to 17.5 GiB for <inline-formula><mml:math id="M201" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers and to 15.2 GiB for <inline-formula><mml:math id="M202" altimg="si42.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>31,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers when using 64 bins and to 10.8 and 9 GiB when using 1024 bins. The time needed to build an IBF only varies by a few seconds between 64 and 1024, with 19-mers for the new DREAM-Yara having the biggest difference with 12 s (7:37 and 7:49 for 64 and 1024 bins, respectively), while the difference is 3 s otherwise. When using the same parameters, the new version is around 1.5 min faster to build the IBF (from 9:17 to 7:47). Using minimizers amplifies this effect, resulting in an IBF build time of 4:15 for <inline-formula><mml:math id="M203" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers and 2:15 for <inline-formula><mml:math id="M204" altimg="si42.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>31,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers due to a smaller IBF size and less representative <italic>k</italic>-mers to process. The new version of the IBF is also able to answer queries faster than the version used in the original DREAM-Yara, hence the time needed for mapping decreases when switching to the newer version. Comparing for 19-mers, there is a change from 5:15 to 3:25 for 64 bins and from 7:39 to 6:18 for 1024 bins. Since the thresholds for minimizers are heuristic, this generally results in more verification being necessary, i.e. the mapper needs to map more reads. Hence, while still faster than the original version, the runtime for 64 bins increases to 3:54 and 4:24 for <inline-formula><mml:math id="M205" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>- and <inline-formula><mml:math id="M206" altimg="si42.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>31,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, respectively. Likewise, the runtime for 1024 bins increases to 6:59 and 6:52 for <inline-formula><mml:math id="M207" altimg="si11.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>23,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>- and <inline-formula><mml:math id="M208" altimg="si42.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>31,19</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, respectively.</p>
      <p id="p0250">When using minimizers and hence a probabilistic thresholding, the number of unmapped reads increased only by 2 respectively 14 which is quite acceptable considering the memory decrease.</p>
    </sec>
  </sec>
  <sec id="sec3">
    <title>Discussion</title>
    <p id="p0255">In this paper, we presented an approach to answer approximate string queries using a <italic>representative</italic> set of <italic>k</italic>-mers of the database and query. We stored a set of <inline-formula><mml:math id="M209" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers as representative <italic>k</italic>-mers of the database in a binning directory using a partitioned, IBF.</p>
    <p id="p0260">Binning directories could be used in various settings which we discuss below.</p>
    <sec id="sec3.1">
      <title>Using BDs for metagenomic profiling</title>
      <p id="p0265">Tools like Kraken (<xref rid="bib24" ref-type="bibr">Wood and Salzberg, 2014</xref>) or Centrifuge (<xref rid="bib14" ref-type="bibr">Kim et al., 2016</xref>) perform metagenomic binning by querying the <italic>k</italic>-mer content of genomes using NGS reads and inferring the presence or absence of organisms in the sample using the taxonomy of a phylogenetic tree.</p>
      <p id="p0270">Hence, we could use BDs for a classification based on taxonomic levels (e.g., species, genus, <inline-formula><mml:math id="M210" altimg="si43.gif"><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula>) or assembly level, and group the reference genome sequences accordingly. Using the counts for <italic>k</italic>-mers given by the BD, we can infer the composition of a metagenomic sample. Indeed, (<xref rid="bib19" ref-type="bibr">Piro et al., 2020</xref>) already applied this idea as described in (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>) for this task. This resolved the problem of uneven bin sizes by applying a preprocessing step to distribute the <italic>k</italic>-mer content of bins more evenly.</p>
    </sec>
    <sec id="sec3.2">
      <title>Using BDs for querying file content</title>
      <p id="p0275">Another application for BDs which we also used in one benchmark is to query all existing human RNA-Seq files in the SRA for the presence of transcripts. For this application, the bins would be defined by the respective file content. We would expect that the effective text size <inline-formula><mml:math id="M211" altimg="si44.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is considerably less than 5 TBases since we sample from human genes. Of course, this application scenario is not limited to RNA-Seq files.<table-wrap position="float" id="undtbl9"><label>Table</label><caption><p>Example of the assignment of <italic>q</italic>-mers to x = 5 partitions</p></caption><table frame="hsides" rules="groups"><thead><tr><th>2-mer</th><th>AA</th><th>AC</th><th>AG</th><th>AT</th><th>CA</th><th>CC</th><th>CG</th><th>CT</th></tr></thead><tbody><tr><td>Part</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>2-mer</td><td>GA</td><td>GC</td><td>GG</td><td>GT</td><td>TA</td><td>TC</td><td>TG</td><td>TT</td></tr><tr><td>Part</td><td>2</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><table-wrap-foot><fn><p>Given a DNA alphabet (<italic>σ</italic> = 4) and x = 5, we have to distribute the 16 possible <italic>q</italic>-mers evenly to the 5 parts. In this example we assume a uniform distribution of the <italic>q</italic>-mers.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="sec3.3">
      <title>Using BDs for read mapping</title>
      <p id="p0280">In the context of read mapping, we can use the BD as follows. The database would be the reference genome(s) we want to map our reads against. Assume we have divided them into bins such that similar parts of the genomes are placed within the same bin. In the context of metagenomics analysis, this could be achieved by using a taxonomic tree (see also (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>)); alternatively, the sequences could be clustered based on similarity. The sequences in the bins could then be indexed using a compressed suffix array or other suitable indices and the BD can be used to distribute the approximate searches. The biological case study in this paper is an example of such an application.</p>
    </sec>
    <sec id="sec3.4">
      <title>Possible extensions</title>
      <p id="p0285">Currently, Raptor stores all representative <italic>k</italic>-mers, even if some representative <italic>k</italic>-mers in the reference dataset are ubiquitous, i.e. they appear in all or almost all, e.g., 95%, bins. While some approaches, like Mantis, exclude certain <italic>k</italic>-mers from consideration, one could instead exclude them from the IBF and store them in a small lookup table. Whenever such a <italic>k</italic>-mer is queried, we can increase the counters on all bins and save the lookups in the IBF. This might reduce the size of the IBF and speed up the search time.</p>
      <p id="p0290">While not shown in this paper, the update operation on an IBF was already used in DREAM-Yara (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>) and ganon (<xref rid="bib19" ref-type="bibr">Piro et al., 2020</xref>). Adding data is trivial since we just need to set the corresponding bits in the <italic>x</italic>-PIBF. For removing data from the <italic>x</italic>-PIBF we need to clear and rebuild the <italic>affected</italic> bins of the update.</p>
    </sec>
    <sec id="sec3.5">
      <title>Limitations of study</title>
      <p id="p0295">The main limiting factor of our method is its susceptibility to uneven bin sizes as well as a high number of bins. The number of bins <italic>b</italic> directly affects the run time and memory consumption since the processed sub-bitvectors are of size <italic>b</italic>. While the increase in memory consumption is negligible, processing several ten thousand of bins will lead to a moderate slowdown. The size of the IBF is determined by the bin with the highest <italic>k</italic>-mer content. Hence, having unevenly distributed <italic>k</italic>-mer content across the bins will force us to increase the size of the IBF to accommodate a reasonable FP rate for the biggest bin, even though the smaller bins could achieve the same FP rate with a much lower size. However, we are actively working on a version of the IBF that will automatically adapt to inputs with uneven bin sizes. Furthermore, we will enhance the IBF by adding a hierarchical structure, i.e. a multi-level tree structure, which will dramatically reduce the number of bins needed to represent a dataset.</p>
      <p id="p0300">In conclusion, we presented a novel, versatile, fast, and memory efficient data structure for <italic>k</italic>-mer-based analysis of large sets of sequences using binning directories. Our implementation, Raptor, is ready for secondary memory use and its data structures can be efficiently compressed if the used bitvector is sparse. Furthermore, we showed that the concept of <inline-formula><mml:math id="M212" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers allows to effectively reduce the set of representative <italic>k</italic>-mers without sacrificing specificity nor sensitivity by applying our probabilistic thresholding. Raptor outperformed the state-of-the-art tools Mantis and COBS in both run time and space consumption. The use of <inline-formula><mml:math id="M213" altimg="si36.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mn>40,20</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers was able to reduce the memory footprint of our method from 8 to 0.9 GiB for the RNA-Seq dataset introduced in (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>), which is about one order of magnitude less compared to Mantis (<inline-formula><mml:math id="M214" altimg="si45.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≈</mml:mo><mml:mn>19</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>23</mml:mn></mml:mrow></mml:math></inline-formula> GiB). Using <inline-formula><mml:math id="M215" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers, the run time was better by factors between 12 and 144 compared to Mantis and COBS which enables completely new ways for analyzing large sequencing archives in ways that were not possible before. Raptor and binning directories are available in the SeqAn library (<xref rid="bib20" ref-type="bibr">Reinert et al., 2017</xref>) of efficient data types and algorithms.</p>
    </sec>
  </sec>
  <sec id="sec5">
    <title>STAR★Methods</title>
    <sec id="sec5.1">
      <title>Key resources table</title>
      <p id="p0310">
        <table-wrap position="float" id="undtbl1">
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th>REAGENT or RESOURCE</th>
                <th>SOURCE</th>
                <th>IDENTIFIER</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="3">
                  <bold>Deposited data</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>NIH brain, breast, and blood tissue (2652 experiments)</td>
                <td>
                  <xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>
                </td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.1186393" id="intref0010">https://doi.org/10.5281/zenodo.1186393</ext-link>
                </td>
              </tr>
              <tr>
                <td>NCBI RefSeq Archaea and Bacteria</td>
                <td>Various</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4647988" id="intref0015">https://doi.org/10.5281/zenodo.4647988</ext-link>
                </td>
              </tr>
              <tr>
                <td>Clustered NCBI RefSeq (64 bins)</td>
                <td>This paper</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4650188" id="intref0020">https://doi.org/10.5281/zenodo.4650188</ext-link>
                </td>
              </tr>
              <tr>
                <td>Clustered NCBI RefSeq (1024 bins)</td>
                <td>This paper</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4651078" id="intref0025">https://doi.org/10.5281/zenodo.4651078</ext-link>
                </td>
              </tr>
              <tr>
                <td>Clustered NCBI RefSeq queries (64 and 1024 bins)</td>
                <td>This paper</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4651379" id="intref0030">https://doi.org/10.5281/zenodo.4651379</ext-link>
                </td>
              </tr>
              <tr>
                <td>Artificial data set (64 and 1024 bins)</td>
                <td>This paper</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/seqan/raptor" id="intref0035">https://github.com/seqan/raptor</ext-link>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <bold>Software and algorithms</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>Raptor</td>
                <td>This paper</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/seqan/raptor" id="intref0040">https://github.com/seqan/raptor</ext-link>
                </td>
              </tr>
              <tr>
                <td>Mantis</td>
                <td>
                  <xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>
                </td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/splatlab/mantis" id="intref0045">https://github.com/splatlab/mantis</ext-link>
                </td>
              </tr>
              <tr>
                <td>COBS</td>
                <td>
                  <xref rid="bib3" ref-type="bibr">Bingmann et al., 2019</xref>
                </td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/bingmann/cobs" id="intref0050">https://github.com/bingmann/cobs</ext-link>
                </td>
              </tr>
              <tr>
                <td>DREAM-Yara</td>
                <td>
                  <xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>
                </td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/seqan/dream_yara" id="intref0055">https://github.com/seqan/dream_yara</ext-link>
                </td>
              </tr>
              <tr>
                <td>TaxSBP</td>
                <td>Vitor Piro</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/pirovc/taxsbp" id="intref0060">https://github.com/pirovc/taxsbp</ext-link>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </p>
    </sec>
    <sec id="sec5.2">
      <title>Resource availability</title>
      <sec id="sec5.2.1">
        <title>Lead contact</title>
        <p id="p0315">Further information and requests for resources should be directed to and will be fulfilled by the Lead Contact, Knut Reinert (<ext-link ext-link-type="uri" xlink:href="mailto:knut.reinert@fu-berlin.de" id="intref0065">knut.reinert@fu-berlin.de</ext-link>).</p>
      </sec>
      <sec id="sec5.2.2">
        <title>Materials availability</title>
        <p id="p0320">This study did not generate new materials.</p>
      </sec>
      <sec sec-type="data-availability" id="sec5.2.3">
        <title>Data and code availability</title>
        <p id="p0325">The data used for our experiments pertaining RNA-Seq is the same as used in Mantis (<xref rid="bib18" ref-type="bibr">Pandey et al., 2018</xref>). It consists of 2652 human sequencing experiments which originate from blood, breast and brain tissue samples. A list of SRRs and URIs of these experiments is provided by the authors of Mantis via Zenodo at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.1186393" id="intref0070">https://doi.org/10.5281/zenodo.1186393</ext-link>.</p>
        <p id="p0330">Datasets related to the biological case study using DREAM-Yara are available via Zenodo. These include: The NCBI RefSeq of archeal and bacterial genomes as of February 14th 2021 17:09 CET (<ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4647988" id="intref0075">https://doi.org/10.5281/zenodo.4647988</ext-link>), the version clustered into 64 bins (<ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4650188" id="intref0080">https://doi.org/10.5281/zenodo.4650188</ext-link>), the version clustered into 1024 bins (<ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4651078" id="intref0085">https://doi.org/10.5281/zenodo.4651078</ext-link>), and the queries used for both versions (<ext-link ext-link-type="uri" xlink:href="https://doi.org/10.5281/zenodo.4651379" id="intref0090">https://doi.org/10.5281/zenodo.4651379</ext-link>).</p>
        <p id="p0335">All scripts and supplemental code used in this paper, including those related to the artificial dataset and DREAM-Yara, are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/seqan/raptor" id="intref0095">https://github.com/seqan/raptor</ext-link>.</p>
        <p id="p0340">Pre-built DREAM-Yara indices for parameters shown in this paper are available at <ext-link ext-link-type="uri" xlink:href="https://ftp.imp.fu-berlin.de/pub/raptor/" id="intref0100">https://ftp.imp.fu-berlin.de/pub/raptor/</ext-link>.</p>
        <p id="p0345">Raptor is written in C++20 using the SeqAn Library (<xref rid="bib20" ref-type="bibr">Reinert et al., 2017</xref>) and available at <ext-link ext-link-type="uri" xlink:href="https://github.com/seqan/raptor" id="intref0105">https://github.com/seqan/raptor</ext-link>.</p>
      </sec>
    </sec>
    <sec id="sec5.3">
      <title>Method details</title>
      <sec id="sec5.3.1">
        <title><inline-formula><mml:math id="M216" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-<bold>Mminimizers</bold></title>
        <p id="p0350">In this work we introduce the concept of <inline-formula><mml:math id="M217" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><italic>-minimizers</italic> for computing representative <italic>k</italic>-mers. In <xref rid="fig1" ref-type="fig">Figure 1</xref>, we show an example for this concept. The reverse complement sequence is denoted in lower case, and we used the lexicographically smallest <italic>k</italic>-mer for clarity. In practice, this leads to a skewed distribution of minimizers which can be corrected by, for example, applying an XOR operation with a random value to each <italic>k</italic>-mer hash value before taking the numeric minimum (see (<xref rid="bib15" ref-type="bibr">Marçais et al., 2017</xref>) for a discussion). In the Figure you see a short example of a) ungapped 4-mers in a window of size 4, which means we take the lexicographically smallest of the <italic>k</italic>-mer and its reverse complement as the minimizing <italic>k</italic>-mer. The second case b) shows the minimizing 4-mers for a window of size 8. We form the minimum of all <italic>k</italic>-mers and their reverse complement in this window. We denote the window span with ’-’ and place the minimizing <italic>k</italic>-mer at the respective window position. For the properties and the size of the data we will handle, <italic>k</italic> will usually be in the range of <inline-formula><mml:math id="M218" altimg="si52.gif"><mml:mrow><mml:mn>16</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>32</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec id="sec5.3.2">
        <title>Effective text size and ratio</title>
        <p id="p0355">In general, Raptor assumes that we have a collection of strings <inline-formula><mml:math id="M219" altimg="si53.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> over an alphabet <inline-formula><mml:math id="M220" altimg="si54.gif"><mml:mrow><mml:mtext>Σ</mml:mtext></mml:mrow></mml:math></inline-formula>, with a total length <inline-formula><mml:math id="M221" altimg="si55.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:munder><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Raptor stores the <italic>k</italic>-mer content of <inline-formula><mml:math id="M222" altimg="si53.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> or a <italic>representative</italic> transformation of it. Raptor uses <inline-formula><mml:math id="M223" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula><italic>-minimizers</italic> for computing the set of representative <italic>k</italic>-mers.</p>
        <p id="p0360">To capture the repetitiveness of the <inline-formula><mml:math id="M224" altimg="si53.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, we define the <italic>effective</italic> text length <inline-formula><mml:math id="M225" altimg="si44.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> as the number of distinct, <italic>representative k</italic>-mers in all the <inline-formula><mml:math id="M226" altimg="si56.gif"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. In order to store the set of texts <inline-formula><mml:math id="M227" altimg="si53.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, we further assume that we have divided the <inline-formula><mml:math id="M228" altimg="si56.gif"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> into <italic>b</italic> bins <inline-formula><mml:math id="M229" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (mind that a single <inline-formula><mml:math id="M230" altimg="si56.gif"><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> itself could be divided into several bins without many adaptations). For the strings in a bin <inline-formula><mml:math id="M231" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we denote the set of representative <italic>k</italic>-mers with <inline-formula><mml:math id="M232" altimg="si58.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and the effective text length with <inline-formula><mml:math id="M233" altimg="si59.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> as the number of representative <italic>k</italic>-mers of the strings in <inline-formula><mml:math id="M234" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, i.e. the cardinality of <inline-formula><mml:math id="M235" altimg="si58.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
        <p id="p0365">Dividing the strings into bins could result in a large or small intersection of their representative <italic>k</italic>-mer content, depending on the method. To capture this, we define the <italic>effective text ratio</italic>
<inline-formula><mml:math id="M236" altimg="si60.gif"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> as <inline-formula><mml:math id="M237" altimg="si61.gif"><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula>. The effective text ratio is a measure of how well we have partitioned our <italic>k</italic>-mer content into the bins. Ideally it is 1 and in the worst case it is <italic>b</italic>. We want to point out that the effective text length <inline-formula><mml:math id="M238" altimg="si44.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is a crucial measure for the problem of indexing large genomic text collections. For example, (<xref rid="bib5" ref-type="bibr">Bradley et al., 2019</xref>) compute an index for 170 TiB of sequence data. However, this data set is quite repetitive since its effective text length <inline-formula><mml:math id="M239" altimg="si62.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mn>31</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is only <inline-formula><mml:math id="M240" altimg="si63.gif"><mml:mrow><mml:mn>6</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>10</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        <p id="p0370">For our artificial data set, we give the effective text ratio <inline-formula><mml:math id="M241" altimg="si51.gif"><mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for different <italic>k</italic> for both 64 and <inline-formula><mml:math id="M242" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins in <xref rid="tbl8" ref-type="table">Table 8</xref>.</p>
        <p id="p0375">One can see that we need a <italic>k</italic>-mer size of at least 16 to achieve an effective text ratio under 2. For <inline-formula><mml:math id="M243" altimg="si64.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula> the effective text ratio is near 1 which means that most <italic>k</italic>-mers in the bins are unique. For this reason we used <inline-formula><mml:math id="M244" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula> in our experiments.</p>
      </sec>
      <sec id="sec5.3.3">
        <title>Binning directories</title>
        <p id="p0380">We define a <italic>binning directory (BD)</italic> for the text collection <inline-formula><mml:math id="M245" altimg="si53.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> divided into <italic>b</italic> bins <inline-formula><mml:math id="M246" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as a data structure that returns the counts of the representative <italic>k</italic>-mers in the query multiset <inline-formula><mml:math id="M247" altimg="si65.gif"><mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for each bin <inline-formula><mml:math id="M248" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. In this work a binning directory uses a set membership data structure, namely the <italic>x</italic>-PIBF, that returns the bin membership as a (compressed) bitvector which we call the <italic>binning bitvector</italic>. The BD then combines the binning bitvectors into count vectors. Our Tool Raptor uses (probabilistic) thresholding to determine whether a query is in a bin or not.</p>
        <p id="p0385">Implementing a simple version is indeed not difficult. The problems lie in the fact that the effective text size <inline-formula><mml:math id="M249" altimg="si44.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> can be very large, i.e. <inline-formula><mml:math id="M250" altimg="si66.gif"><mml:mrow><mml:msup><mml:mn>10</mml:mn><mml:mn>10</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M251" altimg="si67.gif"><mml:mrow><mml:msup><mml:mn>10</mml:mn><mml:mn>12</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>. For example, the metagenomics data set used in (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>) contains about <inline-formula><mml:math id="M252" altimg="si68.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>10</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> different 19-mers. A naive implementation that stores all those 19-mers in a hash table containing the binning vectors for <inline-formula><mml:math id="M253" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bins would need about 40 TiB (an open addressing hash table with about <inline-formula><mml:math id="M254" altimg="si69.gif"><mml:mrow><mml:mn>4</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:msup><mml:mn>10</mml:mn><mml:mn>10</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> entries, each pointing to a <inline-formula><mml:math id="M255" altimg="si26.gif"><mml:mrow><mml:mn>1,024</mml:mn></mml:mrow></mml:math></inline-formula> bit bitvector). Hence, the challenge is implementing the BD in a more space-efficient way while maintaining a fast run time.</p>
        <p id="p0390">We approach this problem in two ways in this paper. For implementing a binning directory, we adapted the IBF data structure presented in (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>) to work well on secondary memory. We call it the <italic>x</italic>-partitioned IBF (<italic>x</italic>-PIBF). Secondly, we employ <inline-formula><mml:math id="M256" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers to reduce the number of representative <italic>k</italic>-mers significantly while still accurately answering the question in which bins a query can occur.</p>
      </sec>
      <sec id="sec5.3.4">
        <title>Answering a query with Raptor</title>
        <p id="p0395">Answering a query includes the retrieval of the binning bitvectors and the counting of <italic>k</italic>-mers to determine the bins to be searched. Using a <italic>x</italic>-PIBF, Raptor has to compute <italic>h</italic> hash functions, retrieve <italic>h</italic> sub-bitvectors and compute a bitwise AND. We can use a standard bitvector of size <italic>n</italic> that uses <italic>n</italic> bits, or the compressed bitvector of the SDSL (<xref rid="bib9" ref-type="bibr">Gog et al., 2014</xref>) that uses approximately <inline-formula><mml:math id="M257" altimg="si70.gif"><mml:mrow><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mtext>log</mml:mtext><mml:mfrac><mml:mi>n</mml:mi><mml:mi>m</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bits, where <italic>m</italic> is the number of bits set and <italic>n</italic> the length of the bitvector.</p>
        <p id="p0400">For counting, Raptor has to traverse the binning bitvector of size <italic>b</italic> and increment counters for each bit set to 1. To speed up this crucial step we used, for uncompressed bitvectors, the lzcount intrinsic operation which counts the number of leading zeros in a 64 bit word. This accelerated the bin counting step by a factor of almost 2 compared to the individual checking of each bit. A further speed up is possible once the AVX512 SIMD extensions are available on standard computers (already possible for Intel’s Skylake processor). These optimizations cannot be directly applied to compressed bitvectors.</p>
        <p id="p0405">Having the counts, we apply a thresholding according to the original <italic>k</italic>-mer counting lemma (<xref rid="bib13" ref-type="bibr">Jokinen and Ukkonen, 1991</xref>) or according to a probabilistic model for <inline-formula><mml:math id="M258" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers.</p>
        <sec id="sec5.3.4.1">
          <title>Lemma 1</title>
          <p id="p0410">For a given k and number of errors e, there are <inline-formula><mml:math id="M259" altimg="si71.gif"><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> many k-mers in p and an approximate occurrence of p in T has to share at least <inline-formula><mml:math id="M260" altimg="si72.gif"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>k</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">⋅</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> k-mers.</p>
          <p id="p0415">Hence, if the count exceeds the threshold for the bin, we report the pattern to occur in this bin, otherwise not. This approach is depicted in <xref rid="fig2" ref-type="fig">Figure 2</xref>. However, using minimizers makes the direct application of Lemma 1 impossible for <inline-formula><mml:math id="M261" altimg="si31.gif"><mml:mrow><mml:mi>w</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">&gt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. We present a solution in the next section.<fig id="fig2"><label>Figure 2</label><caption><p>Binning directory in conjunction with the <italic>k</italic>-mer Lemma</p><p>Bins with a counter greater than or equal to the threshold (in this case 4) need to be validated for <italic>p</italic>.</p></caption><graphic xlink:href="gr2"/></fig></p>
        </sec>
      </sec>
      <sec id="sec5.3.5">
        <title>Probabilistic thresholding</title>
        <p id="p0420">Lemma 1 works only for <inline-formula><mml:math id="M262" altimg="si73.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers. It does not hold for general <inline-formula><mml:math id="M263" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers. The latter is apparent since the <italic>number</italic> and <italic>distribution</italic> of <inline-formula><mml:math id="M264" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers is sequence dependent and hence leads to different thresholds for each read. This problem is exemplified in <xref rid="fig3" ref-type="fig">Figure 3</xref>. The examples show that an error does not only <italic>directly</italic> invalidate the minimizers covering the error position but also <italic>indirectly</italic> affects minimizers <italic>not</italic> covering the error position, resulting in a different count of minimizers.<fig id="fig3"><label>Figure 3</label><caption><p>Impact of an error on the number of <italic>k</italic>-mers</p><p>The sequences (A) and (B) represent the same sequence without and with an error at position 6 replacing a T with a G, respectively. The sequence in (A) has 3 minimizers, one of which (<italic>caca</italic>) is destroyed by the error position. Hence, we could assume that a sequence with one error at this position has a count of 2. However, introducing the error by replacing T with G has the effect that the first window now has a different minimizer not covering the error position (<italic>ggca</italic>) and hence (B) still has a minimizer count of 3. Thus, (A) and (B) would be wrongly deemed not matching with 1 error.</p></caption><graphic xlink:href="gr3"/></fig></p>
        <p id="p0425">Taking these indirectly destroyed minimizers into consideration, there are several ad hoc ways to compute the threshold. The first is to adapt Lemma 1 such that we compute the threshold as follows: For a given <italic>k</italic>, <italic>w</italic> and number of errors <italic>e</italic>, there are <inline-formula><mml:math id="M265" altimg="si74.gif"><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mspace width="0.25em"/><mml:mrow><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mspace width="0.25em"/><mml:mi>w</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> many windows in <italic>p</italic> and if we take the multiplicity of the minimizers into account, an approximate occurrence of <italic>p</italic> in <italic>T</italic> has to share at least <inline-formula><mml:math id="M266" altimg="si75.gif"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>w</mml:mi><mml:mo linebreak="badbreak">⋅</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> minimizers, i.e. we replace <italic>k</italic> with <italic>w</italic>. However, this leads to low thresholds. The threshold in <xref rid="fig3" ref-type="fig">Figure 3</xref>
<inline-formula><mml:math id="M267" altimg="si76.gif"><mml:mrow><mml:mi>a</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> would be negative, i.e. <inline-formula><mml:math id="M268" altimg="si77.gif"><mml:mrow><mml:mn>13</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>8</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>8</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, and thus useless for filtering.</p>
        <p id="p0430">Another way to compute an individual threshold is to repeat the following two steps for each error: 1) compute the minimizer coverage of a query <italic>p</italic> (counting each minimizer only once) 2) One maximum coverage position is chosen and the minimizers covering this position are removed. The overall number of removed minimizers is subtracted from the number of minimizers to obtain the threshold <italic>t</italic>. This works better than the first approach, but is time-consuming to compute.</p>
        <p id="p0435">We can show that a simple probabilistic model yields thresholds that are on average much better than the above ad-hoc methods and removes the need to compute an individual threshold for each read. For this, we proceed as follows. We refer to the size of the query as <italic>p</italic>, the size of the window in which we compute minimizers is denoted by <italic>w</italic>, and <italic>m</italic> is the number of minimizers in a query. As pointed out above, an error affects several minimizers depending on its position and the character that is replaced. Each error lowers the threshold of the counting lemma. We want to derive a probabilistic model that computes this threshold for a given <italic>p</italic> as good as possible with only <italic>w</italic>, <italic>k</italic>, and <italic>m</italic> as input. We aim at having an as high as possible threshold without missing too many hits (i.e. having false negatives).</p>
        <p id="p0440">For this, we use the following definitions:<list list-type="simple" id="ulist0015"><list-item id="u0030"><label>•</label><p id="p0445"><inline-formula><mml:math id="M269" altimg="si78.gif"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> : Random variable that is 1 if there is a minimizer starting at index <italic>i</italic>, <inline-formula><mml:math id="M270" altimg="si79.gif"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item id="u0035"><label>•</label><p id="p0450"><inline-formula><mml:math id="M271" altimg="si80.gif"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>: Random variable that indicates that <italic>n</italic> minimizers are affected by at least one error, <inline-formula><mml:math id="M272" altimg="si81.gif"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item id="u0040"><label>•</label><p id="p0455"><italic>τ</italic>: Probability threshold for the number of affected minimizers.</p></list-item></list></p>
      </sec>
      <sec id="sec5.3.6">
        <title>Index based model for one error</title>
        <p id="p0460">In order to define <inline-formula><mml:math id="M273" altimg="si82.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for one error, we need the distribution of <inline-formula><mml:math id="M274" altimg="si78.gif"><mml:mrow><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. In practice, assuming an uniform distribution of the minimizers in <inline-formula><mml:math id="M275" altimg="si83.gif"><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> yields good results:<disp-formula id="fd1"><label>(Equation 1)</label><mml:math id="M276" altimg="si84.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">=</mml:mo><mml:mfrac><mml:mtext>number of minimizer</mml:mtext><mml:mtext>number of indices</mml:mtext></mml:mfrac><mml:mo linebreak="goodbreak">=</mml:mo><mml:mfrac><mml:mi>m</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p>
        <p id="p0465">This can now be used to compute <inline-formula><mml:math id="M277" altimg="si82.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Let <italic>j</italic> be the position within a sequence where the error is located. Thus, it can affect at most <italic>k</italic> minimizers <italic>directly</italic>. The minimizers that are affected by the error at position <italic>j</italic> are the minimizers starting at indices <inline-formula><mml:math id="M278" altimg="si85.gif"><mml:mrow><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M279" altimg="si86.gif"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Naturally, these minimizers are the only ones that include the position <italic>j</italic>. Hence, there are at most <italic>k</italic> minimizers that include the position <italic>j</italic> and thereby there are at most <italic>k</italic> minimizers <italic>directly</italic> modified by the error. This can be expressed via a binomial distribution and yields:<disp-formula id="fd2"><label>(Equation 2)</label><mml:math id="M280" altimg="si87.gif"><mml:mrow><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="badbreak">∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>:</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo linebreak="newline">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mi>k</mml:mi></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mi>n</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>X</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mo linebreak="newline">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mi>k</mml:mi></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mi>n</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mi>m</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak">−</mml:mo><mml:mfrac><mml:mi>m</mml:mi><mml:mrow><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
        <p id="p0470"><inline-formula><mml:math id="M281" altimg="si82.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> can now be used to compute the new filtering threshold. Let <italic>d</italic> be the number of <inline-formula><mml:math id="M282" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers affected such that<disp-formula id="fd3"><label>(Equation 3)</label><mml:math id="M283" altimg="si88.gif"><mml:mrow><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>d</mml:mi></mml:munderover><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">&gt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>τ</mml:mi><mml:mtext> and </mml:mtext><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak">&lt;</mml:mo><mml:mspace width="0.25em"/><mml:mi>τ</mml:mi></mml:mrow></mml:math></disp-formula></p>
        <p id="p0475">Then the following lemma holds:</p>
        <sec id="sec5.3.6.1">
          <title>Lemma 2</title>
          <p id="p0480">For a given p, w, and k and one error, at most d many k-mers are affected with a probability of τ. Thus, an approximate occurrence of the query in T has to share at least <inline-formula><mml:math id="M284" altimg="si89.gif"><mml:mrow><mml:mi>t</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> k-mers with probability at least <inline-formula><mml:math id="M285" altimg="si90.gif"><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mi>τ</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
          <p id="p0485">This method enables us to use <italic>τ</italic> to control the false positive and false negative rates of our filter. The higher we choose <italic>τ</italic>, the more minimizers are affected, i.e. the threshold <italic>t</italic> decreases and the false positive rate increases. The lower we choose <italic>τ</italic>, the fewer minimizers are affected, i.e. the threshold increases <italic>t</italic> and the false negative rate decreases.</p>
          <p id="p0490">Furthermore, this model only depends on <italic>m</italic> which is known for each read. In order to obtain the threshold, we simply have to look it up in a precomputed table for the specific parameters or compute the table once if it has not been computed yet.</p>
        </sec>
      </sec>
      <sec id="sec5.3.7">
        <title>Extension for indirect errors</title>
        <p id="p0495">The previous model can be extended to account for errors affecting minimizers <italic>indirectly</italic>. The example in <xref rid="fig3" ref-type="fig">Figure 3</xref> shows that an error can affect a minimizer even though the error does not overlap with the minimizer.</p>
        <p id="p0500">We define the random variable <inline-formula><mml:math id="M286" altimg="si91.gif"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that is 1 if the error affects <italic>n k</italic>-mers indirectly. Thus, if we assume for simplification that the events of directly and indirectly affecting a minimizer are independent, <inline-formula><mml:math id="M287" altimg="si82.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> becomes:<disp-formula id="fd4"><label>(Equation 4)</label><mml:math id="M288" altimg="si92.gif"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="badbreak">∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>:</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"/></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mi>P</mml:mi><mml:mtext>′</mml:mtext></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mtext>with</mml:mtext></mml:mtd><mml:mtd columnalign="left"/></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mtext>′</mml:mtext></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="badbreak">=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mtext>′</mml:mtext></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext> if </mml:mtext><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="badbreak">&lt;</mml:mo><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mtext>else</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>where <inline-formula><mml:math id="M289" altimg="si93.gif"><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mtext>′</mml:mtext></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the distribution of the previous model.</p>
        <p id="p0505">The main challenge with this extension is the computation of <inline-formula><mml:math id="M290" altimg="si94.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We tried to find a tractable formulation of <inline-formula><mml:math id="M291" altimg="si91.gif"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, but did not succeed and leave this as an open problem. This is why we estimate <inline-formula><mml:math id="M292" altimg="si94.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in this work experimentally by sampling. We generate a query with and without an error and then check the number of minimizers that are indirectly modified by the error. This sampling method is flexible for different parameters and can be easily applied for the relevant range of parameters or be quickly computed on the fly. In our experiments, a sampling of <inline-formula><mml:math id="M293" altimg="si38.gif"><mml:mrow><mml:mn>10,000</mml:mn></mml:mrow></mml:math></inline-formula> cases lead to convergence of <inline-formula><mml:math id="M294" altimg="si94.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The thresholds are computed for <inline-formula><mml:math id="M295" altimg="si95.gif"><mml:mrow><mml:mi>τ</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>0.99</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec id="sec5.3.8">
        <title>Extension for multiple errors</title>
        <p id="p0510">We can further extend our model to consider multiple errors. For example, assume that there are 2 errors, <inline-formula><mml:math id="M296" altimg="si96.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M297" altimg="si97.gif"><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, that affect <inline-formula><mml:math id="M298" altimg="si98.gif"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M299" altimg="si99.gif"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> many <italic>k</italic>-mers, respectively. Thus, the two errors combined affect at most <inline-formula><mml:math id="M300" altimg="si100.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> many <italic>k</italic>-mers. Hence, affecting at most <italic>d</italic> many <italic>k</italic>-mers can be achieved by all different combinations of <inline-formula><mml:math id="M301" altimg="si101.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="M302" altimg="si102.gif"><mml:mrow><mml:mi>d</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M303" altimg="si103.gif"><mml:mrow><mml:mn>0</mml:mn><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M304" altimg="si104.gif"><mml:mrow><mml:mn>0</mml:mn><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p id="p0515">Generalizing this for <italic>e</italic> errors affecting <inline-formula><mml:math id="M305" altimg="si105.gif"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> minimizers leads to the following distribution:<disp-formula id="fd5"><label>(Equation 5)</label><mml:math id="M306" altimg="si106.gif"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>n</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="badbreak">∈</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo linebreak="badbreak">⋅</mml:mo><mml:mi>e</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo>:</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"/></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo linebreak="newline">=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo linebreak="badbreak">≤</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo linebreak="badbreak">≤</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo linebreak="badbreak">≤</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo linebreak="badbreak">≤</mml:mo><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo linebreak="badbreak">+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo linebreak="badbreak">+</mml:mo><mml:mo>…</mml:mo><mml:mo linebreak="badbreak">+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munderover><mml:munderover><mml:mrow><mml:mo>∏</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>e</mml:mi></mml:munderover><mml:msup><mml:mi>P</mml:mi><mml:mtext>′</mml:mtext></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:msub><mml:mi>d</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>with <inline-formula><mml:math id="M307" altimg="si93.gif"><mml:mrow><mml:msup><mml:mi>P</mml:mi><mml:mtext>′</mml:mtext></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>D</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> being the distribution of the previous model allowing for indirect errors.</p>
        <p id="p0520">We also developed more involved models to account for two errors being in close vicinity (not shown), however the rounded thresholds very seldomly change. Hence, we omit them.</p>
        <p id="p0525">In summary, the threshold for the counting lemma can be looked up in a table given the number of errors, the number of minimizers of a query, and the parameters <inline-formula><mml:math id="M308" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and hence the filtering speeds up considerably. The method models the occurrences of <inline-formula><mml:math id="M309" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>-minimizers within the windows and how they affect each other (see <xref rid="fig3" ref-type="fig">Figure 3</xref> for an example).</p>
      </sec>
      <sec id="sec5.3.9">
        <title><italic>x</italic>-partitioned IBF</title>
        <p id="p0530">Finally, we propose our last contribution, the use of an <italic>x</italic>-partitioned interleaved Bloom filter (<italic>x</italic>-PIBF) in binning directories, which are an extension of the IBF proposed in (<xref rid="bib8" ref-type="bibr">Dadi et al., 2018</xref>). An IBF for <italic>b</italic> bins combines <italic>b</italic> standard Bloom filters (<xref rid="bib4" ref-type="bibr">Bloom, 1970</xref>). A Bloom filter is simply a bitvector of size <italic>n</italic> and a set of <italic>h</italic> hash functions that map a value, in our case a representative <italic>k</italic>-mer, to one of the bit positions. A value is present in the Bloom filter if all <italic>h</italic> positions return a 1. Note that a Bloom filter can give a false positive answer. However, if the Bloom filter size is large enough, the probability of a false positive answer is low. A Bloom filter of size <italic>n</italic> bits with <italic>h</italic> different hash functions and <italic>m</italic> elements inserted has a probability of giving a false positive answer of approximately<disp-formula id="ufd1"><mml:math id="M310" altimg="si107.gif"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo linebreak="badbreak">=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak">−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="badbreak">−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo linebreak="badbreak">⋅</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mi>h</mml:mi></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p id="p0535">For this reason, we have to allocate sufficient space such that <inline-formula><mml:math id="M311" altimg="si108.gif"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> does not become too large. Still, the problem of using a simple Bloom filter is that it does not point us to the binning bitvectors. To alleviate the problem, the IBF uses <italic>b</italic> Bloom filters (one for each bin) with identical hash functions and then interleaves their bitvectors. Putting it differently, this means that it replaces each bit in the Bloom filter by a (sub)-bitvector of size <italic>b</italic>, where the <italic>i</italic>-th bit ”belongs” to the Bloom filter for bin <inline-formula><mml:math id="M312" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The resulting IBF has a size of <inline-formula><mml:math id="M313" altimg="si109.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. When inserting a <italic>k</italic>-mer from bin <inline-formula><mml:math id="M314" altimg="si57.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> into the IBF, it computes all <italic>h</italic> hash functions which point to the position of the block where the sub-bitvectors are and then sets the <italic>i</italic>-th bit from the respective beginnings. Hence, the IBF effectively interleaves <italic>b</italic> Bloom filters in a way that allows us to easily retrieve the binning bitvectors for the <italic>h</italic> hash functions. When querying in which bins a <italic>k</italic>-mer can be found, we retrieve the <italic>h</italic> sub-bitvectors and apply a logical AND to them which results in the required binning bitvector indicating the membership of the <italic>k</italic>-mer in the bins. The procedure is depicted in <xref rid="fig4" ref-type="fig">Figure 4</xref>.<fig id="fig4"><label>Figure 4</label><caption><p>Example of an IBF</p><p>Differently colored Bloom filters of length <italic>n</italic> for the <italic>b</italic> bins are shown in the top. The individual Bloom filters are interleaved to make an IBF of size <inline-formula><mml:math id="M315" altimg="si47.gif"><mml:mrow><mml:mi>b</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">×</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. In the example we retrieve 3 positions for a <italic>k</italic>-mer (ACGTACT) using 3 different hash functions. The corresponding sub-bitvectors are combined with a bitwise &amp; resulting in the needed binning bitvector.</p></caption><graphic xlink:href="gr4"/></fig></p>
        <p id="p0540">Finally, the binning bitvectors are summed up to obtain the count vectors. For this, we allocate <italic>t</italic> many counters, each with <italic>b</italic> entries, where <italic>t</italic> is the number of threads used. These counters are reused as we process the reads in parallel.</p>
        <p id="p0545">If the set of stored <italic>k</italic>-mers is very large or if we want to achieve a very low FPR of the IBF, it might be too big to keep in the main memory. For those cases we implemented the <italic>x</italic>-partitioned IBF (<italic>x</italic>-PIBF) where we partition the set of stored <italic>k</italic>-mers into <italic>x</italic> parts as follows:</p>
        <p id="p0550">For a <italic>x</italic>-PIBF of size <italic>s</italic> bits, we create <italic>x</italic> parts, each with <inline-formula><mml:math id="M316" altimg="si110.gif"><mml:mrow><mml:mo>[</mml:mo><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>x</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula> bits. Then we partition the <italic>k</italic>-mers based on the first <italic>q</italic> characters with <inline-formula><mml:math id="M317" altimg="si111.gif"><mml:mrow><mml:mi>q</mml:mi><mml:mspace width="0.25em"/><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:msub><mml:mtext>log</mml:mtext><mml:mi>σ</mml:mi></mml:msub><mml:mspace width="0.25em"/><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, where <italic>σ</italic> is the alphabet size. We count the <italic>q</italic>-mer frequencies of all <italic>k</italic>-mers and assign them as evenly as possible to the <italic>x</italic> parts (see below table for an example). The counting step can be omitted, in which case we assume a uniform prefix distribution.</p>
        <p id="p0555">Finally, we have to adapt our hash functions such that all <italic>h</italic> hash values for a <italic>k</italic>-mer lie in the same part of the <italic>x</italic>-PIBF. This can easily be done by storing offsets in a <inline-formula><mml:math id="M318" altimg="si112.gif"><mml:mrow><mml:msup><mml:mi>q</mml:mi><mml:mi>σ</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> large table and adding those to the hash values for an IBF of size <inline-formula><mml:math id="M319" altimg="si110.gif"><mml:mrow><mml:mo>[</mml:mo><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mi>x</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p id="p0560">If we query a set of <italic>k</italic>-mers, we load the first part of the <italic>x</italic>-PIBF into memory, stream over all <italic>k</italic>-mers counting the relevant ones for this part and ignoring the others. Then we repeat this for all other parts after loading them. In the Results section we report on the time/memory trade-off.</p>
      </sec>
      <sec id="sec5.3.10">
        <title>Compressing bitvectors</title>
        <p id="p0565">Binning directories use a large bitvector containing all the binning bitvectors for all representative <italic>k</italic>-mers. In this work we also allow the use of a compressed bitvector implementation from the SDSL (<xref rid="bib9" ref-type="bibr">Gog et al., 2014</xref>). While a standard bitvector of size <italic>n</italic> uses <italic>n</italic> bits, the compressed bitvector of the SDSL uses approximately <inline-formula><mml:math id="M320" altimg="si70.gif"><mml:mrow><mml:mi>m</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">⋅</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mo linebreak="badbreak">+</mml:mo><mml:mtext>log</mml:mtext><mml:mfrac><mml:mi>n</mml:mi><mml:mi>m</mml:mi></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bits, where <italic>m</italic> is the number of bits set, and <italic>n</italic> the length of the bitvector. Note that while this can reduce the space consumption for sparse bitvectors, it increases the access time which we will discuss in the experiments.</p>
        <p id="p0570">To construct a compressed bitvector, we first have to create the <italic>entire</italic> uncompressed bitvector and then compress it. This means that both the uncompressed and compressed bitvectors have to be in main memory at some point during construction which increases the memory footprint during construction while reducing the memory requirements when using the bitvector. A main property of the compressed bitvector is that it is immutable. If we want to change a bit after the vector is constructed, we need to change the bit in the uncompressed bitvector and reconstruct the compressed bitvector. Since decompression for the compressed bitvector is not supported by the SDSL, we also need to store the uncompressed bitvector on disk to enable future updates of the IBF. Nevertheless, we need to have the whole bitvector initially in memory which might pose a problem. This problem can be solved elegantly using the partitioning of the IBF as proposed before.</p>
      </sec>
    </sec>
    <sec id="sec5.4">
      <title>Quantification and statistical analysis</title>
      <p id="p0575">For the evaluation of our method, we use the notions of <italic>false negatives</italic> (FN) and <italic>false positives</italic> (FP). We examine reads originating from a known bin <italic>i</italic>. A false positive is a read that originated from bin <italic>i</italic> but was assigned to any bin <inline-formula><mml:math id="M321" altimg="si48.gif"><mml:mrow><mml:mi>j</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. If a read was assigned to multiple bins, it is likewise classified as false positive, as at least one of the reported bins must not be bin <italic>i</italic>. A false negative read is a read originating from bin <italic>i</italic> that was not assigned to bin <italic>i</italic>, independent of how many bins it was assigned to.</p>
    </sec>
  </sec>
</body>
<back>
  <ref-list id="cebib0010">
    <title>References</title>
    <ref id="bib1">
      <element-citation publication-type="other" id="sref1">
        <person-group person-group-type="author">
          <collab>All of Us (NIH)</collab>
        </person-group>
        <article-title>All of us research program overview</article-title>
        <ext-link ext-link-type="uri" xlink:href="https://allofus.nih.gov/about/all-us-research-program-overview" id="intref0110">https://allofus.nih.gov/about/all-us-research-program-overview</ext-link>
        <year>2020</year>
      </element-citation>
    </ref>
    <ref id="bib2">
      <element-citation publication-type="journal" id="sref2">
        <person-group person-group-type="author">
          <name>
            <surname>Berger</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>Computational solutions for omics data</article-title>
        <source>Nat. Rev.</source>
        <volume>14</volume>
        <year>2013</year>
        <fpage>333</fpage>
        <lpage>346</lpage>
      </element-citation>
    </ref>
    <ref id="bib3">
      <element-citation publication-type="book" id="sref3">
        <person-group person-group-type="author">
          <name>
            <surname>Bingmann</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Bradley</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Gauger</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <chapter-title>COBS: A compact bit-sliced signature index</chapter-title>
        <source>String Processing and Information Retrieval</source>
        <year>2019</year>
        <publisher-name>Springer</publisher-name>
        <fpage>285</fpage>
        <lpage>303</lpage>
      </element-citation>
    </ref>
    <ref id="bib4">
      <element-citation publication-type="journal" id="sref4">
        <person-group person-group-type="author">
          <name>
            <surname>Bloom</surname>
            <given-names>B.H.</given-names>
          </name>
        </person-group>
        <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>
        <source>Commun. ACM</source>
        <volume>13</volume>
        <year>1970</year>
        <fpage>422</fpage>
        <lpage>426</lpage>
        <pub-id pub-id-type="doi">10.1145/362686.362692</pub-id>
      </element-citation>
    </ref>
    <ref id="bib5">
      <element-citation publication-type="journal" id="sref5">
        <person-group person-group-type="author">
          <name>
            <surname>Bradley</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>den Bakker</surname>
            <given-names>H.C.</given-names>
          </name>
          <name>
            <surname>Rocha</surname>
            <given-names>E.P.C.</given-names>
          </name>
          <name>
            <surname>McVean</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast search of all deposited bacterial and viral genomic data</article-title>
        <source>Nat. Biotechnol.</source>
        <volume>37</volume>
        <year>2019</year>
        <fpage>152</fpage>
        <lpage>159</lpage>
        <pub-id pub-id-type="doi">10.1038/s41587-018-0010-1</pub-id>
        <pub-id pub-id-type="pmid">30718882</pub-id>
      </element-citation>
    </ref>
    <ref id="bib6">
      <element-citation publication-type="other" id="sref6">
        <person-group person-group-type="author">
          <name>
            <surname>Caulfield</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Davies</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Dennys</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Elbahy</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Fowler</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Hill</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Hubbard</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Jostins</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Maltby</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Mahon-Pearson</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>The National genomics research and healthcare knowledgebase</article-title>
        <ext-link ext-link-type="uri" xlink:href="https://figshare.com/articles/dataset/GenomicEnglandProtocol_pdf/4530893" id="intref0115">https://figshare.com/articles/dataset/GenomicEnglandProtocol_pdf/4530893</ext-link>
        <year>2019</year>
      </element-citation>
    </ref>
    <ref id="bib7">
      <element-citation publication-type="journal" id="sref7">
        <person-group person-group-type="author">
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Limasset</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <volume>32</volume>
        <year>2016</year>
        <fpage>i201</fpage>
        <lpage>i208</lpage>
      </element-citation>
    </ref>
    <ref id="bib8">
      <element-citation publication-type="journal" id="sref8">
        <person-group person-group-type="author">
          <name>
            <surname>Dadi</surname>
            <given-names>T.H.</given-names>
          </name>
          <name>
            <surname>Siragusa</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Piro</surname>
            <given-names>V.C.</given-names>
          </name>
          <name>
            <surname>Andrusch</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Seiler</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Renard</surname>
            <given-names>B.Y.</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>DREAM-Yara: an exact read mapper for very large databases with short update time</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <volume>34</volume>
        <year>2018</year>
        <fpage>766</fpage>
        <lpage>772</lpage>
      </element-citation>
    </ref>
    <ref id="bib9">
      <element-citation publication-type="book" id="sref9">
        <person-group person-group-type="author">
          <name>
            <surname>Gog</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Beller</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Moffat</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Petri</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <chapter-title>From theory to practice: Plug and play with succinct data structures</chapter-title>
        <source>13th International Symposium on Experimental Algorithms</source>
        <year>2014</year>
        <publisher-name>SEA</publisher-name>
        <fpage>326</fpage>
        <lpage>337</lpage>
      </element-citation>
    </ref>
    <ref id="bib10">
      <element-citation publication-type="journal" id="sref10">
        <person-group person-group-type="author">
          <name>
            <surname>Gupta</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Coleman</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Medini</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Mohan</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Shrivastava</surname>
            <given-names>A.</given-names>
          </name>
        </person-group>
        <article-title>RAMBO: Repeated and Merged Bloom filter for multiple set membership testing (MSMT) in sub-linear time</article-title>
        <source>arXiv</source>
        <year>2019</year>
        <fpage>1</fpage>
        <lpage>14</lpage>
        <comment>arXiv:1910.02611</comment>
        <ext-link ext-link-type="uri" xlink:href="http://arxiv.org/abs/1910.02611" id="intref0120">http://arxiv.org/abs/1910.02611</ext-link>
      </element-citation>
    </ref>
    <ref id="bib11">
      <element-citation publication-type="other" id="sref11">
        <person-group person-group-type="author">
          <name>
            <surname>Holtgrewe</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Mason – a read simulator for second generation sequencing data. Technical Report FU Berlin</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://publications.imp.fu-berlin.de/962/" id="intref0125">http://publications.imp.fu-berlin.de/962/</ext-link>
        <year>2010</year>
      </element-citation>
    </ref>
    <ref id="bib12">
      <element-citation publication-type="journal" id="sref12">
        <person-group person-group-type="author">
          <collab>International Human Genome Sequencing Consortium</collab>
        </person-group>
        <article-title>Initial sequencing and analysis of the human genome</article-title>
        <source>Nature</source>
        <volume>409</volume>
        <year>2001</year>
        <fpage>860</fpage>
        <lpage>921</lpage>
        <pub-id pub-id-type="pmid">11237011</pub-id>
      </element-citation>
    </ref>
    <ref id="bib13">
      <element-citation publication-type="journal" id="sref13">
        <person-group person-group-type="author">
          <name>
            <surname>Jokinen</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Two algorithms for approximate string matching in static texts</article-title>
        <source>Lecture Notes Comp. Sci.</source>
        <volume>520</volume>
        <year>1991</year>
        <fpage>240</fpage>
        <lpage>248</lpage>
      </element-citation>
    </ref>
    <ref id="bib14">
      <element-citation publication-type="journal" id="sref14">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Song</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Breitwieser</surname>
            <given-names>F.P.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Centrifuge: rapid and sensitive classification of metagenomic sequences</article-title>
        <source>Genome Res.</source>
        <volume>26</volume>
        <year>2016</year>
        <fpage>1721</fpage>
        <lpage>1729</lpage>
        <pub-id pub-id-type="pmid">27852649</pub-id>
      </element-citation>
    </ref>
    <ref id="bib15">
      <element-citation publication-type="journal" id="sref15">
        <person-group person-group-type="author">
          <name>
            <surname>Marçais</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Pellow</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Orenstein</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Shamir</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Improving the performance of minimizers and winnowing schemes</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <volume>33</volume>
        <year>2017</year>
        <fpage>i110</fpage>
        <lpage>i117</lpage>
      </element-citation>
    </ref>
    <ref id="bib16">
      <element-citation publication-type="journal" id="sref16">
        <person-group person-group-type="author">
          <name>
            <surname>Marchet</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Puglisi</surname>
            <given-names>S.J.</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Salson</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Data structures based on k-mers for querying large collections of sequencing datasets</article-title>
        <source>bioRxiv</source>
        <year>2019</year>
        <pub-id pub-id-type="doi">10.1101/866756</pub-id>
      </element-citation>
    </ref>
    <ref id="bib17">
      <element-citation publication-type="journal" id="sref17">
        <person-group person-group-type="author">
          <name>
            <surname>Marchet</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Gautheret</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Salson</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>REINDEER: efficient indexing of k-mer presence and abundance in sequencing datasets</article-title>
        <source>bioRxiv</source>
        <year>2020</year>
        <pub-id pub-id-type="doi">10.1101/2020.03.29.014159</pub-id>
      </element-citation>
    </ref>
    <ref id="bib18">
      <element-citation publication-type="journal" id="sref18">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Almodaresi</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Bender</surname>
            <given-names>M.A.</given-names>
          </name>
          <name>
            <surname>Ferdman</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Johnson</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Patro</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Mantis: a fast, small, and exact large-scale sequence-search index</article-title>
        <source>Cell Syst.</source>
        <volume>7</volume>
        <year>2018</year>
        <fpage>201</fpage>
        <lpage>207.e4</lpage>
        <pub-id pub-id-type="pmid">29936185</pub-id>
      </element-citation>
    </ref>
    <ref id="bib19">
      <element-citation publication-type="journal" id="sref19">
        <person-group person-group-type="author">
          <name>
            <surname>Piro</surname>
            <given-names>V.C.</given-names>
          </name>
          <name>
            <surname>Dadi</surname>
            <given-names>T.H.</given-names>
          </name>
          <name>
            <surname>Seiler</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Renard</surname>
            <given-names>B.Y.</given-names>
          </name>
        </person-group>
        <article-title>ganon: precise metagenomics classification against large and up-to-date sets of reference sequences</article-title>
        <source>Bioinformatics (Oxford, England)</source>
        <volume>36</volume>
        <year>2020</year>
        <fpage>i12</fpage>
        <lpage>i20</lpage>
      </element-citation>
    </ref>
    <ref id="bib20">
      <element-citation publication-type="journal" id="sref20">
        <person-group person-group-type="author">
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Dadi</surname>
            <given-names>T.H.</given-names>
          </name>
          <name>
            <surname>Ehrhardt</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Hauswedell</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Mehringer</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Rahn</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Pockrandt</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Winkler</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Siragusa</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>The SeqAn C++ template library for efficient sequence analysis: a resource for programmers</article-title>
        <source>J. Biotechnol.</source>
        <volume>261</volume>
        <year>2017</year>
        <fpage>157</fpage>
        <lpage>168</lpage>
        <pub-id pub-id-type="pmid">28888961</pub-id>
      </element-citation>
    </ref>
    <ref id="bib21">
      <element-citation publication-type="journal" id="sref21">
        <person-group person-group-type="author">
          <name>
            <surname>Solomon</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C.</given-names>
          </name>
        </person-group>
        <article-title>Fast search of thousands of short-read sequencing experiments</article-title>
        <source>Nat. Biotechnol.</source>
        <volume>34</volume>
        <year>2016</year>
        <fpage>300</fpage>
        <lpage>302</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.nature.com/nbt/journal/v34/n3/full/nbt.3442.html" id="intref0130">http://www.nature.com/nbt/journal/v34/n3/full/nbt.3442.html</ext-link>
        <pub-id pub-id-type="pmid">26854477</pub-id>
      </element-citation>
    </ref>
    <ref id="bib22">
      <element-citation publication-type="book" id="sref22">
        <person-group person-group-type="author">
          <name>
            <surname>Sun</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Harris</surname>
            <given-names>R.S.</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Medvedev</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <chapter-title>AllSome sequence Bloom trees</chapter-title>
        <source>Research in Computational Molecular Biology</source>
        <year>2017</year>
        <publisher-name>Springer</publisher-name>
        <fpage>272</fpage>
        <lpage>286</lpage>
      </element-citation>
    </ref>
    <ref id="bib23">
      <element-citation publication-type="journal" id="sref23">
        <person-group person-group-type="author">
          <name>
            <surname>Venter</surname>
            <given-names>J.C.</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>X.</given-names>
          </name>
        </person-group>
        <article-title>The sequence of the human genome</article-title>
        <source>Science</source>
        <volume>291</volume>
        <year>2001</year>
        <fpage>1304</fpage>
        <lpage>1351</lpage>
        <pub-id pub-id-type="pmid">11181995</pub-id>
      </element-citation>
    </ref>
    <ref id="bib24">
      <element-citation publication-type="journal" id="sref24">
        <person-group person-group-type="author">
          <name>
            <surname>Wood</surname>
            <given-names>D.E.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Kraken: ultrafast metagenomic sequence classification using exact alignments</article-title>
        <source>Genome Biol.</source>
        <volume>15</volume>
        <year>2014</year>
        <fpage>R46</fpage>
        <pub-id pub-id-type="pmid">24580807</pub-id>
      </element-citation>
    </ref>
  </ref-list>
  <ack id="ack0010">
    <title>Acknowledgments</title>
    <p id="p0580">The authors acknowledge the support of the de.NBI network for bioinformatics infrastructure, the Intel SeqAn IPCC, the <funding-source id="gs1"><institution-wrap><institution-id institution-id-type="doi">10.13039/501100004189</institution-id><institution>Max Planck Society</institution></institution-wrap></funding-source> and the IMPRS for Biology and Computation (BAC).</p>
    <sec id="sec6">
      <title>Author contributions</title>
      <p id="p0585">E.S. designed and wrote the software and conducted the experiments on the artificial data set. S.M. designed the software. M.D. contributed to the software and analyzed the real data set. E.T. provided the probabilistic method to determine the minimizer threshold. K.R. designed the study and was a major contributor in writing the manuscript. All authors read and approved the final manuscript.</p>
    </sec>
    <sec sec-type="COI-statement" id="sec7">
      <title>Declaration of interests</title>
      <p id="p0590">The authors declare no competing interests.</p>
    </sec>
  </ack>
</back>
