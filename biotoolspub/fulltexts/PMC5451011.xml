<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5451011</article-id>
    <article-id pub-id-type="pmid">28562641</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-16-38246</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0177569</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Peptides</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Database and Informatics Methods</subject>
          <subj-group>
            <subject>Biological Databases</subject>
            <subj-group>
              <subject>Proteomic Databases</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Proteomics</subject>
            <subj-group>
              <subject>Proteomic Databases</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Applied Mathematics</subject>
            <subj-group>
              <subject>Algorithms</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Simulation and Modeling</subject>
          <subj-group>
            <subject>Algorithms</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Biomarkers</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Information Technology</subject>
          <subj-group>
            <subject>Data Processing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Database and Informatics Methods</subject>
          <subj-group>
            <subject>Database Searching</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Molecular Biology</subject>
          <subj-group>
            <subject>Macromolecular Structure Analysis</subject>
            <subj-group>
              <subject>Protein Structure</subject>
              <subj-group>
                <subject>Protein Structure Comparison</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Proteins</subject>
            <subj-group>
              <subject>Protein Structure</subject>
              <subj-group>
                <subject>Protein Structure Comparison</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Proteins</subject>
            <subj-group>
              <subject>Plasma Proteins</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PGCA: An algorithm to link protein groups created from MS/MS data</article-title>
      <alt-title alt-title-type="running-head">PGCA</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Kepplinger</surname>
          <given-names>David</given-names>
        </name>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Takhar</surname>
          <given-names>Mandeep</given-names>
        </name>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sasaki</surname>
          <given-names>Mayu</given-names>
        </name>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hollander</surname>
          <given-names>Zsuzsanna</given-names>
        </name>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Smith</surname>
          <given-names>Derek</given-names>
        </name>
        <xref ref-type="aff" rid="aff003">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>McManus</surname>
          <given-names>Bruce</given-names>
        </name>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>McMaster</surname>
          <given-names>W. Robert</given-names>
        </name>
        <xref ref-type="aff" rid="aff004">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ng</surname>
          <given-names>Raymond T.</given-names>
        </name>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="aff005">
          <sup>5</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Cohen Freue</surname>
          <given-names>Gabriela V.</given-names>
        </name>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>Department of Statistics, University of British Columbia, Vancouver, British Columbia, Canada</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>NCE CECR PROOF Centre of Excellence, Vancouver, British Columbia, Canada</addr-line>
    </aff>
    <aff id="aff003">
      <label>3</label>
      <addr-line>University of Victoria - Genome BC Proteomics Centre, Victoria, British Columbia, Canada</addr-line>
    </aff>
    <aff id="aff004">
      <label>4</label>
      <addr-line>Department of Medical Genetics, University of British Columbia, Vancouver, British Columbia, Canada</addr-line>
    </aff>
    <aff id="aff005">
      <label>5</label>
      <addr-line>Department of Computer Science, University of British Columbia, Vancouver, British Columbia, Canada</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Mischak</surname>
          <given-names>Harald</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>University of Glasgow, UNITED KINGDOM</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <fn fn-type="con">
        <p>
          <list list-type="simple">
            <list-item>
              <p><bold>Conceptualization:</bold> GCF WRM BM RTN.</p>
            </list-item>
            <list-item>
              <p><bold>Data curation:</bold> MT MS ZH RTN DK DS.</p>
            </list-item>
            <list-item>
              <p><bold>Formal analysis:</bold> MT ZH DK GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Investigation:</bold> MT MS ZH DK WRM BM RTN GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Methodology:</bold> RTN GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Project administration:</bold> GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Resources:</bold> MS DS WBM BM RTN.</p>
            </list-item>
            <list-item>
              <p><bold>Software:</bold> MT DK GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Supervision:</bold> RTN GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Validation:</bold> MT MS ZH GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Visualization:</bold> ZH DK GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Writing – original draft:</bold> RTN GCF.</p>
            </list-item>
            <list-item>
              <p><bold>Writing – review &amp; editing:</bold> MT MS ZH DK WRM BM RTN GCF.</p>
            </list-item>
          </list>
        </p>
      </fn>
      <corresp id="cor001">* E-mail: <email>gcohen@stat.ubc.ca</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>31</day>
      <month>5</month>
      <year>2017</year>
    </pub-date>
    <volume>12</volume>
    <issue>5</issue>
    <elocation-id>e0177569</elocation-id>
    <history>
      <date date-type="received">
        <day>23</day>
        <month>9</month>
        <year>2016</year>
      </date>
      <date date-type="accepted">
        <day>28</day>
        <month>4</month>
        <year>2017</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2017 Kepplinger et al</copyright-statement>
      <copyright-year>2017</copyright-year>
      <copyright-holder>Kepplinger et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0177569.pdf"/>
    <abstract>
      <p>The quantitation of proteins using shotgun proteomics has gained popularity in the last decades, simplifying sample handling procedures, removing extensive protein separation steps and achieving a relatively high throughput readout. The process starts with the digestion of the protein mixture into peptides, which are then separated by liquid chromatography and sequenced by tandem mass spectrometry (MS/MS). At the end of the workflow, recovering the identity of the proteins originally present in the sample is often a difficult and ambiguous process, because more than one protein identifier may match a set of peptides identified from the MS/MS spectra. To address this identification problem, many MS/MS data processing software tools combine all plausible protein identifiers matching a common set of peptides into a protein group. However, this solution introduces new challenges in studies with multiple experimental runs, which can be characterized by three main factors: <italic>i)</italic> protein groups’ identifiers are local, i.e., they vary run to run, <italic>ii)</italic> the composition of each group may change across runs, and <italic>iii)</italic> the supporting evidence of proteins within each group may also change across runs. Since in general there is no conclusive evidence about the absence of proteins in the groups, protein groups need to be linked across different runs in subsequent statistical analyses. We propose an algorithm, called Protein Group Code Algorithm (PGCA), to link groups from multiple experimental runs by forming global protein groups from connected local groups. The algorithm is computationally inexpensive and enables the connection and analysis of lists of protein groups across runs needed in biomarkers studies. We illustrate the identification problem and the stability of the PGCA mapping using 65 iTRAQ experimental runs. Further, we use two biomarker studies to show how PGCA enables the discovery of relevant candidate protein group markers with similar but non-identical compositions in different runs.</p>
    </abstract>
    <funding-group>
      <funding-statement>The author(s) received no specific funding for this work.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="6"/>
      <table-count count="0"/>
      <page-count count="19"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>All BiT data is now available as Supporting Information files. Jain Foundation’s full data resource is confidential. Only protein identifications, relevant for this study, are submitted as Supporting Information files.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>All BiT data is now available as Supporting Information files. Jain Foundation’s full data resource is confidential. Only protein identifications, relevant for this study, are submitted as Supporting Information files.</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>Shotgun proteomic techniques have gained popularity in the last decades allowing a global and relatively high throughput identification and quantitation of proteins in complex samples such as plasma or total cell/tissue extracts [<xref rid="pone.0177569.ref001" ref-type="bibr">1</xref>, <xref rid="pone.0177569.ref002" ref-type="bibr">2</xref>]. The appealing peptide-centric nature of shotgun proteomics simplifies sample preparation procedures and does not require extensive protein separation steps as in previous technologies [<xref rid="pone.0177569.ref003" ref-type="bibr">3</xref>]. In a typical experimental workflow the protein mixture is first digested into peptides, which are then separated by liquid chromatography and sequenced by tandem mass spectrometry (MS/MS). The resulting peptide’s fragmentation mass spectra is then used to recover the identity of the proteins originally present in the sample by searching against a sequence database with available software. This process can be decomposed into two main steps. First, the set of peptides resulting from proteolytic digestion of proteins needs to be identified from the MS/MS fragmentation data. Many algorithms have been proposed to match the observed spectra to peptide sequences, including SEQUEST [<xref rid="pone.0177569.ref004" ref-type="bibr">4</xref>], MASCOT [<xref rid="pone.0177569.ref005" ref-type="bibr">5</xref>], X!TANDEM [<xref rid="pone.0177569.ref006" ref-type="bibr">6</xref>], and hEIDI [<xref rid="pone.0177569.ref007" ref-type="bibr">7</xref>] (a comprehensive review of these and other methods can be found in the literature [<xref rid="pone.0177569.ref008" ref-type="bibr">8</xref>–<xref rid="pone.0177569.ref010" ref-type="bibr">10</xref>]). Second, the set of proteins present in the sample before digestion needs to be recovered from the list of identified peptides. Since the same peptide sequences can be present in multiple proteins, the link between proteins originally present in the sample and proteins identified from observed peptides is often lost. Overall, the process of recovering the identities of the original proteins from the observed MS/MS spectra is complex and in most cases ambiguous, adding an important challenge to the analysis and interpretation of the data [<xref rid="pone.0177569.ref003" ref-type="bibr">3</xref>, <xref rid="pone.0177569.ref008" ref-type="bibr">8</xref>, <xref rid="pone.0177569.ref011" ref-type="bibr">11</xref>].</p>
    <p>Many software tools have been developed to process MS/MS data addressing the protein identification problem, such as ProteinPilot<sup>™</sup> [<xref rid="pone.0177569.ref012" ref-type="bibr">12</xref>], ProteinProphet [<xref rid="pone.0177569.ref013" ref-type="bibr">13</xref>], Scaffold [<xref rid="pone.0177569.ref014" ref-type="bibr">14</xref>], ProteinLP [<xref rid="pone.0177569.ref010" ref-type="bibr">10</xref>], ProteinLASSO [<xref rid="pone.0177569.ref009" ref-type="bibr">9</xref>], TRIC [<xref rid="pone.0177569.ref015" ref-type="bibr">15</xref>], DBParser [<xref rid="pone.0177569.ref016" ref-type="bibr">16</xref>], and X!TandemPipeline [<xref rid="pone.0177569.ref017" ref-type="bibr">17</xref>]. Although the organization of the results varies among these tools, most of them combine the set of all plausible protein identifiers matching a common set of peptides into a protein group. In accordance with the Molecular &amp; Cellular Proteomics publication guidelines [<xref rid="pone.0177569.ref018" ref-type="bibr">18</xref>], this strategy results in a minimal list of non-redundant protein groups sufficient to explain all observed peptides.</p>
    <p><xref ref-type="fig" rid="pone.0177569.g001">Fig 1</xref> illustrates the challenge of identifying proteins from the lists of observed peptides with an example from two experimental runs from iTRAQ (isobaric tags for relative and absolute quantitation). For both runs, the raw MS/MS data was processed using ProteinPilot<sup>™</sup> software v4.0 with the integrated Paragon<sup>™</sup> Search and ProGroup<sup>™</sup> algorithms [<xref rid="pone.0177569.ref018" ref-type="bibr">18</xref>] and searching against UniProtKB database (October 2014 release). <xref ref-type="fig" rid="pone.0177569.g001">Fig 1A</xref> shows part of the protein summary files for one protein group identified differently in 2 experimental runs (Exp). Within each experiment, ProteinPilot organizes the set of proteins matching the identified peptide list into a group (N represents the local group identifier). <xref ref-type="fig" rid="pone.0177569.g001">Fig 1B</xref> shows the aligned amino acid sequences of the proteins identified in these experiments and highlights the peptides identified within each run using different colors and bold fonts (black = identified in both experiments; green = identified only in experiment 1; blue = identified only in experiment 2).</p>
    <fig id="pone.0177569.g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0177569.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>Exemplary challenge in protein identification.</title>
        <p>(A) A glance at a protein group identified by ProteinPilot in 2 iTRAQ experiments (Exp). Top proteins within each group are shown in bold colour fonts (green fonts for experiment 1 and blue for experiment 2). (B) Coverage maps of the identified protein sequences (aligned with Clustal Omega v1.2.2) with the list of peptides used for identification in bold font. Peptides identified in both experiments are highlighted using black fonts. Peptides identified only in experiment 1 are highlighted in green, and those identified only in experiment 2 are identified in blue fonts.</p>
      </caption>
      <graphic xlink:href="pone.0177569.g001"/>
    </fig>
    <p>Protein groups with more than one identifier contain, in general, proteins with a high degree of sequence similarity, including multiple entries for one gene product, and isoforms or multiple members of a protein family. Some tools assign a probability or a score to each protein in the group estimating the likelihood that the corresponding protein was present in the sample (see [<xref rid="pone.0177569.ref003" ref-type="bibr">3</xref>, <xref rid="pone.0177569.ref008" ref-type="bibr">8</xref>] for a review). In most cases, a “winner” (or top-) protein identity is selected to represent each group and it is placed at the top in the protein summary file. For example, in the first experiment of <xref ref-type="fig" rid="pone.0177569.g001">Fig 1</xref>, both Isoform Gamma-A of Fibrinogen gamma chain (P02679-2) and Fibrinogen gamma chain (P02679) are returned as a group of proteins based on the set of identified peptides (bold black and green in <xref ref-type="fig" rid="pone.0177569.g001">Fig 1B</xref>), and Isoform Gamma-A of Fibrinogen gamma chain is selected as the top-protein to represent the group with all quantitative values assigned to it (Exp 1, <xref ref-type="fig" rid="pone.0177569.g001">Fig 1A</xref>). In the second experiment, the detection of the peptide QVRPEHPAETEYDSLYPEDDL belonging only to Fibrinogen gamma chain (in blue at the end of P02679 sequence in <xref ref-type="fig" rid="pone.0177569.g001">Fig 1B</xref>) resulted in the unique identification of this protein identification in the group (Exp 2, <xref ref-type="fig" rid="pone.0177569.g001">Fig 1A</xref>).</p>
    <p>In a typical proteomics workflow, the MS/MS data from each experimental run is processed one at a time to identify and quantify the proteins present in each sample or set of samples included in the run. In many studies, multiple runs are required to analyze all the samples. The previous example depicts the challenge of comparing protein levels among different experiments when protein groups, instead of unique protein identifiers, are used to report protein abundances. The most naïve approach to compare protein groups from different experiments is to rely on the top-protein selected by the processing software within each run. Although in some groups the presence of the top-protein is supported by the detection of unique peptides belonging to it, there are many groups containing indistinguishable protein identifications since all the identified peptides belong to the overlapping regions of the protein sequences [<xref rid="pone.0177569.ref003" ref-type="bibr">3</xref>]. In the example shown in <xref ref-type="fig" rid="pone.0177569.g001">Fig 1</xref>, both proteins in experiment 1 could have been present in the original sample but using only the top-protein to link this group across experiments will treat Fibrinogen gamma chain (P02679) as non-detected in this experiment.</p>
    <p>In general, the identification problem in a multi-experiment setting can be characterized by three main factors: <italic>i)</italic> each protein group has only a local identifier per experimental run (i.e., protein groups identifiers vary run to run), <italic>ii)</italic> the composition of each group may change across runs, and <italic>iii)</italic> the supporting evidence of proteins within each group may also change across runs. For example, the local protein groups in <xref ref-type="fig" rid="pone.0177569.g001">Fig 1</xref> have different IDs in each run (N) and contain two proteins in experiment 1 versus one protein in experiment 2. Still, these two groups are highly related and can be compared quantitatively in a subsequent analysis. While an independent technical validation or a manual inspection of the groups is required to determine which protein(s) from each group was(were) originally present in the sample, such validation will be rarely done on the full lists of groups [<xref rid="pone.0177569.ref008" ref-type="bibr">8</xref>]. Thus, an alternative solution to select and link the information contained in groups from multiple experiments is required to enable a subsequent statistical analysis.</p>
    <p>In this paper, we propose a computationally inexpensive algorithm, called Protein Group Code Algorithm (PGCA), to merge protein summaries from multiple experimental quantitative proteomics data. The goal of PGCA is to enable the analysis of quantitative data available for protein groups instead of unique protein identifiers. Although this strategy does not directly address the protein inference problem that resulted in the identification of protein groups, it enables the user to maintain the information available in the groups for subsequent analyses. PGCA creates a mapping (or dictionary) of local into global protein groups and assigns a protein group code (PGC) to each global group in the resulting list. The global PGC can then be used to link lists of protein groups across different experimental runs. We use three datasets to characterize the problem, to examine in detail the mapping created by PGCA, as well as to carefully evaluate the impact of its application in two biomarker studies.</p>
  </sec>
  <sec id="sec002">
    <title>Results and discussion</title>
    <p>In this section we describe the algorithm we developed to merge proteomic data files containing protein groups that resulted from processing MS/MS data. We then use the algorithm to characterize the composition of typical protein summaries containing groups of protein identifications and evaluate the reproducibility of the groups among multiple experimental runs. Further, we illustrate how the protein inference problem may impact on a subsequent statistical analysis. Finally, we demonstrate two useful properties of PGCA: the proposed method is order invariant (i.e., the results do not depend on the order that files are processed) and incremental (i.e., new files can be added to existing dictionaries). Technical details about the datasets used and the algorithm are presented Materials and methods.</p>
    <sec id="sec003">
      <title>PGCA: The protein group code algorithm</title>
      <p>PGCA can be decomposed into three algorithms: <bold>CreateLocalGroups</bold>, <bold>UpdateDictionary</bold>, and <bold>CodingProteinGroups</bold>.</p>
      <p><bold>CreateLocalGroups</bold> algorithm creates a set of <italic>local</italic> or intra-experimental protein groups (LocalGroupSet) from the protein groups available within each input file. Examples of local protein groups include the top-protein of a group, the set of proteins matching to the top gene, or the whole protein group. We can think of this step as a potential refinement of the groups created from MS/MS data to determine the amount of information contained in each group that will be kept for comparisons across multiple runs.</p>
      <p><xref ref-type="fig" rid="pone.0177569.g002">Fig 2</xref> shows an example of local groups created from three input files. In this example, the local groups are identical to those created by ProteinPilot. The first two files illustrate how the same 3 protein identifiers are organized differently in these two files (i.e., 2 local groups in the first file and 1 local group in the second one). The last file shows how new protein identifiers may be added to existing groups.</p>
      <fig id="pone.0177569.g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0177569.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Protein group example.</title>
          <p>The top panel shows parts of three protein summaries from dataset B that are processed in consecutive order (input files) to construct a dictionary. Bold fonts are used to highlight the top protein in each group as reported by ProteinPilot. The second panel shows the local groups created by CreateLocalGroups algorithm within each file. The third panel shows the global groups created by the UpdateDictionary algorithm. Dotted lines are used to show the global groups of the previous step. The last panel shows the corresponding dictionaries, created by the UpdateDictionary algorithm, as files are being processed. The alignment of IPI00215894.1 (UniProt P01042-2), IPI00797833.3 (almost identical to UniProt P01042-2), and IPI00032328.2 (UniProt P01042-1) are given in <xref ref-type="supplementary-material" rid="pone.0177569.s001">S1 Fig</xref>.</p>
        </caption>
        <graphic xlink:href="pone.0177569.g002"/>
      </fig>
      <p><bold>UpdateDictionary</bold> merges sets of local protein groups from different experimental runs creating a set of <italic>global</italic> or inter-experimental protein groups (GlobalGroupSet). Each global protein group is built from the union of connected local groups across multiple runs. A protein group code (PGC) is then assigned to each global group creating a mapping or dictionary.</p>
      <p><xref ref-type="fig" rid="pone.0177569.g002">Fig 2</xref> shows the global group created from the three local groups in the previous example. In the first step, there are two global groups, identical to the local ones, one with 2 proteins and the other one with a single protein. Since the 3 proteins in these global groups appear as a single group in the local group from the second file, PGCA forms a unique global group after processing the second file, with a unique protein group code in the updated dictionary <italic>D</italic><sub>2</sub>. In the third step, a new protein is added to one of the local groups, and thus to the existing global group. The last panel shows the corresponding dictionaries, created by the UpdateDictionary algorithm, as files are being processed.</p>
      <p><bold>CodingProteinGroups</bold> uses the created dictionary to translate protein identities into protein group codes (PGC) within each protein summary. The assigned PGCs can be used to link the groups across different experimental runs and analyze the quantitative value of each group across experiments.</p>
      <p>Continuing with the previous example, after processing all 3 files, a new column is added to each file in the top panel with the resulting PGC, e.g., PGC 20 in this example.</p>
      <p>PGCA offers three different approaches enabling the user to tune the degree of similarity among linked protein groups: <italic>i)</italic>
<bold>PGCA-All</bold> links the raw protein groups identified within each experimental run, <italic>ii)</italic>
<bold>PGCA-topGene</bold> links subsets of proteins matching to the gene of the top protein, and <italic>iii)</italic>
<bold>PGCA-topIdentifier</bold> links groups by their top-proteins across different experimental runs. This last option was included in the algorithm for completion. However, we note that there are different ways of doing this without <bold>PGCA</bold> and that the <bold>UpdateDictionary</bold> step becomes trivial in this case since all local groups are singletons.</p>
      <p><xref ref-type="fig" rid="pone.0177569.g003">Fig 3</xref> illustrates the difference between these approaches using 3 input files. The local groups created by PGCA-All contain all identified proteins within each file. Since none of the proteins in the first file (EXP01) match to the top-gene (PKM2), the local group created by PGCA-topGenes for this file contains only the top protein (Q504U3). In the other two files, all proteins match to the same gene (PKM), thus the local groups created by PGCA-All and PGCA-topGenes are identical. The local groups of PGCA-topIdentifier retain only the top protein within each group. After processing all three files, PGCA-All creates a unique global group with all related proteins; PGCA-topGene creates two global groups since proteins in those groups do not match the same gene; and PGCA-topIdentifier creates three distinct groups since a different master protein was assigned by Proteome Discoverer within each file.</p>
      <fig id="pone.0177569.g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0177569.g003</object-id>
        <label>Fig 3</label>
        <caption>
          <title>PGCA-All, PGCA-topGene, and PGCA-topIdentifier.</title>
          <p>(A) The first column shows parts of three protein summaries from dataset C that are processed in consecutive order (input files) to construct a dictionary (<italic>D</italic><sub>3</sub>) using different PGCA approaches. Bold fonts are used to highlight the top protein in each group as reported by Proteome Discoverer. The next 3 columns show the local groups (green sets) and the global groups (red sets) created by PGCA-All, PGCA-topGene, and PGCA-topIdentifier, respectively, as files are being processed. (B) Dictionaries created by each approach after processing the three input files. The alignment of the four proteins are given in <xref ref-type="supplementary-material" rid="pone.0177569.s002">S2 Fig</xref>.</p>
        </caption>
        <graphic xlink:href="pone.0177569.g003"/>
      </fig>
      <p>Although some of the groups change their composition and/or ordering of the proteins, in general they contain some common proteins that allow the connection of the detected groups through all runs. PGCA-All assigns a unique and common protein group code (PGC) to all connected proteins, which can then be used to link and analyze this group across runs. Noteworthy, the statistical analysis of some groups can be lost if only the top-identifier is used to link the identified groups across runs. In the example illustrated in <xref ref-type="fig" rid="pone.0177569.g003">Fig 3</xref>, different proteins are chosen to represent the group within each run, thus this protein group can not be compared among samples. Different criteria on linking groups from multiple runs can have an important impact in a subsequence statistical analysis.</p>
    </sec>
    <sec id="sec004">
      <title>Variation in protein identification</title>
      <p>Dataset A consists of 4 lists of protein groups generated by ProteinPilot from 4 iTRAQ experiments used to process technical replicates of a pool of plasma from healthy individuals (see <xref ref-type="sec" rid="sec010">Materials and methods</xref> and <xref ref-type="supplementary-material" rid="pone.0177569.s004">S1 File</xref>). Ideally, the 4 lists of protein identifications from each of these experiments should be identical since technical replicates of the same sample were processed in all runs. However, in practice this is not the case due to different sources of variation, including sample preparation, separation, and mass spectrometer detection. On average, 193 protein groups were identified per experimental run, with almost half of them containing a single protein identifier and less than 12% containing proteins matching to multiple genes. Out of the 175 identified groups in the first run, only 97 groups contained exactly the same proteins in all the other experiments, with 63 always containing a single identifier (size 1). Out of the 34 non-singleton groups containing the same proteins in all runs, 20 had the same top-protein. Similar results were observed from other runs.</p>
      <p>Dataset B consists of 12 lists of protein groups generated by Proteome Discoverer from 12 spectral count-based experiments used to process plasma samples from 12 healthy individuals. Thus, with this dataset, we examine the effect of technical and biological variation in protein identification (see <xref ref-type="sec" rid="sec010">Materials and methods</xref> and <xref ref-type="supplementary-material" rid="pone.0177569.s005">S2 File</xref>). <xref ref-type="fig" rid="pone.0177569.g004">Fig 4</xref> illustrates the sizes of the local protein groups within each experiment. Similar to what was observed for the iTRAQ experiments, on average, 222 protein groups were identified within each experimental run, with 60% of these containing a single protein identifier. To compare the composition of the groups among the 12 experiments, we use the Dice coefficient proposed by Hesse et al. [<xref rid="pone.0177569.ref007" ref-type="bibr">7</xref>] as a measure of similarity between protein groups (defined in <xref ref-type="sec" rid="sec010">Materials and methods</xref>). In this study, we use this measure to compare the local protein groups (child groups in Hesse et al.’s terminology) within each experiment with the global groups (parent groups) in the dictionary created by PGCA. The dictionary from these 12 experiments contains a total of 357 global proteins groups.</p>
      <fig id="pone.0177569.g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0177569.g004</object-id>
        <label>Fig 4</label>
        <caption>
          <title>Sizes of protein groups within experimental runs.</title>
          <p>Sizes of the local groups identified by Proteome Discoverer within each of the 12 spectral count-based experiments in Dataset B.</p>
        </caption>
        <graphic xlink:href="pone.0177569.g004"/>
      </fig>
      <p>We first compare the raw protein groups created by Proteome Discoverer (i.e., the local groups are not refined) with the corresponding global groups in the dictionary created by PGCA. If a global group in the dictionary is not identified in an individual experiment, the intersection between the global and the local group is empty and the Dice coefficient is 0 (dark-orange cell in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5A</xref>). If a local group contains the same protein identifiers as the global group (except perhaps for the order of the proteins in the group), the intersection is the same group and the Dice coefficient is 1 (light-yellow cells in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5A</xref>). Lastly, if only a subset of the protein identifiers in the global group are identified in an individual experiment, the intersection between the local and global group equals the local group and the Dice coefficient is smaller than 1 (represented by a range of colours between dark-orange and light-yellow in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5A</xref>). As expected from a mass spectrometry experiment, 22% of the 357 global groups were identified in only one experiment (dark-orange columns with only one light-yellow cell at the right in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5A</xref>) and 45% were identified in all the experiment, although perhaps with a different structure (light yellow and light orange columns to the left in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5A</xref>).</p>
      <fig id="pone.0177569.g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0177569.g005</object-id>
        <label>Fig 5</label>
        <caption>
          <title>The Dice coefficient to compare lists of protein groups.</title>
          <p>(A) Dice coefficient to compare the raw protein groups identified within each experiment with the dictionary created by PGCA. (B) Dice coefficient to compare the top-protein of a given group with the set of all top-proteins used to represent the group in other experiments.</p>
        </caption>
        <graphic xlink:href="pone.0177569.g005"/>
      </fig>
      <p>However, the Dice coefficient is a measure of similarity between two unordered sets and cannot capture changes in the structure of the groups. For example, among the 45% protein groups identified in all 12 experiments, 23% of them were identified with different top-proteins among the different experiments. Since it is a common practice to use only the top-protein of the identified groups to link lists from multiple experiments, <xref ref-type="fig" rid="pone.0177569.g005">Fig 5B</xref> illustrates the changes in the top-protein among groups from different experiments. In this comparison, only the top-protein is retained from each local group and compared against the set of all the top-proteins appearing in related groups (i.e., the union of all top-proteins in the local groups). As before, a Dice coefficient equal to 0 (dark-orange cells in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5B</xref>) indicates that the group was not identified in the experiment. A Dice coefficient equal to 1 (light-yellow cells in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5B</xref>) indicates that there is a unique top-protein representing all local groups (the local groups may not be identical but they are all represented by the same top-protein). A Dice coefficient smaller than 1 (range of colours between dark-orange and light-yellow in <xref ref-type="fig" rid="pone.0177569.g005">Fig 5B</xref>) indicates that different top-proteins were used to represent the group across experiments (i.e., the parent group containing all possible top-proteins has more protein identifiers than each individual group). This study shows that similar results are observed when different biological samples are processed within and across experiments (see also next section), showing that the observed variation in protein identification is dominated by the technical variation.</p>
    </sec>
    <sec id="sec005">
      <title>Application to biomarkers studies</title>
      <p>In general in a biomarker study, the proteins identified in (almost) all experimental runs are analyzed to compare protein levels from different subject groups (e.g., diseased vs healthy patients). As previously discussed, two main tasks are required before starting this discovery analysis. First, the protein identifiers in each identified group (or a selected subset of these) need to be translated into a unique protein group code (PGC) identifier for each experimental run. Second, the assigned group code is used to link the groups among runs and to retain those consistently detected in all (or almost all) runs for subsequent statistical analyses. Importantly, these steps are required even if only the top-protein in each group will be retained, since the lists of top-proteins also vary, both in content and order, across runs. Using different criteria to link the lists of identified proteins results in different sets of proteins to be analyzed. For example, the group illustrated in <xref ref-type="fig" rid="pone.0177569.g002">Fig 2</xref> can be compared in all 3 runs only when groups are linked using the PGC assigned by PGCA-All. Alternatively, if only the top-protein is used, then IPI00215894.1 (UniProt P01042-2) is observed in only the first file; IPI00797833.3 (almost identical to UniProt P01042-2) is observed in the last two files, and IPI00032328.2 (UniProt P01042-1) is observed in files 1 and 3. This may result in losing certain proteins from subsequent analyses if their identification rate across all runs in the study is not large enough.</p>
      <sec id="sec006">
        <title>Heart transplantation data</title>
        <p>The Biomarkers in Transplantation (BiT) team conducted a large biomarker study seeking protein markers of acute rejection in cardiac and renal transplantation using plasma samples [<xref rid="pone.0177569.ref019" ref-type="bibr">19</xref>, <xref rid="pone.0177569.ref020" ref-type="bibr">20</xref>]. <xref ref-type="fig" rid="pone.0177569.g006">Fig 6A</xref> illustrates the number of protein group <italic>codes</italic> that are consistently identified in different experimental runs of the heart transplantation study (dataset C in <xref ref-type="supplementary-material" rid="pone.0177569.s006">S3 File</xref>). To ease the visualization of the results, the 65 files are incorporated in the analysis one-at-a-time in decreasing order according to the total number of protein groups within each file. As expected, the number of codes identified in all runs decreases as the number of runs increases for all three approaches. This result characterizes the lack of consistency in the identification of proteins previously observed in mass spectrometry data [<xref rid="pone.0177569.ref003" ref-type="bibr">3</xref>, <xref rid="pone.0177569.ref021" ref-type="bibr">21</xref>]. The distance between the solid and the other lines shows that part of this lack of consistency is explained by changes in the composition of the identified protein groups as previously observed in dataset A. In small studies (1 to 10 runs, <xref ref-type="fig" rid="pone.0177569.g006">Fig 6A</xref>), the number of codes consistently identified in all runs increases, on average, from 134 to 162 if the code assigned by PGCA-All is used to link the identifications across runs (20% increment), instead of using the top-protein. Similar patterns are observed in medium studies (10 to 30 runs) with a 33% average increment and in large studies (more than 30 runs) with a 50% average increment in the number of common codes among runs (e.g., from 35 to 59 common codes among 65 runs). Thus, incorporating the information contained in the detected protein groups and allowing these groups to slightly vary their composition across runs may reduce the impact of the lack of identification consistency in subsequent analyzes.</p>
        <fig id="pone.0177569.g006" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0177569.g006</object-id>
          <label>Fig 6</label>
          <caption>
            <title>Mapping results according to PGCA.</title>
            <p>(A) Number of consistently identified protein group codes (common PGCs on y-axis) linked by different PGCA approaches (PGCA-All in solid black, PGCA-topGene in dotted blue, and PGCA-topIdentifier in dotted-dashed red) after a stepwise incorporation of each experiment (x-axis). (B) Number of new protein identities (thick-solid line), of new global protein groups (thin-solid line), and of mergers (dotted line) after a stepwise processing of each experiment. (C) Number of global protein groups in the sequential mappings for different ranges of group sizes (single protein groups in solid black line, groups with 2 proteins in dash-dotted blue line, groups with 3 to 5 proteins in dotted red line, groups with more than 5 proteins in dashed purple line).</p>
          </caption>
          <graphic xlink:href="pone.0177569.g006"/>
        </fig>
        <p>One goal of this biomarker study was to identify potential proteomic markers of acute cardiac allograph rejection. A total of 17 iTRAQ experiments were used to process 6 plasma samples from patients with acute heart rejection (AR) and 12 from patients without rejection (NR). Using PGCA-All in this study to link the protein groups identified across different runs enabled the analysis of 127 protein groups, of which 61 were not represented by the same top-identifier in all runs. Some of the candidate markers with statistically significant differential protein levels between AR and NR groups were represented by different top-proteins across the 17 iTRAQ runs and would have been missed if only the top-protein was used to represent each protein group. For example, Isoform 1 of Sex hormone-binding globulin protein (SHBG) was the top-protein in 13 out of 17 iTRAQ experiments in the study and Isoform 2 of the same protein was the top-protein in the 4 remaining experiments. In particular this candidate marker (robust limma test p-value of 0.03, Wilcoxon p-value of 0.06) was validated using multiple reaction monitoring coupled with mass spectrometry (MRM assay) showing differential protein levels between the AR and NR groups (with Wilcoxon p-value of 0.03). All data from this study is available in <xref ref-type="supplementary-material" rid="pone.0177569.s007">S4 File</xref>.</p>
      </sec>
      <sec id="sec007">
        <title>Muscular dystrophy data</title>
        <p>The Jain Foundation with MRM Proteomics and PROOF Centre of Excellence is conducting a proteomics discovery study of blood-based biomarkers associated with skeletal muscle function. Using PGCA-All to link the protein groups identified across different runs enabled the analysis of 131 protein groups identified in more than 75% of the samples, of which 26 were not represented by the same top-identifier in all runs. Of the 26 that would have been missed if only the top-protein were used to link the identified groups, 9 had a false discovery rate (FDR) below 10% in a statistical analysis that compares the protein levels of LGMD2B (n = 50) versus control samples (n = 25). The difference in groups identifications are shown in <xref ref-type="supplementary-material" rid="pone.0177569.s008">S5 File</xref>. Although these results remain to be validated in an independent cohort, identifying potential candidate markers is crucial in the discovery phase before moving to the validation stage [<xref rid="pone.0177569.ref020" ref-type="bibr">20</xref>].</p>
      </sec>
    </sec>
    <sec id="sec008">
      <title>Variation in PGCA’s mapping</title>
      <p>PGCA creates a mapping of local to global protein groups by comparing the composition of the local protein groups identified within each experimental run. Using a unique global protein group code to represent all the proteins identified in connected local groups enables linking related groups from multiple experimental runs, even if these groups slightly change their composition across runs. Noteworthy, the mapping created by PGCA is data driven and depends on the list of local protein groups identified within each experimental run. Thus, if new experiments are added to a study, the current mapping needs to be updated accordingly (see <xref ref-type="fig" rid="pone.0177569.g002">Fig 2</xref>). To study the variation in PGCA’s mapping, each experiment from the dataset C was sequentially processed by PGCA and the resulting mapping was examined. Three possible changes may occur simultaneously or in isolation to a mapping being updated: <italic>i)</italic> new global protein groups are added, <italic>ii)</italic> new protein identities are added to existing global protein groups, and <italic>iii)</italic> existing global protein groups are merged due to the incorporation of connecting groups in the mapping.</p>
      <p><xref ref-type="fig" rid="pone.0177569.g006">Fig 6B</xref> illustrates the contribution of these components of variation in the mapping. For simplicity, only results from PGCA-All are shown as similar results were observed for PGCA-topGene and the figure is trivial for PGCA-topIdentifier. We note that increments in the number of new accession numbers (thick-solid line) result in similar increments in the number of new groups (thin-solid line). Thus, most of the new protein identities are non-redundant creating new global groups. The distance between both solid lines corresponds to new protein identities joining existing groups and/or new protein identities from the new non-singleton groups. As the number of processed experimental runs increases, both lines get closer together showing that changes in the mapping are mainly due to the identification of new groups of size 1 instead of a reconfiguration of the existing groups (i.e., addition of new proteins to existing groups and/or merger of groups). The number of mergers at each step (dotted line) remains always below 3 indicating that local groups are consistently connected across runs.</p>
      <p>A complementary measure examined is the growth in the total number of global protein groups in the mappings for different ranges of group sizes (<xref ref-type="fig" rid="pone.0177569.g006">Fig 6C</xref>). Similar results were observed for PGCA-topGene. Groups with a unique identifier (size 1) are the ones growing faster. The number of groups with sizes between 2 and 5 are also growing but at a lower pace and remains almost constant after processing 45 experiments. Overall, results demonstrate the stabilization of the created mapping. The observed variation in protein identifications and the non-negligible percentage of proteins identified in isolation in each run characterize most mass spectrometry identification lists.</p>
    </sec>
    <sec id="sec009">
      <title>Properties</title>
      <p>This Section presents some properties of PGCA with proof outlines given in <xref ref-type="supplementary-material" rid="pone.0177569.s003">S1 Appendix</xref>. As these properties hold for the three PGCA approaches described before, we uniformly refer to PGCA. We give more details on the notation used in the Materials and Method section.</p>
      <p>Each time a new file is processed, the updated mapping results in a comprehensive list of global protein groups, each with a protein group code, that can be used to link groups across experimental runs. The following results demonstrate that the global groups in the mapping are disjoint and that each was derived from connected local groups. The corollaries at the end of this Section show two results with important practical utility. First, the same mapping is obtained regardless of the order in which files are processed (i.e., order invariance). Second, a current mapping can be easily updated every time that new files are incorporated into a study without the need of reprocessing all the data (i.e., incremental).</p>
      <p><bold>Definition 1</bold><italic>Let</italic><inline-formula id="pone.0177569.e001"><alternatives><graphic xlink:href="pone.0177569.e001.jpg" id="pone.0177569.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula><italic>be a set of protein groups</italic>. <italic>Given two groups</italic><inline-formula id="pone.0177569.e002"><alternatives><graphic xlink:href="pone.0177569.e002.jpg" id="pone.0177569.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></alternatives></inline-formula><italic>and</italic><inline-formula id="pone.0177569.e003"><alternatives><graphic xlink:href="pone.0177569.e003.jpg" id="pone.0177569.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, <italic>B</italic><sub>1</sub><italic>and</italic><italic>B</italic><sub>2</sub><italic>are connected if either B</italic><sub>1</sub> ∩ <italic>B</italic><sub>2</sub> ≠ ∅ <italic>or there exist a connector set</italic>
<inline-formula id="pone.0177569.e004"><alternatives><graphic xlink:href="pone.0177569.e004.jpg" id="pone.0177569.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mrow><mml:mover><mml:mi>B</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∪</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup><mml:msub><mml:mi>B</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <italic>with all B</italic><sub><italic>j</italic></sub>
<italic>in</italic>
<inline-formula id="pone.0177569.e005"><alternatives><graphic xlink:href="pone.0177569.e005.jpg" id="pone.0177569.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula>, <italic>such that:</italic></p>
      <list list-type="order">
        <list-item>
          <p><inline-formula id="pone.0177569.e006"><alternatives><graphic xlink:href="pone.0177569.e006.jpg" id="pone.0177569.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:mover><mml:mi>B</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>≠</mml:mo><mml:mi>∅</mml:mi></mml:mrow></mml:math></alternatives></inline-formula><italic>for</italic><italic>i</italic> = 1, 2, <italic>and</italic></p>
        </list-item>
        <list-item>
          <p><inline-formula id="pone.0177569.e007"><alternatives><graphic xlink:href="pone.0177569.e007.jpg" id="pone.0177569.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mover><mml:mi>B</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula><italic>can not be partitioned into two disjoint collections of sets in</italic><inline-formula id="pone.0177569.e008"><alternatives><graphic xlink:href="pone.0177569.e008.jpg" id="pone.0177569.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula>.</p>
        </list-item>
      </list>
      <p><italic>Further</italic>, <inline-formula id="pone.0177569.e009"><alternatives><graphic xlink:href="pone.0177569.e009.jpg" id="pone.0177569.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula><italic>is connected if all groups</italic><inline-formula id="pone.0177569.e010"><alternatives><graphic xlink:href="pone.0177569.e010.jpg" id="pone.0177569.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></alternatives></inline-formula><italic>are connected</italic>.</p>
      <p><bold>Lemma 1</bold><italic>Let L be the set of local groups from a file F (i.e., L = CreateLocalGroups(F)), G be the set of global groups from a dictionary D, and</italic><inline-formula id="pone.0177569.e011"><alternatives><graphic xlink:href="pone.0177569.e011.jpg" id="pone.0177569.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>∪</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. <italic>Let</italic><inline-formula id="pone.0177569.e012"><alternatives><graphic xlink:href="pone.0177569.e012.jpg" id="pone.0177569.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>U</mml:mi><mml:mi>p</mml:mi><mml:mi>d</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>D</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>y</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula><italic>be the output dictionary from the UdpdateDictionary algorithm</italic>. <italic>Given B, a set of accession numbers from those in</italic><inline-formula id="pone.0177569.e013"><alternatives><graphic xlink:href="pone.0177569.e013.jpg" id="pone.0177569.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mi mathvariant="script">B</mml:mi></mml:math></alternatives></inline-formula>, <italic>and</italic><inline-formula id="pone.0177569.e014"><alternatives><graphic xlink:href="pone.0177569.e014.jpg" id="pone.0177569.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi><mml:mtext> </mml:mtext><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>c</mml:mi><mml:mi>h</mml:mi><mml:mtext> </mml:mtext><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>a</mml:mi><mml:mi>t</mml:mi><mml:mtext> </mml:mtext><mml:mi>B</mml:mi><mml:mo>∩</mml:mo><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mi>E</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <italic>B is a global group in</italic><inline-formula id="pone.0177569.e015"><alternatives><graphic xlink:href="pone.0177569.e015.jpg" id="pone.0177569.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula><italic>if and only if</italic><inline-formula id="pone.0177569.e016"><alternatives><graphic xlink:href="pone.0177569.e016.jpg" id="pone.0177569.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula><italic>is non-empty and connected, and</italic><inline-formula id="pone.0177569.e017"><alternatives><graphic xlink:href="pone.0177569.e017.jpg" id="pone.0177569.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∩</mml:mo><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mi>∅</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.277778em"/><mml:mo>∀</mml:mo><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi><mml:mo>\</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>From Lemma 1, it easily follows that any global group <italic>B</italic> in <inline-formula id="pone.0177569.e018"><alternatives><graphic xlink:href="pone.0177569.e018.jpg" id="pone.0177569.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> can be written as the union of all connected group in <inline-formula id="pone.0177569.e019"><alternatives><graphic xlink:href="pone.0177569.e019.jpg" id="pone.0177569.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mi mathvariant="script">B</mml:mi></mml:math></alternatives></inline-formula> that are included in <italic>B</italic>.</p>
      <p><bold>Theorem 1</bold><italic>Let L<sub>i</sub> be the set of local groups from an input file F<sub>i</sub> (i.e., L<sub>i</sub> = CreateLocalGroups(F<sub>i</sub>)) for i</italic> = 1, …, <italic>nFiles, and</italic>
<inline-formula id="pone.0177569.e020"><alternatives><graphic xlink:href="pone.0177569.e020.jpg" id="pone.0177569.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:mrow><mml:msub><mml:mi mathvariant="script">L</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>F</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∪</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>F</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>
<italic>be the universe of all these local groups</italic>. <italic>Starting from an empty dictionary D</italic><sub>0</sub>, <italic>let D<sub>nFiles</sub> = PGCA</italic>(<italic>D</italic><sub>0</sub>, <italic>F</italic><sub>1</sub>, …, <italic>F</italic><sub><italic>nFiles</italic></sub>) <italic>be the output dictionary from input files F</italic><sub><italic>i</italic></sub>, <italic>i</italic> = 1, …, <italic>nFiles</italic>. <italic>Given B a set of accession numbers from those in</italic>
<inline-formula id="pone.0177569.e021"><alternatives><graphic xlink:href="pone.0177569.e021.jpg" id="pone.0177569.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:msub><mml:mi mathvariant="script">L</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>F</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>
<italic>and</italic>
<inline-formula id="pone.0177569.e022"><alternatives><graphic xlink:href="pone.0177569.e022.jpg" id="pone.0177569.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mrow><mml:mi mathvariant="script">A</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">L</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>F</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mspace width="0.277778em"/><mml:mi>B</mml:mi><mml:mo>∩</mml:mo><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mi>E</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <italic>B is a global group in D</italic><sub><italic>nFiles</italic></sub>
<italic>if and only if</italic>
<inline-formula id="pone.0177569.e023"><alternatives><graphic xlink:href="pone.0177569.e023.jpg" id="pone.0177569.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mi mathvariant="script">A</mml:mi></mml:math></alternatives></inline-formula>
<italic>is non-empty and connected, and</italic>
<inline-formula id="pone.0177569.e024"><alternatives><graphic xlink:href="pone.0177569.e024.jpg" id="pone.0177569.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∩</mml:mo><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mi>∅</mml:mi><mml:mo>,</mml:mo><mml:mspace width="0.277778em"/><mml:mo>∀</mml:mo><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi mathvariant="script">L</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mi>F</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>\</mml:mo><mml:mi mathvariant="script">A</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p><bold>Corollary 1</bold><italic>PGCA is order invariant, i.e., the order in which the files F</italic><sub>1</sub>, …, <italic>F</italic><sub><italic>nFiles</italic></sub><italic>are input in PGCA do not change the general groups in the output D</italic><sub><italic>nFiles</italic></sub>.</p>
      <p><bold>Corollary 2</bold><italic>PGCA is incremental, i.e., using the same notation as in Theorem 1</italic>,</p>
      <disp-formula id="pone.0177569.e025">
        <alternatives>
          <graphic xlink:href="pone.0177569.e025.jpg" id="pone.0177569.e025g" mimetype="image" position="anchor" orientation="portrait"/>
          <mml:math id="M25">
            <mml:mtable columnalign="left">
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>D</mml:mi>
                      <mml:mrow>
                        <mml:mi>n</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>m</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mo>=</mml:mo>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mi>U</mml:mi>
                    <mml:mi>p</mml:mi>
                    <mml:mi>d</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>D</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>c</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>r</mml:mi>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>D</mml:mi>
                          <mml:mn>0</mml:mn>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mrow>
                          <mml:mo>{</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>L</mml:mi>
                              <mml:mn>1</mml:mn>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:mo>…</mml:mo>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>L</mml:mi>
                              <mml:mrow>
                                <mml:mi>n</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>m</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo>}</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow/>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mo>=</mml:mo>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mi>U</mml:mi>
                    <mml:mi>p</mml:mi>
                    <mml:mi>d</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>e</mml:mi>
                    <mml:mi>D</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>c</mml:mi>
                    <mml:mi>t</mml:mi>
                    <mml:mi>i</mml:mi>
                    <mml:mi>o</mml:mi>
                    <mml:mi>n</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>r</mml:mi>
                    <mml:mi>y</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>D</mml:mi>
                          <mml:mi>n</mml:mi>
                        </mml:msub>
                        <mml:mo>,</mml:mo>
                        <mml:mrow>
                          <mml:mo>{</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>L</mml:mi>
                              <mml:mrow>
                                <mml:mi>n</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mn>1</mml:mn>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:mo>…</mml:mo>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>L</mml:mi>
                              <mml:mrow>
                                <mml:mi>n</mml:mi>
                                <mml:mo>+</mml:mo>
                                <mml:mi>m</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo>}</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </alternatives>
      </disp-formula>
    </sec>
  </sec>
  <sec sec-type="materials|methods" id="sec010">
    <title>Materials and methods</title>
    <p>This section describes the datasets used to demonstrate the properties of our algorithm. We also present all formal details of PGCA (see Algorithm 1) and its three main algorithms, CreateLocalGroups, UpdateDictionary, and CodingProteinGroups (see Algorithms 2, 3, and 4, respectively).</p>
    <sec id="sec011">
      <title>Datasets</title>
      <p>We use 4 different datasets to examine the protein inference problem when multiple experimental runs are required to process all samples in a study. Dataset A consists of 4 experimental runs used to process 16 technical replicates of a pool of plasma from 16 healthy individuals processed by iTRAQ-MALDI-TOF/TOF methodology (see <xref ref-type="supplementary-material" rid="pone.0177569.s004">S1 File</xref>). Dataset B consists of 12 spectral count-based experiments used to identify and quantitate proteins in plasma samples from 12 healthy individuals (see <xref ref-type="supplementary-material" rid="pone.0177569.s005">S2 File</xref>). Dataset C consists of 65 iTRAQ runs used to process 195 samples from heart transplant patients (see <xref ref-type="supplementary-material" rid="pone.0177569.s006">S3</xref> and <xref ref-type="supplementary-material" rid="pone.0177569.s007">S4</xref> Files). Datasets A to C belong to the Biomarkers in Transplantation (BiT) initiative and PROOF Centre of Excellence. Dataset D belongs to the Jain Foundation and consists of 11 iTRAQ runs used to process 50 limb-girdle muscular dystrophy type 2 B (LGMD2B) and 25 healthy controls (see <xref ref-type="supplementary-material" rid="pone.0177569.s008">S5 File</xref>). All these datasets are based on studies approved by the Human Research Ethics Board of the University of British Columbia. All patients enrolled in these studies signed consent forms. Similar experimental and data processing methods were used to process the plasma samples in all datasets, which are described in detail in [<xref rid="pone.0177569.ref019" ref-type="bibr">19</xref>, <xref rid="pone.0177569.ref020" ref-type="bibr">20</xref>], except for those in dataset B which are raw (non-depleted) plasma samples without any isobaric label added. The raw MS/MS data from datasets A and C were processed using ProteinPilot software v3.0 with the integrated Paragon<sup>™</sup> Search and Pro Group<sup>™</sup> algorithms [<xref rid="pone.0177569.ref012" ref-type="bibr">12</xref>], searching against International Protein Index (IPI HUMAN v3.39) database [<xref rid="pone.0177569.ref022" ref-type="bibr">22</xref>]. Datasets B and D were processed using Thermo Proteome Discoverer 1.4 and MASCOT, searching against UniProt database (October 2016 and 2014 release, respectively). Although we can not reprocess some of the data used in this work, we note that the protein inference problem is inherent in tandem mass spectrometry techniques regardless of the proteomics technology and the standard databases used. All codes were written in R (<ext-link ext-link-type="uri" xlink:href="http://www.r-project.org">http://www.r-project.org</ext-link>). A library with an associated Vignette to implement PGCA algorithm is publicly available from Bioconductor (<ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org">http://www.bioconductor.org</ext-link>).</p>
    </sec>
    <sec id="sec012">
      <title>Dice coefficient</title>
      <p>Hesse et al. [<xref rid="pone.0177569.ref007" ref-type="bibr">7</xref>] proposed using the Dice coefficient to compare list of protein groups identified from different experiments (child context) with a parent list generated as the union of all individual lists. The Dice coefficient is a measure of similarity between two (unordered) sets and is defined by 2|<italic>A</italic> ∩ <italic>B</italic>|/(|<italic>A</italic>| + |<italic>B</italic>|), where |.| denotes the number of elements in the set. Note that if the sets <italic>A</italic> and <italic>B</italic> do not share any elements, then the Dice coefficient equals 0. If the sets <italic>A</italic> and <italic>B</italic> have the same elements, then the dice measure equals 1. However, this measure can not capture differences in the order of the elements of the sets. For example, if two protein groups contain the same set of protein identifiers then the Dice coefficient equals 1, even if each group is represented by a different top-protein in different experiments.</p>
    </sec>
    <sec id="sec013">
      <title>Notation</title>
      <p>As a result of processing MS/MS data, most proteomics software generate protein summaries containing quantitative and qualitative information of the sample(s) analyzed within each run. PGCA uses these protein summaries as input files, here named <italic>F</italic><sub>1</sub>, …, <italic>F</italic><sub><italic>nFiles</italic></sub>, with <italic>nFiles</italic> being the total number of input files. PGCA works on the assumption that the following variables are available within each protein summary, or easily generated as a result of processing MS/MS data:</p>
      <list list-type="order">
        <list-item>
          <p>Group identifier (N): an integer used to define (local) protein groups within each experimental run</p>
        </list-item>
        <list-item>
          <p>Top-protein identifier (TopID): an identifier of the top protein identification within each protein group</p>
        </list-item>
        <list-item>
          <p>Accession number (Acc): an identifier from a proteomic database for each identified protein</p>
        </list-item>
        <list-item>
          <p>Protein name (Prot): the protein name in the database matching to the accession number</p>
        </list-item>
        <list-item>
          <p>Gene symbol (Gene): gene(s) matching to the identified protein</p>
        </list-item>
        <list-item>
          <p><inline-formula id="pone.0177569.e026"><alternatives><graphic xlink:href="pone.0177569.e026.jpg" id="pone.0177569.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:mover><mml:mtext>Rest</mml:mtext><mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>: additional information from the input file (e.g., confidence of identification, percentage of coverage, protein (relative) levels).</p>
        </list-item>
      </list>
      <p>Further, we assume that each input file has the variables defined above as columns, i.e., <italic>F</italic><sub><italic>k</italic></sub> has entries &lt;N, TopID, Acc, Prot, Gene, <inline-formula id="pone.0177569.e027"><alternatives><graphic xlink:href="pone.0177569.e027.jpg" id="pone.0177569.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mrow><mml:mover><mml:mtext>Rest</mml:mtext><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula> &gt;.</p>
      <p>PGCA creates a dictionary, <italic>D</italic><sub><italic>nFiles</italic></sub>, adding a protein group code (PGC) to each global group created from <italic>F</italic><sub>1</sub>, …, <italic>F</italic><sub><italic>nFiles</italic></sub>. The subscript <italic>nFiles</italic> is used to indicate how many files were used to create the dictionary. In practice, the set of files used can range from the total number of files in a study to specific files used to process data to answer a particular question.</p>
      <p>The resulting dictionary is used to recode each entry of <italic>F</italic><sub>1</sub>, …, <italic>F</italic><sub><italic>nFiles</italic></sub> and thus generate <italic>nFiles</italic> output files, denoted as <italic>CF</italic><sub>1</sub>, …, <italic>CF</italic><sub><italic>nFiles</italic></sub>. Each entry in <italic>CF</italic><sub><italic>k</italic></sub> is of the form &lt;PGC, N, TopID, Acc, Prot, Gene, <inline-formula id="pone.0177569.e028"><alternatives><graphic xlink:href="pone.0177569.e028.jpg" id="pone.0177569.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mrow><mml:mover><mml:mtext>Rest</mml:mtext><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula> &gt;, where PGC is the code corresponding to the protein accession number (Acc) in the dictionary.</p>
      <p>In PGCA, we define the <italic>j</italic>-th local group <inline-formula id="pone.0177569.e029"><alternatives><graphic xlink:href="pone.0177569.e029.jpg" id="pone.0177569.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mrow><mml:mi>L</mml:mi><mml:msubsup><mml:mi>G</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> in <italic>F</italic><sub><italic>k</italic></sub> as the set of <inline-formula id="pone.0177569.e030"><alternatives><graphic xlink:href="pone.0177569.e030.jpg" id="pone.0177569.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:msubsup><mml:mi>n</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> accession numbers from entries in <italic>F</italic><sub><italic>k</italic></sub> with identical group identifier <italic>j</italic>, i.e., <inline-formula id="pone.0177569.e031"><alternatives><graphic xlink:href="pone.0177569.e031.jpg" id="pone.0177569.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:mrow><mml:mi>L</mml:mi><mml:msubsup><mml:mi>G</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mtext>Acc</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mtext>N</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>; and <italic>nLocalGroups</italic> the total number of distinct Ns in <italic>F</italic><sub><italic>k</italic></sub>. Similarly, The <italic>j</italic>-th global group <italic>GG</italic><sub><italic>j</italic></sub> in <italic>D</italic> is defined as the set of <italic>m</italic><sub><italic>j</italic></sub> accession numbers from entries in a dictionary <italic>D</italic> with identical PGC identifier <italic>j</italic>, i.e., <italic>GG</italic><sub><italic>j</italic></sub> = {Acc<sub><italic>i</italic></sub> ∈ <italic>D</italic>: PGC<sub><italic>i</italic></sub> = <italic>j</italic>}; and <italic>nGlobalGroups</italic> the total number of distinct PGCs in <italic>D</italic>. To simplify the notation, we assume that all groups are numbered in consecutive order, since one can always re-name existing groups.</p>
      <p>Each algorithm is presented as a mathematical function, i.e., <italic>f</italic>(<italic>x</italic>) = <italic>y</italic>, to state that the algorithm <italic>f</italic> transforms the input file <italic>x</italic> into the output object <italic>y</italic>.</p>
    </sec>
    <sec id="sec014">
      <title>Algorithm</title>
      <p>We only present PGCA-All in detail since PGCA-topGene and PGCA-topIdentifier only differ from it in the CreateLocalGroups algorithm within each. In particular, each local group in the LocalGroupSet created by the CreateLocalGroups algorithm in PGCA-topGene retains only those entries from the full local group with identical rank and Gene element as those of the top protein identification. Similarly, CreateLocalGroups algorithm in PGCA-topIdentifier retains only the top entry. Thus, the local groups created by these algorithms are subsets of those created by the PGCA-All (see <xref ref-type="fig" rid="pone.0177569.g003">Fig 3</xref>).</p>
      <p><bold>Algorithm 1:</bold> PGCA</p>
      <p specific-use="line"> <bold>Input:</bold>
<italic>F</italic><sub>1</sub>, …, <italic>F</italic><sub><italic>nFiles</italic></sub></p>
      <p specific-use="line"> <bold>Output:</bold>
<italic>D</italic><sub><italic>nFiles</italic></sub>, <italic>CF</italic><sub>1</sub>, …, <italic>CF</italic><sub><italic>nFiles</italic></sub></p>
      <p specific-use="line">1 Let <italic>D</italic><sub>0</sub> be an empty dictionary</p>
      <p specific-use="line">2 <bold>for</bold> 1 ≤ <italic>k</italic> ≤ <italic>nFiles</italic>
<bold>do</bold></p>
      <p specific-use="line">3  CreateLocalGroups(<italic>F</italic><sub><italic>k</italic></sub>) = <italic>LocalGroupSet</italic><sub><italic>k</italic></sub></p>
      <p specific-use="line">4  UpdateDictionary(<italic>LocalGroupSet</italic><sub><italic>k</italic></sub>, <italic>D</italic><sub><italic>k</italic>−1</sub>) = <italic>D</italic><sub><italic>k</italic></sub></p>
      <p specific-use="line">5 <bold>for</bold> 1 ≤ <italic>k</italic> ≤ <italic>nFiles</italic>
<bold>do</bold></p>
      <p specific-use="line">6  CodingProteinGroups(<italic>D</italic><sub><italic>nFiles</italic></sub>, <italic>F</italic><sub><italic>k</italic></sub>) = <italic>CF</italic><sub><italic>k</italic></sub>. ∎</p>
      <p><bold>Algorithm 2:</bold> CreateLocalGroups</p>
      <p specific-use="line"> <bold>Input:</bold>
<italic>F</italic><sub><italic>k</italic></sub>, the <italic>k</italic>-th input file</p>
      <p specific-use="line"> <bold>Output:</bold>
<inline-formula id="pone.0177569.e032"><alternatives><graphic xlink:href="pone.0177569.e032.jpg" id="pone.0177569.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:mrow><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>G</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>L</mml:mi><mml:msubsup><mml:mi>G</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>;</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>G</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p specific-use="line">1 <bold>for</bold> 1 ≤ <italic>j</italic> ≤ <italic>nLocalGroups</italic><sub><italic>k</italic></sub>
<bold>do</bold></p>
      <p specific-use="line">2  create <inline-formula id="pone.0177569.e033"><alternatives><graphic xlink:href="pone.0177569.e033.jpg" id="pone.0177569.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:mrow><mml:mi>L</mml:mi><mml:msubsup><mml:mi>G</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mtext>Acc</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>:</mml:mo><mml:msub><mml:mtext>N</mml:mtext><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p specific-use="line">3 define <inline-formula id="pone.0177569.e034"><alternatives><graphic xlink:href="pone.0177569.e034.jpg" id="pone.0177569.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:mrow><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>G</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>L</mml:mi><mml:msubsup><mml:mi>G</mml:mi><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>;</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mspace width="0.166667em"/><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>G</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. ∎</p>
      <p><bold>Algorithm 3:</bold> UpdateDictionary</p>
      <p specific-use="line"> <bold>Input:</bold> A dictionary <italic>D</italic> and a LocalGroupSet</p>
      <p specific-use="line"> <bold>Output:</bold> An updated dictionary <inline-formula id="pone.0177569.e035"><alternatives><graphic xlink:href="pone.0177569.e035.jpg" id="pone.0177569.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula></p>
      <p specific-use="line"> /* <monospace>Create a GlobalGroupSet</monospace> */</p>
      <p specific-use="line">1 <bold>if</bold>
<italic>D</italic> = <italic>D</italic><sub>0</sub>
<bold>then return</bold>
<italic>GlobalGroupSet</italic> = ∅;</p>
      <p specific-use="line">2 <bold>else</bold></p>
      <p specific-use="line">3 <bold>for</bold> 1 ≤ <italic>j</italic> ≤ <italic>nGlobalGroups</italic>
<bold>do</bold></p>
      <p specific-use="line">4  create <italic>GG</italic><sub><italic>j</italic></sub> = {Acc<sub><italic>i</italic></sub> ∈ <italic>D</italic>: PGC<sub><italic>i</italic></sub> = <italic>j</italic>}</p>
      <p specific-use="line">5 define <italic>GlobalGroupSet</italic> = {<italic>GG</italic><sub><italic>j</italic></sub>; <italic>j</italic> = 1…, <italic>nGobalGroups</italic>};</p>
      <p specific-use="line"> /* <monospace>Update the GlobalGroupSet</monospace> */</p>
      <p specific-use="line">6 create <inline-formula id="pone.0177569.e036"><alternatives><graphic xlink:href="pone.0177569.e036.jpg" id="pone.0177569.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mo>=</mml:mo><mml:mi>G</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>b</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>G</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mo>∪</mml:mo><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi><mml:mi>G</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:mi>S</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p specific-use="line"> /* <monospace>Merge overlapping and connected groups to a fixpoint</monospace> */</p>
      <p specific-use="line">7 <bold>do</bold></p>
      <p specific-use="line">8  take <inline-formula id="pone.0177569.e037"><alternatives><graphic xlink:href="pone.0177569.e037.jpg" id="pone.0177569.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p specific-use="line">9  <bold>repeat</bold></p>
      <p specific-use="line">   /* <monospace>inner loop to get a fixpoint</monospace> */</p>
      <p specific-use="line">10   compute <inline-formula id="pone.0177569.e038"><alternatives><graphic xlink:href="pone.0177569.e038.jpg" id="pone.0177569.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi><mml:mo>:</mml:mo><mml:mi>E</mml:mi><mml:mo>∩</mml:mo><mml:mi>B</mml:mi><mml:mo>≠</mml:mo><mml:mi>∅</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p specific-use="line">11   <bold>if</bold>
<inline-formula id="pone.0177569.e039"><alternatives><graphic xlink:href="pone.0177569.e039.jpg" id="pone.0177569.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:mi>∅</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
<bold>then</bold></p>
      <p specific-use="line">12    <italic>B</italic> is marked “done”</p>
      <p specific-use="line">13   <bold>else</bold></p>
      <p specific-use="line">14    <inline-formula id="pone.0177569.e040"><alternatives><graphic xlink:href="pone.0177569.e040.jpg" id="pone.0177569.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mrow><mml:mi>B</mml:mi><mml:mo>←</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mo>∪</mml:mo><mml:mrow><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi></mml:mrow></mml:msub><mml:mi>E</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>;</p>
      <p specific-use="line">15    Update <inline-formula id="pone.0177569.e041"><alternatives><graphic xlink:href="pone.0177569.e041.jpg" id="pone.0177569.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mi mathvariant="script">B</mml:mi></mml:math></alternatives></inline-formula> to remove all <inline-formula id="pone.0177569.e042"><alternatives><graphic xlink:href="pone.0177569.e042.jpg" id="pone.0177569.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mrow><mml:mi>E</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">E</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></p>
      <p specific-use="line">16  <bold>until</bold>
<inline-formula id="pone.0177569.e043"><alternatives><graphic xlink:href="pone.0177569.e043.jpg" id="pone.0177569.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mrow><mml:mi mathvariant="script">E</mml:mi><mml:mo>=</mml:mo><mml:mi>∅</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>;</p>
      <p specific-use="line">17 <bold>while</bold>
<inline-formula id="pone.0177569.e044"><alternatives><graphic xlink:href="pone.0177569.e044.jpg" id="pone.0177569.e044g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M44"><mml:mrow><mml:mo>∃</mml:mo><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi><mml:mo>:</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>
<italic>is not marked “done”</italic>;</p>
      <p specific-use="line"> /* <monospace>Update D</monospace> */</p>
      <p specific-use="line">18 assign a distinct PGC to each <inline-formula id="pone.0177569.e045"><alternatives><graphic xlink:href="pone.0177569.e045.jpg" id="pone.0177569.e045g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M45"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, i.e., 〈<italic>PGC</italic><sub><italic>B</italic></sub>, <italic>B</italic>〉</p>
      <p specific-use="line">19 create <inline-formula id="pone.0177569.e046"><alternatives><graphic xlink:href="pone.0177569.e046.jpg" id="pone.0177569.e046g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M46"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>˜</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo>〈</mml:mo><mml:mi>P</mml:mi><mml:mi>G</mml:mi><mml:msub><mml:mi>C</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>〉</mml:mo></mml:mrow><mml:mo>:</mml:mo><mml:mspace width="0.166667em"/><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">B</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> ∎</p>
      <p><bold>Algorithm 4:</bold> CodingProteinGroups</p>
      <p specific-use="line"> <bold>Input:</bold>
<italic>F</italic><sub><italic>k</italic></sub> and the corresponding <italic>D</italic></p>
      <p specific-use="line"> <bold>Output:</bold>
<italic>CF</italic><sub><italic>k</italic></sub></p>
      <p specific-use="line">1 <bold>for</bold>
<italic>each entries</italic>
<italic>a</italic> =&lt; <italic>N</italic><sub><italic>a</italic></sub>, <italic>TopID</italic><sub><italic>a</italic></sub>, <italic>Acc</italic><sub><italic>a</italic></sub>, <italic>Prot</italic><sub><italic>a</italic></sub>, <italic>Gene</italic><sub><italic>a</italic></sub>, <inline-formula id="pone.0177569.e047"><alternatives><graphic xlink:href="pone.0177569.e047.jpg" id="pone.0177569.e047g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M47"><mml:msub><mml:mover accent="true"><mml:mrow><mml:mi>R</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo stretchy="true">¯</mml:mo></mml:mover><mml:mi>a</mml:mi></mml:msub></mml:math></alternatives></inline-formula> &gt; <italic>in</italic>
<italic>F</italic><sub><italic>k</italic></sub>
<bold>do</bold></p>
      <p specific-use="line">2  find the unique entry in <italic>D</italic>, such that Acc = Acc<sub><italic>a</italic></sub></p>
      <p specific-use="line">3  let PGC<sub><italic>a</italic></sub> be the protein group code corresponding to Acc<sub><italic>a</italic></sub> in <italic>D</italic></p>
      <p specific-use="line"> /* <monospace>code entries in files</monospace> */</p>
      <p specific-use="line">4 code entry <italic>a</italic> as <italic>c</italic><sub><italic>a</italic></sub> =&lt; PGC<sub><italic>a</italic></sub>, N<sub><italic>a</italic></sub>, TopID<sub><italic>a</italic></sub>, Acc<sub><italic>a</italic></sub>, Prot<sub><italic>a</italic></sub>, Gene<sub><italic>a</italic></sub>, <inline-formula id="pone.0177569.e048"><alternatives><graphic xlink:href="pone.0177569.e048.jpg" id="pone.0177569.e048g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M48"><mml:mrow><mml:msub><mml:mover><mml:mtext>Rest</mml:mtext><mml:mo>¯</mml:mo></mml:mover><mml:mi>a</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> &gt; <italic>CF</italic><sub><italic>k</italic></sub> = {<italic>c</italic><sub><italic>a</italic></sub>; for all <italic>a</italic> entries in <italic>F</italic><sub><italic>k</italic></sub>} ∎</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec015">
    <title>Conclusions</title>
    <p>PGCA offers a pre-processing tool required in many typical workflows of quantitative proteomics data analysis. PGCA allows linking lists of identified proteins organized by groups without making assumption about the presence or the order of proteins within each group. PGCA extends the idea of protein groups to a multiple-experimental setting enabling the connection and comparability of related groups of proteins. The user can tune the degree of connectivity by choosing different criteria within PGCA.</p>
    <p>Comparing the list of detected groups instead of individual proteins identities retains (all) the information contained in the groups maintaining the lists of non-redundant protein identities created within runs. In most cases, the comparison of these proteins is supported by the similarity of their sequences and the overlap among the lists of identified peptides from multiple experimental runs. Although the protein inference problem is well understood in the proteomics community, in this paper we characterize this problem and quantify its impact in subsequent quantitative and qualitative analyses based on multiple experimental runs.</p>
  </sec>
  <sec sec-type="supplementary-material" id="sec016">
    <title>Supporting information</title>
    <supplementary-material content-type="local-data" id="pone.0177569.s001">
      <label>S1 Fig</label>
      <caption>
        <title>Protein group example from dataset C in <xref ref-type="fig" rid="pone.0177569.g002">Fig 2</xref>.</title>
        <p><italic>i</italic>. Protein IPI00215894.1 is in IPI.HUMAN.v3.87 database (last version of IPI), its accession number in UniProt is P01042-2, and is the isoform of LMW of Kininogen-1 (KNG1). Protein IPI00797833.3 differs from IPI00215894.1 by only one amino acid and was removed from IPI.HUMAN.v3.87; <italic>ii</italic>. Protein IPI00032328.2 (in IPI.HUMAN.v3.87) corresponds to P01042-1 in UniProt, and is the isoform HMW of KNG1; <italic>iii</italic>. Alignment of the 3 disRnct proteins in the protein group by Clustal Omega v1.2.2.</p>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0177569.s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s002">
      <label>S2 Fig</label>
      <caption>
        <title>Protein group example from dataset C in <xref ref-type="fig" rid="pone.0177569.g003">Fig 3</xref>.</title>
        <p>Alignment of the 4 distinct proteins in the protein group by Clustal Omega v1.2.2.</p>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0177569.s002.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s003">
      <label>S1 Appendix</label>
      <caption>
        <title>Proof of properties.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0177569.s003.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s004">
      <label>S1 File</label>
      <caption>
        <title>Data files in dataset A.</title>
        <p>4 iTRAQ experiments with technical replicates.</p>
        <p>(ZIP)</p>
      </caption>
      <media xlink:href="pone.0177569.s004.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s005">
      <label>S2 File</label>
      <caption>
        <title>Data files in dataset B.</title>
        <p>12 spectral count-based experiments from 12 plasma samples.</p>
        <p>(ZIP)</p>
      </caption>
      <media xlink:href="pone.0177569.s005.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s006">
      <label>S3 File</label>
      <caption>
        <title>Data files in dataset C.</title>
        <p>65 iTRAQ experiments used to process samples from the BiT Heart Cohort.</p>
        <p>(ZIP)</p>
      </caption>
      <media xlink:href="pone.0177569.s006.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s007">
      <label>S4 File</label>
      <caption>
        <title>Data files used in the heart transplantation biomarkers study.</title>
        <p>Subset from dataset C.</p>
        <p>(ZIP)</p>
      </caption>
      <media xlink:href="pone.0177569.s007.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0177569.s008">
      <label>S5 File</label>
      <caption>
        <title>Data files in dataset D.</title>
        <p>Protein identification information from the muscular dystrophy biomarkers study.</p>
        <p>(ZIP)</p>
      </caption>
      <media xlink:href="pone.0177569.s008.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>We thank the University of Victoria Genome BC Proteomics Centre for their expertise in conducting the iTRAQ experiments. We are grateful with the Jain Foundation to share dataset D with us.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0177569.ref001">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Semanjski</surname><given-names>M</given-names></name>, <name><surname>Macek</surname><given-names>B</given-names></name>. <article-title>Shotgun proteomics of bacterial pathogens: advances, challenges and clinical implications</article-title>. <source>Expert Review of Proteomics</source>. <year>2016</year>;<volume>13</volume>(<issue>2</issue>):<fpage>139</fpage>–<lpage>156</lpage>. <pub-id pub-id-type="doi">10.1586/14789450.2016.1132168</pub-id><?supplied-pmid 26653908?><pub-id pub-id-type="pmid">26653908</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Lam</surname><given-names>MP</given-names></name>, <name><surname>Lau</surname><given-names>E</given-names></name>, <name><surname>Ng</surname><given-names>DC</given-names></name>, <name><surname>Wang</surname><given-names>D</given-names></name>, <name><surname>Ping</surname><given-names>P</given-names></name>. <article-title>Cardiovascular proteomics in the era of big data: experimental and computational advances</article-title>. <source>Clinical Proteomics</source>. <year>2016</year>;<volume>13</volume>(<issue>1</issue>):<fpage>23</fpage><pub-id pub-id-type="doi">10.1186/s12014-016-9124-y</pub-id><?supplied-pmid 27980500?><pub-id pub-id-type="pmid">27980500</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Nesvizhskii</surname><given-names>AI</given-names></name>, <name><surname>Aebersold</surname><given-names>R</given-names></name>. <article-title>Interpretation of Shotgun Proteomic Data: The Protein Inference Problem</article-title>. <source>Molecular and Cellular Proteomics</source>. <year>2005</year>;<volume>4</volume>(<issue>10</issue>):<fpage>1419</fpage>–<lpage>1440</lpage>. <pub-id pub-id-type="doi">10.1074/mcp.R500012-MCP200</pub-id><?supplied-pmid 16009968?><pub-id pub-id-type="pmid">16009968</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Eng</surname><given-names>JK</given-names></name>, <name><surname>McCormack</surname><given-names>AL</given-names></name>, <name><surname>Yates</surname><given-names>JR</given-names></name>. <article-title>An approach to correlate tandem mass spectral data of peptides with amino acid sequences in a protein database</article-title>. <source>Journal of the American Society for Mass Spectrometry</source>. <year>1994</year>;<volume>5</volume>(<issue>11</issue>):<fpage>976</fpage>–<lpage>989</lpage>. <pub-id pub-id-type="doi">10.1016/1044-0305(94)80016-2</pub-id><?supplied-pmid 24226387?><pub-id pub-id-type="pmid">24226387</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Perkins</surname><given-names>DN</given-names></name>, <name><surname>Pappin</surname><given-names>DJ</given-names></name>, <name><surname>Creasy</surname><given-names>DM</given-names></name>, <name><surname>Cottrell</surname><given-names>JS</given-names></name>. <article-title>Probability-based protein identification by searching sequence databases using mass spectrometry data</article-title>. <source>electrophoresis</source>. <year>1999</year>;<volume>20</volume>(<issue>18</issue>):<fpage>3551</fpage>–<lpage>3567</lpage>. <pub-id pub-id-type="doi">10.1002/(SICI)1522-2683(19991201)20:18&lt;3551::AID-ELPS3551&gt;3.0.CO;2-2</pub-id><?supplied-pmid 10612281?><pub-id pub-id-type="pmid">10612281</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Craig</surname><given-names>R</given-names></name>, <name><surname>Beavis</surname><given-names>RC</given-names></name>. <article-title>TANDEM: matching proteins with tandem mass spectra</article-title>. <source>Bioinformatics</source>. <year>2004</year>;<volume>20</volume>(<issue>9</issue>):<fpage>1466</fpage>–<lpage>1467</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bth092</pub-id><?supplied-pmid 14976030?><pub-id pub-id-type="pmid">14976030</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Hesse</surname><given-names>AM</given-names></name>, <name><surname>Dupierris</surname><given-names>V</given-names></name>, <name><surname>Adam</surname><given-names>C</given-names></name>, <name><surname>Court</surname><given-names>M</given-names></name>, <name><surname>Barthe</surname><given-names>D</given-names></name>, <name><surname>Emadali</surname><given-names>A</given-names></name>, <etal>et al</etal><article-title>hEIDI: An intuitive application tool to organize and treat large-scale proteomics data</article-title>. <source>Journal of Proteome Research</source>. <year>2016</year>;<volume>15</volume>(<issue>10</issue>):<fpage>3896</fpage>–<lpage>3903</lpage>. <pub-id pub-id-type="doi">10.1021/acs.jproteome.5b00853</pub-id><?supplied-pmid 27560970?><pub-id pub-id-type="pmid">27560970</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Nesvizhskii</surname><given-names>AI</given-names></name>, <name><surname>Vitek</surname><given-names>O</given-names></name>, <name><surname>Aebersold</surname><given-names>R</given-names></name>. <article-title>Analysis and validation of proteomic data generated by tandem mass spectrometry</article-title>. <source>Nature methods</source>. <year>2007</year>;<volume>4</volume>(<issue>10</issue>):<fpage>787</fpage>–<lpage>797</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth1088</pub-id><?supplied-pmid 17901868?><pub-id pub-id-type="pmid">17901868</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>T</given-names></name>, <name><surname>Gong</surname><given-names>H</given-names></name>, <name><surname>Yang</surname><given-names>C</given-names></name>, <name><surname>He</surname><given-names>Z</given-names></name>. <article-title>ProteinLasso: A Lasso regression approach to protein inference problem in shotgun proteomics</article-title>. <source>Computational Biology and Chemistry</source>. <year>2013</year>;<volume>43</volume>:<fpage>46</fpage>–<lpage>54</lpage>. <pub-id pub-id-type="doi">10.1016/j.compbiolchem.2012.12.008</pub-id><?supplied-pmid 23385215?><pub-id pub-id-type="pmid">23385215</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Huang</surname><given-names>T</given-names></name>, <name><surname>He</surname><given-names>Z</given-names></name>. <article-title>A linear programming model for protein inference problem in shotgun proteomics</article-title>. <source>Bioinformatics</source>. <year>2012</year>;<volume>28</volume>(<issue>22</issue>):<fpage>2956</fpage>–<lpage>2962</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/bts540</pub-id><?supplied-pmid 22954624?><pub-id pub-id-type="pmid">22954624</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Baldwin</surname><given-names>MA</given-names></name>. <article-title>Protein Identification by Mass Spectrometry: Issues to be Considered</article-title>. <source>Molecular and Cellular Proteomics</source>. <year>2004</year>;<volume>3</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>9</lpage>. <pub-id pub-id-type="doi">10.1074/mcp.R300012-MCP200</pub-id><?supplied-pmid 14608001?><pub-id pub-id-type="pmid">14608001</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Shilov</surname><given-names>IV</given-names></name>, <name><surname>Seymour</surname><given-names>SL</given-names></name>, <name><surname>Patel</surname><given-names>AA</given-names></name>, <name><surname>Loboda</surname><given-names>A</given-names></name>, <name><surname>Tang</surname><given-names>WH</given-names></name>, <name><surname>Keating</surname><given-names>SP</given-names></name>, <etal>et al</etal><article-title>The Paragon Algorithm, a next generation search engine that uses sequence temperature values and feature probabilities to identify peptides from tandem mass spectra</article-title>. <source>Molecular &amp; Cellular Proteomics</source>. <year>2007</year>;<volume>6</volume>(<issue>9</issue>):<fpage>1638</fpage>–<lpage>1655</lpage>. <pub-id pub-id-type="doi">10.1074/mcp.T600050-MCP200</pub-id><pub-id pub-id-type="pmid">17533153</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref013">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Nesvizhskii</surname><given-names>AI</given-names></name>, <name><surname>Keller</surname><given-names>A</given-names></name>, <name><surname>Kolker</surname><given-names>E</given-names></name>, <name><surname>Aebersold</surname><given-names>R</given-names></name>. <article-title>A statistical model for identifying proteins by tandem mass spectrometry</article-title>. <source>Analytical chemistry</source>. <year>2003</year>;<volume>75</volume>(<issue>17</issue>):<fpage>4646</fpage>–<lpage>4658</lpage>. <pub-id pub-id-type="doi">10.1021/ac0341261</pub-id><?supplied-pmid 14632076?><pub-id pub-id-type="pmid">14632076</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref014">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Searle</surname><given-names>BC</given-names></name>. <article-title>Scaffold: a bioinformatic tool for validating MS/MS-based proteomic studies</article-title>. <source>Proteomics</source>. <year>2010</year>;<volume>10</volume>(<issue>6</issue>):<fpage>1265</fpage>–<lpage>1269</lpage>. <pub-id pub-id-type="doi">10.1002/pmic.200900437</pub-id><?supplied-pmid 20077414?><pub-id pub-id-type="pmid">20077414</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref015">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Röst</surname><given-names>HL</given-names></name>, <name><surname>Liu</surname><given-names>Y</given-names></name>, <name><surname>D’Agostino</surname><given-names>G</given-names></name>, <name><surname>Zanella</surname><given-names>M</given-names></name>, <name><surname>Navarro</surname><given-names>P</given-names></name>, <name><surname>Rosenberger</surname><given-names>G</given-names></name>, <etal>et al</etal><article-title>TRIC: an automated alignment strategy for reproducible protein quantification in targeted proteomics</article-title>. <source>Nature methods</source>. <year>2016</year>;<volume>13</volume>(<issue>9</issue>):<fpage>777</fpage>–<lpage>783</lpage>. <pub-id pub-id-type="doi">10.1038/nmeth.3954</pub-id><?supplied-pmid 27479329?><pub-id pub-id-type="pmid">27479329</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref016">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Yang</surname><given-names>X</given-names></name>, <name><surname>Dondeti</surname><given-names>V</given-names></name>, <name><surname>Dezube</surname><given-names>R</given-names></name>, <name><surname>Maynard</surname><given-names>DM</given-names></name>, <name><surname>Geer</surname><given-names>LY</given-names></name>, <name><surname>Epstein</surname><given-names>J</given-names></name>, <etal>et al</etal><article-title>DBParser: web-based software for shotgun proteomic data analyses</article-title>. <source>Journal of proteome research</source>. <year>2004</year>;<volume>3</volume>(<issue>5</issue>):<fpage>1002</fpage>–<lpage>1008</lpage>. <pub-id pub-id-type="doi">10.1021/pr049920x</pub-id><?supplied-pmid 15473689?><pub-id pub-id-type="pmid">15473689</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref017">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Langella</surname><given-names>O</given-names></name>, <name><surname>Valot</surname><given-names>B</given-names></name>, <name><surname>Balliau</surname><given-names>T</given-names></name>, <name><surname>Blein-Nicolas</surname><given-names>M</given-names></name>, <name><surname>Bonhomme</surname><given-names>L</given-names></name>, <name><surname>Zivy</surname><given-names>M</given-names></name>. <article-title>X! TandemPipeline: a tool to manage sequence redundancy for protein inference and phosphosite identification</article-title>. <source>Journal of Proteome Research</source>. <year>2016</year>;<volume>16</volume>(<issue>2</issue>):<fpage>494</fpage>–<lpage>503</lpage>. <pub-id pub-id-type="doi">10.1021/acs.jproteome.6b00632</pub-id><?supplied-pmid 27990826?><pub-id pub-id-type="pmid">27990826</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref018">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Bradshaw</surname><given-names>RA</given-names></name>, <name><surname>Burlingame</surname><given-names>AL</given-names></name>, <name><surname>Carr</surname><given-names>S</given-names></name>, <name><surname>Aebersold</surname><given-names>R</given-names></name>. <article-title>Reporting Protein Identification Data The next Generation of Guidelines</article-title>. <source>Molecular &amp; Cellular Proteomics</source>. <year>2006</year>;<volume>5</volume>(<issue>5</issue>):<fpage>787</fpage>–<lpage>788</lpage>. <pub-id pub-id-type="doi">10.1074/mcp.E600005-MCP200</pub-id><pub-id pub-id-type="pmid">16670253</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref019">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Freue</surname><given-names>GVC</given-names></name>, <name><surname>Sasaki</surname><given-names>M</given-names></name>, <name><surname>Meredith</surname><given-names>A</given-names></name>, <name><surname>Günther</surname><given-names>OP</given-names></name>, <name><surname>Bergman</surname><given-names>A</given-names></name>, <name><surname>Takhar</surname><given-names>M</given-names></name>, <etal>et al</etal><article-title>Proteomic signatures in plasma during early acute renal allograft rejection</article-title>. <source>Molecular &amp; Cellular Proteomics</source>. <year>2010</year>;<volume>9</volume>(<issue>9</issue>):<fpage>1954</fpage>–<lpage>1967</lpage>. <pub-id pub-id-type="doi">10.1074/mcp.M110.000554</pub-id><pub-id pub-id-type="pmid">20501940</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref020">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Cohen Freue</surname><given-names>GV</given-names></name>, <name><surname>Meredith</surname><given-names>A</given-names></name>, <name><surname>Smith</surname><given-names>D</given-names></name>, <name><surname>Bergman</surname><given-names>A</given-names></name>, <name><surname>Sasaki</surname><given-names>M</given-names></name>, <name><surname>Lam</surname><given-names>KKY</given-names></name>, <etal>et al</etal><article-title>Computational Biomarker Pipeline from Discovery to Clinical Implementation: Plasma Proteomic Biomarkers for Cardiac Transplantation</article-title>. <source>PLoS Comput Biol</source>. <year>2013</year>;<volume>9</volume>(<issue>4</issue>):<fpage>e1002963</fpage><pub-id pub-id-type="doi">10.1371/journal.pcbi.1002963</pub-id><?supplied-pmid 23592955?><pub-id pub-id-type="pmid">23592955</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref021">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>Chong</surname><given-names>PK</given-names></name>, <name><surname>Wright</surname><given-names>PC</given-names></name>. <article-title>Identification and Characterization of the Sulfolobus s olfataricus P2 Proteome</article-title>. <source>Journal of proteome research</source>. <year>2005</year>;<volume>4</volume>(<issue>5</issue>):<fpage>1789</fpage>–<lpage>1798</lpage>. <pub-id pub-id-type="doi">10.1021/pr0501214</pub-id><?supplied-pmid 16212434?><pub-id pub-id-type="pmid">16212434</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0177569.ref022">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Kersey</surname><given-names>PJ</given-names></name>, <name><surname>Duarte</surname><given-names>J</given-names></name>, <name><surname>Williams</surname><given-names>A</given-names></name>, <name><surname>Karavidopoulou</surname><given-names>Y</given-names></name>, <name><surname>Birney</surname><given-names>E</given-names></name>, <name><surname>Apweiler</surname><given-names>R</given-names></name>. <article-title>Technical Brief The International Protein Index: An integrated database for proteomics experiments</article-title>. <source>Proteomics</source>. <year>2004</year>;<volume>4</volume>(<issue>1985</issue>):<fpage>1988</fpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
