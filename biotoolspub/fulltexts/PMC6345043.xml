<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6345043</article-id>
    <article-id pub-id-type="publisher-id">2592</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-018-2592-5</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>IMOS: improved Meta-aligner and Minimap2 On Spark</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-4675-9111</contrib-id>
        <name>
          <surname>Hadadian Nejad Yousefi</surname>
          <given-names>Mostafa</given-names>
        </name>
        <address>
          <email>hadadian@ce.sharif.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Goudarzi</surname>
          <given-names>Maziar</given-names>
        </name>
        <address>
          <email>goudarzi@sharif.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Motahari</surname>
          <given-names>Seyed Abolfazl</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 0740 9747</institution-id><institution-id institution-id-type="GRID">grid.412553.4</institution-id><institution>Department of Computer Engineering, Sharif University of Technology, </institution></institution-wrap>Azadi, Tehran, Iran </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>1</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>1</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>51</elocation-id>
    <history>
      <date date-type="received">
        <day>23</day>
        <month>8</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>27</day>
        <month>12</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Long reads provide valuable information regarding the sequence composition of genomes. Long reads are usually very noisy which renders their alignments on the reference genome a daunting task. It may take days to process datasets enough to sequence a human genome on a single node. Hence, it is of primary importance to have an aligner which can operate on distributed clusters of computers with high performance in accuracy and speed.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this paper, we presented IMOS, an aligner for mapping noisy long reads to the reference genome. It can be used on a single node as well as on distributed nodes. In its single-node mode, IMOS is an Improved version of Meta-aligner (IM) enhancing both its accuracy and speed. IM is up to 6x faster than the original Meta-aligner. It is also implemented to run IM and Minimap2 on Apache Spark for deploying on a cluster of nodes. Moreover, multi-node IMOS is faster than SparkBWA while executing both IM (1.5x) and Minimap2 (25x).</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>In this paper, we purposed an architecture for mapping long reads to a reference. Due to its implementation, IMOS speed can increase almost linearly with respect to the number of nodes in a cluster. Also, it is a multi-platform application able to operate on Linux, Windows, and macOS.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Aligner</kwd>
      <kwd>Long read</kwd>
      <kwd>Big data</kwd>
      <kwd>Distributed processing</kwd>
      <kwd>PacBio</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Long reads are usually very noisy having multiple substitutions, insertions, and deletions, c.f. PacBio RS II [<xref ref-type="bibr" rid="CR1">1</xref>] and Nanopore MinION [<xref ref-type="bibr" rid="CR2">2</xref>]. At the same time, long reads are valuable in bridging repeat regions which provide information not acquired by short reads. They can also be used to identify many structural variations such as translocations, duplication, etc. To exploit the full information embedded in such reads, one requires to align them accurately to the reference genome.</p>
    <p>Several long read aligners are developed in the past. Each aligner has its own capability. The Pacific Bioscience, the company which makes PacBio RS II sequencer, presented BLASR [<xref ref-type="bibr" rid="CR3">3</xref>] for aligning Pacbio long reads. It has good accuracy by reporting several locations with different scores for each read. Despite the costs (e.g. time, energy, storage) paid for finding every possible location, most of them have the least importance for downstream analysis due to the low alignment score. Heng Li presented Minimap2 [<xref ref-type="bibr" rid="CR4">4</xref>] as the successor of his prior work BWA-MEM [<xref ref-type="bibr" rid="CR5">5</xref>]. It is a very fast and accurate long read aligner. In addition to the great ideas including using minimizers [<xref ref-type="bibr" rid="CR6">6</xref>], it is implemented very efficiently. Sedlazeck et al. [<xref ref-type="bibr" rid="CR7">7</xref>] proposed a long read aligner which produces alignments optimized for structural variation detection. Meta-aligner [<xref ref-type="bibr" rid="CR8">8</xref>] is designed based on statistical features of the reference genome. The main concern of Meta-aligner is to align all reads by respecting the integrity of them with no clipping. This conservative attempt makes it more accurate but rather slow in mapping. Therefore, we set an aim of this paper to improve both speed and accuracy of Meta-aligner in order to have a fast and accurate long read aligner not restricted to a specific OS.</p>
    <p>With the ever-increasing size of genomics data and the growing demands for sequencing, ordinary single node software would not be able to satisfy all the computing needs where they last in order of days for a full run. Distributed processing as a cost-efficient solution to speed up the computations could be a good feasible choice in practice compared to other solutions such as using hardware acceleration (e.g. FPGA and ASIC). There are some aligners designed to work on distributed platforms. DistMap [<xref ref-type="bibr" rid="CR9">9</xref>] is a distributed software deploying nine short read aligners on an Apache Hadoop [<xref ref-type="bibr" rid="CR10">10</xref>] cluster. Abuin et al. developed two applications, called BigBWA [<xref ref-type="bibr" rid="CR11">11</xref>] and SparkBWA [<xref ref-type="bibr" rid="CR12">12</xref>] that distribute BWA on both Apache Hadoop and Apache Spark [<xref ref-type="bibr" rid="CR13">13</xref>]. As mentioned by Abuin <italic>et al</italic> in [<xref ref-type="bibr" rid="CR12">12</xref>], SparkBWA is the successor of BigBWA and provide a better performance. None of the prior works pay attention to hardware-aware optimizations. Another aim of this paper is to develop a working application for aligning long reads that outperforms current rivals and to present an efficient framework to build an application that could be easily upgradeable.</p>
    <p>Meta-aligner developed in our lab uses genomes statistics to achieve higher performance. However, in its original form, it is not competitive to other aligners. Therefore, we propose some improvements that make it faster and more reliable in this paper. We also re-develop it and apply the improvements using Java. Although it can handle large datasets, it is also suitable for aligning small datasets without changing the OS. For the distributed working mode, we use Apache Spark, which is a sophisticated big data processing platform recently developed and widely adopted for large-scale applications. We propose and develop a distributed architecture for aligning long reads to a reference genome. We select our improved Meta-aligner(IM) and Minimap2 for deploying on the proposed framework.This shows that our framework is general and can be adopted by other aligners as well.</p>
  </sec>
  <sec id="Sec2">
    <title>Single node implementation</title>
    <p>In our single node implementation, Meta-aligner is improved in five significant ways. In this section, we describe the details of improvements made on Meta-aligner. The first two makes the mapping more accurate, while the others three accelerates the program. Moreover, these upgrades also lead to an output more comfortable for downstream analysis. Then, we applied these improvements and implemented a new aligner in Java language. To the best of our knowledge, IMOS is the first long read aligner in Java. It is suitable for other contributors to use it in multi-platforms applications.</p>
    <sec id="Sec3">
      <title>Get feedback from the local alignment algorithm</title>
      <p>We use feedback from the local alignment algorithm after mapping each read to gain higher accuracy by: (i) verifying that the edit distance is not more than expected from the input specification, and (ii) making the reported position more precise. Figures <xref rid="Fig1" ref-type="fig">1</xref> and <xref rid="Fig2" ref-type="fig">2</xref> show the flowcharts of computing procedure on a read for Meta-aligner and IMOS, respectively. Meta-aligner aligns all reads and then run local alignment. We changed the procedure by getting feedback from the local alignment algorithm which is based on the Smith-Waterman (SW) algorithm [<xref ref-type="bibr" rid="CR14">14</xref>]. Consequently, we can compare the edit distance reported by SW and what we expect from input data to find out whether the read correctly assigned or not. Also, to avoid wasting time on the low quality or hard-to-map reads, we defined a threshold (Th) for the number of attempts at aligning a read.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Meta-aligner: flowchart of computing procedure on a read</p></caption><graphic xlink:href="12859_2018_2592_Fig1_HTML" id="MO1"/></fig>
<fig id="Fig2"><label>Fig. 2</label><caption><p>IMOS: flowchart of computing procedure on a read</p></caption><graphic xlink:href="12859_2018_2592_Fig2_HTML" id="MO2"/></fig></p>
      <p>Since in a long read, there are lots of insertions and deletions the reported position based on the information of seeds could be different from the exact position of the long read. For instance, a long read split into 20 seeds of length 40 base pairs. If we report the position of the long read based on the information of seeds 19 and 20, indels in 18 previous seed are implicitly ignored. Thus, the reported position might differ about 100 base pairs (15% of 18×40) from the exact position. Therefore, we use the information of the local alignment algorithm to refine the position.</p>
    </sec>
    <sec id="Sec4">
      <title>SureMap instead of bowtie</title>
      <p>Meta-aligner used bowtie [<xref ref-type="bibr" rid="CR15">15</xref><italic>] which considers no gap while mapping seeds to the reference genome. On the other hand, we used SureMap [</italic><xref ref-type="bibr" rid="CR16">16</xref>] instead of Bowtie because it can handle indels for short reads. Therefore, SureMap can extract more accurate information from a seed. Hence, this improvement leads to better accuracy.</p>
    </sec>
    <sec id="Sec5">
      <title>Integrated design</title>
      <p>The Meta-aligner structure has a top-level procedure that incorporates a prebuilt short read aligner in order to map seeds of a long read. These two parties communicate through storing input and output on the disk. The top-level procedure splits the reads into a number of seeds and writes them into several files. For each file, it calls the short read aligner with these files as input. Then, the short read aligner loads the input file from the disk to the main memory and writes down the output to the disk again. Finally, the top-level procedure loads the output file of short read aligner from the disk to the main memory and maps long reads with respect to the mapped short reads. This structure has two issues that degrade the performance of the mapping, I) high storage usage as a low-speed unit, and II) additive initialization time of the short read aligner with each call.</p>
      <p>We re-implemented both SureMap and the top-level procedure in Java. By integrating them, they work as one unit in a same memory address space. This removes any storage or initialization overheads.</p>
    </sec>
    <sec id="Sec6">
      <title>Change traversing in the alignment stage</title>
      <p>Meta-aligner has two main stages, alignment and assignment stages. In the alignment stage, it tries to find the position of a read by finding two seeds that mapped uniquely. If a read did not align in this stage, in the assignment stage, it tries to find the position of the long read regarding every possible position of every seed. Their results show that a large fraction of the dataset is mapped in the alignment stage with a shorter time per read and a small fraction have a long processing time per read in the assignment stage.</p>
      <p>Meta-aligner traverses seeds with a brute-force algorithm. We use a randomized method to gain a higher speed. Our experiments show that two adjacent seeds have a high chance to be in a same region (random or repeat region). A random (repeat) region is a region or interval in the sequence of DNA that a read can (cannot) be uniquely mapped in it. Meta-aligner traverses seeds sequentially from first to last seed. Therefore, if a significant portion of a read located in a repeat region, Meta-aligner alignment stage will last long while computing seeds that are in repeat regions. We use a randomized method to gain a higher speed. Our traverse method has two states: 
<list list-type="order"><list-item><p>If the seed is in a repeat region, next seed will be one random seed among remaining seeds.</p></list-item><list-item><p>If the seed is in a random region, next seed will be one random un-traversed seed among adjacent ones unless both are traversed. In the latter case, next seed will be one random seed among remaining seeds.</p></list-item></list></p>
      <p>Algorithms 1 and 2 show the traverse method of the original Meta-aligner and IMOS, respectively. It is evident that this improvement has no effect on accuracy and only increase the speed of the traverse method on average.</p>
      <p>
        <graphic position="anchor" xlink:href="12859_2018_2592_Figa_HTML" id="MO3"/>
      </p>
      <p>
        <graphic position="anchor" xlink:href="12859_2018_2592_Figb_HTML" id="MO4"/>
      </p>
    </sec>
    <sec id="Sec7">
      <title>Efficient search in the assignment stage</title>
      <p>After a read did not map in the alignment stage, the original Meta-aligner performs another fragmentation operation which splits a read into a number of seeds. In other words, it adds new seeds of the long read as shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>. The primitive seeds are the result of the first fragmentation done in the alignment stage and the overlapping seeds are the outcome of the new fragmentation in the assignment stage. The original Meta-aligner computes every seed (primitive and overlapping seeds) in its assignment stage. We do not process seeds that are not informative so as to gain a higher speed. Since primitive seeds computed once, they are less informative in the assignment stage. Also, It is possible to find two seeds that can be uniquely mapped among newly added seeds. Therefore, we only compute newly added seeds which are more informative.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Meta-aligner fragmentation</p></caption><graphic xlink:href="12859_2018_2592_Fig3_HTML" id="MO5"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Distributed (Spark) implementation</title>
    <p>In the best case, the performance of single machines can be doubled in every 1.5 years with respect to Moore’s law. Moreover, a two times faster machine is four times more expensive while distributed systems cost to performance ratio is almost constant. For having an unlimited (theoretically) processing power, we need a distributed system that allows us to double the performance every time by doubling the number of machines. Since our application works with a huge amount of data and processing of this amount of data lasts long, we need a distributed system to do jobs in a reasonable time.</p>
    <p>In this section, first, the reasons why we chose Apache Spark and its introduction are presented. Our cluster design comes after that. Then, the technical implementation issues are explained and the solutions are presented. Afterward, an overview of our worker node design is presented. Finally, after discussing our batch implementation thoroughly, a summary of streaming implementation is presented.</p>
    <sec id="Sec9">
      <title>Platform</title>
      <p>We had two directions I) implement our own platform, II) use a matured distributed processing platform. We chose the second option because: 
<list list-type="bullet"><list-item><p>Implementing our own platform is time-consuming.</p></list-item><list-item><p>It is difficult to implement a platform that considers every kind of failure.</p></list-item><list-item><p>It is hard to relay on an immature distributer.</p></list-item></list></p>
      <p>To determine which platform suits the application well, we consider the fact that aligning reads to a reference is intrinsically a batch job. Therefore, the platform should provide a high throughput in order to reduce the processing time. In addition, the runtime should scale almost linearly with respect to the number of nodes in the cluster.</p>
      <p>After considering a number of different choices for deploying IM and Minimap2 in a distributed environment, we chose Apache Spark [<xref ref-type="bibr" rid="CR13">13</xref><italic>] among Apache big data processing platforms [</italic><xref ref-type="bibr" rid="CR10">10</xref><italic>,</italic><xref ref-type="bibr" rid="CR13">13</xref><italic>,</italic><xref ref-type="bibr" rid="CR17">17</xref><italic>–</italic><xref ref-type="bibr" rid="CR19">19</xref><italic>]. It is an open source big data processing framework for distributed environments. It can work on a cluster of computing machines. According to results of evaluations done in [</italic><xref ref-type="bibr" rid="CR20">20</xref><italic>,</italic><xref ref-type="bibr" rid="CR21">21</xref>] which analyzed the performance of big data platforms through a number of standard benchmarks, Apache Spark provides better throughput and scalability in both batch and stream processing. As a summary, the main reasons for our choice are described as follows: 
<list list-type="bullet"><list-item><p><bold>Open Source:</bold> Spark is open source and has an active community which is growing and contributing rapidly.</p></list-item><list-item><p><bold>Fast:</bold> Spark is very fast and up to 100 times faster than its predecessors like Apache Hadoop [<xref ref-type="bibr" rid="CR10">10</xref>] due to its implementation. It improves in many aspects such as storage and fault-tolerant mechanism.</p></list-item><list-item><p><bold>Highly Scalable:</bold> Spark tries to reduce runtime overheads in order to reach a linear speed up related to the number of nodes in the cluster.</p></list-item><list-item><p><bold>Unified Platform:</bold> It offers a wide range of services for different applications and implementations. In other words, it is an all-in-one platform. For instance, an application which is designed for batch processing can be re-designed for stream processing with a little effort. This greatly speeds up developing and maintenance of an application.</p></list-item><list-item><p><bold>Easy to Develop:</bold> There is no need to involve developers with low-level system controls such as managing the cluster. The developer needs only to concentrate on designing the algorithms and the program. This ease brings focus and concentration to developers for innovation.</p></list-item><list-item><p><bold>Independent Design:</bold> Each component of Apache Spark like the cluster manager can be customized independently.</p></list-item></list></p>
      <p>Figure <xref rid="Fig4" ref-type="fig">4</xref> shows the architecture of Apache Spark which is master/slave. The driver runs the main function of applications and creates a SparkContext for each application which coordinates the independent set of processes of the parent application. The SparkContext can be connected to a cluster manager which could be one of Apache Spark Standalone, Apache Hadoop Yarn [<xref ref-type="bibr" rid="CR22">22</xref><italic>], Apache Mesos [</italic><xref ref-type="bibr" rid="CR23">23</xref><italic>], and Google Kubernetes [</italic><xref ref-type="bibr" rid="CR24">24</xref>]. The cluster manager connects the master node to workers and allocates the required resources on the cluster to the application. Each worker node runs an executor process which is the unit responsible for computing and storing operations. It runs and coordinates tasks. Tasks are the smallest operational components that can be run in parallel. A set of tasks form a job and a set of jobs form an application. The SparkContext sends tasks to executors. Each rectangle is a component that could be placed on any networked machine. For instance, a driver and a worker can be placed on a same machine or two distinct machines.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Apache Spark architecture</p></caption><graphic xlink:href="12859_2018_2592_Fig4_HTML" id="MO6"/></fig></p>
      <p>Apache Spark can work with Hadoop Distributed File System (HDFS) [<xref ref-type="bibr" rid="CR25">25</xref>] which is a highly fault-tolerant distributed file system. It is designed to work on low-cost commodity hardware. Similar to Spark, HDFS also has a master/slave architecture. An HDFS cluster has a NameNode as the master which manages the file system and controls the access to files. Each cluster may have a number of DataNodes as slaves that store a file as a number of blocks and execute file operations such as opening a file.</p>
    </sec>
    <sec id="Sec10">
      <title>Cluster design</title>
      <p>We implemented our improved Meta-aligner on the core Spark which is the batch processing engine of Apache Spark. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the architecture of IMOS where the rounded rectangle and each rounded square represent a machine. Spark Driver, HDFS NameNode, and Cluster Manager which are the coordinators are placed on the master node. Since the coordinators do jobs such as scheduling and allocation periodically, it is better to have the master node near the workers. Therefore, we placed all of them on the same local area network (LAN). If a user wants to submit an application remotely, it is better to connect to the master node through SSH or something similar instead of placing the coordinators on the user machine. On every slave node, there are a Spark executor, an HDFS DataNode, and an IMOS worker which is an interface that can run either IM or Minimap2. The workflow of our design is such that the system first distributes the long reads among processing nodes using HDFS and then employs Spark to call the instances of IMOS worker where the data resides. Afterward, the IMOS worker runs an aligner among IM and Minimap2 to start mapping. Finally, The results can then be written on HDFS for being prepared for any downstream analysis or can be sent to the master node for being aggregated.
<fig id="Fig5"><label>Fig. 5</label><caption><p>IMOS architecture. A master node (rounded rectangle) with a number of slaves ones (rounded square). Spark Driver, HDFS NameNode, and the cluster manager are placed on the master node. Each slave node contains a HDFS DataNode, a Spark Executor, and an instance of IMOS worker. Spark executor communicates with DataNode and IMOS worker through storage disk and socket as the medium, respectively. Components of Spark, HDFS, and our design are distinguished using slate gray, blue, and green colors, respectively</p></caption><graphic xlink:href="12859_2018_2592_Fig5_HTML" id="MO7"/></fig></p>
    </sec>
    <sec id="Sec11">
      <title>IMOS worker</title>
      <p>IMOS worker is designed to independent of the underlying aligner. It is an interface that bridges the Spark executor and the aligner. At the startup of the IMOS worker, the user defines its desired aligner. Then, the application runs the aligner in the modified mode as its child process. After the initialization has been done, IMOS worker starts listening to the Spark executor and takes the data with commands and passes them to the aligner. Finally, IMOS worker returns back the results as soon as the aligner’s job is completed.</p>
      <p>In this paper, Meta-aligner and Minimap2 are modified to work with IMOS worker. Other aligners can be adopted similarly.</p>
    </sec>
    <sec id="Sec12">
      <title>Load balancing</title>
      <p>Load balancing is the key to reach the full potential of a distributed system. The finish time of a distributed job is measured by the time that every task is done.</p>
      <p>We presented a load balancer that works on top of a HDFS. Its core concept is to prepare the input file such that the characteristics of each chunk of data be similar when the HDFS distributes them across the cluster nodes. Therefore, there is no need to perform any change in the HDFS NameNode. Moreover, this can be done independently as a data preparation step. Thus, the running time of load balancing is not an issue since it is a static task. However, we provided a linear greedy solution that works near optimal.</p>
      <p>Our analyses show that the two features of a FastQ file which have the most influence on the processing time are the average length and the number of reads. In addition, these two features can be extracted easily. As a big picture, we scan the FastQ file and group every <italic>N</italic> reads where <italic>N</italic> is the number of nodes in the cluster. After the creation of each group, the reads will be sorted by the length. Then, we distribute them one-by-one in a Round-Robin manner to the nodes such that a node receives the read with maximum length once in every <italic>N</italic> distributions.</p>
      <p>Since the whole FastQ file consisting <italic>R</italic> reads is needed to be scanned and there is a sort with the order of <italic>N</italic> log<italic>N</italic> for every <italic>R</italic>/<italic>N</italic> groups, the time complexity of the load balancer is <italic>O</italic>(<italic>R</italic> log<italic>N</italic>). As the number of nodes is much smaller than the number of reads, it can be considered as a constant and be neglected.</p>
    </sec>
    <sec id="Sec13">
      <title>Implementation issues</title>
      <p>We faced some serious concerns while trying to implement our design efficiently. These concerns are explained in the following.</p>
      <sec id="Sec14">
        <title>Minimize storage usage</title>
        <p>The key to Spark performance is its in-memory processing technique. It keeps track of data through a number of operations by storing the intermediate data reliably in the main memory. Accordingly, to conform the Spark architecture, the first question is how to implement our design to minimize the usage of storage as a low-speed unit in the system. One of the best high-performance designs for this application is that the reference files remain in the main memory for the entire application runtime to avoid storage-to-memory communication overheads. Apache Spark provides two type of variable for this purpose: <italic>Broadcast Variables</italic> and <italic>Accumulators</italic>. Both have problems that make them inappropriate for our design. <italic>Broadcast variables</italic> are broadcasted to every worker nodes in the application initialization. This has four main issues: 
<list list-type="bullet"><list-item><p><bold>High Network Usage:</bold> Broadcasting this large amount of data over the network will use the network inefficiently.</p></list-item><list-item><p><bold>Initialization Time:</bold> For each application, there will be an initialization time to broadcast the reference files.</p></list-item><list-item><p><bold>Node Failure:</bold> Each time a node faces a failure, the data must be broadcasted again.</p></list-item><list-item><p><bold>Memory Overhead:</bold> In Spark implementation, a broadcast variable is accompanied with a large meta-data. Our experiments show that an 11GB variable at the host occupies 17GB of the guest main memory.</p></list-item></list></p>
        <p>On the other hand, <italic>accumulators</italic> can only be defined as primitives such as Integer. Hence, none of these options solve the problem of maintaining the reference files in the main memory. Therefore, we used another strategy.</p>
        <p>Since the single node implementation of almost every aligner keeps the reference files in the main memory for the whole runtime, we decided to place an instance of the IMOS worker in every worker nodes as an independent application working with spark through a memory-to-memory medium. We chose socket programming on localhost as the safest medium which also provides an ultra-fast communication speed.</p>
        <p>In this implementation, an instance of the IMOS worker runs at the worker node setup-time once at the cluster setup. The Spark executor, IMOS worker, and the selected aligner communicating through socket programming while the only storage usage is loading the data from HDFS by the Spark executor. In addition to solving the aforementioned problems of <italic>broadcast variables</italic> and <italic>accumulators</italic>, this design benefits from I) high-speed memory-to-memory transactions instead of using storage disk as the medium, II) the initialization of the aligner done once for multiple jobs.</p>
      </sec>
      <sec id="Sec15">
        <title>Data structure</title>
        <p>The second concern is about the data Structure. What data Structure is provided by Apache Spark and how to use it most efficiently. Apache Spark core concept is Resilient Distributed Datasets (RDD) which is a distributed collection of data that can be operated in parallel. RDD is not the data, it contains a number of partitions storing data. Further, an interesting feature is that it recovers automatically from failure. An RDD can be created by parallelization of a dataset in the driver program or loading from a file system like HDFS. In our design, an RDD is created by loading the input FastQ file from HDFS.</p>
        <p>A possible question is that why partitioning is needed. Loading every record from the file system into a single partition requires a large amount of space in the main memory, but with this technique, records can be transferred to the main memory in a partition-by-partition quantization. Since the processing power is limited which obviously cannot process every record in parallel, it is enough to read a sufficient amount of data each time to make sure that the CPU is fully utilized. In our design, the partitions size is set to 64MB which is equals to HDFS block size. This size setting avoids repartitioning in order to save time. Moreover, 64MB is approximately the required size to store 4750 long reads with the average length of 7000 base pairs which is large enough to ensure that the CPU always has reads to process. Of course, this only affects the efficiency of memory usage with negligible effect on CPU time.</p>
        <p>RDDs can perform two sets of operations: Transformations and Actions. Transformations create a new RDD from an existing one. Actions collect and return the values stored in the RDD to the driver program. All transformations are lazy which means they will not compute anything until an action requires the result of them. This infers that there is no need to worry about memory usage while chaining a number of transformations.</p>
        <p>In our design, IMOS should create an RDD containing reads from HDFS. Then, it should send read mapping task with a transformation and return the mapped information with an action. There are two suitable transformations for read mapping: <italic>map()</italic> and <italic>mapPartitions()</italic> methods. The former operates on elements of the RDD while the latter operates on a partition (list) of elements from the RDD. We have decided to choose <italic>mapPartitions()</italic> because of two reasons: 
<list list-type="bullet"><list-item><p><bold>Reduce Overheads:</bold> As mentioned earlier, we need to send reads from Apache Spark executor to the aligner through a localhost connection. Sending reads in burst could use network efficiently. Still, An ideal high-performance design is to keep CPU always working at maximum utilization. Using batch data reduces I/O overheads leading to a better CPU utilization.</p></list-item><list-item><p><bold>Custom Thread Control Mechanism:</bold> Using <italic>map()</italic> method, Spark creates a thread for each read. Creating and killing threads in a high number would waste a lot of time. Furthermore, Spark may create more threads than the number of physical cores which is not recommended for a high-performance design due to the race for shared resources and the high number of context switches. It is noteworthy that there are also better opportunities for maximizing CPU usage by customizing threads when reads arrive in batch.</p></list-item></list></p>
      </sec>
      <sec id="Sec16">
        <title>Controlling threads</title>
        <p>As stated above, we need to control the threads. So, the questions are “Which implementation of threads suits our design?” and “How to implement threads to work efficiently together providing mutual exclusion as there are many shared resources?”. We designed our own thread control mechanism. Instead of creating a thread for each read, we create a number of threads equal to the number of cores and assign each thread to a core. Moreover, we stepped farther and used Java Thread Pool instead of the ordinary threads. It enables us to use wake/sleep instead of create/kill to save time. The <italic>mapPartitions()</italic> method gives a list containing the reads. We divide the list into the number of threads and assign each part to a thread. For maximizing the CPU usage, every thread must start and end together. Therefore, we need load balancing to maximize utilization. We distributed reads with respect to the length of reads such that the average read length of every part is almost equal. Since our distribution is not perfect, we designed a race-free double end queue for storing the reads that are assigned to each thread. When a thread finishes the processing of its own queue, it joins a thread which has more remaining reads in its queue.</p>
        <p>Spark may call <italic>mapPartitions()</italic> method more than once at the same time. If we create a number of threads with each call, there might be more threads than the number of cores. As we discussed earlier, this is not pleasant for a high-performance design. So, used a semaphore-based mechanism to ensure that only one partition is being processed at each time.</p>
      </sec>
    </sec>
    <sec id="Sec17">
      <title>Worker node design</title>
      <p>Figure <xref rid="Fig6" ref-type="fig">6</xref> shows the workflow of each worker node in our design. As it is shown, there are four entities with separate memory address space: 
<list list-type="bullet"><list-item><p><bold>HDFS DataNode:</bold> The only entity that always uses storage is DataNode that stores a chunk of the input FastQ file.
<fig id="Fig6"><label>Fig. 6</label><caption><p>Worker node workflow. Horizontal and vertical line separates different hardware and software units, respectively</p></caption><graphic xlink:href="12859_2018_2592_Fig6_HTML" id="MO8"/></fig></p></list-item><list-item><p><bold>Spark Executor:</bold> The spark executor works as a manager to divide the chunk into a number of partitions that formed an RDD and transfers them to the aligner for being processed. It also calls a <italic>mapPartitions()</italic> function on each partition.</p></list-item><list-item><p><bold>IMOS Worker:</bold> It is an interface between the Spark executor and the aligner. There is also a lock to control the parallelization of the <italic>mapPartitions()</italic> functions.</p></list-item><list-item><p><bold>Aligner:</bold> It is shown as a black box since it could be any aligner.</p></list-item></list></p>
      <p>The Scenarios for the cases that either the IM or Minimap2 is selected as the aligner are a little bit different where we will elaborate more in the sequel.</p>
      <p>First, the Spark executor reads the chunk from HDFS. For the IM case, it is the only storage-to-memory communication. The Spark executor stores the FastQ file as an RDD in the main memory. The RDD contains a number of partitions where each of them is a list that contains a part of the reads. As mentioned above, a <italic>mapPartitions()</italic> function is called on each partition. Each <italic>mapPartitions()</italic> sends a request to the IMOS worker to get the lock and use the aligner. The lock grants functions in First-Come-First-Served order like a queue. Then, the granted function transfers the list of reads that stored in the partition to the memory space of IMOS Worker. Unlike the IM case that IMOS worker passes reads through socket-programming, IMOS worker uses storage in the Minimap2 case. After the transfer is completed the IMOS worker calls the aligner to start mapping the reads. When the mapping process is finished, the aligner returns the results to the IMOS worker. Similarly in both cases, returning the results goes through a memory-to-memory medium. Afterward, the granted function gets the result back from IMOS worker and releases the lock. Finally, the granted function can send the results to the Spark Driver or store them on the HDFS DataNode. This procedure repeats until every partition in every RDD is processed.</p>
    </sec>
    <sec id="Sec18">
      <title>Apache Spark streaming implementation</title>
      <p>Last but not least, we also implemented our improved Meta-aligner on the Spark Streaming. The Spark streaming is an extension to the core Spark. It can receive streams from brokers such as Apache Kafka [<xref ref-type="bibr" rid="CR26">26</xref>]. The streams arrive in a record by record quantization. In every specified time interval, the spark streaming gets all the arrived records and organize them together in a bundle called micro-batch. Each micro-batch will be passed to the core Spark and treated like a normal batch. The communication and processing time could overlap each other by using stream processing techniques. Therefore, at least theoretically, it could reduce the latency and total processing time of each dataset. We discussed it with more details in the Discussion section.</p>
    </sec>
  </sec>
  <sec id="Sec19" sec-type="results">
    <title>Results</title>
    <sec id="Sec20">
      <title>Experimental setup</title>
      <p>We performed two sets of experiments to evaluate the performance of IMOS in single node and distributed modes. In the single-node, we have used a server with a Intel Xeon E5-2630 v3 processor having 8 cores and 32 GB of RAM operating on Ubuntu 14.04 LTS. We used Apache Spark 2.2.0 for both batch and streaming experiments. In the distributed mode, we deployed an apache spark cluster of 10 nodes with one driver node and 9 worker nodes. Each node has a configuration similar to the one used in the single node.</p>
    </sec>
    <sec id="Sec21">
      <title>Datasets</title>
      <p>Table <xref rid="Tab1" ref-type="table">1</xref> presents characteristics of eleven datasets used to examine the performance of aligners. Nine of them are synthetic designed for evaluating speed and accuracy for different traits using three different read simulators: Wgsim [<xref ref-type="bibr" rid="CR27">27</xref><italic>], SimLoRD [</italic><xref ref-type="bibr" rid="CR28">28</xref><italic>], and PBSim [</italic><xref ref-type="bibr" rid="CR29">29</xref><italic>]. We used Wgsim to generate reads with different length and error rate. Its Synthetic datasets designed in two classes: short reads (Wgsim-S-class) and long reads (Wgsim-L-class). Although IMOS developed especially for high error long reads, we also evaluate the performance of aligning short reads too. SimLoRD and PBsim are used to simulate the PacBio SMRT sequencing. SimLoRD is used with its default parameters which are driven from public PacBio datasets and PBsim is used with its sampling-based method to produce reads similar to the real datasets used in this paper. We used two real datasets that are samples from Human 54 × and Han Chines Trio PacBio reads with accession numbers of SRX533609 and ERX1366175 published in NCBI Sequence Read Archive [</italic><xref ref-type="bibr" rid="CR30">30</xref>]. They are used for measuring speed on a real dataset. Note that, the reference genome used in all experiments is human genome hg19.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Datasets Characteristic: The name of synthetic datasets contains the read simulator name</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">DataSet name</th><th align="left">Dataset size (MB)</th><th align="left">Read length (bp)</th><th align="left">Read length range (bp)</th><th align="left">Mismatch (%)</th><th align="left">Indel (%)</th><th align="left">Number of reads</th></tr></thead><tbody><tr><td align="left">Wgsim-S0</td><td align="left">59</td><td align="left">300</td><td align="left">FIX</td><td align="left">0.9</td><td align="left">0.1</td><td align="left">100000</td></tr><tr><td align="left">Wgsim-S1</td><td align="left">193</td><td align="left">1000</td><td align="left">FIX</td><td align="left">0.9</td><td align="left">0.1</td><td align="left">100000</td></tr><tr><td align="left">Wgsim-S2</td><td align="left">193</td><td align="left">1000</td><td align="left">FIX</td><td align="left">0</td><td align="left">10</td><td align="left">100000</td></tr><tr><td align="left">Wgsim-S3</td><td align="left">193</td><td align="left">1000</td><td align="left">FIX</td><td align="left">9</td><td align="left">1</td><td align="left">100000</td></tr><tr><td align="left">Wgsim-L0</td><td align="left">232</td><td align="left">7000</td><td align="left">FIX</td><td align="left">1</td><td align="left">16</td><td align="left">20000</td></tr><tr><td align="left">Wgsim-L1</td><td align="left">232</td><td align="left">7000</td><td align="left">FIX</td><td align="left">0.9</td><td align="left">0.1</td><td align="left">20000</td></tr><tr><td align="left">Wgsim-L2</td><td align="left">458</td><td align="left">12000</td><td align="left">FIX</td><td align="left">1</td><td align="left">16</td><td align="left">20000</td></tr><tr><td align="left">SimLoRD</td><td align="left">315</td><td align="left">8182</td><td align="left">500-34687</td><td align="left">1</td><td align="left">16</td><td align="left">20000</td></tr><tr><td align="left">PBSim</td><td align="left">343</td><td align="left">7596</td><td align="left">181-24998</td><td align="left">1</td><td align="left">16</td><td align="left">22556</td></tr><tr><td align="left">SRX533609</td><td align="left">2589</td><td align="left">6890</td><td align="left">500-39445</td><td align="left">1</td><td align="left">16</td><td align="left">174537</td></tr><tr><td align="left">ERX1366175</td><td align="left">800</td><td align="left">12997</td><td align="left">503-55908</td><td align="left">1</td><td align="left">16</td><td align="left">30713</td></tr></tbody></table><table-wrap-foot><p>For Wgsim datasets, There are two type of synthetic datasets, S- and L-class which refers to Short and Long reads and their name start with S and L, respectively. The last two datasets are real and represent by the accession number</p></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="Sec22">
      <title>Single node experiments</title>
      <p>We analyzed the performance of our Improved Meta-aligner, the original Meta-aligner, BWA-MEM, and Minimap2. Comparison of Improved and the origianl Meta-aligner demonstrate how effective are our improvements and that of Minimap2 and BWA-MEM helps the better comparison of IMOS and Spark-BWA. Table <xref rid="Tab2" ref-type="table">2</xref> shows the performance of the tools for every dataset. We filter out alignments with MAPQ less than 10 and then measure the accuracy and map rate. Our measurement of accuracy is the number of SAM file [<xref ref-type="bibr" rid="CR31">31</xref>] lines with the correctly reported position to the number of all lines. Map Rate is the percentage of mapped reads (containing incorrect ones) to all.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Single Node performance comparison of IMOS and the original Meta-aligner</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left">Tool</th><th align="left">Map rate (%)</th><th align="left">Accuracy (%) <italic>T</italic>=0</th><th align="left">Accuracy (%) <italic>T</italic>=10</th><th align="left">Accuracy (%) <italic>T</italic>=100</th><th align="left">Time (s)</th></tr></thead><tbody><tr><td align="left">Wgsim-S0</td><td align="left">IM</td><td align="left">99.66</td><td align="left">94.5</td><td align="left">94.9</td><td align="left">94.9</td><td align="left">40</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">95.31</td><td align="left">93.40</td><td align="left">93.73</td><td align="left">93.74</td><td align="left">58</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">97.81</td><td align="left">99.81</td><td align="left">99.99</td><td align="left">100</td><td align="left">20</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">97.44</td><td align="left">97.94</td><td align="left">99.99</td><td align="left">99.99</td><td align="left">12</td></tr><tr><td align="left">Wgsim-S1</td><td align="left">IM</td><td align="left">99.95</td><td align="left">97.36</td><td align="left">97.9</td><td align="left">97.9</td><td align="left">97</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">97.79</td><td align="left">94.76</td><td align="left">96.27</td><td align="left">96.29</td><td align="left">174</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">98.89</td><td align="left">99.78</td><td align="left">99.99</td><td align="left">99.99</td><td align="left">79</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">98.67</td><td align="left">97.86</td><td align="left">99.99</td><td align="left">99.99</td><td align="left">25</td></tr><tr><td align="left">Wgsim-S2 (Indel rich)</td><td align="left">IM</td><td align="left">99.43</td><td align="left">87.17</td><td align="left">95.52</td><td align="left">96.62</td><td align="left">360</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">70.74</td><td align="left">21.58</td><td align="left">79.6</td><td align="left">90.65</td><td align="left">501</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">97.65</td><td align="left">85.42</td><td align="left">99.94</td><td align="left">99.97</td><td align="left">130</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">97.99</td><td align="left">75.76</td><td align="left">99.16</td><td align="left">99.98</td><td align="left">23</td></tr><tr><td align="left">Wgsim-S3 (Mismatch rich)</td><td align="left">IM</td><td align="left">99.46</td><td align="left">95.13</td><td align="left">96.62</td><td align="left">96.62</td><td align="left">352</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">99.05</td><td align="left">67.09</td><td align="left">96.21</td><td align="left">96.23</td><td align="left">202</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">98.38</td><td align="left">82.18</td><td align="left">90.86</td><td align="left">99.91</td><td align="left">134</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">97.79</td><td align="left">76.60</td><td align="left">98.94</td><td align="left">99.99</td><td align="left">24</td></tr><tr><td align="left">Wgsim-L0 (Indel rich)</td><td align="left">IM</td><td align="left">99.96</td><td align="left">78.04</td><td align="left">97.27</td><td align="left">97.37</td><td align="left">780</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">79.96</td><td align="left">7.41</td><td align="left">39.2</td><td align="left">92.37</td><td align="left">1928</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">98.84</td><td align="left">74.78</td><td align="left">99.69</td><td align="left">99.98</td><td align="left">180</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">99.04</td><td align="left">59.02</td><td align="left">94.58</td><td align="left">99.98</td><td align="left">47</td></tr><tr><td align="left">Wgsim-L1</td><td align="left">IM</td><td align="left">99.81</td><td align="left">99.02</td><td align="left">99.05</td><td align="left">99.05</td><td align="left">438</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">99.49</td><td align="left">90.71</td><td align="left">97.71</td><td align="left">97.73</td><td align="left">2306</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">99.20</td><td align="left">99.10</td><td align="left">100</td><td align="left">100</td><td align="left">118</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">99.05</td><td align="left">98.06</td><td align="left">100</td><td align="left">100</td><td align="left">33</td></tr><tr><td align="left">Wgsim-L2 (Indel rich)</td><td align="left">IM</td><td align="left">98.63</td><td align="left">76.61</td><td align="left">99.14</td><td align="left">99.14</td><td align="left">1954</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">95.97</td><td align="left">5.02</td><td align="left">31.56</td><td align="left">94.23</td><td align="left">6103</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">99.22</td><td align="left">75.00</td><td align="left">99.77</td><td align="left">99.98</td><td align="left">318</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">99.22</td><td align="left">58.69</td><td align="left">94.74</td><td align="left">99.98</td><td align="left">72</td></tr><tr><td align="left">SimLoRD</td><td align="left">IM</td><td align="left">92.79</td><td align="left">89.75</td><td align="left">93.69</td><td align="left">93.69</td><td align="left">991</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">92.79</td><td align="left">0.08</td><td align="left">22.15</td><td align="left">42.09</td><td align="left">1851</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">92.43</td><td align="left">85.46</td><td align="left">95.98</td><td align="left">97.65</td><td align="left">458</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">92.43</td><td align="left">79.88</td><td align="left">98.07</td><td align="left">99.89</td><td align="left">75</td></tr><tr><td align="left">PBSim</td><td align="left">IM</td><td align="left">99.75</td><td align="left">88.60</td><td align="left">95.81</td><td align="left">95.96</td><td align="left">1098</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">90.55</td><td align="left">1.05</td><td align="left">5.15</td><td align="left">40.49</td><td align="left">3918</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">98.65</td><td align="left">65.22</td><td align="left">96.01</td><td align="left">97.65</td><td align="left">567</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">98.93</td><td align="left">54.50</td><td align="left">95.56</td><td align="left">99.98</td><td align="left">78</td></tr><tr><td align="left">SRX533609</td><td align="left">IM</td><td align="left">92.35</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">9031</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">70.05</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">24,393</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">92.75</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">3653</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">89.58</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">348</td></tr><tr><td align="left">ERX1366175</td><td align="left">IM</td><td align="left">97.33</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">2780</td></tr><tr><td align="left"/><td align="left">Meta-aligner</td><td align="left">88.15</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">14,303</td></tr><tr><td align="left"/><td align="left">BWA-MEM</td><td align="left">95.24</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">1512</td></tr><tr><td align="left"/><td align="left">Minimap2</td><td align="left">94.14</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">146</td></tr></tbody></table></table-wrap></p>
      <p>Whereas for the synthetic datasets we know the real position of each read, we calculate the accuracy by comparing the real position with the one that the tool declared. The parameter T which is illustrated in the Accuracy column is for Tolerance. Suppose T, P, and X as Tolerance, the real Position, and the declared position. if <italic>X</italic> satisfies in the equation <italic>P</italic>−<italic>T</italic>&lt;=<italic>X</italic>&lt;=<italic>P</italic>+<italic>T</italic>, then the declared position is correct.</p>
      <p>Since the actual position for the real dataset is not known, calculating accuracy is not possible. We could have calculated the accuracy by edit distance factor. If an aligned read is more than a certain percent similar to the reference, then count it as correctly mapped read. A significant concern with this calculation is the fact that due to high error rates, a read may be aligned to a position different than the real one by chance. These types of errors can directly affect the correctness of any downstream analysis.</p>
      <p>The results confirm the improvements. IM always performs better than the original Meta-aligner in terms of Map Rate, Accuracy, and Speed. There is an exception that IM is slower than Meta-aligner for Wgsim-S3 dataset where mismatches and indels happened frequently and rarely, respectively. This happened because the original Meta-aligner uses Bowtie which is more efficient in handling mismatches than SureMap. The point is that IM can offer better accuracy even in this case. However, it is noteworthy to mention that the Wgsim-S3 is an unusual case especially for PacBio datasets. Comparing results of Wgsim-S-class and Wgsim-L-class datasets, we can conclude that IM works better at least under one of these circumstances: 1) Read Length is very long, 2) Error rate of read is very high. Despite we designed IM for long noisy reads, the result shows a little difference between the result of S-class and L-class. This is interesting as it shows the robustness of IM. In terms of speed, IM is up to 6 × faster than Meta-aligner.</p>
      <p>Moreover, the comparison of IM with BWA-MEM and Minimap2 shows that IM is competitive in term of map rate and accuracy. The forth column of Table <xref rid="Tab2" ref-type="table">2</xref> shows that IM always has the best accuracy for indel rich datasets where <italic>T</italic>=0. A main reason for the better speed of BWA-MEM and Minimap2 w.r.t IM is the programming language used for the implementation. Although Java is platform independent, it is slower than C ∖C++.</p>
      <p>As we expected, Minimap2 is always faster than BWA-MEM. Specially for PacBio reads, it is about 10 times faster. Although it offers slightly better accuracy for Pacbio read, it has similar accuracy for other cases.</p>
      <p>The real datasets characteristic are like PBSim and SimLoRD. We can approximate the accuracy of the tools by the results of these two. We can conclude that IM accuracy is always better than Meta-aligner alongside higher map rate for real datasets and is competitive with BWA-MEM and Minimap2 where it is better for smaller <italic>T</italic>s and a bit worse for bigger <italic>T</italic>s. Given our definition of accuracy, one can conclude that IMOS output is trustworthy for any downstream analysis.</p>
    </sec>
    <sec id="Sec23">
      <title>Apache Spark experiments</title>
      <p>IMOS also is designed and implemented as an Apache Spark batch as well as streaming application to be executable on clusters. As mentioned before, our rival in the distributed environment is SparkBWA. Usually, a Spark cluster has a master node with a number of worker nodes. Since an instance of IMOS single node should be run on each slave node, the computational process remains the same. Therefore, accuracy and map rate for each dataset was the same as the single node experiments.</p>
      <p>We deployed tools on an apache spark cluster of 10 nodes, one master and nine workers. The master node is placed at the middle of a star topology connected to nine other worker nodes. We repeated the experiment for different number of worker nodes to evaluate the scalability of tools. Figure <xref rid="Fig7" ref-type="fig">7</xref> shows the speed up of tools with single node performance as the reference point. As expected, the performance of each tool almost doubles with doubling the number of nodes. Therefore, the relation ratio of tools approximately remains constant. Hence, selecting this reference point matters because the effect of implementation overheads is more recognizable. Comparison of worker node numbers of 0 (single node) and 1 shows the overheads of distributed implementation. The results show that IMOS with IM as aligner in batch mode has the least overhead and with Minimap2 has slightly more overheads because it uses storage. Unlike IMOS that keeps the aligners data in the memory for entire application runtime, SparkBWA calls BWA for each partition meaning initialization and more importantly loading reference files should be run for each partition. This is the major factor of high SparkBWA overheads alongside use of storage as interconnect media between Spark executor and BWA.
<fig id="Fig7"><label>Fig. 7</label><caption><p>Scalability of application on a spark cluster. Zero as number of worker nodes is the results of single node with no spark involved</p></caption><graphic xlink:href="12859_2018_2592_Fig7_HTML" id="MO9"/></fig></p>
      <p>IMOS with IM and Minimap2 speed up is about 2.5 × and 3 × better than SparkBWA. Moreover, according to results of Table <xref rid="Tab2" ref-type="table">2</xref>, Minimap2 is about 10 × faster than BWA-MEM. Therefore, IMOS is roughly 25 × faster than SparkBWA when using Minimap2. In addition, it is fascinating to know that although IM is about 2 times slower than BWA-MEM, IMOS even with IM is faster than SparkBWA (about 3/2 times). The results of streaming implementation are not as expected and is discussed in the Discussion section.</p>
      <p>We also analyzed the performance of our thread control mechanism used in IMOS-IM. Figure <xref rid="Fig8" ref-type="fig">8</xref> shows the processing time of each 16 threads in the thread pool for a partition containing 1000 reads. Note that the result for every other partition was very similar, so we only present an example. As shown, the maximum difference between the processing time of threads is only 3%. This shows the effectiveness of our load balancing and thread control mechanism. The average CPU utilization with this technique was about 99%.
<fig id="Fig8"><label>Fig. 8</label><caption><p>Processing time of 16 threads for a partition of 1000 reads</p></caption><graphic xlink:href="12859_2018_2592_Fig8_HTML" id="MO10"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec24" sec-type="discussion">
    <title>Discussion</title>
    <p>In this section, we first compare choosing between batch and streaming processing. Then, we report the bottleneck analysis of IM and a future solution.</p>
    <sec id="Sec25">
      <title>Batch vs streaming</title>
      <p>The input data of this application is a Fasta file containing reads. This file can be very huge in size. Therefore, the communication time is not negligible. For instance, a Fasta file containing 10 × coverage of human genome which counts as a low coverage would be 60GB. Transferring this file through almost the highest Internet connection which is reported to be about 184 Mb/s according to Akamai [<xref ref-type="bibr" rid="CR32">32</xref>] will last about 45 min. Stream processing is able to overlap the communication time with processing time. So, we implemented IMOS-IM using Spark Streaming. As shown in Fig. <xref rid="Fig7" ref-type="fig">7</xref> scalability of spark streaming is not as good as its batch processing. Our analysis shows that the micro-batch mechanism used for spark streaming and its scheduler for distributing data are the two main overheads. Also, if the system is fully utilized then the communication time of next job overlaps with the execution of the current job. Therefore, seeing the whole system as a pipeline, we can only count the execution time for each dataset which is the dominant time. Thus, we decided to release IMOS working with Apache Spark batch processing.</p>
    </sec>
    <sec id="Sec26">
      <title>Bottleneck analysis</title>
      <p>We have analyzed the performance of IMOS-IM on a single node in order to find the bottlenecks. We have profiled CPU, cache, main memory, storage, and context switches when the mapping was running. Our analyses are presented for each item in the following. 
<list list-type="bullet"><list-item><p><bold>CPU:</bold> The average reported CPU utilization over the application runtime is 98% approximately which verify the maximum CPU utilization.</p></list-item><list-item><p><bold>Context Switches:</bold> As expected, since we do not create more threads than the number of cores, the context switch occurs rarely.</p></list-item><list-item><p><bold>Storage:</bold> We monitored the hit rate of main memory. The hit rate only falls with the arrival of new partitions. This means that the storage usage is just as expected.</p></list-item><list-item><p><bold>Main Memory:</bold> We monitored the read and write speed of the main memory. Summation of read and write speed never reaches the maximum throughput of the used RAM. This reveals that the main memory is not the bottleneck. However, the high amount of data read and data write between CPU and RAM gives us a clue that the cache may not function properly.</p></list-item><list-item><p><bold>Cache:</bold> We analyzed the hit rate of cache L3. Its hit rate is 40% approximately. As we expect the hit rate of L3 cache to be more than 50%, the cache has the highest chance to be the bottleneck.</p></list-item></list></p>
      <p>To verify that cache is the bottleneck, First, we split our work into two major part, I) Finding the position of a read using Suremap [<xref ref-type="bibr" rid="CR16">16</xref>] and II) Local alignment using the Smith-Waterman algorithm [<xref ref-type="bibr" rid="CR14">14</xref>]. Timing analysis shows that finding position scales almost linear with the number of cores, but local alignment does not. Our analysis shows that the bottleneck for local alignment is low cache L3 hit rate which is about 15% on average that prevent local alignment as well as the whole program to scale linearly on a single node. Note that 15% for the hit rate of L3 cache is extremely small. Therefore, using a more scalable local alignment algorithm could lead to a system that scales linearly as Altera [<xref ref-type="bibr" rid="CR33">33</xref>] implemented the Smith-Waterman algorithm using FPGA and gained around 200x speed up. Consequently, using FPGA as an accelerator could make the local alignment time negligible and and improve the overall performance.</p>
    </sec>
  </sec>
  <sec id="Sec27" sec-type="conclusion">
    <title>Conclusion</title>
    <p>We have presented IMOS (Improved Meta-aligner and Minimap2 On Spark) which is a long read aligner suitable for noisy Pacbio reads able to be run on a single node (IM) as well as on an Apache Spark cluster (IMOS-IM and IMOS-Minimap2 respectively representing our port of IM and Minimap2 to our IMOS framework). One of our main intentions was to improve Meta-aligner in both accuracy and speed. We have improved the original Meta-aligner in 5 significant ways and re-implement it in Java. To the best of our knowledge, IMOS is the first long read aligner implemented in Java able to run on Linux, Windows, and macOS easily. IMOS is up to 6 times faster than the original Meta-aligner. Still, IMOS has a higher map rate alongside a higher accuracy. Eventually, the result of IMOS is trustworthy for any downstream analysis.</p>
    <p>The other intention of ours was to design a framework suitable for mapping genomic sequences to a reference genome in a distributed environment. We ported both IM as well as Minimap2 to our IMOS framework. Moreover, we provided an interface to be able to run other aligners as well. IMOS is up to 25 × and 1.5 × faster than the current best-performing distributed aligner on Spark, SparkBWA, when with Minimap2 and IM as aligner respectively.</p>
    <p>The direction for our future works is to integrate our design with a downstream analysis like structural variation detection to use the benefits of integration. Designing both upstream and downstream analysis together provides more optimization opportunities because one can design each side to work better with the other side.</p>
  </sec>
  <sec id="Sec28">
    <title>Availability and requirements</title>
    <p><bold>Project name:</bold> IMOS</p>
    <p>
      <bold>Project home page:</bold>
      <ext-link ext-link-type="uri" xlink:href="https://easy.ce.sharif.edu/imos">https://easy.ce.sharif.edu/imos</ext-link>
    </p>
    <p><bold>Operating system(s):</bold> Platform independent</p>
    <p><bold>Programming language:</bold> Java and C</p>
    <p><bold>Other requirements:</bold> Java 8, Apache Spark 2.1 and later, Apache Hadoop 2.7 and later</p>
    <p><bold>License:</bold> CC BY 4.0.</p>
    <p><bold>Any restrictions to use by non-academics:</bold> none</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>CPU</term>
        <def>
          <p>Central processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>GB</term>
        <def>
          <p>Gigabyte</p>
        </def>
      </def-item>
      <def-item>
        <term>HDFS</term>
        <def>
          <p>Hadoop distributed file system</p>
        </def>
      </def-item>
      <def-item>
        <term>IM</term>
        <def>
          <p>Improved meta-aligner</p>
        </def>
      </def-item>
      <def-item>
        <term>I/O</term>
        <def>
          <p>Input/output</p>
        </def>
      </def-item>
      <def-item>
        <term>LAN</term>
        <def>
          <p>Local area network</p>
        </def>
      </def-item>
      <def-item>
        <term>MB</term>
        <def>
          <p>Megabyte</p>
        </def>
      </def-item>
      <def-item>
        <term>Mb/s</term>
        <def>
          <p>Mega bit per second</p>
        </def>
      </def-item>
      <def-item>
        <term>RAM</term>
        <def>
          <p>Random access memory</p>
        </def>
      </def-item>
      <def-item>
        <term>RDD</term>
        <def>
          <p>Resilient distributed dataset</p>
        </def>
      </def-item>
      <def-item>
        <term>SW</term>
        <def>
          <p>Smith-Waterman</p>
        </def>
      </def-item>
      <def-item>
        <term>Th</term>
        <def>
          <p>Threshold</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to cordially thank Damoun Nashta’ali and Mohammad Javad Rezae Seraji for their helpful advices.</p>
    <sec id="d29e2282">
      <title>Funding</title>
      <p>The authors declare that they have no source for funding.</p>
    </sec>
    <sec id="d29e2287" sec-type="data-availability">
      <title>Availability of data and materials</title>
      <p>IMOS is freely available at <ext-link ext-link-type="uri" xlink:href="https://easy.ce.sharif.edu/imos">https://easy.ce.sharif.edu/imos</ext-link>. The required reference files of human genome are available for the sake of simplicity.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>MHNY designed the algorithm and distributed architecture under supervision of SAM and MG, respectively. MHNY and MG performed the bottleneck analyses. MHNY is responsible for implementing IMOS and collecting the results. All authors discussed the results. All authors wrote and approve the manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec>
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec>
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec>
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec>
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <mixed-citation publication-type="other">PacBio RS II - Pacific Biosciences. www.pacb.com/products-and-services/pacbio-systems/rsii/. Accessed 2018.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <mixed-citation publication-type="other">MinION. <ext-link ext-link-type="uri" xlink:href="https://nanoporetech.com/products/minion">https://nanoporetech.com/products/minion</ext-link>. Accessed 2018.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chaisson</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Tesler</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Mapping single molecule sequencing reads using basic local alignment with successive refinement (blasr): application and theory</article-title>
        <source>BMC Bioinforma</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>1</issue>
        <fpage>238</fpage>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>1</volume>
        <fpage>7</fpage>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <mixed-citation publication-type="other">Li H. Aligning sequence reads, clone sequences and assembly contigs with bwa-mem.2013. arXiv preprint arXiv:1303.3997.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hayes</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Hunt</surname>
            <given-names>BR</given-names>
          </name>
          <name>
            <surname>Mount</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Yorke</surname>
            <given-names>JA</given-names>
          </name>
        </person-group>
        <article-title>Reducing storage requirements for biological sequence comparison</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <issue>18</issue>
        <fpage>3363</fpage>
        <lpage>9</lpage>
        <?supplied-pmid 15256412?>
        <pub-id pub-id-type="pmid">15256412</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <mixed-citation publication-type="other">Sedlazeck FJ, Rescheneder P, Smolka M, Fang H, Nattestad M, von Haeseler A, Schatz MC. Accurate detection of complex structural variations using single molecule sequencing.2017. Preprint at <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/arly/2017/07/28/169557">https://www.biorxiv.org/content/arly/2017/07/28/169557</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nashta-aliv</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Aliyari</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Moghadam</surname>
            <given-names>AA</given-names>
          </name>
          <name>
            <surname>Edrisi</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Motahari</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Khalaj</surname>
            <given-names>BH</given-names>
          </name>
        </person-group>
        <article-title>Meta-aligner: long-read alignment based on genome statistics</article-title>
        <source>BMC Bioinforma</source>
        <year>2017</year>
        <volume>18</volume>
        <issue>1</issue>
        <fpage>126</fpage>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pandey</surname>
            <given-names>RV</given-names>
          </name>
          <name>
            <surname>Schlötterer</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Distmap: a toolkit for distributed short read mapping on a hadoop cluster</article-title>
        <source>PLoS ONE</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>8</issue>
        <fpage>72614</fpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>White</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <source>Hadoop: The Definitive Guide.</source>
        <year>2012</year>
        <publisher-loc>Sebastopol</publisher-loc>
        <publisher-name>“O’Reilly Media, Inc.”</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abuín</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Pichel</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Pena</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Amigo</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Bigbwa: approaching the burrows–wheeler aligner to big data technologies</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>24</issue>
        <fpage>4003</fpage>
        <lpage>5</lpage>
        <?supplied-pmid 26323715?>
        <pub-id pub-id-type="pmid">26323715</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abuín</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Pichel</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Pena</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Amigo</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Sparkbwa: speeding up the alignment of high-throughput dna sequencing data</article-title>
        <source>PloS ONE</source>
        <year>2016</year>
        <volume>11</volume>
        <issue>5</issue>
        <fpage>0155461</fpage>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zaharia</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Chowdhury</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Franklin</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Shenker</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Stoica</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>Spark: Cluster computing with working sets</article-title>
        <source>HotCloud</source>
        <year>2010</year>
        <volume>10</volume>
        <issue>10-10</issue>
        <fpage>95</fpage>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Waterman</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequence</article-title>
        <source>Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>7</lpage>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pop</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short dna sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>25</fpage>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <mixed-citation publication-type="other">Seraji MR, Motahari SA. Suremap: Versatile, error tolerant, and high sensitive read mapper. bioRxiv. 2017;:1–11. elocation-id 173740.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Carbone</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Katsifodimos</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ewen</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Markl</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Haridi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tzoumas</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Apache flink: Stream and batch processing in a single engine</article-title>
        <source>Bull IEEE Comput Soc Tech Comm Data Eng</source>
        <year>2015</year>
        <volume>36</volume>
        <issue>4</issue>
        <fpage>28</fpage>
        <lpage>38</lpage>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Toshniwal</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Taneja</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Shukla</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ramasamy</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Patel</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Kulkarni</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Jackson</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Gade</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Fu</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Donham</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Storm@ twitter</article-title>
        <source>Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data</source>
        <year>2014</year>
        <publisher-loc>Snowbird</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Noghabi</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Paramasivam</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Pan</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Ramesh</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bringhurst</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Gupta</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Campbell</surname>
            <given-names>RH</given-names>
          </name>
        </person-group>
        <article-title>Samza: stateful scalable stream processing at linkedin</article-title>
        <source>Proc VLDB Endowment</source>
        <year>2017</year>
        <volume>10</volume>
        <issue>12</issue>
        <fpage>1634</fpage>
        <lpage>45</lpage>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Veiga</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Expósito</surname>
            <given-names>RR</given-names>
          </name>
          <name>
            <surname>Pardo</surname>
            <given-names>XC</given-names>
          </name>
          <name>
            <surname>Taboada</surname>
            <given-names>GL</given-names>
          </name>
          <name>
            <surname>Tourifio</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Performance evaluation of big data frameworks for large-scale data analytics</article-title>
        <source>Big Data (Big Data), 2016 IEEE International Conference On</source>
        <year>2016</year>
        <publisher-loc>Washington, D.C.</publisher-loc>
        <publisher-name>IEEE</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Nasiri</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Nasehi</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Goudarzi</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A survey of distributed stream processing systems for smart city data analytics</article-title>
        <source>Smart Cities and IoT, 2018 ACM International Conference Of</source>
        <year>2018</year>
        <publisher-loc>Mashhad</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Vavilapalli</surname>
            <given-names>VK</given-names>
          </name>
          <name>
            <surname>Murthy</surname>
            <given-names>AC</given-names>
          </name>
          <name>
            <surname>Douglas</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Agarwal</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Konar</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Evans</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Graves</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Lowe</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Shah</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Seth</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Apache hadoop yarn: Yet another resource negotiator</article-title>
        <source>Proceedings of the 4th Annual Symposium on Cloud Computing</source>
        <year>2013</year>
        <publisher-loc>Santa Clara</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Hindman B, Konwinski A, Zaharia M, Ghodsi A, Joseph AD, Katz RH, Shenker S, Stoica I. Mesos: A platform for fine-grained resource sharing in the data center. In: NSDI, vol. 11: 2011. p. 22.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Brewer</surname>
            <given-names>EA</given-names>
          </name>
        </person-group>
        <article-title>Kubernetes and the path to cloud native</article-title>
        <source>Proceedings of the Sixth ACM Symposium on Cloud Computing</source>
        <year>2015</year>
        <publisher-loc>Hilton Waikoloa Village</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Shvachko</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Kuang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Radia</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chansler</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>The hadoop distributed file system</article-title>
        <source>Mass Storage Systems and Technologies (MSST), 2010 IEEE 26th Symposium On</source>
        <year>2010</year>
        <publisher-loc>Incline Village</publisher-loc>
        <publisher-name>Ieee</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <mixed-citation publication-type="other">Kreps J, Narkhede N, Rao J, et al.Kafka: A distributed messaging system for log processing. In: Proceedings of the NetDB.2011. p. 1–7.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <mixed-citation publication-type="other">Li H. wgsim-read simulator for next generation sequencing. Github Repository. 2011. <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/wgsim">https://github.com/lh3/wgsim</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stöcker</surname>
            <given-names>BK</given-names>
          </name>
          <name>
            <surname>Köster</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Rahmann</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Simlord: simulation of long read data</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>17</issue>
        <fpage>2704</fpage>
        <lpage>6</lpage>
        <?supplied-pmid 27166244?>
        <pub-id pub-id-type="pmid">27166244</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ono</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Asai</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Hamada</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Pbsim: Pacbio reads simulator—toward accurate genome assembly</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>29</volume>
        <issue>1</issue>
        <fpage>119</fpage>
        <lpage>21</lpage>
        <?supplied-pmid 23129296?>
        <pub-id pub-id-type="pmid">23129296</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <mixed-citation publication-type="other">Ncbi Sequence Read Archive (SRA). www.ncbi.nlm.nih.gov/sra. Accessed 2018.</mixed-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <mixed-citation publication-type="other">Group SFSW, et al.Sequence alignment/map format specification; 2014.</mixed-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <mixed-citation publication-type="other">Akamai. <ext-link ext-link-type="uri" xlink:href="https://www.akamai.com/">https://www.akamai.com/</ext-link>. Accessed 2018.</mixed-citation>
    </ref>
    <ref id="CR33">
      <label>33</label>
      <mixed-citation publication-type="other">Platform S. White paper implementation of the smith-waterman algorithm on a reconfigurable supercomputing platform.</mixed-citation>
    </ref>
  </ref-list>
</back>
