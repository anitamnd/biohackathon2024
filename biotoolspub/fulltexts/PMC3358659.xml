<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3358659</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-13-S6-S6</article-id>
    <article-id pub-id-type="pmid">22373409</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-13-S6-S6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Proceedings</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>An improved approach for accurate and efficient calling of structural variations with low-coverage sequence data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Zhang</surname>
          <given-names>Jin</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>jinzhang@engr.uconn.edu</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Wang</surname>
          <given-names>Jiayin</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>jywang@engr.uconn.edu</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Wu</surname>
          <given-names>Yufeng</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>ywu@engr.uconn.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computer Science and Engineering, University of Connecticut, Storrs, CT 06269, USA</aff>
    <pub-date pub-type="collection">
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>19</day>
      <month>4</month>
      <year>2012</year>
    </pub-date>
    <volume>13</volume>
    <issue>Suppl 6</issue>
    <supplement>
      <named-content content-type="supplement-title">Proceedings of the Second Annual RECOMB Satellite Workshop on Massively Parallel Sequencing (RECOMB-seq 2012)</named-content>
      <named-content content-type="supplement-editor">Paul Medvedev and Eleazar Eskin</named-content>
    </supplement>
    <fpage>S6</fpage>
    <lpage>S6</lpage>
    <permissions>
      <copyright-statement>Copyright Â©2012 Zhang et al.; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <copyright-holder>Zhang et al.; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/13/S6/S6"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Recent advances in sequencing technologies make it possible to comprehensively study structural variations (SVs) using sequence data of large-scale populations. Currently, more efforts have been taken to develop methods that call SVs with exact breakpoints. Among these approaches, split-read mapping methods can be applied on low-coverage sequence data. With increasing amount of data generated, more efficient split-read mapping methods are still needed. Also, since sequence errors can not be avoided for the current sequencing technologies, more accurate split-read mapping methods are still needed to better handle sequence errors.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this paper, we present a split-read mapping method implemented in the program <italic>SVseq2 </italic>which improves our previous work SVseq1. Similar to SVseq1, SVseq2 calls deletions (and insertions) with exact breakpoints. SVseq2 achieves more accurate calling through split-read mapping within focal regions. SVseq2 also has a much desired feature: there is no need to specify the maximum deletion size, while some existing split-read mapping methods need more memory and longer running time when larger maximum deletion size is chosen. SVseq2 is also much faster because it only needs to examine a small number of ways of splitting the reads. Moreover, SVseq2 supports insertion calling from low-coverage sequence data, while SVseq1 only supports deletion finding. The program SVseq2 can be downloaded at <ext-link ext-link-type="uri" xlink:href="http://www.engr.uconn.edu/~jiz08001/">http://www.engr.uconn.edu/~jiz08001/</ext-link>.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>SVseq2 enables accurate and efficient SV calling through split-read mapping within focal regions using paired-end reads. For many simulated data and real sequence data, SVseq2 outperforms some other existing approaches in accuracy and efficiency, especially when sequence coverage is low.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>19-20 April 2012</conf-date>
      <conf-name>Second Annual RECOMB Satellite Workshop on Massively Parallel Sequencing</conf-name>
      <conf-loc>Barcelona, Spain</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Finding structural genomic variations (e.g. deletions and insertions) has become an active research subject recently. It is commonly believed that some structural variations may be linked to complex diseases [<xref ref-type="bibr" rid="B1">1</xref>]. Now high throughput sequencing (HTS) technologies (such as the Roche 454 FLX, Illumina Genome Analyzer, and ABI SOLiD) become more available. Sequence data can potentially reveal nearly all genetic variations, including structural variants. Thus, great efforts have been made for discovering structural variations in populations using sequence data. For example, the ongoing 1000 Genomes Project has released called structural variations for several human populations from hundreds of sequenced individuals in the pilot studies [<xref ref-type="bibr" rid="B1">1</xref>].</p>
    <p>Many current sequence datasets are consisted of pairs of reads. These pairs can be mapped to a reference genome using read mapping tools such as Bowtie [<xref ref-type="bibr" rid="B2">2</xref>] and BWA [<xref ref-type="bibr" rid="B3">3</xref>]. Usually both reads of the same pair can be successfully mapped to two different locations of the reference genome. The distance in between is called insert size, whose value depends on the library mean and standard deviation. Abnormal insert size (as suggested by the two mapped reads) may indicate the presence of some genomic structure not present in the reference genome. Such pairs are called discordant pairs, which can be useful in locating structural variations. There are many methods that detect SVs by analyzing the insert size of discordant pairs, such as PEMer [<xref ref-type="bibr" rid="B4">4</xref>], BreakDancer [<xref ref-type="bibr" rid="B5">5</xref>], GASV [<xref ref-type="bibr" rid="B6">6</xref>] and VariationHunter [<xref ref-type="bibr" rid="B7">7</xref>]. A drawback of these methods is that only approximate positions of the breakpoints of the SVs can be found, while the high resolution of break points is useful in SV classification and annotation [<xref ref-type="bibr" rid="B8">8</xref>]. Read depth methods (e.g. [<xref ref-type="bibr" rid="B9">9</xref>]) belong to another type of method that does not show the exact breakpoints.</p>
    <p>Assembly and split-read mapping methods are the alternative approaches that can find exact breakpoints of SVs. One representative method using split-read mapping is the program Pindel [<xref ref-type="bibr" rid="B10">10</xref>]. Sometimes a reads mapping program cannot properly map a pair of reads. There are multiple causes for unmapped reads, e.g. errors in sequence reads. The presence of SVs may also cause some reads to be unmappable. In the case of deletions, for example, when a read contains breakpoints of a deletion site, the read will contain two parts: one from the region prior to the deletion site and one from the region following the deletion site. The read may be unmappable because the read is a concatenation of the two parts and is not contained in the reference genome. The pairs with one read mapped and the other read unmapped are used in the split-read mapping methods. The mapped read in the pair is used as an anchor. The other read is split in the middle and then the two parts are attempted to map to the reference genome. If mapped correctly, the mapped split reads may reveal where the deletions occur. Recently there are more methods dedicated to find exact breakpoints. SRiC [<xref ref-type="bibr" rid="B11">11</xref>] is a split-read method mainly works on longer single reads like the Sanger and 454 reads. AGE [<xref ref-type="bibr" rid="B12">12</xref>] maps an assembled contig to a reference genome to detect the exact breakpoints of multiple SVs. There are also methods (e.g. CREST [<xref ref-type="bibr" rid="B13">13</xref>]) that do not detect the breakpoints themselves but rely on the exact breakpoints provided by mapping tools (through soft-clip mapping). A disadvantage of split-read mapping is that mapping split reads with a large gap is usually less efficient. Moreover, split reads may be mapped to wrong locations due to noises in the reads. Also, for the SVs with a breakpoint in a repetitive region, mapping may fail.</p>
    <p>Despite there are increasing number of developed methods, calling structural variations from real sequence data remains a challenging computational problem. The challenges for calling structural variations with real sequence data include: (i) sequence data tends to be short and noisy (i.e. containing sequence errors or artifacts caused by errors in reads mapping), (ii) much current sequence data is at low coverage, and (iii) the volume of sequence data is often large. Therefore, much work is still needed to develop more accurate and efficient approaches for structural variation calling with low-coverage sequence data.</p>
    <p>Recently, we have developed a computational approach for calling deletions from low-coverage sequence data [<xref ref-type="bibr" rid="B14">14</xref>]. This approach (implemented in the program SVseq1) integrates two existing deletion calling approaches (namely discordant insert size analysis and split-read mapping), and thus in principle it utilizes more information contained in the reads than the pure split-read mapping approaches. Since sequence data tends to be noisy, it is important to utilize more information contained in the data when calling deletions. Briefly, SVseq1 first tries to split a read (that cannot be mapped as a whole) and maps the prefix and suffix parts in two regions. The gap between the two mapped regions of the split read may correspond to a deletion. Since there may be more than one way of splitting for some reads and some mapped split reads may only be artifacts of sequence and/or mapping errors, we filter the <italic>candidate </italic>deletions (from the split-read mapping) using discordant insert size analysis. That is, we call a candidate deletion a true deletion only when the candidate deletions are supported by the discordant insert size analysis. Simulation results in [<xref ref-type="bibr" rid="B14">14</xref>] show that our method outperforms an existing method [<xref ref-type="bibr" rid="B10">10</xref>].</p>
    <p>Our work in [<xref ref-type="bibr" rid="B14">14</xref>] makes progress toward improving deletion calling from sequence data. However, we notice that it has several disadvantages. The most severe issue is that it is difficult to determine the best way for splitting reads: due to noise in reads, there may be many equally good ways for splitting the reads. This not only leads to longer running time (due to the need to examine more candidate deletions), but also may introduce false positives. Moreover, split-read mapping tends to be slow especially for genome-scale data. At last, only deletion calling is supported in [<xref ref-type="bibr" rid="B14">14</xref>] and obviously other types of structural variations (e.g. insertions) may also be of interests to many downstream applications.</p>
    <p>In this paper, we present our recent work that improves upon SVseq1 [<xref ref-type="bibr" rid="B14">14</xref>]. Our new approach is implemented in the program <italic>SVseq2</italic>. The following lists the main features of SVseq2.</p>
    <p>1. Like SVseq1, SVseq2 calls deletions (and insertions) with exact breakpoints.</p>
    <p>2. SVseq2 achieves more accurate calling through split-read mapping on focal regions. SVseq2 also has a much desired feature: there is no need to specify the maximum deletion size, which is often needed by other methods (e.g. [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B14">14</xref>]). SVseq2 is also much faster because it only needs to examine a small number of ways of splitting the reads.</p>
    <p>3. SVseq2 utilizes new features of sequence reads mapping tools. Latest sequence reads mapping (e.g. BWA [<xref ref-type="bibr" rid="B3">3</xref>]) provides partial reads mapping (called soft-clips in BWA). These partially mapped reads are often provided in the sequence data. SVseq2 relies on the soft-clip mapping provided by reads mapping tools in part of the split-read mapping. This makes SVseq2 faster than SVseq1 and some other similar deletion finding programs (e.g. [<xref ref-type="bibr" rid="B10">10</xref>]).</p>
    <p>4. SVseq2 is also easier to use: it only needs mapped sequence data (stored in a BAM file) and reference genome (stored in FASTA format) as input.</p>
    <p>5. SVseq2 supports insertion calling from low-coverage sequence data.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <p>SVseq2 is mainly designed to reduce the number of falsely mapped split reads. In our previous method SVseq1 [<xref ref-type="bibr" rid="B14">14</xref>], split-read mapping is performed on a genomic region whose length depends on the maximum size of deletions to detect. Then, each mapped split read introduces a candidate deletion, which is then filtered through discordant pair analysis. Suppose one wants to find deletions up to 1 Mb long, SVseq1 needs to search for a region roughly 1 Mb long on the reference genome. Due to errors in reads and repeats in the genome, there may be many "hits" when split reads are mapped. Many falsely mapped splits reads are filtered with discordant pairs, but some may happen to pass the filtering step. Also, when the number of hits is large, it can be slow in finding all the hits and evaluating them. SVseq2 takes a different approach in calling deletions:</p>
    <p>1. The mapped segment of a split read (from soft-clip mapping) is used as the starting point of split-read mapping. This utilizes new features of read mapping tool and speeds up the computation.</p>
    <p>2. To locate the soft-clipped segment of the split read, we infer a focal region (i.e. the region that highly likely where the soft-clipped segment may be mapped) using the discordant read analysis. We will explain in the following how this step is performed.</p>
    <p>3. The focal region is usually much shorter and thus there is less chance to introduce false positives. We then search for the occurrence of the second segment within the focal region using a semi-global alignment algorithm.</p>
    <p>For insertions, SVseq2 also uses soft-clip mapping in locating the likely insertions. We now give a more detailed description on how SVseq2 calls deletions and insertions.</p>
    <sec>
      <title>Deletion calling</title>
      <p>SVseq2 relies on two types of patterns formed by split reads to detect deletions.</p>
      <p>â¢ Type I pattern: the segment facing the anchor end is mapped (e.g. Read 1 in Figure <xref ref-type="fig" rid="F1">1</xref>).</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Type I pattern of deletion calling</bold>. Read 1 is a split read. Read 2 is a spanning pair. Read 3 is a pair on the other haplotype without the deletion.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-S6-S6-1"/>
      </fig>
      <p>â¢ Type II pattern: the segment away from the anchor is mapped (e.g. Read 4 in Figure <xref ref-type="fig" rid="F2">2</xref>).</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Type II pattern of deletion calling</bold>. Read 4 itself is a spanning pair. The left end is split.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-S6-S6-2"/>
      </fig>
      <p>For type I pattern, the mapped segment of a split read based on soft-clip mapping faces the anchor. We denote the mapped location of the mapped segment as [<italic>a, b</italic>] (where <italic>a </italic>&lt;<italic>b</italic>). To discover a deletion, the soft-clipped segment needs to be mapped to some region [<italic>c, d</italic>] (where <italic>c </italic>&lt;<italic>d </italic>&lt;<italic>a</italic>). We denote the length of the soft-clipped segment as <italic>l<sub>s </sub></italic>= <italic>d </italic>- <italic>c </italic>+ 1. Because the length of the true deletion is not known, some existing split-read mapping methods (e.g. [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B14">14</xref>]) have a parameter on the maximum distance to search for the second (i.e. the soft-clipped) segment. Instead of searching in a large region, SVseq2 only searches a <italic>focal </italic>region by the guidance of spanning pairs. Our goal here is to infer where the soft-clipped segment is likely to start (i.e. the likely range of <italic>c</italic>). Our first observation is: even with low-coverage sequence data, a deletion is still likely to have at least one paired-end read whose two ends are located on different sides of the deletion (i.e. a spanning pair). Suppose there is a read pair whose two ends are mapped to [<italic>s</italic><sub>1 </sub>, <italic>e</italic><sub>1 </sub>] and [<italic>s</italic><sub>2 </sub>, <italic>e</italic><sub>2 </sub>] respectively on the reference genome (where <italic>s</italic><sub>1 </sub>&lt;<italic>e</italic><sub>1 </sub>&lt;<italic>s</italic><sub>2 </sub>&lt;<italic>e</italic><sub>2 </sub>), and this pair is a spanning pair for the deletion, whose location is determined by the mapping of the soft-clipped segment of the split read. We let <italic>l<sub>i </sub></italic>be the expected insert size and let <italic>Ï </italic>be the standard deviation of the insert size. Note that <italic>l<sub>i </sub></italic>measures the outer distance of the pair (i.e. the distance of the two farthest points of the two two reads). We denote the length of the two reads of the spanning pair as <italic>l</italic><sub>1 </sub>and <italic>l</italic><sub>2 </sub>respectively. Suppose the minimum deletion size to be detected by SVseq2 is <italic>m<sub>d</sub></italic>. SVseq2 sets <italic>m<sub>d </sub></italic>to be 50.</p>
      <p>We first show where to find spanning pairs for a given split read.</p>
      <p><bold>Lemma 1 </bold><italic>For type-I pattern, s</italic><sub>2 </sub>â¥ <italic>a, and with high probability, we have s</italic><sub>2 </sub>â¤ <italic>a - l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub>+ <italic>l<sub>i </sub></italic>+ 3<italic>Ï</italic>.</p>
      <p><bold>Proof 1 </bold><italic>If s</italic><sub>2 </sub><italic>&lt; a, then a is not a breakpoint. This does not agree with our underlying assumption that the mapped segment </italic>[<italic>a, b</italic>] <italic>corresponds to a deletion</italic>.</p>
      <p><italic>To give an upper bound on s</italic><sub>2</sub>, <italic>note that a is the position of the right breakpoint. The rightmost position of e<sub>1 </sub>on the reference is a - l<sub>del</sub>, where l<sub>del </sub>is the length of the deletion. Now since with high probability, the distance between s</italic><sub>2 </sub><italic>and e<sub>1 </sub>is at most l<sub>i </sub>- l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub><italic>+ </italic>3<italic>Ï + l<sub>del </sub>on the reference. So with high probability s</italic><sub>2 </sub>â¤ (<italic>a - l<sub>del</sub></italic>)<italic>+ </italic>(<italic>l<sub>i </sub>- l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub><italic>+ </italic>3<italic>Ï + l<sub>del</sub></italic>) <italic>= a - l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub><italic>+ l<sub>i </sub>+ </italic>3<italic>Ï</italic>.</p>
      <p>Lemma 1 states where the spanning pairs are very likely to be located. For a given split read, SVseq2 searches for reads mapped on the reverse strand within this region for spanning pairs.</p>
      <p>Now suppose we find one spanning pair for the given split read. Recall the spanning pair is mapped to [<italic>s</italic><sub>1</sub>, <italic>e</italic><sub>1 </sub>] and [<italic>s</italic><sub>2</sub>, <italic>e</italic><sub>2</sub>]. The following lemma specifies the range of <italic>c </italic>(i.e. the starting point of the soft-clipped segment).</p>
      <p><bold>Lemma 2 </bold><italic>For type-I pattern, e</italic><sub>1 </sub>- <italic>l<sub>s </sub>â¤ c â¤ a - m<sub>d </sub>- l<sub>s </sub></italic>. <italic>Moreover, with high probability, we have c â¤ e</italic><sub>1 </sub><italic>+ l<sub>i </sub>- l<sub>s </sub>- l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub><italic>+ </italic>3<italic>Ï</italic>.</p>
      <p><bold>Proof 2 </bold><italic>Note that the rightmost position a deletion can end is md bases to the left of a on the reference, because the minimum deletion size is m<sub>d</sub>. So c â¤ a - m<sub>d</sub> - l<sub>s</sub>. Since the spanning pair </italic>([<italic>s</italic><sub>1</sub>, <italic>e</italic><sub>1</sub>], [<italic>s</italic><sub>2</sub>, <italic>e</italic><sub>2</sub>]) <italic>spans the deletion, we know the deletion must occur to the right of </italic>[<italic>s</italic><sub>1</sub>, <italic>e</italic><sub>1</sub>]. <italic>The leftmost position of the deletion is thus at least e1. Since the length of l<sub>s </sub>is to be mapped (to the left) from the left end of the deletion, we have c + l<sub>s </sub>â¥ e</italic><sub>1</sub>.</p>
      <p><italic>We now estimate how large c can be. Note that on the alternative chromosome (the chromosome with the deletion), the left and right breakpoints of the deletion become the same, and the left breakpoint of the deletion must be to the left of the starting position of the right end of the spanning pair. Thus, on the reference chromosome, with high probability, the left breakpoint is no bigger than e</italic><sub>1 </sub><italic>+ l<sub>i </sub>- l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub><italic>+ </italic>3<italic>Ï</italic>.</p>
      <p>Lemma 2 states that we only need to search for the second segment of the split read within the region [<italic>e</italic><sub>1 </sub>- <italic>l<sub>s</sub>, min</italic>(<italic>e</italic><sub>1 </sub>+ <italic>l<sub>i </sub></italic>- <italic>l<sub>s </sub></italic>- <italic>l</italic><sub>1 </sub>- <italic>l</italic><sub>2 </sub>+ 3<italic>Ï, a </italic>- <italic>m<sub>d </sub></italic>- <italic>l<sub>s </sub></italic>)]. This region is called the "<italic>focal</italic>" region for the split read being mapped and a spanning pair. In most current sequence data, the focal region is relatively small. For example, suppose <italic>l<sub>s </sub></italic>= 50 (taken from a read of 100 bps long), <italic>l</italic><sub>1 </sub>= <italic>l</italic><sub>2 </sub>= 100, <italic>l<sub>i </sub></italic>= 200 and <italic>Ï </italic>= 50. Then the width of the focal region is not larger than 200. This is much smaller than the focal region that the original split-read mapping would have searched (which can be as long as 1 Mbps). Also, from Lemma 1, the width of the region for spanning pairs is at most 150.</p>
      <p>The processing of split reads with type II pattern is similar in many aspects to that of type I pattern. A main difference between type I and type II patterns is that type II pattern does not need additional spanning pairs because the paired-end read itself is a spanning pair. This imposes an additional constraint on the focal region. Suppose the mapped segment of the split read is located at [<italic>a, b</italic>] and the mapped anchor is located at [<italic>s, e</italic>] (where <italic>a </italic>&lt;<italic>b </italic>&lt;<italic>s </italic>&lt;<italic>e </italic>as shown in Figure <xref ref-type="fig" rid="F2">2</xref>). We let [<italic>c, d</italic>] be the location of the soft-clipped segment of the split read on the reference (where <italic>b </italic>&lt;<italic>c </italic>&lt;<italic>d</italic>). We let <italic>l<sub>s </sub></italic>= <italic>d </italic>- <italic>c </italic>+ 1 be the length of the soft-clipped segment. We let <italic>l</italic><sub>1 </sub>and <italic>l</italic><sub>2 </sub>be the length of the two reads (i.e. <italic>l</italic><sub>2 </sub>= <italic>e </italic>- <italic>s </italic>+ 1). <italic>m<sub>d</sub>, l<sub>i </sub></italic>and <italic>Ï </italic>are defined as before. The following lemma specifies where the soft-clipped segment is allowed to map.</p>
      <p>Lemma 3 <italic>b + m<sub>d </sub>â¤ c â¤ s. Also, with high probability, we have s - l<sub>i </sub>- l<sub>s </sub>+ l</italic><sub>1 </sub><italic>+ l</italic><sub>2 </sub>- 3<italic>Ï â¤ c â¤ s</italic>.</p>
      <p><bold>Proof 3 </bold><italic>Note that the leftmost position a deletion can start is m<sub>d</sub> bases to the right of b on the reference, because the minimum deletion size is m<sub>d </sub>. Also, the breakpoint cannot go to the right side of s for there is no split on the anchor</italic>.</p>
      <p><italic>Note that the position of soft-clipped segment is constrained by the anchor position and the insert size. So the second inequality follows the same reasoning as in Lemma 2</italic>.</p>
      <p>Lemma 3 states that we only need to search for the second segment of Type II pattern of the split read within the focal region [<italic>max</italic>(<italic>b </italic>+ <italic>m<sub>d</sub>, s </italic>- <italic>l<sub>i </sub></italic>- <italic>l<sub>s </sub></italic>+ <italic>l</italic><sub>1 </sub>+ <italic>l</italic><sub>2 </sub>- 3<italic>Ï</italic>), <italic>s</italic>]. For the cases when the split read is on the reverse strand, the method applied on them is essentially the same as when they are on the forward strand.</p>
      <p>Our experience indicates that type I pattern is usually more reliable then type II pattern, because less errors are expected at the head of Illumina reads. Thus SVseq2 gives type I pattern higher weights than type II pattern when calling deletions. The weight of type I pattern is set to 3, and the weight is set to 1 for type II pattern. A cutoff value on the total weight (i.e. the sum of weights of supporting reads for a deletion) is used by SVseq2. The default cutoff value is set to 3, i.e. at least one type I pattern read is required or at least three type II pattern reads are required when there is no type I pattern read.</p>
      <p>To search for the occurrence of a soft-clipped segment within a inferred focal region, SVseq2 uses a semi-global alignment algorithm, as illustrated in Figure <xref ref-type="fig" rid="F3">3</xref>. Briefly, we want to map the entire soft-clipped segment within the focal region. Thus, the gaps outside of the aligned positions for the focal region are without penalty, while we set the gap penalty within the read to 3. The similarity score is 1 for matches and -1 for mismatches. Since the focal region and the read are relatively short (e.g. several hundreds at most for the focal region and less than one hundred for Illumina reads), split-read mapping with sequence alignment can be performed relatively fast.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>SVseq2 uses a semi-global alignment algorithm</bold>. The gaps "GTTCTAAGCC" and "GAATCACTTGGA" are without penalty. The gap at "TAC" and "T-C" are with penalty 3. The T-A mismatch are scored -1. Other Matches are scored 1 each. Total score is 23.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-S6-S6-3"/>
      </fig>
      <p>Since the above split-read mapping method starts from soft-clip mapping, its accuracy depends on how accurate the soft-clip mapping is. Because soft-clip mapping is found through local sequence alignment, sometimes errors can be introduced by soft-clip mapping. We observe that one possible error in soft-clip mapping occurs when there is a gap in the soft-clip mapping. As shown in Figure <xref ref-type="fig" rid="F4">4</xref>, soft-clip mapping may align a segment longer than that in the true split read by introducing a false gap, while the true alignment can be achieved without gap by mapping a longer soft-clipped segment to a later position. When this occurs, the length of the detected deletion can be different from the real length. SVseq2 addresses this potential problem by using an adjustment step, which tries to find an optimized mapping of the entire read by avoiding errors (i.e. as shown in Figure <xref ref-type="fig" rid="F4">4</xref>). During the adjustment step, we examine all supporting split reads for some deletion. If each of the split reads can be adjusted to achieve a better mapping (i.e. by rearranging the split-read alignment as shown in Figure <xref ref-type="fig" rid="F4">4</xref>), then SVseq2 removes the gaps within these reads and adjusts the length of the deletion accordingly. If the reads do not agree with each other in terms of splitting positions, then SVseq2 takes a voting scheme by choosing split reads with higher alignment scores.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Adjustment of breakpoints</bold>. Length of a deletion can be adjusted. In the upper case, the left segment is mapped by Smith-Waterman algorithm with a gap and the length of the deletion is 101. In the lower case, the gap is removed and the length of the deletion is adjusted to 100.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-S6-S6-4"/>
      </fig>
      <p>In practice, there may be more than one spanning pairs for a candidate deletion (corresponding to a split read). When the deletion is heterozygous in a diploid genome, Some spanning pairs may originate from the copy without the deletion while others from the copy with the deletion. Some other spanning pairs may be due to mapping errors. One possible scheme is to find a "consensus" focal region by combining information provided by multiple spanning pairs. SVseq2 simply takes the union of all the focal regions from all the possible spanning pairs. This is because there could be mapping errors in the spanning pairs, and thus SVseq2 takes a conservative estimate of the focal region. Our experience shows that the overall focal region is still relatively small and searching for split read can be performed relatively efficiently.</p>
    </sec>
    <sec>
      <title>Insertion finding</title>
      <p>SVseq2 uses the reads with head segments mapped with low quality (contains too many gaps or is soft-clipped) to detect insertions. (Here a head segment means the 5' portion of a read.) In particular, SVseq2 uses type III pattern: two mapped segments of split reads overlap but the two whole reads cannot be aligned well (see Figure <xref ref-type="fig" rid="F5">5</xref>). Both reads are from properly mapped pairs, and both have low quality mapping or soft-clip at the head segment. We consider a split read that has its tail mapped on the reverse strand. If another split read is from the other direction of the insertion, its split is very likely to be only located in a small region near the known breakpoint. For example, in Figure <xref ref-type="fig" rid="F5">5</xref>, knowing that read 1 is mapped with a possible breakpoint, then only the reads that have split in the short Region 1 have to be examined. As shown in Figure <xref ref-type="fig" rid="F5">5</xref>, if there is an insertion, then the heads of the reads are not from the reference genome. Thus, the overlapped portions of the two reads are unlikely to be aligned well. On the other hand, if there is no insertion, then the overlapped portions come from the same genomic region and should be aligned well. Because the not well mapped segments are from the heads of the Illumina reads, less errors are expected in these segments and their alignment is more reliable.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Type III pattern in finding insertion</bold>. Tail segments (portions 1 and 4) are mapped next to each other on the reference. The sequences of head segments (portions 2 and 3) belong to the inserted sequence.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-S6-S6-5"/>
      </fig>
      <p>SVseq2 relies on pair wise sequence algorithm to align two overlapped reads. The parameters are the same as for the deletion case. If the score of the mapping over the length of the overlap is less than 0.1 then the pair is treated as evidence of a possible insertion. The default cutoff value of reads supporting an insertion for SVseq2 is 3. That is, at least another read in this region has the same split and passes the alignment test with the read in this pair on the different strand.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>We apply SVseq2 on both simulated datasets and real datasets, comparing with SVseq1 [<xref ref-type="bibr" rid="B14">14</xref>] and Pindel 0.2.4d [<xref ref-type="bibr" rid="B10">10</xref>] on accuracy and efficiency. For deletion finding, the three methods are run on simulated population data, real individual and pooled data. For insertion finding, simulated individual data is used. The real sequence datasets (20101123 Illumina data) consist of the alignment files of 18 individuals on chromosome 20. Nine of the individuals are from the CEU population and the others are from the YRI population. These alignment datasets are mapped using BWA with soft-clips on NCBI human genome 37. The accuracy is evaluated according to the results by the 1000 Genomes Project <ext-link ext-link-type="ftp" xlink:href="ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/technical/working/20110719_merged_sv_calls/">ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/technical/working/20110719_merged_sv_calls/</ext-link>. The results contain assembled deletions and the ones found by five SV detection tools of more than 1000 individuals (which include the ones used in this paper). The methods include BreakDancerMax1.1 [<xref ref-type="bibr" rid="B5">5</xref>], CNVnator [<xref ref-type="bibr" rid="B9">9</xref>], GenomeStrip v1.04 [<xref ref-type="bibr" rid="B15">15</xref>], EMBL/Delly and Pindel [<xref ref-type="bibr" rid="B10">10</xref>]. Since not all of the methods are able to provide exact breakpoints of deletions, evaluation of accuracy of methods is based on both a strict criterion and a less strict criterion. A called deletion is viewed correct by the strict one, if the length of the called deletion is the same as a deletion in the results by the benchmark. The less strict one only requires that a called deletion overlaps with a deletion in the benchmark, and at least 50% of the bases of the called deletion are supported. </p>
    <sec>
      <title>Finding deletions using simulated pooled data</title>
      <p>The simulated datasets with read length 100 from [<xref ref-type="bibr" rid="B14">14</xref>] are used in this paper to compare SVseq2 to SVseq1 and Pindel in terms of accuracy and sensitivity. The datasets are simulated from the sequence of chromosome 15 (100,338,915 bps in length) of NCBI human genome 36. The results of the copy number variation release paper of the 1000 Genomes Project [<xref ref-type="bibr" rid="B16">16</xref>] are based on this version of genome. The deletions of the 45 individuals from the CEU population reported by [<xref ref-type="bibr" rid="B16">16</xref>] are introduced to the simulation datasets (union.2010_06.deletions.genotypes.vcf.gz). Since the haplotypes of the deletions are not inferred in the file, for the heterogeneous deletions we arbitrarily place one such deletion to one of the two haplotypes of an individual. Since the deletions are usually far apart from each other, this may not have big effects on the accuracy of the simulation. A tool called wgsim <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/wgsim">https://github.com/lh3/wgsim</ext-link> is used with the "-h" option to generate paired-end reads from the two copies of genomes of an individual. Single nucleotide polymorphisms and small indels on each genome are simulated using the default parameters. All the datasets are generated with base error rate 2%. Paired-end reads are simulated with read length 100 and "outer distance" 500. Three datasets with coverage 3.2Ã, 4.2Ã and 6.4Ã are used. BWA, which provides soft-clips, is used with default parameters to map these simulated paired-end reads to the entire NCBI human genome 36.</p>
      <p>The performance of finding deletions is compared among SVseq2, SVseq1 and Pindel, on these pooled datasets. The results are shown in Table <xref ref-type="table" rid="T1">1</xref>. We can see that SVseq2 usually has the highest accuracy and sensitivity. Pindel usually has a high accuracy but lower sensitivity comparing with the other two methods. Mapping a soft-clipped segment of a split read to a focal region reduces the chance that this segment is mapped to wrong positions. Since the mapping approach of SVseq2 is more accurate, it does not need a higher cutoff to call deletions (recall that the cutoff value of 3 means that only one type I pattern read is needed). We can see that when coverage is higher (6.4Ã), the sensitivity of SVseq2 and SVseq1 is similar. But when coverage is lower (3.2Ã), the sensitivity of SVseq2 is higher than SVseq1. When the coverage or the frequency of a deletion is very low, SVseq2 may have a better chance of detecting it than using the other two methods.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Comparison of SVseq2, SVseq1 and Pindel in simulation.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">Coverage</th>
              <th align="center">Tool</th>
              <th align="center">Findings</th>
              <th align="center">True Positive</th>
              <th align="center">Accuracy (%)</th>
              <th align="center">Sensitivity (%)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">3.2Ã</td>
              <td align="center">SVseq2</td>
              <td align="center">114</td>
              <td align="center">112</td>
              <td align="center">98</td>
              <td align="center">85</td>
            </tr>
            <tr>
              <td/>
              <td align="center">SVseq1</td>
              <td align="center">111</td>
              <td align="center">108</td>
              <td align="center">97</td>
              <td align="center">82</td>
            </tr>
            <tr>
              <td/>
              <td align="center">Pindel</td>
              <td align="center">91</td>
              <td align="center">90</td>
              <td align="center">99</td>
              <td align="center">68</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">4.2Ã</td>
              <td align="center">SVseq2</td>
              <td align="center">113</td>
              <td align="center">112</td>
              <td align="center">99</td>
              <td align="center">85</td>
            </tr>
            <tr>
              <td/>
              <td align="center">SVseq1</td>
              <td align="center">117</td>
              <td align="center">109</td>
              <td align="center">93</td>
              <td align="center">83</td>
            </tr>
            <tr>
              <td/>
              <td align="center">Pindel</td>
              <td align="center">91</td>
              <td align="center">90</td>
              <td align="center">99</td>
              <td align="center">68</td>
            </tr>
            <tr>
              <td colspan="6">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">6.4Ã</td>
              <td align="center">SVseq2</td>
              <td align="center">123</td>
              <td align="center">120</td>
              <td align="center">98</td>
              <td align="center">91</td>
            </tr>
            <tr>
              <td/>
              <td align="center">SVseq1</td>
              <td align="center">128</td>
              <td align="center">120</td>
              <td align="center">94</td>
              <td align="center">91</td>
            </tr>
            <tr>
              <td/>
              <td align="center">Pindel</td>
              <td align="center">103</td>
              <td align="center">102</td>
              <td align="center">99</td>
              <td align="center">77</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Reads of length 100 on chromosome 15 with 132 deletions are simulated. The cutoff value of SVseq2 is 3. The cutoff value is 3 for SVseq1 and Pindel. Number of findings and true positives in each setting are reported.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>A called deletion is viewed correct in the comparison in Table <xref ref-type="table" rid="T1">1</xref> if the length of a called deletion is the same as the simulated length. The split-read approaches have the advantage of high resolution of breakpoints, while different approaches such as read depth and read pair methods are not suitable to find the exact breakpoints. The 132 deletions introduced into the simulation are only from 45 individuals of the CEU population on one chromosome, but the frequencies of the lengths of these deletions (see Figure <xref ref-type="fig" rid="F6">6</xref>) show the same trend with the frequencies of the deletions found by the 1000 Genomes Project (refer to Figure <xref ref-type="fig" rid="F2">2a</xref> of [<xref ref-type="bibr" rid="B16">16</xref>]). SVseq2 is able to detect both smaller and larger deletions. For example, in the 6.4Ã coverage setting, SVseq2 finds all the 6 larger deletions with length &gt; 7, 000 and Pindel misses one deletion. For the 33 deletions with length in range 1, 000 to 7, 000, SVseq2 finds 29 and Pindel finds 25 deletions. For the 93 smaller deletions with length &lt; 1, 000, the numbers are 85 and 72, respectively. The effectiveness of the SV finding methods may also be affected by sequence coverage. For example, CNVnator [<xref ref-type="bibr" rid="B9">9</xref>] is a read depth method that is very accurate on the 1000 Genomes Project's trio data. The resolution of breakpoints is also high when it is applied on high coverage data. But it does not perform as well on the low-coverage datasets, e.g. when it is applied on the 6.4Ã coverage data using bin size of 30, 100, 500 and 1, 000, CNVnator reports 510, 120, 74 and 53 deletions, with 44, 35, 14 and 8 correct (if the region of a reported deletion overlaps with the true region) respectively.</p>
      <fig id="F6" position="float">
        <label>Figure 6</label>
        <caption>
          <p><bold>Lengths of the deletions used in the simulation</bold>. Histogram of the lengths of 126 deletions in the simulation with length less than 7, 000. There are other 6 deletions with length range from 7, 688 to 160, 798.</p>
        </caption>
        <graphic xlink:href="1471-2105-13-S6-S6-6"/>
      </fig>
    </sec>
    <sec>
      <title>Finding deletions using real individual data</title>
      <p>The sequence data of five individuals from YRI population used by the 1000 Genomes Project is used to compare SVseq2, SVseq1 and Pindel on real individual data. The number of findings and true positives are shown in Table <xref ref-type="table" rid="T2">2</xref>.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Comparison of SVseq2, SVseq1 and Pindel using real individual data.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="center" colspan="3">SVseq2(3)</th>
              <th align="center" colspan="3">SVseq2(4)</th>
              <th align="center" colspan="3">SVseq1</th>
              <th align="center" colspan="3">Pindel</th>
            </tr>
            <tr>
              <th/>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">NA19311</td>
              <td align="center">48</td>
              <td align="center">38(79%)</td>
              <td align="center">44(92%)</td>
              <td align="center">24</td>
              <td align="center">24(100%)</td>
              <td align="center">24(100%)</td>
              <td align="center">15</td>
              <td align="center">14(93%)</td>
              <td align="center">14(93%)</td>
              <td align="center">3</td>
              <td align="center">2(67%)</td>
              <td align="center">2(67%)</td>
            </tr>
            <tr>
              <td align="center">NA19312</td>
              <td align="center">47</td>
              <td align="center">27(57%)</td>
              <td align="center">32(6872%)</td>
              <td align="center">19</td>
              <td align="center">16(84%)</td>
              <td align="center">16(84%)</td>
              <td align="center">28</td>
              <td align="center">12(43%)</td>
              <td align="center">20(72%)</td>
              <td align="center">9</td>
              <td align="center">2(22%)</td>
              <td align="center">7(78%)</td>
            </tr>
            <tr>
              <td align="center">NA19313</td>
              <td align="center">70</td>
              <td align="center">23(33%)</td>
              <td align="center">43(61%)</td>
              <td align="center">27</td>
              <td align="center">16(59%)</td>
              <td align="center">22(81%)</td>
              <td align="center">70</td>
              <td align="center">21(30%)</td>
              <td align="center">51(73%)</td>
              <td align="center">14</td>
              <td align="center">3(21%)</td>
              <td align="center">12(85%)</td>
            </tr>
            <tr>
              <td align="center">NA19316</td>
              <td align="center">17</td>
              <td align="center">14(82%)</td>
              <td align="center">16(94%)</td>
              <td align="center">4</td>
              <td align="center">3(75%)</td>
              <td align="center">4(100%)</td>
              <td align="center">3</td>
              <td align="center">2(67%)</td>
              <td align="center">3(100%)</td>
              <td align="center">7</td>
              <td align="center">5(71%)</td>
              <td align="center">6(86%)</td>
            </tr>
            <tr>
              <td align="center">NA19317</td>
              <td align="center">28</td>
              <td align="center">18(64%)</td>
              <td align="center">22(79%)</td>
              <td align="center">13</td>
              <td align="center">10(77%)</td>
              <td align="center">10(77%)</td>
              <td align="center">6</td>
              <td align="center">4(67%)</td>
              <td align="center">4(67%)</td>
              <td align="center">4</td>
              <td align="center">2(50%)</td>
              <td align="center">4(100%)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>SVseq2 is run with cutoff values 3 and 4. The cutoff value is 3 for SVseq1 and Pindel. F stands for "Findings", SE for "Supported by exact breakpoints" and SO for "Supported by overlap". Numbers in the parenthesis are accuracies.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>Using individual sequence data, SVseq2 is able to utilize split reads to call more deletions than SVseq1 and Pindel even when the coverage is very low. With cutoff value 3, SVseq2 finds the largest number of deletions and a large portion has supports by the benchmark. If a higher cutoff value 4 is used, most of the called deletions are supported by the benchmark. The number of findings is still larger than SVseq1 and Pindel, when using cutoff value 4.</p>
    </sec>
    <sec>
      <title>Finding deletions using real pooled data</title>
      <p>Sequence reads from 9 individuals from CEU population are pooled together, and reads from 9 individuals from YRI populations are pooled together. SVseq2, SVseq1 and Pindel are tested using these two pooled datasets. Results are shown in Table <xref ref-type="table" rid="T3">3</xref>.</p>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Comparison of SVseq2, Svseq1 and Pindel using real pooled data.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th/>
              <th align="center" colspan="3">SVseq2(3)</th>
              <th align="center" colspan="3">SVseq2(4)</th>
              <th align="center" colspan="3">SVseq1</th>
              <th align="center" colspan="3">Pindel</th>
            </tr>
            <tr>
              <th/>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
              <th align="center">F</th>
              <th align="center">SE</th>
              <th align="center">SO</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">CEU</td>
              <td align="center">108</td>
              <td align="center">43(40%)</td>
              <td align="center">72(67%)</td>
              <td align="center">39</td>
              <td align="center">26(67%)</td>
              <td align="center">36(92%)</td>
              <td align="center">258</td>
              <td align="center">48(19%)</td>
              <td align="center">99(38%)</td>
              <td align="center">30</td>
              <td align="center">19(63%)</td>
              <td align="center">25(83%)</td>
            </tr>
            <tr>
              <td colspan="13">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="center">YRI</td>
              <td align="center">195</td>
              <td align="center">77(39%)</td>
              <td align="center">133(68%)</td>
              <td align="center">84</td>
              <td align="center">55(65%)</td>
              <td align="center">68(81%)</td>
              <td align="center">131</td>
              <td align="center">54(41%)</td>
              <td align="center">101(77%)</td>
              <td align="center">112</td>
              <td align="center">38(34%)</td>
              <td align="center">77(69%)</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>SVseq2 is run with cutoff values 3 and 4. The cutoff value is 3 for SVseq1 and Pindel. F stands for "Findings", SE for "Supported by exact breakpoints" and SO for "Supported by overlap". Numbers in the parenthesis are accuracies.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>Using pooled data, all three methods are able to find more deletions than using individual data. SVseq2 finds more deletions using cutoff value 3 but false positive rate is increased too. Quite a portion of deletions found by SVseq2 using cutoff value 3 are missed by using cutoff value 4. Even pooling nine individuals together, many less frequent deletions still belong to single individuals. Because the sequence coverage is low, only one split read with soft-clipped mapping covers such a deletion (recall that the cutoff value 3 means one type I read). The quality of soft-clipped mapping provided by the mapping tools matters in finding SVs. If a mapping tool fails to perform soft-clip mapping on a split read, then this read is not used by SVseq2. By pooling more data from more individuals, more deletions are likely to be found by SVseq2.</p>
    </sec>
    <sec>
      <title>Simulation results for insertion</title>
      <p>There are fewer insertion finding methods than deletion finding. Also, fewer insertions have been called and released than deletions. To simulate insertion, the release (CEU.trio.2010_06.novelsequences.sites.vcf) of the NA12878 individual is used in this paper. This individual has been sequenced at high coverage and the 1000 Genomes Project has released some inserted sequences of this individual. Chromosome 4 of NCBI human genome 36 is used in the simulation, since there are 13 (the highest number of) inserted sequences on this chromosome in the release for this individual. Each insertion is treated to be heterozygous and added into an arbitrary haplotype. Illumina reads with 20Ã coverage (so that each inserted sequence has 10Ã coverage) are simulated using wgism <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/wgsim">https://github.com/lh3/wgsim</ext-link> with insert size 230 and read length 100. The reads are mapped using BWA. Both SVseq2 and Pindel 0.2.4.d are tested to find insertions. SVseq2 finds 10 insertions with 9 true positives. Pindel finds 2 insertions, both of which are correct. One is found as "LI" and the other is found as "SI". The large insertion reported by Pindel as "LI" has 6 split reads supporting it, where 3 out of 6 are from the forward strand and the other 3 are from the reverse strand. Even at 20Ã coverage, split reads of type III pattern are not common in this simulation study. This simulation shows that SVseq2 is able to use fewer supporting reads to call insertions.</p>
    </sec>
    <sec>
      <title>Running time</title>
      <p>Because the mapping of SVseq2 is performed on focal regions, the algorithm of SVseq2 is usually faster than SVseq1 and Pindel. The run time of SVseq2, SVseq1 and Pindel is compared in this paper on one dataset. The file (NA19312.chrom20.ILLUMINA.bwa.LWK.low_coverage.20101123.bam) from the 1000 Genomes Project is used. The chromosome is 63, 025, 520 bps in length and the file is about 5.4Ã coverage. Running time of the three methods with different settings is shown in Table <xref ref-type="table" rid="T4">4</xref>. Each method is run using one thread on a 3192 MHz Intel Xeon workstation. It can be seen that SVseq2 is the fastest among the three methods in calling deletions. SVseq2 also runs faster in calling insertions than Pindel. Also note that the running time of SVseq1 and Pindel depends on the maximum event size. It can be seen that, if the maximum event size is set higher, both SVseq1 and Pindel will take even longer time to run. Before running SVseq1 and Pindel, running some additional scripts is needed to collect inputs for these two programs. Such preprocessing may take several minutes, which are not included in the table. SVseq2 takes the BAM file as input and there is no additional preprocessing.</p>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>Comparison of SVseq2, SVseq1 and Pindel on running time.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">Method</th>
              <th align="right">Max Event Size</th>
              <th align="left">SV Type</th>
              <th align="center">Time</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">SVseq2</td>
              <td align="right">None</td>
              <td align="left">DEL</td>
              <td align="center">1 m 48 s</td>
            </tr>
            <tr>
              <td/>
              <td align="right">None</td>
              <td align="left">INS</td>
              <td align="center">20 s</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">SVseq1</td>
              <td align="right">35, 000</td>
              <td align="left">DEL</td>
              <td align="center">8 m 40 s</td>
            </tr>
            <tr>
              <td/>
              <td align="right">1, 000, 000</td>
              <td align="left">DEL</td>
              <td align="center">82 m</td>
            </tr>
            <tr>
              <td colspan="4">
                <hr/>
              </td>
            </tr>
            <tr>
              <td align="left">Pindel</td>
              <td align="right">32, 368</td>
              <td align="left">DEL, INS, TD</td>
              <td align="center">7 m 40 s</td>
            </tr>
            <tr>
              <td/>
              <td align="right">517, 888</td>
              <td align="left">DEL, INS, TD</td>
              <td align="center">93 m</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>DEL stands for deletion, INS for insertion and TD for Tandem repeat.</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec sec-type="conclusions">
    <title>Conclusions</title>
    <p>There are four types of methods that use high throughput sequencing data to call SVs. Read depth methods and assembly methods usually need data with higher coverage. Read pair methods and read depth methods are not able to find exact breakpoints of SVs. Split-read mapping methods may find exact breakpoints of some SVs with low-coverage data. However, split-read mapping alone usually leads to significant false positives. Combining split-read mapping with other types of methods may increase the power in finding SVs. In this paper we describe an improved split-read mapping method to call SVs using low-coverage sequence data. We show that by using read pairs with discordant insert sizes, split-read mapping can be applied as mapping a segment of a split read on a focal region. Using the lemmas in the Methods section, we show that the length of the focal region can be much smaller than the maximum deletion size. Mapping split reads within a small focal region reduces the chance that a segment is aligned to incorrect positions. Thus, mapping split reads within focal regions leads to both higher accuracy and shorter running time. Applying on several datasets, we show that SVseq2 outperforms some other methods in both accuracy and efficiency. SVseq2 is more powerful compared to these methods when using very low coverage sequence data.</p>
    <p>The split-read mapping approach in SVseq2 can still be improved, e.g. to better model the error patterns of high throughput sequencing data. For the situation when there are repeats in focal regions, insert size analysis might be helpful in finding correct mapping.</p>
  </sec>
  <sec>
    <title>Availability</title>
    <p>The program SVseq2 can be downloaded at <ext-link ext-link-type="uri" xlink:href="http://www.engr.uconn.edu/~jiz08001/">http://www.engr.uconn.edu/~jiz08001/</ext-link>.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>JZ designed algorithms, developed software, performed analysis and experiments, wrote the paper. JW contributed to performing analysis and experiments. YW designed the algorithms, wrote the paper and supervised the project. All authors have read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>All the authors are supported by National Science Foundation grant IIS-0953563.</p>
    <p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 13 Supplement 6, 2012: Proceedings of the Second Annual RECOMB Satellite Workshop on Massively Parallel Sequencing (RECOMB-seq 2012). The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/bmcbioinformatics/supplements/13/S6">http://www.biomedcentral.com/bmcbioinformatics/supplements/13/S6</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <collab>Consortium TGP</collab>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09534</pub-id>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinfor-matics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Korbel</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Abyzov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Carriero</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Cayting</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Snyder</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>M</given-names>
        </name>
        <article-title>PEMer: a computational framework with simulation-based error models for inferring genomic structural variants from massive paired-end sequencing data</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>2</issue>
        <fpage>R23</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-2-r23</pub-id>
        <pub-id pub-id-type="pmid">19236709</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Chen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wallis</surname>
          <given-names>JW</given-names>
        </name>
        <name>
          <surname>McLellan</surname>
          <given-names>MD</given-names>
        </name>
        <name>
          <surname>Larson</surname>
          <given-names>DE</given-names>
        </name>
        <name>
          <surname>Kalicki</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Pohl</surname>
          <given-names>CS</given-names>
        </name>
        <name>
          <surname>McGrath</surname>
          <given-names>SD</given-names>
        </name>
        <name>
          <surname>Wendl</surname>
          <given-names>MC</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Q</given-names>
        </name>
        <name>
          <surname>Locke1</surname>
          <given-names>DP</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Fulton</surname>
          <given-names>RS</given-names>
        </name>
        <name>
          <surname>Ley</surname>
          <given-names>TJ</given-names>
        </name>
        <name>
          <surname>Wilson</surname>
          <given-names>RK</given-names>
        </name>
        <name>
          <surname>Ding</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Mardis</surname>
          <given-names>ER</given-names>
        </name>
        <article-title>BreakDancer: an algorithm for high-resolution mapping of genomic structural variation</article-title>
        <source>Nat Methods</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>677</fpage>
        <lpage>681</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1363</pub-id>
        <pub-id pub-id-type="pmid">19668202</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sindi</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Helman</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Bashir</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Raphael</surname>
          <given-names>B</given-names>
        </name>
        <article-title>A geometric approach for classification and comparison of structural variants</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>12</issue>
        <fpage>i222</fpage>
        <lpage>i230</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp208</pub-id>
        <pub-id pub-id-type="pmid">19477992</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Alkan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Kidd</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Marques-Bonet</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Aksay</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Antonacci</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Hormozdiari</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Kitzman</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Baker</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Malig</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mutlu</surname>
          <given-names>O</given-names>
        </name>
        <name>
          <surname>Sahinalp</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Gibbs</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Eichler</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Personalized copy number and segmental duplication maps using next-generation sequencing</article-title>
        <source>Nat Genet</source>
        <year>2009</year>
        <volume>41</volume>
        <fpage>1061</fpage>
        <lpage>1067</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.437</pub-id>
        <pub-id pub-id-type="pmid">19718026</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lam</surname>
          <given-names>HYK</given-names>
        </name>
        <name>
          <surname>Mu</surname>
          <given-names>XJ</given-names>
        </name>
        <name>
          <surname>Stutz</surname>
          <given-names>AM</given-names>
        </name>
        <name>
          <surname>Tanzer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Cayting</surname>
          <given-names>PD</given-names>
        </name>
        <name>
          <surname>Snyder</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kim</surname>
          <given-names>PM</given-names>
        </name>
        <name>
          <surname>Korbel</surname>
          <given-names>JO</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>MB</given-names>
        </name>
        <article-title>Nucleotide- resolution analysis of structural variants using BreakSeq and a breakpoint library</article-title>
        <source>Nat Biotechnol</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>47</fpage>
        <lpage>55</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.1600</pub-id>
        <pub-id pub-id-type="pmid">20037582</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abyzov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Urban</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Snyder</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>M</given-names>
        </name>
        <article-title>CNVnator: an approach to discover, genotype, and characterize typical and atypical CNVs from family and population genome sequencing</article-title>
        <source>Genome Res</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>6</issue>
        <fpage>974</fpage>
        <lpage>984</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.114876.110</pub-id>
        <pub-id pub-id-type="pmid">21324876</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Ye</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Schulz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Long</surname>
          <given-names>Q</given-names>
        </name>
        <name>
          <surname>Apweiler</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Ning</surname>
          <given-names>Z</given-names>
        </name>
        <article-title>Pindel: a pattern growth approach to detect break points of large deletions and medium sized insertions from paired-end short reads</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2865</fpage>
        <lpage>2871</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp394</pub-id>
        <pub-id pub-id-type="pmid">19561018</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>ZD</given-names>
        </name>
        <name>
          <surname>Du</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Abyzov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Urban</surname>
          <given-names>AE</given-names>
        </name>
        <name>
          <surname>Snyder</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Identification of genomic indels and structural variations using split reads</article-title>
        <source>BMC Genomics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>375</fpage>
        <lpage>386</lpage>
        <pub-id pub-id-type="doi">10.1186/1471-2164-12-375</pub-id>
        <pub-id pub-id-type="pmid">21787423</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Abyzov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>M</given-names>
        </name>
        <article-title>AGE: defining breakpoints of genomic structural variants at single-nucleotide resolution, through optimal alignments with gap excision</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>5</issue>
        <fpage>595</fpage>
        <lpage>603</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq713</pub-id>
        <pub-id pub-id-type="pmid">21233167</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Mullighan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Easton</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Roberts</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Heatley</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ma</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Rusch</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Harris</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Ding</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Holmfeldt</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Payne-Turner</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Fan</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Wei</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Zhao</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Obenauer</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Naeve</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Mardis</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Wilson</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Downing</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>CREST maps somatic structural variation in cancer genomes with base-pair resolution</article-title>
        <source>Nat Methods</source>
        <year>2011</year>
        <volume>8</volume>
        <fpage>652</fpage>
        <lpage>654</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1628</pub-id>
        <pub-id pub-id-type="pmid">21666668</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>SVseq: an approach for detecting exact breakpoints of deletions with low-coverage sequence data</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>23</issue>
        <fpage>3228</fpage>
        <lpage>3234</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr563</pub-id>
        <pub-id pub-id-type="pmid">21994222</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Handsaker</surname>
          <given-names>RE</given-names>
        </name>
        <name>
          <surname>Korn</surname>
          <given-names>JM</given-names>
        </name>
        <name>
          <surname>Nemesh</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>McCarroll</surname>
          <given-names>SA</given-names>
        </name>
        <article-title>Discovery and genotyping of genome structural polymorphism by sequencing on a population scale</article-title>
        <source>Nat Genet</source>
        <year>2011</year>
        <volume>43</volume>
        <fpage>269</fpage>
        <lpage>276</lpage>
        <pub-id pub-id-type="doi">10.1038/ng.768</pub-id>
        <pub-id pub-id-type="pmid">21317889</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mills</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Walter</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Stewart</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Handsaker</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Alkan</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Abyzov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Yoon</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ye</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Cheetham</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Chinwalla</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Conrad</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Fu</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Grubert</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Hajirasouliha</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Hormozdiari</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Iakoucheva</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Iqbal</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Kang</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kidd</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Konkel</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Korn</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Khurana</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Kural</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Lam</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Leng</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Luo</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Mu</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Nemesh</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Peckham</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Rausch</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Scally</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Stromberg</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Stutz</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Urban</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Walker</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wu</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Batzer</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Ding</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Marth</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>McVean</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Sebat</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Snyder</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Ye</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Eichler</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Gerstein</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Hurles</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Lee</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>McCarroll</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Korbel</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Project</surname>
          <given-names>G</given-names>
        </name>
        <article-title>Mapping copy number variation by population-scale genome sequencing</article-title>
        <source>Nature</source>
        <year>2011</year>
        <volume>470</volume>
        <fpage>59</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09708</pub-id>
        <pub-id pub-id-type="pmid">21293372</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
