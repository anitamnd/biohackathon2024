<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3283304</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-12-S9-S15</article-id>
    <article-id pub-id-type="pmid">22151882</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-12-S9-S15</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Proceedings</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>STELLAR: fast and exact local alignments</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Kehr</surname>
          <given-names>Birte</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>birte.kehr@fu-berlin.de</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Weese</surname>
          <given-names>David</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>david.weese@fu-berlin.de</email>
      </contrib>
      <contrib contrib-type="author" id="A3">
        <name>
          <surname>Reinert</surname>
          <given-names>Knut</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>knut.reinert@fu-berlin.de</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computer Science, Free University Berlin, Takustr. 9, 14195 Berlin, Germany</aff>
    <aff id="I2"><label>2</label>International Max Planck Research School for Computational Biology and Scientific Computing, Ihnestr. 63-73, 14195 Berlin, Germany</aff>
    <pub-date pub-type="collection">
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>5</day>
      <month>10</month>
      <year>2011</year>
    </pub-date>
    <volume>12</volume>
    <issue>Suppl 9</issue>
    <supplement>
      <named-content content-type="supplement-title">Proceedings of the Ninth Annual Research in Computational Molecular Biology (RECOMB) Satellite Workshop on Comparative Genomics</named-content>
      <named-content content-type="supplement-editor">Aaron Darling and Cathal Seoighe</named-content>
    </supplement>
    <fpage>S15</fpage>
    <lpage>S15</lpage>
    <permissions>
      <copyright-statement>Copyright ©2011 Kehr et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2011</copyright-year>
      <copyright-holder>Kehr et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/12/S9/S15"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Large-scale comparison of genomic sequences requires reliable tools for the search of local alignments. Practical local aligners are in general fast, but heuristic, and hence sometimes miss significant matches.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present here the local pairwise aligner STELLAR that has full sensitivity for <italic>ε</italic>-alignments, i.e. guarantees to report all local alignments of a given minimal length and maximal error rate. The aligner is composed of two steps, filtering and verification. We apply the SWIFT algorithm for lossless filtering, and have developed a new verification strategy that we prove to be exact. Our results on simulated and real genomic data confirm and quantify the conjecture that heuristic tools like BLAST or BLAT miss a large percentage of significant local alignments.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>STELLAR is very practical and fast on very long sequences which makes it a suitable new tool for finding local alignments between genomic sequences under the edit distance model. Binaries are freely available for Linux, Windows, and Mac OS X at <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de/projects/stellar">http://www.seqan.de/projects/stellar</ext-link>. The source code is freely distributed with the SeqAn C++ library version 1.3 and later at <ext-link ext-link-type="uri" xlink:href="http://www.seqan.de">http://www.seqan.de</ext-link>.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>8-10 October 2011</conf-date>
      <conf-name>Ninth Annual Research in Computational Molecular Biology (RECOMB) Satellite Workshop on Comparative Genomics</conf-name>
      <conf-loc>Galway, Ireland</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Introduction</title>
    <p>Computing good local alignments is a fundamental problem in bioinformatics. By looking for local alignments of biological sequences one aims for example at identifying homologous regions, i.e. regions that are assumed to originate from the same ancestral sequence, or at finding functionally similar sequences. The problem has been studied for more than 30 years [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], but still remains interesting. In the beginning, local alignments were used to look for homologous regions in relatively short protein or nucleic acid sequences. Also, for a long time, local alignments have been used to identify conserved, functionally related elements. More recently, local alignments were applied on a genomic scale as prerequisite to global genomic alignments. For several reasons genomic scale alignments are usually not collinear and hence one has to resort to computing local similarities. Now the aim is not anymore to identify <italic>some</italic> homologous regions but rather to display <italic>all</italic> similarities between two or more genomic sequences [<xref ref-type="bibr" rid="B3">3</xref>-<xref ref-type="bibr" rid="B7">7</xref>]. This requires not only efficiency in computation to process very long sequences, but also accuracy regarding sensitivity, i.e. exact tools that do not miss regions of significant local similarity.</p>
    <p>For the computation of local alignments numerous tools have been developed: Early tools such as SSEARCH [<xref ref-type="bibr" rid="B2">2</xref>] and FASTA [<xref ref-type="bibr" rid="B16">16</xref>] are sensitive but too slow for large-scale sequence comparison. Then, there are efficient heuristics, with the BLAST family [<xref ref-type="bibr" rid="B17">17</xref>-<xref ref-type="bibr" rid="B19">19</xref>] being the most prominent example. Further developments for specific large-scale analyzes resulted in tools like BLAT [<xref ref-type="bibr" rid="B20">20</xref>] which was designed for high speed, and BLASTZ [<xref ref-type="bibr" rid="B21">21</xref>] which was designed for higher sensitivity. The more recently published tool BWT-SW [<xref ref-type="bibr" rid="B22">22</xref>] again focuses on sensitivity and is able to report all local alignments.</p>
    <p>To assess homology of biological sequences by local alignment, generally some kind of similarity criterion is necessary. The most widely accepted criterion is the <italic>E-value</italic>[<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B23">23</xref>], a probabilistic measure that assesses the significance of a local alignment. The E-value denotes the expected number of local alignments with a minimal score occurring by chance in the input sequences. The score underlying the E-value is a Smith-Waterman-like score, most commonly using affine gap costs. All popular alignment tools that report E-values, e.g. BLAST, compute such a score, and afterward apply an E-value threshold on their output. In this paper, we describe a method that follows an alternative approach to compute only significant local alignments of nucleic acid sequences: We compute only high-scoring alignments, which are guaranteed to have a good (low) E-value. We use a maximal error rate for local alignments (normalized edit distance) as a score threshold, and additionally require a minimal alignment length. Our method is specialized on relatively low error rates, which in turn justifies the use of edit distance instead of affine gap costs. For a given error rate and a minimal alignment length our method is exact, i.e. it identifies all local alignments without loss of sensitivity. We compute an E-value for all generated local alignments and a minimal E-value for the input parameters. The method is implemented in the program STELLAR (SwifT Exact LocaL AligneR) using the SeqAn C++ library [<xref ref-type="bibr" rid="B24">24</xref>,<xref ref-type="bibr" rid="B25">25</xref>]. The program depends only on very few and clearly understandable parameters. We prove that our algorithm is exact for all reasonable parameter settings and confirm this experimentally. We compare STELLAR against popular local alignment programs, namely BLAST, LASTZ, BLAT, and BWT-SW in terms of speed and sensitivity and show that some of the tools miss many significant local alignments that can be detected with STELLAR.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Definitions and overview of algorithm</title>
      <p>A pairwise local alignment of length <italic>n</italic> is a sequence of <italic>n</italic> match, insertion, deletion, and substitution columns. In our approach deletion, insertion, and substitution columns are all treated equally. Hence, we will call these columns <italic>error</italic> columns. The number of error columns is the edit or Levenshtein distance of a local alignment. Normalizing this distance by dividing it by the length of the local alignment, we obtain an <italic>error rate.</italic> An <italic>ε-match</italic> is a local alignment that has an error rate of at most <italic>ε</italic> &gt; 0 and length <italic>n</italic> ≥ <italic>n</italic><sub>0</sub>. Fig. <xref ref-type="fig" rid="F1">1</xref> shows two examples of <italic>ε</italic>-matches as segments of a longer local alignment.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Overlapping <italic>ε</italic>-matches.</bold> An alignment of two strings containing two overlapping <italic>ε</italic>-matches for <italic>ε</italic> = 0.1 and <italic>n</italic><sub>0</sub> = 20. The <italic>ε</italic>-match indicated by the dashed box has an error rate of 2/22, the <italic>ε</italic>-match indicated by the box with a continuous line one of 2/25. The union of these two <italic>ε</italic>-matches from position 4 to position 31 is not an <italic>ε</italic>-match: the error rate is 3/28 &gt; 0.1. Furthermore, the intersection of the two <italic>ε</italic>-matches is with 19 columns too short to be an <italic>ε</italic>-match.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-S9-S15-1"/>
      </fig>
      <p>The notion of an <italic>X – drop</italic> to delineate local alignments from each other is well established by Miller and coworkers in the context of similarity alignments [<xref ref-type="bibr" rid="B18">18</xref>,<xref ref-type="bibr" rid="B26">26</xref>,<xref ref-type="bibr" rid="B27">27</xref>]. An <italic>X-drop</italic> within an alignment, where <italic>X</italic> &gt; 0 is given, is a region of consecutive columns with a total score of <italic>–X</italic> or less. In other words, it is a region where the score drops by <italic>X</italic> or more. In Fig. <xref ref-type="fig" rid="F2">2</xref> we display an example in which we score error columns by –1. The X-drop is a very intuitive way to model local dissimilarity and hence we choose to adopt the concept for our model of local similarity. Since we address the computation of <italic>ε</italic>-matches in this paper we propose the following scoring scheme that depends on the error rate <italic>ε</italic>: We score a match by +1 and an error by <italic>p</italic> = <italic>–</italic>1/<italic>ε</italic> + 1. In addition, we adjust the score drop-off parameter by multiplying it with the negative of the error penalty –<italic>p</italic> such that the user specified parameter <italic>X</italic> still corresponds to the number of errors in a match-free X-drop region and is easy to grasp for the user (Fig. <xref ref-type="fig" rid="F3">3</xref>). To emphasize the difference from the usual understanding of an X-drop we call this weighted X-drop an <italic>ε-X-drop.</italic></p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>X-drop</bold>. An alignment containing an X-drop for <italic>X</italic> = 3. In this example, an <italic>ε</italic>-match with <italic>ε</italic> = 0.1 and <italic>n</italic><sub>0</sub> = 20 (indicated by the box) spans the X-drop.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-S9-S15-2"/>
      </fig>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold><italic>ε</italic>-X-drop.</bold> An alignment containing an <italic>ε</italic>-X-drop for <italic>X</italic> = 3 and <italic>ε</italic> = 0.1. To reach an <italic>ε</italic>-X-drop with a score drop-off of at least <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i1.gif"/></inline-formula>, a fourth error column is necessary in this example because of the positively scoring matches in between the errors.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-S9-S15-3"/>
      </fig>
      <p>The goal of this work is to find <italic>ε</italic>-matches of two sequences without <italic>ε</italic>-X-drops. Often, <italic>ε</italic>-matches overlap to a large extent (see Fig. <xref ref-type="fig" rid="F1">1</xref> for an example), or segments of <italic>ε</italic>-matches are themselves <italic>ε</italic>-matches (e.g. we obtain an <italic>ε</italic>-match by removing a column from one end of the <italic>ε</italic>-matches in Fig. <xref ref-type="fig" rid="F1">1</xref>). Thus, the number of <italic>ε</italic>-matches can be very large with very redundant similarity information. We handle this issue by only identifying the longest <italic>ε</italic>-match of one location: If two <italic>ε</italic>-matches overlap, we output only the longer one unless the overhanging part of the shorter <italic>ε</italic>-match still has a minimal length of <italic>n</italic><sub>0</sub>. In that case we output both complete <italic>ε</italic>-matches. Thus, for the example in Fig. <xref ref-type="fig" rid="F1">1</xref> we only output one <italic>ε</italic>-match. We say that such an <italic>ε</italic>-match is <italic>maximal.</italic></p>
      <p>We now present an algorithm to compute exactly <italic>all</italic> maximal <italic>ε</italic>-matches without <italic>ε</italic>-X-drop. Our algorithm runs in two phases: filtering and verification. The filtering phase implements the SWIFT algorithm [<xref ref-type="bibr" rid="B28">28</xref>], a very efficient full-sensitivity filter for <italic>ε</italic>-matches. Note that SWIFT is a <italic>filter</italic> algorithm and does not output a list of <italic>ε</italic>-matches. While it guarantees not to miss any maximal <italic>ε</italic>-match and hugely reduces the search space, a verification phase is necessary to identify false positive hits of the filter. Furthermore, verification is needed to determine the exact start and end positions of maximal <italic>ε</italic>-matches. We have developed a verification strategy that runs in five steps: <italic>ε</italic>-core identification, <italic>ε</italic>-X-drop core filter, <italic>ε</italic>-X-drop extension, identification of maximal <italic>ε</italic>-matches, and filtering of overlapping matches. Verification may stop after any of these steps if it is clear that we will not identify a new <italic>ε</italic>-match without <italic>ε</italic>-X-drop. The strategy guarantees to find all maximal <italic>ε</italic>-matches without <italic>ε</italic>-X-drop.</p>
      <p>A similar two-step algorithm that consists of SWIFT filtering and subsequent verification is implemented in the read mapper RazerS [<xref ref-type="bibr" rid="B14">14</xref>]. The difference to RazerS is, however, that we are looking for <italic>ε</italic>-matches that are local in both sequences whereas read mappers compute semi-global alignments, i.e align the full read sequence to a reference. RazerS uses a slightly modified SWIFT filtering, and the verification is much simpler since the length of the final alignments is preset by the read length.</p>
    </sec>
    <sec>
      <title>Filtering phase</title>
      <p>The SWIFT algorithm proposed by Rasmussen et al. is an efficient <italic>q</italic>-gram based filter to detect potential <italic>ε</italic>-match regions between two sequences. It is based on the <italic>q</italic>-gram lemma [<xref ref-type="bibr" rid="B29">29</xref>,<xref ref-type="bibr" rid="B30">30</xref>]. This lemma states that every alignment of length <italic>n</italic> with <italic>k</italic> error columns contains at least <italic>T</italic>(<italic>n</italic>, <italic>k</italic>, <italic>q</italic>) := <italic>n</italic> + 1 – <italic>q</italic>(<italic>k</italic> + 1) <italic>q</italic>-hits, substrings of <italic>q</italic> consecutive match columns. Considering the dotplot of two sequences, every <italic>q</italic>-hit corresponds to a diagonal stretch of matches with length <italic>q.</italic> Obviously, all <italic>q</italic>-hits of an alignment with <italic>k</italic> errors can cover at most <italic>k</italic> + 1 different diagonals in the dotplot.</p>
      <p>Rasmussen et al. proved that for any given <italic>ε</italic> and <italic>n</italic><sub>0</sub> there exist <italic>w</italic>, <italic>q</italic>, <italic>e</italic> and <italic>τ</italic> such that every <italic>ε</italic>-match contains <italic>τ q</italic>-hits that reside in a <italic>w</italic> × <italic>e</italic> parallelogram. A <italic>w</italic> × <italic>e</italic> parallelogram is the intersection of <italic>e</italic> + 1 consecutive diagonals and <italic>w</italic> + 1 consecutive columns in the dotplot.</p>
      <p>To detect <italic>w</italic> × <italic>e</italic> parallelograms with <italic>τ q</italic>-hits in the dotplot, the SWIFT algorithm slides from left to right over one sequence and searches overlapping <italic>q</italic>-grams in a <italic>q</italic>-gram index of the other sequence. Found <italic>q</italic>-hits are counted in bins of Δ + <italic>e</italic> consecutive diagonals whose first diagonal is a multiple of Δ. As adjacent bins share e diagonals, every <italic>w</italic> × <italic>e</italic> parallelogram is contained in one bin. Every bin contains a <italic>q</italic>-hit counter and represents the parallelogram with columns bounded by the leftmost and rightmost contained <italic>q</italic>-hit. If a <italic>q</italic>-hit is found that is at most <italic>w – q</italic> columns apart from the rightmost <italic>q</italic>-hit, the parallelogram is extended. Otherwise it is closed and a new one starting at the found <italic>q</italic>-hit is opened as the two hits cannot be part of the same <italic>w</italic> × <italic>e</italic> parallelogram. A closed parallelogram whose bin counter has reached <italic>τ</italic> is output as a <italic>SWIFT hit</italic> and verified as described in the following section.</p>
      <p>Fig. <xref ref-type="fig" rid="F4">4</xref> shows examples for SWIFT hits containing either a subalignment of an <italic>ε</italic>-match, whole <italic>ε</italic>-matches, no <italic>ε</italic>-match or an <italic>ε</italic>-match with an X-drop.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>Example SWIFT hits</bold>. Example SWIFT hits for <italic>n</italic><sub>0</sub> = 20, <italic>ε</italic> = 0.1, and <italic>q</italic> = 6 (= <italic>s<sup>min</sup></italic>). Accordingly, <italic>w</italic> = 20, <italic>τ</italic> = 3, and e = 2. SWIFT searches parallelograms that contain at least <italic>τ</italic> = 3 <italic>q</italic>-gram hits by streaming over sequence 1 and searching common <italic>q</italic>-grams in sequence 2. Subfigure (a) shows an <italic>ε</italic>-match that results in two SWIFT hits and the <italic>ε</italic>-match is longer than both of the two hits. (b) shows a SWIFT hit that contains two <italic>ε</italic>-matches and (c) shows a false positive SWIFT hit induced by three separated <italic>q</italic>-gram hits. (d) shows a SWIFT hit that contains an <italic>ε</italic>-match with a 3-drop.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-S9-S15-4"/>
      </fig>
    </sec>
    <sec>
      <title>Verification phase</title>
      <p>Fig. <xref ref-type="fig" rid="F4">4</xref> demonstrates that the output of the filtering phase is not yet a list of <italic>ε</italic>-matches, although the SWIFT algorithm hugely reduces the search space. SWIFT hits may contain one or more <italic>ε</italic>-matches, but may as well be false positive and contain no <italic>ε</italic>-match. Some SWIFT hits may overlap and contain the same or parts of the same <italic>ε</italic>-match. Further, they may be much longer than a contained <italic>ε</italic>-match, or they may cover only parts of an <italic>ε</italic>-match. Therefore, we have developed the following verification strategy.</p>
      <p>We start verifying SWIFT hits by identifying a segment of an <italic>ε</italic>-match that overlaps with the SWIFT hit. We call such a segment an <italic>ε-core.</italic> We guarantee not to miss any <italic>ε</italic>-match by identifying all <italic>ε</italic>-cores contained in a SWIFT hit. <italic>ε</italic>-cores will then serve as starting points for extension, possibly beyond the ends of SWIFT hits. Finally, we cut the longest <italic>ε</italic>-matches from extended <italic>ε</italic>-cores and remove overlapping <italic>ε</italic>-matches.</p>
      <sec>
        <title>Definition and existence of <italic>ε</italic>-cores</title>
        <p>Under the simple scoring scheme where a match scores +1 and an error <italic>p</italic> = <italic>–</italic>1/<italic>ε</italic> + 1, we define an <italic>ε</italic>-core of an <italic>ε</italic>-match as a segment with a score of at least:<disp-formula><graphic xlink:href="1471-2105-12-S9-S15-i2.gif"/></disp-formula></p>
        <p>where <italic>n</italic><sub>0</sub> is the minimal length of an <italic>ε</italic>-match and <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i3.gif"/></inline-formula> is the next larger length that allows one more error than <italic>n</italic><sub>0</sub>.</p>
        <p>In the following two lemmata we prove the correctness of our approach that starts verification from <italic>ε</italic>-cores.</p>
        <p>
          <bold>Lemma 1. </bold>
          <italic>Every ε-mαtch contains at least one ε-core.</italic>
        </p>
        <p><italic>Proof.</italic><inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i4.gif"/></inline-formula> is the maximal number of errors in an <italic>ε</italic>-match of length <italic>n</italic>. Thus, the number of matching positions in an <italic>ε</italic>-match of length <italic>n</italic> is at least <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i5.gif"/></inline-formula>. These <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i6.gif"/></inline-formula> matching positions can be split by the errors of the <italic>ε</italic>-match into at most <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i7.gif"/></inline-formula> error-free segments. If the errors are spread evenly over the <italic>ε</italic>-match, at least one of the error-free segments has length ≥ <italic>l</italic>(<italic>n</italic>, <italic>ε</italic>), where <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i8.gif"/></inline-formula>. Some thought reveals that any other distribution of the errors would result in at least one longer error-free segment. Therefore, an <italic>ε</italic>-match of length <italic>n</italic> contains at least one <italic>ε</italic>-core of length ≥ <italic>l</italic>(<italic>n</italic>, <italic>ε</italic>)<italic>.</italic> Unfortunately, <italic>l</italic>(<italic>n</italic>, <italic>ε</italic>) is a sawtooth function, i.e. <italic>l</italic>(<italic>n</italic>, <italic>ε</italic>) is not monotonically increasing in <italic>n</italic> (Fig. <xref ref-type="fig" rid="F5">5</xref>). Hence, one cannot use <italic>l</italic>(<italic>n</italic><sub>0</sub>, <italic>ε</italic>) as a bound for all <italic>n</italic> ≥ <italic>n</italic><sub>0</sub>. The function drops to a minimum at each point <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i9.gif"/></inline-formula>. However, it is easy to confirm that the minima are strictly increasing, i.e. each successive minimum of the sawtooth is higher than the previous one. Therefore, the smallest value of <italic>l</italic>(<italic>n</italic>, <italic>ε</italic>) over all <italic>n</italic> ≥ <italic>n</italic><sub>0</sub> is the minimum of <italic>l</italic>(<italic>n</italic><sub>0</sub>, <italic>ε</italic>) and <italic>l</italic>(<italic>n</italic><sub>1</sub>, <italic>ε</italic>). This is exactly the definition of <italic>s</italic><sup>min</sup>, i.e. an <italic>ε</italic>-match contains at least one error-free segment of length <italic>s<sup>min</sup></italic> which is an <italic>ε</italic>-core. □</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p><bold>Sawtoothed function.</bold> Plot of the sawtoothed function <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i15.gif"/></inline-formula> for <italic>n</italic><sub>0</sub> and <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i16.gif"/></inline-formula> with <italic>ε</italic> = 0.05.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-S9-S15-5"/>
        </fig>
        <p>Lemma 1 settles the existence of an <italic>ε</italic>-core for every <italic>ε</italic>-match. Unfortunately, the SWIFT filter only guarantees to report SWIFT hits that <italic>overlap</italic> a part of each <italic>ε</italic>-match. Hence, in principle, the SWIFT hit could not contain an <italic>ε</italic>-core, which in turn could make our algorithm miss the <italic>ε</italic>-match. In the next lemma we will show that for a certain value of the parameter <italic>q</italic> this is never the case.</p>
        <p><bold>Lemma 2. </bold><italic>The intersection of a SWIFT hit with an ε-match contains at least one ε-core if q</italic> := <italic>s<sup>min</sup>.</italic></p>
        <p><italic>Proof.</italic> By definition, the intersection of a SWIFT hit with an <italic>ε</italic>-match contains at least <italic>τ q</italic>-grams interspersed by at most <italic>e</italic> errors. Therefore, every SWIFT hit contains at least one segment of at least <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i10.gif"/></inline-formula> consecutive <italic>q</italic>-grams. The length of this segment is at least <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i11.gif"/></inline-formula>. Because <italic>τ</italic> &gt; 0 and e ≥ 0 the first summand <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i12.gif"/></inline-formula> is greater or equal one, so we obtain <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i13.gif"/></inline-formula>. Thus, if we set <italic>q</italic> := <italic>s<sup>min</sup></italic> every SWIFT hit contains at least one segment of length <italic>s<sup>min</sup></italic>, which is an <italic>ε</italic>-core. □</p>
      </sec>
      <sec>
        <title>Step 1: <italic>ε</italic>-core identification</title>
        <p>In our verification strategy, we identify <italic>ε</italic>-cores by applying a banded version of the Waterman-Eggert local alignment algorithm [<xref ref-type="bibr" rid="B31">31</xref>]. The original algorithm computes all non-overlapping local alignments that reach a specified minimal score under a certain scoring scheme by dynamic programming (DP). We use the scoring scheme that scores matches by +1 and errors by <italic>p</italic> = <italic>–</italic>1/<italic>ε</italic> + 1 and set the minimal score to <italic>s<sup>min</sup>.</italic> In our version, we reduce running time and space requirements of the algorithm by banding the computation of the DP matrix according to the parallelogram shape of SWIFT hits (see Fig. <xref ref-type="fig" rid="F4">4</xref>, only the shaded parts of the alignment matrix need to be computed). Thus, per <italic>ε</italic>-core there is a maximum running time of <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i14.gif"/></inline-formula> where <italic>w′</italic> is the length and <italic>e</italic> the width of the corresponding SWIFT hit.</p>
        <p>Since the Waterman-Eggert algorithm reports only non-overlapping local alignments one may think that some <italic>ε</italic>-cores will not be identified because they are hidden by longer local alignments that reach beyond the end of an <italic>ε</italic>-match. However, this can only be for non-maximal <italic>ε</italic>-matches since we have chosen the scoring parameters such that <italic>ε</italic>-cores extended by additional local alignment columns only have higher scores if the additional columns have themselves an error rate of at most <italic>ε</italic> (Fig. <xref ref-type="fig" rid="F6">6</xref>). This is why all maximal <italic>ε</italic>-matches will also include the additional columns, i.e. no local alignment will reach beyond the end of an <italic>ε</italic>-match.</p>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>Extended <italic>ε</italic>-core</bold>. An <italic>ε</italic>-match extended by one error column and <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i17.gif"/></inline-formula> match columns, is still an <italic>ε</italic>-match. Therefore, an <italic>ε</italic>-core should include such an extension, since all maximal <italic>ε</italic>-matches at this location will include it. In this example where <italic>ε</italic> = 0.1 and <italic>n</italic><sub>0</sub> = 20 we see an error-free segment of length 7 ≥ 6 = <italic>s<sup>min</sup></italic> that can be extended to an <italic>ε</italic>-core of length 19 including one error.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-S9-S15-6"/>
        </fig>
      </sec>
      <sec>
        <title>Step 2: <italic>ε</italic>-X-drop core filter</title>
        <p>The second step of our verification strategy is a filter for <italic>ε</italic>-X-drops in the <italic>ε</italic>-cores. In the previous step we ignored <italic>ε</italic>-X-drops in <italic>ε</italic>-cores. If now one of our <italic>ε</italic>-cores contains an <italic>ε</italic>-X-drop, the <italic>ε</italic>-core should be divided into two cores in order to remove the <italic>ε</italic>-X-drop. Similarly, if an <italic>ε</italic>-core contains more than one <italic>ε</italic>-X-drop, the <italic>ε</italic>-core should be divided into even more cores.</p>
        <p>For this decomposition of the <italic>ε</italic>-cores, we apply the post-processing algorithm from Zhang et al. [<xref ref-type="bibr" rid="B27">27</xref>] with the same scores and penalties for matching and error positions as in our <italic>ε</italic>-core identification step. The worst-case running time of this algorithm is linear in the length of the <italic>ε</italic>-core.</p>
        <p>Possibly, we obtain more than one <italic>ε</italic>-core after this step, but in any case the following extension step has to be conducted only to the left and right of the original non-decomposed <italic>ε</italic>-core. If we started with an <italic>ε</italic>-core with more than one <italic>ε</italic>-X-drop, we can skip the following extension step for the middle parts, since the extension algorithm would run immediately into the previously detected <italic>ε</italic>-X-drops.</p>
      </sec>
      <sec>
        <title>Step 3: <italic>ε</italic>-X-drop extension</title>
        <p>The goal of the extension step is to obtain a region that spans all <italic>ε</italic>-matches without <italic>ε</italic>-X-drop containing the <italic>ε</italic>-core. In this region, the <italic>extended ε-core</italic>, we can then look for the maximal <italic>ε</italic>-match. Clearly, we can discard extended <italic>ε</italic>-cores that are shorter than <italic>n</italic><sub>0</sub>.</p>
        <p>For extension we apply the gapped extension algorithm by Zhang et al. [<xref ref-type="bibr" rid="B19">19</xref>] with the <italic>ε</italic>-adjusted scoring parameters as before. This algorithm is a score-only algorithm, i.e. it reports only the score and the sequence positions of the maximal extension but not the precise alignment. However, it reports the maximal and minimal diagonal of the alignment matrix (a band) that needs to be computed when looking for the precise alignment. We will determine the alignment in the next step of the verification strategy together with the exact begin and end positions of the maximal <italic>ε</italic>-match.</p>
        <p>It is hard to do an informative running time analysis for this step. In theory, the dynamic programming algorithm could fill big parts of the alignment matrix. However, for very similar sequences only a narrow diagonal stretch will be filled, and for very distinct sequences we will soon reach an X-drop and stop. Still, we can estimate the running time by <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i18.gif"/></inline-formula> where <italic>L</italic> is the length of the extension and <italic>b</italic> is the width of the band.</p>
        <p>It is easy to confirm that if an <italic>ε</italic>-core is part of an <italic>ε</italic>-match without <italic>ε</italic>-X-drop, then the extended <italic>ε</italic>-core spans this <italic>ε</italic>-match without <italic>ε</italic>-X-drop.</p>
      </sec>
      <sec>
        <title>Step 4: identification of maximal <italic>ε</italic>-matches</title>
        <p>The remaining task is to determine the longest alignment in the extended <italic>ε</italic>-core that has an error rate of at most <italic>ε.</italic> More precisely, we are looking for the longest extension to the left and to the right of the <italic>ε</italic>-core such that the complete alignment has an error rate of at most <italic>ε.</italic> The maximal error rate (i.e. the number of errors and length) that we can allow for the extension to the left depends not only on the error rate of the <italic>ε</italic>-core but also on the error rate of the extension to the right, and vice versa. Therefore, we cannot determine the lengths of the right and left extension separately. Furthermore, depending on the length of the extension the optimal trace through the alignment matrix can differ (Fig. <xref ref-type="fig" rid="F7">7</xref>). Our suggestion is to compute for all possible extension lengths the optimal end position of a trace in the alignment matrix, then to determine the optimal lengths of the right and left extension, and lastly to carry out the traceback. The details of these three steps are described in the following.</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p><bold>Extension traces of an <italic>ε</italic>-core.</bold> Alignment matrix with two possible traces of the extension of an <italic>ε</italic>-core. Depending on the length of the extension (red numbers), we obtain the lowest error rates by aligning different sequence positions to each other. For an extension length of 5, 7, and 9 it is better to follow the upper trace, whereas for a length of 11 the lower trace has fewer errors. For all other lengths there is a longer trace with the same number of errors, and therefore it is not necessary to consider those lengths while looking for maximal <italic>ε</italic>-matches.</p>
          </caption>
          <graphic xlink:href="1471-2105-12-S9-S15-7"/>
        </fig>
        <p>The computation of the optimal end position of a trace for all possible extension lengths can be done along with the computation of the alignment matrix. Unfortunately, two traces of different lengths may end in the same column of the alignment matrix. For this reason, it is necessary to compute the alignment matrix using an algorithm for normalized alignment score [<xref ref-type="bibr" rid="B32">32</xref>,<xref ref-type="bibr" rid="B33">33</xref>], which in addition iterates over all alignment lengths. As already mentioned, the alignment matrix can be banded by the minimal and maximal diagonal from the seed extension algorithm.</p>
        <p>Along with the alignment matrix computation we check and if necessary update in each iteration step a list <italic>bestEnds</italic> with the best alignment matrix entry for the corresponding extension length. Each entry consists of the length and score (or number of errors) of the alignment, and coordinates in the alignment matrix. This list can afterward be reduced to a smaller set of possible lengths using the following observation: The position before the start and the position behind the end of the sought <italic>ε</italic>-match is an error, otherwise the <italic>ε</italic>-match would not be maximal. Hence, we only need to keep those list entries for lengths <italic>l</italic> where the score difference of <italic>bestEnd</italic>[<italic>l</italic>] and <italic>bestEnd</italic>[<italic>l</italic> + 1] is smaller than the score of a match. As a result we obtain two lists with possible traceback starting points, one for start positions of the <italic>ε</italic>-match obtained from the left extension, and one for end positions obtained from the right extension.</p>
        <p>On these lists we then apply the following exhaustive search algorithm that iterates over combinations of possible start and end positions: We start with the leftmost possible start position and iterate over possible end positions from right to left. We continue with the next possible start position and restart with the rightmost possible end position as soon as the segment between the current start and end position has an error rate of at most <italic>ε</italic> (update currently longest <italic>ε</italic>-match), or if this segment is shorter than the minimal <italic>ε</italic>-match length or our currently longest <italic>ε</italic>-match (do not update currently longest <italic>ε</italic>-match). The algorithm stops when the segment between the current start position and the rightmost possible end position is shorter than the minimal <italic>ε</italic>-match length or the currently longest <italic>ε</italic>-match. Using this strategy we cannot miss the longest <italic>ε</italic>-match without <italic>ε</italic>-X-drop if the <italic>ε</italic>-core is part of one.</p>
        <p>In case there is another maximal <italic>ε</italic>-match containing the <italic>ε</italic>-core, we have to recurse this search twice with the lists reduced by the following entries: All start positions before the start position of the longest <italic>ε</italic>-match and all end positions that are smaller than <italic>n</italic><sub>0</sub> added to the end position of the longest <italic>ε</italic>-match; and all start positions before the start position of the longest <italic>ε</italic>-match minus <italic>n</italic><sub>0</sub> and all end positions behind the end position of the longest <italic>ε</italic>-match.</p>
        <p>As a last step, we have to look up the coordinates for the optimal extensions in the <italic>bestEnd</italic> lists and start traceback from these positions in the alignment matrices. The <italic>ε</italic>-core extended by the resulting alignments is a maximal <italic>ε</italic>-match that contains the <italic>ε</italic>-core.</p>
        <p>The running time for computing the alignment matrix using a normalized alignment score is in <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i19.gif"/></inline-formula> where <italic>b</italic> is again the width of the band and <italic>L</italic> is the length of the extension. Dropping the normalization of the alignment score reduces running time by a factor of <italic>L.</italic> Determining the optimal start end end position in the left extension of length <italic>L</italic><sub>1</sub> and right extension of length <italic>L</italic><sub>2</sub> takes <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i20.gif"/></inline-formula> time per <italic>ε</italic>-match, and finally, the traceback takes time linear in the length of the final <italic>ε</italic>-match.</p>
      </sec>
      <sec>
        <title>Step 5: removal of largely overlapping <italic>ε</italic>-matches</title>
        <p>An <italic>ε</italic>-match identified during the verification phase is the longest that contains one specific <italic>ε</italic>-core but it is not necessarily maximal in that it does not overlap with a longer <italic>ε</italic>-match. In addition, an <italic>ε</italic>-match containing two <italic>ε</italic>-cores will be identified twice. To ensure that we output each <italic>ε</italic>-match only once and also only maximal <italic>ε</italic>-matches, this last step is necessary.</p>
        <p>We remove overlapping <italic>ε</italic>-matches by sorting the <italic>ε</italic>-matches by their begin position in one sequence and pairwisely comparing here overlapping matches further. If two <italic>ε</italic>-matches are found to be identical, one is discarded. Also, if the shorter of the two <italic>ε</italic>-matches has no unique part of length <italic>n</italic><sub>0</sub>, this <italic>ε</italic>-match is discarded. The running time of this last step is dominated by sorting the <italic>ε</italic>-matches, i.e. it is in <inline-formula><inline-graphic xlink:href="1471-2105-12-S9-S15-i21.gif"/></inline-formula>, where <italic>M</italic> is the number of <italic>ε</italic>-matches before removal.</p>
        <p>
          <bold>Theorem.</bold>
          <italic>Let M be the set of maximal ε-matches without ε-X-drop between two sequences. Then the algorithm that uses SWIFT for filtering and the described strategy for verification will detect exactly all ε-matches in M.</italic>
        </p>
        <p><italic>Proof.</italic> The SWIFT filter algorithm guarantees to report at least one overlapping SWIFT hit for every <italic>ε</italic>-match of the input sequences. The first step of the verification strategy detects all <italic>ε</italic>-cores in SWIFT hits. Apply Lemma 1 to prove that every <italic>ε</italic>-match contains an <italic>ε</italic>-core. According to Lemma 2, one of the <italic>ε</italic>-cores of every <italic>ε</italic>-match is contained in a SWIFT hit. Thus, for every <italic>ε</italic>-match in <italic>M</italic> the first verification step identifies at least one <italic>ε</italic>-core.</p>
        <p>Let <italic>C′</italic> be the set of <italic>ε</italic>-cores identified during the first step, and let <italic>C</italic> ⊆ <italic>C′</italic> be the subset of <italic>ε</italic>-cores that are part of an <italic>ε</italic>-match in <italic>M.</italic> Since none of the <italic>ε</italic>-matches in <italic>M</italic> contain an <italic>ε</italic>-X-drop, the local alignment obtained after <italic>ε</italic>-X-drop extension (Step 3) of an <italic>ε</italic>-core <italic>c</italic> ∈ <italic>C</italic> spans the corresponding <italic>ε</italic>-match.</p>
        <p>By cutting the extended <italic>ε</italic>-cores as described in Step 4, we eventually end up with a set of <italic>ε</italic>-matches <italic>M</italic><bold><italic>′</italic></bold> that each contains a certain <italic>ε</italic>-core. Step 4 also guarantees that per <italic>ε</italic>-core no longer <italic>ε</italic>-match exists than the <italic>ε</italic>-match in <italic>M′</italic>. Therefore, after removal of overlapping <italic>ε</italic>-matches (Step 5), our set of <italic>ε</italic>-matches contains exactly all maximal <italic>ε</italic>-matches without <italic>ε</italic>-X-drop. □</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>We have implemented the algorithmic pipeline in the program STELLAR following exactly the above described steps with one exception: To improve running time, STELLAR computes the alignment matrix during the identification of the longest <italic>ε</italic>-match with unnormalized alignment score. The following results show that this has in practice no effect on the sensitivity.</p>
    <p>We tested STELLAR on simulated and on real genomic data and compared its performance to BLAST [<xref ref-type="bibr" rid="B18">18</xref>], LASTZ as the replacement of BLASTZ [<xref ref-type="bibr" rid="B21">21</xref>], BLAT [<xref ref-type="bibr" rid="B20">20</xref>], BWT-SW [<xref ref-type="bibr" rid="B22">22</xref>], and Smith-Waterman alignments obtained with SSEARCH from the FASTA package [<xref ref-type="bibr" rid="B16">16</xref>]. In addition, we ran BLAST with a more sensitive parameter setting: According to Lemma 1, every <italic>ε</italic>-match contains a seed of length <italic>s<sup>min</sup></italic>, and therefore, we set BLAST’s word-size parameter to the corresponding <italic>s<sup>min</sup></italic> computed in STELLAR. To demonstrate the differences between the programs we compared speed and sensitivity on all data sets. Running times were measured on a 2.66 GHz Intel Xeon X5550 with 72 GB of RAM running Linux. Running times of BWT-SW include pre-processing of the database sequence. In all test runs STELLAR needed less than 1 GB of RAM, so we omit further details of memory usage. As a measurement for sensitivity we computed the percentage of matches from a reference set that were sufficiently covered by matches from the respective program. We say that matches that are covered by less than 10% are missed (Fig. <xref ref-type="fig" rid="F8">8</xref>). This is a very loose criterion which is in favor of the compared programs.</p>
    <fig id="F8" position="float">
      <label>Figure 8</label>
      <caption>
        <p><bold>Match coverage.</bold> A set of matches <italic>A</italic> = {<italic>A</italic><sub>1</sub>, …, <italic>A</italic><sub>8</sub>} that are to be compared to a set of reference matches {<italic>B</italic><sub>1</sub>, …, <italic>B</italic><sub>7</sub>}<italic>.</italic> We say that a match <italic>B<sub>i</sub></italic> is covered by the matches from <italic>A</italic> if at least 10% of the alignment columns agree between <italic>B<sub>i</sub></italic> and any match from <italic>A.</italic></p>
      </caption>
      <graphic xlink:href="1471-2105-12-S9-S15-8"/>
    </fig>
    <sec>
      <title>Simulated sequences</title>
      <p>To demonstrate STELLAR’s gain of sensitivity in comparison to other programs, we used simulated data sets. The advantage here is that the reference set of local alignments for the computation of the sensitivity is given. We simulated random sequences with uniformly distributed characters from the alphabet {A, C, G, T}. In addition, we simulated random local alignments of length 50-200 bp and inserted errors at different rates into the alignments. In order to see at what error rates the programs start missing local alignments, we created a first data set where 500 such local alignments with an error rate of 0%, 2.5%, 5%, 7.5%, or 10% were inserted into a sequence of length 1 Mb at random positions. A second simulation was conducted to assess the effect of the sequence length. Here, sequences of lengths 1 kb, 10 kb, 100 kb, 1 Mb, and 10 Mb were simulated containing local alignments with error rates between 0 and 10%. On these data sets we ran the above mentioned programs, with STELLAR’s error rate parameter set accordingly and the minimal match length set to 50. The results are shown in Tables <xref ref-type="table" rid="T1">1</xref> and <xref ref-type="table" rid="T2">2</xref>. Table <xref ref-type="table" rid="T1">1</xref> demonstrates that STELLAR, in particular for the higher error rates, outperforms the other programs. SSEARCH has full sensitivity as expected but is very slow. We confirmed that with an E-value cutoff of 0.01 it does not detect any other than the inserted local alignments. BWT-SW reports all local alignments, too, but is still much slower than STELLAR. For BLAST and LASTZ the number of missed matches is low for very low error rates but increases with higher error rates. This implies that one can benefit the most from STELLAR when comparing closely related sequences that still have significant differences. As an example, Fig. <xref ref-type="fig" rid="F9">9</xref> displays one <italic>ε</italic>-match that only STELLAR, BWT-SW, and SSEARCH identify. BLAST is the fastest of all programs, though only with default parameters and lower sensitivity. BLAT constantly misses around 30% of all matches. We assume that the reason for BLAT’s bad performance is that it was originally designed for the comparison of many short sequences (ESTs or reads) against one long sequence and not for the comparison of two long sequences. Table <xref ref-type="table" rid="T2">2</xref> supports this assumption, as the number of matches missed by BLAT is low for the 1 kb – 100 kb sequences but increases up to almost 70% for sequences of length 10 Mb. In contrast, the sensitivity of BLAST and LASTZ seems not to be affected by different sequence lengths. STELLAR is in general faster than BWT-SW, BLAT, and LASTZ with one exception – the 10 Mb sequences. This indicates already a limitation of STELLAR on very long sequences with high error rates. The SWIFT filter has a lower specificity for high error rates and generates very many SWIFT hits. As a result, many verification steps are necessary, which leads to an increase in running time. However, STELLAR is faster than the sensitive BLAST for the 10 Mb sequences and also for high error rates. The sudden increase in running time for the sensitive BLAST at higher error rates (Table <xref ref-type="table" rid="T1">1</xref>) is due to a much lower <italic>s<sup>min</sup></italic> for <italic>ε</italic> = 10%.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Running times and sensitivity on simulated sequences containing local alignments of different error rates</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">error rate</th>
              <th align="center" colspan="2">0%</th>
              <th align="center" colspan="2">2.5%</th>
              <th align="center" colspan="2">5%</th>
              <th align="center" colspan="2">7.5%</th>
              <th align="center" colspan="2">10%</th>
            </tr>
            <tr>
              <th align="left"/>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">SSEARCH</td>
              <td align="right">133:17 h</td>
              <td align="right">0.00%</td>
              <td align="right">132:55 h</td>
              <td align="right">0.00%</td>
              <td align="right">133:24 h</td>
              <td align="right">0.00%</td>
              <td align="right">132:25 h</td>
              <td align="right">0.00%</td>
              <td align="right">132:52 h</td>
              <td align="right">0.00%</td>
            </tr>
            <tr>
              <td align="left">STELLAR</td>
              <td align="right">2.96 s</td>
              <td align="right">0.00%</td>
              <td align="right">3.30 s</td>
              <td align="right">0.00%</td>
              <td align="right">3.61 s</td>
              <td align="right">0.00%</td>
              <td align="right">3.91 s</td>
              <td align="right">0.00%</td>
              <td align="right">4.44 s</td>
              <td align="right">0.00%</td>
            </tr>
            <tr>
              <td align="left">BWT-SW</td>
              <td align="right">16.59 s</td>
              <td align="right">0.00%</td>
              <td align="right">16.63 s</td>
              <td align="right">0.00%</td>
              <td align="right">16.53 s</td>
              <td align="right">0.00%</td>
              <td align="right">16.29 s</td>
              <td align="right">0.00%</td>
              <td align="center">16.24 s</td>
              <td align="center">0.00%</td>
            </tr>
            <tr>
              <td align="left">BLAST</td>
              <td align="right">0.25 s</td>
              <td align="right">0.00%</td>
              <td align="right">0.26 s</td>
              <td align="right">0.16%</td>
              <td align="right">0.26 s</td>
              <td align="right">5.36%</td>
              <td align="right">0.25 s</td>
              <td align="right">17.00%</td>
              <td align="right">0.24 s</td>
              <td align="right">38.80%</td>
            </tr>
            <tr>
              <td align="left">BLAST*</td>
              <td align="right">0.25 s</td>
              <td align="right">0.16%</td>
              <td align="right">0.26 s</td>
              <td align="right">0.00%</td>
              <td align="right">0.28 s</td>
              <td align="right">0.04%</td>
              <td align="right">0.51 s</td>
              <td align="right">0.28%</td>
              <td align="right">14.99 s</td>
              <td align="right">2.60%</td>
            </tr>
            <tr>
              <td align="left">LASTZ</td>
              <td align="right">6.49 s</td>
              <td align="right">0.00%</td>
              <td align="right">6.48 s</td>
              <td align="right">0.72%</td>
              <td align="right">6.22 s</td>
              <td align="right">5.56%</td>
              <td align="right">5.86 s</td>
              <td align="right">12.68%</td>
              <td align="right">5.23 s</td>
              <td align="right">24.92%</td>
            </tr>
            <tr>
              <td align="left">BLAT</td>
              <td align="right">14.30 s</td>
              <td align="right">29.36%</td>
              <td align="right">11.52 s</td>
              <td align="right">29.64%</td>
              <td align="right">14.06 s</td>
              <td align="right">28.88%</td>
              <td align="right">14.71 s</td>
              <td align="right">31.44%</td>
              <td align="right">14.66 s</td>
              <td align="right">34.32%</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Sequences have a length of 1 Mb and contain local alignments of lengths between 50 and 200 bp. The simulations were repeated five times, the displayed values are the average of all runs except for SSEARCH which was run only once. Sensitivity is measured by the percentage of missed local alignments (Fig. <xref ref-type="fig" rid="F8">8</xref>). BWT-SW, BLAST, BLAT, and LASTZ were run with default parameter settings. BLAST* stands for a more sensitive run of BLAST with the word size parameter set to <italic>s<sup>min</sup></italic>, i.e. the minimal length of an <italic>ε</italic>-core (see text for details).</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Running times and sensitivity on simulated sequences of different lengths</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">seq length</th>
              <th align="center" colspan="2">1 kb</th>
              <th align="center" colspan="2">10 kb</th>
              <th align="center" colspan="2">100 kb</th>
              <th align="center" colspan="2">1 Mb</th>
              <th align="center" colspan="2">10 Mb</th>
            </tr>
            <tr>
              <th align="left"/>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
              <th align="center">time</th>
              <th align="center">missed</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">SSEARCH</td>
              <td align="right">2.45 s</td>
              <td align="right">0.00%</td>
              <td align="right">259.5 s</td>
              <td align="right">0.00%</td>
              <td align="right">7:16 h</td>
              <td align="right">0.00%</td>
              <td align="right">136:16 h</td>
              <td align="right">0.00%</td>
              <td align="center">–</td>
              <td align="center">–</td>
            </tr>
            <tr>
              <td align="left">STELLAR</td>
              <td align="right">1 ms</td>
              <td align="right">0.00%</td>
              <td align="right">5 ms</td>
              <td align="right">0.00%</td>
              <td align="right">0.07 s</td>
              <td align="right">0.00%</td>
              <td align="right">4.36 s</td>
              <td align="right">0.00%</td>
              <td align="right">782.46 s</td>
              <td align="right">0.00%</td>
            </tr>
            <tr>
              <td align="left">BWT-SW</td>
              <td align="center">–</td>
              <td align="center">–</td>
              <td align="right">787 ms</td>
              <td align="right">0.00%</td>
              <td align="right">1.40 s</td>
              <td align="right">0.00%</td>
              <td align="right">16.33 s</td>
              <td align="right">0.00%</td>
              <td align="right">508.45 s</td>
              <td align="right">0.00%</td>
            </tr>
            <tr>
              <td align="left">BLAST</td>
              <td align="right">4 ms</td>
              <td align="right">14.00%</td>
              <td align="right">8 ms</td>
              <td align="right">6.00%</td>
              <td align="right">0.03 s</td>
              <td align="right">11.40%</td>
              <td align="right">0.25 s</td>
              <td align="right">13.40%</td>
              <td align="right">3.34 s</td>
              <td align="right">12.64%</td>
            </tr>
            <tr>
              <td align="left">BLAST*</td>
              <td align="right">6 ms</td>
              <td align="right">0.00%</td>
              <td align="right">13 ms</td>
              <td align="right">0.00%</td>
              <td align="right">0.16 s</td>
              <td align="right">0.00%</td>
              <td align="right">14.75 s</td>
              <td align="right">0.60%</td>
              <td align="right">2266.64 s</td>
              <td align="right">1.46%</td>
            </tr>
            <tr>
              <td align="left">LASTZ</td>
              <td align="right">9 ms</td>
              <td align="right">10.00%</td>
              <td align="right">59 ms</td>
              <td align="right">2.00%</td>
              <td align="right">0.56 s</td>
              <td align="right">7.80%</td>
              <td align="right">5.99 s</td>
              <td align="right">9.40%</td>
              <td align="right">116.26 s</td>
              <td align="right">9.12%</td>
            </tr>
            <tr>
              <td align="left">BLAT</td>
              <td align="right">25 ms</td>
              <td align="right">0.00%</td>
              <td align="right">39 ms</td>
              <td align="right">0.00%</td>
              <td align="right">0.40 s</td>
              <td align="right">1.00%</td>
              <td align="right">15.24 s</td>
              <td align="right">33.00%</td>
              <td align="right">384.79 s</td>
              <td align="right">69.30%</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Sequences contain <italic>a</italic> = [length/2000] local alignments with a maximal error rate of 10% and lengths between 50 and 200 bp. The simulation of the 1 kb sequences was repeated 50 times, the simulation of the 10 kb and 100 kb sequences ten times. The displayed values are the average of all runs except for SSEARCH which was run only once. Sensitivity is measured by the percentage of missed local alignments (Fig. <xref ref-type="fig" rid="F8">8</xref>). BWT-SW, BLAST, BLAT, and LASTZ were run with default parameter settings. BLAST* stands for a more sensitive run of BLAST with the word size parameter set to <italic>s<sup>min</sup></italic>, i.e. the minimal length of an <italic>ε</italic>-core (see text for details).</p>
        </table-wrap-foot>
      </table-wrap>
      <fig id="F9" position="float">
        <label>Figure 9</label>
        <caption>
          <p><bold><italic>ε</italic>-match in simulated data.</bold> An example <italic>ε</italic>-match from the simulated sequences of length 1 Mb and <italic>ε</italic> = 10%. This <italic>ε</italic>-match with an E-value of 7 × 10<sup>–26</sup> is only found by STELLAR, BWT-SW, and SSEARCH, but by none of the other programs.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-S9-S15-9"/>
      </fig>
    </sec>
    <sec>
      <title>Genomic sequences</title>
      <p>We downloaded the assembled genomes of <italic>Drosophíla melanogaster</italic> (release 5.26) and <italic>Drosophíla pseudoobscura</italic> (release 2.14) from FlyBase [<xref ref-type="bibr" rid="B34">34</xref>]. We selected chromosome arm 2L from <italic>D. melanogaster</italic> (~23.5 Mb) and group 3 from the chromosome 4 assembly of <italic>D. pseudoobscura</italic> (~11.7 Mb) for our test runs. Unfortunately, this data set is too big to compute local alignments with SSEARCH, and since BLAST performs better than BLAT and LASTZ on the simulated data we chose to compare STELLAR on the genomic data only to BLAST. We expect BLAST to compute very short alignments with low error rates and some long alignments with higher error rates that do not fulfill the minimal length or error rate criterion for <italic>ε</italic>-matches, and hence STELLAR will not find them. Therefore, to double-check STELLAR’s sensitivity, we filter all <italic>ε</italic>-matches from the set of BLAST hits. Additonally, some of the longer BLAST hits may contain valid <italic>ε</italic>-matches that we extract and add to the set of filtered BLAST hits.</p>
      <p>Results for STELLAR are shown in Table <xref ref-type="table" rid="T3">3</xref> and results for BLAST in Table <xref ref-type="table" rid="T4">4</xref>. STELLAR identifies for example 345 <italic>ε</italic>-matches with an error rate of 10% and a minimal match length of 200. As expected, these cover all of the <italic>ε</italic>-matches filtered from the set of BLAST hits. In contrast to the simulated sequences, the running time increases significantly with a higher error rate or lower minimal length. This can be explained with the filter algorithm being more specific for higher minimal lengths and low error rates as already mentioned above. With less specific filtering, many more SWIFT hits need to be verified resulting in a higher running time. In the future we might be able to reduce this effect by parallelization.</p>
      <table-wrap id="T3" position="float">
        <label>Table 3</label>
        <caption>
          <p>Results of STELLAR on drosophila chromosomes</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="right">error rate</th>
              <th align="center">min. length</th>
              <th align="center">running time</th>
              <th align="center">num. of <italic>ε</italic>-matches</th>
              <th align="center">overlap BLAST<italic><sup>a</sup></italic></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="right">10%</td>
              <td align="right">100</td>
              <td align="right">7777 s</td>
              <td align="right">3911</td>
              <td align="right">100%</td>
            </tr>
            <tr>
              <td align="right">10%</td>
              <td align="right">200</td>
              <td align="right">1566 s</td>
              <td align="right">345</td>
              <td align="right">100%</td>
            </tr>
            <tr>
              <td align="right">5%</td>
              <td align="right">200</td>
              <td align="right">21 s</td>
              <td align="right">44</td>
              <td align="right">100%</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>We used chromosome arm 2L from <italic>D. melanogaster</italic> (~23.5 Mb) and group 3 of chromosome 4 from <italic>D.pseudoobscura</italic> (~11.7Mb). STELLAR was run with the X-drop parameter set to 20.</p>
          <p><italic><sup>a</sup></italic> Percentage of covered local alignments from accordingly filtered BLAST output.</p>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap id="T4" position="float">
        <label>Table 4</label>
        <caption>
          <p>Results of BLAST on drosophila chromosomes</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="center">word size</th>
              <th align="center">running time</th>
              <th align="center">num. of hits</th>
              <th align="center">overlap STELLAR 200<italic><sup>b</sup></italic></th>
              <th align="center">overlap STELLAR 100<italic><sup>b</sup></italic></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">default</td>
              <td align="right">9 s</td>
              <td align="right">9504</td>
              <td align="right">95.1%</td>
              <td align="right">89.6%</td>
            </tr>
            <tr>
              <td align="center">8</td>
              <td align="right">2175 s</td>
              <td align="right">29597</td>
              <td align="right">100.0%</td>
              <td align="right">99.7%</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>We used chromosome arm 2L from <italic>D. melanogaster</italic> (~23.5 Mb) and group 3 of chromosome 4 from <italic>D.pseudoobscura</italic> (~11.7Mb).</p>
          <p><italic><sup>a</sup></italic> Percentage of covered STELLAR matches (error rate 10%, minimal length 200 or 100).</p>
        </table-wrap-foot>
      </table-wrap>
      <p>BLAST with default settings is again the faster program, but misses 17 <italic>ε</italic>-matches of minimal length 200. One of these matches is displayed in Fig. <xref ref-type="fig" rid="F10">10</xref>. When we change the word size parameter such that BLAST is able to identify all <italic>ε</italic>-matches of minimal length 200, it is slower than STELLAR. STELLAR with minimal length 100 and error rate 10% is slowest in all tested settings, but identifies 408 <italic>ε</italic>-matches that BLAST with default parameters does not find, and 13 <italic>ε</italic>-matches that even the more sensitive setting of BLAST does not find though these <italic>ε</italic>-matches have an E-value of 6.1 x 10<sup>–23</sup> or lower.</p>
      <fig id="F10" position="float">
        <label>Figure 10</label>
        <caption>
          <p><bold>ε-match between drosophila sequences</bold>. An example <italic>ε</italic>-match from the drosophila sequences with <italic>ε</italic> = 10% and <italic>n</italic><sub>0</sub> = 200. This <italic>ε</italic>-match with an E-value of 6 × 10<sup>–84</sup> is not found by BLAST with default parameters.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-S9-S15-10"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>We presented STELLAR, an algorithm to compute <italic>all</italic> local alignments of a minimal length according to a clear quality definition using the established measures <italic>error rate</italic> and <italic>X-drop.</italic> STELLAR brings exact local alignments to the community at the speed of heuristic state-of-the-art tools like BLAST, BLAT, or LASTZ. In addition, our experiments show that our effort is worthwhile since the heuristic tools miss up to about a third of the matches using simulated and real genomic data. Compared to its closest competitor, BWT-SW, it is in most benchmarks faster and offers with the <italic>X-drop</italic> parameter a possibility to exclude local alignments with bad regions. A limitation of STELLAR is that only <italic>ε</italic>-matches up to a certain error rate can be computed since the filtering phase loses specificity with increasing error rate. Therefore, for longer and less similar though significant local alignments BLAST remains more appropriate.</p>
    <p>As an outlook another relatively new application for local alignments that has emerged with the advent of cheap next-generation sequencing should be mentioned. Standard read mapping programs [<xref ref-type="bibr" rid="B8">8</xref>-<xref ref-type="bibr" rid="B14">14</xref>] usually can only map entire reads to the reference. With the increasing read length, there will be more reads that span breakage points, e.g. translocations, gene fusions, or splice junctions. The application of an efficient and exact local alignment program could be one way to successfully map such reads and detect variation [<xref ref-type="bibr" rid="B15">15</xref>]. Application of STELLAR is especially promising in that it uses the error rate for sensitivity control, an established criterion for read mappers. With a downstream chaining procedure of the partial read matches detected by STELLAR, it may then be possible to detect even multiple splits of reads. Hence, for finding local alignments in the tested range of error rates STELLAR could replace the heuristic tools.</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This article has been published as part of <italic>BMC Bioinformatics</italic> Volume 12 Supplement 9, 2011: Proceedings of the Ninth Annual Research in Computational Molecular Biology (RECOMB) Satellite Workshop on Comparative Genomics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/12?issue=S9">http://www.biomedcentral.com/1471-2105/12?issue=S9</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sellers</surname>
          <given-names>PH</given-names>
        </name>
        <article-title>The theory and computation of evolutionary distances: Pattern recognition</article-title>
        <source>Journal of Algorithms</source>
        <year>1980</year>
        <volume>1</volume>
        <issue>4</issue>
        <fpage>359</fpage>
        <lpage>373</lpage>
        <pub-id pub-id-type="doi">10.1016/0196-6774(80)90016-4</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Smith</surname>
          <given-names>TF</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Paten</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Herrero</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Beal</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Sequence progressive alignment, a framework for practical large-scale probabilistic consistency alignment</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>3</issue>
        <fpage>295</fpage>
        <lpage>301</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn630</pub-id>
        <pub-id pub-id-type="pmid">19056777</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Darling</surname>
          <given-names>AE</given-names>
        </name>
        <name>
          <surname>Mau</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Perna</surname>
          <given-names>NT</given-names>
        </name>
        <article-title>progressiveMauve: multiple genome alignment with gene gain, loss and rearrangement</article-title>
        <source>PLoS One</source>
        <year>2010</year>
        <volume>5</volume>
        <issue>6</issue>
        <fpage>e11147</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0011147</pub-id>
        <pub-id pub-id-type="pmid">20593022</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dubchak</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Poliakov</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Kislyuk</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Brudno</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Multiple whole-genome alignments without a reference organism</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <issue>4</issue>
        <fpage>682</fpage>
        <lpage>689</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.081778.108</pub-id>
        <pub-id pub-id-type="pmid">19176791</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Raphael</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Zhi</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Tang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Pevzner</surname>
          <given-names>P</given-names>
        </name>
        <article-title>A novel method for multiple alignment of sequences with repeated and shuffled elements</article-title>
        <source>Genome Res</source>
        <year>2004</year>
        <volume>14</volume>
        <issue>11</issue>
        <fpage>2336</fpage>
        <lpage>2346</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.2657504</pub-id>
        <pub-id pub-id-type="pmid">15520295</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Blanchette</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <name>
          <surname>Riemer</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Elnitski</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Smit</surname>
          <given-names>AFA</given-names>
        </name>
        <name>
          <surname>Roskin</surname>
          <given-names>KM</given-names>
        </name>
        <name>
          <surname>Baertsch</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Rosenbloom</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Clawson</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Green</surname>
          <given-names>ED</given-names>
        </name>
        <name>
          <surname>Haussler</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Aligning multiple genomic sequences with the threaded blockset aligner</article-title>
        <source>Genome Res</source>
        <year>2004</year>
        <volume>14</volume>
        <issue>4</issue>
        <fpage>708</fpage>
        <lpage>715</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.1933104</pub-id>
        <pub-id pub-id-type="pmid">15060014</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Langmead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Trapnell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Pop</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>SL</given-names>
        </name>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>3</issue>
        <fpage>R25</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2009-10-3-r25</pub-id>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Fast and accurate short read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>14</issue>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Durbin</surname>
          <given-names>R</given-names>
        </name>
        <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>11</issue>
        <fpage>1851</fpage>
        <lpage>1858</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.078212.108</pub-id>
        <pub-id pub-id-type="pmid">18714091</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>SOAP: short oligonucleotide alignment program</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>5</issue>
        <fpage>713</fpage>
        <lpage>714</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn025</pub-id>
        <pub-id pub-id-type="pmid">18227114</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="other">
        <name>
          <surname>Rumble</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Brudno</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Shrimp – short read mapping package</article-title>
        <year>2008</year>
        <ext-link ext-link-type="uri" xlink:href="http://compbio.cs.toronto.edu/shrimp/">http://compbio.cs.toronto.edu/shrimp/</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Jiang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>WH</given-names>
        </name>
        <article-title>SeqMap: mapping massive amount of oligonucleotides to the genome</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>20</issue>
        <fpage>2395</fpage>
        <lpage>2396</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn429</pub-id>
        <pub-id pub-id-type="pmid">18697769</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Weese</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Emde</surname>
          <given-names>AK</given-names>
        </name>
        <name>
          <surname>Rausch</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Döring</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <article-title>RazerS–fast read mapping with sensitivity control</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <issue>9</issue>
        <fpage>1646</fpage>
        <lpage>1654</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.088823.108</pub-id>
        <pub-id pub-id-type="pmid">19592482</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Mortazavi</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Williams</surname>
          <given-names>BA</given-names>
        </name>
        <name>
          <surname>McCue</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Schaeffer</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Wold</surname>
          <given-names>B</given-names>
        </name>
        <article-title>Mapping and quantifying mammalian transcriptomes by RNA-Seq</article-title>
        <source>Nat Methods</source>
        <year>2008</year>
        <volume>5</volume>
        <issue>7</issue>
        <fpage>621</fpage>
        <lpage>628</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1226</pub-id>
        <pub-id pub-id-type="pmid">18516045</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pearson</surname>
          <given-names>WR</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Improved tools for biological sequence comparison</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>1988</year>
        <volume>85</volume>
        <issue>8</issue>
        <fpage>2444</fpage>
        <lpage>2448</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.85.8.2444</pub-id>
        <pub-id pub-id-type="pmid">3162770</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Gish</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Basic local alignment search tool</article-title>
        <source>J Mol Biol</source>
        <year>1990</year>
        <volume>215</volume>
        <issue>3</issue>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Madden</surname>
          <given-names>TL</given-names>
        </name>
        <name>
          <surname>Schäffer</surname>
          <given-names>AA</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Lipman</surname>
          <given-names>DJ</given-names>
        </name>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res</source>
        <year>1997</year>
        <volume>25</volume>
        <issue>17</issue>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/25.17.3389</pub-id>
        <pub-id pub-id-type="pmid">9254694</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Schwartz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Wagner</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>A greedy algorithm for aligning DNA sequences</article-title>
        <source>J Comput Biol</source>
        <year>2000</year>
        <volume>7</volume>
        <issue>1-2</issue>
        <fpage>203</fpage>
        <lpage>214</lpage>
        <pub-id pub-id-type="doi">10.1089/10665270050081478</pub-id>
        <pub-id pub-id-type="pmid">10890397</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <article-title>BLAT-the BLAST-like alignment tool</article-title>
        <source>Genome Res</source>
        <year>2002</year>
        <volume>12</volume>
        <issue>4</issue>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Schwartz</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <name>
          <surname>Smit</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Baertsch</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Hardison</surname>
          <given-names>RC</given-names>
        </name>
        <name>
          <surname>Haussler</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Human-mouse alignments with BLASTZ</article-title>
        <source>Genome Res</source>
        <year>2003</year>
        <volume>13</volume>
        <fpage>103</fpage>
        <lpage>107</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.809403</pub-id>
        <pub-id pub-id-type="pmid">12529312</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Lam</surname>
          <given-names>TW</given-names>
        </name>
        <name>
          <surname>Sung</surname>
          <given-names>WK</given-names>
        </name>
        <name>
          <surname>Tam</surname>
          <given-names>SL</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>CK</given-names>
        </name>
        <name>
          <surname>Yiu</surname>
          <given-names>SM</given-names>
        </name>
        <article-title>Compressed indexing and local alignment of DNA</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>6</issue>
        <fpage>791</fpage>
        <lpage>797</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn032</pub-id>
        <pub-id pub-id-type="pmid">18227115</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Karlin</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <article-title>Methods for assessing the statistical significance of molecular sequence features by using general scoring schemes</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>1990</year>
        <volume>87</volume>
        <issue>6</issue>
        <fpage>2264</fpage>
        <lpage>2268</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.87.6.2264</pub-id>
        <pub-id pub-id-type="pmid">2315319</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Döring</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Weese</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Rausch</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <article-title>SeqAn an efficient, generic C++ library for sequence analysis</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>11</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-11</pub-id>
        <pub-id pub-id-type="pmid">18184432</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="book">
        <name>
          <surname>Gogol-Döring</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Reinert</surname>
          <given-names>K</given-names>
        </name>
        <source>Biological Sequence Analysis Using the SeqAn C++ Library</source>
        <year>2009</year>
        <publisher-name>Chapman &amp; Hall/CRC Mathematical &amp; Computational Biology, CRC Press, Boca Raton, USA</publisher-name>
        <ext-link ext-link-type="uri" xlink:href="http://www.crcpress.com/ecommerce_product/product_detail.jsf?isbn=9781420076233">http://www.crcpress.com/ecommerce_product/product_detail.jsf?isbn=9781420076233</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Berman</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Alignments without low-scoring regions</article-title>
        <source>J Comput Biol</source>
        <year>1998</year>
        <volume>5</volume>
        <issue>2</issue>
        <fpage>197</fpage>
        <lpage>210</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.1998.5.197</pub-id>
        <pub-id pub-id-type="pmid">9672828</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zhang</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Berman</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Wiehe</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Miller</surname>
          <given-names>W</given-names>
        </name>
        <article-title>Post-processing long pairwise alignments</article-title>
        <source>Bioinformatics</source>
        <year>1999</year>
        <volume>15</volume>
        <issue>12</issue>
        <fpage>1012</fpage>
        <lpage>1019</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/15.12.1012</pub-id>
        <pub-id pub-id-type="pmid">10745991</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Rasmussen</surname>
          <given-names>KR</given-names>
        </name>
        <name>
          <surname>Stoye</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Myers</surname>
          <given-names>EW</given-names>
        </name>
        <article-title>Efficient q-gram filters for finding all ε-matches over a given length</article-title>
        <source>J Comput Biol</source>
        <year>2006</year>
        <volume>13</volume>
        <issue>2</issue>
        <fpage>296</fpage>
        <lpage>308</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2006.13.296</pub-id>
        <pub-id pub-id-type="pmid">16597241</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="other">
        <name>
          <surname>Burkhardt</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Crauser</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Ferragina</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Lenhof</surname>
          <given-names>HP</given-names>
        </name>
        <name>
          <surname>Rivals</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Vingron</surname>
          <given-names>M</given-names>
        </name>
        <article-title>q-gram based database searching using a suffix array (QUASAR)</article-title>
        <source>J Comput Biol, RECOMB ’99</source>
        <year>1999</year>
        <fpage>77</fpage>
        <lpage>83</lpage>
        <pub-id pub-id-type="pmid">21899412</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="other">
        <name>
          <surname>Jokinen</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Ukkonen</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Two algorithms for approxmate string matching in static texts</article-title>
        <source>Mathematical Foundations of Computer Science 1991, Volume 520 of Lect Notes Comput Sc</source>
        <year>1991</year>
        <fpage>240</fpage>
        <lpage>248</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.springerlink.com/content/p58155n8012x0477/">http://www.springerlink.com/content/p58155n8012x0477/</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <name>
          <surname>Eggert</surname>
          <given-names>M</given-names>
        </name>
        <article-title>A new algorithm for best subsequence alignments with application to tRNA-rRNA comparisons</article-title>
        <source>J Mol Biol</source>
        <year>1987</year>
        <volume>197</volume>
        <issue>4</issue>
        <fpage>723</fpage>
        <lpage>728</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(87)90478-5</pub-id>
        <pub-id pub-id-type="pmid">2448477</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Marzal</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Vidal</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Computation of normalized edit distance and applications</article-title>
        <source>IEEE T Pattern Anal</source>
        <year>1993</year>
        <volume>15</volume>
        <fpage>926</fpage>
        <lpage>932</lpage>
        <pub-id pub-id-type="doi">10.1109/34.232078</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Arslan</surname>
          <given-names>AN</given-names>
        </name>
        <name>
          <surname>Eǧecioǧlu</surname>
          <given-names>Ö</given-names>
        </name>
        <article-title>Efficient algorithms for normalized edit distance</article-title>
        <source>Journal of Discrete Algorithms</source>
        <year>2000</year>
        <volume>1</volume>
        <fpage>3</fpage>
        <lpage>20</lpage>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Tweedie</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Ashburner</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Falls</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Leyland</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>McQuilton</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Marygold</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Millburn</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Osumi-Sutherland</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Schroeder</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Seal</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zhang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Consortium</surname>
          <given-names>F</given-names>
        </name>
        <article-title>FlyBase: enhancing drosophila gene ontology annotations</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <volume>37</volume>
        <issue>Database issue</issue>
        <fpage>D555</fpage>
        <lpage>D559</lpage>
        <pub-id pub-id-type="pmid">18948289</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
