<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3223363</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btr562</article-id>
    <article-id pub-id-type="publisher-id">btr562</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fast scaffolding with small independent mixed integer programs</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Salmela</surname>
          <given-names>Leena</given-names>
        </name>
        <xref ref-type="corresp" rid="COR1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mäkinen</surname>
          <given-names>Veli</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Välimäki</surname>
          <given-names>Niko</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ylinen</surname>
          <given-names>Johannes</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ukkonen</surname>
          <given-names>Esko</given-names>
        </name>
      </contrib>
    </contrib-group>
    <aff id="AFF1">Department of Computer Science, Helsinki Institute for Information Technology, University of Helsinki, Helsinki, Finland</aff>
    <author-notes>
      <corresp id="COR1">* To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: Alex Bateman</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>1</day>
      <month>12</month>
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>13</day>
      <month>10</month>
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>10</month>
      <year>2011</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>27</volume>
    <issue>23</issue>
    <fpage>3259</fpage>
    <lpage>3265</lpage>
    <history>
      <date date-type="received">
        <day>2</day>
        <month>3</month>
        <year>2011</year>
      </date>
      <date date-type="rev-recd">
        <day>14</day>
        <month>9</month>
        <year>2011</year>
      </date>
      <date date-type="accepted">
        <day>6</day>
        <month>10</month>
        <year>2011</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2011. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2011</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">http://creativecommons.org/licenses/by-nc/3.0</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Assembling genomes from short read data has become increasingly popular, but the problem remains computationally challenging especially for larger genomes. We study the scaffolding phase of sequence assembly where preassembled contigs are ordered based on mate pair data.</p>
      <p><bold>Results:</bold> We present MIP Scaffolder that divides the scaffolding problem into smaller subproblems and solves these with mixed integer programming. The scaffolding problem can be represented as a graph and the biconnected components of this graph can be solved independently. We present a technique for restricting the size of these subproblems so that they can be solved accurately with mixed integer programming. We compare MIP Scaffolder to two state of the art methods, SOPRA and SSPACE. MIP Scaffolder is fast and produces better or as good scaffolds as its competitors on large genomes.</p>
      <p><bold>Availability:</bold> The source code of MIP Scaffolder is freely available at <ext-link ext-link-type="uri" xlink:href="http://www.cs.helsinki.fi/u/lmsalmel/mip-scaffolder/">http://www.cs.helsinki.fi/u/lmsalmel/mip-scaffolder/</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>leena.salmela@cs.helsinki.fi</email>
      </p>
    </abstract>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>Present high-throughput sequencing machines can produce hundreds of millions of short reads in a single run. Initially, this technology was targeted at resequencing applications but is nowadays also deployed in <italic>de novo</italic> sequencing projects. Apart from single reads, the sequencing machines can also produce mate pairs, i.e. pairs of reads whose approximate distance in the target genome is known. Although there are good methods to assemble reads produced by the older Sanger technology, new approaches are needed to deal with data from the second-generation sequencing machines, because the characteristics of the data like read length and sequencing errors are different (<xref ref-type="bibr" rid="B11">Pop, 2009</xref>).</p>
    <p>In a <italic>de novo</italic> sequencing project, the read data is typically first quality trimmed and filtered to ensure high-quality data for subsequent processing. A method to correct sequencing errors may also be used. The next step is to assemble the reads into contigs, which are gapless sequences of nucleotides. In the last step, the contigs are ordered into scaffolds based on mate pair reads (<xref ref-type="bibr" rid="B11">Pop, 2009</xref>).</p>
    <p>Here we consider the scaffolding problem. The input to the scaffolding problem is the contigs produced by a contig assembler, the mappings of the mate pair reads to the contigs and the insert sizes of the mate pair libraries. The objective is to find a linear ordering of the contigs, which maximizes the number of mate pairs whose pairwise distance equals the insert size. In practise, a linear ordering of all the contigs is not achieved, because the data may be incomplete and the organism may have several chromosomes. Instead each contig is assigned to a scaffold and given an orientation and position within the scaffold.</p>
    <p><xref ref-type="bibr" rid="B6">Kececioglu and Myers (1995)</xref> have shown that even determining the orientation of the contigs is NP-hard. Therefore, all practical methods to solve the scaffolding problem use heuristics and achieve only an approximate solution.</p>
    <p>Many assemblers like Velvet (<xref ref-type="bibr" rid="B16">Zerbino and Birney, 2008</xref>), Allpaths (<xref ref-type="bibr" rid="B3">Butler <italic>et al.</italic>, 2008</xref>) and SOAPdenovo (<xref ref-type="bibr" rid="B9">Li <italic>et al.</italic>, 2010</xref>) contain a scaffolding module. Some stand-alone scaffolders have also been developed. Bambus (<xref ref-type="bibr" rid="B12">Pop <italic>et al.</italic>, 2004</xref>) is designed for Sanger data, and SOPRA (<xref ref-type="bibr" rid="B4">Dayarian <italic>et al.</italic>, 2010</xref>) and SSPACE (<xref ref-type="bibr" rid="B2">Boetzer <italic>et al.</italic>, 2011</xref>) are developed for second-generation sequencing data. Bambus and SSPACE are based on a greedy method, whereas SOPRA relies on statistical optimization and partitioning the scaffolding problem. Our new approach uses a partitioning scheme similar to SOPRA but unlike SOPRA we restrict the size of the partitions and thus we can solve the subproblems exactly with mixed integer programming.</p>
    <p>The rest of the article is outlined as follows. In <xref ref-type="sec" rid="SEC2">Section 2</xref>, we present a theoretical framework for scaffolding based on mixed integer programming and partitioning the scaffolding problem. <xref ref-type="sec" rid="SEC3">Section 3</xref> presents a practical implementation of this framework. We compare the new scaffolder to SOPRA and SSPACE in <xref ref-type="sec" rid="SEC4">Section 4</xref>. Finally, we conclude in <xref ref-type="sec" rid="SEC5">Section 5</xref>.</p>
  </sec>
  <sec id="SEC2">
    <title>2 ALGORITHM</title>
    <p>The input to a scaffolder is a set of contigs produced by an assembler and a set of mate pairs. First, we map the mate pairs to the contigs. This yields links between contigs that we represent as a graph. The graph is then partitioned into subproblems, which we solve with mixed integer programming. Finally, we combine the solutions of the subproblems to solve the whole scaffolding problem. Each of these tasks is discussed in more detail below. In <xref ref-type="sec" rid="SEC3">Section 3</xref>, we address practical issues in implementing our approach.</p>
    <sec id="SEC2.1">
      <title>2.1 Scaffolding graph</title>
      <p>The input to the scaffolding problem can be represented as a bidirected graph called the <italic>scaffolding graph</italic>. Each contig is represented by a node in the graph. There is an edge between two contigs if there are mate pairs linking them. The edge is directed at both endpoints indicating the orientation of the contigs with regard to each other. <xref ref-type="fig" rid="F1">Figure 1</xref> shows the four possible ways of linking two contigs. Here the mate pair ends are oriented as in SOLiD data, where both reads of the pair are from the same strand of the genome.
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>The four possible ways of linking two contigs with a mate pair and the bidirected edge representing each case.</p></caption><graphic xlink:href="btr562f1"/></fig></p>
      <p>Several mate pairs can induce the same edge in the scaffolding graph. The total number of these mate pairs is the <italic>support</italic> s<sub><italic>k</italic></sub> of the edge <italic>k</italic>. These mate pairs are used to estimate the <italic>distance</italic> d<sub><italic>k</italic></sub> between the two contigs.</p>
      <p>The scaffolding problem can now be formulated as removing a set of edges with minimum combined support from the scaffolding graph such that each node can be assigned a position and orientation that satisfy the constraints imposed by the remaining edges. Each scaffold can then be constructed in two equivalent ways: the other way can be obtained by reversing the whole scaffold.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Mixed integer programming formulation</title>
      <p>In this section, we will develop a mixed integer programming (MIP) formulation for the scaffolding problem. As a convention, we will use italic type to denote variables and roman type to denote constants for those quantities that are present in the MIP formulation. There are <italic>n</italic> contigs. Let us denote the length of contig <italic>i</italic> by a<sub><italic>i</italic></sub>. Let L be an estimate of the upper bound of possible scaffold length (e.g. an estimated upper bound of the length of the entire genome or the longest chromosome).</p>
      <p>The solution to the MIP problem will assign values to the following variables. For each contig <italic>i</italic> (1≤<italic>i</italic>≤<italic>n</italic>), we have two integer-valued variables:
<list list-type="bullet"><list-item><p><italic>x</italic><sub><italic>i</italic></sub>∈{1,…, L}: the location of contig <italic>i</italic> in its scaffold. The location is always the position that aligns with the beginning of the contig. So if the contig aligns to the scaffold in reverse, the location is still the position where the beginning of the contig aligns. See <xref ref-type="fig" rid="F2">Figure 2</xref> for examples.</p></list-item><list-item><p><italic>o</italic><sub><italic>i</italic></sub>∈{0, 1}: the orientation of the contig, 0 meaning reverse orientation and 1 forward orientation.</p></list-item></list>
</p>
      <p>Additionally, there is one real-valued variable for each edge in the scaffolding graph:
<list list-type="bullet"><list-item><p><italic>I</italic><sub><italic>k</italic></sub>∈[0, 1]: how well the distance constraint imposed by edge <italic>k</italic> is satisfied. <italic>I</italic><sub><italic>k</italic></sub>=1 means that in the solution the distance between contigs of edge <italic>k</italic> is exactly d<sub><italic>k</italic></sub>.</p></list-item></list>
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>The two possible placements of contigs <italic>i</italic> and <italic>j</italic> when an edge with orientation corresponding to the top left case in <xref ref-type="fig" rid="F1">Figure 1</xref> is used in a scaffolding. The top figure shows the case when both contigs are forward oriented and the bottom one shows the case when they are reverse oriented.</p></caption><graphic xlink:href="btr562f2"/></fig>
</p>
      <p>We have thus 2<italic>n</italic>+<italic>m</italic> variables in total where <italic>m</italic> is the number of edges in the scaffolding graph.</p>
      <p>Each edge <italic>k</italic> imposes a set of constraints. We give here the constraints for an edge where the two contigs, <italic>i</italic> and <italic>j</italic>, are oriented and positioned with regard to each other according to the top left case in <xref ref-type="fig" rid="F1">Figure 1</xref>. <xref ref-type="fig" rid="F2">Figure 2</xref> shows the two possible placements of the contigs in a scaffold so that the mate pairs are satisfied. We see that here both contigs are either forward oriented or reverse oriented. Thus, <italic>o</italic><sub><italic>i</italic></sub>=<italic>o</italic><sub><italic>j</italic></sub> and we get the following constraints:
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="btr562m1"/></disp-formula>
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="btr562m2"/></disp-formula>
where the indicator variable <italic>I</italic><sub><italic>k</italic></sub> is used to relax the constraints because if the mate pairs are not satisfied in the solution, then the orientations may not match either.</p>
      <p>From the top case of <xref ref-type="fig" rid="F2">Figure 2</xref>, we see that the following should hold when both contigs are forward oriented:
<disp-formula><graphic xlink:href="btr562um1"/></disp-formula>
We get the following relaxed constraints:
<disp-formula id="M3"><label>(3)</label><graphic xlink:href="btr562m3"/></disp-formula>
<disp-formula id="M4"><label>(4)</label><graphic xlink:href="btr562m4"/></disp-formula>
where C is a large enough constant to relax the constraints if either this edge is not included in the solution or the two contigs are reverse oriented. A good choice for C is 2L as <italic>x</italic><sub><italic>i</italic></sub>≤L and <italic>x</italic><sub><italic>j</italic></sub>≤L. Similarly, we get the relaxed constraints for the case where both contigs are reverse oriented (see bottom of <xref ref-type="fig" rid="F2">Fig. 2</xref>):
<disp-formula id="M5"><label>(5)</label><graphic xlink:href="btr562m5"/></disp-formula>
<disp-formula id="M6"><label>(6)</label><graphic xlink:href="btr562m6"/></disp-formula></p>
      <p>The constraints for edges corresponding to the other three cases shown in <xref ref-type="fig" rid="F1">Figure 1</xref> are derived similarly. For each edge, we thus get six constraints corresponding to Equations (<xref ref-type="disp-formula" rid="M1">1</xref>-<xref ref-type="disp-formula" rid="M6">6</xref>). In total, we get 6<italic>m</italic> constraints where <italic>m</italic> is the number of edges in the scaffolding graph.</p>
      <p>When defining the constraints imposed by edge <italic>k</italic>, we allowed the distance d<sub><italic>k</italic></sub> to vary by C (1 − <italic>I</italic><sub><italic>k</italic></sub>). Our objective is to minimize the amount by which we need to stretch these constraints:
<disp-formula><graphic xlink:href="btr562um2"/></disp-formula>
where the sum is over all edges in the scaffolding graph. This is equivalent to the objective function:
<disp-formula id="M7"><label>(7)</label><graphic xlink:href="btr562m7"/></disp-formula>
where again the sum is over all edges in the scaffolding graph. Note that if <italic>I</italic><sub><italic>k</italic></sub> were integer-valued, this would correspond to maximizing the number of satisfied mate pairs.</p>
      <p>The solution to the MIP problem assigns values to the variables <italic>x</italic><sub><italic>i</italic></sub>, <italic>o</italic><sub><italic>i</italic></sub> and <italic>I</italic><sub><italic>k</italic></sub>. We then remove from the scaffolding graph those edges that are stretched or contracted by &gt;1000 bp (i.e. <italic>I</italic><sub><italic>k</italic></sub> is not close to 1). Each connected component of the graph then forms a scaffold and the variables <italic>x</italic><sub><italic>i</italic></sub> and <italic>o</italic><sub><italic>i</italic></sub> give the position and orientation of each contig <italic>i</italic> within its scaffold.</p>
      <p>The above formulation allows two contigs to be positioned in the solution so that they overlap. As post-processing, we detect such overlapping contigs and remove one of them from the scaffold if the overlap is long and the overlapping sequences of the contigs are not similar.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Partitioning the scaffolding problem</title>
      <p><xref ref-type="bibr" rid="B4">Dayarian <italic>et al.</italic>, (2010)</xref> noticed that the scaffolding problem can be partitioned into subproblems that can be solved independently. If the removal of a contig divides the scaffolding graph into two components, then the scaffolding can be solved independently for these two components both of which also include the removed node. Since the two parts of the graph only share one contig, the independent solutions can be easily combined. In graph theoretical terms, this corresponds to dividing the scaffolding graph into its biconnected components, and the contigs whose removal disconnects the graph are the articulation nodes.</p>
      <p>If there are no errors in mate pairs or their mappings, all contigs longer than the insert length of the mate pair library are articulation nodes in the scaffolding graph, because no mate pair spans over them. Thus, long contigs should divide the other contigs into those that come before them and those that come after. In real data, there are chimeric mate pairs and mate pairs that map to several locations in the genome. Therefore, not all long contigs in real data are articulation nodes.</p>
      <p>When combining the scaffolds from independent solutions, overlaps between contigs have to be observed. If combining two solutions would cause two contigs with sequence similarity &lt;90% to overlap, we do not combine the solutions. Instead we keep one solution as it is and remove the contig corresponding to the articulation node from the other solution and split that solution into two scaffolds, those contigs that are placed before the removed one and those that are placed after.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 IMPLEMENTATION</title>
    <sec id="SEC3.1">
      <title>3.1 General</title>
      <p>MIP Scaffolder is implemented as a set of C++ programs. We use Lemon graph library (<ext-link ext-link-type="uri" xlink:href="http://lemon.cs.elte.hu/">http://lemon.cs.elte.hu/</ext-link>) to implement the scaffolding graph and lp_solve (<ext-link ext-link-type="uri" xlink:href="http://lpsolve.sourceforge.net/">http://lpsolve.sourceforge.net/</ext-link>) to solve the MIP problems.</p>
      <p>As input MIP Scaffolder takes the contigs as FASTA files and the alignments of the mate pairs to the contigs as SAM files. MIP Scaffolder can use several mate pair libraries with different insert sizes simultaneously. The output of MIP Scaffolder is the scaffolds in a FASTA file.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Filtering mate-pair mappings</title>
      <p>We first use a read mapper like the readaligner tool by <xref ref-type="bibr" rid="B10">Mäkinen <italic>et al.</italic>, (2010)</xref> to map the mate pairs to the contigs. For further processing, we use only those mate pairs whose both ends map to a unique position in the contig collection.</p>
      <p>To improve the quality of the mate pair mappings, we filter the mappings so that we only keep mappings that are consistent with other mate pairs mapping to approximately the same location. We call a mate pair mapping (<italic>w</italic>, <italic>p</italic>)-<italic>consistent</italic> if for both ends of the mate pair the following holds: if a mate pair end maps to a contig, then there exists a window of length <italic>w</italic> on this contig such that if in total <italic>r</italic> mate pair ends map into the same window and link the contig to the same direction, then at least <italic>p</italic>· <italic>r</italic> of all these mate pairs link the same pair of contigs as the original mate pair. We only keep the mate pairs mappings that are (<italic>w</italic>, <italic>p</italic>)-consistent for some <italic>w</italic> and <italic>p</italic> which are parameters of our method. <xref ref-type="fig" rid="F3">Figure 3</xref> shows examples of (<italic>w</italic>, 0.5)-consistent and inconsistent mate pair mappings. Consistent mate pair mappings can be found by sliding a window of length <italic>w</italic> on each contig. If the window contains <italic>r</italic> mappings and <italic>p</italic>· <italic>r</italic> of these link the same pair of contigs, then the <italic>p</italic>· <italic>r</italic> mate pair ends are marked consistent. We then scan all the mate pair mappings and keep those whose both ends are marked consistent.
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Examples of (<italic>w</italic>, 0.5)-consistent and inconsistent mate pair mappings. The arrows denote contigs and the short lines mate pairs. The mate pair ends are connected with arcs. The mate pairs with solid line arcs connecting them are consistent and the mate pairs with dashed line arcs connecting them are not consistent.</p></caption><graphic xlink:href="btr562f3"/></fig></p>
      <p>Filtering out mate pairs that are not consistent has two benefits. First, it ensures that mate pairs mapping to repeat regions are not used in the scaffolding process even if the repeat region is present only once in the contig collection. If all repeat regions would be present several times, keeping only unique mappings should suffice. Second, the insert length distributions tend to have long tails. Mate pairs whose insert length deviates significantly from the mean may be filtered out allowing us to estimate the distance between contigs more accurately.</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 The scaffold graph</title>
      <p>To estimate the distance d<sub><italic>k</italic></sub> associated with an edge <italic>k</italic> linking two contigs, we use edge bundling (<xref ref-type="bibr" rid="B12">Pop <italic>et al.</italic>, 2004</xref>) combined with a maximum likelihood method (<xref ref-type="bibr" rid="B5">Gnerre <italic>et al.</italic>, 2011</xref>; <xref ref-type="bibr" rid="B14">Simpson <italic>et al.</italic>, 2009</xref>). For each mate pair library, we estimate the mean insert size <italic>g</italic><sub>mean</sub> and the insert size range [g<sub>min</sub>, <italic>g</italic><sub>max</sub>] and using these values we compute minimum and maximum suggested distances between the contigs based on each mate pair. We then find a maximum set of mate pairs such that the intersection of the suggested distance ranges is a non-empty range. The final distance d<sub><italic>k</italic></sub> is then computed as a maximum likelihood estimate based on the mean insert size.</p>
      <p>Contigs from repeat regions complicate the scaffolding process, because they do not have a unique placement in the genome. Like previous approaches (<xref ref-type="bibr" rid="B4">Dayarian <italic>et al.</italic>, 2010</xref>), we attempt to recognize such contigs based on their high degree in the scaffolding graph or much higher than expected coverage and remove them from the scaffolding graph. By default, contigs with coverage &gt;2.5 times the average coverage of contigs or degree &gt;50 are classified as repeat contigs. Both thresholds can be adjusted by the user.</p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Restricting the size of partitions</title>
      <p>If the biconnected components of the scaffolding graph are large, it is not feasible to solve the corresponding MIP problem. Furthermore, solutions to MIP problems of such large partitions often place many contigs so that they overlap with other contigs even if the overlapping sequences are not similar. This complicates the post-processing of the solutions.</p>
      <p>Therefore, we restrict the size of the biconnected components by using a suitable subgraph of the scaffolding graph. We use the technique by <xref ref-type="bibr" rid="B15">Westbrook and Tarjan (1992</xref>) to keep track of the biconnected components dynamically as new edges are added to the scaffolding graph. We measure the size of a biconnected component by the number of edges. First, we sort the potential edges of the scaffolding graph in decreasing order according to their support s<sub><italic>k</italic></sub>. We then add the edges to the graph in this order but only if the addition of an edge does not create a too large biconnected component. This allows us to demand high support edges for those parts of the genome that are well sampled by the mate pair library, while also being able to utilize lower support edges for those parts of the genome that have a lower coverage in the mate pair library. We show in our experiments that a relatively small threshold for the component size yields the best scaffolding results.</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 RESULTS AND DISCUSSION</title>
    <sec id="SEC4.1">
      <title>4.1 Mate pair libraries and contigs</title>
      <p>The read sets used to test our approach are summarized in <xref ref-type="table" rid="T1">Table 1</xref>. The first two read sets are SOLiD reads from the <italic>Escherichia coli</italic> DH10B substrain and the <italic>Caernorhabditis Elegans</italic> genome. The <italic>E.coli</italic> read set is produced by Applied Biosystems, and we used the filtered subset available at <ext-link ext-link-type="uri" xlink:href="http://hts.rutgers.edu/">http://hts.rutgers.edu/</ext-link>. This set is quality filtered and trimmed to 35 bp. We used the mean filter distributed with SOPRA to filter the <italic>C.elegans</italic> read set and kept reads with average quality at least 19 and no indeterminate colors. The third read set is an Illumina paired end library for <italic>Pseudomonas syringae</italic> and the fourth read set consists of two Illumina mate pair libraries for the human genome. The human Illumina mate pair libraries were first trimmed to 36 bp and then we filtered out all reads where &gt;30% of the bases had quality score ≤10. The statistics in <xref ref-type="table" rid="T1">Table 1</xref> are for the filtered sets.
<table-wrap id="T1" position="float"><label>Table 1.</label><caption><p>The test datasets</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"><italic>E.coli</italic></th><th align="left" rowspan="1" colspan="1"><italic>C.elegans</italic></th><th align="left" rowspan="1" colspan="1"><italic>P.syringae</italic></th><th align="left" colspan="2" rowspan="1"><italic>H.sapiens</italic><hr/></th></tr><tr><th align="left" rowspan="1" colspan="1">Reference organism</th><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1"/></tr><tr><th align="left" rowspan="1" colspan="1">Name</th><th align="left" rowspan="1" colspan="1"><italic>Escherichia coli</italic></th><th align="left" rowspan="1" colspan="1"><italic>Caenorhabditis elegans</italic></th><th align="left" rowspan="1" colspan="1"><italic>Pseudomonas syringae</italic></th><th align="left" colspan="2" rowspan="1"><italic>Homo sapiens</italic></th></tr><tr><th align="left" rowspan="1" colspan="1">Genome size (Mbp)</th><th align="left" rowspan="1" colspan="1">4.6</th><th align="left" rowspan="1" colspan="1">100.3</th><th align="left" rowspan="1" colspan="1">6.1</th><th align="left" colspan="2" rowspan="1">3080</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Dataset</td><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/></tr><tr><td align="left" rowspan="1" colspan="1">Accession number (SRA/ERA)</td><td align="left" rowspan="1" colspan="1">NA</td><td align="left" rowspan="1" colspan="1">SRR033650</td><td align="left" rowspan="1" colspan="1">ERR005143</td><td align="left" rowspan="1" colspan="1">SRR067771</td><td align="left" rowspan="1" colspan="1">SRR067773</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">SRR067777</td><td align="left" rowspan="1" colspan="1">SRR067779</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">SRR067781</td><td align="left" rowspan="1" colspan="1">SRR067778</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1"/><td align="left" rowspan="1" colspan="1">SRR067776</td><td align="left" rowspan="1" colspan="1">SRR067786</td></tr><tr><td align="left" rowspan="1" colspan="1">Read length (bp)</td><td align="left" rowspan="1" colspan="1">35</td><td align="left" rowspan="1" colspan="1">25</td><td align="left" rowspan="1" colspan="1">36</td><td align="left" rowspan="1" colspan="1">36</td><td align="left" rowspan="1" colspan="1">36</td></tr><tr><td align="left" rowspan="1" colspan="1">Number of reads</td><td align="left" rowspan="1" colspan="1">2× 7.4 M</td><td align="left" rowspan="1" colspan="1">2× 24 M</td><td align="left" rowspan="1" colspan="1">2× 3.6 M</td><td align="left" rowspan="1" colspan="1">2× 298.6 M</td><td align="left" rowspan="1" colspan="1">2× 342.0 M</td></tr><tr><td align="left" rowspan="1" colspan="1">Coverage</td><td align="left" rowspan="1" colspan="1">110×</td><td align="left" rowspan="1" colspan="1">10×</td><td align="left" rowspan="1" colspan="1">42×</td><td align="left" rowspan="1" colspan="1">7×</td><td align="left" rowspan="1" colspan="1">8×</td></tr><tr><td align="left" rowspan="1" colspan="1">Spanning coverage</td><td align="left" rowspan="1" colspan="1">1930×</td><td align="left" rowspan="1" colspan="1">427×</td><td align="left" rowspan="1" colspan="1">236×</td><td align="left" rowspan="1" colspan="1">223×</td><td align="left" rowspan="1" colspan="1">311×</td></tr><tr><td align="left" rowspan="1" colspan="1">Insert size</td><td align="left" rowspan="1" colspan="1">1200</td><td align="left" rowspan="1" colspan="1">1785</td><td align="left" rowspan="1" colspan="1">400</td><td align="left" rowspan="1" colspan="1">2300</td><td align="left" rowspan="1" colspan="1">2800</td></tr><tr><td align="left" rowspan="1" colspan="1">Sequencing platform</td><td align="left" rowspan="1" colspan="1">SOLiD</td><td align="left" rowspan="1" colspan="1">SOLiD</td><td align="left" rowspan="1" colspan="1">Illumina</td><td align="left" rowspan="1" colspan="1">Illumina</td><td align="left" rowspan="1" colspan="1">Illumina</td></tr></tbody></table><table-wrap-foot><fn><p>The statistics are given for the sets after trimming and filtering. The spanning coverage is the total coverage of the read pairs and the bases in between them.</p></fn></table-wrap-foot></table-wrap>
</p>
      <p>We ran the initial contig assembly with Velvet (<xref ref-type="bibr" rid="B16">Zerbino and Birney, 2008</xref>). The reads in the <italic>C.elegans</italic> dataset were too short and the coverage too low to assemble the reads into contigs. We were also not able to assemble contigs for the complete human genome because of memory constraints. Instead we used the wgsim tool distributed with SAMtools (<xref ref-type="bibr" rid="B7">Li <italic>et al.</italic>, 2009</xref>) to generate synthetic reads of length 100 from the reference genome and built the contigs based on these reads. For the human genome, the reads were generated and assembled one chromosome at a time to keep the memory requirements on a reasonable level. The coverage of these synthetic reads was 30× for <italic>C.elegans</italic>. For the human genome, we generated paired reads with insert size 500 and 20× coverage. These reads were not made available for scaffolding.</p>
      <p>When running Velvet, we kept contigs &gt;150 bp. We used the following other parameters:
<list list-type="bullet"><list-item><p><italic>E.coli</italic>: hash length 19 and coverage cutoff 6.</p></list-item><list-item><p><italic>C.elegans</italic>: hash length 61 and coverage cutoff 6.</p></list-item><list-item><p><italic>P.syringae</italic>: hash length 21 and coverage cutoff 6.</p></list-item><list-item><p><italic>H.sapiens</italic>: hash length 57, coverage cutoff 6, and expected coverage 20, no scaffolding.</p></list-item></list>
</p>
      <p>The <italic>E.coli</italic> dataset was in color space and we used the contig translation of SOPRA to get contigs in base space. For the other datasets, the reads used to build the contigs were in base space and so we could directly use the contigs produced by Velvet. The statistics of the produced contigs are included in <xref ref-type="table" rid="T3">Tables 3</xref>–<xref ref-type="table" rid="T6">6</xref>.</p>
    </sec>
    <sec id="SEC4.2">
      <title>4.2 Evaluation of scaffolds</title>
      <p>The produced scaffolds were compared for the length of the scaffolds and for their correctness. For length comparison, we used the N50 measure as well as the total length of the scaffolds.</p>
      <p>We evaluated the correctness of the scaffolds as follows. Using swift by <xref ref-type="bibr" rid="B13">Rasmussen <italic>et al.</italic> (2006</xref>), we searched for maximal approximate local matches between the scaffold and the genome sequence. With <italic>E.coli</italic> and <italic>P.syringae</italic>, we used parameters 11 for the seed length, 0.05 for the maximum error level and 30 for the minimum length of a maximal match. With <italic>C.elegans</italic>, we used the same seed length, 0.02 for the maximum error level and 35 for the minimum length of a maximal match. With the human scaffolds, we used 0.01 for the maximum error level, and 100 for the minimal length of a maximal match. This produced a set of tuples each representing a match between a substring range of scaffold and substring range of genome. To obtain an alignment for the whole scaffold inside the genome, we implemented the colinear chaining algorithm (<xref ref-type="bibr" rid="B1">Abouelhoda, 2007</xref>) that finds a subset of the tuples that retains the linear order in both source (scaffold) and target (genome), and maximizes the overall coverage of the source (scaffold). Additionally, we restricted the length of gaps in the colinear chaining algorithm to 2000 bp on the <italic>E.coli</italic> and <italic>P.syringae</italic> datasets and to 5000 bp on the <italic>C.elegans</italic> and human datasets. This way we could obtain a reliable alignment without resorting into laborious sequence-level dynamic programming.</p>
      <p>Three measures were computed based on the colinear chaining. <italic>Genome coverage</italic> denotes the proportion of positions inside the genome taking part into the alignment. <italic>Scaffold coverage</italic> denotes the proportion of positions inside scaffolds taking part into the alignment. We also extracted those parts of the scaffolds that took part into the alignment and repeated the colinear chaining computation recursively for the remaining part until no parts having a maximal local approximate match remained. Finally, we computed the N50 length statistic for all extracted parts. We call this N50 value the <italic>normalized N50 statistic</italic>. Note that the extracted parts of scaffolds do not contain gaps and so the normalized N50 statistic should be compared to the N50 value computed on the complete scaffolds excluding gaps.</p>
      <p>The validity of scaffolds was additionally measured similarly to <xref ref-type="bibr" rid="B5">Gnerre <italic>et al.</italic> (2011</xref>). Pairs of sequences separated by a given distance were extracted randomly from the scaffolds. These pairs were then mapped to the reference and we measured the proportion of pairs whose orientation matched and distance was within 10% of the given distance. The validity of contigs was not measured in this fashion as they were not long enough.</p>
    </sec>
    <sec id="SEC4.3">
      <title>4.3 Parameters and runtime of the scaffolders</title>
      <p>For the <italic>E.coli</italic>, <italic>C.elegans</italic> and <italic>P.syringae</italic> datasets, we used readaligner (<xref ref-type="bibr" rid="B10">Mäkinen <italic>et al.</italic>, 2010</xref>) to map the mate pairs to contigs and for the human dataset we used SOAP2 (<xref ref-type="bibr" rid="B8">Li <italic>et al.</italic>, 2009</xref>). For the <italic>E.coli</italic> and <italic>P.syringae</italic> datasets, the results for SOPRA are for the version which is integrated with Velvet and thus directly uses the placement of reads as designated by Velvet. We allowed at most two edit operations (mismatches and indels) when running readaligner and at most three mismatches when running SOAP2. We were able to map 91% of the <italic>E.coli</italic> reads, 87% of the <italic>C.elegans</italic> reads and 87% of the <italic>P.syringae</italic> reads. For the human dataset, SOAP2 reported a unique match for 70% of the reads.</p>
      <p>We tried several parameter combinations for MIP Scaffolder. <xref ref-type="fig" rid="F4">Figure 4</xref> shows how the N50 value and the genome coverage of the scaffolds for the <italic>E.coli</italic> dataset evolve as we vary <italic>w</italic> and <italic>p</italic> when determining (<italic>w</italic>,<italic>p</italic>)-consistent mappings. The longest scaffolds are produced with fairly loose filtering but the loosest filtering also gives less accurate scaffolds. <xref ref-type="fig" rid="F5">Figure 5</xref> shows how the N50 value and the genome coverage evolve when the maximum size of the biconnected component is varied. Here, we notice that the maximum size of the component does not affect the scaffold lengths or correctness much. For the analysis of the scaffolds, we used (10, 0.7)-consistent mappings and maximum component size 100.
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>The effect of filtering (<italic>w</italic>,<italic>p</italic>)-consistent mappings for the <italic>E.coli</italic> dataset. Here we used the maximum component size of 100 edges.</p></caption><graphic xlink:href="btr562f4"/></fig>
<fig id="F5" position="float"><label>Fig. 5.</label><caption><p>The effect of maximum component size for (<italic>w</italic>,<italic>p</italic>)-consistent mappings for various combinations of <italic>w</italic> and <italic>p</italic> for the <italic>E.coli</italic> dataset.</p></caption><graphic xlink:href="btr562f5"/></fig></p>
      <p>We similarly experimented with different parameters on the other datasets and chose those parameters that produced longest scaffolds. For the <italic>C.elegans</italic> dataset, we used (30, 0.75)-consistent read mapping and maximum component size 50, for the <italic>P.syringae</italic> dataset (30, 0.5)-consistent read mappings and maximum component size 50 and for the human dataset (50, 0.75)-consistent read mappings and maximum component size 50.</p>
      <p>We tried several parameters for running SOPRA and show the results for those parameters that gave the longest scaffolds measured by the N50 value. The <italic>E.coli</italic> and the <italic>P.syringae</italic> scaffolds were produced with the version of SOPRA that is integrated with Velvet, and the <italic>C.elegans</italic> and human scaffolds were produced using pregenerated contigs. For the <italic>E.coli</italic> dataset, we got best results with support threshold (-w) 6. The original paper reports result with support threshold 5 but our scaffolds are slightly longer. This might be due to the stochastic nature of the algorithm which means that even different runs with the same parameters may produce different results. For the <italic>C.elegans</italic> and <italic>P.syringae</italic> datasets, we got longest scaffolds with support thresholds 20 and 4, respectively. We could not run SOPRA on the human dataset because it ran out of memory.</p>
      <p>SSPACE does not support mate pair libraries from the SOLiD technology and so we ran it only on the <italic>P.syringae</italic> and human datasets. SSPACE was run with default parameters.</p>
      <p>The scaffolders were run on a server with 16 cores operating at 2.93 GHz and 128 GB of memory. <xref ref-type="table" rid="T2">Table 2</xref> shows the runtimes of the different scaffolders. We see that MIP Scaffolder is the fastest of the scaffolders except on the human dataset. On the human dataset, MIP Scaffolder spent half of its time preprocessing the read mappings. As further work, we plan to improve the efficiency of this phase.
<table-wrap id="T2" position="float"><label>Table 2.</label><caption><p>Runtimes (in hours) of the scaffolders</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1"><italic>E.coli</italic></th><th align="left" rowspan="1" colspan="1"><italic>C.elegans</italic></th><th align="left" rowspan="1" colspan="1"><italic>P.syringae</italic></th><th align="left" rowspan="1" colspan="1"><italic>H.sapiens</italic></th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">SOPRA</td><td align="left" rowspan="1" colspan="1">0.17</td><td align="left" rowspan="1" colspan="1">3.12</td><td align="left" rowspan="1" colspan="1">0.03</td><td align="left" rowspan="1" colspan="1">–</td></tr><tr><td align="left" rowspan="1" colspan="1">SSPACE</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">0.02</td><td align="left" rowspan="1" colspan="1">9.5</td></tr><tr><td align="left" rowspan="1" colspan="1">MIP Scaffolder</td><td align="left" rowspan="1" colspan="1">0.03</td><td align="left" rowspan="1" colspan="1">0.20</td><td align="left" rowspan="1" colspan="1">0.004</td><td align="left" rowspan="1" colspan="1">18.8</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="SEC4.4">
      <title>4.4 Comparison of scaffolds</title>
      <p><xref ref-type="table" rid="T3">Tables 3</xref>–<xref ref-type="table" rid="T6">6</xref> show the length and validation statistics of the scaffolds produced by SOPRA, SSPACE and MIP Scaffolder for the various datasets. We report the scaffold lengths both including gaps and without gaps. The length statistics without gaps are more important, because the statistics with gaps can vary if the insert length of the mate pair library is estimated incorrectly (<xref ref-type="bibr" rid="B12">Pop <italic>et al.</italic>, 2004</xref>).</p>
      <p>For the <italic>E.coli</italic> data, SOPRA produces longest scaffolds that are also the most accurate as measured by genome coverage. The validity at 10 kb of these scaffolds is low because SOPRA's estimate of the insert size is not accurate. For the <italic>C.elegans</italic> data, MIP Scaffolder produces longest scaffolds that are almost as accurate as those produced by SOPRA. On this dataset, we note that scaffolds produced by SOPRA have a higher genome coverage than the contigs which is likely due to our method maximizing the scaffold coverage instead of genome coverage; contigs can be easier aligned to the same region in genome than scaffolds. For the <italic>P.syringae</italic> data, MIP Scaffolder produces longest scaffolds that are not quite as accurate as those produced by the other methods. We also note that SSPACE performs better than SOPRA on this dataset. For the human scaffolds, the coverage figures are quite low for both MIP Scaffolder and SSPACE. This is partly due to the strict alignment criteria that was used to make running the validation feasible. Also the coverage of the contigs is low for this dataset indicating that a larger portion of the contigs are chimeric. A chimeric contig incorporated into a scaffold breaks the alignment of the scaffold against the reference into two parts of which only the longer one is considered in our validation method when computing genome and scaffold coverage. Structural variation between individuals may also cause lower coverage in the human data as the contigs are built on simulated reads from the reference genome, while the mate pairs are real data. Also validity at 50 kb is low indicating problems with scaffolding.
<table-wrap id="T3" position="float"><label>Table 3.</label><caption><p>The length and validation statistics of scaffolds produced from the <italic>E.coli</italic> data set by the scaffolders</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Scaffolder</th><th align="left" rowspan="2" colspan="1">Number of scaffolds</th><th align="center" colspan="2" rowspan="1">N50 (bp)</th><th align="center" colspan="2" rowspan="1">Total length (bp)</th><th align="left" rowspan="2" colspan="1">Genome coverage</th><th align="left" rowspan="2" colspan="1">Scaffold coverage</th><th align="left" rowspan="2" colspan="1">Normalized N50(bp)</th><th align="left" rowspan="2" colspan="1">Validity at 10kb</th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Contigs</td><td align="left" rowspan="1" colspan="1">4341</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">1499</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">4 362 035</td><td align="left" rowspan="1" colspan="1">0.922</td><td align="left" rowspan="1" colspan="1">0.998</td><td align="left" rowspan="1" colspan="1">1496</td><td align="left" rowspan="1" colspan="1">–</td></tr><tr><td align="left" rowspan="1" colspan="1">SOPRA</td><td align="left" rowspan="1" colspan="1">168</td><td align="left" rowspan="1" colspan="1">203 090</td><td align="left" rowspan="1" colspan="1">185 290</td><td align="left" rowspan="1" colspan="1">4 840 884</td><td align="left" rowspan="1" colspan="1">4 354 534</td><td align="left" rowspan="1" colspan="1">0.912</td><td align="left" rowspan="1" colspan="1">0.988</td><td align="left" rowspan="1" colspan="1">185 227</td><td align="left" rowspan="1" colspan="1">0.910</td></tr><tr><td align="left" rowspan="1" colspan="1">MIP Scaffolder</td><td align="left" rowspan="1" colspan="1">207</td><td align="left" rowspan="1" colspan="1">182 666</td><td align="left" rowspan="1" colspan="1">170 864</td><td align="left" rowspan="1" colspan="1">4 558 212</td><td align="left" rowspan="1" colspan="1">4 327 789</td><td align="left" rowspan="1" colspan="1">0.889</td><td align="left" rowspan="1" colspan="1">0.968</td><td align="left" rowspan="1" colspan="1">170 796</td><td align="left" rowspan="1" colspan="1">0.972</td></tr></tbody></table><table-wrap-foot><fn><p>When computing colinear chaining to obtain genome coverage, scaffold coverage and normalized N50 values, gaps were restricted to at most 2000 bp.</p></fn></table-wrap-foot></table-wrap>
<table-wrap id="T4" position="float"><label>Table 4.</label><caption><p>The length and validation statistics of scaffolds produced from the <italic>C.elegans</italic> dataset by the scaffolders</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Scaffolder</th><th align="left" rowspan="2" colspan="1">Number of scaffolds</th><th align="center" colspan="2" rowspan="1">N50 (bp)</th><th align="center" colspan="2" rowspan="1">Total length (bp)</th><th align="left" rowspan="1" colspan="1">Genome coverage</th><th align="left" rowspan="1" colspan="1">Scaffold coverage</th><th align="left" rowspan="1" colspan="1">Normalized N50 (bp)</th><th align="left" rowspan="1" colspan="1">Validity at 10 kb</th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Contigs</td><td align="left" rowspan="1" colspan="1">31 419</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">14 717</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">96 249 755</td><td align="left" rowspan="1" colspan="1">0.943</td><td align="left" rowspan="1" colspan="1">1.000</td><td align="left" rowspan="1" colspan="1">14 717</td><td align="left" rowspan="1" colspan="1">–</td></tr><tr><td align="left" rowspan="1" colspan="1">SOPRA</td><td align="left" rowspan="1" colspan="1">17 951</td><td align="left" rowspan="1" colspan="1">132 547</td><td align="left" rowspan="1" colspan="1">130 346</td><td align="left" rowspan="1" colspan="1">98 595 934</td><td align="left" rowspan="1" colspan="1">96 243 554</td><td align="left" rowspan="1" colspan="1">0.945</td><td align="left" rowspan="1" colspan="1">0.999</td><td align="left" rowspan="1" colspan="1">130 346</td><td align="left" rowspan="1" colspan="1">0.990</td></tr><tr><td align="left" rowspan="1" colspan="1">MIP Scaffolder</td><td align="left" rowspan="1" colspan="1">10 721</td><td align="left" rowspan="1" colspan="1">189 704</td><td align="left" rowspan="1" colspan="1">187 796</td><td align="left" rowspan="1" colspan="1">98 273 945</td><td align="left" rowspan="1" colspan="1">95 406 856</td><td align="left" rowspan="1" colspan="1">0.933</td><td align="left" rowspan="1" colspan="1">0.986</td><td align="left" rowspan="1" colspan="1">183 891</td><td align="left" rowspan="1" colspan="1">0.973</td></tr></tbody></table><table-wrap-foot><fn><p>When computing colinear chaining to obtain genome coverage, scaffold coverage and normalized N50 values, gaps were restricted to at most 5000 bp.</p></fn></table-wrap-foot></table-wrap>
<table-wrap id="T5" position="float"><label>Table 5.</label><caption><p>The length and validation statistics of scaffolds produced from the <italic>P.syringae</italic> dataset by the scaffolders</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Scaffolder</th><th align="left" rowspan="2" colspan="1">Number of scaffolds</th><th align="center" colspan="2" rowspan="1">N50 (bp)</th><th align="center" colspan="2" rowspan="1">Total length (bp)</th><th align="left" rowspan="2" colspan="1">Genome coverage</th><th align="left" rowspan="2" colspan="1">Scaffold coverage</th><th align="left" rowspan="2" colspan="1">Normalized N50 (bp)</th><th align="left" rowspan="2" colspan="1">Validity at 10 kb</th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Contigs</td><td align="left" rowspan="1" colspan="1">2251</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">6972</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">5 925 601</td><td align="left" rowspan="1" colspan="1">0.964</td><td align="left" rowspan="1" colspan="1">0.981</td><td align="left" rowspan="1" colspan="1">6982</td><td align="left" rowspan="1" colspan="1">–</td></tr><tr><td align="left" rowspan="1" colspan="1">SOPRA</td><td align="left" rowspan="1" colspan="1">568</td><td align="left" rowspan="1" colspan="1">75 224</td><td align="left" rowspan="1" colspan="1">74 724</td><td align="left" rowspan="1" colspan="1">5 987 540</td><td align="left" rowspan="1" colspan="1">5 917 490</td><td align="left" rowspan="1" colspan="1">0.958</td><td align="left" rowspan="1" colspan="1">0.989</td><td align="left" rowspan="1" colspan="1">72 714</td><td align="left" rowspan="1" colspan="1">0.998</td></tr><tr><td align="left" rowspan="1" colspan="1">SSPACE</td><td align="left" rowspan="1" colspan="1">345</td><td align="left" rowspan="1" colspan="1">94 315</td><td align="left" rowspan="1" colspan="1">93 850</td><td align="left" rowspan="1" colspan="1">5 991 990</td><td align="left" rowspan="1" colspan="1">5 910 839</td><td align="left" rowspan="1" colspan="1">0.946</td><td align="left" rowspan="1" colspan="1">0.978</td><td align="left" rowspan="1" colspan="1">93 850</td><td align="left" rowspan="1" colspan="1">0.984</td></tr><tr><td align="left" rowspan="1" colspan="1">MIP Scaffolder</td><td align="left" rowspan="1" colspan="1">188</td><td align="left" rowspan="1" colspan="1">103 598</td><td align="left" rowspan="1" colspan="1">103 352</td><td align="left" rowspan="1" colspan="1">5 990 318</td><td align="left" rowspan="1" colspan="1">5 919 596</td><td align="left" rowspan="1" colspan="1">0.918</td><td align="left" rowspan="1" colspan="1">0.949</td><td align="left" rowspan="1" colspan="1">84 779</td><td align="left" rowspan="1" colspan="1">0.983</td></tr></tbody></table><table-wrap-foot><fn><p>When computing colinear chaining to obtain genome coverage, scaffold coverage and normalized N50 values, gaps were restricted to at most 2000 bp.</p></fn></table-wrap-foot></table-wrap>
<table-wrap id="T6" position="float"><label>Table 6.</label><caption><p>The length and validation statistics of scaffolds produced from the <italic>H.sapiens</italic> dataset by the scaffolders</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Scaffolder</th><th align="left" rowspan="2" colspan="1">Number of scaffolds</th><th align="center" colspan="2" rowspan="1">N50 (bp)</th><th align="center" colspan="2" rowspan="1">Total length (bp)</th><th align="left" rowspan="2" colspan="1">Genome</th><th align="left" rowspan="2" colspan="1">Scaffold</th><th align="left" rowspan="2" colspan="1">Normalized</th><th align="left" rowspan="2" colspan="1">Validity</th></tr><tr><th rowspan="1" colspan="1"/><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th><th align="left" rowspan="1" colspan="1">With gaps</th><th align="left" rowspan="1" colspan="1">No gaps</th></tr></thead><tbody align="left"><tr><td align="left" rowspan="1" colspan="1">Contigs</td><td align="left" rowspan="1" colspan="1">349 514</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">18 994</td><td align="left" rowspan="1" colspan="1">–</td><td align="left" rowspan="1" colspan="1">2 785 310 070</td><td align="left" rowspan="1" colspan="1">0.863</td><td align="left" rowspan="1" colspan="1">0.959</td><td align="left" rowspan="1" colspan="1">18 185</td><td align="left" rowspan="1" colspan="1">–</td></tr><tr><td align="left" rowspan="1" colspan="1">SSPACE</td><td align="left" rowspan="1" colspan="1">97 525</td><td align="left" rowspan="1" colspan="1">348 941</td><td align="left" rowspan="1" colspan="1">348 566</td><td align="left" rowspan="1" colspan="1">2 834 193 333</td><td align="left" rowspan="1" colspan="1">2 783 020 651</td><td align="left" rowspan="1" colspan="1">0.640</td><td align="left" rowspan="1" colspan="1">0.719</td><td align="left" rowspan="1" colspan="1">179 418</td><td align="left" rowspan="1" colspan="1">0.869</td></tr><tr><td align="left" rowspan="1" colspan="1">MIP Scaffolder</td><td align="left" rowspan="1" colspan="1">83 909</td><td align="left" rowspan="1" colspan="1">328 665</td><td align="left" rowspan="1" colspan="1">325 444</td><td align="left" rowspan="1" colspan="1">2 823 814 726</td><td align="left" rowspan="1" colspan="1">2 776 643 640</td><td align="left" rowspan="1" colspan="1">0.684</td><td align="left" rowspan="1" colspan="1">0.769</td><td align="left" rowspan="1" colspan="1">190 008</td><td align="left" rowspan="1" colspan="1">0.870</td></tr></tbody></table><table-wrap-foot><fn><p>When computing colinear chaining to obtain genome coverage, scaffold coverage and normalized N50 values, gaps were restricted to at most 5000 bp.</p></fn></table-wrap-foot></table-wrap>
</p>
    </sec>
  </sec>
  <sec id="SEC5">
    <title>5 CONCLUSION</title>
    <p>We have presented MIP Scaffolder which partitions the scaffolding problem into subproblems of restricted size and solves these subproblems exactly with mixed integer programming. We compared MIP Scaffolder to SOPRA and SSPACE on four datasets. On two of the datasets, MIP Scaffolder produced longer scaffolds that are not quite as accurate as those produced by the other two methods. For the human dataset, MIP Scaffolder produced slightly shorter but more accurate scaffolds than SSPACE and on the <italic>E.coli</italic> dataset SOPRA outperformed MIP Scaffolder. Our experiments also showed that our approach is fast allowing the user to try out different parameter combinations easily to optimize for long scaffolds. It is also possible to optimize for accurate scaffolds if, for example, EST data or the sequence of a close relative species can be used to measure the correctness of scaffolding.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENT</title>
    <p>We wish to thank Rainer Lehtonen, Virpi Ahola, Ilkka Hanski, Panu Somervuo, Lars Paulin, Petri Auvinen, Liisa Holm, Patrik Koskinen and Pasi Rastas for insightful discussions about sequence assembly and scaffolding.</p>
    <p><italic>Funding</italic>: <funding-source>Academy of Finland</funding-source> [Grant numbers <award-id>118653 (ALGODAN)</award-id> and <award-id>1140727</award-id>]; <funding-source>Helsinki Graduate School in Computer Science and Engineering</funding-source>.</p>
    <p><italic>Conflict of Interest:</italic> none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>A chaining algorithm for mapping cdna sequences to multiple genomic sequences</article-title>
        <source>Proceedings of SPIRE′07</source>
        <year>2007</year>
        <volume>4726</volume>
        <publisher-loc>Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>1</fpage>
        <lpage>13</lpage>
        <comment>of <italic>LNCS</italic></comment>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Boetzer</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Scaffolding pre-assembled contigs using SSPACE</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>578</fpage>
        <lpage>579</lpage>
        <pub-id pub-id-type="pmid">21149342</pub-id>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Butler</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ALLPATHS: de novo assembly of whole-genome shotgun microreads</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>810</fpage>
        <lpage>820</lpage>
        <pub-id pub-id-type="pmid">18340039</pub-id>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dayarian</surname>
            <given-names>A.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SOPRA: scaffolding algorithm for paired reads via statistical optimization</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>345</fpage>
        <pub-id pub-id-type="pmid">20576136</pub-id>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gnerre</surname>
            <given-names>S.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2011</year>
        <volume>108</volume>
        <fpage>1513</fpage>
        <lpage>1518</lpage>
        <pub-id pub-id-type="pmid">21187386</pub-id>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kececioglu</surname>
            <given-names>J.D.</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E.W.</given-names>
          </name>
        </person-group>
        <article-title>Combinatorial algorithms for DNA sequence assembly</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>13</volume>
        <fpage>7</fpage>
        <lpage>51</lpage>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>The sequence alignment/map (SAM) format and SAMtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2078</fpage>
        <lpage>2079</lpage>
        <comment>1000 Genome Project Data Processing Subgroup</comment>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SOAP2: an improved ultrafast tool for short read alignment</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1966</fpage>
        <lpage>1967</lpage>
        <pub-id pub-id-type="pmid">19497933</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome Res.</source>
        <year>2010</year>
        <volume>20</volume>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Mäkinen</surname>
            <given-names>V.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Unified view of backward backtracking in short read mapping</article-title>
        <source>Algorithms and Applications: Essays Dedicated to Esko Ukkonen on the Occasion of His 60th Birthday</source>
        <year>2010</year>
        <volume>6060</volume>
        <publisher-loc>Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>182</fpage>
        <lpage>195</lpage>
        <comment>of <italic>LNCS</italic></comment>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pop</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Genome assembly reborn: recent computational challenges</article-title>
        <source>Brief. Bioinformatics</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>354</fpage>
        <lpage>366</lpage>
        <pub-id pub-id-type="pmid">19482960</pub-id>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pop</surname>
            <given-names>M.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Hierarchical scaffolding with Bambus</article-title>
        <source>Genome Res.</source>
        <year>2004</year>
        <volume>14</volume>
        <fpage>149</fpage>
        <lpage>159</lpage>
        <pub-id pub-id-type="pmid">14707177</pub-id>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rasmussen</surname>
            <given-names>K.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Efficient q-gram filters for finding all epsilon-matches over a given length</article-title>
        <source>J. Comp. Biol.</source>
        <year>2006</year>
        <volume>13</volume>
        <fpage>296</fpage>
        <lpage>308</lpage>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>J.T.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ABySS: a parallel assembler for short read sequence data</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Westbrook</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Tarjan</surname>
            <given-names>R.E.</given-names>
          </name>
        </person-group>
        <article-title>Maintaining bridge-connected and biconnected components on-line</article-title>
        <source>Algorithmica</source>
        <year>1992</year>
        <volume>7</volume>
        <fpage>433</fpage>
        <lpage>464</lpage>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>D.R.</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
