<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Sci Rep</journal-id>
    <journal-id journal-id-type="iso-abbrev">Sci Rep</journal-id>
    <journal-title-group>
      <journal-title>Scientific Reports</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2045-2322</issn>
    <publisher>
      <publisher-name>Nature Publishing Group UK</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6962409</article-id>
    <article-id pub-id-type="publisher-id">54957</article-id>
    <article-id pub-id-type="doi">10.1038/s41598-019-54957-7</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Brian2GeNN: accelerating spiking neural network simulations with graphics hardware</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-2648-4790</contrib-id>
        <name>
          <surname>Stimberg</surname>
          <given-names>Marcel</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-1007-6474</contrib-id>
        <name>
          <surname>Goodman</surname>
          <given-names>Dan F. M.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-4451-915X</contrib-id>
        <name>
          <surname>Nowotny</surname>
          <given-names>Thomas</given-names>
        </name>
        <address>
          <email>t.nowotny@sussex.ac.uk</email>
        </address>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <aff id="Aff1"><label>1</label>Sorbonne Université, INSERM, CNRS, Institut de la Vision, Paris, France </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2113 8111</institution-id><institution-id institution-id-type="GRID">grid.7445.2</institution-id><institution>Department of Electrical and Electronic Engineering, </institution><institution>Imperial College London, </institution></institution-wrap>London, UK </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 1936 7590</institution-id><institution-id institution-id-type="GRID">grid.12082.39</institution-id><institution>Centre for Computational Neuroscience and Robotics, </institution><institution>Sussex Neuroscience, School of Engineering and Informatics, University of Sussex, </institution></institution-wrap>Brighton, UK </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>15</day>
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>15</day>
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>10</volume>
    <elocation-id>410</elocation-id>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>5</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>11</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">“Brian” is a popular Python-based simulator for spiking neural networks, commonly used in computational neuroscience. GeNN is a C++-based meta-compiler for accelerating spiking neural network simulations using consumer or high performance grade graphics processing units (GPUs). Here we introduce a new software package, Brian2GeNN, that connects the two systems so that users can make use of GeNN GPU acceleration when developing their models in Brian, without requiring any technical knowledge about GPUs, C++ or GeNN. The new Brian2GeNN software uses a pipeline of code generation to translate Brian scripts into C++ code that can be used as input to GeNN, and subsequently can be run on suitable NVIDIA GPU accelerators. From the user’s perspective, the entire pipeline is invoked by adding two simple lines to their Brian scripts. We have shown that using Brian2GeNN, two non-trivial models from the literature can run tens to hundreds of times faster than on CPU.</p>
    </abstract>
    <kwd-group kwd-group-type="npg-subject">
      <title>Subject terms</title>
      <kwd>Computational neuroscience</kwd>
      <kwd>Software</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">https://doi.org/10.13039/501100000266</institution-id>
            <institution>RCUK | Engineering and Physical Sciences Research Council (EPSRC)</institution>
          </institution-wrap>
        </funding-source>
        <award-id>EP/J019690/1</award-id>
        <award-id>EP/P006094/1</award-id>
        <principal-award-recipient>
          <name>
            <surname>Nowotny</surname>
            <given-names>Thomas</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">https://doi.org/10.13039/100010661</institution-id>
            <institution>EC | Horizon 2020 Framework Programme (EU Framework Programme for Research and Innovation H2020)</institution>
          </institution-wrap>
        </funding-source>
        <award-id>785907</award-id>
        <principal-award-recipient>
          <name>
            <surname>Nowotny</surname>
            <given-names>Thomas</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1" sec-type="introduction">
    <title>Introduction</title>
    <p id="Par2">GPU acceleration emerged when creative academics discovered that modern graphics processing units (GPUs) could be used to execute general purpose algorithms, e.g. for neural network simulations<sup><xref ref-type="bibr" rid="CR1">1</xref>,<xref ref-type="bibr" rid="CR2">2</xref></sup>. The real revolution occurred when NVIDIA corporation embraced the idea of GPUs as general purpose computing accelerators and developed the CUDA application programming interface<sup><xref ref-type="bibr" rid="CR3">3</xref></sup> in 2006. Since then, GPU acceleration has become a major factor in high performance computing and has fueled much of the recent renaissance in artificial intelligence. One of the remaining challenges when using GPU acceleration is the high degree of insight into GPU computing architecture and careful optimizations needed in order to achieve good acceleration, in spite of the abstractions that CUDA offers. A number of simulators have used GPUs to accelerate spiking neural network simulations, but the majority do not allow for easily defining new models, relying instead on a fixed set of existing models<sup><xref ref-type="bibr" rid="CR4">4</xref>–<xref ref-type="bibr" rid="CR8">8</xref></sup>. Since 2010 we have been developing the GPU enhanced neuronal networks (GeNN) framework<sup><xref ref-type="bibr" rid="CR9">9</xref></sup> that uses code generation techniques<sup><xref ref-type="bibr" rid="CR10">10</xref>,<xref ref-type="bibr" rid="CR11">11</xref></sup> to simplify the use of GPU accelerators for the simulation of spiking neural networks. GPUs, and in particular GeNN, have been shown to enable efficient simulations compared to CPUs and even compared to dedicated neuromorphic hardware<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>. Other simulators that have taken this code generation approach are Brian2CUDA<sup><xref ref-type="bibr" rid="CR13">13</xref></sup> (currently under development) and ANNarchy<sup><xref ref-type="bibr" rid="CR14">14</xref></sup> (Linux only).</p>
    <p id="Par3">Brian is a general purpose simulator for spiking neural networks written in Python, with the aim of simplifying the process of developing models<sup><xref ref-type="bibr" rid="CR15">15</xref>–<xref ref-type="bibr" rid="CR17">17</xref></sup>. Version 2 of Brian<sup><xref ref-type="bibr" rid="CR18">18</xref></sup> introduced a code generation framework<sup><xref ref-type="bibr" rid="CR10">10</xref>,<xref ref-type="bibr" rid="CR19">19</xref></sup> to allow for higher performance than was possible in pure Python. The design separates the Brian front-end (written in Python) from the back-end computational engine (multiple possibilities in different languages, including C++), and allows for the development of third party packages to add new back-ends.</p>
    <p id="Par4">Here, we introduce the Brian2GeNN software interface we have developed to allow running Brian models on a GPU via GeNN. We analysed the performance for some typical models and find that–depending on the CPU and GPU used–performance can be tens to hundreds of times faster.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <p id="Par5">We benchmarked Brian2GeNN on two model networks that we named “COBAHH” and “Mbody”. COBAHH is an implementation of a benchmark network described by Brette <italic>et al</italic>.<sup><xref ref-type="bibr" rid="CR20">20</xref></sup> (for details, see Methods). Essentially, this benchmark model consists of <italic>N</italic> Hodgkin-Huxley-type neurons, modified from the model by Traub and Miles<sup><xref ref-type="bibr" rid="CR21">21</xref></sup>, 80% of which form excitatory synapses and 20% inhibitory synapses. All neurons were connected to all other neurons randomly with a connection probability chosen such that each neuron received on average 1,000 connections for large models, or connections from all other neurons if the number of neurons was less than 1,000.</p>
    <p id="Par6">Mbody is an implementation of a previous model of the mushroom body<sup><xref ref-type="bibr" rid="CR22">22</xref></sup>, but unlike in the original publication also with a similar neuron model to the one used for the COBAHH benchmark (for details, see Methods). The model was used with 100 projection neurons, 100 extrinsic Kenyon cells and varying numbers <italic>N</italic> of intrinsic Kenyon cells (hidden layer). Projection neurons in the input layer are connected with fixed probability of 15% to intrinsic Kenyon cells. Up to <italic>N</italic> = 10,000 intrinsic Kenyon cells are connected all-to-all to the extrinsic Kenyon cells, and for <italic>N</italic> &gt; 10,000, they are connected randomly with probability chosen such that the extrinsic Kenyon cells receive input from on average 10,000 intrinsic Kenyon cells.</p>
    <p id="Par7">The COBAHH model is an example of a popular model type used for cortical microcircuits whereas the Mbody model is a typical feedforward network. COBAHH like models are used to investigate the dynamics of balanced networks and do not involve learning while the Mbody example is a prototypical model of a simple learning circuit, for instance for classification, and hence contains plastic synapses. The main audience for Brian 2 and GeNN are computational neuroscientists and we have therefore used models with conductance based neurons. The models were scaled so that the activity in the models was within sensible physiological limits, i.e. activity neither died out nor went into unrealistically high firing rates. The exact scaling and the details of the models are explained in the Methods.</p>
    <p id="Par8">Both models were integrated with an exponential Euler algorithm at 0.1 ms time steps. The benchmarks presented here were obtained using the GeNN sparse matrix representation for synaptic connections.</p>
    <p id="Par9">We benchmarked the models on different systems and with different backends. The GeNN backend through the Brian2GeNN interface presented here was compared to the “C++ standalone” backend included with the Brian simulator which runs on the CPU with either a single thread or with multiple threads via the OpenMP interface. Benchmarks were performed for both, single precision (32 bit) and double precision (64 bit) floating point. This is particularly relevant for GPUs because different GPU models have a different number of 64 bit cores, which in addition may be run at reduced clock frequencies for thermal management, and, therefore, can be between only 2× but up to 32× slower in double precision simulations than in single precision (see Table <xref rid="Tab1" ref-type="table">1</xref>).<table-wrap id="Tab1"><label>Table 1</label><caption><p>Configurations used for benchmarking.</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="3">CPU</th><th colspan="5">GPU</th></tr><tr><th># cores</th><th>Clock speed (GHz)</th><th>Memory (GB)</th><th>Architecture</th><th># cores</th><th>Memory (GB)</th><th>Performance* (single)</th><th>Performance* (double)</th></tr></thead><tbody><tr><td colspan="3"><bold>Intel Xeon E5-1630 v3</bold></td><td colspan="5"><bold>Quadro K2200</bold></td></tr><tr><td>4</td><td>3.7-3.8</td><td>16</td><td>Maxwell</td><td>640</td><td>4</td><td>1,439</td><td>45</td></tr><tr><td colspan="3"><bold>Intel Xeon E5-1620 v2</bold></td><td colspan="5"><bold>Tesla K40c</bold></td></tr><tr><td>4</td><td>3.7-3.9</td><td>32</td><td>Kepler</td><td>2,880</td><td>12</td><td>4,290</td><td>1,430</td></tr><tr><td colspan="3"><bold>Intel Core i9-7920X</bold></td><td colspan="5"><bold>TITAN Xp</bold></td></tr><tr><td>12</td><td>2.9-4.4</td><td>64</td><td>Pascal</td><td>3,840</td><td>12</td><td>12,150</td><td>380</td></tr><tr><td colspan="3"><bold>Dual Intel Xeon Gold 6148</bold></td><td colspan="5"><bold>Tesla V100</bold></td></tr><tr><td>2 × 20</td><td>2.4</td><td>192</td><td>Volta</td><td>5,120</td><td>16</td><td>14,131</td><td>7,066</td></tr></tbody></table><table-wrap-foot><p>*Maximum performance in GFLOPS.</p></table-wrap-foot></table-wrap></p>
    <p id="Par10">We recorded the overall wall clock time for the simulation including all stages from code generation and initialization in Python to C++ compilation and execution of the binary (“overall runtime”). We also took more fine-grained measurements of the time for code generation and compilation, the time spent for synapse creation and initialization, the time spent for the actual simulation and the overhead, including, e.g., time spent on reformatting data structures between Brian 2 and GeNN formats, copying to and from the GPU and writing results to disk. All simulation times that we present here are the smallest out of three simulation runs with an identical setup.</p>
    <p id="Par11">We verified that the simulation results do not depend on the simulation method that was used (single- and multi-threaded simulation on the CPU via Brian; simulation on the GPU via Brian2GeNN and GeNN). However, the simulations that were performed for the benchmark results here cannot be directly compared with each other, since synaptic connections and variable initialisation are random. When we fix these connections and initialisations to be identical across runs, we do get highly reproducible simulation results: in a test recording all the spikes in a COBAHH network with 16,000 neurons over 10 s, all simulations with double precision gave exactly the same results, i.e. all spikes fell into identical time steps for all neurons. When using single precision, small numerical discrepancies (e.g. due to differences in the order of summations) added up and led to minor spike timing discrepancies between simulations on the CPU and the GPU. However, all neurons emitted the exact same number of spikes, the discrepancies were almost exclusively restricted to spikes occurring a single time step earlier or later; only 9 out of 16,000 neurons (i.e., 0.06%) had any spikes shifted by more than a single time step. For the Mbody benchmark, all simulations were completely identical across CPU- and GPU-based simulations in a test with 160,200 neurons over 1 s, both for single and double precision. Note that in general, numerical simulations performed on different platforms cannot be expected to always give results that are identical on a spike-by-spike basis, especially in recurrent networks. Validating simulation results across different technical approaches therefore requires comparing more global measures such as firing and correlation statistics<sup><xref ref-type="bibr" rid="CR23">23</xref></sup>. A validation of this type has been performed previously for the GeNN simulator<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>.</p>
    <sec id="Sec3">
      <title>Simulation time</title>
      <p id="Par12">The results for the net simulation time for the two models on CPU and the TITAN Xp and Tesla V100 GPUs are shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref> as a function of the size of the models, indicated by the total number of neurons. GeNN offers two different strategies for parallelising the spike propagation logic, along pre-synaptic inputs (looping over post-synaptic targets) or along post-synaptic targets (looping over pre-synaptic sources). We benchmarked both algorithms for each of the models.<fig id="Fig1"><label>Figure 1</label><caption><p>Benchmark of the net simulation time on a 12 core CPU with a single thread (dark gray) or using OpenMP with 24 threads (light gray), compared to a consumer GPU (TITAN Xp) and an HPC model (Tesla V100). For the GPUs, simulation times are displayed separately for a pre-synaptic parallelisation strategy (dotted) or post-synaptic strategy (dashed). The better of the two strategies is highlighted by a solid line.</p></caption><graphic xlink:href="41598_2019_54957_Fig1_HTML" id="d29e563"/></fig></p>
      <p id="Par13">The single thread CPU solution scales essentially linearly with the size of the two models, expressed in terms of the number of simulated neurons (Fig. <xref rid="Fig1" ref-type="fig">1</xref>). This reflects the linear scaling of processing time with the number of operations required and that both models are essentially neuron-bound on the CPU due to their computationally expensive neuron model, their chosen connectivity and the observed number of spikes. The 24-thread OpenMP simulations take initially the same time for very small models but we found that the simulations ran about 13–14 times faster than on a single CPU core for the largest MBody model tested on a single CPU core (160,200 neurons) and 8–11 times faster for the largest COBAHH model tested on a single CPU core (256,000 neurons). Larger models were only tested on 24-thread OpenMP and GPUs due to the prohibitively long runtime on a single CPU core. For models larger than 40,200 neurons (Mbody) and 8,000 neurons (COBAHH), the 24 thread OpenMP solution also scales approximately linearly with the number of neurons.</p>
      <p id="Par14">The simulations run on the GPU via Brian2GeNN (green and purple lines in Fig. <xref rid="Fig1" ref-type="fig">1</xref>) were significantly faster than the 24 thread OpenMP (light gray), for instance, 40–54 times faster in the Mbody model for 10,240,200 neurons and up to 24–26 times faster in the COBAHH model for 1,024,000 neurons when using the Tesla V100 GPU. We have summarised the observed speed-ups achieved for the simulation time in Table <xref rid="Tab2" ref-type="table">2</xref><table-wrap id="Tab2"><label>Table 2</label><caption><p>Speed-up on GPUs.</p></caption><table frame="hsides" rules="groups"><thead><tr><th colspan="13">Mbody benchmark</th></tr><tr><th/><th colspan="6"><italic>compared to CPU 1 thread</italic></th><th colspan="6"><italic>compared to CPU 24 thread</italic></th></tr></thead><tbody><tr><td><bold># neurons</bold></td><td colspan="2">40,200</td><td colspan="2">80,200</td><td colspan="2">160,200</td><td colspan="2">40,200</td><td colspan="2">160,200</td><td colspan="2">10,240,200</td></tr><tr><td>Quadro K2200</td><td><italic>39.2</italic></td><td><underline>6.5</underline></td><td><italic>52.0</italic></td><td>6.7</td><td><italic>60.7</italic></td><td>7.0</td><td><italic>3.3</italic></td><td>0.6</td><td><italic>4.3</italic></td><td><underline>0.5</underline></td><td><italic>4.3</italic></td><td><underline>0.5</underline></td></tr><tr><td>Tesla K40c</td><td><italic>34.7</italic></td><td>25.6</td><td><italic>58.8</italic></td><td>39.8</td><td><italic>80.9</italic></td><td>53.8</td><td><italic>2.9</italic></td><td>2.4</td><td><italic>5.7</italic></td><td>4.2</td><td><italic>7.1</italic></td><td>5.8</td></tr><tr><td>Titan Xp</td><td><italic>101.9</italic></td><td>39.4</td><td><italic>190.3</italic></td><td>51.4</td><td><italic>300.3</italic></td><td>60.9</td><td><italic>8.5</italic></td><td>3.7</td><td><italic>21.1</italic></td><td>4.8</td><td><italic>31.0</italic></td><td>5.0</td></tr><tr><td>Tesla V100</td><td><italic>124.3</italic></td><td>105.9</td><td><italic>235.5</italic></td><td>191.7</td><td><italic><underline>401.6</underline></italic></td><td>251.7</td><td>10.4</td><td>9.9</td><td>28.3</td><td>19.7</td><td><italic><underline>53.9</underline></italic></td><td>40.4</td></tr><tr><td colspan="13"><bold>COBAHH benchmark</bold></td></tr><tr><td><bold># neurons</bold></td><td colspan="2">64,000</td><td colspan="2">128,000</td><td colspan="2">256,000</td><td colspan="2">64,000</td><td colspan="2">256,000</td><td colspan="2">10,24,000</td></tr><tr><td>Quadro K2200</td><td><italic>18.0</italic></td><td>4.9</td><td><italic>24.2</italic></td><td>4.5</td><td><italic>13.6</italic></td><td><underline>4.1</underline></td><td><italic>1.7</italic></td><td>0.6</td><td><italic>1.3</italic></td><td><underline>0.5</underline></td><td>–</td><td>–</td></tr><tr><td>Tesla K40c</td><td><italic>20.6</italic></td><td>16.3</td><td><italic>11.7</italic></td><td>9.4</td><td><italic>16.7</italic></td><td>8.6</td><td><italic>1.9</italic></td><td>1.9</td><td><italic>1.6</italic></td><td>1.1</td><td><italic>1.0</italic></td><td>–</td></tr><tr><td>Titan Xp</td><td><italic>57.7</italic></td><td>29.1</td><td><italic>40.3</italic></td><td>22.2</td><td><italic>73.8</italic></td><td>33.7</td><td><italic>5.4</italic></td><td>3.4</td><td><italic>7.2</italic></td><td>4.1</td><td><italic>16.9</italic></td><td>6.5</td></tr><tr><td>Tesla V100</td><td><italic><underline>207.7</underline></italic></td><td>155.7</td><td><italic>196.5</italic></td><td>134.4</td><td><italic>154.1</italic></td><td>113.5</td><td><italic>19.6</italic></td><td>18.3</td><td><italic>15.0</italic></td><td>13.9</td><td><italic><underline>26.3</underline></italic></td><td>24.2</td></tr></tbody></table><table-wrap-foot><p>This only considers simulation time. Numbers are relative to simulations on the host of the Titan Xp GPU (see Table <xref rid="Tab1" ref-type="table">1</xref>) and compare to a single-thread simulation (left) or a 24-thread OpenMP simulation (right). The two numbers shown are for single precision (italic) and double precision (normal font). The underlined numbers are the highest and lowest observed speed-ups for each of the four quadrants of the table.</p></table-wrap-foot></table-wrap>. Overall the GPU runs always faster than a single threaded CPU version, up to a factor of 400, but when compared against the 24 thread OpenMP version, acceleration can vary from 2× slower than the CPU to about 50× faster.</p>
      <p id="Par15">Interestingly, the different parallelisation methods for spike propagation available in GeNN (dashed and dotted lines in Fig. <xref rid="Fig1" ref-type="fig">1</xref>) perform differently as a function of size. The post-synaptic method is always faster for small models while the pre-synaptic method wins for very large models. This trend is the same for both tested models, but the exact crossover point where pre-synaptic parallelisation becomes more efficient depends on the model, and to a lesser degree on the GPU hardware. For the Mbody example, the swap occurs at moderate model sizes of about 40200 neurons, whereas for the COBAHH model, it is for much larger models (128,000 neurons for the TITAN Xp and 512,000 neurons for the Tesla V100). Also, while the differences of the two methods are not that pronounced for the large Mbody models, the post-synaptic method in the COBAHH model scales very poorly with size at large model sizes, leading to quite low performance of Brian2GeNN in this mode. The pre-synaptic method, on the contrary, is not particularly fast for smaller to medium sized COBAHH models (even slower than the 24 thread OpenMP version), but scales excellently for the largest models, leading to significant speedups over OpenMP.</p>
      <p id="Par16">The general trend of the post-synaptic method being faster for small models and the pre-synaptic method for large models can be understood based on how these methods work and based on the scaling method of the benchmark models. In the post-synaptic parallelisation method, each post-synaptic neuron occupies its own thread and there is a loop over incoming spikes. This is efficient when there are many post-synaptic neurons and few incoming spikes. In contrast, in the pre-synaptic method, each emitted spike is processed in a separate thread, and there is a loop over the affected post-synaptic neurons. This method is better if there are many spikes and few or a moderate number of post-synaptic targets. In both models, the number of post-synaptic targets during scaling is constant (or capped for the iKCeKC synapses), but the number of spikes grows with the size of the model. In small models, there are few spikes and relative to the small spike number many post-synaptic targets - the post-synaptic method is better. For much larger models, there are many more spikes but roughly the same number of post-synaptic targets for each spike, so the pre-synaptic method becomes better. When, however, the exact crossover between the methods occurs, is hard to predict and can also depend on the GPU and the details of how the connectivity and the activity in the models scale.</p>
      <p id="Par17">The simulation times for a larger variety of different GPU hardwares are shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. Note that we here display the results for the better of the two parallelisation strategies for each model run. We benchmarked four different graphics cards (see Table <xref rid="Tab1" ref-type="table">1</xref>). The results show consistent trends given the specifications of the hardware (Table <xref rid="Tab1" ref-type="table">1</xref>), even though some may not be as obvious as others. The Tesla V100 is almost always fastest, typically followed by the TITAN Xp, Tesla K40c and Quadro K2200 card in this order. Note however, the marked difference in double precision performance for the consumer cards (Quadro K2200 and TITAN Xp), compared to the high performance computing cards (Tesla K40c and Tesla V100): In Fig. <xref rid="Fig2" ref-type="fig">2</xref>, the blue and green lines are at markedly higher values on the left plots than on the right, while the orange and purple lines barely change between single and double precision plots. This is expected because the consumer cards have NVIDIA GPU architectures (Maxwell respectively Pascal) that have fewer double precision cores and double precision operations are hence up to 32 times slower than single precision, while the HPC cards used here are Kepler and Volta architecture and have only a factor 2 performance difference between double precision and single precision operations. Accordingly, while in single precision, the presumably less powerful but more recent Quadro K2200 card performs at the level of or even better than the older but larger Tesla K40c accelerator, it does not compare favourably for double precision.<fig id="Fig2"><label>Figure 2</label><caption><p>Benchmarking of the net simulation time for different GPU models. Measurements were taken separately for the MBody model (top) and COBAHH model (bottom) for double precision floating point (left) and single precision (right). Simulation time is shown relative to the simulated biological time (10 s). CPU performance was measured on the host of the TITAN Xp GPU (see Table <xref rid="Tab1" ref-type="table">1</xref>). For the GPUs, the better (smaller) of the simulation times for either pre-synaptic or post-synaptic parallelisation strategy are shown; circles mark the simulations where the pre-synaptic strategy was faster, and squares those where the post-synaptic strategy was faster. See Fig. <xref rid="Fig1" ref-type="fig">1</xref> and main text for more in-depth explanation.</p></caption><graphic xlink:href="41598_2019_54957_Fig2_HTML" id="d29e1085"/></fig></p>
      <p id="Par18">Comparing the two models, it is clear that the performance gains of Brian2GeNN on the different GPU platforms is more marked for the Mbody model than for the COBAHH model. This would be expected for the spike propagation code because the mainly feedforward structure of the Mbody model lends itself better to parallelisation on GPUs with GeNN than the randomly recurrently connected COBAHH model. It should be noted that spike propagation is the most challenging aspect of running neural network simulations on GPUs<sup><xref ref-type="bibr" rid="CR24">24</xref></sup>, and it typically takes up a larger share of the total computation time compared to simulations on CPUs. We can see this pattern in the examples presented here (executed on the Intel Core i9-7920X CPU with a Titan Xp GPU): in a single precision simulation of the COBAHH model with 512,000 neurons, the synaptic propagation takes up 47% of the time when run on the CPU (24threads), but 82% when run on the GPU; in a simulation of the Mbody model with 10,240,200 neurons, synaptic propagation, including updates of the plastic synapses, takes up only 1–2% of the time on the CPU but 20% on the GPU.</p>
    </sec>
    <sec id="Sec4">
      <title>Time for other tasks</title>
      <p id="Par19">So far we have presented results for the core simulation time. As explained in the methods, Brian2GeNN has a substantial pipeline of tasks before and after the main simulation takes place. Figure <xref rid="Fig3" ref-type="fig">3</xref> illustrates the essence of how the computation times along this pipeline stack up. We defined four main phases of a Brian2GeNN run: “code generation and compilation”, “synapse creation”, “main simulation” and “overheads”, which bundles smaller tasks such as transforming data formats between Brian 2 format and GeNN format, copying from and to the GPU and writing results to disk. For illustration we have used the data from the TITAN Xp card and Intel Core i9-7920X CPU. The data in the top two panels in Fig. <xref rid="Fig3" ref-type="fig">3</xref> repeats the results for the simulation time but also shows extrapolations for shorter and longer runs, where computation times are strictly proportional to the length of simulated biological time. This phase is almost entirely determined by the GPU model. The bottom two panels show the compute time spent on the other three phases, which are determined by the CPU and the CPU-GPU bandwidth (for copying data to the GPU). Code generation and compilation is a fixed cost that is completely independent of the model size. On the contrary, computation time for synapse creation and initialisation increases linearly with model size in terms of the number of neurons. The other overheads are initially almost independent of model size but then also start increasing with the number of neurons. In the balance, for small to mid-sized models and short simulation runs (1 s biological time), code generation and compilation dominates the overall runtime whereas for large models and longer runs, the time for the main simulation dominates.<fig id="Fig3"><label>Figure 3</label><caption><p>Overview of the components that make up the total runtime of a simulation for the Mbody (left) and the COBAHH benchmark (right). The top panels show the time spent in the simulation itself which scales with the biological runtime of the model (shown at the right) and dominates the overall runtime for big networks and/or long simulations. Simulation times were measured for biological runtimes of 10 s (middle line), while the times for runs of 1 s (bottom line) and 100 s (top line) were extrapolated. The bottom panels show the time spent for code generation and compilation (blue), general overhead such as copying data between the CPU and the GPU (orange), and the time for synapse creation and the initialization of state variables before the start of the simulation (green). The details shown here are for single-precision simulations run on the Titan Xp GPU.</p></caption><graphic xlink:href="41598_2019_54957_Fig3_HTML" id="d29e1111"/></fig></p>
      <p id="Par20">To give a rough guide at which amount of biological time for any given model size it becomes viable to use Brian2GeNN we have calculated the minimum simulated biological time for which the overall runtime for Brian2GeNN is smaller than a 24 thread OpenMP solution (Fig. <xref rid="Fig4" ref-type="fig">4</xref>). For simulated biological time of 100 s or more it is always faster to use Brian2GeNN, regardless of model size or employed GPU accelerator. For shorter simulated time it depends on the simulated model and the GPU. For example, simulating 10 s biological time is perfectly viable on a Tesla V100 for the Mbody model at size 40,200 but would be slower on a Tesla K40c; or, simulating 10 s biological time would not be viable for any of the tested GPUs for the COBAHH model at size 8,000 but viable on all of them at size 64,000.<fig id="Fig4"><label>Figure 4</label><caption><p>Minimal biological runtime after which the total simulation time, including preparations such as code generation and compilation (cf. Fig. <xref rid="Fig3" ref-type="fig">3</xref>), is smaller when using a GPU compared to 24 threads on a CPU, for networks of different sizes. This data was calculated from benchmark results as displayed in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. The CPU comparison is the host of the Titan Xp GPU (see Table <xref rid="Tab1" ref-type="table">1</xref>). Results for the Mbody benchmark (left) and the COBAHH benchmark (right). The calculations are based on single precision performance for the Quadro GPU (blue) and Titan Xp GPU (green), and on double precision performance for the Tesla K40c (orange) and the Tesla V100 GPU (purple).</p></caption><graphic xlink:href="41598_2019_54957_Fig4_HTML" id="d29e1134"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec5" sec-type="discussion">
    <title>Discussion</title>
    <p id="Par21">In designing software for computational neuroscience, there are two seemingly conflicting requirements: for high performance and for flexibility. The ability to create new types of models is essential for research that goes beyond what is already known at the time that a simulator package is created. However, hand written code that implements particular models can be much more computationally efficient. This is particularly true in the case of GPU simulations, as it is difficult to make maximally efficient use of GPU resources. Consequently, almost all GPU-based simulators for spiking neural networks have not made it possible to easily create new user-defined neuron models<sup><xref ref-type="bibr" rid="CR4">4</xref>–<xref ref-type="bibr" rid="CR8">8</xref></sup>. The exceptions are GeNN, the package Brian2CUDA<sup><xref ref-type="bibr" rid="CR13">13</xref></sup> currently under development, and ANNarchy<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>, which is discussed below.</p>
    <p id="Par22">The technique of code generation allows us to solve this apparent conflict, and has been used by both the GeNN and Brian simulators<sup><xref ref-type="bibr" rid="CR9">9</xref>,<xref ref-type="bibr" rid="CR10">10</xref>,<xref ref-type="bibr" rid="CR19">19</xref></sup> as well as a number of other neural simulators<sup><xref ref-type="bibr" rid="CR11">11</xref></sup>. In the case of GeNN, when writing a new model users need to write only a very small section of generic C++ code that defines how the variables of a neuron model are updated, and this is then inserted into a detailed template that allows that model to be simulated efficiently on a GPU. Brian meanwhile allows users to write their model definition at an even higher level, as standard mathematical equations in a Python script. These are then automatically converted into low-level C++ code to be compiled and executed on a CPU. In both cases, users write high level code (short snippets of C++ in the case of GeNN, or Python/mathematics in the case of Brian) and efficient low level code is automatically generated.</p>
    <p id="Par23">Linking Brian and GeNN accomplishes two tasks. Firstly, it allows existing Brian users to make use of a GPU to run their simulations without any technical knowledge of GPUs (via GeNN). Secondly, it gives GeNN users a high level and feature packed interface (Brian and Python) to manage their simulations. GeNN was originally designed to be used at the C++ level, with network setup and simulation management handled by the user in C++, but not all computational neuroscientists are comfortable working at this level and there can be considerable savings in development time working at a higher level.</p>
    <p id="Par24">The only other spiking neural network simulation package to allow for flexible model definition in a high level language, and for code to run on GPUs, is ANNarchy<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>. This simulator was originally designed to adapt a model definition syntax similar to Brian’s to rate-coded networks (rather than spiking neural networks), and to make use of GPUs for high performance. It has subsequently been updated to allow for the definition of spiking neural networks as well as hybrid networks, and simulating spiking networks on the GPU is now provided as an experimental feature. In contrast to Brian2GeNN which supports all major operating systems, ANNarchy only supports running simulations on the GPU on Linux.</p>
    <p id="Par25">As noted in<sup><xref ref-type="bibr" rid="CR24">24</xref></sup>, on GPUs it is unlikely that there is a single best algorithm for spiking neural network simulation, but rather the best algorithm will depend on the model. A diversity of GPU spiking neural network simulator packages is therefore desirable.</p>
    <p id="Par26">Brian’s framework for defining models of neurons, synapses, networks and computational experiments is designed to be as expressive and flexible as possible. Consequently, not all features of Brian are available in GeNN, and not all simulations that can be run in GeNN will run efficiently. Among the most important currently unsupported features are continuous, i.e. not spike-based, connections (used for example to implement electrical synapses); heterogeneous, i.e. synapse-specific, synaptic delays; arbitrary, time-varying continuous stimuli; and complex simulation schedules (for example, multiple simulation runs or different simulation time steps for individual groups of neurons/synapses). Attempting to use an unsupported Brian feature with Brian2GeNN will simply raise an error.</p>
    <p id="Par27">However, some features that are supported may also lead to slow code on the GPU. This is because efficient use of the GPU requires appropriate paralellisation strategies and specific memory access patterns, and for some features (particularly relating to backpropagation of information in synapses) it is very difficult to arrange data in memory so that it can be accessed efficiently for both, forward and backward propagation on the GPU<sup><xref ref-type="bibr" rid="CR24">24</xref></sup>. The very different scaling of runtimes in the COBAHH example for pre- and post-synaptic parallelisation strategies for synaptic updates in large model instances, as seen in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, is a very typical example of such phenomena. However, it is not straightforward to predict when problems of this kind will be significant. The Mbody example has STDP but because it is otherwise well suited for GeNN due to essentially feedforward connectivity for the majority of synapses and sparse firing, it speeds up well in Brian2GeNN. The COBAHH example does not have plasticity and yet, due to its relatively dense, random connectivity and somewhat higher firing rates, the speedups are good but less pronounced than in the Mbody example. Ideally, one would like to be able to predict the likelihood and magnitude of an expected speedup for a given model on a given GPU but this is a notoriously difficult problem<sup><xref ref-type="bibr" rid="CR24">24</xref></sup>. We therefore encourage users to simply try Brian2GeNN on their script, which can be done by adding just two lines to their script importing brian2genn and selecting the ‘genn’ device.</p>
    <p id="Par28">A general limitation of running simulations on GPU rather than CPU is memory, as GPUs typically have much less available memory. At the time of writing, the largest memory available on a GPU is 32GB on the extremely expensive V100, while consumer cards have less than 12GB. Available RAM typically limits maximum simulation size due to synaptic weight matrices (very close to 8 bytes per synapse for single precision or 12 bytes per synapse for double precision). For example, the COBAHH simulation at the largest sizes has around 60–70 times as many synapses as the Mbody simulation, meaning that maximum simulation sizes (as measured by the number of neurons) for the Mbody simulation are larger than for COBAHH (Fig. <xref rid="Fig2" ref-type="fig">2</xref>).</p>
    <p id="Par29">Further work on Brian and GeNN will go in two main directions. On the GeNN side, we plan to expand the features available in GeNN to cover more of the features available in Brian, as well as improving efficiency. A specific bottleneck that has been recently identified is the synapse creation task (see Fig. <xref rid="Fig3" ref-type="fig">3</xref>). Work is under way that enables synapse creation on the GPU instead of the CPU with considerable performance advantages, in particular where synaptic connectivity becomes more intricate.</p>
    <p id="Par30">On the Brian side, we plan to simplify and optimise the process of writing third party back-ends. This will not only simplify future development of Brian2GeNN but will also encourage the development of an ecosystem of back-ends, for example featuring different GPU algorithms or targeting different computational hardware such as field programmable gate arrays (FPGAs). An interface to generate CUDA code directly from a Brian script, called Brian2CUDA<sup><xref ref-type="bibr" rid="CR13">13</xref></sup>, is also under development, but has not yet been released. Note that Brian2CUDA uses different data structures and algorithms than GeNN, and Brian, Brian2CUDA and GeNN are all developed by independent teams, and it is therefore likely that both GeNN and Brian2CUDA will be useful for different modelling requirements.</p>
    <p id="Par31">For Brian2GeNN itself, we are planning to expose more of the optimisation choices offered to direct users of GeNN to Brian2GeNN users, for instance per-synapse group choices for connectivity matrix representations (sparse, dense, ragged, bitmask) and parallelisation strategies (pre- or post-synaptic). We will also work on exposing the emerging on-GPU initialisation methods mentioned above and the heterogeneous synaptic delays that were recently introduced to GeNN.</p>
  </sec>
  <sec id="Sec6">
    <title>Methods</title>
    <sec id="Sec7">
      <title>Brian2GeNN</title>
      <p id="Par32">Brian2GeNN makes use of the existing code generation facilities in the Brian and GeNN simulators. These code generation facilities differ in important aspects. The Brian simulator provides a comprehensive code generation framework that converts not only high-level descriptions of neural and synaptic models to executable code, but also extends this framework to model initialization including the generation of synapses according to high-level rules. In addition, the user code is written in Python, a language that is very accessible to researchers with a less technical background. However, the generated code is C++ code that runs only on the CPU, and therefore cannot make use of the computational power of GPU accelerators. GeNN’s code generation framework on the other hand is focused more on organizing the code to run efficiently on highly parallel GPUs, leaving the task of defining the code for simulating the neural and synaptic model, and the details of how to run the overall simulation to the user. This is completed in C++, which allows tight integration with other C++ based code, e.g. in the context of robotic controllers, but also makes writing a GeNN simulation relatively difficult for inexperienced programmers. The major advantage of using GeNN is its ability to generate efficient CUDA code that can be executed on a GPU to accelerate simulations.</p>
      <p id="Par33">Brian2GeNN acts as a “glue” between Brian and GeNN, thereby combining the advantages of both simulators. It is built as an extension of Brian’s code generation mechanism and can therefore be directly used from within a Brian script; by choosing the “GeNN device” (lines 2–3, Fig. <xref rid="Fig5" ref-type="fig">5</xref> top), a standard Brian simulation is turned into a hybrid Brian/GeNN simulation. Such a script typically sets up the simulation components and then triggers the simulation of the network (Fig. <xref rid="Fig5" ref-type="fig">5</xref> top and bottom left). At this point, the code generation process is activated and generates, compiles and executes the target code. The results of this simulation are then written to disk by the executed code, enabling the Python code to access the requested results to analyze or plot them. The executable code (Fig. <xref rid="Fig5" ref-type="fig">5</xref> bottom right) is jointly generated by Brian (blue boxes), Brian2GeNN (green boxes/arrows), and GeNN (red box) and executed partly on the CPU and partly on the GPU. The initial steps, synapse creation and model initialization, are unchanged from Brian’s default code generation process. However, since Brian and GeNN use different data structures to represent synapses, Brian2GeNN has to generate code to convert between the two formats. In addition, it copies all the data to the GPU so that it can be used during the simulation run. The main simulation loop delegates the core of the simulation, the dynamic update of neural and synaptic state variables as well as the propagation of synaptic events, to the code generated by the GeNN simulator, which executes on the GPU. After each time step, some of this data may be copied back from the GPU and converted to the Brian format so that it can be recorded by Brian’s monitoring mechanism. After the end of the simulation run, Brian2GeNN takes care to copy all data back from the GPU and to convert it to the Brian format, so that Brian can store the results to disk and make them available for analysis in the Python script.<fig id="Fig5"><label>Figure 5</label><caption><p>Running simulations with Brian2GeNN. Top: Excerpt from an example Brian script that will execute in a hybrid Brian/GeNN simulation due to the import of the brian2genn library (line 2) and the selection of the “GeNN device” (line 3). Bottom left: Typical workflow of a Brian2GeNN simulation: the run call triggers the code generation, compilation and execution. After the successful run, results are stored to disk and made available to the Python script. Numbers refer to the corresponding lines in the example code on top. Bottom right: Structure of generated code. Parts of the code result from Brian’s standard code generation process (blue), while the main run step is implemented by GeNN (red) and everything is connected together by Brian2GeNN (green). The preparation of the simulation and actions such as variable monitoring are executed on the CPU (left), while the core of the simulation is executed on the GPU (right). The numbers in the boxes refer to the elements of the example code (top) and general schematic (bottom left) which are the base for the code of the corresponding block. For example, the “run step”, i.e. the advancement of the state variables of neurons and synapses at every time step, is based on the definitions of the neuron and synapse models in (1) and (2).</p></caption><graphic xlink:href="41598_2019_54957_Fig5_HTML" id="d29e1246"/></fig></p>
    </sec>
    <sec id="Sec8">
      <title>Benchmark models</title>
      <p id="Par34">We benchmarked Brian2GeNN on two models, named COBAHH and Mbody.</p>
      <sec id="Sec9">
        <title>COBAHH model</title>
        <p id="Par35">The COBAHH model is a model frequently used in simulations of cortical structures and consists of two populations (Fig. <xref rid="Fig6" ref-type="fig">6a</xref>), a population of 0.8·<italic>N</italic> excitatory neurons and 0.2·<italic>N</italic> inhibitory neurons, where <italic>N</italic> denotes the total number of neurons, which was scaled from 200 to 1,024,000. Each pair of neurons is connected by a synapse with fixed probability <italic>p</italic> = 1,000/<italic>N</italic> (i.e., pairwise Bernoulli-distributed, potentially including self-connections), so that on average each neuron receives 1,000 inputs, regardless of scaling. For <italic>N</italic> &lt; 1,000, <italic>p</italic> is set to 1, i.e. the network is all-to-all connected. Synapses are modeled as conductance based synapses,<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${I}_{{\rm{syn}}}={g}_{E}({V}_{E}-{V}_{{\rm{post}}})+{g}_{I}({V}_{I}-{V}_{{\rm{post}}})$$\end{document}</tex-math><mml:math id="M2" display="block"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">syn</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">post</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">post</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\frac{d{g}_{E}}{dt}=-\frac{{g}_{E}}{{\tau }_{E}}+{w}_{E}\sum _{i}\,\delta (t-{t}_{i})$$\end{document}</tex-math><mml:math id="M4" display="block"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder></mml:mrow><mml:mspace width=".25em"/><mml:mi>δ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\frac{d{g}_{I}}{dt}=-\frac{{g}_{I}}{{\tau }_{I}}+{w}_{I}\sum _{i}\,\delta (t-{t}_{i})$$\end{document}</tex-math><mml:math id="M6" display="block"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder></mml:mrow><mml:mspace width=".25em"/><mml:mi>δ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>where <italic>g</italic><sub><italic>E</italic></sub> is the conductance of the synapse at time <italic>t</italic>, <italic>w</italic><sub><italic>E</italic></sub> is the “weight” of the synapse, <italic>τ</italic><sub><italic>E</italic></sub> = 5 ms is the timescale of synaptic PSCs, <italic>V</italic><sub><italic>E</italic></sub> = 0 mV is the reversal potential and <italic>t</italic><sub><italic>i</italic></sub> denotes the spike times of the pre-synaptic neuron. The sum is over all pre-synaptic spikes and <italic>δ</italic> represents the Dirac <italic>δ</italic> distribution. The symbols are analogous for the inhibitory synapses with values <italic>τ</italic><sub><italic>I</italic></sub> = 10 ms and <italic>V</italic><sub><italic>I</italic></sub> = −80 mV. The weights for synapses were chosen as <italic>w</italic><sub><italic>E</italic></sub>,<italic>w</italic><sub><italic>I</italic></sub> = <italic>ω</italic>·10<sup>−9</sup> nS, where <inline-formula id="IEq1"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\omega  \sim U\mathrm{([0,1])}$$\end{document}</tex-math><mml:math id="M8"><mml:mi>ω</mml:mi><mml:mo>~</mml:mo><mml:mi>U</mml:mi><mml:mn>([0,1])</mml:mn></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq1.gif"/></alternatives></inline-formula> is a uniformly distributed random variable on the interval [0,1] and the synaptic conductances were initialized independently according to the following normal distributions: <inline-formula id="IEq2"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${g}_{E} \sim N\mathrm{(40}\,{\rm{nS}}\mathrm{,(15}\,{\rm{nS}}\,{)}^{2})$$\end{document}</tex-math><mml:math id="M10"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>E</mml:mi></mml:mrow></mml:msub><mml:mo>~</mml:mo><mml:mi>N</mml:mi><mml:mn>(40</mml:mn><mml:mspace width=".1em"/><mml:mi mathvariant="normal">nS</mml:mi><mml:mn>,(15</mml:mn><mml:mspace width=".25em"/><mml:mi mathvariant="normal">nS</mml:mi><mml:mspace width=".1em"/><mml:msup><mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq2.gif"/></alternatives></inline-formula> and <inline-formula id="IEq3"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${g}_{I} \sim N\mathrm{(200}\,{\rm{nS}}\,,\,{\mathrm{(120}{\rm{nS}})}^{2})$$\end{document}</tex-math><mml:math id="M12"><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub><mml:mo>~</mml:mo><mml:mi>N</mml:mi><mml:mn>(200</mml:mn><mml:mspace width=".25em"/><mml:mi mathvariant="normal">nS</mml:mi><mml:mspace width=".1em"/><mml:mo>,</mml:mo><mml:mspace width=".25em"/><mml:msup><mml:mrow><mml:mn>(120</mml:mn><mml:mspace width=".25em"/><mml:mi mathvariant="normal">nS</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq3.gif"/></alternatives></inline-formula>. Note that there is no substantial effect of the recurrent synapses due to the very low weight values <italic>w</italic><sub><italic>E</italic></sub> and <italic>w</italic><sub><italic>I</italic></sub>. This has been done on purpose, so that scaling the network does not affect the network activity. However, since the values are non-zero, the simulations still include all the computations to propagate the synaptic activity and are therefore representative for benchmarking purposes.<fig id="Fig6"><label>Figure 6</label><caption><p>Diagrams of the two benchmark models, COBAHH (<bold>a</bold>) and Mbody (<bold>b</bold>). The COBAHH model is fully recurrent, whereas the Mbody model is essentially feedforward with exception of some all-to-all inhibition among the 100 eKCs.</p></caption><graphic xlink:href="41598_2019_54957_Fig6_HTML" id="d29e1714"/></fig></p>
        <p id="Par36">Neurons were modeled by Hodgkin-Huxley type conductance based model equations,<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${C}_{M}\frac{dV}{dt}={g}_{L}({V}_{L}-V)+{g}_{{\rm{Na}}}{m}^{3}h({V}_{{\rm{Na}}}-V)+{g}_{{\rm{K}}}{n}^{4}({V}_{{\rm{K}}}-V)+{I}_{{\rm{syn}}}$$\end{document}</tex-math><mml:math id="M14" display="block"><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Na</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">Na</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">K</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">K</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">syn</mml:mi></mml:mrow></mml:msub></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula>where <italic>C</italic><sub><italic>M</italic></sub> = 0.2 nF is the membrane capacitance, <italic>g</italic><sub><italic>L</italic></sub> = 10 nS, <italic>g</italic><sub>Na</sub> = 20 μS, <italic>g</italic><sub>K</sub> = 6 μS are the maximal conductances, <italic>V</italic><sub><italic>L</italic></sub> = −60 mV, <italic>V</italic><sub>Na</sub> = 50 mV and <italic>V</italic><sub>K</sub> = −90 mV the reversal potentials and the activation variables have dynamic equations of the form<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\frac{dx}{dt}={\alpha }_{x}\mathrm{(1}-x)-{\beta }_{x}x$$\end{document}</tex-math><mml:math id="M16" display="block"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mn>(1</mml:mn><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mi>x</mml:mi></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>where <italic>x</italic> = <italic>m</italic>, <italic>h</italic>, or <italic>n</italic>. The rate curves <italic>α</italic><sub><italic>x</italic></sub> and <italic>β</italic><sub><italic>x</italic></sub> are summarised in Table <xref rid="Tab3" ref-type="table">3</xref>.<table-wrap id="Tab3"><label>Table 3</label><caption><p>Activation and inactivation rate curves as functions of <italic>v</italic> = <italic>V</italic>/[mV].</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Variable</th><th><italic>α</italic> [kHz]</th><th><italic>β</italic> [kHz]</th></tr></thead><tbody><tr><td><italic>m</italic></td><td><inline-formula id="IEq4"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\displaystyle {\alpha }_{m}=0.32\frac{-50-v}{{e}^{\frac{-50-v}{4}}-1}$$\end{document}</tex-math><mml:math id="M18"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.32</mml:mn><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>50</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>50</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq4.gif"/></alternatives></inline-formula></td><td><inline-formula id="IEq5"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\displaystyle {\beta }_{m}=0.28\frac{23+v}{{e}^{\frac{23+v}{5}}-1}$$\end{document}</tex-math><mml:math id="M20"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.28</mml:mn><mml:mfrac><mml:mrow><mml:mn>23</mml:mn><mml:mo>+</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>23</mml:mn><mml:mo>+</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq5.gif"/></alternatives></inline-formula></td></tr><tr><td><italic>h</italic></td><td><inline-formula id="IEq6"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\displaystyle {\alpha }_{h}=0.128{e}^{\frac{-46-v}{18}}$$\end{document}</tex-math><mml:math id="M22"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.128</mml:mn><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>46</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mn>18</mml:mn></mml:mfrac></mml:mrow></mml:msup></mml:mstyle></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq6.gif"/></alternatives></inline-formula></td><td><inline-formula id="IEq7"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\displaystyle {\beta }_{h}=\frac{4}{1+{e}^{\frac{-23-v}{5}}}$$\end{document}</tex-math><mml:math id="M24"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>4</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>23</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mstyle></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq7.gif"/></alternatives></inline-formula></td></tr><tr><td><italic>n</italic></td><td><inline-formula id="IEq8"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\displaystyle {\alpha }_{n}=0.032\frac{-48-v}{{e}^{\frac{-48-v}{5}}-1}$$\end{document}</tex-math><mml:math id="M26"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.032</mml:mn><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>48</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>48</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:mfrac></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq8.gif"/></alternatives></inline-formula></td><td><inline-formula id="IEq9"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\displaystyle {\beta }_{n}=0.5{e}^{\frac{-53-v}{40}}$$\end{document}</tex-math><mml:math id="M28"><mml:mstyle displaystyle="true" scriptlevel="0"><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>53</mml:mn><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mn>40</mml:mn></mml:mfrac></mml:mrow></mml:msup></mml:mstyle></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq9.gif"/></alternatives></inline-formula></td></tr></tbody></table></table-wrap></p>
        <p id="Par37">Membrane potentials were initialized independently as <inline-formula id="IEq10"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$V\mathrm{(0)} \sim N({V}_{L}-5\,{\rm{mV}},{\mathrm{(5}{\rm{mV}})}^{2})$$\end{document}</tex-math><mml:math id="M30"><mml:mi>V</mml:mi><mml:mn>(0)</mml:mn><mml:mo>~</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>5</mml:mn><mml:mspace width=".25em"/><mml:mi mathvariant="normal">mV</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mn>(5</mml:mn><mml:mspace width=".25em"/><mml:mi mathvariant="normal">mV</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq10.gif"/></alternatives></inline-formula>. Spikes were detected whenever the membrane potential <italic>V</italic> surpassed <italic>V</italic><sub>thresh</sub> = −20 mV and neurons were refractory, i.e. could not produce further spikes, for 3 ms after each spike.</p>
      </sec>
      <sec id="Sec10">
        <title>Mbody model</title>
        <p id="Par38">The Mbody model is essentially a feedforward network inspired by the mushroom body of insects. As illustrated in Fig. <xref rid="Fig6" ref-type="fig">6b</xref>, there are three neuron populations, the projection neurons (PNs) of the antennal lobe, the so-called intrinsic Keynon cells (iKCs) of the mushroom body calyx, and the extrinsic Kenyon cells (eKCs) of the mushroom body lobes. PNs project to iKCs with a random connectivity, where each synapse exists with probability <italic>p</italic><sub>PNiKC</sub> = 0.15 (i.e., pairwise Bernoulli-distributed). For networks with less than 10,000 iKCs, <italic>N</italic><sub>iKC</sub> ≤ 10,000, the connections between iKCs and eKCs are all-to-all. For <italic>N</italic><sub>iKC</sub> &gt; 10,000 they are random with fixed probability <italic>p</italic><sub>iKCeKC</sub> = 10,000/<italic>N</italic><sub>iKC</sub> for each connection to exist. This will on average connect 10,000 iKCs to each eKC. In addition to the feedforward connections, eKCs inhibit each other laterally with an all-to-all connectivity (including self-connections). Synapses are described as conductance based synapses,<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${I}_{{\rm{syn}}}={g}_{x}({V}_{x}-{V}_{{\rm{post}}})$$\end{document}</tex-math><mml:math id="M32" display="block"><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">syn</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">post</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\frac{d{g}_{x}}{dt}=-\frac{{g}_{x}}{{\tau }_{x}}+{w}_{x}\sum _{i}\,\delta (t-{t}_{i})$$\end{document}</tex-math><mml:math id="M34" display="block"><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder></mml:mrow><mml:mspace width=".25em"/><mml:mi>δ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula>where <italic>g</italic><sub><italic>x</italic></sub> are the time dependent conductances of the synapses, <italic>w</italic><sub><italic>x</italic></sub> stands for the synapse weights, <italic>V</italic><sub><italic>x</italic></sub> stands for <italic>V</italic><sub>PNiKC</sub> = <italic>V</italic><sub>iKCeKC</sub> = 0 mV and <italic>V</italic><sub>eKCeKC</sub> = −92 mV, and <italic>τ</italic><sub><italic>x</italic></sub> for the synaptic timescales of <italic>τ</italic><sub>PNiKC</sub> = 2 ms, <italic>τ</italic><sub>iKCeKC</sub> = 10 ms, and <italic>τ</italic><sub>eKCeKC</sub> = 5 ms, respectively. The sum is over all spikes in the pre-synaptic neuron, <italic>t</italic><sub><italic>i</italic></sub> are the spike times and <italic>δ</italic> is the Dirac <italic>δ</italic> distribution as before. The weights are <italic>w</italic><sub>PNiKC</sub> = (6.75 + 0.844 <inline-formula id="IEq14"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$v$$\end{document}</tex-math><mml:math id="M36"><mml:mi>v</mml:mi></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq14.gif"/></alternatives></inline-formula>) nS, where <inline-formula id="IEq11"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$v \sim N\mathrm{(0,1)}$$\end{document}</tex-math><mml:math id="M38"><mml:mi>v</mml:mi><mml:mo>~</mml:mo><mml:mi>N</mml:mi><mml:mn>(0,1)</mml:mn></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq11.gif"/></alternatives></inline-formula> is a normally distributed random variable, and <italic>w</italic><sub>eKCeKC</sub> = 50.6 nS. Synapses between iKCs and eKCs additionally follow a spike timing dependent plasticity (STDP) rule. At each spike occurrence,<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Delta w=\{\begin{array}{cc}A{e}^{-\frac{\Delta t}{{\tau }_{l}}} &amp; \Delta t &gt; 0\\ -A{e}^{\frac{\Delta t}{{\tau }_{l}}} &amp; {\rm{otherwise}}\end{array}$$\end{document}</tex-math><mml:math id="M40" display="block"><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>A</mml:mi><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>t</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>−</mml:mo><mml:mi>A</mml:mi><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="normal">otherwise</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equ9"><label>9</label><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${w}_{ij}\mapsto {w}_{ij}+\Delta w$$\end{document}</tex-math><mml:math id="M42" display="block"><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>↦</mml:mo><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi mathvariant="normal">Δ</mml:mi><mml:mi>w</mml:mi></mml:math><graphic xlink:href="41598_2019_54957_Article_Equ9.gif" position="anchor"/></alternatives></disp-formula>where <italic>w</italic><sub><italic>ij</italic></sub> symbolises the weight of a synapse between the spiking neuron and every other neuron it is connected to, and <italic>w</italic><sub><italic>ij</italic></sub> is clipped to the interval [0,<italic>w</italic><sub>max</sub>] after Δ<italic>w</italic> is added. Δ<italic>t</italic> = <italic>t</italic><sub>post</sub> − <italic>t</italic><sub>pre</sub> is the time difference between pre- and post-synaptic spikes and we have adopted an all-to-all pairing rule, i.e. at each post-synaptic spike, all previous pre-synaptic spikes are considered and <italic>vice versa</italic>. The learning amplitude is <italic>A</italic> = <italic>k</italic>·0.1 nS, the STDP time scale <italic>τ</italic><sub><italic>l</italic></sub> = 10 ms, and <italic>w</italic><sub>max</sub> = <italic>k</italic> · 3.75 nS. The model was originally developed for 2,500 iKCs, which approximates the size of a <italic>Drosophila</italic> mushroom body, and we use the constant <italic>k</italic> = 2,500/<italic>N</italic><sub>iKCeKC</sub> as a scaling factor for parameters relating to the synaptic conductance from iKCs to eKCs. If <italic>k</italic> &lt; 1, we set it to 1. Here, <italic>N</italic><sub>iKCeKC</sub> is the expected number of synapses to each eKC, i.e. <italic>N</italic><sub><italic>iKCeKC</italic></sub> = <italic>N</italic><sub>iKC</sub> if <italic>N</italic><sub>iKC</sub> &lt; 10,000 and <italic>N</italic><sub>iKCeKC</sub> = 10,000 otherwise. This scaling avoids biologically unrealistic, too large inputs to eKCs.</p>
        <p id="Par39">The weights of the plastic synapses were initialized in two steps. First, all synapses were set to a low “inactive” weight <italic>k</italic>·<italic>ω</italic>·<italic>w</italic><sub>max</sub>/10. Then, each weight was set to a higher, “active” weight <italic>k</italic>(2.5 + 0.5<italic>ν</italic>) with probability 0.2. Here <inline-formula id="IEq12"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\omega  \sim U\mathrm{([0,1])}$$\end{document}</tex-math><mml:math id="M44"><mml:mi>ω</mml:mi><mml:mo>~</mml:mo><mml:mi>U</mml:mi><mml:mn>([0,1])</mml:mn></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq12.gif"/></alternatives></inline-formula> is again a uniform random variable in [0.1] and <inline-formula id="IEq13"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\nu  \sim N\mathrm{(0,1)}$$\end{document}</tex-math><mml:math id="M46"><mml:mi>ν</mml:mi><mml:mo>~</mml:mo><mml:mi>N</mml:mi><mml:mn>(0,1)</mml:mn></mml:math><inline-graphic xlink:href="41598_2019_54957_Article_IEq13.gif"/></alternatives></inline-formula> a normally distributed random variable.</p>
        <p id="Par40">The PN neurons in the input layer are described by a spike source array, i.e. they emit spikes at pre-determined times and are otherwise not modeled in detail. We use a structured set of random input patterns. First we choose 10 basis input patterns by randomly choosing 20 active PNs. Each of these input patterns is multiplied into <italic>N</italic><sub>rep</sub> variants by changing the identity of each of the active PNs with probability 0.1. The number <italic>N</italic><sub>rep</sub> is determined such that the overall runtime is as desired (see below) and all variants are presented once. Patterns are presented every 50 ms with a random jitter chosen uniformly between 0 and 2 ms. All other neurons are described by Hodgkin-Huxley equations as in the COBAHH model above, Eq. (<xref rid="Equ4" ref-type="">4</xref>) and Table <xref rid="Tab3" ref-type="table">3</xref>, but parameterised slightly differently with <italic>C</italic><sub><italic>M</italic></sub> = 0.3 nF, <italic>g</italic><sub><italic>L</italic></sub> = 26.7 nS, <italic>g</italic><sub>Na</sub> = 7.15 μS, <italic>g</italic><sub>K</sub> = 1.43 μS, <italic>V</italic><sub><italic>L</italic></sub> = −63.56 mV, <italic>V</italic><sub>Na</sub> = 50 mV, and <italic>V</italic><sub>K</sub> = −95 mV. All Hodgkin-Huxley neurons were initialised with <italic>V</italic> = <italic>V</italic><sub><italic>L</italic></sub>, <italic>m</italic> = 0, and <italic>h</italic> = 0.5.</p>
        <p id="Par41">The source code of the two model networks is published alongside the entire benchmarking code and results at <ext-link ext-link-type="uri" xlink:href="https://github.com/brian-team/brian2genn_benchmarks">https://github.com/brian-team/brian2genn_benchmarks</ext-link>.</p>
      </sec>
    </sec>
    <sec id="Sec11">
      <title>Benchmarks</title>
      <p id="Par42">Benchmarks were run on a number of different workstations, with different GPUs installed ranging from a standard consumer card (Quadro K2200) to a more powerful gaming GPU (TITAN Xp), an older computing accelerator model (Tesla K40c) to the most recent and most powerful accelerator (Tesla V100). The different configurations for benchmarking are listed in Table <xref rid="Tab1" ref-type="table">1</xref>. We used Brian 2, version 2.2<sup><xref ref-type="bibr" rid="CR25">25</xref></sup>, GeNN version 3.2<sup><xref ref-type="bibr" rid="CR26">26</xref></sup>, and Brian2GeNN version 1.2<sup><xref ref-type="bibr" rid="CR27">27</xref></sup> for our benchmarks.</p>
      <p id="Par43">In initial benchmarks we tested the models when run with “monitors”, Brian’s mechanism for recording the activity during a simulation, and without. We observed that when monitoring the state of a few neurons, monitors play virtually no role in the context of the two models used as benchmarks here. We, therefore, only present the benchmarking figures without monitors in place. For the runs using Brian2GeNN, we used GeNN’s Yale sparse matrix representation<sup><xref ref-type="bibr" rid="CR9">9</xref></sup> throughout. While for smaller models, dense matrix representations may have speed advantages, the more relevant mid- and large-scale models would lead to “out of memory” failure on all tested GPUs with either of GeNN’s dense matrix representations. Even with sparse matrix representation, some of the largest simulation sizes could not be run on all GPU models because of the difference in size of the GPU memory on the employed devices. The corresponding data points were omitted from the benchmark figures.</p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p><bold>Publisher’s note</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>We thank James Knight for assisting us with running benchmarks on the Tesla V100 device and helping with adjustments in GeNN. This work was partially funded by the EPSRC (grants EP/J019690/1, EP/P006094/1) and Horizon 2020 research and innovation program under grant agreement no. 785907 (Human Brain Project, SGA2), and the Royal Society (grant RG170298). The Titan Xp and the K40c used for this research were donated by the NVIDIA Corporation. The authors gratefully acknowledge the Gauss Centre for Supercomputing e.V. (<ext-link ext-link-type="uri" xlink:href="http://www.gauss-centre.eu">www.gauss-centre.eu</ext-link>) for supporting this project by providing computing time through the John von Neumann Institute for Computing (NIC) on the GCS Supercomputer JUWELS at Jülich Supercomputing Centre (JSC).</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Author contributions</title>
    <p>M.S., D.G. and T.N. developed Brian2GeNN, M.S., D.G. and T.N. ran benchmarks, M.S. produced figures, M.S., D.G. and T.N. wrote the manuscript. All authors reviewed the manuscript.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Data availability</title>
    <p>Brian2GeNN is developed publicly on github (<ext-link ext-link-type="uri" xlink:href="https://github.com/brianteam/brian2genn">https://github.com/brianteam/brian2genn</ext-link>). The scripts and raw results of the benchmark runs are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/brian-team/brian2genn_benchmarks">https://github.com/brian-team/brian2genn_benchmarks</ext-link>.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par44">The authors declare no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Oh</surname>
            <given-names>K-S</given-names>
          </name>
          <name>
            <surname>Jung</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>GPU implementation of neural networks</article-title>
        <source>Pattern Recognit.</source>
        <year>2004</year>
        <volume>37</volume>
        <fpage>1311</fpage>
        <lpage>1314</lpage>
        <pub-id pub-id-type="doi">10.1016/j.patcog.2004.01.013</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">Rolfes, T. <italic>Neural networks on programmable graphics hardware</italic> (Charles River Media, Boston, MA, 2004).</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">NVIDIA® Corporation. CUDA™, <ext-link ext-link-type="uri" xlink:href="https://developer.nvidia.com/cuda-zone">https://developer.nvidia.com/cuda-zone</ext-link> (2006–2018).</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nageswaran</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Dutt</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Krichmar</surname>
            <given-names>JL</given-names>
          </name>
          <name>
            <surname>Nicolau</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Veidenbaum</surname>
            <given-names>AV</given-names>
          </name>
        </person-group>
        <article-title>A configurable simulation environment for the efficient simulation of large-scale spiking neural networks on graphics processors</article-title>
        <source>Neural Networks</source>
        <year>2009</year>
        <volume>22</volume>
        <fpage>791</fpage>
        <lpage>800</lpage>
        <pub-id pub-id-type="doi">10.1016/j.neunet.2009.06.028</pub-id>
        <?supplied-pmid 19615853?>
        <pub-id pub-id-type="pmid">19615853</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">Fidjeland, A. &amp; Shanahan, M. Accelerated simulation of spiking neural networks using GPUs. In <italic>The 2010 International Joint Conference on Neural Networks (IJCNN)</italic>, 1–8, 10.1109/IJCNN.2010.5596678 (2010).</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Mutch, J., Knoblich, U. &amp; Poggio, T. CNS: a GPU-based framework for simulating cortically-organized networks. <italic>Comput. Sci. Artif. Intell. Lab. Tech. Rep</italic>. (2010).</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Hoang, R. V., Tanna, D., Jayet Bray, L. C., Dascalu, S. M. &amp; Harris, F. C. A novel CPU/GPU simulation environment for large-scale biologically realistic neural modeling. <italic>Front. Neuroinformatics</italic><bold>7</bold>, 19, 10.3389/fninf.2013.00019 (2013).</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <mixed-citation publication-type="other">Bekolay, T. <italic>et al</italic>. Nengo: a Python tool for building large-scale functional brain models. <italic>Front</italic>. <italic>Neuroinformatics</italic><bold>7,</bold> 48, 10.3389/fninf.2013.00048 (2014).</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yavuz</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Turner</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Nowotny</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>GeNN: A code generation framework for accelerated brain simulations</article-title>
        <source>Sci. Rep.</source>
        <year>2016</year>
        <volume>6</volume>
        <fpage>18854</fpage>
        <pub-id pub-id-type="doi">10.1038/srep18854</pub-id>
        <?supplied-pmid 26740369?>
        <pub-id pub-id-type="pmid">26740369</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>DFM</given-names>
          </name>
        </person-group>
        <article-title>Code Generation: A Strategy for Neural Network Simulators</article-title>
        <source>Neuroinformatics</source>
        <year>2010</year>
        <volume>8</volume>
        <fpage>183</fpage>
        <lpage>196</lpage>
        <pub-id pub-id-type="doi">10.1007/s12021-010-9082-x</pub-id>
        <?supplied-pmid 20857234?>
        <pub-id pub-id-type="pmid">20857234</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">Blundell, I. <italic>et al</italic>. Code Generation in Computational Neuroscience: A Review of Tools and Techniques. <italic>Front</italic>. <italic>Neuroinformatics</italic><bold>12,</bold> 68, 10.3389/fninf.2018.00068 (2018).</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Knight</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Nowotny</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>GPUs outperform current HPC and neuromorphic solutions in terms of speed and energy when simulating a highly-connected cortical model</article-title>
        <source>Front. Neurosci.</source>
        <year>2018</year>
        <volume>12</volume>
        <fpage>941</fpage>
        <pub-id pub-id-type="doi">10.3389/fnins.2018.00941</pub-id>
        <?supplied-pmid 30618570?>
        <pub-id pub-id-type="pmid">30618570</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Augustin, M., Alevi, D., Stimberg, M. &amp; Obermayer, K. Flexible simulation of neuronal network models on graphics processing units: an efficient code generation approach based on Brian. In <italic>Bernstein Conference 2018</italic>, 10.12751/nncn.bc2018.0072 (2018).</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Vitay, J., Dinkelbach, H. Ü. &amp; Hamker, F. H. ANNarchy: a code generation approach to neural simulations on parallel hardware. <italic>Front. Neuroinformatics</italic><bold>9,</bold> 19, 10.3389/fninf.2015.000191702.06463 (2015).</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Brette</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Brian: a simulator for spiking neural networks in python</article-title>
        <source>Front. neuroinformatics</source>
        <year>2008</year>
        <volume>2</volume>
        <fpage>5</fpage>
        <pub-id pub-id-type="doi">10.3389/neuro.11.005.2008</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>DFM</given-names>
          </name>
          <name>
            <surname>Brette</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>The Brian simulator</article-title>
        <source>Front. Neurosci.</source>
        <year>2009</year>
        <volume>3</volume>
        <fpage>192</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="doi">10.3389/neuro.01.026.2009</pub-id>
        <?supplied-pmid 20011141?>
        <pub-id pub-id-type="pmid">20011141</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>Dan</given-names>
          </name>
          <name>
            <surname>Brette</surname>
            <given-names>Romain</given-names>
          </name>
        </person-group>
        <article-title>Brian simulator</article-title>
        <source>Scholarpedia</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>10883</fpage>
        <pub-id pub-id-type="doi">10.4249/scholarpedia.10883</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stimberg</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Brette</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Goodman</surname>
            <given-names>DFM</given-names>
          </name>
        </person-group>
        <article-title>Brian 2, an intuitive and efficient neural simulator</article-title>
        <source>eLife</source>
        <year>2019</year>
        <volume>8</volume>
        <fpage>e47314</fpage>
        <pub-id pub-id-type="doi">10.7554/eLife.47314</pub-id>
        <?supplied-pmid 31429824?>
        <pub-id pub-id-type="pmid">31429824</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stimberg</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Goodman</surname>
            <given-names>DFM</given-names>
          </name>
          <name>
            <surname>Benichoux</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Brette</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Equation-oriented specification of neural models for simulations</article-title>
        <source>Front. Neuroinformatics</source>
        <year>2014</year>
        <volume>8</volume>
        <fpage>6</fpage>
        <pub-id pub-id-type="doi">10.3389/fninf.2014.00006</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brette</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Simulation of networks of spiking neurons: A review of tools and strategies</article-title>
        <source>J. Comput. Neurosci.</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>349</fpage>
        <lpage>398</lpage>
        <pub-id pub-id-type="doi">10.1007/s10827-007-0038-6</pub-id>
        <?supplied-pmid 17629781?>
        <pub-id pub-id-type="pmid">17629781</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <mixed-citation publication-type="other">Traub, R. D. &amp; Miles, R. <italic>Neural Networks of the Hippocampus</italic> (Cambridge University Press, New York, 1991).</mixed-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nowotny</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Huerta</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Abarbanel</surname>
            <given-names>HDI</given-names>
          </name>
          <name>
            <surname>Rabinovich</surname>
            <given-names>MI</given-names>
          </name>
        </person-group>
        <article-title>Self-organization in the olfactory system: Rapid odor recognition in insects</article-title>
        <source>Biol Cybern</source>
        <year>2005</year>
        <volume>93</volume>
        <fpage>436</fpage>
        <lpage>446</lpage>
        <pub-id pub-id-type="doi">10.1007/s00422-005-0019-7</pub-id>
        <pub-id pub-id-type="pmid">16320081</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">van Albada, S. J. <italic>et al</italic>. Performance Comparison of the Digital Neuromorphic Hardware SpiNNaker and the Neural Network Simulation Software NEST for a Full-Scale Cortical Microcircuit Model. <italic>Front. Neurosci</italic>. <bold>12</bold>, 10.3389/fnins.2018.00291 (2018).</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Brette</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Goodman</surname>
            <given-names>DFM</given-names>
          </name>
        </person-group>
        <article-title>Simulating spiking neural networks on GPU</article-title>
        <source>Netw. (Bristol, England)</source>
        <year>2012</year>
        <volume>23</volume>
        <fpage>167</fpage>
        <lpage>82</lpage>
        <pub-id pub-id-type="doi">10.3109/0954898X.2012.730170</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <mixed-citation publication-type="other">Stimberg, M., Goodman, D. F. M. &amp; Brette, R. Brian 2 (version 2.2), 10.5281/zenodo.1459786 (2018).</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <mixed-citation publication-type="other">Knight, J., Yavuz, E., Turner, J. &amp; Nowotny, T. GeNN (version 3.2), 10.5281/zenodo.593735 (2018).</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <mixed-citation publication-type="other">Stimberg, M., Nowotny, T. &amp; Goodman, D. F. M. Brian2GeNN (version 1.2), 10.5281/zenodo.1464116 (2018).</mixed-citation>
    </ref>
  </ref-list>
</back>
