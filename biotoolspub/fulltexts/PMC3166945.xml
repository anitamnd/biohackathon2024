<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3166945</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-12-333</article-id>
    <article-id pub-id-type="pmid">21831268</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-12-333</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Efficient counting of <bold><italic>k</italic></bold>-mers in DNA sequences using a bloom filter</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes" id="A1">
        <name>
          <surname>Melsted</surname>
          <given-names>Páll</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>pmelsted@gmail.com</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A2">
        <name>
          <surname>Pritchard</surname>
          <given-names>Jonathan K</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>pritch@uchicago.edu</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Human Genetics, The University of Chicago, Chicago IL, 60637, USA</aff>
    <aff id="I2"><label>2</label>Howard Hughes Medical Institute, The University of Chicago, Chicago IL, 60637, USA</aff>
    <pub-date pub-type="collection">
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>8</month>
      <year>2011</year>
    </pub-date>
    <volume>12</volume>
    <fpage>333</fpage>
    <lpage>333</lpage>
    <history>
      <date date-type="received">
        <day>14</day>
        <month>5</month>
        <year>2011</year>
      </date>
      <date date-type="accepted">
        <day>10</day>
        <month>8</month>
        <year>2011</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright ©2011 Melsted and Pritchard; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2011</copyright-year>
      <copyright-holder>Melsted and Pritchard; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/12/333"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Counting <italic>k</italic>-mers (substrings of length <italic>k </italic>in DNA sequence data) is an essential component of many methods in bioinformatics, including for genome and transcriptome assembly, for metagenomic sequencing, and for error correction of sequence reads. Although simple in principle, counting <italic>k</italic>-mers in large modern sequence data sets can easily overwhelm the memory capacity of standard computers. In current data sets, a large fraction-often more than 50%-of the storage capacity may be spent on storing <italic>k</italic>-mers that contain sequencing errors and which are typically observed only a single time in the data. These singleton <italic>k</italic>-mers are uninformative for many algorithms without some kind of error correction.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present a new method that identifies all the <italic>k</italic>-mers that occur more than once in a DNA sequence data set. Our method does this using a Bloom filter, a probabilistic data structure that stores all the observed <italic>k</italic>-mers implicitly in memory with greatly reduced memory requirements. We then make a second sweep through the data to provide exact counts of all nonunique <italic>k</italic>-mers. For example data sets, we report up to 50% savings in memory usage compared to current software, with modest costs in computational speed. This approach may reduce memory requirements for any algorithm that starts by counting <italic>k</italic>-mers in sequence data with errors.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>A reference implementation for this methodology, BFCounter, is written in C++ and is GPL licensed. It is available for free download at <ext-link ext-link-type="uri" xlink:href="http://pritch.bsd.uchicago.edu/bfcounter.html">http://pritch.bsd.uchicago.edu/bfcounter.html</ext-link></p>
      </sec>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>With recently-developed methods for massively parallel DNA sequencing it is now practical for individual labs to perform whole-genome or transcriptome sequencing of a wide variety of organisms, and to perform metagenomic sequencing of environmental samples. Additionally, these new sequencing technologies are becoming widely used for reduced representation sequencing and genotyping of non-model organisms [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], including those with no available genome sequence.</p>
    <p>Each of these applications involves <italic>de novo </italic>assembly from very large numbers of short reads. Despite progress in recent years, <italic>de novo </italic>assembly remains a computationally challenging task. The current research for assembly with short reads is focused on <italic>de Bruijn </italic>graph methods [<xref ref-type="bibr" rid="B3">3</xref>-<xref ref-type="bibr" rid="B7">7</xref>]. The nodes in a <italic>de Bruijn </italic>graph are the <italic>k</italic>-mers of a pre-specified length <italic>k </italic>that are contained within the sequencing reads. Two <italic>k</italic>-mers are connected in the graph if they are adjacent in at least one sequencing read. Although <italic>de Bruijn </italic>graphs provide a nice conceptual framework that cuts down on computation time, the size of the graph can be very large, typically including billions of <italic>k</italic>-mers for vertebrate-sized genomes.</p>
    <p>In order to deal with the computational challenges of working with such large data sets, a number of methods have been proposed for storing <italic>k</italic>-mers efficiently. Most <italic>de Bruijn </italic>graph assemblers store <italic>k</italic>-mers using 2 bits to encode each nucleotide, so that each <italic>k</italic>-mer <inline-formula><inline-graphic xlink:href="1471-2105-12-333-i1.gif"/></inline-formula> takes bytes. The <italic>k</italic>-mers are then stored in a hash table, usually with some associated information such as coverage and neighborhood information in the <italic>de Bruijn </italic>graph. The exact memory usage depends on the hash table used; for example, the assembly software ABySS [<xref ref-type="bibr" rid="B6">6</xref>] uses the Google <italic>sparsehash </italic>library, which has minimal memory overhead <ext-link ext-link-type="uri" xlink:href="http://code.google.com/p/google-sparsehash/">http://code.google.com/p/google-sparsehash/</ext-link>. Additionally, ABySS can share the memory load across multiple machines, splitting up the hash table so that each potential <italic>k</italic>-mer is assigned to a unique machine, although this setup has more communication overhead across machines and requires additional work by the end user. A recently-developed program named Jellyfish is specifically designed for <italic>k</italic>-mer counting (for <italic>k</italic>-mers of up to 32 bp) [<xref ref-type="bibr" rid="B8">8</xref>]. It uses a "quotienting" technique [<xref ref-type="bibr" rid="B9">9</xref>] to reduce the space needed to store each <italic>k</italic>-mer in a hash table, and it achieves much lower memory usage than other available methods. Additionally, [<xref ref-type="bibr" rid="B10">10</xref>] show how to compress both the <italic>de Bruijn </italic>graph and the <italic>k</italic>-mer coverage counts to nearly the optimal. However this compression is done after all the <italic>k</italic>-mers have been counted, in contrast to Jellyfish.</p>
    <p>A complementary strategy for reducing memory usage is based on the observation that in current data sets, a large fraction of the observed <italic>k</italic>-mers may arise from sequencing errors. Most of these occur uniquely in the data, and hence they greatly increase the memory requirements of <italic>de novo </italic>assembly without adding much information. For this reason, it is frequently helpful to either discard unique <italic>k</italic>-mers prior to building the graph, or to attempt to correct them if they are similar to other, much more abundant, <italic>k</italic>-mers [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B14">14</xref>]. For example, the team that sequenced the giant panda genome obtained 56-fold coverage of the 2.4 GB genome on the Illumina sequencing platform [<xref ref-type="bibr" rid="B11">11</xref>]. Using a supercomputer with 512 GB of RAM, the authors counted a total of 8.62 billion 27-mers. After removing or correcting low-coverage <italic>k</italic>-mers, they eliminated 68% of the observed <italic>k</italic>-mers, reducing the total number to just 2.69 billion. Their genome assembly was based on this reduced set.</p>
    <p>More generally, while the number of true <italic>k</italic>-mers in a genome sequence is at most the genome length, <italic>G </italic>(or less in practice, due to repeats), the number of spurious <italic>k</italic>-mers grows almost linearly with sequencing depth. To illustrate this, if we assume a uniform error rate <italic>α </italic>per nucleotide, then the expected number of spurious <italic>k</italic>-mers at sequence coverage <italic>C </italic>is <inline-formula><inline-graphic xlink:href="1471-2105-12-333-i2.gif"/></inline-formula>, where <italic>l </italic>is the length of sequence reads. (This calculation ignores the rare events in which an identical sequencing error occurs more than once, and that error rates are typically highest near the ends of reads.) Then for example, at an error rate of 1% per base, read length of 100 bp, and <italic>k </italic>= 31, the number of spurious <italic>k</italic>-mers would exceed the genome length <italic>G </italic>at just 5.33-fold coverage.</p>
    <p>However, even the seemingly simple goal of eliminating singleton, or low coverage, <italic>k</italic>-mers is computationally demanding in practice, since we do not know <italic>a priori </italic>which <italic>k</italic>-mers have low coverage. An obvious approach would be to simply load all observed <italic>k</italic>-mers into a hash table while counting the number of occurrences of each. But this task alone can easily overwhelm the memory of standard high performance machines.</p>
    <p>The goal then is to implement a method for identifying unique <italic>k</italic>-mers (or more generally, <italic>k</italic>-mers that occur <italic>&lt; n </italic>times), that makes highly efficient use of memory while providing efficient storage of <italic>k</italic>-mers with fast insertion and query times. The problem of counting the number of distinct <italic>k</italic>-mers is much easier if we are willing to settle for an approximate answer that works with high probability [<xref ref-type="bibr" rid="B15">15</xref>].</p>
    <p>Here, we describe an approach to solving this problem by storing an implicit and highly compact representation of the observed <italic>k</italic>-mers, known as a Bloom filter. A reference implementation, implemented in a C++ program called BFCounter, is freely available. We show empirical results of applying this method to published sequencing data. We also discuss possible extensions and further applications of the method.</p>
  </sec>
  <sec>
    <title>Results and Discussion</title>
    <sec>
      <title>The Bloom Filter</title>
      <p>The Bloom filter is a probabilistic data structure supporting dynamic set membership queries with false positives [<xref ref-type="bibr" rid="B16">16</xref>]. It allows us to identify in an extremely compact way all <italic>k</italic>-mers that are present more than once in a data set, while allowing a low rate of false positives. Bloom filters have been used widely in computing applications, but to date rarely in bioinformatics, but see [<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B17">17</xref>,<xref ref-type="bibr" rid="B18">18</xref>].</p>
      <p>The essential idea is illustrated in Figure <xref ref-type="fig" rid="F1">1</xref>. The Bloom filter is a bit array <italic>B</italic>, initialized to be 0 at every position. We also define a set of <italic>d </italic>hash functions, <italic>h</italic><sub>1</sub>, ..., <italic>h<sub>d</sub></italic>, where each hash function maps a given <italic>k</italic>-mer <italic>x </italic>to a location in <italic>B</italic>.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>Bloom filter example</bold>. An example of a Bloom filter with three hash functions. The <italic>k</italic>-mers <italic>a </italic>and <italic>b </italic>have been inserted, but <italic>c </italic>and <italic>d </italic>have not. The three hash functions are represented with arrows, and the bits corresponding to the hashes for <italic>a </italic>and <italic>b </italic>have been set to 1. The Bloom filter indicates correctly that <italic>k</italic>-mer <italic>c </italic>has not been inserted since not all of its bits are set to 1. However, <italic>k</italic>-mer <italic>d </italic>is an example of a false positive: it has not been inserted, but since its bits were set to 1 by the insertion of <italic>a </italic>and <italic>b</italic>, the Bloom filter falsely reports that <italic>d </italic>has been seen already.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-333-1"/>
      </fig>
      <p>In order to insert a <italic>k</italic>-mer <italic>x </italic>into the Bloom filter, we set all of the <italic>d </italic>corresponding locations in <italic>B </italic>to be 1; that is, we set <italic>B</italic>[<italic>h<sub>i</sub></italic>(<italic>x</italic>)] = 1 for <italic>i </italic>= 1, ..., <italic>d</italic>. Then, to determine whether a <italic>k</italic>-mer <italic>y </italic>has been inserted, we simply check whether each of the corresponding hash positions is 1: i.e., whether <italic>B</italic>[<italic>h<sub>i</sub></italic>(<italic>y</italic>)] are all set to 1 for <italic>i </italic>= 1, ..., <italic>d</italic>. If this is the case, then we infer that <italic>y </italic>has probably been seen before. By construction, this procedure correctly identifies every <italic>k</italic>-mer that is present more than once in the data; however, the cost of very efficient memory usage is that we accept a low rate of false positives in which we infer that <italic>y </italic>has been seen previously, but in fact it has not.</p>
      <p>The Bloom filter has a tradeoff between memory usage (i.e., the number of bits used) and the false positive rate. When storing <italic>n k</italic>-mers in a Bloom filter of <italic>m </italic>bits, and using <italic>d </italic>hash functions, the false positive rate is approximately <inline-formula><inline-graphic xlink:href="1471-2105-12-333-i3.gif"/></inline-formula>. Given <italic>n </italic>and <italic>m</italic>, the optimal number of hash functions that minimizes the false positive ratio is <inline-formula><inline-graphic xlink:href="1471-2105-12-333-i4.gif"/></inline-formula>[<xref ref-type="bibr" rid="B19">19</xref>]. In practice we may have a rough idea in advance about <italic>n</italic>, the number of <italic>k</italic>-mers, and we can select <italic>m </italic>as a fixed multiple of <italic>n</italic>. For example using <italic>m </italic>= 8 · <italic>n </italic>(which corresponds to storing one byte per <italic>k</italic>-mer), and <italic>d </italic>= 5 gives a false positive ratio of 2.16%. Many variations and improvements have been proposed for Bloom filters [<xref ref-type="bibr" rid="B20">20</xref>,<xref ref-type="bibr" rid="B21">21</xref>]; or see [<xref ref-type="bibr" rid="B19">19</xref>] for a survey.</p>
    </sec>
    <sec>
      <title>Storing and counting <italic>k</italic>-mers using the Bloom Filter</title>
      <p>To count all non-unique <italic>k</italic>-mers we use a Bloom filter <italic>B </italic>and a simple hash table <italic>T </italic>to store <italic>k</italic>-mers. The Bloom filter keeps track of <italic>k</italic>-mers we have encountered so far and acts as a "staging area", while the hash table stores all the <italic>k</italic>-mers seen at least twice so far. The idea is to use the memory-efficient Bloom filter to store implicitly all <italic>k</italic>-mers seen so far, while only inserting non-unique <italic>k</italic>-mers into the hash table.</p>
      <p>Initially both the Bloom filter and the hash table are empty. All <italic>k</italic>-mers are generated sequentially from the sequencing reads. Note that in most applications we do not need to distinguish between a <italic>k</italic>-mer and its reverse complement sequence. Thus, as we read in each <italic>k</italic>-mer we also consider the reverse complement of that <italic>k</italic>-mer and then work with whichever of the two versions is lexicographically smaller (we refer to the smaller sequence as the "canonical <italic>k</italic>-mer").</p>
      <p>For each <italic>k</italic>-mer, <italic>x</italic>, we check if <italic>x </italic>is in the Bloom filter <italic>B</italic>. If it is not in <italic>B </italic>then we update the appropriate bits in <italic>B </italic>to indicate that it has now been observed. If <italic>x </italic>is in <italic>B</italic>, then we check if it is in <italic>T</italic>, and if not, we add it to <italic>T</italic>.</p>
      <p>This scheme guarantees that all <italic>k</italic>-mers with a coverage of 2 or more are inserted into <italic>T</italic>. However a small proportion of unique <italic>k</italic>-mers will be inserted into <italic>T </italic>due to false positive queries to <italic>B</italic>. After the first pass through the sequence data, one can re-iterate over the sequence data to obtain exact counts of the <italic>k</italic>-mers in <italic>T </italic>and then simply delete all unique <italic>k</italic>-mers. The time spent on the second round is at most 50% of the total time, and tends to be less since hash table lookups are generally faster than insertions. A detailed pseudocode is given in Figure <xref ref-type="fig" rid="F2">2</xref>.</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Algorithm pseudocode</bold>. A pseudocode for the Bloom filter <italic>k</italic>-mer counting algorithm.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-333-2"/>
      </fig>
      <p>It is also possible to obtain approximate <italic>k</italic>-mer counts by iterating only once over the sequence reads. In this case we record a coverage count of 2 when first inserting a <italic>k</italic>-mer into the hash table <italic>T</italic>, and subsequently increment the counter for each additional observation of this <italic>k</italic>-mer. This means that the coverage counts for some <italic>k</italic>-mers are 1 higher than the true value, and some <italic>k</italic>-mers in <italic>T </italic>are in fact false positives (i.e., present only once).</p>
    </sec>
    <sec>
      <title>Higher Coverage Cutoffs</title>
      <p>For some applications a higher coverage cutoff may be required to either filter out sequencing errors or to simply extract sequences of interest. The algorithm can be extended to use counting Bloom filters, where each bit in the bit array is now replaced with a counter that uses only a small number of bits. If the desired minimum coverage is <italic>c </italic>we use an array of <italic>m </italic>⌈log<sub>2</sub>(<italic>c</italic>)⊥-bit counters. The counting Bloom filter was introduced by [<xref ref-type="bibr" rid="B20">20</xref>] to allow for deletions, but here we use the counts directly.</p>
      <p>To check if a <italic>k</italic>-mer should be inserted into the hash table <italic>T </italic>we look to see if all of <italic>B</italic>[<italic>h<sub>i</sub></italic>(<italic>x</italic>)] are equal to <italic>c </italic>- 1. Otherwise we insert it into the Bloom filter. When inserting a <italic>k</italic>-mer <italic>x</italic>, we set<disp-formula><graphic xlink:href="1471-2105-12-333-i5.gif"/></disp-formula></p>
      <p>for <italic>i </italic>= 1, ..., <italic>d</italic>. Note that for a <italic>k</italic>-mer <italic>x</italic>, min{<italic>B</italic>[<italic>h<sub>i</sub></italic>(<italic>x</italic>)]|<italic>i </italic>= 1, ..., <italic>d</italic>} gives an upper bound on the number of occurrences of <italic>x </italic>so far. Of course the basic version simply corresponds to the case of <italic>c </italic>= 2.</p>
    </sec>
    <sec>
      <title>Parallelizability</title>
      <p>The algorithm is presented above as a standard single processor program and our current implementation is not multi-threaded.</p>
      <p>Nonetheless it would be possible to speed up the operations using multiple cores with lock-free data structures. This would require a non-blocking implementation of the hash table [<xref ref-type="bibr" rid="B22">22</xref>] and a modification to the Bloom filter. The bit array in the Bloom filter is implemented as an array of word-sized integers, usually 32 or 64 bits. To avoid accidental collisions where two bit locations in the same word are updated, one can use "compare-and-swap" (CAS) operations on words to ensure atomic updates of each bit independently.</p>
      <p>Since the role of the Bloom filter is to keep track of <italic>k</italic>-mers seen previously, this scheme could plausibly fail in the unlikely event that two occurrences of the same k-mer are inserted into the Bloom filter simultaneously by different threads. In this case the two threads would both query the Bloom filter for a <italic>k</italic>-mer, <italic>x</italic>, and after both receive a negative answer the two threads would insert <italic>x </italic>simultaneously. If <italic>x </italic>occurs exactly twice in the data set then we would fail to record it in the hash table and get a false negative, although this type of false negative seems unlikely to be a serious concern in practice. However this can be fixed by extending the Bloom filter data structure to return the number of bits set to 1 when querying, and the number of bits changed from 0 to 1 when inserting. This makes insertion atomic, each thread can then determine when inserting a new <italic>k</italic>-mer into the Bloom filter whether any other threads were inserting the same <italic>k</italic>-mer simultaneously by comparing the number of bits changed from 0 to 1. If the two numbers do not match, we can infer that some other thread had already inserted the <italic>k</italic>-mer into the Bloom filter and proceed with inserting the <italic>k</italic>-mer into the hash table.</p>
    </sec>
    <sec>
      <title>Implementation</title>
      <p>We implemented this algorithm in a program called BFCounter in C++, available from <ext-link ext-link-type="uri" xlink:href="http://pritch.bsd.uchicago.edu/bfcounter.html">http://pritch.bsd.uchicago.edu/bfcounter.html</ext-link> The source code is licenced under a GPL licence. For the implementation we used the Google <italic>sparsehash </italic>library and a Bloom filter library by A. Partow <ext-link ext-link-type="uri" xlink:href="http://www.partow.net/programming/hashfunctions/index.html">http://www.partow.net/programming/hashfunctions/index.html</ext-link>. We store a 1-byte counter for each <italic>k</italic>-mer and by default <italic>k</italic>-mers take 8-bytes of memory with a maximum <italic>k </italic>of 31, although if desired, larger <italic>k</italic>-mers can be specified at compile time. We require the user to specify an estimate for the number of <italic>k</italic>-mers in the sequencing data and use a Bloom filter with 4 times as many bits as the expected number of <italic>k</italic>-mers this corresponds to a memory usage of 4-bits per <italic>k</italic>-mer and the optimal number of hash functions functions for the Bloom filter is <italic>d </italic>= 3.</p>
    </sec>
    <sec>
      <title>Example data sets</title>
      <p>To illustrate the performance of the new method, we describe the analysis of two data sets of sequencing reads from human genomic DNA. The first data set consists of 7.5 M 100 bp paired-end reads from the Illumina platform that mapped to Chromosome 21. These data, from HapMap individual NA19240, are available from Illumina at <ext-link ext-link-type="uri" xlink:href="http://www.illumina.com/truseq/tru_resources/datasets.ilmn.">http://www.illumina.com/truseq/tru_resources/datasets.ilmn.</ext-link> This data set corresponds to approximately 32-fold coverage of Chromosome 21, a coverage-level that is typical of many contemporary sequencing studies. Since the reads have already been mapped to a genome this likely represents a cleaner data set (i.e., with fewer errors and lower repeat content) than we would expect to get from unprocessed sequence data.</p>
      <p>The second data set consists of genome-wide sequence data from the 1000 Genomes Project Pilot II study [<xref ref-type="bibr" rid="B23">23</xref>]. Individual NA19240 was sequenced at 40-fold coverage, using 2.66 billion 36 bp paired-end Illumina reads. The data were filtered to remove sequences with low quality scores and missing basecalls; they are available at <ext-link ext-link-type="ftp" xlink:href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/NA19240/sequence_read/">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data/NA19240/sequence_read/</ext-link>.</p>
      <p>Our first application is to the 32-fold sequence data from Chromosome 21 data. We collected all <italic>k</italic>-mers from the sequencing reads, using <italic>k </italic>= 31. Figure <xref ref-type="fig" rid="F3">3</xref> shows the distribution of the number of times each <italic>k</italic>-mer is seen in the input data. Out of 80.4M observed <italic>k</italic>-mers, slightly more than half (48.7M) are observed only a single time. The vast majority of these singleton <italic>k</italic>-mers (99.87%) are not found in the reference genome and hence are most likely due to sequencing errors, thus supporting the approach of discarding or correcting these unique <italic>k</italic>-mers.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Number of <italic>k</italic>-mers</bold>. The plot shows the number of distinct <italic>k</italic>-mers found in the sequencing data from chr21 at different coverage levels, based on random subsampling of the data. The total number of distinct <italic>k</italic>-mers in the hg18 genome sequence of chr21 is 32.5 million <italic>k</italic>-mers. Unfiltered, the number of <italic>k</italic>-mers found increases at a steady rate after 5-fold coverage. When unique <italic>k</italic>-mers are removed, the number of filtered <italic>k</italic>-mers approaches the ideal number at around 7-fold coverage and the rate of increase is significantly reduced.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-333-3"/>
      </fig>
      <p>Figure <xref ref-type="fig" rid="F4">4</xref> illustrates how the total number of <italic>k</italic>-mers, and the number of nonunique <italic>k</italic>-mers increases with sequencing depth for this data set. For the unfiltered <italic>k</italic>-mers we see the same behavior with increasing coverage as expected from the Introduction: namely, the total number of <italic>k</italic>-mers found increases approximately linearly for coverage levels greater than about 5X. This increase is almost completely due to the increase in unique <italic>k</italic>-mers that contain errors. In contrast, the number of non-unique <italic>k</italic>-mers is only slightly more than the expected number based on the number of distinct <italic>k</italic>-mers in the hg18 genome sequence from Chromosome 21.</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold><italic>k</italic>-mer distribution</bold>. Distribution of coverage levels for <italic>k</italic>-mers in the sequence reads from chromosome 21. There is a clear distinction between the coverage levels of the 31.7M observed <italic>k</italic>-mers that are found in the hg18 reference genome sequence compared to the 48.7M <italic>k</italic>-mers that are not in hg18. Of the <italic>k</italic>-mers not found in hg18, 44.5M or 99.87%, are observed only once, and are likely sequencing errors. A small fraction of <italic>k</italic>-mers that do not match hg18 are observed many times in the data; these likely represent SNP differences between the sequenced individual and hg18 and would be retained by the Bloom filter.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-333-4"/>
      </fig>
      <p>To evaluate the computational performance of BFCounter we compared it to Jellyfish [<xref ref-type="bibr" rid="B8">8</xref>] and to a naive <italic>k</italic>-mer counting program without any filtering. All comparisons were done on a 64-bit x86 Intel Xeon machine with 8 cores at 2.4 GHz and 144 GB of memory running Linux kernel version 2.6.18. The disks were all from shared network through Lustre. All time measurements were done with the time unix command and memory usage was measured using strace.</p>
      <p>The naive version simply stores all <italic>k</italic>-mers explicitly in a Google <italic>sparsehash </italic>hash table and skips the filtering step. Jellyfish is a sophisticated <italic>k</italic>-mer counting program that features support for multicore machines. Furthermore Jellyfish stores an implicit representation of <italic>k</italic>-mers in a hash table to save memory. The authors of the Jellyfish program recently showed that their method provides large memory savings compared to other traditional methods for <italic>k</italic>-mer counting. Jellyfish requires us to prespecify the size of the hash table to use; if the hash table fills up, the results are written to disk and merged later. To compare the programs we found the minimum size so that Jellyfish could keep all <italic>k</italic>-mers in memory. For the second data set Jellyfish could not fit all <italic>k</italic>-mers in memory with default parameters. To fit the hash table in memory we needed to set the number of reprobes to 255 by running Jellyfish with the -p 255 option. For timing comparisons we run Jellyfish in serial mode.</p>
      <p>The increase in the number of <italic>k</italic>-mers affects the memory consumption directly. Figure <xref ref-type="fig" rid="F5">5</xref> plots the memory requirements of BFCounter, Jellyfish and the naive version. The increase in memory levels off for BFCounter after about 7-fold coverage, whereas for the naive version and Jellyfish the memory increases steadily as the number of <italic>k</italic>-mers grows.</p>
      <fig id="F5" position="float">
        <label>Figure 5</label>
        <caption>
          <p><bold>Memory usage</bold>. The memory usage of the three programs at different coverage levels (Chromosome 21 data). Note that Jellyfish and the naive counter are storing <italic>all k</italic>-mers while BFCounter filters out most unique <italic>k</italic>-mers without storing them explicitly in memory. The memory usage of BFCounter and the naive version roughly mimic the shape for the number of filtered <italic>k</italic>-mers in Figure 3. The discrete jumps in the memory usage of Jellyfish are due to implementation details as the size of the hash table has to be a power of 2.</p>
        </caption>
        <graphic xlink:href="1471-2105-12-333-5"/>
      </fig>
      <p>Table <xref ref-type="table" rid="T1">1</xref> presents the memory and time requirements for the three methods when applied to the second data set (40-fold coverage of a human genome with 36 bp reads). For this analysis we set the <italic>k</italic>-mer length <italic>k </italic>= 25, which strikes a balance between the number of <italic>k</italic>-mers produced by each read, here 11, and the specificity of the <italic>k</italic>-mers. Although for this data set the average basepair coverage is fixed, the <italic>k</italic>-mer coverage decreases with <italic>k</italic>. On the other hand increasing <italic>k </italic>gives more observed <italic>k</italic>-mers, since sequencing errors can generate up to <italic>k </italic>unique <italic>k</italic>-mers.</p>
      <table-wrap id="T1" position="float">
        <label>Table 1</label>
        <caption>
          <p>Memory usage and Time for whole genome data</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th align="left">Program</th>
              <th align="center">Time (hrs)</th>
              <th align="center">Memory (GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">BFCounter</td>
              <td align="center">23.82</td>
              <td align="center">42</td>
            </tr>
            <tr>
              <td align="left">Jellyfish</td>
              <td align="center">8.03</td>
              <td align="center">71</td>
            </tr>
            <tr>
              <td align="left">Naive*</td>
              <td align="center">&gt;26.38</td>
              <td align="center">&gt;128</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Memory and time usage for the 1000 Genomes data set (40-fold coverage of individual NA19240). *The naive version ran out of memory after processing 84.7% of the reads.</p>
        </table-wrap-foot>
      </table-wrap>
      <p>There are 12.18 billion <italic>k</italic>-mers present in the sequencing reads, of which 9.35 billion are unique and 2.83 billion have coverage of two or greater (compared to 2.37 billion distinct 25-mers in the hg18 genome sequence). When BFCounter was run, about 0.5 billion of the unique <italic>k</italic>-mers were stored in the hash table after the first phase which corresponds to a 5.3% false positive rate for the Bloom filter. Thus, BFCounter stored 27% of the original <italic>k</italic>-mers after the first pass, and this was cut to 23% after false positives were removed.</p>
      <p>As may be seen from the table, BFCounter uses considerably less memory than either Jellyfish or the naive hash table method. Indeed the naive method ran out of memory and was unable to complete. However, BFCounter takes approximately three times longer to run as Jellyfish. Part of the difference in speed is due to BFCounter taking a second pass through the data to obtain exact <italic>k</italic>-mer counts (which may not be essential for all applications).</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>Counting <italic>k</italic>-mers from sequencing data is an essential component of many recent methods for genome assembly from short read sequence data. However, in current data sets, it is frequently the case that more than half of the reads contain errors and are observed just a single time. Since these error-containing <italic>k</italic>-mers are so numerous, they can overwhelm the memory capacity of available high-performance machines, and they increase the computational complexity of downstream analysis.</p>
    <p>In this paper, we describe a straightforward application of the Bloom filter data structure to help identify and store the reads that are present more than once (or more than <italic>n </italic>times) in a data set, and are therefore far more likely to be correct. By doing so, we achieve greatly reduced memory requirements compared to a naive but memory-efficient hash table method, as well as to Jellyfish (which has been highly optimized for memory efficiency, while storing all <italic>k</italic>-mers). For many applications, it may be sufficient to simply ignore the unique <italic>k</italic>-mers (as was done for the panda genome); alternatively, users may prefer to "correct" reads by comparing unique <italic>k</italic>-mers to common <italic>k</italic>-mers [<xref ref-type="bibr" rid="B11">11</xref>-<xref ref-type="bibr" rid="B14">14</xref>]. In summary, the approach presented here could be straightforwardly incorporated into a wide variety of algorithms that start by counting <italic>k</italic>-mers.</p>
    <p>Our method trades off reduced memory usage for an increase in processing time. In many cases the memory limitation is a hard threshold and the counting of <italic>k</italic>-mers is only run once and a fixed set of <italic>k</italic>-mers is stored for future computation. For genome assembly methods the construction of de Bruijn graphs dominates memory consumption [<xref ref-type="bibr" rid="B7">7</xref>] and the time for completion can be several days [<xref ref-type="bibr" rid="B13">13</xref>], depending on the amount of postprocessing.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>PM and JKP contributed ideas and participated in writing this article. PM designed the algorithm, implemented the software and ran the experiments. Both authors read and approved the final manuscript.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was funded by a grant from the National Institutes of Health: MH084703. JKP is supported by the Howard Hughes Medical Institute.</p>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>We thank Guillaume Marçais for help with running Jellyfish, and Jean-Baptiste Veyrieras and members of the Gilad, Pritchard, Przeworski and Stephens labs for helpful discussions.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Baird</surname>
          <given-names>NA</given-names>
        </name>
        <name>
          <surname>Etter</surname>
          <given-names>PD</given-names>
        </name>
        <name>
          <surname>Atwood</surname>
          <given-names>TS</given-names>
        </name>
        <name>
          <surname>Currey</surname>
          <given-names>MC</given-names>
        </name>
        <name>
          <surname>Shiver</surname>
          <given-names>AL</given-names>
        </name>
        <name>
          <surname>Lewis</surname>
          <given-names>ZA</given-names>
        </name>
        <name>
          <surname>Selker</surname>
          <given-names>EU</given-names>
        </name>
        <name>
          <surname>Cresko</surname>
          <given-names>WA</given-names>
        </name>
        <name>
          <surname>Johnson</surname>
          <given-names>EA</given-names>
        </name>
        <article-title>Rapid SNP Discovery and Genetic Mapping Using Sequenced RAD Markers</article-title>
        <source>PLoS ONE</source>
        <year>2008</year>
        <volume>3</volume>
        <issue>10</issue>
        <fpage>e3376</fpage>
        <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0003376">http://dx.doi.org/10.1371/journal.pone.0003376</ext-link>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0003376</pub-id>
        <pub-id pub-id-type="pmid">18852878</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="other">
        <name>
          <surname>Andolfatto</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Davison</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Erezyilmaz</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Hu</surname>
          <given-names>TT</given-names>
        </name>
        <name>
          <surname>Mast</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Sunayama-Morita</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Stern</surname>
          <given-names>DL</given-names>
        </name>
        <article-title>Multiplexed shotgun genotyping for rapid and efficient genetic mapping</article-title>
        <source>Genome Research</source>
        <year>2011</year>
        <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/early/2011/02/28/gr.115402.110.abstract">http://genome.cshlp.org/content/early/2011/02/28/gr.115402.110.abstract</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Pevzner</surname>
          <given-names>PA</given-names>
        </name>
        <name>
          <surname>Tang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>MS</given-names>
        </name>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proceedings of the National Academy of Sciences of the United States of America</source>
        <year>2001</year>
        <volume>98</volume>
        <issue>17</issue>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.pnas.org/content/98/17/9748.abstract">http://www.pnas.org/content/98/17/9748.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zerbino</surname>
          <given-names>DR</given-names>
        </name>
        <name>
          <surname>Birney</surname>
          <given-names>E</given-names>
        </name>
        <article-title>Velvet: Algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/18/5/821.abstract">http://genome.cshlp.org/content/18/5/821.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1101/gr.074492.107</pub-id>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Butler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>MacCallum</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Kleber</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Shlyakhter</surname>
          <given-names>IA</given-names>
        </name>
        <name>
          <surname>Belmonte</surname>
          <given-names>MK</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>ALLPATHS: De novo assembly of whole-genome shotgun microreads</article-title>
        <source>Genome Research</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>5</issue>
        <fpage>810</fpage>
        <lpage>820</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/18/5/810.abstract">http://genome.cshlp.org/content/18/5/810.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1101/gr.7337908</pub-id>
        <pub-id pub-id-type="pmid">18340039</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Simpson</surname>
          <given-names>JT</given-names>
        </name>
        <name>
          <surname>Wong</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Jackman</surname>
          <given-names>SD</given-names>
        </name>
        <name>
          <surname>Schein</surname>
          <given-names>JE</given-names>
        </name>
        <name>
          <surname>Jones</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Birol</surname>
          <given-names>I</given-names>
        </name>
        <article-title>ABySS: A parallel assembler for short read sequence data</article-title>
        <source>Genome Research</source>
        <year>2009</year>
        <volume>19</volume>
        <issue>6</issue>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/19/6/1117.abstract">http://genome.cshlp.org/content/19/6/1117.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1101/gr.089532.108</pub-id>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Zhu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Ruan</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Qian</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Fang</surname>
          <given-names>X</given-names>
        </name>
        <name>
          <surname>Shi</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Shan</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kristiansen</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Li</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Yang</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>J</given-names>
        </name>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome Research</source>
        <year>2010</year>
        <volume>20</volume>
        <issue>2</issue>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/20/2/265.abstract">http://genome.cshlp.org/content/20/2/265.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Marçais</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Kingsford</surname>
          <given-names>C</given-names>
        </name>
        <article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>6</issue>
        <fpage>764</fpage>
        <lpage>770</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/27/6/764.abstract">http://bioinformatics.oxfordjournals.org/content/27/6/764.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr011</pub-id>
        <pub-id pub-id-type="pmid">21217122</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="book">
        <name>
          <surname>Knuth</surname>
          <given-names>DE</given-names>
        </name>
        <source>The art of computer programming, sorting and searching</source>
        <year>1998</year>
        <volume>3</volume>
        <edition>2</edition>
        <publisher-name>Redwood City, CA, USA: Addison Wesley Longman Publishing Co., Inc</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Conway</surname>
          <given-names>TC</given-names>
        </name>
        <name>
          <surname>Bromage</surname>
          <given-names>AJ</given-names>
        </name>
        <article-title>Succinct data structures for assembling large genomes</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>4</issue>
        <fpage>479</fpage>
        <lpage>486</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/27/4/479.abstract">http://bioinformatics.oxfordjournals.org/content/27/4/479.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq697</pub-id>
        <pub-id pub-id-type="pmid">21245053</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Li</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Fan</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Tian</surname>
          <given-names>G</given-names>
        </name>
        <etal/>
        <article-title>The sequence and de novo assembly of the giant panda genome</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>463</volume>
        <issue>7279</issue>
        <fpage>311</fpage>
        <lpage>317</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature08696">http://dx.doi.org/10.1038/nature08696</ext-link>
        <pub-id pub-id-type="doi">10.1038/nature08696</pub-id>
        <pub-id pub-id-type="pmid">20010809</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kelley</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Schatz</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Salzberg</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Quake: quality-aware detection and correction of sequencing errors</article-title>
        <source>Genome Biology</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>11</issue>
        <fpage>R116</fpage>
        <ext-link ext-link-type="uri" xlink:href="http://genomebiology.com/2010/11/11/R116">http://genomebiology.com/2010/11/11/R116</ext-link>
        <pub-id pub-id-type="pmid">21114842</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gnerre</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>MacCallum</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Przybylski</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Ribeiro</surname>
          <given-names>FJ</given-names>
        </name>
        <name>
          <surname>Burton</surname>
          <given-names>JN</given-names>
        </name>
        <name>
          <surname>Walker</surname>
          <given-names>BJ</given-names>
        </name>
        <name>
          <surname>Sharpe</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Hall</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Shea</surname>
          <given-names>TP</given-names>
        </name>
        <name>
          <surname>Sykes</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Berlin</surname>
          <given-names>AM</given-names>
        </name>
        <name>
          <surname>Aird</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Costello</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Daza</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Williams</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Nicol</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Gnirke</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Nusbaum</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Lander</surname>
          <given-names>ES</given-names>
        </name>
        <name>
          <surname>Jaffe</surname>
          <given-names>DB</given-names>
        </name>
        <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>
        <source>Proceedings of the National Academy of Sciences</source>
        <year>2011</year>
        <volume>108</volume>
        <issue>4</issue>
        <fpage>1513</fpage>
        <lpage>1518</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.pnas.org/content/108/4/1513.abstract">http://www.pnas.org/content/108/4/1513.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1073/pnas.1017351108</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Shi</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Schmidt</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Liu</surname>
          <given-names>W</given-names>
        </name>
        <name>
          <surname>Müller-Wittig</surname>
          <given-names>W</given-names>
        </name>
        <article-title>A Parallel Algorithm for Error Correction in High-Throughput Short-Read Data on CUDA-Enabled Graphics Hardware</article-title>
        <source>Journal of Computational Biology</source>
        <year>2010</year>
        <volume>17</volume>
        <issue>4</issue>
        <fpage>603</fpage>
        <lpage>615</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://www.liebertonline.com/doi/abs/10.1089/cmb.2009.0062">http://www.liebertonline.com/doi/abs/10.1089/cmb.2009.0062</ext-link>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0062</pub-id>
        <pub-id pub-id-type="pmid">20426693</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="book">
        <name>
          <surname>Bar-Yossef</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Jayram</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Kumar</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Sivakumar</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Trevisan</surname>
          <given-names>L</given-names>
        </name>
        <person-group person-group-type="editor">Rolim J, Vadhan S</person-group>
        <article-title>Counting Distinct Elements in a Data Stream</article-title>
        <source>Randomization and Approximation Techniques in Computer Science, Volume 2483 of Lecture Notes in Computer Science</source>
        <year>2002</year>
        <publisher-name>Springer Berlin/Heidelberg</publisher-name>
        <fpage>952</fpage>
        <lpage>952</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/3-540-45726-7_1">http://dx.doi.org/10.1007/3-540-45726-7_1</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bloom</surname>
          <given-names>BH</given-names>
        </name>
        <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>
        <source>Commun ACM</source>
        <year>1970</year>
        <volume>13</volume>
        <fpage>422</fpage>
        <lpage>426</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://doi.acm.org/10.1145/362686.362692">http://doi.acm.org/10.1145/362686.362692</ext-link>
        <pub-id pub-id-type="doi">10.1145/362686.362692</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Stranneheim</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Käller</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Allander</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Andersson</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Arvestad</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Lundeberg</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Classification of DNA sequences using Bloom filters</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>13</issue>
        <fpage>1595</fpage>
        <lpage>1600</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/content/26/13/1595.abstract">http://bioinformatics.oxfordjournals.org/content/26/13/1595.abstract</ext-link>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq230</pub-id>
        <pub-id pub-id-type="pmid">20472541</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Krishnamurthy</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Buhler</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Chamberlain</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Franklin</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gyang</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Jacob</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Lancaster</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Biosequence Similarity Search on the Mercury System</article-title>
        <source>The Journal of VLSI Signal Processing</source>
        <year>2007</year>
        <volume>49</volume>
        <fpage>101</fpage>
        <lpage>121</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/s11265-007-0087-0">http://dx.doi.org/10.1007/s11265-007-0087-0</ext-link>
        <pub-id pub-id-type="doi">10.1007/s11265-007-0087-0</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Broder</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mitzenmacher</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Network Applications of Bloom Filters: A Survey</article-title>
        <source>Internet Mathematics</source>
        <year>2004</year>
        <volume>1</volume>
        <issue>4</issue>
        <fpage>485</fpage>
        <lpage>509</lpage>
        <pub-id pub-id-type="doi">10.1080/15427951.2004.10129096</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fan</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Cao</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Almeida</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Broder</surname>
          <given-names>AZ</given-names>
        </name>
        <article-title>Summary cache: a scalable wide-area web cache sharing protocol</article-title>
        <source>IEEE/ACM Trans Netw</source>
        <year>2000</year>
        <volume>8</volume>
        <fpage>281</fpage>
        <lpage>293</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/90.851975">http://dx.doi.org/10.1109/90.851975</ext-link>
        <pub-id pub-id-type="doi">10.1109/90.851975</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="other">
        <name>
          <surname>Pagh</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Pagh</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Rao</surname>
          <given-names>SS</given-names>
        </name>
        <article-title>An optimal Bloom filter replacement</article-title>
        <source>Proceedings of the sixteenth annual ACM-SIAM symposium on Discrete algorithms, SODA '05, Philadelphia, PA, USA: Society for Industrial and Applied Mathematics</source>
        <year>2005</year>
        <fpage>823</fpage>
        <lpage>829</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://portal.acm.org/citation.cfm?id=1070432.1070548">http://portal.acm.org/citation.cfm?id=1070432.1070548</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="book">
        <name>
          <surname>Purcell</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Harris</surname>
          <given-names>T</given-names>
        </name>
        <person-group person-group-type="editor">Fraigniaud P</person-group>
        <article-title>Non-blocking Hashtables with Open Addressing</article-title>
        <source>Distributed Computing, Volume 3724 of Lecture Notes in Computer Science</source>
        <year>2005</year>
        <publisher-name>Springer Berlin/Heidelberg</publisher-name>
        <fpage>108</fpage>
        <lpage>121</lpage>
        <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/11561927_10">http://dx.doi.org/10.1007/11561927_10</ext-link>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <collab>The 1000 Genomes Project Consortium</collab>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <issue>7319</issue>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="doi">10.1038/nature09534</pub-id>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
