<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7493873</article-id>
    <article-id pub-id-type="publisher-id">3586</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-020-03586-3</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Variable-order reference-free variant discovery with the Burrows-Wheeler Transform</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Prezza</surname>
          <given-names>Nicola</given-names>
        </name>
        <address>
          <email>nicola.prezza@di.unipi.it</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pisanti</surname>
          <given-names>Nadia</given-names>
        </name>
        <address>
          <email>pisanti@di.unipi.it</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sciortino</surname>
          <given-names>Marinella</given-names>
        </name>
        <address>
          <email>marinella.sciortino@unipa.it</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0001-5075-1214</contrib-id>
        <name>
          <surname>Rosone</surname>
          <given-names>Giovanna</given-names>
        </name>
        <address>
          <email>giovanna.rosone@unipi.it</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.5395.a</institution-id><institution-id institution-id-type="ISNI">0000 0004 1757 3729</institution-id><institution>Dipartimento di Informatica, Università di Pisa, </institution></institution-wrap>Largo B. Pontecorvo, 3, Pisa, Italy </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.10776.37</institution-id><institution-id institution-id-type="ISNI">0000 0004 1762 5517</institution-id><institution>Dipartimento di Matematica e Informatica, Università di Palermo, </institution></institution-wrap>Via Archirafi, 34, Palermo, Italy </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>16</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>16</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>21</volume>
    <issue>Suppl 8</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</issue-sponsor>
    <elocation-id>260</elocation-id>
    <history>
      <date date-type="received">
        <day>1</day>
        <month>6</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>8</day>
        <month>6</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">In [Prezza et al., AMB 2019], a new reference-free and alignment-free framework for the detection of SNPs was suggested and tested. The framework, based on the Burrows-Wheeler Transform (BWT), significantly improves sensitivity and precision of previous de Bruijn graphs based tools by overcoming several of their limitations, namely: (i) the need to establish a fixed value, usually small, for the order <italic>k</italic>, (ii) the loss of important information such as <italic>k</italic>-mer coverage and adjacency of <italic>k</italic>-mers within the same read, and (iii) bad performance in repeated regions longer than <italic>k</italic> bases. The preliminary tool, however, was able to identify only SNPs and it was too slow and memory consuming due to the use of additional heavy data structures (namely, the Suffix and LCP arrays), besides the BWT.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">In this paper, we introduce a new algorithm and the corresponding tool ebwt2InDel that (i) extend the framework of [Prezza et al., AMB 2019] to detect also INDELs, and (ii) implements recent algorithmic findings that allow to perform the whole analysis using just the BWT, thus reducing the working space by one order of magnitude and allowing the analysis of full genomes. Finally, we describe a simple strategy for effectively parallelizing our tool for SNP detection only. On a 24-cores machine, the parallel version of our tool is one order of magnitude faster than the sequential one. The tool ebwt2InDel is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/nicolaprezza/ebwt2InDel">github.com/nicolaprezza/ebwt2InDel</ext-link>.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">Results on a synthetic dataset covered at 30x (Human chromosome 1) show that our tool is indeed able to find up to 83% of the SNPs and 72% of the existing INDELs. These percentages considerably improve the 71% of SNPs and 51% of INDELs found by the state-of-the art tool based on de Bruijn graphs. We furthermore report results on larger (real) Human whole-genome sequencing experiments. Also in these cases, our tool exhibits a much higher sensitivity than the state-of-the art tool.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>SNP</kwd>
      <kwd>INDEL</kwd>
      <kwd>BWT</kwd>
      <kwd>Alignment-free</kwd>
      <kwd>Assembly-free</kwd>
    </kwd-group>
    <conference xlink:href="http://bioinformatics.it/">
      <conf-name>Annual Meeting of the Bioinformatics Italian Society (BITS 2019)</conf-name>
      <conf-acronym>BITS 2019</conf-acronym>
      <conf-loc>Palermo, Italy</conf-loc>
      <conf-date>26-28 June 2019</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Variant calling has become a fundamental task in genomics and metagenomics analyses. With <italic>Variant Calling</italic> is meant the process of identifying variants associated with an individual, or trait, or population, from genomic data. The most typical workflow for variant calling downstream of a genome(s) or exome(s) sequencing, is to map the obtained reads onto a reference genome by means of some alignment tool, and then highlight loci where the reads differ from the reference. Such mapping, however, is time consuming, error prone, and it can even be unfeasible when a reference genome is not available (in this case the analysis should start with an assembly process that reconstructs the genomes before comparing/analysing them, but this is often out of reach in practice for several computational and experimental reasons). In this scenario, there has been a growing interest in <italic>reference-free</italic> (and assembly-free) variant calling methods, that perform their task directly on the raw reads data [<xref ref-type="bibr" rid="CR1">1</xref>–<xref ref-type="bibr" rid="CR7">7</xref>]. In the literature one can find reference-free methods and tools for detecting SNPs [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR4">4</xref>, <xref ref-type="bibr" rid="CR7">7</xref>, <xref ref-type="bibr" rid="CR8">8</xref>], small INDELs [<xref ref-type="bibr" rid="CR4">4</xref>, <xref ref-type="bibr" rid="CR8">8</xref>, <xref ref-type="bibr" rid="CR9">9</xref>], sequencing errors [<xref ref-type="bibr" rid="CR10">10</xref>–<xref ref-type="bibr" rid="CR12">12</xref>], rearrangement breakpoints [<xref ref-type="bibr" rid="CR13">13</xref>] in genomic data, haplotype assembly [<xref ref-type="bibr" rid="CR14">14</xref>–<xref ref-type="bibr" rid="CR16">16</xref>], as well as alternative splicing events [<xref ref-type="bibr" rid="CR2">2</xref>] on RNA-Seq data.</p>
    <p>Most of the above mentioned effective tools (e.g. [<xref ref-type="bibr" rid="CR1">1</xref>–<xref ref-type="bibr" rid="CR4">4</xref>, <xref ref-type="bibr" rid="CR13">13</xref>, <xref ref-type="bibr" rid="CR17">17</xref>, <xref ref-type="bibr" rid="CR18">18</xref>]) in variant discovery use a de Bruijn graph (dBG), i.e. a directed graph in which the set of nodes corresponds to the set of <italic>k</italic>-mers contained in the reads and two <italic>k</italic>-mers are connected by an edge if (i) they perfectly overlap on <italic>k</italic>−1 nucleotides, and (ii) the corresponding (<italic>k</italic>+1)-mer obtained by concatenating them occurs in the dataset (usually, with a fixed minimum frequency). The identification of variants is carried out by detecting and analyzing <italic>bubbles</italic> in dBG, i.e. pairs of disjoint paths sharing the same source node and target node. The advantages of using dBG include the formalization of several biologically interesting features through specific properties of paths in the graph. The drawback of these dBG representations is the need to set in advance the value of the parameter <italic>k</italic> and the lossy constraint of considering <italic>k</italic>-mers rather than representing the actual whole collection of reads. In particular, coverage information of each <italic>k</italic>-mer, as well as the fact that two or more <italic>k</italic>-mers might belong to the same read (and are thus adjacent in the genome), are important pieces of information that are not usually stored in the de Bruijn graph. The limitation of fixing <italic>k</italic> is also present in [<xref ref-type="bibr" rid="CR19">19</xref>, <xref ref-type="bibr" rid="CR20">20</xref>] where <italic>k</italic>-mers are indexed, and in the methods of [<xref ref-type="bibr" rid="CR21">21</xref>, <xref ref-type="bibr" rid="CR22">22</xref>] that use a <italic>Gk array</italic>, while other methods that use suffix array based data structures (like PgSA [<xref ref-type="bibr" rid="CR23">23</xref>]), instead, do not have a fixed <italic>k</italic>-mer size.</p>
    <p>The Burrows-Wheeler Transform (BWT) of a text <italic>T</italic> is a suitable permutation of the letters of <italic>T</italic>, and it has become a fundamental tool for the design of self-indexing data structures. This permutation has been intensively studied from a theoretical and combinatorial viewpoints [<xref ref-type="bibr" rid="CR24">24</xref>–<xref ref-type="bibr" rid="CR30">30</xref>] and has found important and successful applications in several areas in science and engineering [<xref ref-type="bibr" rid="CR7">7</xref>, <xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR31">31</xref>–<xref ref-type="bibr" rid="CR40">40</xref>], but so far it was not yet used <italic>per se</italic> for direct detection of variants. The eBWT is an extension of the BWT to collections of strings that has been introduced in [<xref ref-type="bibr" rid="CR41">41</xref>]. In [<xref ref-type="bibr" rid="CR42">42</xref>], the authors described fast and RAM-efficient methods capable of computing the eBWT of sequence collections of the size encountered in human whole genome sequencing experiments. The eBWT of a read set can be built by using e.g. [<xref ref-type="bibr" rid="CR43">43</xref>–<xref ref-type="bibr" rid="CR47">47</xref>]. In [<xref ref-type="bibr" rid="CR48">48</xref>] the eBWT was used to index reads from the <italic>1000 Genomes Project</italic> [<xref ref-type="bibr" rid="CR49">49</xref>] in order to support <italic>k</italic>-mer search queries. An eBWT-based compressed index of sets of reads has also been suggested as a basis for both RNA-Seq [<xref ref-type="bibr" rid="CR50">50</xref>] and metagenomic [<xref ref-type="bibr" rid="CR51">51</xref>, <xref ref-type="bibr" rid="CR52">52</xref>] analyses.</p>
    <p>In this paper, we present a new eBWT based strategy for SNPs and INDELs detection in a dataset of “raw reads”. Unlike the usual methods, our tool takes as input the (extended) Burrows-Wheeler Transform of the read collection. The strength of BWT-based indexing for variant calling stems from the facts that the BWT tends to group symbols that share the same right context into <italic>runs</italic> of letters and, remarkably, that the original text can be reconstructed from it (thus allowing the BWT to represent the original string without loss of information), see [<xref ref-type="bibr" rid="CR24">24</xref>, <xref ref-type="bibr" rid="CR26">26</xref>, <xref ref-type="bibr" rid="CR53">53</xref>–<xref ref-type="bibr" rid="CR55">55</xref>]. In [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>] we exploited this property and introduced the <italic>Positional Clustering</italic> framework via a series of theoretical results that overall led to the characterization of SNPs as clusters in the BWT of the reads collection, and to detect such clusters using two additional data structures: the <italic>Longest Common Prefix Array</italic> (LCP) and the <italic>Suffix Array</italic> (SA) of the dataset. We thus implemented a SNPs calling tool that we experimentally validated: its accuracy in terms of sensitivity and precision was very promising and competitive, with running time and memory usage comparable when limited to the actual search phase. However, when taking into account the preprocessing phase, and thus the cost of computing LCP array and SA (in addition to the eBWT), the positional clustering based tool for SNPs detection resulted to be overall computationally inefficient. In this work, we overcome the above limitation by using a recent algorithmic result [<xref ref-type="bibr" rid="CR56">56</xref>] that shows how to extract the LCP<italic>on-the-fly</italic> from the eBWT. Moreover, combinatorial properties of the (LF mapping of the) BWT are used to replace the Suffix Array. As a result, we wrap up a new algorithm that exploits the positional clustering for variant detection using the BWT only, and hence reduces the working space by an order of magnitude. Furthermore, in the resulting tool <sc>EBWT2INDEL</sc>, we extend the positional clustering algorithmic framework to the detection of INDELs. Experimental results show that our tool exhibits a much higher sensitivity than the state-of-the art tool.</p>
  </sec>
  <sec id="Sec2">
    <title>Methods</title>
    <sec id="Sec3">
      <title>Definitions</title>
      <p>Consider a string <italic>s</italic> of length |<italic>s</italic>| from some finite ordered alphabet <italic>Σ</italic>={<italic>c</italic><sub>1</sub>,<italic>c</italic><sub>2</sub>,…,<italic>c</italic><sub><italic>σ</italic></sub>} of size <italic>σ</italic>. In this paper, we will work only with the DNA alphabet <italic>Σ</italic><sub><italic>DNA</italic></sub>={<italic>$</italic>,<italic>A</italic>,<italic>C</italic>,<italic>G</italic>,<italic>T</italic>} (augmented with a special end-marker <italic>$</italic>, read below), therefore <italic>σ</italic> will be assumed to be constant with respect to |<italic>s</italic>|. We assume a total order &lt; on alphabet characters such that <italic>$</italic>&lt;<italic>c</italic> for all <italic>c</italic>∈<italic>Σ</italic>∖{<italic>$</italic>}. We denote the characters of a string <italic>s</italic> by <italic>s</italic>[1],<italic>s</italic>[2],…,<italic>s</italic>[|<italic>s</italic>|], where |<italic>s</italic>| is the length of <italic>s</italic>. A <italic>substring</italic> of <italic>s</italic> is denoted as <italic>s</italic>[<italic>i</italic>,<italic>j</italic>]=<italic>s</italic>[<italic>i</italic>]⋯<italic>s</italic>[<italic>j</italic>], with <italic>s</italic>[..<italic>j</italic>]=<italic>s</italic>[1,<italic>j</italic>] being called a <italic>prefix</italic> and <italic>s</italic>[<italic>i</italic>..]=<italic>s</italic>[<italic>i</italic>,|<italic>s</italic>|] a <italic>suffix</italic> of <italic>s</italic>.</p>
      <p>Consider now a string <italic>s</italic> of length <italic>n</italic> terminated by the end-marker <italic>$</italic>. If we imagine placing the suffixes of <italic>s</italic> in lexicographic order <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$s[i_{1}..] &lt; \dots &lt; s[i_{n}..]$\end{document}</tex-math><mml:math id="M2"><mml:mi>s</mml:mi><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>..</mml:mi><mml:mo>]</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>⋯</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>s</mml:mi><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mi>..</mml:mi><mml:mo>]</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq1.gif"/></alternatives></inline-formula>, then the Burrows-Wheeler Transform (BWT) of <italic>s</italic> [<xref ref-type="bibr" rid="CR57">57</xref>] is defined as the unique permutation bwt(<italic>s</italic>) of <italic>s</italic> such that bwt(<italic>s</italic>)[<italic>j</italic>]=<italic>s</italic>[<italic>i</italic><sub><italic>j</italic></sub>−1] if <italic>i</italic><sub><italic>j</italic></sub>&gt;1, and bwt(<italic>s</italic>)[<italic>j</italic>]=<italic>$</italic> otherwise. Each symbol in the BWT is therefore associated with a suffix of the string. Note that, from this definition, the symbols in <italic>s</italic> preceding the same right context <italic>w</italic>∈<italic>Σ</italic><sup>∗</sup> (i.e. <italic>w</italic> is a common prefix of the suffixes starting after those symbols) are consecutive in the BWT. Perhaps, the two most important of its many interesting properties are that (i) the BWT is reversible, in the sense that <italic>s</italic> can be reconstructed from <italic>b</italic><italic>w</italic><italic>t</italic>(<italic>s</italic>) with no additional information [<xref ref-type="bibr" rid="CR58">58</xref>] and (ii) the clustering effect of the produced output, i.e. the BWT tends to group together symbols that occur in similar contexts in the input string, making the output easy and fast to compress (see, for instance, [<xref ref-type="bibr" rid="CR53">53</xref>, <xref ref-type="bibr" rid="CR59">59</xref>]).</p>
      <p>We now consider the generalization of the above notions to a collection <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}=\{R_{1},R_{2},\ldots,R_{m}\}$\end{document}</tex-math><mml:math id="M4"><mml:mi mathvariant="script">S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq2.gif"/></alternatives></inline-formula> of <italic>m</italic> strings (also called <italic>reads</italic> in what follows, due to our target application). We assume that each string is terminated by the end-marker character <italic>$</italic> (common to all strings). In this generalized setting, <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$n = \sum _{i=1}^{m} |R_{i}|$\end{document}</tex-math><mml:math id="M6"><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq3.gif"/></alternatives></inline-formula>, i.e. the sum of the lengths of all strings in <inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M8"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq4.gif"/></alternatives></inline-formula>. One way to generalize the notion of BWT to such a collection of strings, while also keeping its desirable properties, is to imagine that the end-markers ending the strings are distinct, i.e. that each member <italic>R</italic><sub><italic>i</italic></sub> of the collection is terminated by a distinct end-marker<xref ref-type="fn" rid="Fn1">1</xref><italic>$</italic><sub><italic>i</italic></sub> such that <italic>$</italic><sub>1</sub>&lt;…&lt;<italic>$</italic><sub><italic>m</italic></sub>&lt;<italic>c</italic>, for any other <italic>c</italic>≠<italic>$</italic><sub><italic>i</italic></sub> of <italic>Σ</italic>. Then, as described above, we sort the suffixes of all strings in <inline-formula id="IEq5"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M10"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq5.gif"/></alternatives></inline-formula> and concatenate their preceding characters. The resulting string is called <italic>extended Burrows-Wheeler Transform</italic> (eBWT), see [<xref ref-type="bibr" rid="CR41">41</xref>, <xref ref-type="bibr" rid="CR42">42</xref>]. Another important property of the (e)BWT is the so-called <italic>LF mapping</italic>: the <italic>i</italic>-th occurrence of character <italic>c</italic> on the BWT and the first character of the <italic>i</italic>-th lexicographically-smallest suffix starting with <italic>c</italic> correspond to the same position in the input string (or collection of strings). We indicate with <italic>LF</italic> the function mapping eBWT positions to suffixes (in lexicographic order) as described above, and with <italic>FL</italic> its inverse (FL is also known as the <italic>Ψ</italic> array). The LF mapping stands at the core of the BWT’s reversibility property and of <italic>backward search</italic>, an elegant algorithm used on BWT-based indexes to find the range of suffixes prefixed by a given string. The basic step of backward search consists in finding, given the range of suffixes prefixed by a string <italic>p</italic>, the range of suffixes prefixed <italic>a</italic>·<italic>p</italic>, for any character <italic>a</italic>∈<italic>Σ</italic> (see [<xref ref-type="bibr" rid="CR58">58</xref>] for more details). On constant-sized alphabets (like our <italic>Σ</italic><sub><italic>DNA</italic></sub>), this step can be implemented in constant time. In this paper we will use backward search to efficiently find a consensus string among the strings preceding a given range of suffixes.</p>
      <p>The <italic>longest common prefix</italic> (LCP) array of <inline-formula id="IEq6"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M12"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq6.gif"/></alternatives></inline-formula> is the array <inline-formula id="IEq7"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {lcp}(\mathcal {S})$\end{document}</tex-math><mml:math id="M14"><mml:mtext mathvariant="sans-serif">lcp</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq7.gif"/></alternatives></inline-formula> of length <italic>n</italic>, such that <inline-formula id="IEq8"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {lcp}(\mathcal {S})[i]$\end{document}</tex-math><mml:math id="M16"><mml:mtext mathvariant="sans-serif">lcp</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq8.gif"/></alternatives></inline-formula>, with 2≤<italic>i</italic>≤<italic>n</italic>, is the length of the longest common prefix between the <italic>i</italic>-th and (<italic>i</italic>−1)-th lexicographically-smallest suffixes, and <inline-formula id="IEq9"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {lcp}(\mathcal {S})[1] = 0$\end{document}</tex-math><mml:math id="M18"><mml:mtext mathvariant="sans-serif">lcp</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq9.gif"/></alternatives></inline-formula>. If a unique end-marker <italic>$</italic> is used to end strings in <inline-formula id="IEq10"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M20"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq10.gif"/></alternatives></inline-formula>, then end-markers belonging to distinct strings are treated as different characters in the above definition. In what follows, we will simply write lcp[<italic>i</italic>] as a shorthand for <inline-formula id="IEq11"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {lcp}(\mathcal {S})[i]$\end{document}</tex-math><mml:math id="M22"><mml:mtext mathvariant="sans-serif">lcp</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq11.gif"/></alternatives></inline-formula> when <inline-formula id="IEq12"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M24"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq12.gif"/></alternatives></inline-formula> will be clear from the context.</p>
      <p>The problem we aim at solving in this paper is that of finding variants within a read set without mapping the reads onto the reference genome (alignment-free), and thus without actually needing a reference (reference-free). More formally, given as input the eBWT of a read set <inline-formula id="IEq13"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal S$\end{document}</tex-math><mml:math id="M26"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq13.gif"/></alternatives></inline-formula>, our task is to output frequent enough (i.e. covered-enough in the reads dataset) SNPs and INDELs <inline-formula id="IEq14"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$T_{1} \rightarrow T_{2}$\end{document}</tex-math><mml:math id="M28"><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq14.gif"/></alternatives></inline-formula>, with <inline-formula id="IEq15"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$T_{1}, T_{2} \in \Sigma _{DNA}^{*}$\end{document}</tex-math><mml:math id="M30"><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:msubsup><mml:mrow><mml:mi>Σ</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">DNA</mml:mtext></mml:mrow><mml:mrow><mml:mo>∗</mml:mo></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq15.gif"/></alternatives></inline-formula> (e.g. <italic>T</italic><sub>1</sub>=CGT and <italic>T</italic><sub>2</sub>=C means that the INDEL <inline-formula id="IEq16"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\text {\texttt {CGT}} \rightarrow \text {\texttt {C}}$\end{document}</tex-math><mml:math id="M32"><mml:mtext>CGT</mml:mtext><mml:mo>→</mml:mo><mml:mtext>C</mml:mtext></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq16.gif"/></alternatives></inline-formula> is present in the dataset) surrounded by a user-defined number of bases (in the example above, we may output the pair <inline-formula id="IEq17"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$(\mathtt {AT\underline {CGT}CT},\mathtt {AT\underline C CT})$\end{document}</tex-math><mml:math id="M34"><mml:mo>(</mml:mo><mml:mstyle mathvariant="monospace"><mml:mtext mathvariant="italic">AT</mml:mtext><mml:munder accentunder="false"><mml:mrow><mml:mtext mathvariant="italic">CGT</mml:mtext></mml:mrow><mml:mo accent="true">_</mml:mo></mml:munder><mml:mtext mathvariant="italic">CT</mml:mtext></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant="monospace"><mml:mtext mathvariant="italic">AT</mml:mtext><mml:munder accentunder="false"><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo accent="true">_</mml:mo></mml:munder><mml:mtext mathvariant="italic">CT</mml:mtext></mml:mstyle><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq17.gif"/></alternatives></inline-formula>, where the INDEL is underlined). Such procedure can be interpreted as a filtering process that isolates statistically-significant fragments containing variants (note that the output is considerably smaller than the input). This could be useful, e.g. as a pre-processing step to speed up subsequent alignment against a database containing known variants, or simply as a direct quantification of the number of variants in the input dataset (the output’s size is proportional to this number).</p>
    </sec>
    <sec id="Sec4">
      <title>Positional clustering</title>
      <p>A crucial property of the eBWT is that the symbols preceding suffixes that begin with some context <italic>w</italic> (a suitable <italic>w</italic> will be defined later) will result in a contiguous substring of <inline-formula id="IEq18"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {ebwt}(\mathcal {S})$\end{document}</tex-math><mml:math id="M36"><mml:mtext mathvariant="sans-serif">ebwt</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq18.gif"/></alternatives></inline-formula>. We call this substring a <italic>cluster</italic>. A similar concept has been used in [<xref ref-type="bibr" rid="CR60">60</xref>] for the reference-free compression of sequence quality scores and in [<xref ref-type="bibr" rid="CR52">52</xref>] for an alignment-free and assembly-free framework for metagenomic classification. The general idea is that if <italic>all</italic> symbols in a cluster associated to <italic>w</italic> are equal to a symbol <italic>c</italic>, then every occurrence of <italic>w</italic> in <inline-formula id="IEq19"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M38"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq19.gif"/></alternatives></inline-formula> is preceded by <italic>c</italic>. The opposite situation is more interesting for our purposes: if a cluster contains at least two distinct symbols and <italic>w</italic> is long enough, then those symbols may reflect a variant (e.g. a SNP or the right end of an INDEL) in the input dataset. We call <italic>positional clustering</italic> this variants characterization on the eBWT.</p>
      <p>Based on the above observation, in this paper we describe a reference-free and alignment-free tool able to find SNPs and INDELs in an input read set by analyzing just its eBWT. More precisely, the key observation at the core of our tool is that, since variants share the same right-context, they are clustered when we suffix-sort all the reads’ suffixes. As a consequence, the string <inline-formula id="IEq20"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {ebwt}(\mathcal {S})$\end{document}</tex-math><mml:math id="M40"><mml:mtext mathvariant="sans-serif">ebwt</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq20.gif"/></alternatives></inline-formula> can be partitioned in clusters (substrings), each containing the sequenced copies of a fixed position in the underlying (unknown) genome. If that position contains a variant in the read set (e.g. a bi-allelic site, a SNP, or an INDEL), then the cluster will contain more than one distinct symbol. The properties of eBWT clusters were studied in [<xref ref-type="bibr" rid="CR6">6</xref>], where the following definition was given: clusters are maximal substrings ebwt[<italic>i</italic>,<italic>j</italic>] such that the suffixes in the lexicographic range [<italic>i</italic>,<italic>j</italic>] are prefixed by a string (context) <italic>w</italic> that appears only once in the genome. In particular, <italic>w</italic> is chosen to be the shortest such prefix. When such a cluster can be defined (i.e. <italic>w</italic> does not fall in a repetitive region; note that this event is less frequent with longer reads), this definition guarantees that characters in ebwt[<italic>i</italic>,<italic>j</italic>] are the sequenced copies of a single genome position. At this point, one question arises naturally: given that the underlying genome is unknown, how can we compute the contexts <italic>w</italic> (and thus the clusters)? The following theorem, proven in [<xref ref-type="bibr" rid="CR6">6</xref>], answers the question: with high probability (dependent on the sequencing error rate), clusters correspond to maximal intervals ebwt[<italic>i</italic>,<italic>j</italic>] that do not contain local LCP minima, i.e. no index 1&lt;<italic>i</italic>≤<italic>r</italic>≤<italic>j</italic>&lt;<italic>n</italic> satisfies lcp[<italic>r</italic>−1]≥lcp[<italic>r</italic>]&lt;lcp[<italic>r</italic>+1]. In order to filter out clusters corresponding to short random contexts <italic>w</italic> (which are statistically not significant), also a minimum LCP is required: for some fixed <italic>k</italic><sub><italic>min</italic></sub> (by default, <italic>k</italic><sub><italic>min</italic></sub>=16), the suffixes in the cluster must share at least <italic>k</italic> characters (i.e. lcp[<italic>r</italic>]≥<italic>k</italic><sub><italic>min</italic></sub> for <italic>i</italic>≤<italic>r</italic>≤<italic>j</italic>). Note that this characterization does not need the underlying reference genome to be known, and thus allows us to find clusters with a simple linear scan of the LCP array. Importantly, and differently from tools using a context of fixed length (e.g. those based on de Bruijn graphs), the length |<italic>w</italic>| of our contexts is <italic>variable-order</italic> (i.e. dependent on the particular cluster, thus data driven and not fixed a priori), and can be up to the full read length for high-enough coverages and small-enough error rates.</p>
      <p>With our preliminary tool for SNPs detection, described in [<xref ref-type="bibr" rid="CR7">7</xref>], we showed that the positional clustering framework is indeed able to considerably improve the sensitivity of state-of-the-art tools based on de Bruijn graphs. This outcome was expected, since those tools (i) throw away important information such as the coverage of each <italic>k</italic>-mer and adjacency of <italic>k</italic>-mers inside the input sequenced fragments, and (ii) are not able to disambiguate repetitive regions longer than <italic>k</italic> (even if <italic>k</italic> could be much smaller than the read length). One important drawback of our tool, however, was the need to compute the generalized Suffix Array of the collection (required to efficiently extract contexts from the eBWT), as well as its eBWT and LCP array. This resulted in huge memory demandings: letting <italic>n</italic> be the total number of bases in the collection, the input alone took 7<italic>n</italic> bytes of space on disk. In this paper, we employ recent algorithmic findings described in [<xref ref-type="bibr" rid="CR56">56</xref>] and improve our tool so that it only needs the eBWT as input. Local LCP minima are computed on-the-fly by simulating a suffix tree traversal (using just the eBWT). Furthermore, we no longer need to compute the generalized Suffix Array, as contexts surrounding variants are extracted using the eBWT’s <italic>LF mapping</italic> property. Moreover, we extend our preliminary tool so that also INDELs can be detected. As a result, we are able to process much larger data sets and become competitive with existing alignment-free tools that find SNPs/INDELs within one or more read sets.</p>
    </sec>
    <sec id="Sec5">
      <title>Data structures</title>
      <p>In [<xref ref-type="bibr" rid="CR56">56</xref>], the authors showed that the LCP of a collection <inline-formula id="IEq21"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}$\end{document}</tex-math><mml:math id="M42"><mml:mi mathvariant="script">S</mml:mi></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq21.gif"/></alternatives></inline-formula> of total size <italic>n</italic> on alphabet [1,<italic>σ</italic>] can be computed from <inline-formula id="IEq22"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\textsf {ebwt}(\mathcal {S})$\end{document}</tex-math><mml:math id="M44"><mml:mtext mathvariant="sans-serif">ebwt</mml:mtext><mml:mo>(</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq22.gif"/></alternatives></inline-formula> in <inline-formula id="IEq23"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$O(n\log \sigma)$\end{document}</tex-math><mml:math id="M46"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>log</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq23.gif"/></alternatives></inline-formula> time using <inline-formula id="IEq24"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$O(n\log \sigma)$\end{document}</tex-math><mml:math id="M48"><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>log</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq24.gif"/></alternatives></inline-formula> bits of working space on top of the input and output size. The algorithm works by simulating a visit of the generalized suffix tree of the collection using just its eBWT. For each visited suffix tree node <italic>x</italic>, the algorithm induces the LCP values whose coordinates stand between the eBWT ranges of the children of <italic>x</italic>. At the end of the visit, all LCP values have been filled. Describing this algorithm is out of the scope of this article; the interested reader can find all the algorithmic details in [<xref ref-type="bibr" rid="CR56">56</xref>].</p>
      <p>We note that, in order to implement the positional clustering strategy, we do not require the whole LCP array: we just need to know which of its entries are larger than <italic>k</italic><sub><italic>min</italic></sub> and which are local minima, i.e. our goal is to compute two bitvectors <italic>K</italic><sub><italic>min</italic></sub>[1..<italic>n</italic>] and localMin[1..<italic>n</italic>] defined as <italic>K</italic><sub><italic>min</italic></sub>[<italic>i</italic>]=1 if and only if lcp[<italic>i</italic>]≥<italic>k</italic><sub><italic>min</italic></sub> and localMin[<italic>i</italic>]=1 if and only if lcp[<italic>i</italic>−1]≥lcp[<italic>i</italic>]&lt;lcp[<italic>i</italic>+1]. Similarly, for a fixed parameter <italic>k</italic><sub><italic>right</italic></sub> (by default, <italic>k</italic><sub><italic>right</italic></sub>=30) we compute an additional bitvector <italic>K</italic><sub><italic>right</italic></sub>[1..<italic>n</italic>] defined as <italic>K</italic><sub><italic>right</italic></sub>[<italic>i</italic>]=1 if and only if lcp[<italic>i</italic>]≥<italic>k</italic><sub><italic>right</italic></sub>. This bitvector will be used to know from which suffix to extract the <italic>k</italic><sub><italic>right</italic></sub> characters that will form the right-context of our output events (for more details, read the next section). It is easy to modify the algorithm of [<xref ref-type="bibr" rid="CR56">56</xref>] to compute these three bitvectors instead of the LCP array, and we do not describe the technical details here. By using the same data structures described in [<xref ref-type="bibr" rid="CR56">56</xref>] (a cache-efficient packed string on alphabet <italic>Σ</italic><sub><italic>DNA</italic></sub>), the total space used in RAM by our variant calling algorithm (which we will describe in the next subsection) is just 7<italic>n</italic> bits (including the bitvectors <italic>K</italic><sub><italic>min</italic></sub>,<italic>K</italic><sub><italic>right</italic></sub>, and localMin), i.e. less than the ASCII-encoded input dataset which, stored in fasta format, takes at least 8<italic>n</italic> bits of space on disk. This space doubles if the user wishes to include also the reverse-complemented dataset, a recommended operation that considerably improves the sensitivity and precision of the method (see [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>]).</p>
    </sec>
    <sec id="Sec6">
      <title>Variant calling algorithm</title>
      <p>The eBWT and arrays <italic>K</italic><sub><italic>min</italic></sub>,<italic>K</italic><sub><italic>right</italic></sub>, and localMin are all we need to find variants (i.e. SNPs and INDELs) in the input dataset. Figure <xref rid="Fig1" ref-type="fig">1</xref> illustrates the process of finding an INDEL (SNPs are found similarly, read below). As discussed above, an eBWT cluster is a maximal substring ebwt[<italic>i</italic>,<italic>j</italic>] such that <italic>K</italic><sub><italic>min</italic></sub>[<italic>r</italic>]=1 and localMin[<italic>r</italic>]=0 for all <italic>i</italic>≤<italic>r</italic>≤<italic>j</italic>. For each eBWT cluster ebwt[<italic>i</italic>,<italic>j</italic>] (in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, the cluster is highlighted in gray: TCCTC), we proceed as follows. (i) If the cluster does not contain at least two distinct letters, each occurring at least <italic>m</italic><italic>i</italic><italic>n</italic><sub><italic>cov</italic></sub> times (by default, <italic>m</italic><italic>i</italic><italic>n</italic><sub><italic>cov</italic></sub>=6; this is a parameter that can be modified using option -m), then we discard it. Otherwise, we proceed with the next step. (ii) For each pair (<italic>c</italic><sub>1</sub>,<italic>c</italic><sub>2</sub>) of distinct letters occurring at least <italic>m</italic><italic>i</italic><italic>n</italic><sub><italic>cov</italic></sub> times in the cluster we do the following:
<fig id="Fig1"><label>Fig. 1</label><caption><p>Strategy for finding SNPs/INDELs. <bold>1</bold> Underlyng (unknown) genotype, including an INDEL. <bold>2</bold> Input reads sequenced from the genotype (including sequencing errors). <bold>3</bold> eBWT, LCP, and contexts preceding (LEFT) and following (RIGHT) each eBWT character. In bold: LCP minima. In gray: eBWT cluster. Note that we explicitly compute only column eBWT (the other columns are shown only for illustrative purposes). LCP minima are computed on-the-fly, whereas contexts LEFT and RIGHT are reconstructed using backward search and the FL mapping, respectively. <bold>4</bold> Output INDEL <inline-formula id="IEq25"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathtt {TGC \rightarrow T}$\end{document}</tex-math><mml:math id="M50"><mml:mstyle mathvariant="monospace"><mml:mtext mathvariant="italic">TGC</mml:mtext><mml:mo>→</mml:mo><mml:mi>T</mml:mi></mml:mstyle></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq25.gif"/></alternatives></inline-formula>, extended by one nucleotide to the left and two to the right. Note that the output INDEL is left-shifted, whereas originally (in the unknown genotype) it was right-shifted. To call the INDEL, we (i) compute (via backward search) the two consensus sequences AT and ATGC of the two alleles’ left-contexts (i.e. the strings obtained by concatenating symbols in LEFT and eBWT), and (ii) align them, possibly allowing an INDEL to their right-end. In the figure, the best alignment is the one that deletes GC from ATGC. SNPs are computed similarly, the only difference being that the best alignment of the left-contexts does not introduce insertions nor deletions</p></caption><graphic xlink:href="12859_2020_3586_Fig1_HTML" id="MO1"/></fig><list list-type="bullet"><list-item><p>We compute a consensus <italic>L</italic><sub><italic>t</italic></sub>, for values <italic>t</italic>=1,2, of length at most <italic>M</italic>=<italic>k</italic><sub><italic>left</italic></sub>+<italic>m</italic><italic>a</italic><italic>x</italic><sub><italic>indel</italic></sub> – where by default <italic>k</italic><sub><italic>left</italic></sub>=31 (this is a parameter that can be modified using option -L) and <italic>m</italic><italic>a</italic><italic>x</italic><sub><italic>indel</italic></sub>=10 (this is a parameter that can be modified using option -g) – among suffixes of strings preceding and including character <italic>c</italic><sub><italic>t</italic></sub> in the eBWT (in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, the strings LEFT [<italic>r</italic>]·ebwt[<italic>r</italic>], for <italic>i</italic>≤<italic>r</italic>≤<italic>j</italic>). The consensus – which is defined to be the most frequent string preceding the variant – is computed using backward search: let ebwt[<italic>l</italic><sub>1</sub>,<italic>r</italic><sub>1</sub>] be the range obtained by left-extending ebwt[<italic>i</italic>,<italic>j</italic>] with letter <italic>c</italic><sub><italic>t</italic></sub>. Starting from ebwt[<italic>l</italic><sub>1</sub>,<italic>r</italic><sub>1</sub>], for <italic>M</italic>−1 times we extend the current eBWT range ebwt[<italic>l</italic><sub><italic>q</italic></sub>,<italic>r</italic><sub><italic>q</italic></sub>] (<inline-formula id="IEq26"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$q=1,\dots, M-1$\end{document}</tex-math><mml:math id="M52"><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq26.gif"/></alternatives></inline-formula>) with the most frequent letter in ebwt[<italic>l</italic><sub><italic>q</italic></sub>,<italic>r</italic><sub><italic>q</italic></sub>] (possibly stopping earlier if the range becomes empty). In the example reported in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, we have <italic>c</italic><sub>1</sub>=T,<italic>c</italic><sub>2</sub>=C and, by choosing <italic>k</italic><sub><italic>left</italic></sub>=2 and <italic>m</italic><italic>a</italic><italic>x</italic><sub><italic>indel</italic></sub>=2, we obtain <italic>L</italic><sub>1</sub>=AT and <italic>L</italic><sub>2</sub>=ATGC.</p></list-item><list-item><p>Using function FL, we extract a prefix <italic>R</italic> of <italic>k</italic><sub><italic>right</italic></sub> characters from the <italic>r</italic>-th smallest suffix for an arbitrary index <italic>i</italic>≤<italic>r</italic>≤<italic>j</italic> such that <italic>K</italic><sub><italic>right</italic></sub>[<italic>r</italic>]=1, where by default <italic>k</italic><sub><italic>right</italic></sub>=30 (this is a parameter that can be modified using option -R). In Fig. <xref rid="Fig1" ref-type="fig">1</xref>, we choose <italic>k</italic><sub><italic>right</italic></sub>=2; string <italic>R</italic> is extracted from array RIGHT (in the figure example, any index <italic>r</italic> in the cluster is valid) and corresponds to GC.</p></list-item><list-item><p>We find the alignment between <italic>L</italic><sub>1</sub> and <italic>L</italic><sub>2</sub> that minimizes the variant of edit distance where at most one insertion or deletion is allowed at the right-end of the two strings (and nowhere else). Since we know where the INDEL ends, the optimal alignment can be found in linear time. If the optimal alignment does not include INDELs, then the event is a SNP. If the optimal alignment introduces too many edits (by default 2, including the central SNP/INDEL; this is a parameter that can be modified using option -v), then the event is discarded. This is an additional filter that allows discarding left-borders of long repetitive regions, which differ in the contexts preceding the suffixes in the cluster and are therefore captured by the above strategy. In the example of Fig. <xref rid="Fig1" ref-type="fig">1</xref>, the optimal alignment is the one that deletes GC from <italic>L</italic><sub>2</sub>=ATGC.</p></list-item><list-item><p>We output the sequences <italic>L</italic><sub>1</sub>·<italic>R</italic> and <italic>L</italic><sub>2</sub>·<italic>R</italic>, as well as information useful to localize the SNP/INDEL (i.e. length and position in the two fragments), and the coverage of the two sequences in the input dataset.</p></list-item></list></p>
      <p>Note that, by definition of our procedure, INDELs necessarily end with two distinct characters. For example, in Fig. <xref rid="Fig1" ref-type="fig">1</xref> the output INDEL is <inline-formula id="IEq27"><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathtt {TGC \rightarrow T}$\end{document}</tex-math><mml:math id="M54"><mml:mstyle mathvariant="monospace"><mml:mtext mathvariant="italic">TGC</mml:mtext><mml:mo>→</mml:mo><mml:mi>T</mml:mi></mml:mstyle></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq27.gif"/></alternatives></inline-formula>. This is due to the fact that those two distinct characters are the ones appearing in the cluster, and we only process clusters containing at least two distinct characters. The effect of this strategy is that, in general, INDELs called from reads aligning on the forward strand will be left-shifted (note: in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, the output INDEL is left-shifted, whereas in the original genotype it was right-shifted), whereas INDELs called from reads aligning on the reverse strand will be right-shifted. This is a characteristic shared by several INDELs calling tools since, in principle, it is not possible to decide the correct shift of the INDEL based only on the information contained in the reads. Typical solutions to this ambiguity include using post-processing tools able to normalize INDEL shift in .vcf files (which requires producing a .vcf from our output, read next section), see, e.g. [<xref ref-type="bibr" rid="CR61">61</xref>].</p>
    </sec>
    <sec id="Sec7">
      <title>VCF creation</title>
      <p>If a reference genome is available, then the variants called by our tool can be aligned against it and converted to .vcf format. This can be useful, for example, to compare our output against a database of known variants and, in particular, to validate the output of the tool (see next section). In the next paragraph we describe a pipeline based on the aligner bwa-mem<xref ref-type="fn" rid="Fn2">2</xref>.</p>
      <p>First of all, variants can be filtered by minimum coverage using our executable filter_snp. In general, a higher minimum coverage will increase precision and decrease sensitivity (see “<xref rid="Sec10" ref-type="sec">Results</xref>” section). The next step is to convert our calls to fastq format. This can be achieved, for example, using the tool seqtk<xref ref-type="fn" rid="Fn3">3</xref> (with the command seqtk seq -F ’I’ in.fa &gt; out.fq) that creates a .fastq file with one entry per output fragment and with dummy high base qualities. Then, the .fastq file can be aligned against the reference genome using bwa-mem. The resulting .sam file can finally be directly converted to .vcf format using our executable sam2vcf. This tool converts every mismatch and INDEL contained in the alignments into a .vcf entry. In our repository we provide a script (snp2vcf.sh) that automatizes this process. Finally, as an optional stage (that was performed in our experiments) one can remove duplicated variations by sorting the .vcf by coordinate and then removing duplicate lines.</p>
    </sec>
    <sec id="Sec8">
      <title>Validation</title>
      <p>We used hap.py (<ext-link ext-link-type="uri" xlink:href="https://github.com/Illumina/hap.py">https://github.com/Illumina/hap.py</ext-link>) to validate the variations output by the tools. This tool is among the gold standards solutions to compute <italic>sensitivity</italic><inline-formula id="IEq28"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$=\frac {TP}{TP+FN}$\end{document}</tex-math><mml:math id="M56"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq28.gif"/></alternatives></inline-formula>, <italic>precision</italic><inline-formula id="IEq29"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$=\frac {TP}{TP+FP}$\end{document}</tex-math><mml:math id="M58"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq29.gif"/></alternatives></inline-formula>, and <italic>F1 score</italic><inline-formula id="IEq30"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$=\frac {2TP}{2TP+FP+FN}$\end{document}</tex-math><mml:math id="M60"><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="12859_2020_3586_Article_IEq30.gif"/></alternatives></inline-formula> (<italic>T</italic><italic>P</italic>,<italic>F</italic><italic>P</italic>,<italic>F</italic><italic>N</italic> being true positives, false positives, and false negatives, respectively) of a given .vcf against a ground truth .vcf.</p>
    </sec>
    <sec id="Sec9">
      <title>A parallel pipeline for SNP detection</title>
      <p>We now describe a simple strategy that allows to effectively parallelize our tool, at the price of limiting the analysis to SNPs only. The idea is to sort the input reads by similarity using the tool HARC<xref ref-type="fn" rid="Fn4">4</xref>[<xref ref-type="bibr" rid="CR62">62</xref>]. This tool clusters overlapping reads that share a (long) prefix/suffix up to a (small) Hamming distance; as a consequence, the sorted fasta file contains the reads approximately in their order of appearance on the underlying genome. We then break the sorted file into <italic>t</italic> pieces containing approximately the same number of reads. Under the assumption that the reads are sorted by their mapping position on the genome, the <italic>t</italic> pieces can be processed independently (i.e. by building the eBWT and running our tool on each of them). At the end, the union of the <italic>t</italic> outputs (that is, the called variations) will essentially be the same as the one produced by the sequential pipeline. We note that there could be some small differences between the output of the two (sequential and parallel) pipelines due to the fact that, on positions bordering the split points, the coverage is distributed between two fasta’s adjacent pieces. However, in practical applications <italic>t</italic> will be small (i.e. corresponding to the number of processors or servers), therefore we simply ignore this phenomenon in our heuristic. The most important source of noise in this strategy, instead, is that the reads’ order generated by the sorting tool (in this case, HARC) is only an <italic>approximation</italic> of their relative mapping position on the genome. In particular, we note that HARC measures similarity under the Hamming distance, that is, it does not take into account the existence of INDELs among reads. As we show in the next section, this has a strong impact on the sensitivity of INDEL detection of our parallelized tool. Our software repository includes a script, pebwt2InDel.sh, that automatically runs the parallel pipeline (including running HARC, splitting the sorted fasta file, and building the eBWT).</p>
    </sec>
  </sec>
  <sec id="Sec10" sec-type="results">
    <title>Results</title>
    <p>We compared our <sc>EBWT2INDEL</sc> with <sc>DISCOSNP</sc>++ [<xref ref-type="bibr" rid="CR8">8</xref>], that is an improvement of the <sc>DISCOSNP</sc> [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR5">5</xref>] algorithm: while <sc>DISCOSNP</sc> only detects (both heterozygous and homozygous) <italic>isolated</italic> SNPs from any number of read datasets without a reference genome, <sc>DISCOSNP</sc>++ detects and ranks all kinds of SNPs as well as small INDELs. As shown in [<xref ref-type="bibr" rid="CR8">8</xref>], <sc>DISCOSNP</sc>++ performs better than state-of-the-art methods in terms of both computational performances and quality of the results.</p>
    <p><sc>DISCOSNP</sc>++ is a pipeline of several independent tools. In the first step, <sc>DISCOSNP</sc>++ builds the dBG of the input datasets taking into account both the size of the <italic>k</italic>-mers and the minimum coverage <italic>c</italic> (DBGH5 module), and presumed erroneous <italic>k</italic>-mers are removed based on their frequency. Then, <sc>DISCOSNP</sc>++ detects bubbles [<xref ref-type="bibr" rid="CR17">17</xref>] generated in the dBG by the presence of SNPs (isolated or not) and INDELs, and it outputs a .fasta file containing the variant sequences (KISSNP2 module). A final step (KISSREADS2) maps back the reads from all input read sets on the variant sequences, mainly in order to determine the read coverage per allele and per read set of each variant. This module also computes a rank per variant, indicating whether it exhibits discriminant allele frequencies in the datasets. The last module generates a .vcf of the predicted variants. If no reference genome is provided, this step is simply a change of format from .fasta to .vcf (VCFCREATOR module).</p>
    <p>We performed three experiments: (i) on synthetic data, Human chromosome 1, (ii) on real data, Human chromosome 1, and (iii) on whole-genome sequencing real Human data. We added the reverse-complement of the reads to each dataset in order to improve the sensitivity of our tool (note that <sc>DISCOSNP</sc>++ performs implicitly this step by adding the reverse-complement of the <italic>k</italic>-mers to the de Bruijn graph as well). We validated the results of experiments (i) and (ii) at different coverages to assess the effect of coverage on the tools’ performance. In the simulated experiment (i), the ground truth, represented by a .vcf file, was known with certainty and thus the experiment had the goal to assess the precision and sensitivity of the tools. The experiments on real data allowed us to assess the sensitivity and speed of the tools in real-case scenarios. The goal of experiments (i) and (ii) was to reconstruct the genotype of individual HG00096 (from the <italic>1000 Genomes Project</italic>’s database), Chromosome 1, by detecting heterozygous sites from the raw reads. Precision and sensitivity of the tools were calculated by comparing the ground truth .vcf with the .vcf generated from the tools’ outputs, by using the pipeline described above. In experiment (iii), we analyzed variations contained in the union of the two whole-genome datasets NA12892 and NA12878 (mother and son, respectively). The goal of this experiment was to compare the number of variations reported by the two tools in a more realistic (and large) scenario.</p>
    <p>Both tools allow the user to filter out variants covered less than a fixed threshold. In our case, this is done at post-processing time (using the tool filter_snp) by simply discarding low-covered variants from the output of <sc>EBWT2INDEL</sc>. In the case of <sc>DISCOSNP</sc>++, this requires re-building the de Bruijn graph with a different value of parameter -c. For both tools, precision is proportional to this threshold, while sensitivity is inversely proportional. In experiments (i) and (ii), we therefore ran both tools varying this threshold in the range [2,26] and selected the value yielding the best average between the F1 scores of INDELs and SNPs. On synthetic data and coverages 10x, 20x, 30x, 40x, 50x, we obtained the best results for <sc>EBWT2INDEL</sc> with thresholds 3, 3, 4, 4, 6 and for <sc>DISCOSNP</sc>++ with thresholds 2, 2, 3, 3, 4, respectively. Similar settings were used on real data.</p>
    <p>All our experiments have been run on a 24-core machine with Intel(R) Xeon(R) CPU E5-2620 v3 at 2.40 GHz, and with 128 GB of shared memory. The system is Ubuntu 14.04.2 LTS.</p>
    <sec id="Sec11">
      <title>Synthetic experiment (i) - human chromosome 1</title>
      <p>In the synthetic experiment (i), we generated two variants of human Chromosome 1 by applying to it the two alleles of each heterozygous variation contained in the .vcf file downloaded from ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/. The modified bi-allelic chromosome was used to simulate synthetic reads with the tool SimSeq [<xref ref-type="bibr" rid="CR63">63</xref>], uniformly distributing the coverage among the two chromosome’s variants and using the HiSeq error profile<xref ref-type="fn" rid="Fn5">5</xref> publicly available in the SimSeq’s repository. We simulated 100-bp synthetic reads with total coverage ranging from 10x to 50x in order to assess the effect of coverage on the sensitivity and precision of the two tools. The results on the synthetic dataset are reported in Figs. <xref rid="Fig2" ref-type="fig">2</xref> and <xref rid="Fig3" ref-type="fig">3</xref>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Simulated SNP detection. SNP sensitivity, precision and <italic>F</italic><sub>1</sub> score on synthetic data as a function of the dataset’s coverage</p></caption><graphic xlink:href="12859_2020_3586_Fig2_HTML" id="MO2"/></fig><fig id="Fig3"><label>Fig. 3</label><caption><p>Simulated INDEL detection. INDEL sensitivity, precision and <italic>F</italic><sub>1</sub> score on synthetic data as a function of the dataset’s coverage</p></caption><graphic xlink:href="12859_2020_3586_Fig3_HTML" id="MO3"/></fig></p>
    </sec>
    <sec id="Sec12">
      <title>Experiment on real data (ii) - human chromosome 1</title>
      <p>In the real data experiment (ii) we ran the two tools on a reads dataset (HG00096, Chromosome 1) downloaded from ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/phase3/data/. We randomly sampled reads from the original dataset keeping a coverage ranging from 10x to the 48x full-dataset coverage. For the ground truth, we used again the .vcf file used in the synthetic dataset. Unlike in the first experiment, we note that in this case such .vcf was only an approximation of the real ground truth (that is, the individual’s unknown genotype) since it had been created by the <italic>1000 Genomes Project</italic> consortium starting from the raw read dataset that we also used for our experiment. It is therefore expected that the differences between this and the .vcfs created by <sc>EBWT2INDEL</sc> and <sc>DISCOSNP</sc>++ are larger with respect to those in the synthetic dataset, with consequent drops in precision for both tools. In Table <xref rid="Tab1" ref-type="table">1</xref> we report the running times of both tools on the datasets. We separate the running time required to build the BWT (by using BCR [<xref ref-type="bibr" rid="CR42">42</xref>, <xref ref-type="bibr" rid="CR43">43</xref>]) from the running time of <sc>EBWT2INDEL</sc> for two reasons: first, our tool assumes that the input is represented as a BWT, which is a lossless representation of the input fasta and can therefore replace it; optimizing the BWT-constructions step is a well-studied problem that does not fit the scope of this article. Second, the BWT needs to be built only once for each input dataset. If one wishes to run further analyses on the same dataset, possibly using different parameters, the same BWT can be used. This is not the case for <sc>DISCOSNP</sc>, whose de Bruijn graph is a lossy representation of the data and depends on the input parameters (<italic>k</italic>-mer length and minimum coverage). In Table <xref rid="Tab2" ref-type="table">2</xref> we report the sensitivity and precision of the tools on the 30x-covered dataset. We decided to show only the results on this coverage for simplicity of exposition: as in the synthetic experiments, we observed that with coverages larger than 30x the sensitivity and precision of the two tools did not improve significantly.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Running times on real data</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">coverage</th><th align="left">BCR (BWT)</th><th align="left"><sc>ebwt2InDel</sc></th><th align="left"><sc>DiscoSnp</sc>++</th></tr></thead><tbody><tr><td align="left">10</td><td align="left">1:03:02</td><td align="left">0:51:05</td><td align="left">00:54:07</td></tr><tr><td align="left">20</td><td align="left">2:08:52</td><td align="left">1:24:00</td><td align="left">01:09:06</td></tr><tr><td align="left">30</td><td align="left">3:19:18</td><td align="left">2:20:14</td><td align="left">01:21:31</td></tr><tr><td align="left">40</td><td align="left">4:22:06</td><td align="left">2:55:45</td><td align="left">01:37:41</td></tr><tr><td align="left">48</td><td align="left">5:11:35</td><td align="left">3:57:26</td><td align="left">01:42:50</td></tr></tbody></table><table-wrap-foot><p>We also show the times required to build the BWT using the tool BCR. All tools were run using one core only</p></table-wrap-foot></table-wrap><table-wrap id="Tab2"><label>Table 2</label><caption><p>Results on the 30x-covered real dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">metric</th><th align="left"><sc>ebwt2InDel</sc></th><th align="left"><sc>DiscoSnp</sc>++</th></tr></thead><tbody><tr><td align="left">SEN SNP</td><td align="left">0.791231</td><td align="left">0.641049</td></tr><tr><td align="left">PREC SNP</td><td align="left">0.596384</td><td align="left">0.784806</td></tr><tr><td align="left">SEN INDEL</td><td align="left">0.547036</td><td align="left">0.425699</td></tr><tr><td align="left">PREC INDEL</td><td align="left">0.533956</td><td align="left">0.571847</td></tr><tr><td align="left">F1 SNP</td><td align="left">0.680127</td><td align="left">0.705681</td></tr><tr><td align="left">F1 INDEL</td><td align="left">0.540417</td><td align="left">0.488067</td></tr></tbody></table></table-wrap></p>
      <p><bold>Comparison with our old tool</bold> ebwt2snp</p>
      <p>We also tested the old version of our tool [<xref ref-type="bibr" rid="CR7">7</xref>] on the 20x real dataset in order to evaluate the improvement in performance of the new version. We recall that the tool [<xref ref-type="bibr" rid="CR7">7</xref>] needs to compute the Generalized Suffix Array (GSA) of the reads set (this can be achieved using BCR). This (uncompressed) data structure is much larger than the ebwt used by eBWT2CLUST, thus a larger pre-processing time and larger disk usage with respect to eBWT2CLUST are expected. We also note that, once the GSA is computed, the tool [<xref ref-type="bibr" rid="CR7">7</xref>] only needs to scan this array once to perform the analysis. The post-processing phase therefore is very fast and uses little RAM. On the 20x real dataset, eBWT2CLUST takes 2h 9’ to compute the ebwt (BCR), and 1h 24’ to perform the analysis (ebwt2InDel), using 8.3 GB of RAM and 9.5 GB of disk space (in addition to the input dataset and output). The old tool ebwt2snp requires 14h 13’ to compute the Generalized Suffix Array (BCR) and 28’ to perform the analysis (ebwt2clust + clust2snp) using 1 GB of RAM (it loads fewer structures in RAM) and 73 GB of disk space (in addition to the input dataset and output). Thus, our new pipeline is, overall, much faster and uses one order of magnitude less disk space due to the use of compressed data structures (faster to calculate and lighter to store).</p>
      <p>
        <bold>Enabling Parallelism</bold>
      </p>
      <p>We run <sc>EBWT2INDEL</sc> and <sc>DISCOSNP</sc>++ on the 30x-covered real dataset allowing the two tools to use 24 cores, in order to establish the effectiveness of the parallelization strategies of both tools. The parallel pipeline using HARC followed by BCR and <sc>EBWT2INDEL</sc> (run in parallel on 24 pieces of the sorted fasta file) terminated in 33 minutes. This is approximately 10 times faster than the complete sequential pipeline (see Table <xref rid="Tab1" ref-type="table">1</xref>). By comparing the results with the same ground-truth vcf file used for Table <xref rid="Tab2" ref-type="table">2</xref>, we obtained a SNP sensitivity of 71.68%, a SNP precision of 68.58%, and a F1 score of 70.09% (setting the minimum-coverage parameter -m to 5, which yielded the best sensitivity/precision trade-off). As expected (since HARC works only under Hamming distance), INDEL sensitivity and precision dropped to 5.79% and 30.31%, respectively. <sc>DISCOSNP</sc>++ terminated the analysis in 28 minutes and achieved the same performance as those shown in Table <xref rid="Tab2" ref-type="table">2</xref> (the number of cores used by <sc>DISCOSNP</sc>++ affects only its running times, not its output).</p>
    </sec>
    <sec id="Sec15">
      <title>Real experiment (iii) - whole genome, two individuals</title>
      <p>In the first whole genome experiment we reported variations contained in the union of the first 320 million 100-bp reads from both datasets <ext-link ext-link-type="uri" xlink:href="https://www.internationalgenome.org/data-portal/sample/NA12892">github.com/nicolaprezza/ebwt2InDel</ext-link>and <ext-link ext-link-type="uri" xlink:href="https://www.internationalgenome.org/data-portal/sample/NA12878">www.internationalgenome.org/data-portal/sample/NA12878</ext-link> (mother and son, respectively). Note that, first, we have filtered the reads by removing those containing the symbol <italic>N</italic>. In total, the dataset’s size amounted to 65.3 Gbp, that is, a coverage of 10x per individual. We used the same corresponding parameters for the two tools: -m/-c = 3 controls the minimum read/<italic>k</italic>-mer coverage, -g/-D = 10 controls the maximum INDEL length, and -v/-P = 2 controls the maximum number of differences allowed (in the bubble/left-context of clusters) in addition to the main SNP/INDEL. In order to count the number of variations output by the tools, we converted their outputs (that is, .fasta files containing DNA fragment pairs testifying the variations) to .vcf files by aligning them against the hg38 Human assembly (using the pipeline described in “<xref rid="Sec7" ref-type="sec">VCF creation</xref>” subsection). Finally, we removed duplicate entries from the .vcf files (since both tools analyze the dataset and its reverse-complement, some variants could be found twice: on the forward and reverse strands). In sequential mode, BCR required 23 hours and 19 minutes to build the eBWT, while <sc>EBWT2INDEL</sc> terminated its execution in 33 hours (the whole pipeline took therefore 56 hours). The process returned 4,265,718 SNPs and 270,488 INDELs. Our parallel pipeline, on the other hand, processed the input in just 8 hours and reported 2,693,867 SNPs and 65,582 INDELs. <sc>DISCOSNP</sc>++ completed the analysis in about 2 hours and 45 minutes when running in parallel mode with 1947% of CPU utilization, and in 10 hours when using one core only. The pipeline based on <sc>DISCOSNP</sc>++ returned 787,256 SNPs and 104,090 INDELs.</p>
    </sec>
    <sec id="Sec16">
      <title>Real experiment (iv) - whole genome, one individual</title>
      <p>We performed one more experiment whose goal was to find heterozygous sites from a 20x-covered dataset of Human individual NA12878. We selected 1.300.000.000 reads from the file ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR622/SRR622457/. The whole dataset, together with the reverse-complemented reads, totalled approximately 122 GBp. For the ground truth, we used the NCBI .vcf<ext-link ext-link-type="uri" xlink:href="ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/release/NA12878_HG001/latest/">ftp://ftp-trace.ncbi.nlm.nih.gov/giab/ftp/release/NA12878_HG001/latest/</ext-link>, and validated the calls using hap.py. As in the previous experiment, we used the same corresponding parameters for the two tools: -m/-c = 3, -g/-D = 10, and -v/-P = 2. In order to build a .vcf from the tools’ outputs, we aligned the called variations against the hg38 Human assembly, and removed duplicate entries from the resulting .vcf.</p>
      <p>BCR required 21 hours and 24 minutes to build the eBWT, while <sc>EBWT2INDEL</sc> terminated its execution in 24 hours and 34 minutes (the whole pipeline took therefore 46 hours). The whole pipeline found 55.56% of the INDELs and 85.53% of the SNPs present in the ground truth, with a precision of 47.07% and 35.16%, respectively. <sc>DISCOSNP</sc>++ completed the analysis in 32 hours and 44 minutes and found 41.68% of the INDELs and 72.18% of the SNPs, with a precision of 51.33% and 63.97%, respectively.</p>
    </sec>
  </sec>
  <sec id="Sec17" sec-type="discussion">
    <title>Discussion</title>
    <sec id="Sec18">
      <title>Synthetic experiment (i) - human chromosome 1</title>
      <p>Experiments on synthetic data allowed us to assess how precisely the two tools were able to reconstruct the original .vcf file. The outcome, reported in Figs. <xref rid="Fig2" ref-type="fig">2</xref> and <xref rid="Fig3" ref-type="fig">3</xref>, is that <sc>EBWT2INDEL</sc> finds considerably more SNPs and INDELs than <sc>DISCOSNP</sc>++, at the price of being slightly less precise. At 10x coverage, most variations are not found by both tools. However, already at 20x the sensitivity of the tools starts to stabilize, reaching stable values at 30x. The plots suggest that increasing the coverage above 30x does not bring significant advantages. At 30x, <sc>EBWT2INDEL</sc> is able to find nearly all SNPs (93%), and a large fraction of the INDELs (83%). <sc>DISCOSNP</sc>++, on the other hand, finds only 70% of the SNPs and 50% of the INDELs. The high sensitivity of our tool is moderately paid in terms of precision: at 30x coverage, 77% of the SNPs and 89% of the INDELs output by our tool are correct, versus 90% and 94% of <sc>DISCOSNP</sc>++. By mixing precision and sensitivity in the F1 metric, we obtain higher scores than <sc>DISCOSNP</sc>++ across all coverages.</p>
    </sec>
    <sec id="Sec19">
      <title>Real experiment (ii) - human chromosome 1</title>
      <p>Also on real data our tool exhibits a much higher sensitivity than <sc>DISCOSNP</sc>++, especially on INDELs: we are able to find 79.1% of the SNPs contained in the ground truth, as opposed to 64.1% of <sc>DISCOSNP</sc>++, and 54.7 of the INDELs, as opposed to 42.6% of <sc>DISCOSNP</sc>++. As expected, both tools exhibit a lower precision with respect to the synthetic experiment, due to the fact that in this case the ground truth was just an approximation of the underlying genotype. By enabling parallelism, <sc>EBWT2INDEL</sc>’s SNP sensitivity decreases by 7.4%, but precision increases by 8.9%, resulting in an increase of the F1 score by 2%. This is explainable by the fact that, by pre-processing the data with HARC, we separate in different chunks reads that share long sub-sequences (and thus create eBWT clusters) but align on different parts of the genome. As expected, our parallel pipeline finds very few INDELs compared to the sequential one. In a future development of our tool we plan to implement a read-sorting algorithm able to work under edit distance in order to improve this result.</p>
    </sec>
    <sec id="Sec20">
      <title>Real experiment (iii) - whole genome, two individuals</title>
      <p>The large processing times of our pipeline are paid off by a much larger number of reported variations: using comparable parameters for both tools, the fragments output by <sc>EBWT2INDEL</sc> (in sequential mode) contained &gt;5 times more SNPs and &gt;2 times more INDELs than those output by <sc>DISCOSNP</sc>++. In parallel mode, <sc>EBWT2INDEL</sc> found less SNPs, though still &gt;3 times more than <sc>DISCOSNP</sc>++. This depends on the sorting strategy of HARC, which in this case separated reads that, in the sequential pipeline, contained areas that clustered together and also yielded SNPs.</p>
      <p>We note that, while the goal of this experiment was just to compare the raw amount of variations found by the two tools in the merged dataset, in a more realistic application one might be interested in discarding heterozygous sites within the same individual and keep only differences across the two individuals. This kind of analysis cannot be performed using <sc>DISCOSNP</sc>++, since this tool does not “color” the paths of bubbles in the de Bruijn graph according to their provenience from the two input datasets (the <italic>k</italic>-mers of both individuals are pooled together). On the other hand, this analysis can easily be performed with <sc>EBWT2INDEL</sc> by just comparing the BWTs of the two datasets, or taking as input one single BWT (as we did in our experiment) <italic>and</italic> a bitvector (the so-called <italic>document array</italic>) that tells apart eBWT characters of the two individuals.</p>
    </sec>
    <sec id="Sec21">
      <title>Real experiment (iv) - whole genome, one individual</title>
      <p>In this experiment, <sc>EBWT2INDEL</sc> has been about 50% slower than <sc>DISCOSNP</sc>++ but found many more variations. As observed in the above real experiments, the precision of both tools is low due to the fact that the ground truth itself is an approximation (and not exact as in the simulated experiments; in this case, a low precision value means that the tool has found more variations than those present in the ground truth.</p>
    </sec>
    <sec id="Sec22">
      <title>Resources</title>
      <p>Despite the complex data structures used, the running times of <sc>EBWT2INDEL</sc> are not much higher than those of <sc>DISCOSNP</sc>++: using one core for both tools, <sc>EBWT2INDEL</sc> is 2.3 times slower than <sc>DISCOSNP</sc>++ on the 48x-covered real dataset, and 1.42 times slower on the 30x-covered real dataset. It is worth to note that, while the running times of our tool scale linearly with the dataset’s size, those of <sc>DISCOSNP</sc> scale linearly with the dataset’s <italic>complexity</italic> (i.e. number of distinct <italic>k</italic>-mers): this is the reason why the ratio between ours and <sc>DISCOSNP</sc>++ running times increase with the coverage. If we take into account also BWT construction, this step accounted for 60% of the total processing time in experiments (i) and (ii), and 42% in experiment (iii). By enabling parallelism, our whole pipeline (eBWT construction and SNP analysis) runs in times comparable to those of <sc>DISCOSNP</sc>++, while also being more sensitive.</p>
      <p>As far as the RAM usage of our tool is concerned, we observed that (as expected) it always amounted to 7<italic>n</italic> bits per base; on the largest dataset (50x synthetic), this was equivalent to 21GB. On the (more realistic) 30x real dataset, our tool used 12.7 GB of RAM. The RAM usage of our tool was dominated by the variant calling phase; building the BWT required at most 3GB of RAM on the largest dataset.</p>
    </sec>
  </sec>
  <sec id="Sec23" sec-type="conclusion">
    <title>Conclusions</title>
    <p>In this work, we described <sc>EBWT2INDEL</sc>, a new algorithm that detects SNPs and INDELs. We also described a simple strategy for effectively parallelizing our tool for SNP detection only.</p>
    <p>We validated <sc>EBWT2INDEL</sc> on both synthetic and real data. In particular, we simulated synthetic read collections with a range of values for the coverage, to investigate the effect of such parameter on both accuracy and computational performances. In this case the ground truth is known with certainty, and thus the experiment has also the goal to assess the precision of the tools. The experiment on real data aims at assessing the sensitivity and speed of the tools in a real-case scenario. On synthetic 100 bp reads simulated from the Human chromosome 1 at 30x coverage, our tool is able to find 83.5% of the SNPs with an accuracy of 77.8%, and 72.2% of the INDELS with an accuracy of 84.4%. This considerably improves the sensitivity of the state-of-the-art tool based on de Bruijn graphs, who finds 70.6% of the SNPs with an accuracy of 90% and 51.4% of the INDELs with an accuracy of 89%. Similar performance are observed on real data (with lower precision for both tools due to the use of an approximated ground truth). As far as the computational cost of our tool is concerned (excluding eBWT computation), when using only one core we report a slow-down of a factor of 1.4 with respect to the state-of-the-art tool. When including eBWT computation, our whole pipeline is 4 times slower than the state-of-the-art (run on one core only). We then describe a simple way to parallelize our strategy for SNPs detection only. When enabling multi-threading on 24 cores for both tools, our complete pipeline runs in times comparable to those of the state-of-the-art competitor while at the same time also exhibiting a higher SNP precision. As a limitation, our parallel pipeline at the moment works for SNPs only, due to the use of an external pre-processing tool that does not take into account the presence of INDELs in the read set. We plan to overcome this limitation in a forthcoming update of our tool. We furthermore report results on a larger (real) whole-genome sequencing experiment whose input consisted of two 10x-covered Human datasets from the <italic>1000 Genomes Project</italic>. Also in this case, our tool exhibits a much higher sensitivity than the state-of-the art tool, finding &gt;5 times more SNPs and &gt;2 times more INDELs.</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>BWT</term>
        <def>
          <p>Burrows-Wheeler Transform</p>
        </def>
      </def-item>
      <def-item>
        <term>eBWT</term>
        <def>
          <p>Extended Burrows-Wheeler Transform</p>
        </def>
      </def-item>
      <def-item>
        <term>GSA</term>
        <def>
          <p>Generalized suffix array</p>
        </def>
      </def-item>
      <def-item>
        <term>LCP</term>
        <def>
          <p>Longest common prefix</p>
        </def>
      </def-item>
      <def-item>
        <term>SA</term>
        <def>
          <p>Suffix array</p>
        </def>
      </def-item>
      <def-item>
        <term>dBG</term>
        <def>
          <p>de Bruijn graph</p>
        </def>
      </def-item>
      <def-item>
        <term>VCF</term>
        <def>
          <p>Variant call format</p>
        </def>
      </def-item>
      <def-item>
        <term>INDEL</term>
        <def>
          <p>INsertions and/or DELetions</p>
        </def>
      </def-item>
      <def-item>
        <term>SNP</term>
        <def>
          <p>Single nucleotide polymorphism</p>
        </def>
      </def-item>
      <def-item>
        <term>FN</term>
        <def>
          <p>False negatives</p>
        </def>
      </def-item>
      <def-item>
        <term>FP</term>
        <def>
          <p>False positives</p>
        </def>
      </def-item>
      <def-item>
        <term>TP</term>
        <def>
          <p>True positives</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn id="Fn1">
      <label>1</label>
      <p>the end-markers are not actually distinct: they are treated as such only inside the sorting algorithm.</p>
    </fn>
    <fn id="Fn2">
      <label>2</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/bwa.git">https://github.com/lh3/bwa.git</ext-link>
      </p>
    </fn>
    <fn id="Fn3">
      <label>3</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/seqtk.git">https://github.com/lh3/seqtk.git</ext-link>
      </p>
    </fn>
    <fn id="Fn4">
      <label>4</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/shubhamchandak94/HARC">https://github.com/shubhamchandak94/HARC</ext-link>
      </p>
    </fn>
    <fn id="Fn5">
      <label>5</label>
      <p>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/jstjohn/SimSeq/blob/master/examples/">https://github.com/jstjohn/SimSeq/blob/master/examples/</ext-link>
      </p>
    </fn>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>Not applicable.</p>
    <sec id="d30e3404">
      <title>About this supplement</title>
      <p>This article has been published as part of Volume 21, Supplement 8 2020: Italian Society of Bioinformatics (BITS): Annual Meeting 2019. The full contents of the supplement are available at <ext-link ext-link-type="uri" xlink:href="https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-21-supplement-8">https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-21-supplement-8</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>NPi, NPr, GR and MS designed and discussed the approach and the main strategy. NPr implemented the tool; NPi, NPr, GR and MS designed the experiments; NPr and GR performed the experiments; NPi, NPr, GR and MS contributed to the analysis of experiments; NPi, NPr, GR and MS wrote the manuscript. All authors read and approved the final manuscript. GR is the PI of the project that supported this study.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>GR, NPi, MS are partially, and NPr is totally, supported by the project MIUR-SIR CMACBioSeq (“Combinatorial methods for analysis and compression of biological sequences”) grant n. RBSI146R5L. Publication costs are funded by the project MIUR-SIR CMACBioSeq grant n. RBSI146R5L.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The tool <sc>ebwt2InDel</sc> is freely available for academic use at <ext-link ext-link-type="uri" xlink:href="https://github.com/nicolaprezza/ebwt2InDel">github.com/nicolaprezza/ebwt2InDel</ext-link>. Information to generate the simulated datasets is available in the Datasets directory of the same Github repository. The datasets used and/or analysed during the current study are available from the corresponding author on reasonable request.</p>
  </notes>
  <notes id="FPar1">
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar2">
    <title>Consent for publication</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar3" notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <mixed-citation publication-type="other">Peterlongo P, Schnel N, Pisanti N, Sagot M, Lacroix V. Identifying SNPs without a Reference Genome by comparing raw reads. In: SPIRE, LNCS 6393: 2010. p. 147–58. 10.1007/978-3-642-16321-0_14.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sacomoto</surname>
            <given-names>GAT</given-names>
          </name>
          <name>
            <surname>Kielbassa</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Uricaru</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Antoniou</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Sagot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Lacroix</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>KISSPLICE: de-novo calling alternative splicing events from RNA-seq data</article-title>
        <source>BMC Bioinf</source>
        <year>2012</year>
        <volume>13</volume>
        <issue>S-6</issue>
        <fpage>5</fpage>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leggett</surname>
            <given-names>RM</given-names>
          </name>
          <name>
            <surname>MacLean</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Reference-free SNP detection: dealing with the data deluge</article-title>
        <source>BMC Genomics</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>4</issue>
        <fpage>10</fpage>
        <pub-id pub-id-type="pmid">24387160</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Iqbal</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Turner</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>McVean</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Flicek</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Caccamo</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>
        <source>Nat Genet</source>
        <year>2012</year>
        <volume>44</volume>
        <issue>2</issue>
        <fpage>226</fpage>
        <lpage>32</lpage>
        <?supplied-pmid 22231483?>
        <pub-id pub-id-type="pmid">22231483</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Uricaru</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Lacroix</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Quillery</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Plantard</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Chikhi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Lemaitre</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Reference-free detection of isolated SNPs</article-title>
        <source>Nuc Acids Res</source>
        <year>2015</year>
        <volume>43</volume>
        <issue>2</issue>
        <fpage>11</fpage>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Prezza</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Detecting Mutations by eBWT</article-title>
        <source>18th Workshop on Algorithms in Bioinformatics (WABI 2018), LIPIcs, vol. 113</source>
        <year>2018</year>
        <publisher-loc>Dagstuhl, Germany</publisher-loc>
        <publisher-name>Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Prezza</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>SNPs detection by eBWT positional clustering</article-title>
        <source>Algoritm Mol Biol</source>
        <year>2019</year>
        <volume>14</volume>
        <issue>1</issue>
        <fpage>3</fpage>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <mixed-citation publication-type="other">Peterlongo P, Riou C, Drezen E, Lemaitre C. DiscoSnp++: de novo detection of small variants from raw unassembled read set(s). bioRxiv. 2017. 10.1101/209965.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Lu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Bolund</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Schierup</surname>
            <given-names>MH</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>SOAPindel: efficient identification of indels from short paired reads</article-title>
        <source>Gen Res</source>
        <year>2013</year>
        <volume>23</volume>
        <issue>1</issue>
        <fpage>195</fpage>
        <lpage>200</lpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salmela</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Rivals</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>LoRDEC: accurate and efficient long read error correction</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>24</issue>
        <fpage>3506</fpage>
        <lpage>14</lpage>
        <?supplied-pmid 25165095?>
        <pub-id pub-id-type="pmid">25165095</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salmela</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Walve</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rivals</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Accurate self-correction of errors in long reads using de Bruijn graphs</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>33</volume>
        <issue>6</issue>
        <fpage>799</fpage>
        <lpage>806</lpage>
        <?supplied-pmid 27273673?>
        <pub-id pub-id-type="pmid">27273673</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Limasset</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Flot</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Peterlongo</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Toward perfect reads: self-correction of short reads via mapping on de Bruijn graphs</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>36</volume>
        <issue>5</issue>
        <fpage>1374</fpage>
        <lpage>81</lpage>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <mixed-citation publication-type="other">Lemaitre C, Ciortuz L, Peterlongo P. Mapping-free and assembly-free discovery of inversion breakpoints from raw NGS reads. In: AlCoB: 2014. p. 119–30. 10.1007/978-3-319-07953-0_10.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bonizzoni</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Dondi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Klau</surname>
            <given-names>GW</given-names>
          </name>
          <name>
            <surname>Pirola</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Zaccaria</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>On the minimum error correction problem for haplotype assembly in diploid and polyploid genomes</article-title>
        <source>J Comput Biol</source>
        <year>2016</year>
        <volume>23</volume>
        <issue>9</issue>
        <fpage>718</fpage>
        <lpage>36</lpage>
        <?supplied-pmid 27280382?>
        <pub-id pub-id-type="pmid">27280382</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pirola</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zaccaria</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dondi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Klau</surname>
            <given-names>GW</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bonizzoni</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Hapcol: accurate and memory-efficient haplotype assembly from long reads</article-title>
        <source>Bioinform</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>11</issue>
        <fpage>1610</fpage>
        <lpage>7</lpage>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Patterson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Marschall</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>van Iersel</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Stougie</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Klau</surname>
            <given-names>GW</given-names>
          </name>
          <name>
            <surname>Schönhuth</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Whatshap: Weighted haplotype assembly for future-generation sequencing reads</article-title>
        <source>J Comput Biol</source>
        <year>2015</year>
        <volume>22</volume>
        <issue>6</issue>
        <fpage>498</fpage>
        <lpage>509</lpage>
        <?supplied-pmid 25658651?>
        <pub-id pub-id-type="pmid">25658651</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <mixed-citation publication-type="other">Birmelé E, Crescenzi P, Ferreira RA, Grossi R, Lacroix V, Marino A, Pisanti N, Sacomoto GAT, Sagot M. Efficient Bubble Enumeration in Directed Graphs. In: SPIRE, LNCS 7608: 2012. p. 118–29. 10.1007/978-3-642-34109-0_13.</mixed-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leggett</surname>
            <given-names>RM</given-names>
          </name>
          <name>
            <surname>Ramirez-Gonzalez</surname>
            <given-names>RH</given-names>
          </name>
          <name>
            <surname>Verweij</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Kawashima</surname>
            <given-names>CG</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>JDG</given-names>
          </name>
          <name>
            <surname>Caccamo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>MacLean</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Identifying and Classifying Trait Linked Polymorphisms in Non-Reference Species by Walking Coloured de Bruijn Graphs</article-title>
        <source>PLoS ONE</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>3</issue>
        <fpage>1</fpage>
        <lpage>11</lpage>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kimura</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Koike</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Analysis of genomic rearrangements by using the Burrows-Wheeler transform of short-read data</article-title>
        <source>BMC Bioinf</source>
        <year>2015</year>
        <volume>16</volume>
        <issue>suppl.18</issue>
        <fpage>5</fpage>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kimura</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Koike</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Ultrafast SNP analysis using the Burrows-Wheeler transform of short-read data</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <issue>10</issue>
        <fpage>1577</fpage>
        <lpage>83</lpage>
        <?supplied-pmid 25609790?>
        <pub-id pub-id-type="pmid">25609790</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Philippe</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Salson</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lecroq</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Léonard</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Commes</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rivals</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Querying large read collections in main memory: a versatile data structure</article-title>
        <source>BMC Bioinf</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>242</fpage>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <mixed-citation publication-type="other">Välimäki N, Rivals E. Scalable and Versatile <italic>k</italic>-mer Indexing for High-Throughput Sequencing Data. In: ISBRA, LNCS 7875: 2013. p. 237–48. 10.1007/978-3-642-38036-5_24.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Kowalski TM, Grabowski S, Deorowicz S. Indexing arbitrary-length k-mers in sequencing reads. PLoS ONE. 2015; 10(7). 10.1371/journal.pone.0133198.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mantaci</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Burrows-Wheeler transform and Sturmian words</article-title>
        <source>Inf Process Lett</source>
        <year>2003</year>
        <volume>86</volume>
        <issue>5</issue>
        <fpage>241</fpage>
        <lpage>6</lpage>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>From first principles to the Burrows and Wheeler transform and beyond, via combinatorial optimization</article-title>
        <source>Theoret Comput Sci</source>
        <year>2007</year>
        <volume>387</volume>
        <issue>3</issue>
        <fpage>236</fpage>
        <lpage>48</lpage>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mantaci</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Versari</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Measuring the clustering effect of BWT via RLE</article-title>
        <source>Theor Comput Sci</source>
        <year>2017</year>
        <volume>698</volume>
        <fpage>79</fpage>
        <lpage>87</lpage>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <mixed-citation publication-type="other">Kempa D, Kociumaka T. Resolution of the Burrows-Wheeler Transform Conjecture. CoRR. 2019; abs/1910.10631.</mixed-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The Alternating BWT: An algorithmic perspective</article-title>
        <source>Theor Comput Sci</source>
        <year>2020</year>
        <volume>812</volume>
        <fpage>230</fpage>
        <lpage>43</lpage>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A new class of searchable and provably highly compressible string transformations</article-title>
        <source>Annual Symposium on Combinatorial Pattern Matching (CPM), LIPIcs, vol. 128</source>
        <year>2019</year>
        <publisher-loc>Dagstuhl, Germany</publisher-loc>
        <publisher-name>Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <mixed-citation publication-type="other">Giuliani S, Lipták Z, Rizzi R. When a dollar makes a BWT. In: 20th Italian Conference on Theoretical Computer Science, (ICTCS 2019), CEUR Workshop Proceedings, vol. 2504. CEUR-WS.org: 2019. p. 20–33.</mixed-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mantaci</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A new combinatorial approach to sequence comparison</article-title>
        <source>Theory Comput Syst</source>
        <year>2008</year>
        <volume>42</volume>
        <issue>3</issue>
        <fpage>411</fpage>
        <lpage>29</lpage>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mantaci</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Distance measures for biological sequences: Some recent approaches</article-title>
        <source>Int J Approx Reason</source>
        <year>2008</year>
        <volume>47</volume>
        <issue>1</issue>
        <fpage>109</fpage>
        <lpage>24</lpage>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>The Burrows-Wheeler similarity distribution between biological sequences based on Burrows-Wheeler transform</article-title>
        <source>J Theor Biol</source>
        <year>2010</year>
        <volume>262</volume>
        <issue>4</issue>
        <fpage>742</fpage>
        <lpage>9</lpage>
        <?supplied-pmid 19903487?>
        <pub-id pub-id-type="pmid">19903487</pub-id>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate long-read alignment with Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>5</issue>
        <fpage>589</fpage>
        <lpage>95</lpage>
        <?supplied-pmid 20080505?>
        <pub-id pub-id-type="pmid">20080505</pub-id>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cox</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jakobi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Large-scale compression of genomic sequence databases with the Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <issue>11</issue>
        <fpage>1415</fpage>
        <lpage>9</lpage>
        <?supplied-pmid 22556365?>
        <pub-id pub-id-type="pmid">22556365</pub-id>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The Burrows-Wheeler Transform between Data Compression and Combinatorics on Words</article-title>
        <source>The Nature of Computation. Logic, Algorithms, Applications - 9th Conference on Computability in Europe, CiE 2013. Proceedings, LNCS, vol. 7921</source>
        <year>2013</year>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR37">
      <label>37</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Garofalo</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Lightweight LCP construction for very large collections of strings</article-title>
        <source>J Discret Algoritm</source>
        <year>2016</year>
        <volume>37</volume>
        <fpage>17</fpage>
        <lpage>33</lpage>
      </element-citation>
    </ref>
    <ref id="CR38">
      <label>38</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Egidi</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Louza</surname>
            <given-names>FA</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Telles</surname>
            <given-names>GP</given-names>
          </name>
        </person-group>
        <article-title>External memory BWT and LCP computation for sequence collections with applications</article-title>
        <source>Algoritm Mol Biol</source>
        <year>2019</year>
        <volume>14</volume>
        <issue>1</issue>
        <fpage>6</fpage>
        <lpage>1615</lpage>
      </element-citation>
    </ref>
    <ref id="CR39">
      <label>39</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gagie</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sirén</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Wheeler graphs: A framework for BWT-based data structures</article-title>
        <source>Theor Comput Sci</source>
        <year>2017</year>
        <volume>698</volume>
        <fpage>67</fpage>
        <lpage>78</lpage>
        <?supplied-pmid 29276331?>
        <pub-id pub-id-type="pmid">29276331</pub-id>
      </element-citation>
    </ref>
    <ref id="CR40">
      <label>40</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gagie</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Prezza</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Fully Functional Suffix Trees and Optimal Text Searching in BWT-Runs Bounded Space</article-title>
        <source>J ACM</source>
        <year>2020</year>
        <volume>67</volume>
        <issue>1</issue>
        <fpage>2</fpage>
        <lpage>1254</lpage>
      </element-citation>
    </ref>
    <ref id="CR41">
      <label>41</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mantaci</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>An extension of the Burrows-Wheeler Transform</article-title>
        <source>Theoret Comput Sci</source>
        <year>2007</year>
        <volume>387</volume>
        <issue>3</issue>
        <fpage>298</fpage>
        <lpage>312</lpage>
      </element-citation>
    </ref>
    <ref id="CR42">
      <label>42</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bauer</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Lightweight algorithms for constructing and inverting the BWT of string collections</article-title>
        <source>Theoret Comput Sci</source>
        <year>2013</year>
        <volume>483</volume>
        <issue>0</issue>
        <fpage>134</fpage>
        <lpage>48</lpage>
      </element-citation>
    </ref>
    <ref id="CR43">
      <label>43</label>
      <mixed-citation publication-type="other">BCR_LCP_GSA. GitHub repository. <ext-link ext-link-type="uri" xlink:href="https://github.com/giovannarosone/BCR_LCP_GSA.git">https://github.com/giovannarosone/BCR_LCP_GSA.git</ext-link>. Accessed 19 Feb 2020.</mixed-citation>
    </ref>
    <ref id="CR44">
      <label>44</label>
      <mixed-citation publication-type="other">eGAP. GitHub repository. <ext-link ext-link-type="uri" xlink:href="https://github.com/felipelouza/egap.git">https://github.com/felipelouza/egap.git</ext-link>. Accessed 1 Nov 2019.</mixed-citation>
    </ref>
    <ref id="CR45">
      <label>45</label>
      <mixed-citation publication-type="other">sacak-lcp. GitHub repository. <ext-link ext-link-type="uri" xlink:href="https://github.com/felipelouza/sacak-lcp.git">https://github.com/felipelouza/sacak-lcp.git</ext-link>. Accessed 1 Nov 2019.</mixed-citation>
    </ref>
    <ref id="CR46">
      <label>46</label>
      <mixed-citation publication-type="other">ropebwt, 2. GitHub repository. <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/ropebwt2.git">https://github.com/lh3/ropebwt2.git</ext-link>. Accessed 1 Nov 2019.</mixed-citation>
    </ref>
    <ref id="CR47">
      <label>47</label>
      <mixed-citation publication-type="other">BEETL. GitHub repository. <ext-link ext-link-type="uri" xlink:href="https://github.com/BEETL/BEETL.git">https://github.com/BEETL/BEETL.git</ext-link>. Accessed 1 Nov 2019.</mixed-citation>
    </ref>
    <ref id="CR48">
      <label>48</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dolle</surname>
            <given-names>DD</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Cotten</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Iqbal</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>McCarthy</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Keane</surname>
            <given-names>TM</given-names>
          </name>
        </person-group>
        <article-title>Using reference-free compressed data structures to analyze sequencing reads from thousands of human genomes</article-title>
        <source>Gen Res</source>
        <year>2017</year>
        <volume>27</volume>
        <issue>2</issue>
        <fpage>300</fpage>
        <lpage>9</lpage>
      </element-citation>
    </ref>
    <ref id="CR49">
      <label>49</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <collab>The 1000 Genomes Project Consortium</collab>
        </person-group>
        <article-title>A global reference for human genetic variation</article-title>
        <source>Nature</source>
        <year>2015</year>
        <volume>526</volume>
        <fpage>68</fpage>
        <lpage>74</lpage>
        <pub-id pub-id-type="pmid">26432245</pub-id>
      </element-citation>
    </ref>
    <ref id="CR50">
      <label>50</label>
      <mixed-citation publication-type="other">Cox AJ, Jakobi T, Rosone G, Schulz-Trieglaff OB. Comparing DNA sequence collections by direct comparison of compressed text indexes. In: 12th Workshop on Algorithms in Bioinformatics (WABI 2012), LNBI 7534: 2012. p. 214–24. 10.1007/978-3-642-33122-0_17.</mixed-citation>
    </ref>
    <ref id="CR51">
      <label>51</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ander</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Schulz-Trieglaff</surname>
            <given-names>OB</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
        </person-group>
        <article-title>metaBEETL: high-throughput analysis of heterogeneous microbial populations from shotgun DNA sequences</article-title>
        <source>BMC Bioinf</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>5</issue>
        <fpage>2</fpage>
      </element-citation>
    </ref>
    <ref id="CR52">
      <label>52</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Guerrini</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Lightweight Metagenomic Classification via eBWT</article-title>
        <source>Algorithms for Computational Biology, LNCS, vol. 11488 LNBI</source>
        <year>2019</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR53">
      <label>53</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Restivo</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Balancing and clustering of words in the Burrows-Wheeler transform</article-title>
        <source>Theoret Comput Sci</source>
        <year>2011</year>
        <volume>412</volume>
        <issue>27</issue>
        <fpage>3019</fpage>
        <lpage>32</lpage>
      </element-citation>
    </ref>
    <ref id="CR54">
      <label>54</label>
      <mixed-citation publication-type="other">Mantaci S, Restivo A, Rosone G, Sciortino M. Burrows-Wheeler Transform and Run-Length Enconding. In: Combinatorics on Words - 11th International Conference, WORDS 2017. Proceedings, LNCS, vol. 10432: 2017. p. 228–39. 10.1007/978-3-319-66396-8_21.</mixed-citation>
    </ref>
    <ref id="CR55">
      <label>55</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gagie</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Navarro</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Prezza</surname>
            <given-names>N</given-names>
          </name>
        </person-group>
        <article-title>Optimal-time Text Indexing in BWT-runs Bounded Space</article-title>
        <source>Proceedings of the Twenty-Ninth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’18</source>
        <year>2018</year>
        <publisher-loc>Philadelphia, PA, USA</publisher-loc>
        <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR56">
      <label>56</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Prezza</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Pisanti</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Pissis</surname>
            <given-names>SP</given-names>
          </name>
        </person-group>
        <article-title>Space-Efficient Computation of the LCP Array from the Burrows-Wheeler Transform</article-title>
        <source>30th Annual Symposium on Combinatorial Pattern Matching (CPM 2019), LIPIcs, vol. 128</source>
        <year>2019</year>
        <publisher-loc>Dagstuhl, Germany</publisher-loc>
        <publisher-name>Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR57">
      <label>57</label>
      <mixed-citation publication-type="other">Burrows M, Wheeler DJ. A Block Sorting data Compression Algorithm. Technical report. Digit Syst Res Cent. 1994.</mixed-citation>
    </ref>
    <ref id="CR58">
      <label>58</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Adjeroh</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Bell</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Mukherjee</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <source>The Burrows-Wheeler Transform: Data Compression, Suffix Arrays, and Pattern Matching</source>
        <year>2008</year>
        <publisher-loc>Boston, MA</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR59">
      <label>59</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Sciortino</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Boosting textual compression in optimal linear time</article-title>
        <source>J ACM</source>
        <year>2005</year>
        <volume>52</volume>
        <issue>4</issue>
        <fpage>688</fpage>
        <lpage>713</lpage>
      </element-citation>
    </ref>
    <ref id="CR60">
      <label>60</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Janin</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
        </person-group>
        <article-title>Adaptive reference-free compression of sequence quality scores</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>1</issue>
        <fpage>24</fpage>
        <lpage>30</lpage>
        <?supplied-pmid 23661694?>
        <pub-id pub-id-type="pmid">23661694</pub-id>
      </element-citation>
    </ref>
    <ref id="CR61">
      <label>61</label>
      <mixed-citation publication-type="other">Krusche P, Trigg L, Boutros PC, Mason CE, Francisco M, Moore BL, Gonzalez-Porta M, Eberle MA, Tezak Z, Lababidi S, et al.Best practices for benchmarking germline small-variant calls in human genomes. Nat Biotechnol. 2019:1. 10.1038/s41587-019-0054-x.</mixed-citation>
    </ref>
    <ref id="CR62">
      <label>62</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chandak</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tatwawadi</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Compression of genomic sequencing reads via hash-based reordering: algorithm and analysis</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>34</volume>
        <issue>4</issue>
        <fpage>558</fpage>
        <lpage>67</lpage>
      </element-citation>
    </ref>
    <ref id="CR63">
      <label>63</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Earl</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Bradnam</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>St John</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Darling</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Fass</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Buffalo</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Zerbino</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Diekhans</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Nguyen</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Ariyaratne</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Sung</surname>
            <given-names>W-K</given-names>
          </name>
          <name>
            <surname>Ning</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Haimel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Simpson</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Fonseca</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Docking</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Paten</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Assemblathon 1: A competitive assessment of de novo short read assembly methods</article-title>
        <source>Gen Res</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>12</issue>
        <fpage>2224</fpage>
        <lpage>41</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
