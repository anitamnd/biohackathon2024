<?DTDIdentifier.IdentifierValue -//ES//DTD journal article DTD version 5.6.0//EN//XML?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName art560.dtd?>
<?SourceDTD.Version 5.6.0?>
<?ConverterInfo.XSLTName elsevier2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<?origin publisher?>
<?FILEmeta_ISCI102687 xml ?>
<?FILEmain xml ?>
<?FILEmain pdf ?>
<?FILEgr1 jpg ?>
<?FILEgr2 jpg ?>
<?FILEgr3 jpg ?>
<?FILEgr4 jpg ?>
<?FILEfx1 jpg ?>
<?FILEmmc1 pdf ?>
<?FILEsi1 gif ?>
<?FILEsi2 gif ?>
<?FILEsi3 gif ?>
<?FILEsi4 gif ?>
<?FILEsi5 gif ?>
<?FILEsi6 gif ?>
<?FILEsi7 gif ?>
<?FILEsi8 gif ?>
<?FILEsi9 gif ?>
<?FILEsi10 gif ?>
<?FILEsi11 gif ?>
<?FILEsi12 gif ?>
<?FILEsi13 gif ?>
<?FILEsi14 gif ?>
<?FILEsi15 gif ?>
<?FILEsi16 gif ?>
<?FILEsi17 gif ?>
<?FILEsi18 gif ?>
<?FILEsi19 gif ?>
<?FILEsi20 gif ?>
<?FILEsi21 gif ?>
<?FILEsi22 gif ?>
<?FILEsi23 gif ?>
<?FILEsi24 gif ?>
<?FILEsi25 gif ?>
<?FILEsi26 gif ?>
<?FILEsi27 gif ?>
<?FILEsi28 gif ?>
<?FILEsi29 gif ?>
<?FILEsi30 gif ?>
<?FILEsi31 gif ?>
<?FILEsi32 gif ?>
<?FILEsi33 gif ?>
<?FILEsi34 gif ?>
<?FILEsi35 gif ?>
<?FILEsi36 gif ?>
<?FILEsi37 gif ?>
<?FILEsi38 gif ?>
<?FILEsi39 gif ?>
<?FILEsi40 gif ?>
<?FILEsi42 gif ?>
<?FILEsi43 gif ?>
<?FILEsi44 gif ?>
<?FILEsi45 gif ?>
<?FILEsi46 gif ?>
<?FILEsi47 gif ?>
<?FILEsi48 gif ?>
<?FILEsi49 gif ?>
<?FILEsi50 gif ?>
<?FILEsi51 gif ?>
<?FILEsi52 gif ?>
<?FILEsi53 gif ?>
<?FILEsi54 gif ?>
<?FILEsi55 gif ?>
<?FILEsi56 gif ?>
<?FILEsi57 gif ?>
<?FILEsi58 gif ?>
<?FILEsi59 gif ?>
<?FILEsi60 gif ?>
<?FILEsi61 gif ?>
<?FILEsi62 gif ?>
<?FILEsi63 gif ?>
<?FILEsi64 gif ?>
<?FILEsi66 gif ?>
<?FILEsi67 gif ?>
<?FILEsi68 gif ?>
<?FILEsi69 gif ?>
<?FILEsi70 gif ?>
<?FILEsi71 gif ?>
<?FILEsi72 gif ?>
<?FILEsi73 gif ?>
<?FILEsi74 gif ?>
<?FILEsi75 gif ?>
<?FILEsi76 gif ?>
<?FILEsi77 gif ?>
<?FILEsi78 gif ?>
<?FILEsi79 gif ?>
<?FILEsi80 gif ?>
<?FILEsi81 gif ?>
<?FILEsi82 gif ?>
<?FILEsi83 gif ?>
<?FILEsi84 gif ?>
<?FILEsi85 gif ?>
<?FILEsi86 gif ?>
<?FILEsi87 gif ?>
<?FILEsi88 gif ?>
<?FILEsi89 gif ?>
<?FILEsi90 gif ?>
<?FILEsi91 gif ?>
<?FILEsi92 gif ?>
<?FILEsi93 gif ?>
<?FILEsi94 gif ?>
<?FILEsi95 gif ?>
<?FILEsi97 gif ?>
<?FILEsi98 gif ?>
<?FILEsi99 gif ?>
<?FILEsi100 gif ?>
<?FILEsi101 gif ?>
<?FILEsi102 gif ?>
<?FILEsi103 gif ?>
<?FILEsi104 gif ?>
<?FILEsi105 gif ?>
<?FILEsi106 gif ?>
<?FILEsi107 gif ?>
<?FILEsi108 gif ?>
<?FILEsi109 gif ?>
<?FILEsi110 gif ?>
<?FILEsi111 gif ?>
<?FILEsi112 gif ?>
<?FILEsi113 gif ?>
<?FILEsi114 gif ?>
<?FILEsi115 gif ?>
<?FILEsi116 gif ?>
<?FILEsi117 gif ?>
<?FILEsi118 gif ?>
<?FILEsi119 gif ?>
<?FILEsi120 gif ?>
<?FILEsi121 gif ?>
<?FILEsi122 gif ?>
<?FILEsi123 gif ?>
<?FILEsi124 gif ?>
<?FILEsi125 gif ?>
<?FILEsi126 gif ?>
<?FILEsi127 gif ?>
<?FILEsi128 gif ?>
<?FILEsi129 gif ?>
<?FILEsi130 gif ?>
<?FILEsi131 gif ?>
<?FILEsi132 gif ?>
<?FILEsi133 gif ?>
<?FILEsi134 gif ?>
<?FILEsi135 gif ?>
<?FILEsi136 gif ?>
<?FILEsi137 gif ?>
<?FILEsi138 gif ?>
<?FILEsi139 gif ?>
<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">iScience</journal-id>
    <journal-id journal-id-type="iso-abbrev">iScience</journal-id>
    <journal-title-group>
      <journal-title>iScience</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2589-0042</issn>
    <publisher>
      <publisher-name>Elsevier</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8246400</article-id>
    <article-id pub-id-type="pii">S2589-0042(21)00655-6</article-id>
    <article-id pub-id-type="doi">10.1016/j.isci.2021.102687</article-id>
    <article-id pub-id-type="publisher-id">102687</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Dynamic partitioning of search patterns for approximate pattern matching using search schemes</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="au1">
        <name>
          <surname>Renders</surname>
          <given-names>Luca</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">1</xref>
      </contrib>
      <contrib contrib-type="author" id="au2">
        <name>
          <surname>Marchal</surname>
          <given-names>Kathleen</given-names>
        </name>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="aff2" ref-type="aff">2</xref>
      </contrib>
      <contrib contrib-type="author" id="au3">
        <name>
          <surname>Fostier</surname>
          <given-names>Jan</given-names>
        </name>
        <email>jan.fostier@ugent.be</email>
        <xref rid="aff1" ref-type="aff">1</xref>
        <xref rid="fn1" ref-type="fn">3</xref>
        <xref rid="cor1" ref-type="corresp">∗</xref>
      </contrib>
      <aff id="aff1"><label>1</label>Department of Information Technology, Ghent University - imec, Ghent 9052, Belgium</aff>
      <aff id="aff2"><label>2</label>Department of Plant Biotechnology and Bioinformatics, Ghent University, Ghent 9052, Belgium</aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor1"><label>∗</label>Corresponding author <email>jan.fostier@ugent.be</email></corresp>
      <fn id="fn1">
        <label>3</label>
        <p id="ntpara0010">Lead contact</p>
      </fn>
    </author-notes>
    <pub-date pub-type="pmc-release">
      <day>10</day>
      <month>6</month>
      <year>2021</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on <pub-date
						pub-type="epub">.-->
    <pub-date pub-type="collection">
      <day>23</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>10</day>
      <month>6</month>
      <year>2021</year>
    </pub-date>
    <volume>24</volume>
    <issue>7</issue>
    <elocation-id>102687</elocation-id>
    <history>
      <date date-type="received">
        <day>19</day>
        <month>3</month>
        <year>2021</year>
      </date>
      <date date-type="rev-recd">
        <day>17</day>
        <month>5</month>
        <year>2021</year>
      </date>
      <date date-type="accepted">
        <day>28</day>
        <month>5</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 The Author(s)</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbyncndlicense">https://creativecommons.org/licenses/by-nc-nd/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY-NC-ND license (http://creativecommons.org/licenses/by-nc-nd/4.0/).</license-p>
      </license>
    </permissions>
    <abstract id="abs0010">
      <title>Summary</title>
      <p>Search schemes constitute a flexible and generic framework to describe how all approximate occurrences of a search pattern in a text can be found efficiently. We propose an algorithm for the dynamic partitioning of search patterns which can be universally applied to any kind of search scheme and demonstrate that this technique significantly reduces the search space. We present Columba, a software tool written in C++, in which a multitude of search schemes are implemented. We discuss implementation aspects such as memory interleaving of Burrows-Wheeler transform representations and the reduction of redundancy that is inherently associated with the edit distance metric. Ultimately, we demonstrate that Columba has superior performance to the state of the art. Using a single CPU core, Columba is able to retrieve all occurrences of 100,000 Illumina reads and their reverse complements within a maximum edit distance of four in the human genome in less than 3 min.</p>
    </abstract>
    <abstract abstract-type="graphical" id="abs0015">
      <title>Graphical abstract</title>
      <fig id="undfig1" position="anchor">
        <graphic xlink:href="fx1"/>
      </fig>
    </abstract>
    <abstract abstract-type="author-highlights" id="abs0020">
      <title>Highlights</title>
      <p>
        <list list-type="simple" id="ulist0010">
          <list-item id="u0010">
            <label>•</label>
            <p id="p0010">Dynamic partitioning of search patterns reduces search space and runtime</p>
          </list-item>
          <list-item id="u0015">
            <label>•</label>
            <p id="p0015">Memory interleaving of bit vector representations of the BWT reduces runtime</p>
          </list-item>
          <list-item id="u0020">
            <label>•</label>
            <p id="p0020">Avoiding redundancy inherent to the edit distance metric reduces the search space</p>
          </list-item>
          <list-item id="u0025">
            <label>•</label>
            <p id="p0025">Our software tool Columba outperforms the state of the art by a factor of 3.5</p>
          </list-item>
        </list>
      </p>
    </abstract>
    <abstract abstract-type="teaser" id="abs0025">
      <p>Algorithms; Bioinformatics; Computer science; High-performance computing in bioinformatics</p>
    </abstract>
    <kwd-group id="kwrds0010">
      <title>Subject areas</title>
      <kwd>Algorithms</kwd>
      <kwd>Bioinformatics</kwd>
      <kwd>Computer science</kwd>
      <kwd>High-performance computing in bioinformatics</kwd>
    </kwd-group>
  </article-meta>
  <notes>
    <p id="misc0010">Published: July 23, 2021</p>
  </notes>
</front>
<body>
  <sec id="sec1">
    <title>Introduction</title>
    <p id="p0030">Sequence alignment algorithms are central to many bioinformatics applications. Given a query pattern <italic>P</italic> (e.g., a read) and a search text <italic>T</italic> (e.g., a reference genome or a collection of genomes), the basic task is to identify occurrences of <italic>P</italic> in <italic>T</italic>. Due to the presence of sequencing errors and natural variation, one is often interested in “approximate pattern matching”: finding occurrences of <italic>P</italic> in <italic>T</italic> within a certain Hamming distance (allowing only substitutions) or Levenshtein/edit distance (allowing substitutions, insertions, and deletions).</p>
    <p id="p0035">Most bioinformatics tools (e.g., BLAT [<xref rid="bib7" ref-type="bibr">Kent, 2002</xref>], BLAST [<xref rid="bib2" ref-type="bibr">Altschul et al., 1990</xref>], BWA [<xref rid="bib11" ref-type="bibr">Li and Durbin, 2009</xref>], etc.) use “lossy” approximate pattern matching algorithms: they rely on heuristics to quickly identify some (but not necessarily all) approximate matches of <italic>P</italic> in <italic>T</italic>. By sacrificing some sensitivity, significant gains in performance can be obtained. In this paper, we focus on “lossless” algorithms that are guaranteed to retrieve all approximate matches of <italic>P</italic> in <italic>T</italic>. Recent algorithmic developments on “bidirectional indexes” and “search schemes” promise to decrease the performance gap between lossy and lossless approximate pattern matching algorithms.</p>
    <p id="p0040">Regular full-text substring indexes (e.g., suffix trees [<xref rid="bib6" ref-type="bibr">Gusfield, 2007</xref>], enhanced suffix arrays [<xref rid="bib1" ref-type="bibr">Abouelhoda et al., 2004</xref>], FM indexes [<xref rid="bib4" ref-type="bibr">Ferragina and Manzini, 2000</xref>]) allow unidirectional pattern matching. In this work, we focus on the FM index (<xref rid="bib4" ref-type="bibr">Ferragina and Manzini, 2000</xref>), which is based on the Burrows-Wheeler transform (BWT) of the search text <italic>T</italic>. It allows for the identification of exact occurrences of a query pattern <italic>P</italic> in <italic>T</italic> with a time complexity of <inline-formula><mml:math id="M1" altimg="si1.gif"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="badbreak">+</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mtext>occ</mml:mtext></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="M2" altimg="si2.gif"><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> the length of <italic>P</italic> and <inline-formula><mml:math id="M3" altimg="si3.gif"><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mtext>occ</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> the number of occurrences of <italic>P</italic> in <italic>T</italic>. It does so by matching pattern <italic>P</italic> character by character in reverse order, from right to left. Baseline lossless approximate pattern matching with up to <italic>k</italic> errors is performed by exploring branches of the FM index that could potentially be matches. Branches are explored character by character for as long as they remain within the maximum allowed Hamming/Levenshtein distance of <italic>k</italic> errors with the corresponding part of query pattern <italic>P</italic>. When the number of errors exceeds the value of <italic>k</italic>, the branch is abandoned (called “backtracking”), and the search procedure continues with the next feasible branch that is yet unexplored. The problem is that (a) the number of branches to explore increases rapidly with the number of errors allowed and (b) the vast majority of branches that are explored turn out not to be matches. In other words, the search space, i.e., the feasible region of the full-text index in which occurrences of <italic>P</italic> could be found, is very large, rendering the backtracking procedure computationally unfeasible even for modest values of <italic>k</italic>.</p>
    <p id="p0045">Bidirectional indexes (affix trees [<xref rid="bib12" ref-type="bibr">Maaβ, 2000</xref>], affix arrays [<xref rid="bib17" ref-type="bibr">Strothmann, 2007</xref>], and bidirectional FM indexes [<xref rid="bib10" ref-type="bibr">Lam et al., 2009</xref>]) augment the functionality of their unidirectional counterparts by allowing to extend queries in either direction: a pattern <italic>P</italic> can be searched by starting at any position of <italic>P</italic> and extending the match either to the left or to the right in arbitrary order. Lam (<xref rid="bib10" ref-type="bibr">Lam et al., 2009</xref>) was the first to note that this added functionality could significantly accelerate lossless approximate pattern matching in full-text indexes by leveraging the classical “pigeonhole principle”: by partitioning <italic>P</italic> in <inline-formula><mml:math id="M4" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> non-overlapping parts with <italic>k</italic> the maximum number of allowed errors, it immediately follows that one part must be error free. By first performing an exact search for each of the <inline-formula><mml:math id="M5" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> parts and then extending that match with an approximate search, the search space is reduced significantly and computational gains are obtained. Indeed, the initial exact match avoids the computationally costly exploration of the densely branched region near the root of the search tree.</p>
    <p id="p0050">Kucherov et al. generalized these ideas and introduced the notion of “search schemes” (<xref rid="bib9" ref-type="bibr">Kucherov et al., 2014</xref>). Search schemes define how a pattern <italic>P</italic> is matched using a bidirectional full-text index such that unsuccessful branches are discarded as quickly as possible, reducing the search space and hence runtime. We adopt their notation. Pattern <italic>P</italic> is partitioned into <italic>p</italic> (potentially uneven) parts <inline-formula><mml:math id="M6" altimg="si5.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mspace width="0.25em"/><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mspace width="0.25em"/><mml:mi>p</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. A <italic>search</italic>
<inline-formula><mml:math id="M7" altimg="si6.gif"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is a triplet of arrays of size <italic>p</italic> where π is a permutation over <inline-formula><mml:math id="M8" altimg="si7.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mn>1,2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> that defines the order in which the parts <inline-formula><mml:math id="M9" altimg="si8.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are processed. It must satisfy the connectivity property in that sense that a partial match can only be extended in a contiguous manner, either to the left or to the right. The arrays <italic>L</italic> and <italic>U</italic> define the lower and upper bound to the cumulative number of errors when each part is processed. The core idea is to only gradually increase the number of allowed errors when more parts of <italic>P</italic> are matched against the full-text index, significantly reducing the search space near the dense root of the search tree. To cover all possible error distributions over the length of a pattern, multiple “searches” are required that collectively form a search scheme. Kucherov et al. proposed a number of efficient search schemes for up to <inline-formula><mml:math id="M10" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors using <inline-formula><mml:math id="M11" altimg="si10.gif"><mml:mrow><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M12" altimg="si11.gif"><mml:mrow><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> parts. For example, for <inline-formula><mml:math id="M13" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> errors and <inline-formula><mml:math id="M14" altimg="si13.gif"><mml:mrow><mml:mi>p</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> parts, they proposed a search scheme with three searches: <inline-formula><mml:math id="M15" altimg="si14.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>123,000,022</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; <inline-formula><mml:math id="M16" altimg="si15.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>321,000,012</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; and <inline-formula><mml:math id="M17" altimg="si16.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>213,001,012</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. In the <inline-formula><mml:math id="M18" altimg="si17.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> search, exact matching is first performed for the leftmost part <inline-formula><mml:math id="M19" altimg="si18.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Next, this exact match is extended to the right, thus processing parts <inline-formula><mml:math id="M20" altimg="si19.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M21" altimg="si20.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, using a backtracking procedure that allows up to two errors. In the <inline-formula><mml:math id="M22" altimg="si21.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> search, exact matching is first performed for the rightmost part <inline-formula><mml:math id="M23" altimg="si20.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and extended to the left by first allowing up to a single error in <inline-formula><mml:math id="M24" altimg="si19.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and then two errors in <inline-formula><mml:math id="M25" altimg="si18.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Indeed, occurrences of <italic>P</italic> with two errors in the middle part were already covered by search <inline-formula><mml:math id="M26" altimg="si17.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Finally, search <inline-formula><mml:math id="M27" altimg="si22.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> first involves an exact matching of <inline-formula><mml:math id="M28" altimg="si19.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, which is then extended to the left allowing a single error and finally to the right with at least one and at most two errors.</p>
    <p id="p0055">Kianfar et al. (<xref rid="bib8" ref-type="bibr">Kianfar et al., 2018</xref>) further extended this work and used integer linear programming to generate additional search schemes for the Hamming distance metric. Additionally, they show that related work on lossless approximate pattern matching by Vroland et al. on 01∗0 seeds (<xref rid="bib19" ref-type="bibr">Vroland et al., 2016</xref>) can also be expressed as search schemes. Therefore, search schemes represent a flexible framework for lossless approximate pattern matching in which a multitude of algorithmic ideas can be expressed. For reference, all search schemes used in this paper are provided in <xref rid="mmc1" ref-type="supplementary-material">Table S1</xref>.</p>
    <p id="p0060">In this paper, we propose an algorithm for the “dynamic partitioning” of a search pattern <italic>P</italic> based on its sequence content. We demonstrate that this technique reduces the search space and runtime by up to 28% and 25%, respectively, compared to a uniform partitioning of <italic>P</italic>. Dynamic partitioning can be universally applied to any kind of search scheme to boost its performance. We implemented this idea in Columba, an open-source tool written in standard C++11. Columba is almost 3.5 times faster than Bwolo (<xref rid="bib19" ref-type="bibr">Vroland et al., 2016</xref>) for the task of identifying all occurrences of 101 bp Illumina reads in the human reference genome within an edit distance of <inline-formula><mml:math id="M29" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors. Columba is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/columba" id="intref0010">https://github.com/biointec/columba</ext-link> under AGPL-3.0 license.</p>
  </sec>
  <sec id="sec2">
    <title>Results and discussion</title>
    <sec id="sec2.1">
      <title>Benchmarks</title>
      <p id="p0065">In all benchmarks, all occurrences of both strands of search patterns up to an edit distance (allowing substitutions and/or indels) of <inline-formula><mml:math id="M30" altimg="si23.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>1,2,3,4</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> were identified in the human reference genome (GRCh38) (<xref rid="bib16" ref-type="bibr">Schneider et al., 2017</xref>). Non-ACGT characters (e.g., Ns) in the reference sequence were replaced by a randomly chosen nucleotide. Chromosomes were concatenated into a single string. It is therefore possible that a pattern is mapped across the boundary of adjacent chromosomes. Such matches can easily be filtered during post-processing.</p>
      <p id="p0070">We sampled two sets of each <inline-formula><mml:math id="M31" altimg="si24.gif"><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>000</mml:mn></mml:math></inline-formula> Illumina HiSeq 2000 reads (101 bp) from a whole genome sequencing data set (accession no. ERR194147). The first set of reads was used only to determine suitable parameters (as described further) for the different partitioning strategies, for the different search schemes, and for different values of <italic>k</italic>. All benchmark results were obtained using the second set of reads, demonstrating that the empirically derived parameters generalize well to other data sets with similar characteristics. We also provide results for <inline-formula><mml:math id="M32" altimg="si24.gif"><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>000</mml:mn></mml:math></inline-formula> search patterns of length 50 bp, randomly sampled from long Pacific Biosciences reads (accession no. <ext-link ext-link-type="uri" xlink:href="ncbi-wgs:SRR1304331" id="PC_linkVH7cnSECTy">SRR1304331</ext-link>).</p>
      <p id="p0075">All results were obtained using a single core of a 24-core AMD EPYC 7451 CPU running at a base clock frequency of 3.1 GHz. Each simulation was repeated 20 times. We report both the average wall clock time as well as the standard deviation. We report the fraction of search patterns with at least one match as well as the total number of non-redundant occurrences. We label an occurrence as redundant when its starting position is at most <inline-formula><mml:math id="M33" altimg="si25.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> nucleotides away from another match with an equal or lower edit distance.</p>
    </sec>
    <sec id="sec2.2">
      <title>Dynamic partitioning of search patterns reduces the search space</title>
      <p id="p0080">As noted by Kucherov et al. (<xref rid="bib9" ref-type="bibr">Kucherov et al., 2014</xref>) the partitioning of <italic>P</italic> into equally sized parts (called “uniform” partitioning) is not necessarily optimal. This is because different searches might enumerate a different number of strings during the search procedure. Using the search scheme for <inline-formula><mml:math id="M34" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> errors from the introduction section as an example, it is clear that search <inline-formula><mml:math id="M35" altimg="si17.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> will on average be associated with a larger search space than <inline-formula><mml:math id="M36" altimg="si21.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M37" altimg="si22.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> because <inline-formula><mml:math id="M38" altimg="si17.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> allows for two errors in the second part that is processed, whereas <inline-formula><mml:math id="M39" altimg="si21.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M40" altimg="si22.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> allow only for a single error. By increasing the size of <inline-formula><mml:math id="M41" altimg="si18.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, the number of exact matches of <inline-formula><mml:math id="M42" altimg="si18.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> will generally decrease. Consequently, search <inline-formula><mml:math id="M43" altimg="si17.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> will enumerate fewer candidate occurrences. Conversely, by decreasing the size of <inline-formula><mml:math id="M44" altimg="si19.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M45" altimg="si20.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, the search space to explore by <inline-formula><mml:math id="M46" altimg="si21.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M47" altimg="si22.gif"><mml:mrow><mml:msub><mml:mi mathvariant="script">S</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> will increase. Due to the asymmetry between searches, the decrease in search space can be larger than the increase, thus improving the overall performance of the search scheme. In their paper, Kucherov et al. propose a dynamic programming algorithm to find the optimal part sizes, using a model that assumes a random search text <italic>T</italic> and a random search pattern <italic>P</italic>. In this work, we focus on the human genome as a reference genome and on search patterns that have a small edit distance to some subsequence of this reference genome. The assumption of randomness is not valid as the human genome has, unlike random sequences, a very complex repeat structure. Hence, we established optimal part sizes empirically using the first set of reads, as described in the previous section. We call this partitioning the “optimal static” partitioning. These optimal part sizes depend on characteristics of the search patterns (length, error rate, and distribution) as well as the characteristics of the reference genome itself (repeat structure).</p>
      <p id="p0085">Even though these part sizes may be optimal on average, they are not necessarily optimal for each individual search pattern <italic>P</italic>. For example, depending on the sequence content of <italic>P</italic> itself, some parts of <italic>P</italic> might have a very low number of exact matches (or even no matches), whereas other parts might have a very high number of exact matches. In turn, this will again translate into an uneven workload among searches. By reducing the size of the parts with few exact matches while increasing the size of parts with many exact matches, it is again possible to achieve a global reduction in workload. We propose an algorithm for the “dynamic partitioning” of <italic>P</italic>. The ideas are illustrated in <xref rid="fig1" ref-type="fig">Figure 1</xref>. Each part is initialized by matching a single character. The position of that character is taken as the middle position of the corresponding uniformly sized parts, except for the first and last part where we take, respectively, the first and last character of <italic>P</italic>. During each next step, the part with the highest number of exact occurrences (and which can still be extended) is selected, and it is extended by a single character in the direction (left or right) of the adjacent part that has the fewest number of exact occurrences. This procedure is repeated until all characters of <italic>P</italic> are assigned to some part. Intuitively, this greedy algorithm attempts to partition <italic>P</italic> such that each part is associated with an equal number of exact matches. The actual partitioning that is obtained depends on the sequence content of <italic>P</italic> itself and will therefore differ between search patterns, hence the name “dynamic partitioning”. The overhead imposed by dynamic partitioning is very small: the SA/BWT ranges of the exact matches of the parts of <italic>P</italic> (see STAR methods: Bidirectional FM index) that emerge as a by-product of the procedure are stored and are re-used during the execution of the search schemes. Indeed, efficient search schemes consist of searches that first involve the exact matching of some part of <italic>P</italic>. Note that the dynamic partitioning algorithm in general extends parts both to the left and right and therefore takes full advantage of the functionality offered by the bidirectional FM index.<fig id="fig1"><label>Figure 1</label><caption><p>Dynamic partitioning of a search pattern <italic>P</italic> with four parts.</p><p>Each part is initialized by matching a single character (dark gray squares). The part with the largest number of exact occurrences is extended by a single character (light gray squares), either to the left or to the right.</p></caption><graphic xlink:href="gr1"/></fig></p>
      <p id="p0090">In its basic form, the dynamic partitioning algorithm yields parts with a roughly equal number of exact matches, similar to what is expected on average from uniform partitioning. However, in order to obtain the best results, one should aim to balance the relative number of exact matches among parts such that they correspond to what is expected on average from the optimal static partitioning. The dynamic partitioning algorithm is easily adapted to this task as follows: (1) we initialize the first character of each part as the center position of the optimal static partitioning (again, except for the first/last part); (2) we assign per-part weights and balance the weighted number of exact matches among parts. Intuitively, the first modification allows certain parts to “grow” more than others while the weights take into account the expected relative workload among searches. Again, we obtained these weights empirically using the first set of reads.</p>
      <p id="p0095"><xref rid="tbl1" ref-type="table">Table 1</xref> shows the impact of different partitioning strategies for different values of the maximum allowed edit distance <inline-formula><mml:math id="M48" altimg="si23.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>1,2,3,4</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, using the search schemes proposed by Kucherov et al. with <inline-formula><mml:math id="M49" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> parts (<xref rid="bib9" ref-type="bibr">Kucherov et al., 2014</xref>). Besides runtime, the number of nodes visited in the search tree as well as the number of computed elements in the banded edit distance matrix are shown. The former equals the number of times a partial match is extended by a single character <italic>c</italic> (in either direction). In practice, this involves expensive random memory access, and it is therefore a clear indication of intrinsic performance, regardless of the quality of implementation.<table-wrap position="float" id="tbl1"><label>Table 1</label><caption><p>Comparison of different partitioning strategies when identifying all occurrences of both strands of 100,000 Illumina reads in the human reference genome for different values of the maximum allowed edit distance <italic>k</italic> using the search schemes by Kucherov et al. with <inline-formula><mml:math id="M50" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> parts.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Partitioning strategy</th><th colspan="2">Wall clock time <inline-formula><mml:math id="M51" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> SD</th><th colspan="2">No. of nodes visited (search space)</th><th colspan="2">No. of matrix elements computed</th></tr></thead><tbody><tr><td colspan="7"><inline-formula><mml:math id="M52" altimg="si26.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M53" altimg="si98.gif"><mml:mo>=</mml:mo><mml:mn>959</mml:mn><mml:mo>,</mml:mo><mml:mn>844</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M54" altimg="si99.gif"><mml:mrow><mml:mn>93.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Uniform</td><td>6.73 <inline-formula><mml:math id="M55" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.18 s</td><td/><td align="char">29,212,674</td><td/><td align="char">45,697,288</td><td/></tr><tr><td>Optimal static</td><td>6.73 <inline-formula><mml:math id="M56" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.18 s</td><td><inline-formula><mml:math id="M57" altimg="si100.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">29,212,674</td><td><inline-formula><mml:math id="M58" altimg="si100.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">45,697,288</td><td><inline-formula><mml:math id="M59" altimg="si100.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td>Dynamic</td><td>7.23 <inline-formula><mml:math id="M60" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.14 s</td><td><inline-formula><mml:math id="M61" altimg="si101.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>7.4</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">25,829,974</td><td><inline-formula><mml:math id="M62" altimg="si102.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>11.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">39,391,011</td><td><inline-formula><mml:math id="M63" altimg="si103.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>13.8</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td colspan="7"><inline-formula><mml:math id="M64" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M65" altimg="si104.gif"><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>329</mml:mn><mml:mo>,</mml:mo><mml:mn>746</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M66" altimg="si105.gif"><mml:mrow><mml:mn>96.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Uniform</td><td>22.32 <inline-formula><mml:math id="M67" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.15 s</td><td/><td align="char">104,476,617</td><td/><td align="char">339,010,141</td><td/></tr><tr><td>Optimal static</td><td>20.14 <inline-formula><mml:math id="M68" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.12 s</td><td><inline-formula><mml:math id="M69" altimg="si106.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>9.8</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">94,289,677</td><td><inline-formula><mml:math id="M70" altimg="si106.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>9.8</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">282,148,209</td><td><inline-formula><mml:math id="M71" altimg="si107.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>16.8</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td>Dynamic</td><td>17.76 <inline-formula><mml:math id="M72" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.13 s</td><td><inline-formula><mml:math id="M73" altimg="si108.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>20.4</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">74,978,120</td><td><inline-formula><mml:math id="M74" altimg="si109.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>28.2</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">228,389,750</td><td><inline-formula><mml:math id="M75" altimg="si110.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>32.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td colspan="7"><inline-formula><mml:math id="M76" altimg="si28.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M77" altimg="si111.gif"><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>606</mml:mn><mml:mo>,</mml:mo><mml:mn>995</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M78" altimg="si112.gif"><mml:mrow><mml:mn>97.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Uniform</td><td>55.19 <inline-formula><mml:math id="M79" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.44 s</td><td/><td align="char">276,027,753</td><td/><td align="char">1,068,947,201</td><td/></tr><tr><td>Optimal static</td><td>55.27 <inline-formula><mml:math id="M80" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.40 s</td><td><inline-formula><mml:math id="M81" altimg="si113.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.1</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">276,027,753</td><td><inline-formula><mml:math id="M82" altimg="si100.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">1,068,947,201</td><td><inline-formula><mml:math id="M83" altimg="si100.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td>Dynamic</td><td>45.73 <inline-formula><mml:math id="M84" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.39 s</td><td><inline-formula><mml:math id="M85" altimg="si114.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>17.1</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">212,965,491</td><td><inline-formula><mml:math id="M86" altimg="si115.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>22.8</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">816,519,456</td><td><inline-formula><mml:math id="M87" altimg="si116.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>23.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td colspan="7"><inline-formula><mml:math id="M88" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M89" altimg="si117.gif"><mml:mo>=</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>997</mml:mn><mml:mo>,</mml:mo><mml:mn>221</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M90" altimg="si118.gif"><mml:mrow><mml:mn>97.7</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Uniform</td><td>215.37 <inline-formula><mml:math id="M91" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.96 s</td><td/><td align="char">1,154,125,425</td><td/><td align="char">4,941,009,260</td><td/></tr><tr><td>Optimal static</td><td>191.45 <inline-formula><mml:math id="M92" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 1.46 s</td><td><inline-formula><mml:math id="M93" altimg="si119.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>11.1</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">1,012,354,507</td><td><inline-formula><mml:math id="M94" altimg="si120.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>12.3</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">4,272,355,550</td><td><inline-formula><mml:math id="M95" altimg="si121.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>13.5</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td>Dynamic</td><td>162.14 <inline-formula><mml:math id="M96" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.99 s</td><td><inline-formula><mml:math id="M97" altimg="si122.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>24.7</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">827,521,618</td><td><inline-formula><mml:math id="M98" altimg="si123.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>28.3</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">3,607,583,286</td><td><inline-formula><mml:math id="M99" altimg="si124.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>27.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr></tbody></table><table-wrap-foot><fn><p>The percentage values indicate the relative increase or decrease with respect to uniform partitioning. See also <xref rid="mmc1" ref-type="supplementary-material">Tables S2–S7</xref>.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0100">For <inline-formula><mml:math id="M100" altimg="si26.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> errors, the search scheme consists of two searches which are symmetric with respect to each other. Hence, the uniform and optimal static partitioning strategies both partition <italic>P</italic> into two equally sized parts and both show equal performance. The dynamic partitioning strategy reduces the number of nodes visited by 11.6%, demonstrating its ability to reduce the search space. However, because the overhead resulting from the dynamic partitioning procedure itself is larger than the gains from this smaller search space, the runtime increases slightly.</p>
      <p id="p0105">The search scheme for <inline-formula><mml:math id="M101" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> errors is not symmetric; thus, we expect the optimal static partitioning to differ from the uniform partitioning. For <inline-formula><mml:math id="M102" altimg="si27.gif"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>101</mml:mn></mml:mrow></mml:math></inline-formula>, we find optimal part sizes of 41, 29, and 31, respectively. <xref rid="tbl1" ref-type="table">Table 1</xref> shows that applying optimal static partitioning reduces both the number of nodes visited and the runtime by 9.8%. The use of dynamic partitioning yields a notable reduction in search space and runtime of, respectively, 28.2% and 20.4%, both with respect to uniform partitioning. Clearly, the ability to partition patterns based on their sequence content results in a significant computational gain.</p>
      <p id="p0110">For <inline-formula><mml:math id="M103" altimg="si28.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> errors, the search scheme is only asymmetric in the lower bounds. We find that the optimal part sizes are uniform for <inline-formula><mml:math id="M104" altimg="si27.gif"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>101</mml:mn></mml:mrow></mml:math></inline-formula>; hence, optimal static partitioning and uniform partitioning yield identical results. However, dynamic partitioning again reveals superior performance with a runtime reduction of 17.1%.</p>
      <p id="p0115">The search scheme for <inline-formula><mml:math id="M105" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> is highly asymmetric. It consists of eight searches, three of which start from an exact match of part <inline-formula><mml:math id="M106" altimg="si18.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. Therefore, it is beneficial to increase the size of <inline-formula><mml:math id="M107" altimg="si18.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, such that the number of exact matches of this part is reduced. We find optimal part sizes of 27, 20, 15, 19, and 19 that yield a reduction in runtime of <inline-formula><mml:math id="M108" altimg="si29.gif"><mml:mrow><mml:mn>11.1</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula>. Dynamic partitioning, however, is able to further reduce runtime by <inline-formula><mml:math id="M109" altimg="si30.gif"><mml:mrow><mml:mn>24.7</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula>, while the number of nodes visited is reduced by <inline-formula><mml:math id="M110" altimg="si31.gif"><mml:mrow><mml:mn>28.3</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula>. Also for other search schemes, we found that dynamic partitioning reduces the search space and runtime to a similar extent (<xref rid="mmc1" ref-type="supplementary-material">Tables S2–S6</xref>). The same holds for the search patterns sampled from Pacific Biosciences reads (<xref rid="mmc1" ref-type="supplementary-material">Table S7</xref>). We conclude that dynamic partitioning can be universally applied to boost the performance of search schemes.</p>
    </sec>
    <sec id="sec2.3">
      <title>Memory interleaving of bit vectors reduces runtime</title>
      <p id="p0120">To extend a partial match by a single character <italic>c</italic>, the FM index relies on <inline-formula><mml:math id="M111" altimg="si32.gif"><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> queries on the BWT to return the number of occurrences of character <italic>c</italic> in the prefix <inline-formula><mml:math id="M112" altimg="si33.gif"><mml:mi>BWT</mml:mi><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> (see STAR methods: Bidirectional FM index). Given our focus on DNA sequences, which have alphabet size <inline-formula><mml:math id="M113" altimg="si34.gif"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mtext>Σ</mml:mtext><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, we realize this using four bit vectors <inline-formula><mml:math id="M114" altimg="si35.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with constant time rank support. Then, <inline-formula><mml:math id="M115" altimg="si36.gif"><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>B</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:msub><mml:mi>rank</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mfenced><mml:mi>p</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>B</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:math></inline-formula>, i.e., the number of 1-bits in the first <italic>p</italic> positions of <inline-formula><mml:math id="M116" altimg="si35.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. For 64-bit CPU architectures, the rank9 algorithm (<xref rid="bib18" ref-type="bibr">Vigna, 2008</xref>) has attractive properties. Briefly, a bit vector of size <italic>n</italic> bits is stored in <inline-formula><mml:math id="M117" altimg="si37.gif"><mml:mrow><mml:mi>n</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">/</mml:mo><mml:mn>64</mml:mn></mml:mrow></mml:math></inline-formula> 64-bit words. For every <italic>p</italic> that is a multiple of 512 bits, the pre-computed “first-level count” <inline-formula><mml:math id="M118" altimg="si38.gif"><mml:mrow><mml:msub><mml:mtext>rank</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is stored as a 64-bit value. Each first-level count is associated with seven additional pre-computed “second-level counts” that contain values <inline-formula><mml:math id="M119" altimg="si39.gif"><mml:mrow><mml:msub><mml:mtext>rank</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>p</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>64</mml:mn><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> - <inline-formula><mml:math id="M120" altimg="si38.gif"><mml:mrow><mml:msub><mml:mtext>rank</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, for <inline-formula><mml:math id="M121" altimg="si40.gif"><mml:mrow><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mn>7</mml:mn></mml:mrow></mml:math></inline-formula>. These second-level counts are stored as seven 9-bit values within a 64-bit word. Rank operations <inline-formula><mml:math id="M122" altimg="si38.gif"><mml:msub><mml:mi>rank</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mfenced><mml:mi>p</mml:mi></mml:mfenced></mml:math></inline-formula> for arbitrary <italic>p</italic> can then be answered in constant time by adding three contributions: (1) the appropriate first-level and (2) second-level counts; (3) a <inline-formula><mml:math id="M123" altimg="si42.gif"><mml:mi>popcount</mml:mi><mml:mfenced><mml:mi>w</mml:mi></mml:mfenced></mml:math></inline-formula> instruction to count the number of 1-bits in <italic>w</italic>, the word of the bit vector that contains position <italic>p</italic> and for which the bits at positions <italic>p</italic> and higher were masked to zero. The memory overhead of the first- and second-level counts amounts to only 25% of the bit vector data.</p>
      <p id="p0125">Vigna (<xref rid="bib18" ref-type="bibr">Vigna, 2008</xref>) proposed to store the first- and second-level counts in an “interleaved” manner: the two words that hold corresponding first- and second-level counts are located next to each other in memory. When loading the cache line that contains first-level count information, the second-level count information is retrieved as well, thus reducing the number of cache misses. Gog and Petri (<xref rid="bib5" ref-type="bibr">Gog and Petri, 2014</xref>) proposed to additionally interleave the pre-computed count information with the bit vector data itself. In that case, all information to answer a rank query is stored on either a single cache line or two adjacent cache lines.</p>
      <p id="p0130">In the context of search schemes (or more generally: backtracking algorithms), the search tree is explored by extending a partial match with each character <inline-formula><mml:math id="M124" altimg="si43.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mtext>Σ</mml:mtext></mml:mrow></mml:math></inline-formula>. Hence, within a short time duration, different calls to <inline-formula><mml:math id="M125" altimg="si32.gif"><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> are made for fixed <italic>p</italic> and for all <inline-formula><mml:math id="M126" altimg="si43.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mtext>Σ</mml:mtext></mml:mrow></mml:math></inline-formula>. In order to maximally fill a cache line (64 bytes or eight words on typical x86 architectures) with relevant information, we propose to interleave the data related to different bit vectors <inline-formula><mml:math id="M127" altimg="si35.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as shown in <xref rid="fig2" ref-type="fig">Figure 2</xref>. In the case of DNA sequences, all four calls to <inline-formula><mml:math id="M128" altimg="si32.gif"><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> with <inline-formula><mml:math id="M129" altimg="si44.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> can then be answered using 12 words of data. By using 64-byte aligned vectors to store the interleaved bit vector data and pre-computed counts, we guarantee that only two cache lines are required for four occ calls. For the same task, when using four non-interleaved bit vectors, at least four cache lines would be required when these individual bit vectors are stored using the scheme by Gog and Petri while eight cache lines would be required using Vigna's storage scheme. For large genomes, due to the fact that <italic>p</italic> takes unpredictable values, most of these cache lines have to be retrieved from main memory, a task that requires <inline-formula><mml:math id="M130" altimg="si45.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">∼</mml:mo></mml:mrow></mml:math></inline-formula>100 ns (equivalent to 200–300 CPU cycles) on modern CPU architectures. Thus, reducing the number of cache lines that have to be retrieved from memory improves performance.<fig id="fig2"><label>Figure 2</label><caption><p>Interleaved storage of bit vectors <inline-formula><mml:math id="M131" altimg="si35.gif"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and associated first- and second-level counts for <inline-formula><mml:math id="M132" altimg="si95.gif"><mml:mrow><mml:mtext>Σ</mml:mtext><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Four calls to <inline-formula><mml:math id="M133" altimg="si32.gif"><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> for fixed <italic>p</italic> and all <inline-formula><mml:math id="M134" altimg="si43.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">∈</mml:mo><mml:mtext>Σ</mml:mtext></mml:mrow></mml:math></inline-formula> require the data of only two cache lines.</p></caption><graphic xlink:href="gr2"/></fig></p>
      <p id="p0135">We compare our proposed memory storage scheme for bit vectors to the scheme proposed by Vigna. For the sake of simplicity, we refer to these methods as “interleaved” and “non-interleaved”, respectively, even though also in Vigna's scheme, first- and second-level counts are interleaved. <xref rid="tbl2" ref-type="table">Table 2</xref> shows the runtime for both approaches for the different partitioning strategies using the search scheme by Kucherov et al. for <inline-formula><mml:math id="M135" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors and <inline-formula><mml:math id="M136" altimg="si46.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> parts. Runtime is considerably reduced by 35%–37%. Note that the memory storage scheme is independent from the partitioning scheme, and hence, both techniques can be combined. Collectively, they reduce runtime from 342 s (uniform partitioning with non-interleaved bit vectors) to 162 s (dynamic partitioning with interleaved bit vectors), a reduction of 53%.<table-wrap position="float" id="tbl2"><label>Table 2</label><caption><p>The wall clock time for mapping both strands of 100,000 Illumina patterns using interleaved and non-interleaved bit vectors for <inline-formula><mml:math id="M137" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors and the search scheme by Kucherov et al. with <inline-formula><mml:math id="M138" altimg="si46.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> parts.</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Bit vectors</th><th colspan="2">Uniform partitioning</th><th colspan="2">Optimal static partitioning</th><th colspan="2">Dynamic partitioning</th></tr></thead><tbody><tr><td>Non-interleaved</td><td align="char">342.02<inline-formula><mml:math id="M139" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 2.71 s</td><td/><td align="char">295.15<inline-formula><mml:math id="M140" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 2.93 s</td><td/><td align="char">249.49<inline-formula><mml:math id="M141" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 2.19 s</td><td/></tr><tr><td>Interleaved</td><td align="char">215.37<inline-formula><mml:math id="M142" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.96 s</td><td><inline-formula><mml:math id="M143" altimg="si125.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>37.2</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">191.45<inline-formula><mml:math id="M144" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 1.46 s</td><td><inline-formula><mml:math id="M145" altimg="si126.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>35.1</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">162.14<inline-formula><mml:math id="M146" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.99 s</td><td><inline-formula><mml:math id="M147" altimg="si127.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>35.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="sec2.4">
      <title>Reducing redundancy for the edit distance metric reduces the search space</title>
      <p id="p0140">The use of the edit distance metric inherently results in a certain degree of redundancy. An occurrence of a pattern <italic>P</italic> may be reported multiple times with slightly different start and/or end positions in <italic>T</italic>. For example, if <italic>P</italic> occurs as an exact match in <italic>T</italic> and <italic>k</italic> errors are allowed, then <inline-formula><mml:math id="M148" altimg="si47.gif"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mn>4</mml:mn><mml:mi>i</mml:mi></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> redundant occurrences <italic>O</italic> will be found for which the alignments between <italic>P</italic> and <italic>O</italic> have leading and/or trailing gaps in <italic>P</italic> and/or <italic>O</italic>. Hence, the degree of redundancy increases rapidly with the number of errors allowed.</p>
      <p id="p0145">As searches of search schemes align a pattern <italic>P</italic> part by part, the same redundancy occurs when dealing with partial matches of <italic>P</italic>. Consider a search <inline-formula><mml:math id="M149" altimg="si6.gif"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. If all partial occurrences up to part <inline-formula><mml:math id="M150" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with an edit distance of at most <inline-formula><mml:math id="M151" altimg="si49.gif"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are reported, then an alignment procedure for part <inline-formula><mml:math id="M152" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> will be started for each such occurrence, even though some of them may be redundant. In STAR methods, we provide techniques to reduce redundant computations and thus improve performance.</p>
      <p id="p0150">We compare an optimized implementation, which implements the ideas from STAR methods, to a naive implementation. In this naive implementation, an alignment procedure is started for each partial occurrence, even though some of them may be redundant. In <xref rid="tbl3" ref-type="table">Table 3</xref>, both approaches are compared for different values of <italic>k</italic>. For <inline-formula><mml:math id="M153" altimg="si26.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, the difference in runtime, number of nodes, and matrix elements is negligible. For <inline-formula><mml:math id="M154" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, the search space is reduced by 26%, leading to a reduction in runtime by 13%. For <inline-formula><mml:math id="M155" altimg="si28.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, even larger reductions of respectively 46% (search space) and 33% (runtime) are found. This is to be expected, as the redundancy grows quadratically with <italic>k</italic>. For <inline-formula><mml:math id="M156" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, the optimized implementation reduces the search space by 63% and the runtime by 52%. We conclude that for higher values of <italic>k</italic>, an optimized implementation to handle redundancy associated with edit distance metric computations is essential to achieve high computational performance.<table-wrap position="float" id="tbl3"><label>Table 3</label><caption><p>Comparison of a naive and optimized strategy for handling the redundancy associated to the edit distance metric for different values of <italic>k</italic><italic>.</italic></p></caption><table frame="hsides" rules="groups"><thead><tr><th>Edit distance redundancy</th><th colspan="2">Wall clock time <inline-formula><mml:math id="M157" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> SD</th><th colspan="2">No. of nodes visited (search space)</th><th colspan="2">No. of matrix elements computed</th></tr></thead><tbody><tr><td colspan="7"><inline-formula><mml:math id="M158" altimg="si26.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M159" altimg="si98.gif"><mml:mo>=</mml:mo><mml:mn>959</mml:mn><mml:mo>,</mml:mo><mml:mn>844</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M160" altimg="si99.gif"><mml:mrow><mml:mn>93.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Naive</td><td>7.19 <inline-formula><mml:math id="M161" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.10 s</td><td/><td align="char">26,102,601</td><td/><td align="char">39,697,328</td><td/></tr><tr><td>Optimized</td><td>7.23 <inline-formula><mml:math id="M162" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.14 s</td><td><inline-formula><mml:math id="M163" altimg="si128.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>+</mml:mo><mml:mn>0.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">25,829,974</td><td><inline-formula><mml:math id="M164" altimg="si129.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>1.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">39,391,011</td><td><inline-formula><mml:math id="M165" altimg="si130.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>0.8</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td colspan="7"><inline-formula><mml:math id="M166" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M167" altimg="si104.gif"><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>329</mml:mn><mml:mo>,</mml:mo><mml:mn>746</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M168" altimg="si105.gif"><mml:mrow><mml:mn>96.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Naive</td><td>20.50 <inline-formula><mml:math id="M169" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.18 s</td><td/><td align="char">101,087,547</td><td/><td align="char">297,657,004</td><td/></tr><tr><td>Optimized</td><td>17.76 <inline-formula><mml:math id="M170" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.13 s</td><td><inline-formula><mml:math id="M171" altimg="si131.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>13.4</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">75,164,043</td><td><inline-formula><mml:math id="M172" altimg="si132.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>25.6</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">227,670,435</td><td><inline-formula><mml:math id="M173" altimg="si133.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>23.5</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td colspan="7"><inline-formula><mml:math id="M174" altimg="si28.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M175" altimg="si111.gif"><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>606</mml:mn><mml:mo>,</mml:mo><mml:mn>995</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M176" altimg="si112.gif"><mml:mrow><mml:mn>97.0</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Naive</td><td>67.72 <inline-formula><mml:math id="M177" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.52 s</td><td/><td align="char">393,769,104</td><td/><td align="char">1,389,115,919</td><td/></tr><tr><td>Optimized</td><td>45.73 <inline-formula><mml:math id="M178" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.39 s</td><td><inline-formula><mml:math id="M179" altimg="si134.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>32.5</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">212,965,491</td><td><inline-formula><mml:math id="M180" altimg="si135.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>45.9</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">816,519,456</td><td><inline-formula><mml:math id="M181" altimg="si136.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>41.2</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td colspan="7"><inline-formula><mml:math id="M182" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, non-redundant matches <inline-formula><mml:math id="M183" altimg="si117.gif"><mml:mo>=</mml:mo><mml:mn>7</mml:mn><mml:mo>,</mml:mo><mml:mn>997</mml:mn><mml:mo>,</mml:mo><mml:mn>221</mml:mn></mml:math></inline-formula>, reads mapped <inline-formula><mml:math id="M184" altimg="si118.gif"><mml:mrow><mml:mn>97.7</mml:mn><mml:mtext>%</mml:mtext></mml:mrow></mml:math></inline-formula></td></tr><tr><td colspan="7"><hr/></td></tr><tr><td>Naive</td><td>335.67 <inline-formula><mml:math id="M185" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 1.94 s</td><td/><td align="char">2,247,115,246</td><td/><td align="char">8,250,593,095</td><td/></tr><tr><td>Optimized</td><td>162.14 <inline-formula><mml:math id="M186" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.99 s</td><td><inline-formula><mml:math id="M187" altimg="si137.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>51.7</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">827,521,618</td><td><inline-formula><mml:math id="M188" altimg="si138.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>63.2</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td><td align="char">3,607,583,286</td><td><inline-formula><mml:math id="M189" altimg="si139.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo>−</mml:mo><mml:mn>56.3</mml:mn><mml:mtext>%</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></td></tr></tbody></table><table-wrap-foot><fn><p>Both strands of 100,000 Illumina reads are mapped, using the search schemes by Kucherov et al. with <inline-formula><mml:math id="M190" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> parts, dynamic partitioning, and interleaved bit vectors.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="sec2.5">
      <title>Columba has higher computational performance than other state-of-the-art tools</title>
      <p id="p0155">We benchmarked the different search schemes that have been proposed in literature in our implementation (called Columba). Kucherov et al. proposed schemes with <inline-formula><mml:math id="M191" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M192" altimg="si51.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> parts (<xref rid="bib9" ref-type="bibr">Kucherov et al., 2014</xref>). Kianfar et al. generated optimal search schemes for the Hamming distance metric (<xref rid="bib8" ref-type="bibr">Kianfar et al., 2018</xref>). For <inline-formula><mml:math id="M193" altimg="si28.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M194" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors, they contain searches that already allow one or two errors in the first part of <italic>P</italic> that is matched. Hence, we found that these search schemes are not competitive when the edit distance metric is used. From the same research group, Pockrandt et al. derived an alternative search scheme for <inline-formula><mml:math id="M195" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors referred to as Man<sub><italic>Best</italic></sub> (<xref rid="bib15" ref-type="bibr">Pockrandt, 2019</xref>). We also include the search schemes based on the pigeonhole principle as well as those based on the 01∗0 seeds (<xref rid="bib19" ref-type="bibr">Vroland et al., 2016</xref>; <xref rid="bib8" ref-type="bibr">Kianfar et al., 2018</xref>). For the latter, a dedicated tool called Bwolo was developed. In other papers, Bwolo was found to be the fastest available method for the edit distance metric (<xref rid="bib8" ref-type="bibr">Kianfar et al., 2018</xref>; <xref rid="bib15" ref-type="bibr">Pockrandt, 2019</xref>). For all search schemes, dynamic partitioning of search patterns was used with optimal parameters. We also compared our implementation to the implementation of search schemes in SeqAn 3. In our hands, the runtime was found to be orders of magnitude larger than our implementation. Therefore, no results for SeqAn 3 are reported.</p>
      <p id="p0160"><xref rid="tbl4" ref-type="table">Table 4</xref> lists the running times. For efficient search schemes, Columba shows superior performance to Bwolo: for <inline-formula><mml:math id="M196" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors and using the Kucherov <inline-formula><mml:math id="M197" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> search scheme, Columba is almost four times faster than Bwolo. Particularly, even when Bwolo's 01∗0 search strategy is used within Columba, a significant performance difference is revealed. Bwolo uses a unidirectional search index, whereas Columba relies on a bidirectional search functionality. Therefore, Bwolo has to perform in-text verification to validate candidate matches, whereas Columba performs the matching entirely within the index structure itself. Nevertheless, as also noted in (<xref rid="bib8" ref-type="bibr">Kianfar et al., 2018</xref>), in-text verification can in certain cases be faster.<table-wrap position="float" id="tbl4"><label>Table 4</label><caption><p>The runtime for different search schemes that we support in our tool Columba versus a state-of-the-art tool Bwolo for different values of <italic>k</italic><italic>.</italic></p></caption><table frame="hsides" rules="groups"><thead><tr><th>Search scheme/tool</th><th><inline-formula><mml:math id="M198" altimg="si26.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></th><th><inline-formula><mml:math id="M199" altimg="si12.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula></th><th><inline-formula><mml:math id="M200" altimg="si28.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula></th><th><inline-formula><mml:math id="M201" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula></th></tr></thead><tbody><tr><td>Pigeonhole principle</td><td>7.13 <inline-formula><mml:math id="M202" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.04 s</td><td>24.13 <inline-formula><mml:math id="M203" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.15 s</td><td>144.88 <inline-formula><mml:math id="M204" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.99 s</td><td align="char">722.21<inline-formula><mml:math id="M205" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 5.72 s</td></tr><tr><td>Kucherov <inline-formula><mml:math id="M206" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td><td>7.23 <inline-formula><mml:math id="M207" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.14 s</td><td>17.76 <inline-formula><mml:math id="M208" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.13 s</td><td>45.73 <inline-formula><mml:math id="M209" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.39 s</td><td align="char">162.14<inline-formula><mml:math id="M210" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.99 s</td></tr><tr><td>Kucherov <inline-formula><mml:math id="M211" altimg="si51.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula></td><td>7.23 <inline-formula><mml:math id="M212" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.09 s</td><td>20.93 <inline-formula><mml:math id="M213" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.12 s</td><td>58.61 <inline-formula><mml:math id="M214" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.35 s</td><td align="char">195.52<inline-formula><mml:math id="M215" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 1.57 s</td></tr><tr><td>01∗0 principle</td><td>7.22 <inline-formula><mml:math id="M216" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.09 s</td><td>18.50 <inline-formula><mml:math id="M217" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.10 s</td><td>68.67 <inline-formula><mml:math id="M218" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.38 s</td><td align="char">241.17<inline-formula><mml:math id="M219" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 2.07 s</td></tr><tr><td>Kianfar</td><td>7.11 <inline-formula><mml:math id="M220" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.06 s</td><td>17.05 <inline-formula><mml:math id="M221" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.11 s</td><td>152.54 <inline-formula><mml:math id="M222" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 1.19 s</td><td align="char">1994.92<inline-formula><mml:math id="M223" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 19.69 s</td></tr><tr><td>Man<sub><italic>Best</italic></sub></td><td>NA</td><td>NA</td><td>NA</td><td align="char">192.56<inline-formula><mml:math id="M224" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 1.35 s</td></tr><tr><td>Bwolo</td><td>12.68 <inline-formula><mml:math id="M225" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.37 s</td><td>35.87 <inline-formula><mml:math id="M226" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.25 s</td><td>123.60 <inline-formula><mml:math id="M227" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.33 s</td><td align="char">602.14<inline-formula><mml:math id="M228" altimg="si97.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">±</mml:mo></mml:mrow></mml:math></inline-formula> 0.77 s</td></tr></tbody></table><table-wrap-foot><fn><p>For all search schemes, dynamic partitioning was used.</p></fn></table-wrap-foot></table-wrap></p>
      <p id="p0165">Interestingly, in our implementation and using our data set, the original <inline-formula><mml:math id="M229" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> search schemes proposed by Kucherov et al. yield the highest performance. Nevertheless, the performance difference with the Man<sub><italic>Best</italic></sub>, Kucherov <inline-formula><mml:math id="M230" altimg="si51.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, and 01∗0 schemes is relatively small, and other data sets may yield different conclusions. Remarkably, the performance differences between these four efficient search schemes are about as large as the performance differences between partitioning strategies. Therefore, it might be worthwhile to further investigate novel partitioning strategies as well as novel search schemes.</p>
      <p id="p0170">We also benchmarked the runtime of Columba with uniform partitioning, non-interleaved bit vectors, and a naive edit distance implementation (i.e., without any of the improvements proposed in this paper) for <inline-formula><mml:math id="M231" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and using the search scheme by Kucherov et al. with <inline-formula><mml:math id="M232" altimg="si46.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> parts. This resulted in a wall clock time of 560.64 s, almost 3.5 times slower than the runtime of 162.14 s of Columba with all improvements in place (see <xref rid="tbl1" ref-type="table">Table 1</xref>).</p>
      <p id="p0175">Note that Columba, like most alignment tools, can easily take advantage of multi-core and/or multi-CPU architectures by aligning reads on different cores in parallel.</p>
    </sec>
  </sec>
  <sec id="sec3">
    <title>Summary</title>
    <p id="p0180">In this paper, we made three contributions, which together form Columba. We proposed an algorithm for the “dynamic partitioning” of a search pattern <italic>P</italic> based on its sequence content. We demonstrate that for the task of mapping 100 bp Illumina reads to the human reference genome, this technique reduces the search space and runtime by up to 28% and 25%, respectively, compared to a uniform partitioning of <italic>P</italic>. Dynamic partitioning can be universally applied to any kind of search scheme to boost its performance. Additionally, we proposed a new strategy to interleave bit vector representations of the BWT in memory that is specifically tailored to search schemes. This leads to fewer cache misses and reduces runtime by 35%. Again, this technique can be universally applied to all search schemes. Finally, we provided an analysis and discussion on how to maximally avoid redundancy that is inherently associated with edit distance computations. Avoiding this redundancy reduces the search space by up to 63% and the runtime by 52%. Collectively, these techniques reduce the runtime with a factor of almost 3.5. Columba supports different search schemes: the pigeonhole-based schemes, the search schemes with <inline-formula><mml:math id="M233" altimg="si4.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M234" altimg="si51.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> parts as proposed by Kucherov et al. (<xref rid="bib9" ref-type="bibr">Kucherov et al., 2014</xref>), the schemes proposed by Kianfar et al. (<xref rid="bib8" ref-type="bibr">Kianfar et al., 2018</xref>), and the 01∗0 seeds by Vroland et al. (<xref rid="bib19" ref-type="bibr">Vroland et al., 2016</xref>). We demonstrated that our implementation is almost four times faster than Bwolo (<xref rid="bib19" ref-type="bibr">Vroland et al., 2016</xref>) for the task of identifying all occurrences of 100 bp Illumina reads in the human reference genome within an edit distance of <inline-formula><mml:math id="M235" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors. Columba is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/columba" id="intref0020">https://github.com/biointec/columba</ext-link> under AGPL-3.0 license.</p>
  </sec>
  <sec id="sec4">
    <title>Limitations of the study</title>
    <p id="p0185">This work considers only lossless approximate pattern matching algorithms. Columba is not compared against state-of-the-art tools that use lossy approximate pattern matching algorithms. Only the edit distance (i.e., Levenshtein) metric is considered and not the Hamming distance metric. Columba cannot find occurrences under a more generic scoring scheme with arbitrary match, mismatch, and gap scores/penalties. Search schemes have been proposed in literature for up to <inline-formula><mml:math id="M236" altimg="si9.gif"><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> errors. It is still an open research question how efficient search schemes for higher values of <italic>k</italic> can be designed. We have benchmarked Columba using only patterns of length 101 (Illumina) and length 50 (Pacific Biosciences). Performance and relative performance differences with respect to other tools may vary for other pattern lengths. We have benchmarked only using the human reference genome as a search text.</p>
  </sec>
  <sec id="sec5">
    <title>STAR★methods</title>
    <sec id="sec5.1">
      <title>Key resources table</title>
      <p id="p0190">
        <table-wrap position="float" id="undtbl1">
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th>REAGENT or RESOURCE</th>
                <th>SOURCE</th>
                <th>IDENTIFIER</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="3">
                  <bold>Deposited data</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>Illumina sequencing data</td>
                <td>EBI ENA</td>
                <td>ERR194147</td>
              </tr>
              <tr>
                <td>Pacific Biosciences sequencing data</td>
                <td>EBI ENA</td>
                <td>SRR1304331</td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <bold>Software and algorithms</bold>
                </td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td>Columba</td>
                <td>This paper</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/columba" id="intref0025">https://github.com/biointec/columba</ext-link>
                </td>
              </tr>
              <tr>
                <td>Bwolo</td>
                <td>(<xref rid="bib19" ref-type="bibr">Vroland et al., 2016</xref>)</td>
                <td>
                  <ext-link ext-link-type="uri" xlink:href="https://bioinfo.lifl.fr/olo/" id="intref0030">https://bioinfo.lifl.fr/olo/</ext-link>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </p>
    </sec>
    <sec id="sec5.2">
      <title>Resource availability</title>
      <sec id="sec5.2.1">
        <title>Lead contact</title>
        <p id="p0195">Further information and requests for resources should be directed to and will be fulfilled by the lead contact, Jan Fostier <ext-link ext-link-type="uri" xlink:href="mailto:jan.fostier@ugent.be" id="intref0035">jan.fostier@ugent.be</ext-link>.</p>
      </sec>
      <sec id="sec5.2.2">
        <title>Materials availability</title>
        <p id="p0200">This study did not generate new unique reagents.</p>
      </sec>
      <sec sec-type="data-availability" id="sec5.2.3">
        <title>Data and code availability</title>
        <p id="p0205">The data sets used in this study are derived from publicly available data. The first data set consists of 100,000 randomly sampled reads from an Illumina sequencing experiment (EBI ENA, accession no. ERR194147). The sampled reads are available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/columba/releases/download/example/sampled_illumina_reads.fastq" id="intref0045">https://github.com/biointec/columba/releases/download/example/sampled_illumina_reads.fastq</ext-link>. The second data set consists of 100,000 subreads of length 50 randomly sampled from a Pacific Biosciences sequencing experiment (EBI ENA, accession no. <ext-link ext-link-type="uri" xlink:href="ncbi-wgs:SRR1304331" id="PC_linkD2UsNqlPq9">SRR1304331</ext-link>). The sampled version is available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/columba/releases/download/example/sampled_pacbio_seeds.fastq" id="intref0050">https://github.com/biointec/columba/releases/download/example/sampled_pacbio_seeds.fastq</ext-link>.</p>
        <p id="p0210">The code generated during this study is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/biointec/columba" id="intref0055">https://github.com/biointec/columba</ext-link>.</p>
      </sec>
    </sec>
    <sec id="sec5.3">
      <title>Method details</title>
      <sec id="sec5.3.1">
        <title>Bidirectional FM index</title>
        <p id="p0215">We use standard notation on strings, zero-based array indexing and half-open intervals [.,.). The Burrows-Wheeler transform <inline-formula><mml:math id="M237" altimg="si52.gif"><mml:mi>BWT</mml:mi><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> of a text <inline-formula><mml:math id="M238" altimg="si53.gif"><mml:mrow><mml:mi>T</mml:mi><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> of size <italic>n</italic> that ends with a unique (and lexicographically smallest) sentinel character $ is defined as <inline-formula><mml:math id="M239" altimg="si54.gif"><mml:mi>BWT</mml:mi><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo>[</mml:mo><mml:mi>SA</mml:mi><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo><mml:mo>-</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:math></inline-formula> if SA<inline-formula><mml:math id="M240" altimg="si55.gif"><mml:mi>SA</mml:mi><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:math></inline-formula> and BWT[<italic>i</italic>] = $ otherwise (<xref rid="bib3" ref-type="bibr">Burrows and Wheeler, 1994</xref>). SA denotes the suffix array, an array of size <italic>n</italic> over integer values that indicate the starting positions of the suffixes of <italic>T</italic> in lexicographic order. We need support for <inline-formula><mml:math id="M241" altimg="si56.gif"><mml:mi>occ</mml:mi><mml:mo>(</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> queries on the BWT that return the number of occurrences of character <italic>c</italic> in the prefix <inline-formula><mml:math id="M242" altimg="si57.gif"><mml:mi>BWT</mml:mi><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula>. We realize this through <inline-formula><mml:math id="M243" altimg="si58.gif"><mml:mrow><mml:mo>|</mml:mo><mml:mtext>Σ</mml:mtext><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> bit vectors with constant-time rank support. Here, <inline-formula><mml:math id="M244" altimg="si58.gif"><mml:mrow><mml:mo>|</mml:mo><mml:mtext>Σ</mml:mtext><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> denotes the size of the alphabet (e.g., <inline-formula><mml:math id="M245" altimg="si34.gif"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mtext>Σ</mml:mtext><mml:mo>|</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> for DNA sequences). Exact pattern matching is then performed by matching character by character, from right to left. Let <inline-formula><mml:math id="M246" altimg="si59.gif"><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> denote the interval over the suffix array for which the corresponding suffixes have <italic>P</italic> as a prefix. The suffix array interval <inline-formula><mml:math id="M247" altimg="si60.gif"><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> whose suffixes have <inline-formula><mml:math id="M248" altimg="si61.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> as a prefix can then be computed by <inline-formula><mml:math id="M249" altimg="si62.gif"><mml:msup><mml:mi>i</mml:mi><mml:mo>'</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mfenced><mml:mi>c</mml:mi></mml:mfenced><mml:mo>+</mml:mo><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> and <inline-formula><mml:math id="M250" altimg="si63.gif"><mml:msup><mml:mi>j</mml:mi><mml:mo>'</mml:mo></mml:msup><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mfenced><mml:mi>c</mml:mi></mml:mfenced><mml:mo>+</mml:mo><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula>. Here, <inline-formula><mml:math id="M251" altimg="si64.gif"><mml:mrow><mml:mi>C</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>c</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the number of characters in <inline-formula><mml:math id="M252" altimg="si52.gif"><mml:mi>BWT</mml:mi><mml:mo>[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math></inline-formula> strictly smaller than <italic>c</italic>. These are pre-computed and stored in a small array of size <inline-formula><mml:math id="M253" altimg="si58.gif"><mml:mrow><mml:mo>|</mml:mo><mml:mtext>Σ</mml:mtext><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. As <inline-formula><mml:math id="M254" altimg="si56.gif"><mml:mi>occ</mml:mi><mml:mfenced><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:math></inline-formula> queries can be performed in constant time, exact matching of a pattern <italic>P</italic> takes <inline-formula><mml:math id="M255" altimg="si66.gif"><mml:mrow><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>) time. The size of the obtained interval <inline-formula><mml:math id="M256" altimg="si59.gif"><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the number of occurrences of <italic>P</italic> in <italic>T</italic>. The actual positions of the occurrences in <italic>T</italic> are found using the suffix array. The full-text index that comprises a BWT representation and auxiliary tables is called the FM index and may occupy as little as 2-4 bits of memory per character for DNA sequences (<xref rid="bib4" ref-type="bibr">Ferragina and Manzini, 2000</xref>).</p>
        <p id="p0220">A <italic>bidirectional</italic> FM index is realized by also storing BWT<sub><italic>r</italic></sub>, the Burrows-Wheeler transform of the reverse of <italic>T</italic>. By keeping track of both the range <inline-formula><mml:math id="M257" altimg="si59.gif"><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> over the BWT as well as the range <inline-formula><mml:math id="M258" altimg="si60.gif"><mml:mrow><mml:mo>[</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula> over BWT<sub><italic>r</italic></sub> in a synchronized manner (<xref rid="bib10" ref-type="bibr">Lam et al., 2009</xref>), one can extend a pattern <italic>P</italic> to both <inline-formula><mml:math id="M259" altimg="si61.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> as well as <inline-formula><mml:math id="M260" altimg="si67.gif"><mml:mrow><mml:mi>P</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula>. By replacing the ‘Occ’ data structure with a ‘Prefix-Occ’ structure, this can be realized in constant time (<xref rid="bib14" ref-type="bibr">Pockrandt et al., 2017</xref>).</p>
      </sec>
      <sec id="sec5.3.2">
        <title>Reducing redundancy for the edit distance metric</title>
        <p id="p0225">Consider a search <inline-formula><mml:math id="M261" altimg="si6.gif"><mml:mrow><mml:mi mathvariant="script">S</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>π</mml:mi><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. If all partial occurrences up to part <inline-formula><mml:math id="M262" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> with an edit distance of at most <inline-formula><mml:math id="M263" altimg="si49.gif"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are reported, then an alignment procedure for part <inline-formula><mml:math id="M264" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> will be started for each such occurrence, even though some of them may be redundant. If the search procedure does not change direction in between parts <inline-formula><mml:math id="M265" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M266" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, one can achieve this by increasing the width of the banded alignment matrix (AM) from <inline-formula><mml:math id="M267" altimg="si68.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M268" altimg="si69.gif"><mml:mrow><mml:mn>2</mml:mn><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> as exemplified in <xref rid="fig3" ref-type="fig">Figure 3</xref> (left).<fig id="fig3"><label>Figure 3</label><caption><p>A banded alignment matrix (AM) for which the allowed edit distance increases between parts</p><p>Left: The gray-shaded cells are set during initialization, whereas the white-shaded cells are completed during the execution of the search procedure. Search pattern <italic>P</italic> is depicted horizontally, whereas a branch of the index is depicted vertically. Right: the AM for part <inline-formula><mml:math id="M269" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is initialized around the uppermost cluster center of the final column of part <inline-formula><mml:math id="M270" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p></caption><graphic xlink:href="gr3"/></fig></p>
        <p id="p0230">This approach can be improved upon by taking into account the actual edit distance values observed in the final column of the AM of part <inline-formula><mml:math id="M271" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. It may then be possible to reduce the width of the band of the next part <inline-formula><mml:math id="M272" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. For this, we introduce the notion of a <italic>cluster</italic>. We remind the reader that adjacent cells on a row or column of the AM differ by a value of at most one (see Lemma 3 of (<xref rid="bib13" ref-type="bibr">Masek and Paterson, 1980</xref>)). A cluster <inline-formula><mml:math id="M273" altimg="si70.gif"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M274" altimg="si71.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo linebreak="badbreak">≤</mml:mo><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">&lt;</mml:mo><mml:mi>e</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> at column <italic>j</italic> of the AM contains all elements <inline-formula><mml:math id="M275" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="M276" altimg="si73.gif"><mml:mrow><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> for which it holds that <inline-formula><mml:math id="M277" altimg="si74.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Cell <inline-formula><mml:math id="M278" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is called the center of the cluster and can be thought of as a local minimum. <xref rid="fig4" ref-type="fig">Figure 4</xref> (left) illustrates the clusters of a column of the AM.<fig id="fig4"><label>Figure 4</label><caption><p>Illustrations related to Lemma 1.</p><p>Left: The clusters of a column of the AM are encircled. Note that a cell can be part of two adjacent clusters and that a cluster can consist out of only a single cell. Right: Illustration of proof of Lemma 1, case 1.</p></caption><graphic xlink:href="gr4"/></fig></p>
        <p id="p0235">
          <bold>Lemma 1.</bold>
        </p>
        <p id="p0240">
          <italic>Consider the edit distance alignment of strings X and Y and consider the clusters of some column of the AM. For each optimal alignment path that passes through one or more cells of cluster</italic>
          <inline-formula>
            <mml:math id="M279" altimg="si70.gif">
              <mml:mrow>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>c</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>e</mml:mi>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:math>
          </inline-formula>
          <italic>and that does not pass through the center, an alternative optimal alignment path exists that passes through the center of that cluster.</italic>
        </p>
        <p id="p0245"><bold>Proof</bold> Case 1: the optimal alignment path passes through cell <inline-formula><mml:math id="M280" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math id="M281" altimg="si76.gif"><mml:mrow><mml:mi>s</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula> (see <xref rid="fig4" ref-type="fig">Figure 4</xref> right). By definition of a cluster, it holds that <inline-formula><mml:math id="M282" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> = <inline-formula><mml:math id="M283" altimg="si77.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Assume that <inline-formula><mml:math id="M284" altimg="si78.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is the leftmost cell on row <italic>c</italic> through which the optimal alignment path passes. Because the edit distance can only increase along an alignment path, <inline-formula><mml:math id="M285" altimg="si78.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M286" altimg="si79.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M287" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, hence <inline-formula><mml:math id="M288" altimg="si78.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M289" altimg="si79.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M290" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> + <inline-formula><mml:math id="M291" altimg="si80.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (1). Because also <inline-formula><mml:math id="M292" altimg="si78.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M293" altimg="si81.gif"><mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≤</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="M294" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> + <inline-formula><mml:math id="M295" altimg="si82.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (2), it follows from (1) and (2) that <inline-formula><mml:math id="M296" altimg="si83.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The optimal alignment path between matrix cells <inline-formula><mml:math id="M297" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M298" altimg="si78.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> entails exactly <inline-formula><mml:math id="M299" altimg="si84.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> gaps. It then follows that <inline-formula><mml:math id="M300" altimg="si85.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and hence, <inline-formula><mml:math id="M301" altimg="si86.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">≥</mml:mo><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Together with inequality (2), it follows that <inline-formula><mml:math id="M302" altimg="si87.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Therefore, an alternative optimal alignment path runs from the origin to <inline-formula><mml:math id="M303" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; from <inline-formula><mml:math id="M304" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M305" altimg="si78.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and then proceeds in an identical manner as the original path.</p>
        <p id="p0250">Case 2: the optimal alignment path passes through cell <inline-formula><mml:math id="M306" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math id="M307" altimg="si88.gif"><mml:mrow><mml:mi>c</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="goodbreak" linebreakstyle="after">&lt;</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula>. Because of the definition of a cluster, it holds that <inline-formula><mml:math id="M308" altimg="si89.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">=</mml:mo><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow><mml:mo linebreak="goodbreak" linebreakstyle="after">+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The value <inline-formula><mml:math id="M309" altimg="si72.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> can thus always originate from <inline-formula><mml:math id="M310" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> through a vertical path, as the difference in rows between these two cells is exactly <inline-formula><mml:math id="M311" altimg="si90.gif"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">−</mml:mo><mml:mi>c</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Again, an alternative optimal alignment path exists from the origin to cell <inline-formula><mml:math id="M312" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; from <inline-formula><mml:math id="M313" altimg="si75.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M314" altimg="si91.gif"><mml:mrow><mml:mtext>AM</mml:mtext><mml:mrow><mml:mo>[</mml:mo><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; and then proceeds in an identical manner as the original path. ∎</p>
        <p id="p0255">We leverage Lemma 1 to save computations: when part <inline-formula><mml:math id="M315" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is processed, we identify the uppermost cluster center in the last column of the alignment matrix of part <inline-formula><mml:math id="M316" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that has a value between <inline-formula><mml:math id="M317" altimg="si92.gif"><mml:mrow><mml:mi>L</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M318" altimg="si49.gif"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The cells above this cluster center can be ignored: even when they take part in some optimal alignment path, there will always be an alternative optimal path that passes through the center cell (lemma 1). By ignoring these cells, the banded alignment matrix for the next part may be initialized with a reduced width and the number of edit cells to be computed in the next part is reduced. In <xref rid="fig3" ref-type="fig">Figure 3</xref> (right), this is exemplified.</p>
        <p id="p0260">In case the search changes direction in between parts <inline-formula><mml:math id="M319" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M320" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> the same redundancy problem arises. By reporting <italic>all</italic> approximate (partial) matches with an edit distance of at most <inline-formula><mml:math id="M321" altimg="si49.gif"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, multiple, possibly redundant alignments will be started in the other direction. Again, this can be mitigated using the cluster concept. Two cases exist. First, assume part <inline-formula><mml:math id="M322" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is either the leftmost or rightmost part of pattern <italic>P</italic>. This implies that the partial matches will no longer be extended in the current direction. Instead of reporting <italic>all</italic> partial occurrences with an edit distance of at most <inline-formula><mml:math id="M323" altimg="si49.gif"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, we report only the partial match associated to the cluster center with the lowest value. If multiple such centers exist, then the uppermost one is reported, corresponding to the shortest (partial) match. In the second case, if part <inline-formula><mml:math id="M324" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is neither the leftmost or rightmost part of pattern <italic>P</italic>, partial matches are first extended in the <italic>other</italic> direction before resuming the extension in the <italic>present</italic> direction. In this case, we cannot <italic>a priori</italic> assume that an optimal alignment path of the entire pattern <italic>P</italic> (if such alignment exists) will pass through the cluster center with the lowest value. However, due to lemma 1, we know that such optimal alignment path (or an alternative, equivalent path) <italic>will</italic> pass through <italic>one</italic> of the cluster centers. Therefore, when part <inline-formula><mml:math id="M325" altimg="si48.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has been processed, we extend (in the other direction) <italic>only</italic> the FM-range corresponding to the <italic>deepest</italic> point in present branch with the knowledge that this partial match will ultimately turn out to have an edit distance between the lowest and highest cluster center values. This information is valuable when checking the <inline-formula><mml:math id="M326" altimg="si93.gif"><mml:mrow><mml:mi>L</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M327" altimg="si94.gif"><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bounds during the processing of part <inline-formula><mml:math id="M328" altimg="si50.gif"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>π</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mi>i</mml:mi><mml:mo linebreak="badbreak">+</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
  </sec>
</body>
<back>
  <ref-list id="cebib0010">
    <title>References</title>
    <ref id="bib1">
      <element-citation publication-type="journal" id="sref1">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>M.I.</given-names>
          </name>
          <name>
            <surname>Kurtz</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Ohlebusch</surname>
            <given-names>E.</given-names>
          </name>
        </person-group>
        <article-title>Replacing suffix trees with enhanced suffix arrays</article-title>
        <source>J. Discrete Algorithms</source>
        <volume>2</volume>
        <year>2004</year>
        <fpage>53</fpage>
        <lpage>86</lpage>
        <pub-id pub-id-type="doi">10.1016/S1570-8667(03)00065-0</pub-id>
      </element-citation>
    </ref>
    <ref id="bib2">
      <element-citation publication-type="journal" id="sref2">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E.W.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <volume>215</volume>
        <year>1990</year>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-2836(05)80360-2</pub-id>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="bib3">
      <element-citation publication-type="journal" id="sref3">
        <person-group person-group-type="author">
          <name>
            <surname>Burrows</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Wheeler</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>A block-sorting lossless data compression algorithm. Technical report</article-title>
        <source>Digit. Syst. Res. Cent.</source>
        <year>1994</year>
        <pub-id pub-id-type="doi">10.1109/DCC.1997.582009</pub-id>
      </element-citation>
    </ref>
    <ref id="bib4">
      <element-citation publication-type="book" id="sref4">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <chapter-title>Opportunistic data structures with applications</chapter-title>
        <source>Proceedings 41st Annual Symposium on Foundations of Computer Science</source>
        <year>2000</year>
        <fpage>390</fpage>
        <lpage>398</lpage>
        <pub-id pub-id-type="doi">10.1109/SFCS.2000.892127</pub-id>
      </element-citation>
    </ref>
    <ref id="bib5">
      <element-citation publication-type="journal" id="sref5">
        <person-group person-group-type="author">
          <name>
            <surname>Gog</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Petri</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Optimized succinct data structures for massive data</article-title>
        <source>Softw. Pract. Exp.</source>
        <volume>44</volume>
        <year>2014</year>
        <fpage>1287</fpage>
        <lpage>1314</lpage>
        <pub-id pub-id-type="doi">10.1002/spe.2198</pub-id>
      </element-citation>
    </ref>
    <ref id="bib6">
      <element-citation publication-type="book" id="sref6">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <chapter-title>Algorithms on Strings, Trees, and Sequences : Computer Science and Computational Biology</chapter-title>
        <year>2007</year>
        <publisher-name>Cambridge Univ. Press</publisher-name>
        <pub-id pub-id-type="doi">10.1017/CBO9780511574931</pub-id>
      </element-citation>
    </ref>
    <ref id="bib7">
      <element-citation publication-type="journal" id="sref7">
        <person-group person-group-type="author">
          <name>
            <surname>Kent</surname>
            <given-names>W.J.</given-names>
          </name>
        </person-group>
        <article-title>BLAT – the BLAST-like alignment tool</article-title>
        <source>Genome Res.</source>
        <volume>12</volume>
        <year>2002</year>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.229202</pub-id>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </element-citation>
    </ref>
    <ref id="bib8">
      <element-citation publication-type="journal" id="sref8">
        <person-group person-group-type="author">
          <name>
            <surname>Kianfar</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Pockrandt</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Torkamandi</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Luo</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>Optimum search schemes for approximate string matching using bidirectional fm-index</article-title>
        <source>arXiv</source>
        <year>2018</year>
        <comment>1711.02035</comment>
      </element-citation>
    </ref>
    <ref id="bib9">
      <element-citation publication-type="book" id="sref9">
        <person-group person-group-type="author">
          <name>
            <surname>Kucherov</surname>
            <given-names>G.</given-names>
          </name>
          <name>
            <surname>Salikhov</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Tsur</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <chapter-title>Approximate string matching using a bidirectional index</chapter-title>
        <person-group person-group-type="editor">
          <name>
            <surname>Kulikov</surname>
            <given-names>A.S.</given-names>
          </name>
          <name>
            <surname>Kuznetsov</surname>
            <given-names>S.O.</given-names>
          </name>
          <name>
            <surname>Pevzner</surname>
            <given-names>P.</given-names>
          </name>
        </person-group>
        <source>Combinatorial Pattern Matching</source>
        <year>2014</year>
        <publisher-name>Springer International Publishing</publisher-name>
        <fpage>222</fpage>
        <lpage>231</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-319-07566-2_23</pub-id>
      </element-citation>
    </ref>
    <ref id="bib10">
      <element-citation publication-type="book" id="sref10">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Tam</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <chapter-title>High throughput short read alignment via bi-directional BWT</chapter-title>
        <source>IEEE International Conference on Bioinformatics and Biomedicine</source>
        <year>2009</year>
        <fpage>31</fpage>
        <lpage>36</lpage>
        <pub-id pub-id-type="doi">10.1109/BIBM.2009.42</pub-id>
      </element-citation>
    </ref>
    <ref id="bib11">
      <element-citation publication-type="journal" id="sref11">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <volume>25</volume>
        <year>2009</year>
        <fpage>1754</fpage>
        <lpage>1760</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp324</pub-id>
        <pub-id pub-id-type="pmid">19451168</pub-id>
      </element-citation>
    </ref>
    <ref id="bib12">
      <element-citation publication-type="book" id="sref12">
        <person-group person-group-type="author">
          <name>
            <surname>Maaß</surname>
            <given-names>M.G.</given-names>
          </name>
        </person-group>
        <chapter-title>Linear bidirectional on-line construction of affix trees</chapter-title>
        <person-group person-group-type="editor">
          <name>
            <surname>Giancarlo</surname>
            <given-names>R.</given-names>
          </name>
          <name>
            <surname>Sankoff</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <source>Combinatorial Pattern Matching</source>
        <year>2000</year>
        <publisher-name>Springer Berlin Heidelberg</publisher-name>
        <fpage>320</fpage>
        <lpage>334</lpage>
        <pub-id pub-id-type="doi">10.1007/s00453-003-1029-2</pub-id>
      </element-citation>
    </ref>
    <ref id="bib13">
      <element-citation publication-type="journal" id="sref13">
        <person-group person-group-type="author">
          <name>
            <surname>Masek</surname>
            <given-names>W.J.</given-names>
          </name>
          <name>
            <surname>Paterson</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>A faster algorithm computing string edit distances</article-title>
        <source>J. Comput. Syst. Sci.</source>
        <volume>20</volume>
        <year>1980</year>
        <fpage>18</fpage>
        <lpage>31</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-0000(80)90002-1</pub-id>
      </element-citation>
    </ref>
    <ref id="bib15">
      <element-citation publication-type="book" id="sref15">
        <person-group person-group-type="author">
          <name>
            <surname>Pockrandt</surname>
            <given-names>C.M.</given-names>
          </name>
        </person-group>
        <chapter-title>Approximate String Matching: Improving Data Structures and Algorithms</chapter-title>
        <comment>Ph.D. thesis</comment>
        <year>2019</year>
        <publisher-name>Freien Universität Berlin</publisher-name>
        <pub-id pub-id-type="doi">10.17169/refubium-2185</pub-id>
      </element-citation>
    </ref>
    <ref id="bib14">
      <element-citation publication-type="journal" id="sref14">
        <person-group person-group-type="author">
          <name>
            <surname>Pockrandt</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Ehrhardt</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>EPR-dictionaries: a practical and fast data structure for constant time searches in unidirectional and bidirectional FM-indices</article-title>
        <source>Lect. Notes Comput. Sci.</source>
        <volume>10229</volume>
        <year>2017</year>
        <pub-id pub-id-type="doi">10.1007/978-3-319-56970-3_12</pub-id>
      </element-citation>
    </ref>
    <ref id="bib16">
      <element-citation publication-type="journal" id="sref16">
        <person-group person-group-type="author">
          <name>
            <surname>Schneider</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Graves-Lindsay</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Howe</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Bouk</surname>
            <given-names>N.</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>H.C.</given-names>
          </name>
          <name>
            <surname>Kitts</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Murphy</surname>
            <given-names>T.</given-names>
          </name>
          <name>
            <surname>Pruitt</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Thibaud-Nissen</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Albracht</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>Evaluation of GRCh38 and de novo haploid genome assemblies demonstrates the enduring quality of the reference assembly</article-title>
        <source>Genome Res.</source>
        <volume>27</volume>
        <year>2017</year>
        <pub-id pub-id-type="doi">10.1101/gr.213611.116</pub-id>
      </element-citation>
    </ref>
    <ref id="bib17">
      <element-citation publication-type="journal" id="sref17">
        <person-group person-group-type="author">
          <name>
            <surname>Strothmann</surname>
            <given-names>D.</given-names>
          </name>
        </person-group>
        <article-title>The affix array data structure and its applications to RNA secondary structure analysis</article-title>
        <source>Theor. Comput. Sci.</source>
        <volume>389</volume>
        <year>2007</year>
        <fpage>278</fpage>
        <lpage>294</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2007.09.029</pub-id>
      </element-citation>
    </ref>
    <ref id="bib18">
      <element-citation publication-type="book" id="sref18">
        <person-group person-group-type="author">
          <name>
            <surname>Vigna</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <chapter-title>Broadword implementation of rank/select queries</chapter-title>
        <person-group person-group-type="editor">
          <name>
            <surname>McGeoch</surname>
            <given-names>C.C.</given-names>
          </name>
        </person-group>
        <source>Experimental Algorithms</source>
        <year>2008</year>
        <publisher-name>Springer Berlin Heidelberg</publisher-name>
        <fpage>154</fpage>
        <lpage>168</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-540-68552-4_12</pub-id>
      </element-citation>
    </ref>
    <ref id="bib19">
      <element-citation publication-type="journal" id="sref19">
        <person-group person-group-type="author">
          <name>
            <surname>Vroland</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Salson</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Bini</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Touzet</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Approximate search of short patterns with high error rates using the 01∗0 lossless seeds</article-title>
        <source>J. Discrete Algorithms</source>
        <volume>37</volume>
        <year>2016</year>
        <fpage>3</fpage>
        <lpage>16</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jda.2016.03.002</pub-id>
      </element-citation>
    </ref>
  </ref-list>
  <sec id="appsec2" sec-type="supplementary-material">
    <title>Supplemental information</title>
    <p id="p0285">
      <supplementary-material content-type="local-data" id="mmc1">
        <caption>
          <title>Document S1. Tables S1–S7</title>
        </caption>
        <media xlink:href="mmc1.pdf"/>
      </supplementary-material>
    </p>
  </sec>
  <ack id="ack0010">
    <title>Acknowledgments</title>
    <p id="p0265">The authors received no specific funding for this work.</p>
    <sec id="sec6">
      <title>Author contributions</title>
      <p id="p0270">L.R. and J.F. designed and implemented the algorithms. L.R. performed all benchmarks. K.M. and J.F. supervised the study. All authors have written and approved the manuscript.</p>
    </sec>
    <sec sec-type="COI-statement" id="sec7">
      <title>Declaration of interests</title>
      <p id="p0275">The authors declare no competing interests.</p>
    </sec>
  </ack>
  <fn-group>
    <fn id="appsec1" fn-type="supplementary-material">
      <p id="p0280">Supplemental information can be found online at <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.isci.2021.102687" id="intref0060">https://doi.org/10.1016/j.isci.2021.102687</ext-link>.</p>
    </fn>
  </fn-group>
</back>
