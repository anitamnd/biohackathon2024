<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7495891</article-id>
    <article-id pub-id-type="publisher-id">3685</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-020-03685-1</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GPU acceleration of Darwin read overlapper for de novo assembly of long DNA reads</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Ahmed</surname>
          <given-names>Nauman</given-names>
        </name>
        <address>
          <email>n.ahmed@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Qiu</surname>
          <given-names>Tong Dong</given-names>
        </name>
        <address>
          <email>T.D.Qiu@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bertels</surname>
          <given-names>Koen</given-names>
        </name>
        <address>
          <email>k.l.m.bertels@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Al-Ars</surname>
          <given-names>Zaid</given-names>
        </name>
        <address>
          <email>z.al-ars@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.5292.c</institution-id><institution-id institution-id-type="ISNI">0000 0001 2097 4740</institution-id><institution>Delft University of Technology, </institution></institution-wrap>Delft, Netherlands </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.444938.6</institution-id><institution>University of Engineering and Technology Lahore, </institution></institution-wrap>Lahore, Pakistan </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>17</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>17</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>21</volume>
    <issue>Suppl 13</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</issue-sponsor>
    <elocation-id>388</elocation-id>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">In Overlap-Layout-Consensus (OLC) based de novo assembly, all reads must be compared with every other read to find overlaps. This makes the process rather slow and limits the practicality of using de novo assembly methods at a large scale in the field. Darwin is a fast and accurate read overlapper that can be used for de novo assembly of state-of-the-art third generation long DNA reads. Darwin is designed to be hardware-friendly and can be accelerated on specialized computer system hardware to achieve higher performance.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">This work accelerates Darwin on GPUs. Using real Pacbio data, our GPU implementation on Tesla K40 has shown a speedup of 109x vs 8 CPU threads of an Intel Xeon machine and 24x vs 64 threads of IBM Power8 machine. The GPU implementation supports both linear and affine gap, scoring model. The results show that the GPU implementation can achieve the same high speedup for different scoring schemes.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">The GPU implementation proposed in this work shows significant improvement in performance compared to the CPU version, thereby making it accessible for utilization as a practical read overlapper in a DNA assembly pipeline. Furthermore, our GPU acceleration can also be used for performing fast Smith-Waterman alignment between long DNA reads. GPU hardware has become commonly available in the field today, making the proposed acceleration accessible to a larger public. The implementation is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/Tongdongq/darwin-gpu">https://github.com/Tongdongq/darwin-gpu</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Genomics</kwd>
      <kwd>Read overlapper</kwd>
      <kwd>De novo assembly</kwd>
      <kwd>Long DNA reads</kwd>
      <kwd>GPU acceleration</kwd>
    </kwd-group>
    <conference xlink:href="http://epigenomics.snu.ac.kr/APBC2020/">
      <conf-name>The 18th Asia Pacific Bioinformatics Conference</conf-name>
      <conf-acronym>APBC 2020</conf-acronym>
      <conf-loc>Seoul, Korea</conf-loc>
      <conf-date>18-20 August 2020</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>DNA sequencing techniques used today produce short pieces of data (called reads) that represent parts of the sampled DNA, possibly containing some errors. The length and error rate of these reads depends on the sequencing technique used. DNA assembly tries to combine the reads into larger, more accurate DNA segments. For these DNA reads, graph-based assemblers are used for the assembly process, which comes in two flavors: Overlap-Layout-Consensus (OLC) and de Bruijn Graph (dBG).</p>
    <p>The OLC assemblers [<xref ref-type="bibr" rid="CR1">1</xref>] first find overlaps and build an overlap graph. Each node represents a read, and each edge represents an overlap between two reads. During the layout phase, the graph is analyzed to find paths, corresponding to segments of the original genome. The perfect graph contains one path that visits each node exactly once. This problem can be described as finding a Hamiltonian Path. A Hamiltonian Path includes all vertices of a graph exactly once. Examples of assemblers that use the OLC approach are Dazzler [<xref ref-type="bibr" rid="CR2">2</xref>] and SGA [<xref ref-type="bibr" rid="CR3">3</xref>].</p>
    <p>In dBG based assemblers [<xref ref-type="bibr" rid="CR4">4</xref>], each read is divided into <italic>K</italic>-<italic>mers</italic>. A <italic>K</italic>-<italic>mer</italic> is a substring of a read having a length <italic>K</italic>. Each <italic>K</italic>-<italic>mer</italic> represents a directed edge between two vertices, where the source vertex represents the first <italic>K</italic>−1 bases of the <italic>K</italic>-<italic>mer</italic>, and the destination vertex the last <italic>K</italic>−1 bases of the <italic>K</italic>-<italic>mer</italic>. When a particular <italic>K</italic>−1 vertex does not exist, it is created, otherwise, the existing one is reused. The weights of the edges indicate how many times a particular <italic>K</italic>-<italic>mer</italic> is encountered. The next step is to find an Eulerian Path, which is a path that includes all edges of a graph exactly once. Examples of dBG assemblers are Velvet [<xref ref-type="bibr" rid="CR5">5</xref>], ABySS [<xref ref-type="bibr" rid="CR6">6</xref>] and SOAPdenovo2 [<xref ref-type="bibr" rid="CR7">7</xref>].</p>
    <p>So called Next Generation Sequencing (NGS) techniques produce reads with lengths anywhere from 50 to 500 base pairs. They can be produced at high throughput but at the expense of a smaller read length. However, DNA can contain repeat regions, where a certain piece of DNA is repeated many times back-to-back, or a repeat could appear in many different places in the genome. Since these repeats can be longer than the produced short reads, this means the reads cannot be used to resolve these repeat regions. Third generation sequencing produces much longer reads, of up to 60K base pairs. Due to their length, these reads are more likely to contain a whole repeat region, which makes them suitable for accurately reconstructing the repeat regions. A major drawback of longer DNA reads is their higher error rate, ranging from 15-30%, depending on the exact sequencing technology. dBG based assembly is the more preferred approach for NGS reads, which are much shorter and have much lower error rates. However, de Bruijn Graphs are quite susceptible to sequencing errors, since one substituted base pair causes <italic>K</italic> incorrect <italic>K</italic>-<italic>mers</italic>. Pair this with an often-used values of <italic>K</italic> above 50 and third generation sequencing error rate of about 15%, it is clear that the graph will contain a lot of incorrect edges. Therefore, OLC based assemblers are more suitable for state-of-the-art third generation long DNA reads produced by Pacbio and Oxford Nanopore sequencers.</p>
    <p>Darwin [<xref ref-type="bibr" rid="CR8">8</xref>] is a read overlapper for the assembly of long DNA reads. Darwin is designed to be highly accurate, achieving a sensitivity of 99.89% and a precision of 88.30% for simulated Pacbio reads. This is higher than other commonly used read overlappers such as Daligner [<xref ref-type="bibr" rid="CR2">2</xref>]. The ASIC (Application-Specific Integrated Circuit) implementation of Darwin is shown to be hundreds of times faster than other software based overlappers. However, ASIC implementation requires bulk volume production to be economically feasible. Moreover, DNA analysis using high-throughput DNA sequencing is an evolving field, and any major improvement in the algorithm will require a new ASIC implementation which costs both time and money.</p>
    <p>Heterogeneous systems with GPU accelerators have become easily accessible due to their widespread use. They have shown convincing speedups in many high performance computing applications. Therefore, GPU acceleration of various genome analysis algorithms has been the topic of many research works, like in [<xref ref-type="bibr" rid="CR9">9</xref>, <xref ref-type="bibr" rid="CR10">10</xref>] and [<xref ref-type="bibr" rid="CR11">11</xref>]. In this paper, we present a GPU accelerated version of Darwin. We identified the computational bottleneck in the Darwin software and replaced it with the GPU accelerated version. The accelerated implementation proposed in this paper is orders of magnitude faster than its software counterpart. The contributions of the paper are as follows:
<list list-type="bullet"><list-item><p>The paper shows the GPU implementation of the Darwin read overlapper used in the de novo assembly of long DNA reads.</p></list-item><list-item><p>The paper shows that the GPU acceleration of Darwin is orders of magnitude faster than the multithreaded software version on both IBM Power8 and Intel Xeon machines using a real Pacbio dataset.</p></list-item><list-item><p>The results in the paper show that the GPU implementation of Darwin can also be applied for accelerating Smith-Waterman alignment of long DNA reads.</p></list-item></list></p>
  </sec>
  <sec id="Sec2">
    <title>Background</title>
    <p>Smith-Waterman (SW) [<xref ref-type="bibr" rid="CR12">12</xref>] algorithm finds local alignment between a pair of sequences. Smith-Waterman is exact, producing the optimal local alignment. It can be implemented using dynamic programming which computes a 2D matrix <italic>S</italic>. Let <italic>V</italic> and <italic>W</italic> be the two sequences to be aligned. Let <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$V_{0}, V1, \dots, V_{|V|-1}$\end{document}</tex-math><mml:math id="M2"><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq1.gif"/></alternatives></inline-formula> and <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$W_{0}, W1, \dots, W_{|W|-1}$\end{document}</tex-math><mml:math id="M4"><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>W</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>W</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq2.gif"/></alternatives></inline-formula> be the bases of <italic>V</italic> and <italic>W</italic>, respectively. |<italic>V</italic>| and |<italic>W</italic>| are the lengths of <italic>V</italic> and <italic>W</italic>. <italic>S</italic>(<italic>i</italic>,−1)=<italic>S</italic>(−1,<italic>j</italic>)=0 for <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$i=0, 1, 2 \dots, |V|-1$\end{document}</tex-math><mml:math id="M6"><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq3.gif"/></alternatives></inline-formula> and <inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$j=0, 1, 2 \dots, |W|-1$\end{document}</tex-math><mml:math id="M8"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>W</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq4.gif"/></alternatives></inline-formula>. The cells in the matrix are computed using the following recurrence relation:
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} S(i,j) =&amp; max\left\{\begin{array}{lccc} S(i-1,j) + gap \\ S(i,j-1) + gap \\ S(i-1,j-1) + subt\left(V_{i},W_{j}\right) \\ 0 \\ \end{array}\right. ~ \end{array} $$ \end{document}</tex-math><mml:math id="M10"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo></mml:mtd><mml:mtd class="align-2"><mml:mtext mathvariant="italic">max</mml:mtext><mml:mfenced open="{"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">gap</mml:mtext></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">gap</mml:mtext></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">subt</mml:mtext><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr/></mml:mtable></mml:mrow></mml:mfenced><mml:mspace width="1em"/><mml:mspace width="2em"/></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2020_3685_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
    <p>
      <disp-formula id="Equ2">
        <label>2</label>
        <alternatives>
          <tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} m_{i,j} =&amp;\left\{\begin{array}{cc} (i, j) &amp; S(i,j) &gt; m \\ m_{i,j} &amp; S(i,j) \le m \\ \end{array}\right. ~ \end{array} $$ \end{document}</tex-math>
          <mml:math id="M12">
            <mml:mtable class="align" columnalign="left">
              <mml:mtr>
                <mml:mtd class="align-1">
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>m</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mo>,</mml:mo>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                </mml:mtd>
                <mml:mtd class="align-2">
                  <mml:mfenced open="{">
                    <mml:mrow>
                      <mml:mtable>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                          </mml:mtd>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                            <mml:mo>&gt;</mml:mo>
                            <mml:mi>m</mml:mi>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>m</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>j</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mtd>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                            <mml:mo>≤</mml:mo>
                            <mml:mi>m</mml:mi>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr/>
                      </mml:mtable>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mspace width="1em"/>
                  <mml:mspace width="2em"/>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
          <graphic xlink:href="12859_2020_3685_Article_Equ2.gif" position="anchor"/>
        </alternatives>
      </disp-formula>
    </p>
    <p>
      <disp-formula id="Equ3">
        <label>3</label>
        <alternatives>
          <tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} m =&amp; max\left\{\begin{array}{cc} m \\ S(i,j) \end{array}\right. ~ \end{array} $$ \end{document}</tex-math>
          <mml:math id="M14">
            <mml:mtable class="align" columnalign="left">
              <mml:mtr>
                <mml:mtd class="align-1">
                  <mml:mi>m</mml:mi>
                  <mml:mo>=</mml:mo>
                </mml:mtd>
                <mml:mtd class="align-2">
                  <mml:mtext mathvariant="italic">max</mml:mtext>
                  <mml:mfenced open="{">
                    <mml:mrow>
                      <mml:mtable>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mi>m</mml:mi>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mspace width="1em"/>
                  <mml:mspace width="2em"/>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
          <graphic xlink:href="12859_2020_3685_Article_Equ3.gif" position="anchor"/>
        </alternatives>
      </disp-formula>
    </p>
    <p>
      <disp-formula id="Equ4">
        <label>4</label>
        <alternatives>
          <tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} D(i,j) =&amp;\left\{\begin{array}{clcc} 0 &amp; S(i, j) = 0 \\ \uparrow &amp; S(i, j) = S(i-1, j) \\ \leftarrow &amp; S(i, j) = S(i, j-1) \\ \nwarrow &amp; S(i, j) = S(i-1,j-1) + subt\left(V_{i},W_{j}\right) \\ \end{array}\right. \end{array} $$ \end{document}</tex-math>
          <mml:math id="M16">
            <mml:mtable class="align" columnalign="left">
              <mml:mtr>
                <mml:mtd class="align-1">
                  <mml:mi>D</mml:mi>
                  <mml:mo>(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>,</mml:mo>
                  <mml:mi>j</mml:mi>
                  <mml:mo>)</mml:mo>
                  <mml:mo>=</mml:mo>
                </mml:mtd>
                <mml:mtd class="align-2">
                  <mml:mfenced open="{">
                    <mml:mrow>
                      <mml:mtable>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mn>0</mml:mn>
                          </mml:mtd>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                            <mml:mo>=</mml:mo>
                            <mml:mn>0</mml:mn>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mi>↑</mml:mi>
                          </mml:mtd>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                            <mml:mo>=</mml:mo>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mo>←</mml:mo>
                          </mml:mtd>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                            <mml:mo>=</mml:mo>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:mo>↖</mml:mo>
                          </mml:mtd>
                          <mml:mtd>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>)</mml:mo>
                            <mml:mo>=</mml:mo>
                            <mml:mi>S</mml:mi>
                            <mml:mo>(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>)</mml:mo>
                            <mml:mo>+</mml:mo>
                            <mml:mtext mathvariant="italic">subt</mml:mtext>
                            <mml:mfenced close=")" open="(">
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>V</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi>i</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                                <mml:mo>,</mml:mo>
                                <mml:msub>
                                  <mml:mrow>
                                    <mml:mi>W</mml:mi>
                                  </mml:mrow>
                                  <mml:mrow>
                                    <mml:mi>j</mml:mi>
                                  </mml:mrow>
                                </mml:msub>
                              </mml:mrow>
                            </mml:mfenced>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr/>
                      </mml:mtable>
                    </mml:mrow>
                  </mml:mfenced>
                  <mml:mspace width="2em"/>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
          <graphic xlink:href="12859_2020_3685_Article_Equ4.gif" position="anchor"/>
        </alternatives>
      </disp-formula>
    </p>
    <p>Here, <italic>S</italic> and <italic>D</italic> are the score and traceback matrices, respectively. <italic>match</italic>, <italic>mismatch</italic> and <italic>gap</italic> are numeric parameters. <italic>s</italic><italic>u</italic><italic>b</italic><italic>t</italic>(<italic>V</italic><sub><italic>i</italic></sub>,<italic>W</italic><sub><italic>j</italic></sub>) is equal to <italic>match</italic> if <italic>V</italic><sub><italic>i</italic></sub>=<italic>W</italic><sub><italic>j</italic></sub>, and is equal to <italic>mismatch</italic> otherwise. <italic>gap</italic> is the penalty for inserting a gap. <italic>m</italic> is the alignment score, which is initialized to zero, and <italic>m</italic><sub><italic>i</italic>,<italic>j</italic></sub> is the corresponding position on <italic>V</italic> and <italic>W</italic>. The traceback matrix is required to compute the actual alignment. Traceback starts from the highest scoring cell and follows the arrows in <italic>D</italic> until a zero or a boundary of the matrix is encountered. Equations <xref rid="Equ1" ref-type="">1</xref> and <xref rid="Equ3" ref-type="">3</xref> indicate that for computing the alignment score <italic>m</italic> there is no need to store the whole <italic>S</italic> matrix as all cells of the <italic>S</italic> matrix are computed using only the values of three other cells <italic>S</italic>(<italic>i</italic>−1,<italic>j</italic>), <italic>S</italic>(<italic>i</italic>,<italic>j</italic>−1) and <italic>S</italic>(<italic>i</italic>−1,<italic>j</italic>−1). Hence, to compute the alignment score, storing only the values in the previous row and column are sufficient to compute <italic>m</italic>. The above equations are for calculating the alignment with a linear-gap scoring model. However, Darwin and our GPU implementation also support the more commonly used affine gap penalty model in which there are separate penalties for opening a gap (<italic>gapo</italic>) and extending a gap (<italic>gape</italic>).</p>
    <p>A straightforward way of finding all overlaps is performing an alignment algorithm, such as Smith-Waterman, on every pair of reads. The number of alignments is quadratic with the number of reads, and the runtime of one alignment is quadratic with the lengths of the involved reads, making this method not feasible. Many heuristic algorithms have been developed to perform this alignment, for different lengths and error rates. Seed-and-extend is one heuristic, which dramatically reduces the amount of computation needed [<xref ref-type="bibr" rid="CR13">13</xref>]. A seed is a <italic>K</italic>-<italic>mer</italic> made up of <italic>K</italic> consecutive bases of a read. Instead of performing Smith-Waterman on each read pair, only read pairs that have one or more common <italic>K</italic>-<italic>mers</italic> are aligned. A common <italic>K</italic>-<italic>mer</italic> between two or more reads is known as a “seed hit”. Darwin also uses the seed-and-extend approach, which reduces the amount of computation needed, without compromising the output by much. Other algorithms, like BLAST [<xref ref-type="bibr" rid="CR14">14</xref>], also use the seed-and-extend approach, but give sub-optimal alignments. Results in [<xref ref-type="bibr" rid="CR8">8</xref>] show that Darwin provides optimal Smith-Waterman alignments between long DNA sequences with error rates up to 40%.</p>
    <sec id="Sec3">
      <title>Darwin</title>
      <p>Darwin is read overlapping algorithm for de novo assembly of third-generation long DNA reads. It is based on the seed-and-extend. It consists of a filter called D-SOFT (Diagonal-band Seed Overlapping based Filtration Technique), which finds seed hits, and GACT (Genome Alignment using Constant memory Traceback), which extends the seed hit by performing sequence alignment between the sequences on the left and right of the seed hit. Figure <xref rid="Fig1" ref-type="fig">1</xref> shows the seed-and-extend technique employed in Darwin to find the overlap between <italic>Read A</italic> and <italic>Read B</italic>. To compute the overlap, a seed hit is extended on both sides by aligning <italic>R_left</italic> with <italic>Q_left</italic> and <italic>R_right</italic> with <italic>Q_right</italic>. This speedups the computation by avoiding the computation of a large number of dynamic programming matrix cells (grey cells in Fig. <xref rid="Fig1" ref-type="fig">1</xref>).The dynamic programming matrix computed to align <italic>R_left</italic> with <italic>Q_left</italic> is known as <italic>left extension matrix</italic>. Similarly, the dynamic programming matrix computed to align <italic>R_right</italic> with <italic>Q_right</italic> is known as <italic>right extension matrix</italic>.
<fig id="Fig1"><label>Fig. 1</label><caption><p>The seed-and-extend method used in Darwin to find the overlap between <italic>Read A</italic> and <italic>Read B</italic>. <italic>R_left</italic> and <italic>R_right</italic> are the substrings of Read A. <italic>Q_left</italic> and <italic>Q_right</italic> are the substrings of Read B</p></caption><graphic xlink:href="12859_2020_3685_Fig1_HTML" id="MO1"/></fig></p>
      <sec id="Sec4">
        <title>D-SOFT</title>
        <p>D-SOFT is the seeding stage of Darwin, also known as the <italic>filtering</italic> stage. Darwin uses minimizers [<xref ref-type="bibr" rid="CR15">15</xref>] as seeds which are <italic>K</italic>-<italic>mers</italic> extracted from all the reads to be overlapped. The position of a seed is stored in a minimizer table which records the location of the seed in a read along with the identifier of the read. The window size <italic>w</italic> is the most important parameter for building a minimizer table and must be smaller than the seed length (<italic>K</italic>). To obtain seed hits, ‘<italic>N</italic>’ <italic>K</italic>-<italic>mers</italic> of a read are used as seeds that are located in other reads using the minimizer table. Two reads are considered for alignment in the extension phase if they have at least <italic>h</italic> unique bases in common. The pair of reads passing this filter are aligned using a modified Smith-Waterman algorithm described below.</p>
      </sec>
      <sec id="Sec5">
        <title>GACT</title>
        <p>The seed-and-extend approach to find overlap between two reads is much faster than performing the complete Smith-Waterman alignment algorithm. However, the reduced dynamic programming matrices could still be quite large. State-of-the-art third generation sequencers produce reads having lengths in megabases and the dynamic programming matrix in the seed extension may have around 1 Tera cells to compute. For example, if the seed hit lies at the beginning of the two reads, i.e. near the top left corner in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, the right extension matrix is nearly as large as the full matrix.</p>
        <p>Numerous efforts to accelerate Smith-Waterman have been made, both by using hardware like [<xref ref-type="bibr" rid="CR16">16</xref>] and software [<xref ref-type="bibr" rid="CR17">17</xref>]. But the memory required to store the traceback matrix <italic>D</italic> is still an issue. One can apply the Hirschberg’s algorithm described in [<xref ref-type="bibr" rid="CR18">18</xref>] to reduce the RAM storage but at the cost of increase in computation time. Therefore, Darwin proposed the GACT algorithm for seed extension. It has two advantages: 1) All the cells of the right and left extension matrix are not computed reducing the computation time. 2) The traceback matrix is very small. GACT performs normal Smith-Waterman on a submatrix of the extension matrix, known as <italic>tiles</italic> of size <italic>T</italic>x<italic>T</italic>. After computing a tile it computes the next tile, which overlaps the previous tile with at least <italic>O</italic> cells on both axes. For reasonable values for <italic>T</italic> and <italic>O</italic>, GACT has shown to produce the same result as normal Smith-Waterman [<xref ref-type="bibr" rid="CR8">8</xref>]. Figure <xref rid="Fig2" ref-type="fig">2</xref> shows an example of computing the extension matrix with the GACT algorithm. In the example <italic>T</italic>=8 and <italic>O</italic>=3. The tiles are computed in the order <italic>T</italic>1,<italic>T</italic>2,<italic>T</italic>3 and <italic>T</italic>4. The example in Fig. <xref rid="Fig2" ref-type="fig">2</xref> can be used to explain both the computation of left and right extension matrices. The only difference is <inline-formula id="IEq5"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$R = \overline {R\_right}$\end{document}</tex-math><mml:math id="M18"><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mtext>_right</mml:mtext></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq5.gif"/></alternatives></inline-formula> and <inline-formula id="IEq6"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$Q = \overline {Q\_right}$\end{document}</tex-math><mml:math id="M20"><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi>Q</mml:mi><mml:mtext>_right</mml:mtext></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq6.gif"/></alternatives></inline-formula> in case of right extension, where <inline-formula id="IEq7"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R\_right}$\end{document}</tex-math><mml:math id="M22"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mtext>_right</mml:mtext></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq7.gif"/></alternatives></inline-formula> and <inline-formula id="IEq8"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {Q\_right}$\end{document}</tex-math><mml:math id="M24"><mml:mover accent="false"><mml:mrow><mml:mi>Q</mml:mi><mml:mtext>_right</mml:mtext></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq8.gif"/></alternatives></inline-formula> is the reverse of <italic>R_right</italic> and <italic>Q_right</italic> sequences, respectively. Listing 1, shows the algorithm for left extension. Positions <italic>i</italic>_<italic>c</italic><italic>u</italic><italic>r</italic><italic>r</italic> and <italic>j</italic>_<italic>c</italic><italic>u</italic><italic>r</italic><italic>r</italic> are produced by D-SOFT. The start and end position of the current tile are stored in (<italic>i</italic>_<italic>s</italic><italic>t</italic><italic>a</italic><italic>r</italic><italic>t</italic>,<italic>j</italic>_<italic>s</italic><italic>t</italic><italic>a</italic><italic>r</italic><italic>t</italic>) and (<italic>i</italic>_<italic>c</italic><italic>u</italic><italic>r</italic><italic>r</italic>,<italic>j</italic>_<italic>c</italic><italic>u</italic><italic>r</italic><italic>r</italic>), respectively. The traceback path of the whole left extension is kept in <italic>tb_left</italic>. The function <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() uses Smith-Waterman to compute traceback matrix <italic>D</italic> between subsequences <italic>R_tile</italic> and <italic>Q_tile</italic>. Once the traceback matrix is filled, traceback is performed starting from the bottom-right cell, except for the first tile, where traceback starts from the highest-scoring cell. The starting cells of the traceback are coloured yellow in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() returns the number of bases in <italic>R</italic> and <italic>Q</italic> aligned by this tile (<italic>i_off</italic>,<italic>j_off</italic>), the traceback arrows/pointers (<italic>tb</italic>) and the position of the highest-scoring cell (<italic>i_max</italic>,<italic>j_max</italic>). <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() also limits <italic>i_off</italic> and <italic>j_off</italic> to at most <italic>T</italic>−<italic>O</italic> bases, to ensure the next tile overlaps by at least <italic>O</italic> bases on both <italic>R</italic> and <italic>Q</italic>. The green arrows shows the path taken by the traceback in a tile if there is no limit and the traceback is allowed to complete. The left extension finishes when it hits the end of <italic>R</italic> or <italic>Q</italic>, or when traceback cannot add any bases to the existing alignment. The memory needed for the traceback is <inline-formula id="IEq9"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}\left (T^{2}\right)$\end{document}</tex-math><mml:math id="M26"><mml:mi mathvariant="script">O</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq9.gif"/></alternatives></inline-formula>, which is constant since <italic>T</italic> is chosen upfront. The whole alignment of the extension is contained in <italic>tb_left</italic> and is equivalent to the path traced by the red arrows in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. The alignment score of the extension can also be computed with the help of <italic>tb_left</italic> The right extension operates on the reverse of <italic>R</italic> and <italic>Q</italic>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>An example of the GACT algorithm</p></caption><graphic xlink:href="12859_2020_3685_Fig2_HTML" id="MO2"/></fig></p>
        <p>
          <graphic position="anchor" xlink:href="12859_2020_3685_Figb_HTML" id="MO9"/>
        </p>
        <p>The performance of GACT is linear (<italic>O</italic>(<italic>m</italic><italic>a</italic><italic>x</italic>{|<italic>R</italic><italic>e</italic><italic>a</italic><italic>d</italic><italic>A</italic>|,|<italic>R</italic><italic>e</italic><italic>a</italic><italic>d</italic><italic>B</italic>|}·<italic>T</italic>)) where |<italic>R</italic><italic>e</italic><italic>a</italic><italic>d</italic><italic>A</italic>| and |<italic>R</italic><italic>e</italic><italic>a</italic><italic>d</italic><italic>B</italic>| are the lengths of <italic>Read A</italic> and <italic>Read B</italic>, respectively. It is more suited for long reads than banded alignment [<xref ref-type="bibr" rid="CR19">19</xref>] because banded alignment uses a static band around the main diagonal. GACT allows for flexible bands since the position of the new tile depends on the traceback path, this is useful for long reads that have high indel rates.</p>
      </sec>
    </sec>
    <sec id="Sec6">
      <title>GPU processing</title>
      <p>A GPU is a Graphics Processing Unit, which is a processor that is mainly used to perform video processing. GPUs contain many cores that allow them to perform parallelizable tasks very quickly. A GPGPU, or General Purpose GPU, can be programmed to perform tasks that are different from video processing. GPUs cannot operate on their own, they must be guided by a CPU. The functions that run on a GPU are called <italic>kernels</italic> and are usually launched by a CPU.</p>
      <p>CUDA is a parallel programming platform that allows people to use Nvidia GPUs for their applications. Developers can write kernels, launched from a CPU function. The GPU is referred to as <italic>device</italic> and the CPU as <italic>host</italic>. Kernels can be launched from the CPU with a certain number of <italic>thread blocks</italic> with each block containing many GPU threads. The number of blocks and the number of threads in a block are the kernel launch parameters. Each thread executes the kernel code, although they usually operate on different data.</p>
      <p>On a hardware level, an NVIDIA GPU is divided into Streaming Multiprocessors (SM). Each SM contains several cores, or Streaming Processors (SP), these are the basic building blocks and perform the actual calculations. Each block is assigned to at most one SM. This block’s threads are then executed as warps, with 32 threads per warp. Each SM has multiple warp schedulers, so multiple warps can run in parallel on an SM. All threads in a warp must execute the same instruction, if a thread is the only to take a branch, the other threads must wait until the branch is completed, this is called <italic>thread divergence</italic>.</p>
      <p>GPUs have several different memory types and levels. It has its own DRAM known as the <italic>global memory</italic> and a cache shared by all SM’s. Accesses to the global memory are also executed in parallel, this means that all threads try to read/write to the memory in parallel. If the addresses are next to each other, only one memory transaction is needed, since a transaction processes a whole memory line. This is known as coalescing. Non-coalesced memory accesses cause multiple memory transactions.</p>
      <p>A general workflow using a GPU is:
<list list-type="order"><list-item><p>Data is copied from the main memory to the GPU global memory.</p></list-item><list-item><p>The CPU launches the GPU kernel.</p></list-item><list-item><p>The GPU executes the kernel.</p></list-item><list-item><p>Results are copied from the GPU to the CPU memory.</p></list-item></list></p>
    </sec>
    <sec id="Sec7">
      <title>Previous research</title>
      <p>Multiple efforts to accelerate the DNA alignment algorithm on GPU have been made. MUMmerGPU [<xref ref-type="bibr" rid="CR20">20</xref>] is one of the first GPU accelerated algorithms, it stores a suffix tree of the reference sequence on the GPU, and aligns it with queries. Its newest GPU implementation shows a 13x speedup over the CPU implementation. CUDAlign [<xref ref-type="bibr" rid="CR21">21</xref>] accelerates the exact Smith-Waterman algorithm and allows an affine gap. The input sequence length is only restricted by the available global memory. It uses linear space and boasts a 702x and 19.5x speedup compared to 1 core and 64 cores, respectively. CUSHAW2-GPU [<xref ref-type="bibr" rid="CR22">22</xref>] is an accelerated short read aligner. Other work has been done on accelerating BWA-MEM [<xref ref-type="bibr" rid="CR23">23</xref>] and Protein database search [<xref ref-type="bibr" rid="CR24">24</xref>].</p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Implementation</title>
    <sec id="Sec9">
      <title>Profiling</title>
      <p>We measured the runtime of various elements of the Darwin algorithm on the CPU. Two notable parts are D-SOFT (which consists of building the minimizer table, and finding the seeds) and aligning using GACT. Of those two, the <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() function in GACT (Listing 1) takes the most time, namely 99.9% for Pacbio reads. Therefore, we accelerated the <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() function on GPU. We selected a tile size <italic>T</italic> of 320 as it gives optimal Smith-Waterman alignment scores [<xref ref-type="bibr" rid="CR8">8</xref>]. With this setting, 63% of the tiles are exactly 320x320. The remaining tiles are smaller as they occur near the edges of <italic>R</italic>-<italic>Q</italic> matrix (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). If some GPU threads have a smaller tile size, it will cause some divergence, because they will have to wait until the threads with larger tile sizes are finished.</p>
    </sec>
    <sec id="Sec10">
      <title>Acceleration</title>
      <p>It is possible to run the whole GACT kernel on the GPU, for both left and right extension. However, since it is not known how long the resulting alignment will be, and all GPU threads have to wait until all threads are done, this will cause lots of idle time. Instead, it is chosen to only have a single tile of size <italic>T</italic>x<italic>T</italic> aligned per GPU-thread per GPU-invocation as shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>. The <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() function for many different <italic>R</italic>,<italic>Q</italic> pairs are executed in parallel on the GPU. Figure <xref rid="Fig4" ref-type="fig">4</xref> shows the flow graph of GPU accelerated Darwin. It has two GPU kernels shown by green processes in the flow graph. All other tasks are performed on the CPU. The CPU builds the minimizer table using all the reads for which the overlaps have to be computed. The accelerated algorithm processes a set of reads to exploit the massive parallelism of the GPU. The CPU first computes the seed hits for all the reads in the set using the D-SOFT algorithm. With the help of the seed hit location the sequences for the left and right extension matrices are determined. i.e. (<italic>R_left</italic>,<italic>Q_left</italic>) and (<italic>R_right</italic>,<italic>Q_right</italic>). One tile (<italic>R_tile</italic>, <italic>Q_tile</italic> pair) from each extension matrix is assigned to a GPU thread for alignment. All the tile alignments are computed in parallel on the GPU. There are enough seed hits, and hence sufficient extension matrices in the set of reads to fully utilize all the GPU resources. In the post-processing step, full alignment of the extension using <italic>tb_left</italic> (and <italic>tb_right</italic> for right extension) is constructed on the CPU. As described in the “<xref rid="Sec9" ref-type="sec">Profiling</xref>” section all the tasks other than computing the alignment between <italic>R_tile</italic> and <italic>Q_tile</italic> takes a negligible amount of time on the CPU.
<fig id="Fig3"><label>Fig. 3</label><caption><p>GPU thread assignment for parallelization of the tile computation in GACT. <italic>th</italic> is a GPU thread</p></caption><graphic xlink:href="12859_2020_3685_Fig3_HTML" id="MO3"/></fig><fig id="Fig4"><label>Fig. 4</label><caption><p>The flow graph of GPU accelerated Darwin. The green boxes are GPU kernels</p></caption><graphic xlink:href="12859_2020_3685_Fig4_HTML" id="MO4"/></fig></p>
      <p>To reduce the GPU memory accesses, the alignment is preceded by a packing step as indicated in the flow graph of Fig. <xref rid="Fig4" ref-type="fig">4</xref>. The bases of both sequences are packed in a 4-bit format, where 8 bases are packed into a 32-bit integer. This packing is performed on the GPU and it is hundreds of times faster than packing bases on CPU [<xref ref-type="bibr" rid="CR25">25</xref>]. To align <italic>R_tile</italic> with <italic>Q_tile</italic>, we extended the local alignment kernel of GASAL (GPU Accelerated Sequence Alignment Library) library [<xref ref-type="bibr" rid="CR25">25</xref>]. The tile is subdivided into submatrices of size 8x8. Since there are 8 bases in one integer, only two global memory accesses are required to compute a single submatrix. The layout of a tile computed on the GPU is shown in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. Each green box contains an 8x8 submatrix. The submatrices are computed in the order shown by their number. The arrows in the submatrix number 4 show the order of computation of the dynamic programming cells in a submatrix. The figure shows that the <italic>Q_tile</italic> sequence is read multiple times. Hence, packing the sequence with 4 bits per base helps to keep it in the cache for faster access. It is clear from Eqs. <xref rid="Equ1" ref-type="">1</xref>-<xref rid="Equ4" ref-type="">4</xref> that to compute a column of the submatrix only the cells in the left column and the row above it are required. The required column and row are colored blue in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. The column has only 8 elements, and hence can be stored in GPU registers. Therefore, the total amount of memory required is <inline-formula id="IEq10"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O} \left (T + T^{2}\right)$\end{document}</tex-math><mml:math id="M28"><mml:mi mathvariant="script">O</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:mi>T</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq10.gif"/></alternatives></inline-formula>, where <inline-formula id="IEq11"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(T)$\end{document}</tex-math><mml:math id="M30"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mi>T</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq11.gif"/></alternatives></inline-formula> is required for computing maximum alignment score <italic>m</italic> and <inline-formula id="IEq12"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}\left (T^{2}\right)$\end{document}</tex-math><mml:math id="M32"><mml:mi mathvariant="script">O</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="12859_2020_3685_Article_IEq12.gif"/></alternatives></inline-formula> for storing the traceback matrix <italic>D</italic>. Algorithm 1 shows the GPU implementation of the <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() function. The pseudocode above Line 4 is for computing the position of maximum alignment score (<italic>i</italic><sub><italic>m</italic></sub><italic>a</italic><italic>x</italic>,<italic>j</italic><italic>m</italic><italic>a</italic><italic>x</italic>) and the traceback matrix <italic>D</italic>. Observe that the all the writes in <italic>D</italic> are coalesced to optimize the memory bandwidth and reduce the number of memory transactions. The pesudocode below Line 4 is for computing the traceback path <italic>tb</italic>. The GPU accelerated Darwin supports both linear as well as affine gap penalties. Algorithm 1 shows the alignment using the linear gap penalties. The algorithm with affine gap penalties has a similar layout and omitted here for brevity.
<fig id="Fig5"><label>Fig. 5</label><caption><p>Layout of the tile computed on the GPU. Each green box is a 8x8 submatrix</p></caption><graphic xlink:href="12859_2020_3685_Fig5_HTML" id="MO5"/></fig></p>
      <p>
        <graphic position="anchor" xlink:href="12859_2020_3685_Figa_HTML" id="MO10"/>
      </p>
      <p>Sequence alignment of long DNA sequence is a performance bottleneck in genome analysis algorithms. The results of Darwin alignment are same as for normal Smith-Waterman for reasonable values of <italic>T</italic> and <italic>O</italic>. Hence, the Darwin algorithm can also be applied for Smith-Waterman alignment between two long DNA sequences and our GPU implementation of Darwin can be used to accelerate Smith-Waterman alignment (with traceback) for long DNA sequences.</p>
    </sec>
  </sec>
  <sec id="Sec11" sec-type="results">
    <title>Results</title>
    <p>We compared our GPU acceleration with the hand-optimized CPU version of Darwin [<xref ref-type="bibr" rid="CR26">26</xref>] (commit: 16bdb81). Tests are performed on both IBM as well as Intel machines. The IBM machine (S824L) has 2 sockets with each socket containing a 10-core POWER8 @ 3.42 GHz processor. Each core has 8-way Simultaneous Multithreading. Hence, there are 160 logical cores in total. The machine has 256 GB of RAM and a Tesla K40m. The CUDA version is 7.5, and the operating system is Ubuntu 3.19.0-28-generic. The GCC version is 4.9.2.</p>
    <p>The Intel machine has 2 sockets with each socket containing a 6-core Xeon E5-2620 @ 2.4 GHz processor. Each core has 2-way Hyperthreading. Hence, there are 24 logical cores in total. The machine has 32 GB of RAM and a Tesla K40c. The CUDA version is 9.2, and the operating system is CentOS 7.5. The GCC version is 4.8.5. The K40c and K40m have the same performance, the only difference lies in their cooling method.</p>
    <p>We use Pacbio 54x Human sequencing data [<xref ref-type="bibr" rid="CR27">27</xref>]. The data has a size of 172 gigabytes containing 21,856,161 reads. Since the runtime of the experiments has a quadratic relationship with the number of reads, we use first 50 megabytes (8566 reads) as the input dataset to finish the experiments in a reasonable time. Even with 50 megabytes input dataset, the CPU implementation takes more than 2 hours to run on 8 threads of the Intel machine (Fig. <xref rid="Fig8" ref-type="fig">8</xref>). The input dataset contains reads up to 33 kilo bases long with an average read length of 6 kilo bases. Darwin computes the overlaps between the reads in the input dataset. The settings for GPU and CPU implementation are as follows: <italic>m</italic><italic>a</italic><italic>t</italic><italic>c</italic><italic>h</italic>,<italic>m</italic><italic>i</italic><italic>s</italic><italic>m</italic><italic>a</italic><italic>t</italic><italic>c</italic><italic>h</italic>,<italic>g</italic><italic>a</italic><italic>p</italic><italic>o</italic>,<italic>g</italic><italic>a</italic><italic>p</italic><italic>e</italic>=(1,−1,−1,−1), <italic>N</italic>=800, <italic>T</italic>=320, <italic>O</italic>=120, <italic>K</italic>=14, <italic>h</italic>=21, <italic>w</italic>=1.</p>
    <p>Since our GPU implementation accelerates only the <italic>A</italic><italic>l</italic><italic>i</italic><italic>g</italic><italic>n</italic>() function on the GPU, everything else is executed on the CPU with multiple threads. Each CPU thread launches a batch of <italic>R_tile</italic> and <italic>Q_tile</italic> sequences to be aligned on the GPU. Since all these CPU threads share a single GPU, it is necessary to investigate how the choice of numbers of CPU threads, number of GPU blocks and the number of threads in a block affect the performance. Figure <xref rid="Fig6" ref-type="fig">6</xref> shows the total execution size for various settings of these factors. The figure shows that the fastest execution time is obtained with 8 CPU threads running with the GPU launch parameters of 32 blocks and 64 threads per block. We performed a similar analysis for the Intel machine and found that 8/32/64 is the best setting in the case of the Intel machine as well. Therefore, we used the 8/32/64 ((Number of CPU threads) / (number of blocks) / (number of threads per block)) setting for running the GPU implementation in the remainder of the experimental results.
<fig id="Fig6"><label>Fig. 6</label><caption><p>Total execution time of GPU accelerated Darwin for different values of number of CPU threads, numbers of blocks and block size on an IBM machine</p></caption><graphic xlink:href="12859_2020_3685_Fig6_HTML" id="MO6"/></fig></p>
    <p>Figure <xref rid="Fig7" ref-type="fig">7</xref> shows the total execution time of the CPU implementation of Darwin and compares it with the total execution time of the GPU accelerated Darwin, for the IBM machine. Note that the <italic>y</italic>-axis of the figure represents a logarithmic scale due to the high speedup achieved by the GPU implementation. The CPU implementation is running with 64 threads, which gives nearly the fastest execution time. Two GPU times are reported: “GPU” and “GPU-coalesced”. “GPU” is the time without coalescing the accesses to the traceback matrix <italic>D</italic>. The figure shows that the GPU acceleration without coalescing is 2.4x faster than the CPU implementation. Coalescing further accelerates the GPU implementation by 10x to achieve an overall speedup of 24x.
<fig id="Fig7"><label>Fig. 7</label><caption><p>Total execution time of the Darwin’s CPU implementation and GPU accelerated Darwin, on the IBM machine. The CPU implementation is running with 64 CPU threads</p></caption><graphic xlink:href="12859_2020_3685_Fig7_HTML" id="MO7"/></fig><fig id="Fig8"><label>Fig. 8</label><caption><p>Total execution time of Darwin’s CPU implementation and GPU accelerated Darwin, on the Intel machine. The CPU implementation is running with 8 threads</p></caption><graphic xlink:href="12859_2020_3685_Fig8_HTML" id="MO8"/></fig></p>
    <p>Figure <xref rid="Fig8" ref-type="fig">8</xref> show the comparison of total execution times on the Intel machine, again with a logarithmic scale on the <italic>y</italic>-axis. The CPU implementation is running with 8 threads, which gives nearly the fastest execution time. The non-coalesced GPU implementation achieves a speedup of 11.8x over the CPU. With coalesced memory accesses the speedup becomes 109x. Figures <xref rid="Fig7" ref-type="fig">7</xref> and <xref rid="Fig8" ref-type="fig">8</xref> indicate that coalescing helps to improve the speedup by around 10x. This happens due to efficient utilization of large GPU global memory bandwidth.</p>
    <p>The above results were obtained with the linear-gap penalty model which is also the default setting in Darwin. However, Darwin and hence our GPU acceleration also support the affine gap model. Table <xref rid="Tab1" ref-type="table">1</xref> shows the total execution time of the CPU and GPU implementation of Darwin for various values of <italic>match</italic>, <italic>mismatch</italic>, <italic>gapo</italic> and <italic>gape</italic> on the IBM machine. The CPU implementation is running with 64 threads. The table shows that the speedup nearly remains constant (20x-25x) regardless of the scoring scheme. Hence our GPU acceleration is equally effective for both linear and affine gap penalty scoring models.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Runtimes and speedup for different scoring schemes on the IBM machine</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"/><th align="left">(2,-1,-2,-2)</th><th align="left">(1,-3,-1,-1)</th><th align="left">(5,-4,-10,-1)</th></tr></thead><tbody><tr><td align="left">CPU</td><td align="left">31m15</td><td align="left">21m28s</td><td align="left">31m27s</td></tr><tr><td align="left">GPU-coalesced</td><td align="left">76.0</td><td align="left">59.3</td><td align="left">78.0</td></tr><tr><td align="left">speedup</td><td align="left">24.7</td><td align="left">21.7</td><td align="left">24.2</td></tr></tbody></table></table-wrap></p>
  </sec>
  <sec id="Sec12" sec-type="conclusion">
    <title>Conclusions</title>
    <p>Read overlapping is an important step in OLC based de novo assemblers. Darwin is a fast and accurate read overlapper for assembly of long DNA reads. It is based on the seed-and-extend paradigm. It has two stages: 1) D-SOFT, to compute the seeds and 2) GACT, to extend the seed hits on both sides to compute the overlap between two reads. The ASIC implementation of Darwin is shown to be hundreds of times faster than software based read overlappers. GPUs are cost-effective and easily accessible processing units that are used to accelerate many high performance applications. In this paper, we have shown a GPU implementation of Darwin which accelerates the Smith-Waterman alignment with traceback computation used in the GACT stage. We pack the sequences on the GPU and compute the Smith-Waterman alignment matrix by dividing the matrix into 8x8 submatrices. This helps to reduce the GPU memory accesses. To further reduce the memory transactions, writing to the traceback matrix is coalesced. We tested our implementation against the hand-optimized CPU implementation of Darwin. The results show that using the real Pacbio dataset, our GPU implementation is 24x faster than 64 IBM Power8 threads and 109x faster than 8 Intel Xeon threads, regardless of the scoring scheme (linear or affine gap). The GPU implementation can also be used to accelerate generic Smith-Waterman alignment of long DNA sequences. The implementation is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/Tongdongq/darwin-gpu">https://github.com/Tongdongq/darwin-gpu</ext-link>.</p>
  </sec>
  <sec id="Sec13">
    <title>Availability and requirements</title>
    <p><bold>Project name:</bold> darwin-gpu<bold>Project home page:</bold><ext-link ext-link-type="uri" xlink:href="https://github.com/Tongdongq/darwin-gpu">https://github.com/Tongdongq/darwin-gpu</ext-link><bold>Operating system(s):</bold> Linux<bold>Programming language:</bold> C++, CUDA<bold>Other requirements:</bold> CUDA toolkit version 8 or higher.<bold>License:</bold> Apache 2.0<bold>Any restrictions to use by non-academics:</bold> Not applicable</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>ASIC</term>
        <def>
          <p>Application Specific Integrated Circuit</p>
        </def>
      </def-item>
      <def-item>
        <term>CPU</term>
        <def>
          <p>Central Processing Unit</p>
        </def>
      </def-item>
      <def-item>
        <term>CUDA</term>
        <def>
          <p>Compute Unified Device Architecture</p>
        </def>
      </def-item>
      <def-item>
        <term>DNA</term>
        <def>
          <p>Deoxyribonucleic Acid D-SOFT: Diagonal-band Seed Overlapping based Filtration Technique</p>
        </def>
      </def-item>
      <def-item>
        <term>GACT</term>
        <def>
          <p>Genome Alignment using Constant memory Traceback</p>
        </def>
      </def-item>
      <def-item>
        <term>GASAL</term>
        <def>
          <p>GPU Accelerated Sequence Alignment Library</p>
        </def>
      </def-item>
      <def-item>
        <term>GPU</term>
        <def>
          <p>Graphical Processing Unit</p>
        </def>
      </def-item>
      <def-item>
        <term>NGS</term>
        <def>
          <p>Next Generation Sequencing</p>
        </def>
      </def-item>
      <def-item>
        <term>SM</term>
        <def>
          <p>Streaming Multiprocessor</p>
        </def>
      </def-item>
      <def-item>
        <term>SP</term>
        <def>
          <p>Streaming Processor</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <p>We are thankful to Yatish Turakhia from Stanford University for his help during the research.</p>
    <sec id="d30e2513">
      <title>About this supplement</title>
      <p>This article has been published as part of <italic>BMC Bioinformatics Volume 21 Supplement 13, 2020: Selected articles from the 18th Asia Pacific Bioinformatics Conference (APBC 2020): bioinformatics</italic>. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-21-supplement-13">https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-21-supplement-13</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>NA provided the initial GPU implementation, wrote the manuscript and performed some experiments. TDQ carried out the study, extended the GPU implementation to be integrated in Darwin, performed the experiments and wrote some parts of the manuscript. KB headed the research and revised the manuscript. ZA proposed the idea, supervised the research and helped in writing the manuscript. All author(s) read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>This work is partly funded by the Faculty Development Program of the University of Engineering and Technology Lahore and by the FitOptiVis ECSEL Joint Undertaking project under grant number H2020 - ECSEL - 2017 - 2 - 783162. Publication costs are funded by the TUDelft library open access fund.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar1">
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar2">
    <title>Consent for publication</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar3" notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kececioglu</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>Combinatorial algorithms for dna sequence assembly</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>13</volume>
        <issue>7</issue>
        <fpage>7</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1007/BF01188580</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <mixed-citation publication-type="other">Myers G, Tischler G, Cunial F, Pippel M. DAZZLER: Dresden Azzembler for Long Read DNA Projects. https://https://dazzlerblog.wordpress.com. Accessed 2 July 2019.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Efficient de novo assembly of large genomes using compressed data structures</article-title>
        <source>Genome Res</source>
        <year>2012</year>
        <volume>22</volume>
        <issue>3</issue>
        <fpage>549</fpage>
        <lpage>56</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.126953.111</pub-id>
        <?supplied-pmid 22156294?>
        <pub-id pub-id-type="pmid">22156294</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>An eulerian path approach to dna fragment assembly</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>2001</year>
        <volume>98</volume>
        <issue>17</issue>
        <fpage>9748</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.171285098</pub-id>
        <?supplied-pmid 11504945?>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short read assembly using de bruijn graphs</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>074492</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.074492.107</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Jackman</surname>
            <given-names>SD</given-names>
          </name>
          <name>
            <surname>Schein</surname>
            <given-names>JE</given-names>
          </name>
        </person-group>
        <article-title>Abyss: a parallel assembler for short read sequence data</article-title>
        <source>Genome Res</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>089532</fpage>
        <pub-id pub-id-type="doi">10.1101/gr.089532.108</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Soapdenovo2: an empirically improved memory-efficient short-read de novo assembler</article-title>
        <source>Gigascience</source>
        <year>2012</year>
        <volume>1</volume>
        <issue>18</issue>
        <fpage>1</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="pmid">23587310</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Yatish Turakhia</surname>
            <given-names>GB</given-names>
          </name>
          <name>
            <surname>Dally</surname>
            <given-names>WJ</given-names>
          </name>
        </person-group>
        <article-title>Darwin: genomics co-processor provides up to 15,000X acceleration on long read assembly</article-title>
        <source>Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems. ASPLOS ’18</source>
        <year>2018</year>
        <publisher-loc>Williamsburg</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ahmed</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Lévy</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Mushtaq</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>GASAL2: a GPU accelerated sequence alignment library for high-throughput NGS data</article-title>
        <source>BMC Bioinformatics</source>
        <year>2019</year>
        <volume>20</volume>
        <issue>1</issue>
        <fpage>520</fpage>
        <pub-id pub-id-type="doi">10.1186/s12859-019-3086-9</pub-id>
        <?supplied-pmid 31653208?>
        <pub-id pub-id-type="pmid">31653208</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ahmed</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>GPU accelerated sequence alignment with traceback for GATK HaplotypeCaller</article-title>
        <source>BMC Genomics</source>
        <year>2019</year>
        <volume>20</volume>
        <issue>2</issue>
        <fpage>184</fpage>
        <pub-id pub-id-type="doi">10.1186/s12864-019-5468-9</pub-id>
        <?supplied-pmid 30967111?>
        <pub-id pub-id-type="pmid">30967111</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Houtgast</surname>
            <given-names>EJ</given-names>
          </name>
          <name>
            <surname>Sima</surname>
            <given-names>V-M</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Hardware acceleration of bwa-mem genomic short read mapping for longer read lengths</article-title>
        <source>Comput Biol Chem</source>
        <year>2018</year>
        <volume>75</volume>
        <fpage>54</fpage>
        <lpage>64</lpage>
        <pub-id pub-id-type="doi">10.1016/j.compbiolchem.2018.03.024</pub-id>
        <?supplied-pmid 29747076?>
        <pub-id pub-id-type="pmid">29747076</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <issue>1</issue>
        <fpage>195</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ahmed</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>A comparison of seed-and-extend techniques in modern dna read alignment algorithms</article-title>
        <source>2016 IEEE International Conference on Bioinformatics and Biomedicine (BIBM)</source>
        <year>2016</year>
        <publisher-loc>Piscataway</publisher-loc>
        <publisher-name>IEEE</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J Mol Biol</source>
        <year>1990</year>
        <volume>215</volume>
        <issue>3</issue>
        <fpage>403</fpage>
        <lpage>10</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-2836(05)80360-2</pub-id>
        <?supplied-pmid 2231712?>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hayes</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Hunt</surname>
            <given-names>BR</given-names>
          </name>
          <name>
            <surname>Mount</surname>
            <given-names>SM</given-names>
          </name>
        </person-group>
        <article-title>Reducing storage requirements for biological sequence comparison</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <issue>18</issue>
        <fpage>3363</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bth408</pub-id>
        <?supplied-pmid 15256412?>
        <pub-id pub-id-type="pmid">15256412</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rucci</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Garcia</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Botella</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>De Giusti</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Naiouf</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Prieto-Matias</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>SWIFOLD: Smith-Waterman implementation on FPGA with OpenCL for long DNA sequences</article-title>
        <source>BMC Syst Biol</source>
        <year>2018</year>
        <volume>12</volume>
        <issue>5</issue>
        <fpage>96</fpage>
        <pub-id pub-id-type="doi">10.1186/s12918-018-0614-6</pub-id>
        <?supplied-pmid 30458766?>
        <pub-id pub-id-type="pmid">30458766</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Farrar</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Striped smith–waterman speeds database searches six times over other SIMD implementations</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>2</issue>
        <fpage>156</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl582</pub-id>
        <?supplied-pmid 17110365?>
        <pub-id pub-id-type="pmid">17110365</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hirschberg</surname>
            <given-names>DS</given-names>
          </name>
        </person-group>
        <article-title>A Linear Space Algorithm for Computing Maximal Common Subsequences</article-title>
        <source>Commun ACM</source>
        <year>1975</year>
        <volume>18</volume>
        <issue>6</issue>
        <fpage>341</fpage>
        <lpage>3</lpage>
        <pub-id pub-id-type="doi">10.1145/360825.360861</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chao</surname>
            <given-names>KM</given-names>
          </name>
          <name>
            <surname>Pearson</surname>
            <given-names>WR</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Aligning two sequences within a specified diagonal band</article-title>
        <source>Comput Appl Biosci CABIOS</source>
        <year>1992</year>
        <volume>8</volume>
        <issue>5</issue>
        <fpage>481</fpage>
        <lpage>7</lpage>
        <?supplied-pmid 1422882?>
        <pub-id pub-id-type="pmid">1422882</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
        </person-group>
        <article-title>Optimizing data intensive gpgpu computations for dna sequence alignment</article-title>
        <source>Parallel Comput</source>
        <year>2009</year>
        <volume>35</volume>
        <issue>8</issue>
        <fpage>429</fpage>
        <lpage>40</lpage>
        <pub-id pub-id-type="doi">10.1016/j.parco.2009.05.002</pub-id>
        <?supplied-pmid 20161021?>
        <pub-id pub-id-type="pmid">20161021</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <mixed-citation publication-type="other">de O Sandes EF, de Melo ACMA. Smith-waterman alignment of huge sequences with gpu in linear space. In: 2011 IEEE International Parallel Distributed Processing Symposium. Piscataway: IEEE: 2011. p. 1199–211. 10.1109/IPDPS.2011.114. <ext-link ext-link-type="uri" xlink:href="https://ieeexplore.ieee.org/document/6012857/">https://ieeexplore.ieee.org/document/6012857/</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>CUSHAW2-GPU: Empowering Faster Gapped Short-Read Alignment Using GPU Computing</article-title>
        <source>Des Test IEEE</source>
        <year>2014</year>
        <volume>31</volume>
        <issue>1</issue>
        <fpage>31</fpage>
        <lpage>39</lpage>
        <pub-id pub-id-type="doi">10.1109/MDAT.2013.2284198</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Houtgast</surname>
            <given-names>EJ</given-names>
          </name>
          <name>
            <surname>Sima</surname>
            <given-names>VM</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>KLM</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>An efficient gpu-accelerated implementation of genomic short read mapping with bwa-mem</article-title>
        <source>Proc. International Symposium on Highly-Efficient Accelerators and Reconfigurable Technologies</source>
        <year>2016</year>
        <publisher-loc>Hong Kong, China</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hasan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Kentie</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Dopa: Gpu-based protein alignment using database and memory access optimizations</article-title>
        <source>BMC Res Notes</source>
        <year>2011</year>
        <volume>4</volume>
        <fpage>1</fpage>
        <lpage>11</lpage>
        <pub-id pub-id-type="doi">10.1186/1756-0500-4-261</pub-id>
        <pub-id pub-id-type="pmid">21205301</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ahmed</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Mushtaq</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>KLM</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Gpu accelerated api for alignment of genomics sequencing data</article-title>
        <source>Proc. IEEE International Conference on Bioinformatics and Biomedicine</source>
        <year>2017</year>
        <publisher-loc>Piscataway</publisher-loc>
        <publisher-name>IEEE</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <mixed-citation publication-type="other">Turakhia Y. Darwin: A co-processor for long read alignment. <ext-link ext-link-type="uri" xlink:href="https://github.com/yatisht/darwin">https://github.com/yatisht/darwin</ext-link>. Accessed 5 Nov 2018.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <mixed-citation publication-type="other">Data release: 54x long-read coverage for PacBio-only de novo human genome assembly. 2014. <ext-link ext-link-type="uri" xlink:href="https://www.pacb.com/blog/data-release-54x-long-read-coverage-for/">https://www.pacb.com/blog/data-release-54x-long-read-coverage-for/</ext-link>. Accessed 2 July 2019.</mixed-citation>
    </ref>
  </ref-list>
</back>
