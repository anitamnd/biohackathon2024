<?DTDIdentifier.IdentifierValue article.dtd?>
<?DTDIdentifier.IdentifierType system?>
<?SourceDTD.DTDName article.dtd?>
<?SourceDTD.Version 1.0?>
<?ConverterInfo.XSLTName bmc2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2957686</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-11-S7-S3</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-11-S7-S3</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Proceedings</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Robust and accurate prediction of noncoding RNAs from aligned sequences</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" id="A1">
        <name>
          <surname>Saito</surname>
          <given-names>Yutaka</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>saito@dna.bio.keio.ac.jp</email>
      </contrib>
      <contrib contrib-type="author" id="A2">
        <name>
          <surname>Sato</surname>
          <given-names>Kengo</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <xref ref-type="aff" rid="I3">3</xref>
        <email>satoken@k.u-tokyo.ac.jp</email>
      </contrib>
      <contrib contrib-type="author" corresp="yes" id="A3">
        <name>
          <surname>Sakakibara</surname>
          <given-names>Yasubumi</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>yasu@bio.keio.ac.jp</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Biosciences and Informatics, Keio University, 3-14-1 Hiyoshi, Kohoku-ku, Yokohama, Kanagawa 223-8522, Japan</aff>
    <aff id="I2"><label>2</label>Graduate School of Frontier Sciences, University of Tokyo, 5-1-5 Kashiwanoha, Kashiwa, Chiba 277-8561, Japan</aff>
    <aff id="I3"><label>3</label>Computational Biology Research Center (CBRC), National Institute of Advanced Industrial Science and Technology (AIST), 2-42 Aomi, Koto-ku, Tokyo 135-0064, Japan</aff>
    <pub-date pub-type="collection">
      <year>2010</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>15</day>
      <month>10</month>
      <year>2010</year>
    </pub-date>
    <volume>11</volume>
    <issue>Suppl 7</issue>
    <supplement>
      <named-content content-type="supplement-title">Ninth International Conference on Bioinformatics (InCoB2010): Bioinformatics</named-content>
      <named-content content-type="supplement-editor">Christian Schönbach, Kenta Nakai, Tin Wee Tan and Shoba Ranganathan</named-content>
      <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/content/pdf/1471-2105-11-S7-info.pdf">http://www.biomedcentral.com/content/pdf/1471-2105-11-S7-info.pdf</ext-link>
    </supplement>
    <fpage>S3</fpage>
    <lpage>S3</lpage>
    <permissions>
      <copyright-statement>Copyright ©2010 Saito et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2010</copyright-year>
      <copyright-holder>Saito et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="http://www.biomedcentral.com/1471-2105/11/S7/S3"/>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Computational prediction of noncoding RNAs (ncRNAs) is an important task in the post-genomic era. One common approach is to utilize the profile information contained in alignment data rather than single sequences. However, this strategy involves the possibility that the quality of input alignments can influence the performance of prediction methods. Therefore, the evaluation of the robustness against alignment errors is necessary as well as the development of accurate prediction methods.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We describe a new method, called Profile BPLA kernel, which predicts ncRNAs from alignment data in combination with support vector machines (SVMs). Profile BPLA kernel is an extension of <italic>base-pairing profile local alignment </italic>(BPLA) kernel which we previously developed for the prediction from single sequences. By utilizing the profile information of alignment data, the proposed kernel can achieve better accuracy than the original BPLA kernel. We show that Profile BPLA kernel outperforms the existing prediction methods which also utilize the profile information using the high-quality structural alignment dataset. In addition to these standard benchmark tests, we extensively evaluate the robustness of Profile BPLA kernel against errors in input alignments. We consider two different types of error: first, that all sequences in an alignment are actually ncRNAs but are aligned ignoring their secondary structures; second, that an alignment contains unrelated sequences which are not ncRNAs but still aligned. In both cases, the effects on the performance of Profile BPLA kernel are surprisingly small. Especially for the latter case, we demonstrate that Profile BPLA kernel is more robust compared to the existing prediction methods.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Profile BPLA kernel provides a promising way for identifying ncRNAs from alignment data. It is more accurate than the existing prediction methods, and can keep its performance under the practical situations in which the quality of input alignments is not necessarily high.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>26–28 September 2010</conf-date>
      <conf-name>Asia Pacific Bioinformatics Network (APBioNet) Ninth International Conference on Bioinformatics (InCoB2010)</conf-name>
      <conf-loc>Tokyo, Japan</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Reliable identification of noncoding RNA (ncRNA) genes is one of the major goals of recent computational biology [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>]. In most cases, functional ncRNAs form base-paired secondary structures which are closely related to their roles in organisms. Some algorithms exist for extracting secondary structure information from primary sequences using thermodynamic energy models [<xref ref-type="bibr" rid="B3">3</xref>,<xref ref-type="bibr" rid="B4">4</xref>]. This information, in addition to nucleotide sequences, can be exploited for the statistical prediction of ncRNAs.</p>
    <p>To improve the reliability of predictions, many existing methods take an alignment as input rather than a single sequence [<xref ref-type="bibr" rid="B5">5</xref>]. Alignment data provide the profile information of ncRNAs which is not evident from individual sequences; it can help to capture detailed features of primary sequences and secondary structures. Several prediction methods based on support vector machines (SVMs) have been proposed with this respect, and shown to achieve high accuracy [<xref ref-type="bibr" rid="B6">6</xref>-<xref ref-type="bibr" rid="B8">8</xref>]. Each method has its own kernel function which defines the similarity between a pair of alignment data and determines the accuracy of the SVM classifier. Washietl <italic>et al. </italic>[<xref ref-type="bibr" rid="B6">6</xref>] and Gruber <italic>et al. </italic>[<xref ref-type="bibr" rid="B7">7</xref>] have developed RNAz, which employs radial basis function (RBF) kernels to compute the similarity of feature vectors of alignment data. A major contribution to its prediction is made by the structure conservation index (SCI) based on thermodynamic energy models. This feature value assesses whether an alignment is structurally conserved by normalizing the minimum free energy of consensus secondary structures with the average of those for individual sequences. Sato <italic>et al. </italic>[<xref ref-type="bibr" rid="B8">8</xref>] have developed Profile stem kernel as an extension of Stem kernel which was originally proposed for analyzing single sequences [<xref ref-type="bibr" rid="B9">9</xref>]. The method calculates the similarity between a pair of alignment data by summing the substitution scores for all pairs of effective (highly probable) consensus stem structures.</p>
    <p>In their studies, input alignments were assumed to be correct or at least not damaging to the accuracy of the prediction methods. However, it is not necessarily the case under the realistic conditions in genomic and transcriptomic screens. Since aligning genomic sequences is an error-prone process [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B11">11</xref>], prediction methods have to deal with low-quality alignment data in most practical applications. For example, RNAz and Profile stem kernel utilize consensus secondary structures as the profile information, which are known to be degraded by the use of low-quality alignment data [<xref ref-type="bibr" rid="B12">12</xref>]. The previous studies have not fully evaluated to what extent the quality of input alignments can influence the performance of the prediction methods.</p>
    <p>We can consider two different types of error in alignment data: first, that all sequences in an alignment are actually ncRNAs but are aligned ignoring their secondary structures (Type A); second, that an alignment contains unrelated sequences which are not ncRNAs but still aligned (Type B). In the remaining part of this paper, we use these definitions of the Type A and the Type B errors.</p>
    <p>The Type A errors are usually involved in genomic and transcriptomic screens since we practically use sequence-based aligners due to the high computational cost for the construction of structural alignment data. In accordance with this convention, the original papers of RNAz and Profile stem kernel tested their methods only on sequence-based alignment datasets [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B8">8</xref>]. On the other hand, some studies have since then attempted to detect ncRNAs from structural alignment data obtained by realigning sequence-based alignments [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>]. Following these efforts, the recent update of RNAz has reported the results that its accuracy slightly improved when using structural alignment data as input [<xref ref-type="bibr" rid="B7">7</xref>]. However, the results were only on the dataset with various ncRNA families mixed, and the improvement for each particular family was not shown. For Profile stem kernel, similar experiments on the Type A errors have not been presented.</p>
    <p>The amount of the type B errors has been intensively studied using the 17-way vertebrate alignment in the UCSC genome browser [<xref ref-type="bibr" rid="B15">15</xref>]. One study has estimated that 9.7% of the regions include unrelated sequences which are not orthologous to the other sequences in the alignment [<xref ref-type="bibr" rid="B10">10</xref>]. More strikingly, the estimate in [<xref ref-type="bibr" rid="B11">11</xref>] says that 16% of the segments aligned to ncRNA genes are wrongly included in the alignments from the viewpoint of their secondary structures. In spite of the great significance of the Type B errors suggested by these studies, there has been so far no systematic evaluation about their influence to the performance of prediction methods.</p>
    <p>In this paper, we describe a new method, called Profile BPLA kernel, which predicts ncRNAs from alignment data in combination with SVMs. Profile BPLA kernel is an extension of <italic>base-pairing profile local alignment </italic>(BPLA) kernel which we previously developed for the prediction from single sequences [<xref ref-type="bibr" rid="B16">16</xref>]. By utilizing the profile information of alignment data, the proposed kernel can achieve better accuracy than the original BPLA kernel. We show that Profile BPLA kernel outperforms the existing prediction methods which also utilize the profile information using the high-quality structural alignment dataset. In addition to these standard benchmark tests, we extensively evaluate the robustness of Profile BPLA kernel against errors in input alignments. For both the Type A and the Type B errors, the effects on the performance of Profile BPLA kernel are surprisingly small. Especially for the Type B errors, we demonstrate that Profile BPLA kernel is more robust compared to the existing prediction methods.</p>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <sec>
      <title>Algorithm</title>
      <p>In this section, we propose an accurate and robust method for the prediction of ncRNAs from alignment data. The proposed method, named Profile BPLA kernel, is an extension of BPLA kernel which we previously developed for the prediction from single sequences [<xref ref-type="bibr" rid="B16">16</xref>]. Hence, we first review the original algorithm of BPLA kernel, and then extend the method to alignment data.</p>
      <p>The whole schemes of the original BPLA kernel and Profile BPLA kernel are summarized in Figure S1 (Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>).</p>
      <sec>
        <title>Notations</title>
        <p>For an RNA sequence <bold>x</bold>, we denote its length by |<bold>x</bold>|, and the nucleotide at the <italic>i</italic>-th position by <italic>x<sub>i</sub></italic>. For a pair of sequences, <bold>x </bold>and <bold>y</bold>, we denote the set of all possible local alignments in the Smith-Waterman (SW) algorithm [<xref ref-type="bibr" rid="B17">17</xref>] by Π<bold><sub>xy</sub></bold>, and one particular local alignment in Π<bold><sub>xy </sub></bold>by <italic>π</italic><bold><sub>xy</sub></bold>. We denote the alignment score of <italic>π</italic><bold><sub>xy </sub></bold>by Score(<italic>π</italic><bold><sub>xy</sub></bold>), which is calculated based on a scoring function <italic>S</italic><bold><sub>xy</sub></bold>(<italic>i</italic>, <italic>j</italic>) for matching the <italic>i</italic>-th position in <bold>x </bold>and the <italic>j</italic>-th position in <bold>y</bold>. We design <italic>S</italic><bold><sub>xy</sub></bold>(<italic>i</italic>, <italic>j</italic>) using a nucleotide substitution matrix <italic>s</italic>(<italic>x</italic><sub><italic>i</italic>, </sub><italic>y</italic><sub><italic>j</italic></sub>) as its component. In addition, we use four parameters: <italic>α</italic>, <italic>β</italic>, <italic>g</italic>, and <italic>d</italic>.</p>
        <p>For each sequence <bold>x</bold>, we denote the set of all possible secondary structures by Θ<bold><sub>x</sub></bold>, and one particular secondary structure in Θ<bold><sub>x </sub></bold>by <italic>θ</italic><bold><sub>x</sub></bold>. We represent a secondary structure by <italic>θ</italic><bold><sub>x </sub></bold>= {<italic>θ</italic><bold><sub>x</sub></bold>(<italic>i</italic>, <italic>j</italic>)}<italic><sub>i &lt; j</sub></italic>, where a binary variable <italic>θ</italic><bold><sub>x</sub></bold>(<italic>i</italic>, <italic>j</italic>) is equal to one only when the <italic>i</italic>-th position and the <italic>j</italic>-th position in <bold>x </bold>form a base pair. In addition, for each position <italic>i </italic>in <bold>x</bold>, we define three kinds of binary variable: <italic>L</italic><bold><sub>x</sub></bold>(<italic>i</italic>) = Σ<sub><italic>j</italic>:<italic>j </italic>&gt;<italic>i </italic></sub><italic>θ</italic><bold><sub>x</sub></bold>(<italic>i</italic>, <italic>j</italic>) is equal to one only when a pair is formed with one of the downstream positions; <italic>R</italic><bold><sub>x</sub></bold>(<italic>i</italic>) = Σ<sub><italic>j</italic>:<italic>j </italic>&lt;<italic>i </italic></sub><italic>θ</italic><bold><sub>x</sub></bold>(<italic>j</italic>, <italic>i</italic>) is equal to one only when a pair is formed with one of the upstream positions; and <italic>U</italic><bold><sub>x</sub></bold>(<italic>i</italic>) = 1 - <italic>L</italic><bold><sub>x</sub></bold>(<italic>i</italic>) - <italic>R</italic><bold><sub>x</sub></bold>(<italic>i</italic>) is equal to one only when the position is unpaired. These binary variables are converted to the corresponding probabilities by taking the expectation over Θ<bold><sub>x</sub></bold>. For <italic>θ</italic><bold><sub>x</sub></bold>(<italic>i</italic>, <italic>j</italic>), we obtain a base-pairing probability matrix, which consists of the probabilities <italic>P</italic><bold><sub>x</sub></bold>(<italic>i</italic>, <italic>j</italic>) that the <italic>i</italic>-th and the <italic>j</italic>-th positions form a base pair:</p>
        <p>
          <disp-formula>
            <mml:math id="M1" name="1471-2105-11-S7-S3-i1" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>P</mml:mi>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi>x</mml:mi>
                  </mml:mstyle>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>i</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>j</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>θ</mml:mi>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>x</mml:mi>
                        </mml:mstyle>
                      </mml:msub>
                      <mml:mo>∈</mml:mo>
                      <mml:msub>
                        <mml:mi>Θ</mml:mi>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>x</mml:mi>
                        </mml:mstyle>
                      </mml:msub>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>θ</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>θ</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>where the probability distribution <italic>P</italic>(<italic>θ</italic><bold><sub>x</sub></bold>|x) is computed with the McCaskill algorithm [<xref ref-type="bibr" rid="B4">4</xref>] based on thermodynamic energy models. For {<italic>L</italic><bold><sub>x</sub></bold>(<italic>i</italic>), <italic>R</italic><bold><sub>x</sub></bold>(<italic>i</italic>), <italic>U</italic><bold><sub>x</sub></bold>(<italic>i</italic>)}, we obtain a <italic>base-pairing profile </italic>[<xref ref-type="bibr" rid="B18">18</xref>], which consists of the probabilities {<italic>P</italic><bold><sub>x</sub></bold><italic><sup>L</sup></italic>(<italic>i</italic>), <italic>P</italic><bold><sub>x</sub></bold><italic><sup>R</sup></italic>(<italic>i</italic>), <italic>P</italic><bold><sub>x</sub></bold><italic><sup>U </sup></italic>(<italic>i</italic>)} that the <italic>i</italic>-th position is paired with one of the downstream/upstream positions, or unpaired, respectively:</p>
        <p>
          <disp-formula>
            <mml:math id="M2" name="1471-2105-11-S7-S3-i2" overflow="scroll">
              <mml:mtable columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:msubsup>
                      <mml:mi>P</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                      <mml:mi>L</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mi>Θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>L</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>θ</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>θ</mml:mi>
                            <mml:mtext>x</mml:mtext>
                          </mml:msub>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mi>Θ</mml:mi>
                            <mml:mtext>x</mml:mtext>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:mstyle displaystyle="true">
                          <mml:munder>
                            <mml:mo>∑</mml:mo>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                              <mml:mo>:</mml:mo>
                              <mml:mi>j</mml:mi>
                              <mml:mo>&gt;</mml:mo>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:munder>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>θ</mml:mi>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>x</mml:mi>
                              </mml:mstyle>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mstyle>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>θ</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                          <mml:mo>:</mml:mo>
                          <mml:mi>j</mml:mi>
                          <mml:mo>&gt;</mml:mo>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>P</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:msubsup>
                      <mml:mi>P</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                      <mml:mi>R</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mi>Θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>R</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>θ</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mi>Θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:mstyle displaystyle="true">
                          <mml:munder>
                            <mml:mo>∑</mml:mo>
                            <mml:mrow>
                              <mml:mi>j</mml:mi>
                              <mml:mo>:</mml:mo>
                              <mml:mi>j</mml:mi>
                              <mml:mo>&lt;</mml:mo>
                              <mml:mi>i</mml:mi>
                            </mml:mrow>
                          </mml:munder>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>θ</mml:mi>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>x</mml:mi>
                              </mml:mstyle>
                            </mml:msub>
                          </mml:mrow>
                        </mml:mstyle>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>θ</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                          <mml:mo>:</mml:mo>
                          <mml:mi>j</mml:mi>
                          <mml:mo>&lt;</mml:mo>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>P</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:msubsup>
                      <mml:mi>P</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                      <mml:mi>U</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mstyle displaystyle="true">
                      <mml:munder>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mi>θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                          <mml:mo>∈</mml:mo>
                          <mml:msub>
                            <mml:mi>Θ</mml:mi>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                            </mml:mstyle>
                          </mml:msub>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>U</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>P</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mi>θ</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                        </mml:msub>
                      </mml:mrow>
                      <mml:mo>|</mml:mo>
                    </mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mn>1</mml:mn>
                    <mml:mo>−</mml:mo>
                    <mml:msubsup>
                      <mml:mi>P</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                      <mml:mi>L</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>−</mml:mo>
                    <mml:msubsup>
                      <mml:mi>P</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                      <mml:mi>R</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>.</mml:mo>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>For a multiple alignment <bold>X</bold>, we denote the <italic>i</italic>-th column by <italic>X<sub>i</sub></italic>, and the <italic>k</italic>-th sequence by <bold>X</bold><italic><sup>k</sup></italic>. The nucleotide at the <italic>i</italic>-th position in <bold>X</bold><italic><sup>k </sup></italic>is denoted by <inline-formula><mml:math id="M3" name="1471-2105-11-S7-S3-i3" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>X</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>, which can be a gap character.</p>
      </sec>
      <sec>
        <title>Original BPLA kernel for single sequences</title>
        <p>A kernel function is a measure of similarity between a pair of objects and can be used as a prediction method in combination with an SVM classifier as long as Mercer's condition is satisfied [<xref ref-type="bibr" rid="B19">19</xref>]. BPLA kernel calculates the similarity between a pair of RNA sequences using the information of their primary sequences and secondary structures.</p>
        <p>The basic idea of BPLA kernel is to perform a pairwise alignment and then to regard the alignment score as the measure of similarity. Instead of relying on one optimal alignment, we accumulate the scores of all possible local alignments in the SW algorithm using <italic>local alignment </italic>(LA) kernel [<xref ref-type="bibr" rid="B20">20</xref>]. LA kernel between two sequences, <bold>x </bold>and <bold>y</bold>, is defined as follows:</p>
        <p>
          <disp-formula id="bmcM1">
            <label>(1)</label>
            <mml:math id="M4" name="1471-2105-11-S7-S3-i4" overflow="scroll">
              <mml:mrow>
                <mml:mi>K</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mstyle mathvariant="bold" mathsize="normal">
                  <mml:mi>x</mml:mi>
                </mml:mstyle>
                <mml:mo>,</mml:mo>
                <mml:mstyle mathvariant="bold" mathsize="normal">
                  <mml:mi>y</mml:mi>
                </mml:mstyle>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mstyle displaystyle="true">
                  <mml:munder>
                    <mml:mo>∑</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>π</mml:mi>
                        <mml:mrow>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                            <mml:mi>y</mml:mi>
                          </mml:mstyle>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>∈</mml:mo>
                      <mml:msub>
                        <mml:mi>Π</mml:mi>
                        <mml:mrow>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                            <mml:mi>y</mml:mi>
                          </mml:mstyle>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:munder>
                  <mml:mrow>
                    <mml:msup>
                      <mml:mi>e</mml:mi>
                      <mml:mrow>
                        <mml:mi>β</mml:mi>
                        <mml:mtext>Score</mml:mtext>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:msub>
                          <mml:mi>π</mml:mi>
                          <mml:mrow>
                            <mml:mstyle mathvariant="bold" mathsize="normal">
                              <mml:mi>x</mml:mi>
                              <mml:mi>y</mml:mi>
                            </mml:mstyle>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                  </mml:mrow>
                </mml:mstyle>
                <mml:mo>,</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>β </italic>≥ 0 is a concentration parameter. Given a scoring function <italic>S</italic><bold><sub>xy</sub></bold>(<italic>i</italic>, <italic>j</italic>) for the alignment score Score(<italic>π</italic><bold><sub>xy</sub></bold>), LA kernel (1) can be computed by the following algorithm:</p>
        <p>Initialization:</p>
        <p><bold>for </bold><italic>i </italic>∈ {0, ..., |<bold>x</bold>|} and <italic>j </italic>∈ {0, ..., |<bold>y</bold>|} <bold>do</bold></p>
        <p>   <italic>M</italic>(<italic>i</italic>, 0) = <italic>I<sub>X </sub></italic>(<italic>i</italic>, 0) = <italic>I<sub>Y </sub></italic>(<italic>i</italic>, 0) = <italic>T<sub>X </sub></italic>(<italic>i</italic>, 0) = <italic>T<sub>Y </sub></italic>(<italic>i</italic>, 0) = 0</p>
        <p>   <italic>M</italic>(0, <italic>j</italic>) = <italic>I<sub>X </sub></italic>(0, <italic>j</italic>) = <italic>I<sub>Y </sub></italic>(0, <italic>j</italic>) = <italic>T<sub>X </sub></italic>(0, <italic>j</italic>) = <italic>T<sub>Y </sub></italic>(0, <italic>j</italic>) = 0</p>
        <p>end for</p>
        <p>Iteration:</p>
        <p><bold>for </bold><italic>i ∈</italic> {1, ..., |<bold>x</bold>|} and <italic>j </italic>∈ {1, ..., |<bold>y</bold>|} <bold>do</bold></p>
        <p>   <italic>M</italic>(<italic>i</italic>, <italic>j</italic>) = <italic>e</italic><sup><italic>βS</italic><bold>xy</bold>(<italic>i,j</italic>)</sup>(1 + <italic>I<sub>X </sub></italic>(<italic>i - </italic>1, <italic>j - </italic>1) + <italic>I<sub>Y </sub></italic>(<italic>i - </italic>1, <italic>j - </italic>1) + <italic>M</italic>(<italic>i - </italic>1, <italic>j - </italic>1))</p>
        <p>   <italic>I<sub>X </sub></italic>(<italic>i</italic>, <italic>j</italic>) = <italic>e<sup>βg</sup>M</italic>(<italic>i - </italic>1, <italic>j</italic>) + <italic>e<sup>βd</sup>I<sub>X </sub></italic>(<italic>i - </italic>1, <italic>j</italic>)</p>
        <p>   <italic>I<sub>Y </sub></italic>(<italic>i</italic>, <italic>j</italic>) = <italic>e<sup>βg</sup></italic>(<italic>M</italic>(<italic>i</italic>, <italic>j - </italic>1) + <italic>I<sub>X </sub></italic>(<italic>i</italic>, <italic>j - </italic>1)) + <italic>e<sup>βd</sup>I<sub>Y </sub></italic>(<italic>i</italic>, <italic>j - </italic>1)</p>
        <p>   <italic>T<sub>X </sub></italic>(<italic>i</italic>, <italic>j</italic>) = <italic>M</italic>(<italic>i - </italic>1, <italic>j</italic>) + <italic>T<sub>X </sub></italic>(<italic>i - </italic>1, <italic>j</italic>)</p>
        <p>   <italic>T<sub>Y </sub></italic>(<italic>i</italic>, <italic>j</italic>) = <italic>M</italic>(<italic>i</italic>, <italic>j - </italic>1) + <italic>T<sub>X </sub></italic>(<italic>i</italic>, <italic>j - </italic>1) + <italic>T<sub>Y </sub></italic>(<italic>i</italic>, <italic>j - </italic>1)</p>
        <p>end for</p>
        <p>Termination:</p>
        <p><italic>K</italic>(<bold>x</bold>, <bold>y</bold>) = 1 + <italic>T<sub>X </sub></italic>(|<bold>x</bold>|, |<bold>y</bold>|) + <italic>T<sub>Y </sub></italic>(|<bold>x</bold>|, |<bold>y</bold>|) + <italic>M</italic>(|<bold>x</bold>|, |<bold>y</bold>|)</p>
        <p>where the parameters <italic>g </italic>and <italic>d </italic>are penalties for gap opening and gap extension, respectively. In practice, kernel values are normalized to range from 0 to 1:</p>
        <p>
          <disp-formula>
            <mml:math id="M5" name="1471-2105-11-S7-S3-i5" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>K</mml:mi>
                  <mml:mi>n</mml:mi>
                </mml:msub>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mstyle mathvariant="bold" mathsize="normal">
                  <mml:mi>x</mml:mi>
                </mml:mstyle>
                <mml:mo>,</mml:mo>
                <mml:mstyle mathvariant="bold" mathsize="normal">
                  <mml:mi>y</mml:mi>
                </mml:mstyle>
                <mml:mo stretchy="false">)</mml:mo>
                <mml:mo>=</mml:mo>
                <mml:mfrac>
                  <mml:mrow>
                    <mml:mi>K</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                    </mml:mstyle>
                    <mml:mo>,</mml:mo>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>y</mml:mi>
                    </mml:mstyle>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:msqrt>
                      <mml:mrow>
                        <mml:mi>K</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>x</mml:mi>
                        </mml:mstyle>
                        <mml:mo>,</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>x</mml:mi>
                        </mml:mstyle>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mi>K</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>y</mml:mi>
                        </mml:mstyle>
                        <mml:mo>,</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>y</mml:mi>
                        </mml:mstyle>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:msqrt>
                  </mml:mrow>
                </mml:mfrac>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>To incorporate secondary structure information into the match score <italic>S</italic><bold><sub>xy</sub></bold>(<italic>i</italic>, <italic>j</italic>), we employ the scoring function used in STRAL [<xref ref-type="bibr" rid="B21">21</xref>]. For each sequence <bold>x</bold>, we first compute a base-pairing probability matrix <italic>P</italic><bold><sub>x</sub></bold>(<italic>i</italic>, <italic>j</italic>) using the Vienna RNA package [<xref ref-type="bibr" rid="B22">22</xref>] which is an implementation of the McCaskill algorithm. Subsequently, for each position <italic>i </italic>in <bold>x</bold>, we summarize the base-pairing probabilities into the base-pairing profile <inline-formula><mml:math id="M6" name="1471-2105-11-S7-S3-i6" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msubsup><mml:mi>P</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>L</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>R</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>x</mml:mi></mml:mstyle><mml:mi>U</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We define the scoring function <italic>S</italic><bold><sub>xy</sub></bold>(<italic>i, j</italic>) using the base-pairing profiles as follows:</p>
        <p>
          <disp-formula id="bmcM2">
            <label>(2)</label>
            <mml:math id="M7" name="1471-2105-11-S7-S3-i7" overflow="scroll">
              <mml:mtable columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:msub>
                      <mml:mi>S</mml:mi>
                      <mml:mrow>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>x</mml:mi>
                          <mml:mi>y</mml:mi>
                        </mml:mstyle>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mi>α</mml:mi>
                    <mml:msub>
                      <mml:mi>S</mml:mi>
                      <mml:mrow>
                        <mml:mtext>struct</mml:mtext>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:msub>
                      <mml:mi>S</mml:mi>
                      <mml:mrow>
                        <mml:mtext>seq</mml:mtext>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mi>α</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:msqrt>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mi>P</mml:mi>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>x</mml:mi>
                              </mml:mstyle>
                              <mml:mi>L</mml:mi>
                            </mml:msubsup>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:msubsup>
                              <mml:mi>P</mml:mi>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>y</mml:mi>
                              </mml:mstyle>
                              <mml:mi>L</mml:mi>
                            </mml:msubsup>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:msqrt>
                        <mml:mo>+</mml:mo>
                        <mml:msqrt>
                          <mml:mrow>
                            <mml:msubsup>
                              <mml:mi>P</mml:mi>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>x</mml:mi>
                              </mml:mstyle>
                              <mml:mi>R</mml:mi>
                            </mml:msubsup>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>i</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                            <mml:msubsup>
                              <mml:mi>P</mml:mi>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>y</mml:mi>
                              </mml:mstyle>
                              <mml:mi>R</mml:mi>
                            </mml:msubsup>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:msqrt>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mo>+</mml:mo>
                    <mml:mi>s</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>x</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>y</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:msqrt>
                      <mml:mrow>
                        <mml:msubsup>
                          <mml:mi>P</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>x</mml:mi>
                          </mml:mstyle>
                          <mml:mi>U</mml:mi>
                        </mml:msubsup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>i</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:msubsup>
                          <mml:mi>P</mml:mi>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>y</mml:mi>
                          </mml:mstyle>
                          <mml:mi>U</mml:mi>
                        </mml:msubsup>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mi>j</mml:mi>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:msqrt>
                    <mml:mo>,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <italic>α </italic>≥ 0 is a weight parameter for structural information, and a nucleotide substitution score <italic>s</italic>(<italic>x<sub>i</sub></italic>, <italic>y<sub>j</sub></italic>) captures the similarity of primary sequences. We use the RIBOSUM 85-60 substitution matrix [<xref ref-type="bibr" rid="B23">23</xref>] as <italic>s</italic>(<italic>x<sub>i</sub></italic>, <italic>y<sub>j</sub></italic>) with the minor modification that its smallest eigenvalue is subtracted from each of its diagonal elements in order to satisfy Mercer's condition.</p>
        <p>Combining LA kernel (1) with the scoring function (2), we call this method <italic>base-pairing profile local alignment </italic>(BPLA) kernel.</p>
      </sec>
      <sec>
        <title>Profile BPLA kernel for alignment data</title>
        <p>Now we extend BPLA kernel to the prediction from alignment data. Profile BPLA kernel for alignment data need to define the similarity between a pair of alignment data instead of a pair of single sequences. More specifically, the new algorithm needs to perform pairwise alignments between two alignment data, and calculate their alignment scores. This problem reduces to the definition of a scoring function corresponding to (2) for two alignment columns instead of two sequence positions. Both <italic>S</italic><sub>struct </sub>and <italic>S</italic><sub>seq </sub>in (2) should be extended to take into account the profile information contained in the alignment columns. In order to define the structural similarity <italic>S</italic><sub>struct </sub>between two alignment columns, we need a base-pairing profile for each alignment column. This can be calculated if we define a base-pairing probability matrix for a multiple alignment. As shown in [<xref ref-type="bibr" rid="B12">12</xref>,<xref ref-type="bibr" rid="B24">24</xref>], the consensus secondary structures of aligned sequences are accurately modeled by averaging the individual base-pairing probability matrices. Thus, we define a base-pairing probability matrix for a multiple alignment <bold>X </bold>as follows:</p>
        <p>
          <disp-formula>
            <mml:math id="M8" name="1471-2105-11-S7-S3-i8" overflow="scroll">
              <mml:mtable columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:msub>
                      <mml:mi>P</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>X</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mfrac>
                      <mml:mn>1</mml:mn>
                      <mml:mrow>
                        <mml:mi>N</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>X</mml:mi>
                        </mml:mstyle>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mstyle displaystyle="true">
                      <mml:munderover>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>N</mml:mi>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>X</mml:mi>
                          </mml:mstyle>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:munderover>
                      <mml:mrow>
                        <mml:msub>
                          <mml:msup>
                            <mml:mi>P</mml:mi>
                            <mml:mo>′</mml:mo>
                          </mml:msup>
                          <mml:mrow>
                            <mml:msup>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>X</mml:mi>
                              </mml:mstyle>
                              <mml:mi>k</mml:mi>
                            </mml:msup>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:msub>
                      <mml:msup>
                        <mml:mi>P</mml:mi>
                        <mml:mo>′</mml:mo>
                      </mml:msup>
                      <mml:mrow>
                        <mml:msup>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>X</mml:mi>
                          </mml:mstyle>
                          <mml:mi>k</mml:mi>
                        </mml:msup>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mo>{</mml:mo>
                      <mml:mrow>
                        <mml:mtable columnalign="left">
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:msub>
                                  <mml:mi>P</mml:mi>
                                  <mml:mrow>
                                    <mml:msup>
                                      <mml:mstyle mathvariant="bold" mathsize="normal">
                                        <mml:mi>X</mml:mi>
                                      </mml:mstyle>
                                      <mml:msup>
                                        <mml:mi>k</mml:mi>
                                        <mml:mo>′</mml:mo>
                                      </mml:msup>
                                    </mml:msup>
                                  </mml:mrow>
                                </mml:msub>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>i</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>,</mml:mo>
                                <mml:mi>r</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mtext>either</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>of</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:msubsup>
                                  <mml:mi>X</mml:mi>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>k</mml:mi>
                                </mml:msubsup>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>or</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:msubsup>
                                  <mml:mi>X</mml:mi>
                                  <mml:mi>j</mml:mi>
                                  <mml:mi>k</mml:mi>
                                </mml:msubsup>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>is</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>not</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>a</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>gap</mml:mtext>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mn>0</mml:mn>
                            </mml:mtd>
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mtext>otherwise</mml:mtext>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>,</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>where <bold>X</bold><italic><sup>k' </sup></italic>is the original sequence of <bold>X</bold><italic><sup>k </sup></italic>without gaps, <italic>r</italic>(<italic>i</italic>) is the index in <bold>X</bold><italic><sup>k' </sup></italic>corresponding to the <italic>i</italic>-th position in <bold>X</bold><italic><sup>k</sup></italic>, and <italic>N</italic>(<bold>X</bold>) is the number of aligned sequences in <bold>X</bold>.</p>
        <p>The sequence similarity <italic>S</italic><sub>seq </sub>can be extended by defining a substitution score <italic>s</italic>(·,·) between two alignment columns. We use the averaged score of all possible substitutions between two columns, <italic>X<sub>i </sub></italic>and <italic>Y<sub>j</sub></italic>:</p>
        <p>
          <disp-formula>
            <mml:math id="M9" name="1471-2105-11-S7-S3-i9" overflow="scroll">
              <mml:mtable columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:mi>s</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>X</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>Y</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mtext> </mml:mtext>
                    <mml:mfrac>
                      <mml:mn>1</mml:mn>
                      <mml:mrow>
                        <mml:mi>N</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>X</mml:mi>
                        </mml:mstyle>
                        <mml:mo stretchy="false">)</mml:mo>
                        <mml:mi>N</mml:mi>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mstyle mathvariant="bold" mathsize="normal">
                          <mml:mi>Y</mml:mi>
                        </mml:mstyle>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mstyle displaystyle="true">
                      <mml:munderover>
                        <mml:mo>∑</mml:mo>
                        <mml:mrow>
                          <mml:mi>k</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>N</mml:mi>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mstyle mathvariant="bold" mathsize="normal">
                            <mml:mi>X</mml:mi>
                          </mml:mstyle>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:munderover>
                      <mml:mrow>
                        <mml:mstyle displaystyle="true">
                          <mml:munderover>
                            <mml:mo>∑</mml:mo>
                            <mml:mrow>
                              <mml:mi>l</mml:mi>
                              <mml:mo>=</mml:mo>
                              <mml:mn>1</mml:mn>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>N</mml:mi>
                              <mml:mo stretchy="false">(</mml:mo>
                              <mml:mstyle mathvariant="bold" mathsize="normal">
                                <mml:mi>Y</mml:mi>
                              </mml:mstyle>
                              <mml:mo stretchy="false">)</mml:mo>
                            </mml:mrow>
                          </mml:munderover>
                          <mml:msup>
                            <mml:mi>s</mml:mi>
                            <mml:mo>′</mml:mo>
                          </mml:msup>
                        </mml:mstyle>
                      </mml:mrow>
                    </mml:mstyle>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msubsup>
                      <mml:mi>X</mml:mi>
                      <mml:mi>i</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mi>Y</mml:mi>
                      <mml:mi>j</mml:mi>
                      <mml:mi>l</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>,</mml:mo>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:msup>
                      <mml:mi>s</mml:mi>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msubsup>
                      <mml:mi>X</mml:mi>
                      <mml:mi>i</mml:mi>
                      <mml:mi>k</mml:mi>
                    </mml:msubsup>
                    <mml:mo>,</mml:mo>
                    <mml:msubsup>
                      <mml:mi>Y</mml:mi>
                      <mml:mi>j</mml:mi>
                      <mml:mi>l</mml:mi>
                    </mml:msubsup>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mo>=</mml:mo>
                    <mml:mrow>
                      <mml:mo>{</mml:mo>
                      <mml:mrow>
                        <mml:mtable columnalign="left">
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:msubsup>
                                  <mml:mi>X</mml:mi>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>k</mml:mi>
                                </mml:msubsup>
                                <mml:mo>,</mml:mo>
                                <mml:msubsup>
                                  <mml:mi>Y</mml:mi>
                                  <mml:mi>j</mml:mi>
                                  <mml:mi>l</mml:mi>
                                </mml:msubsup>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mtext>either</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>of</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:msubsup>
                                  <mml:mi>X</mml:mi>
                                  <mml:mi>i</mml:mi>
                                  <mml:mi>k</mml:mi>
                                </mml:msubsup>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>or</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:msubsup>
                                  <mml:mi>Y</mml:mi>
                                  <mml:mi>j</mml:mi>
                                  <mml:mi>l</mml:mi>
                                </mml:msubsup>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>is</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>not</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>a</mml:mtext>
                                <mml:mtext> </mml:mtext>
                                <mml:mtext>gap</mml:mtext>
                                <mml:mo stretchy="false">)</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                          <mml:mtr columnalign="left">
                            <mml:mtd columnalign="left">
                              <mml:mn>0</mml:mn>
                            </mml:mtd>
                            <mml:mtd columnalign="left">
                              <mml:mrow>
                                <mml:mo stretchy="false">(</mml:mo>
                                <mml:mtext>otherwise</mml:mtext>
                                <mml:mo stretchy="false">)</mml:mo>
                                <mml:mo>.</mml:mo>
                              </mml:mrow>
                            </mml:mtd>
                          </mml:mtr>
                        </mml:mtable>
                      </mml:mrow>
                    </mml:mrow>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
          </disp-formula>
        </p>
        <p>This is equivalent to the sum-of-pairs score, which is widely used in the problem of group-to-group alignment for primary sequences.</p>
      </sec>
      <sec>
        <title>Rationale for the scoring function</title>
        <p>Although the scoring function (2) in our method has been first proposed for STRAL, its theoretical aspect has been not fully clarified in the previous study [<xref ref-type="bibr" rid="B21">21</xref>]. Here, we formulate the scoring function (2) in the different manner from [<xref ref-type="bibr" rid="B21">21</xref>]. For this purpose, let us consider the following scoring function.</p>
        <p>
          <disp-formula id="bmcM3">
            <label>(3)</label>
            <mml:math id="M10" name="1471-2105-11-S7-S3-i10" overflow="scroll">
              <mml:mrow>
                <mml:msub>
                  <mml:mi>W</mml:mi>
                  <mml:mrow>
                    <mml:mstyle mathvariant="bold" mathsize="normal">
                      <mml:mi>x</mml:mi>
                      <mml:mi>y</mml:mi>
                    </mml:mstyle>
                  </mml:mrow>
                </mml:msub>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>|</mml:mo>
                    <mml:msub>
                      <mml:mi>θ</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                    <mml:msub>
                      <mml:mrow/>
                      <mml:mo>,</mml:mo>
                    </mml:msub>
                    <mml:msub>
                      <mml:mi>θ</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>y</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mtext> </mml:mtext>
                <mml:mo>=</mml:mo>
                <mml:mi>α</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>L</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:msub>
                      <mml:mi>L</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>y</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mi>j</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:mtext> </mml:mtext>
                    <mml:mo>+</mml:mo>
                    <mml:msub>
                      <mml:mi>R</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>x</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mi>i</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                    <mml:msub>
                      <mml:mi>R</mml:mi>
                      <mml:mstyle mathvariant="bold" mathsize="normal">
                        <mml:mi>y</mml:mi>
                      </mml:mstyle>
                    </mml:msub>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mi>j</mml:mi>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mtext> </mml:mtext>
                <mml:mo>+</mml:mo>
                <mml:mi>s</mml:mi>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>x</mml:mi>
                      <mml:mi>i</mml:mi>
                    </mml:msub>
                    <mml:mo>,</mml:mo>
                    <mml:msub>
                      <mml:mi>y</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:msub>
                  <mml:mi>U</mml:mi>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi>x</mml:mi>
                  </mml:mstyle>
                </mml:msub>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mi>i</mml:mi>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:msub>
                  <mml:mi>U</mml:mi>
                  <mml:mstyle mathvariant="bold" mathsize="normal">
                    <mml:mi>y</mml:mi>
                  </mml:mstyle>
                </mml:msub>
                <mml:mrow>
                  <mml:mo>(</mml:mo>
                  <mml:mi>j</mml:mi>
                  <mml:mo>)</mml:mo>
                </mml:mrow>
                <mml:mo>.</mml:mo>
              </mml:mrow>
            </mml:math>
          </disp-formula>
        </p>
        <p>Given a pair of secondary structures, <italic>θ</italic><bold><sub>x </sub></bold>for <bold>x </bold>and <italic>θ</italic><bold><sub>y </sub></bold>for <bold>y</bold>, this function defines the score for matching the <italic>i</italic>-th position in <bold>x </bold>and the <italic>j</italic>-th position in <bold>y</bold>. The score can take a non-zero value in three different cases depending on the direction of base-pairing at the <italic>i</italic>-th position in <italic>θ</italic><bold><sub>x </sub></bold>and the <italic>j</italic>-th position in <italic>θ</italic><bold><sub>y</sub></bold>: it takes α when both of the two positions form a base pair with one of their downstream positions, respectively; it takes α when both of the two positions form a base pair with one of their upstream positions, respectively; and it takes <italic>s</italic>(<italic>x<sub>i</sub></italic>, <italic>y<sub>j</sub></italic>) when both of the two positions are unpaired. Thus, the scoring function (3) evaluates the similarity based on the criteria of whether the two positions have the same state of base-pairing.</p>
        <p>In the equation (3), we need one fixed pair of secondary structures, <italic>θ</italic><bold><sub>x </sub></bold>and <italic>θ</italic><bold><sub>y</sub></bold>. However, we typically do not know one reliable secondary structure for each of <bold>x </bold>and <bold>y</bold>, and have the uncertainty about many suboptimal secondary structures. Therefore, we use the ensemble of all possible secondary structures by taking the expectation of (3) over Θ<bold><sub>x </sub></bold>and Θ<bold><sub>y</sub></bold>:</p>
        <p><disp-formula id="bmcM4"><label>(4)</label><mml:math id="M11" name="1471-2105-11-S7-S3-i11" overflow="scroll"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mtext>x</mml:mtext></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>Θ</mml:mi><mml:mtext>x</mml:mtext></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mtext>y</mml:mtext></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mi>Θ</mml:mi><mml:mtext>y</mml:mtext></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mrow><mml:mtext>xy</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>|</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>x</mml:mtext></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>y</mml:mtext></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>x</mml:mtext></mml:msub><mml:mo>|</mml:mo><mml:mtext>x</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mtext>y</mml:mtext></mml:msub><mml:mo>|</mml:mo><mml:mtext>y</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>α</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mtext>x</mml:mtext><mml:mi>L</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mtext>y</mml:mtext><mml:mi>L</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mtext>x</mml:mtext><mml:mi>R</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mtext>y</mml:mtext><mml:mi>R</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mtext>x</mml:mtext><mml:mi>U</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mtext>y</mml:mtext><mml:mi>U</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>.</p>
        <p>The resulting scoring function (4) can be regarded as a variant of the STRAL's scoring function (2) without square-root operations. In practice, we find that (2) gives slightly better performance compared to (4), and thus use (2) for the component of our method.</p>
      </sec>
    </sec>
    <sec>
      <title>Performance evaluation</title>
      <p>In this section, we examine the accuracy of Profile BPLA kernel in comparison to the state-of-the-art prediction methods based on SVMs. Furthermore, we present a systematic evaluation about the robustness of Profile BPLA kernel against the Type A and the Type B errors in input alignments. See Background for the definitions of the Type A and the Type B errors.</p>
      <sec>
        <title>Dataset and experimental system</title>
        <p>We created a dataset which includes 990 positive samples from five ncRNA families: C/D snoRNAs, H/ACA snoRNAs, miRNA precursors, riboswitches, and tRNAs. These families were collected by combining 885 smaller families in the Rfam database [<xref ref-type="bibr" rid="B25">25</xref>] into larger categories (Table <xref ref-type="table" rid="T1">1</xref>). Each positive sample is an alignment of ncRNAs, and is separated by a sequence identity of less than 60% from the other alignment data (see Methods for details). For the construction of input alignments, we produced two versions of the dataset: the high-quality structural alignments by RAF [<xref ref-type="bibr" rid="B26">26</xref>], and the sequence-based alignments by CLUSTALW [<xref ref-type="bibr" rid="B27">27</xref>]. We generated negative samples which have the same dinucleotide contents as the positives using the randomization by SISSIz [<xref ref-type="bibr" rid="B28">28</xref>].</p>
        <table-wrap id="T1" position="float">
          <label>Table 1</label>
          <caption>
            <p>Summary of the combined Rfam families.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th align="right">Family</th>
                <th align="center">NF</th>
                <th align="center">N</th>
                <th align="center">NS</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="right">C/D snoRNA</td>
                <td align="center">340</td>
                <td align="center">272</td>
                <td align="center">5</td>
              </tr>
              <tr>
                <td align="right">H/ACA snoRNA</td>
                <td align="center">133</td>
                <td align="center">119</td>
                <td align="center">5</td>
              </tr>
              <tr>
                <td align="right">miRNA precursor</td>
                <td align="center">401</td>
                <td align="center">431</td>
                <td align="center">5</td>
              </tr>
              <tr>
                <td align="right">Riboswitch</td>
                <td align="center">10</td>
                <td align="center">85</td>
                <td align="center">3</td>
              </tr>
              <tr>
                <td align="right">tRNA</td>
                <td align="center">1</td>
                <td align="center">83</td>
                <td align="center">3</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Family: name of the larger category used in the performance evaluation. NF: number of smaller families in the Rfam database which were combined. N: number of positive samples. NS: average number of aligned sequences per sample.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>The accuracy of the prediction methods was assessed by the area under the receiver operating characteristic (ROC) curve, <italic>i.e</italic>., the ROC score. The ROC curve plots the true positive rate <italic>TP/</italic>(<italic>TP </italic>+ <italic>FN</italic>) versus false positive rate <italic>FP/</italic>(<italic>TN </italic>+ <italic>FP </italic>) for different decision thresholds of a SVM classifier, where <italic>TP </italic>is the number of correctly predicted positives, <italic>FP </italic>is the number of incorrectly predicted positives, <italic>TN </italic>is the number of correctly predicted negatives, and <italic>FN </italic>is the number of incorrectly predicted negatives. We used four-fold cross-validation with the following modifications. The SVM classifier was trained with the same number of negative samples as the positives, and tested on a data partition which includes eight times as many negative samples as the positives. This problem setting is analogous to genomic and transcriptomic screens, where the vast majority of the search space does not contain functional ncRNA genes. Moreover, the four-fold cross validation is repeated four times with different splits of the dataset (16 trials in total). The parameters <italic>α</italic>, <italic>β</italic>, <italic>g</italic>, and <italic>d </italic>in Profile BPLA kernel were adapted to the training data using the gradient-based optimization developed for the original BPLA kernel [<xref ref-type="bibr" rid="B29">29</xref>]. Note that we did not used the test data for the parameter optimization to avoid overfitting.</p>
      </sec>
      <sec>
        <title>Accuracy improvement by the profile information</title>
        <p>We first examined whether the proposed kernel could achieve better accuracy than the original BPLA kernel by utilizing the profile information of alignment data. For this purpose, the dataset of single sequences was created from the alignment dataset described above. For positive samples, we randomly chose one sequence from each alignment of ncRNAs. We generated negative samples which have the same dinucleotide contents as the positives by the standard shuffling procedure [<xref ref-type="bibr" rid="B30">30</xref>]. Then, the proposed kernel and the original BPLA kernel were compared using the high-quality structural alignment dataset and the corresponding single sequence dataset, respectively.</p>
        <p>Table <xref ref-type="table" rid="T2">2</xref> presents the experimental results. As expected, the proposed kernel achieved the better ROC scores than the original BPLA kernel for the all ncRNA families. These results suggest that the profile information contained in alignment data is useful to improve the prediction of ncRNAs.</p>
        <table-wrap id="T2" position="float">
          <label>Table 2</label>
          <caption>
            <p>Accuracy improvement by the profile information.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th/>
                <th align="center" colspan="2">ROC score (stdev)</th>
              </tr>
              <tr>
                <th align="right">Family</th>
                <th align="center">Original BPLA kernel</th>
                <th align="center">Profile BPLA kernel</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="right">C/D snoRNA</td>
                <td align="center">0.91 (0.02)</td>
                <td align="center">0.95 (0.02)</td>
              </tr>
              <tr>
                <td align="right">H/ACA snoRNA</td>
                <td align="center">0.93 (0.03)</td>
                <td align="center">0.97 (0.02)</td>
              </tr>
              <tr>
                <td align="right">miRNA precursor</td>
                <td align="center">0.96 (0.01)</td>
                <td align="center">0.97 (0.01)</td>
              </tr>
              <tr>
                <td align="right">Riboswitch</td>
                <td align="center">0.86 (0.04)</td>
                <td align="center">0.92 (0.05)</td>
              </tr>
              <tr>
                <td align="right">tRNA</td>
                <td align="center">0.98 (0.02)</td>
                <td align="center">1.00 (0.00)</td>
              </tr>
              <tr>
                <td colspan="3">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="right">average</td>
                <td align="center">0.93 (0.02)</td>
                <td align="center">0.96 (0.02)</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Family: name of the target ncRNA family. ROC score: area under the ROC curve. Profile BPLA kernel, which utilizes the profile information of alignment data, is compared to the original BPLA kernel for single sequences.</p>
          </table-wrap-foot>
        </table-wrap>
      </sec>
      <sec>
        <title>Accuracy on the high-quality structural alignment dataset</title>
        <p>Next, we compared Profile BPLA kernel with the existing prediction methods which also utilize the profile information. In the ideal condition, the profile information should be extracted from high-quality alignment data such that all sequences are actually ncRNAs and aligned taking into account their secondary structures. Therefore, we tested the accuracy of each prediction method using the high-quality structural alignment dataset constructed by RAF. The competitors were RNAz [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>] and Profile stem kernel [<xref ref-type="bibr" rid="B8">8</xref>]. We also performed the experiment with the profile version of LA kernel, which does not consider secondary structure information, by setting base-pairing profiles {<italic>L</italic><bold><sub>x</sub></bold>(<italic>i</italic>) = 0, <italic>R</italic><bold><sub>x</sub></bold>(<italic>i</italic>) = 0, <italic>U</italic><bold><sub>x</sub></bold>(<italic>i</italic>) = 1} in Profile BPLA kernel.</p>
        <p>Table <xref ref-type="table" rid="T3">3</xref> presents the experimental results. Profile BPLA kernel outperformed the other prediction methods except for riboswitches, and achieved the best ROC score on average. The accuracy of Profile LA kernel was severely limited compared to the prediction methods which consider secondary structure information. However, for C/D snoRNAs, Profile LA kernel resulted in the comparable ROC score with RNAz and Profile stem kernel. These results suggest that RNAz and Profile stem kernel may fail to incorporate the effective information of secondary structures. Profile BPLA kernel consistently achieved the better ROC scores than Profile LA kernel, showing its wide applicability.</p>
        <table-wrap id="T3" position="float">
          <label>Table 3</label>
          <caption>
            <p>Accuracy on the high-quality structural alignment dataset.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th/>
                <th align="center" colspan="4">ROC score (stdev)</th>
              </tr>
              <tr>
                <th align="right">Family</th>
                <th align="center">Profile BPLA kernel</th>
                <th align="center">Profile LA kernel</th>
                <th align="center">Profile stem kernel</th>
                <th align="center">RNAz</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="right">C/D snoRNA</td>
                <td align="center">0.95 (0.02)</td>
                <td align="center">0.79 (0.04)</td>
                <td align="center">0.80 (0.02)</td>
                <td align="center">0.78 (0.03)</td>
              </tr>
              <tr>
                <td align="right">H/ACA snoRNA</td>
                <td align="center">0.97 (0.02)</td>
                <td align="center">0.65 (0.20)</td>
                <td align="center">0.89 (0.04)</td>
                <td align="center">0.95 (0.03)</td>
              </tr>
              <tr>
                <td align="right">miRNA precursor</td>
                <td align="center">0.97 (0.01)</td>
                <td align="center">0.69 (0.02)</td>
                <td align="center">0.92 (0.01)</td>
                <td align="center">0.96 (0.01)</td>
              </tr>
              <tr>
                <td align="right">Riboswitch</td>
                <td align="center">0.92 (0.05)</td>
                <td align="center">0.41 (0.23)</td>
                <td align="center">0.77 (0.05)</td>
                <td align="center">0.97 (0.02)</td>
              </tr>
              <tr>
                <td align="right">tRNA</td>
                <td align="center">1.00 (0.00)</td>
                <td align="center">0.88 (0.03)</td>
                <td align="center">0.95 (0.02)</td>
                <td align="center">0.96 (0.02)</td>
              </tr>
              <tr>
                <td colspan="5">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="right">Average</td>
                <td align="center">0.96 (0.02)</td>
                <td align="center">0.69 (0.10)</td>
                <td align="center">0.86 (0.03)</td>
                <td align="center">0.92 (0.02)</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Family: name of the target ncRNA family. ROC score: area under the ROC curve. Profile BPLA kernel is compared to the other prediction methods which also utilize the profile information of alignment data: Profile LA kernel, Profile stem kernel, and RNAz.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>The superiority of Profile BPLA kernel is inherited from the original BPLA kernel. In our previous paper [<xref ref-type="bibr" rid="B16">16</xref>], we have proved that the original BPLA kernel outperforms the non-profile versions of Stem kernel and LA kernel. Our results showed the high accuracy of BPLA kernels in the prediction from alignment data as well as from single sequences. (Note that the non-profile version of RNAz does not exist since the feature values of alignment data used in the method can not be defined for single sequences.)</p>
      </sec>
      <sec>
        <title>Robustness against the Type A errors</title>
        <p>In addition to the standard benchmark tests, we extensively evaluated the robustness of Profile BPLA kernel against errors in input alignments. To discuss the Type A errors, we performed the experiment using the sequence-based alignment dataset constructed by CLUSTALW instead of the high-quality structural alignment dataset.</p>
        <p>By comparing the results in Table <xref ref-type="table" rid="T4">4</xref> with those in Table <xref ref-type="table" rid="T3">3</xref>, we can see the robustness of each prediction method against the Type A errors. Profile BPLA kernel achieved almost the same ROC scores for the two datasets, showing the comparable robustness to RNAz and Profile stem kernel.</p>
        <table-wrap id="T4" position="float">
          <label>Table 4</label>
          <caption>
            <p>Accuracy on the sequence-based alignment dataset.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th/>
                <th align="center" colspan="4">ROC score (stdev)</th>
              </tr>
              <tr>
                <th align="right">Family</th>
                <th align="center">Profile BPLA kernel</th>
                <th align="center">Profile LA kernel</th>
                <th align="center">Profile stem kernel</th>
                <th align="center">RNAz</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="right">C/D snoRNA</td>
                <td align="center">0.95 (0.01)</td>
                <td align="center">0.80 (0.04)</td>
                <td align="center">0.80 (0.02)</td>
                <td align="center">0.77 (0.02)</td>
              </tr>
              <tr>
                <td align="right">H/ACA snoRNA</td>
                <td align="center">0.96 (0.02)</td>
                <td align="center">0.77 (0.17)</td>
                <td align="center">0.87 (0.03)</td>
                <td align="center">0.94 (0.03)</td>
              </tr>
              <tr>
                <td align="right">miRNA precursor</td>
                <td align="center">0.97 (0.01)</td>
                <td align="center">0.69 (0.03)</td>
                <td align="center">0.92 (0.02)</td>
                <td align="center">0.96 (0.01)</td>
              </tr>
              <tr>
                <td align="right">Riboswitch</td>
                <td align="center">0.92 (0.03)</td>
                <td align="center">0.38 (0.19)</td>
                <td align="center">0.79 (0.05)</td>
                <td align="center">0.94 (0.02)</td>
              </tr>
              <tr>
                <td align="right">tRNA</td>
                <td align="center">1.00 (0.00)</td>
                <td align="center">0.88 (0.03)</td>
                <td align="center">0.94 (0.03)</td>
                <td align="center">0.95 (0.02)</td>
              </tr>
              <tr>
                <td colspan="5">
                  <hr/>
                </td>
              </tr>
              <tr>
                <td align="right">average</td>
                <td align="center">0.96 (0.02)</td>
                <td align="center">0.70 (0.09)</td>
                <td align="center">0.86 (0.03)</td>
                <td align="center">0.91 (0.02)</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <p>Family: name of the target ncRNA family. ROC score: area under the ROC curve. Profile BPLA kernel is compared to the other prediction methods which also utilize the profile information of alignment data: Profile LA kernel, Profile stem kernel, and RNAz.</p>
          </table-wrap-foot>
        </table-wrap>
        <p>The robustness of Profile BPLA kernel can be attributed to its formulation. Profile BPLA kernel utilizes averaged base-pairing probability matrices to obtain the profile information of secondary structures. Averaged base-pairing probability matrices have been shown to be useful for the robust modeling of consensus secondary structures against the Type A errors [<xref ref-type="bibr" rid="B12">12</xref>]. Our results showed the effectiveness of averaging base-pairing probabilities for the robustness in the problem of ncRNA prediction.</p>
        <p>Our experiment provided the detailed evaluation of the robustness for each particular ncRNA family. The recent study has reported that the accuracy of RNAz can be slightly improved by the use of structural alignment data [<xref ref-type="bibr" rid="B7">7</xref>]. However, the experiment in [<xref ref-type="bibr" rid="B7">7</xref>] has been performed on the dataset with various families mixed. In our experiment, we found that the Type A errors had different effects on the performance of each prediction method depending on families. This in-depth view of the robustness is especially important when we target a particular family in genomic and transcriptomic screens.</p>
        <p>Our results also demonstrated that Profile BPLA kernel outperformed the existing prediction methods in the "realistic" condition considered in the previous studies [<xref ref-type="bibr" rid="B6">6</xref>-<xref ref-type="bibr" rid="B8">8</xref>]. Profile BPLA kernel achieved the best ROC scores for the sequence-based alignment dataset with the Type A errors as well as for the high-quality structural alignment dataset. In the following experiments, we further evaluated the robustness of Profile BPLA kernel against the Type B errors which have been neglected in the previous studies.</p>
      </sec>
      <sec>
        <title>Robustness against the Type B errors</title>
        <p>For the systematic evaluation of the robustness, we prepared a controlled series of alignment data with different degrees of the Type B errors. Input alignments in genomic and transcriptomic screens are typically constructed by sequence-based alignment tools. Hence, alignment data with the Type B errors are expected to be optimal at least under the criteria of sequence-based alignment tools, even though incorrect from the viewpoint of secondary structures. Based on this assumption, we generated sequences which can be well aligned to a given alignment in terms of primary sequences, but do not conserve its consensus secondary structure (see Methods for details). By introducing these "unrelated" sequences, we simulated the Type B errors in the sequence-based alignment dataset. For each positive sample in the test data, a series of erroneous alignments was prepared by gradually replacing ncRNA sequences with unrelated sequences. We aligned the unrelated sequences with the remaining ncRNA sequences using CLUSTALW. The resulting alignments were then used to make the equal-size datasets for the different fractions of unrelated sequences ranged from 0.0 to 1.0 at intervals of 0.1. An alignment comprising <italic>n </italic>ncRNA sequences and <italic>m </italic>unrelated sequences was included in the dataset of the fraction <italic>f </italic>satisfying (<italic>m - </italic>1)/(<italic>n </italic>+ <italic>m</italic>) &lt; f ≤ <italic>m/</italic>(<italic>n </italic>+ <italic>m</italic>). We trained the SVM classifiers with the original training data in the sequence-based alignment dataset, and tested them on the datasets with the different degrees of the simulated Type B errors. The performance was assessed by the ROC score for discriminating the erroneous alignments from the alignments consisting only of unrelated sequences.</p>
        <p>The experimental results are shown in Figure <xref ref-type="fig" rid="F1">1</xref>. In this figure, zero in the horizontal axis is equivalent to an ordinary prediction problem in which alignments to be discriminated from negative samples do not contain any unrelated sequences. In this situation, Profile BPLA kernel achieved the best accuracy on average, being consistent with the results in Table <xref ref-type="table" rid="T4">4</xref>. (The ROC scores, however, were not exactly the same as those in Table <xref ref-type="table" rid="T4">4</xref> since we used the different kind of negative samples in the test data between the two experiments: alignments consisting only of unrelated sequences for Figure <xref ref-type="fig" rid="F1">1</xref>, and dinucleotide-controlled samples for Table <xref ref-type="table" rid="T4">4</xref>.) As the fraction of unrelated sequences increased, the ROC scores for RNAz rapidly fell down to the baseline. In contrast, Profile BPLA kernel kept the discrimination at high levels until the alignments were overwhelmed by the Type B errors. A similar tendency was seen for Profile stem kernel, although its ROC scores were smaller than Profile BPLA kernel. The performance of Profile LA kernel was seriously damaged by the Type B errors since the method does not consider secondary structures of unrelated sequences. These results suggest that Profile BPLA kernel is the only method which can effectively detect ncRNAs in the presence of the Type B errors.</p>
        <fig id="F1" position="float">
          <label>Figure 1</label>
          <caption>
            <p><bold>Accuracy on the sequence-based alignment dataset with different fractions of unrelated sequences</bold>. For each point, the alignments with the different fraction of unrelated sequences were discriminated from the negative samples which consist only of unrelated sequences. Zero in the horizontal axis corresponds to the detection of the alignments which consist only of actual ncRNAs, <italic>i.e</italic>., an ordinary discrimination problem without the Type B errors. The error bars show standard deviation of ROC scores.</p>
          </caption>
          <graphic xlink:href="1471-2105-11-S7-S3-1"/>
        </fig>
        <p>The observed differences in the robustness among the methods are deeply connected with the rationales behind their predictions. RNAz detects ncRNAs by utilizing the SCI which measures the conservation of secondary structures in an alignment. Therefore, the experimental results for RNAz can be interpreted as showing that unrelated sequences cause noise in a conserved secondary structure. Profile BPLA kernel do not measure the conservation of secondary structures. Instead, we directly calculate the similarity of secondary structures between input alignments and training data. Hence, Profile BPLA kernel can detect an alignment containing only a few ncRNA sequences if they are similar enough to the ncRNAs in training data, even though the alignment itself is not structurally conserved. Figure <xref ref-type="fig" rid="F2">2</xref> illustrates an example of the Type B errors and its influences on the performance of the prediction methods. Although RNAz accepted the native alignment (Figure <xref ref-type="fig" rid="F2">2a</xref>), it rejected the erroneous alignment (Figure <xref ref-type="fig" rid="F2">2b</xref>) due to the drastic decrease in the SCI value. On the other hand, Profile BPLA kernel kept the SVM class probability moderate for the erroneous alignment, accepting the seven miRNA precursors included in the alignment. Note that the erroneous alignment in Figure <xref ref-type="fig" rid="F2">2b</xref> can be regarded as conserved if we focus only on the sequence identity. This suggests that such alignments can be produced by most alignment tools which do not consider secondary structures. In fact, several studies have suggested that genomic alignments contain significant amounts of the Type B errors [<xref ref-type="bibr" rid="B10">10</xref>,<xref ref-type="bibr" rid="B11">11</xref>]. Therefore, the robustness of Profile BPLA kernel is a desirable characteristic for practical applications.</p>
        <fig id="F2" position="float">
          <label>Figure 2</label>
          <caption>
            <p><bold>Example of the Type B errors and its influence on the prediction methods</bold>. (a) Native alignment consisting only of ncRNAs. An alignment of 10 miRNA precursors is highly conserved in terms of both primary sequences and secondary structures. The consensus secondary structure predicted by RNAalifold [<xref ref-type="bibr" rid="B33">33</xref>] exhibits a well-known hairpin loop. Profile BPLA kernel and the other prediction methods accepted this alignment. (b) Alignment with the Type B errors. Three miRNA precursors in the native alignment were replaced with unrelated sequences, which destroyed the consensus secondary structure. This alignment was rejected by RNAz due to the drastic decrease in the SCI and also missed by Profile stem kernel. Profile LA kernel was completely ruined showing the higher SVM class probability for the erroneous alignment than that for the native one. Profile BPLA kernel was the only method to accept the alignment by the moderate decrease in the SVM class probability from the native one. Note that the mean pairwise identity is still high allowing this alignment to be produced by sequence-based alignment tools.</p>
          </caption>
          <graphic xlink:href="1471-2105-11-S7-S3-2"/>
        </fig>
        <p>We emphasize that the Type B errors can not be corrected even if we realign the alignments using structural alignment tools as attempted in [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>]. In contrast to the Type A errors, the Type B errors are caused by the inclusion of unrelated sequences rather than the small shifts of matches and gaps. To make this point clear, we performed the same experiment as in Figure <xref ref-type="fig" rid="F1">1</xref> and Figure <xref ref-type="fig" rid="F2">2</xref> using RAF instead of CLUSTALW. For the training data, we used the high-quality structural alignment dataset, and for the test data, we used the erroneous alignment realigned by RAF. As expected, the results in Figure <xref ref-type="fig" rid="F3">3</xref> and Figure <xref ref-type="fig" rid="F4">4</xref> were close to those in Figure <xref ref-type="fig" rid="F1">1</xref> and Figure <xref ref-type="fig" rid="F2">2</xref>, respectively. In Figure <xref ref-type="fig" rid="F3">3</xref>, Profile BPLA kernel outperformed the existing prediction methods for native alignments, and successfully kept the discrimination for alignments with moderate degrees of the Type B errors. Although the erroneous alignment in Figure <xref ref-type="fig" rid="F4">4b</xref> was slightly changed from that in Figure <xref ref-type="fig" rid="F2">2b</xref>, the outputs of the prediction methods were not significantly improved. These results suggest that the problem of the Type B errors is inevitable, and the robustness of Profile BPLA kernel is essential to detect ncRNAs from low-quality alignment data.</p>
        <fig id="F3" position="float">
          <label>Figure 3</label>
          <caption>
            <p><bold>Accuracy on the structural alignment dataset with different fractions of unrelated sequences</bold>. For each point, the alignments with the different fraction of unrelated sequences were discriminated from the negative samples which consist only of unrelated sequences. Zero in the horizontal axis corresponds to the detection of the alignments which consist only of actual ncRNAs, <italic>i.e</italic>., an ordinary discrimination problem without the Type B errors. The error bars show standard deviation of ROC scores.</p>
          </caption>
          <graphic xlink:href="1471-2105-11-S7-S3-3"/>
        </fig>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p><bold>Realigning unrelated sequences by structural alignment tools attempting to correct the Type B errors</bold>. (a) Native alignment consisting only of ncRNAs. (b) Alignment with the Type B errors. In contrast to the type A errors, the Type B errors cannot be corrected even if we realign the alignments using structural alignment tools. Profile BPLA kernel was still the only method to accept the seven miRNA precursors in the alignment with the Type B errors.</p>
          </caption>
          <graphic xlink:href="1471-2105-11-S7-S3-4"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>We have described a new method for the prediction of ncRNAs from alignment data. Our method, named Profile BPLA kernel, is an extension of BPLA kernel which was originally developed for the prediction from single sequences [<xref ref-type="bibr" rid="B16">16</xref>]. By utilizing the profile information of alignment data, the proposed kernel can achieve better accuracy than the original BPLA kernel. Furthermore, Profile BPLA kernel outperforms the state-of-the-art prediction methods [<xref ref-type="bibr" rid="B6">6</xref>-<xref ref-type="bibr" rid="B8">8</xref>] which also utilize the profile information.</p>
    <p>The evaluation of the robustness against errors in input alignments is a crucial step for the development of practical prediction methods. Even with prediction methods showing excellent accuracy for well-curated alignment datasets, the same performance typically cannot be expected in the practical situations which involve significant amounts of alignment errors. Previous studies did not fully address this issue. Through the present study, we extensively evaluated the effectiveness of Profile BPLA kernel under the realistic conditions in which the quality of input alignments is not necessarily high. We considered the two different types of error in alignment data: first, that all sequences in an alignment are actually ncRNAs but are aligned ignoring their secondary structures (Type A); second, that an alignment contains unrelated sequences which are not ncRNAs but still aligned (Type B). Our experiments presented the more detailed evaluation for the Type A errors than the previous study [<xref ref-type="bibr" rid="B7">7</xref>], and the first systematic evaluation for the Type B errors. For the Type A errors, Profile BPLA kernel has the comparable robustness to the existing prediction methods. For the Type B errors, Profile BPLA kernel achieves the higher level of robustness than the existing prediction methods.</p>
    <p>We conclude that Profile BPLA kernel provides a promising way for identifying ncRNAs genes from alignment data.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Combining related Rfam families</title>
      <p>We created the datasets for the benchmark tests using the Rfam database [<xref ref-type="bibr" rid="B25">25</xref>] version 9.1. To make the tests more challenging, we combined related Rfam families into larger categories as shown in Table <xref ref-type="table" rid="T1">1</xref>. For example, the C/D snoRNA family in Table <xref ref-type="table" rid="T1">1</xref> was established by combining the 340 Rfam families which have the string "<monospace>snoRNA; CD-box;</monospace>" in the description track. The seed alignments for these families were then split into single sequences. We performed a complete linkage clustering using their sequence identity as the similarity function. Clusters were determined using the similarity threshold of 60%, and we obtained one alignment from each cluster consisting of multiple sequences.</p>
    </sec>
    <sec>
      <title>Generating unrelated sequences</title>
      <p>We generated unrelated sequences for simulating the Type B errors in alignment data. For each larger category in Table <xref ref-type="table" rid="T1">1</xref>, we took the seed alignments of the corresponding smaller Rfam families. For each seed alignment, we constructed a profile hidden Markov model (profile HMM) using HMMER [<xref ref-type="bibr" rid="B31">31</xref>], and a covariance model (CM) using INFERNAL [<xref ref-type="bibr" rid="B32">32</xref>]. Profile HMMs and CMs are grammar models to generate sequences which can be well aligned to given alignments, and to calculate scores for aligning generated sequences to the original alignments. Profile HMMs do not consider the constraints of consensus secondary structures in alignments, whereas CMs do. We generated 100000 sequences from the profile HMM, and calculated the scores for aligning these sequences using the profile HMM and the CM. We needed sequences which can be well aligned to a given alignment, but do not conserve its consensus secondary structure. Therefore, we chose the top 100 sequences whose score difference between the profile HMM and the CM was large, and used them as the pool of unrelated sequences.</p>
    </sec>
    <sec>
      <title>Software versions and options</title>
      <p>We used the most recent version of each software, and if not specified, executed it with the default options. We used RNAz [<xref ref-type="bibr" rid="B6">6</xref>,<xref ref-type="bibr" rid="B7">7</xref>] version 2.0 and Profile stem kernel [<xref ref-type="bibr" rid="B8">8</xref>] version 216c. For the computation of base-pairing probability matrices, we used the Vienna RNA package [<xref ref-type="bibr" rid="B22">22</xref>] version 1.8.4. To construct the sequence-based and the structural alignment datasets, we used CLUSTALW [<xref ref-type="bibr" rid="B27">27</xref>] version 1.83 and RAF [<xref ref-type="bibr" rid="B26">26</xref>] version 1.00, respectively. To generate the negative samples, we used SISSIZ version 0.1 with the option "<monospace>--simulate --tstv --precision 0.05 --rna</monospace>" recommended in the original paper [<xref ref-type="bibr" rid="B28">28</xref>]. For the prediction of the consensus secondary structures shown in Figure <xref ref-type="fig" rid="F2">2</xref> and Figure <xref ref-type="fig" rid="F4">4</xref>, we used RNAalifold [<xref ref-type="bibr" rid="B33">33</xref>] included in the Vienna RNA package version 1.8.4. To simulate the unrelated sequences for the Type B errors, we used the HMMER package [<xref ref-type="bibr" rid="B31">31</xref>] version 2.3.2 and the INFERNAL package [<xref ref-type="bibr" rid="B32">32</xref>] version 1.0. For the individual programs in the HMMER and the INFERNAL packages, we used the following commands: "<monospace>hmmbuild -g", "hmmsearch -E 100000</monospace>", and "<monospace>cmsearch -g -T -10000 --toponly --no-qdb --fil-no-hmm --fil-no-qdb</monospace>". Basically, these options were set because we needed global alignments rather than local alignments for the evaluation of the Type B errors, and wanted to calculate the exact scores for profile HMMs and CMs without several heuristics implemented in the programs.</p>
    </sec>
    <sec>
      <title>Availability</title>
      <p>Our implementation of Profile BPLA kernel (including the original BPLA kernel for single sequences) is freely available at <ext-link ext-link-type="uri" xlink:href="http://bpla-kernel.dna.bio.keio.ac.jp/">http://bpla-kernel.dna.bio.keio.ac.jp/</ext-link> under the GNU general public license. It takes RNA sequences or multiple alignments, and calculates a kernel matrix, which can be used as an input for a popular SVM tool called LIBSVM [<xref ref-type="bibr" rid="B34">34</xref>]. Furthermore, our software is capable of parallel processing using the message passing interface (MPI) [<xref ref-type="bibr" rid="B35">35</xref>].</p>
    </sec>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>Y Saito extended the code, performed the experiments and drafted the manuscript. KS developed the algorithm and wrote the original code. Y Sakakibara conceived of the study, and participated in its design and coordination. All authors have read and approved the final manuscript.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="S1">
      <caption>
        <title>Additional file 1</title>
        <p><bold>Figure S1</bold>. Overview of the original BPLA kernel and Profile BPLA kernel. The whole schemes of our method were summarized using a pseudo-code in PDF format.</p>
      </caption>
      <media xlink:href="1471-2105-11-S7-S3-S1.pdf" mimetype="application" mime-subtype="pdf">
        <caption>
          <p>Click here for file</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This work was supported by KAKENHI (Grant-in-Aid for Scientific Research) on Innovative Areas (No.221S0002) from the Ministry of Education, Culture, Sports, Science and Technology of Japan. This work was also supported in part by KAKENHI (Grant-in-Aid for Scientific Research) on Priority Area "Comparative Genomics" (No.17018029) from the Ministry of Education, Culture, Sports, Science and Technology of Japan, and by a grant from "Functional RNA Project" funded by the New Energy and Industrial Technology Development Organization (NEDO) of Japan.</p>
    <p>This article has been published as part of BMC Bioinformatics Volume 11 Supplement 7, 2010: Ninth International Conference on Bioinformatics (InCoB2010): Bioinformatics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/11?issue=S7">http://www.biomedcentral.com/1471-2105/11?issue=S7</ext-link>.</p>
  </sec>
  <ref-list>
    <ref id="B1">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <article-title>Computational genomics of noncoding RNA genes</article-title>
        <source>Cell</source>
        <year>2002</year>
        <volume>109</volume>
        <issue>2</issue>
        <fpage>137</fpage>
        <lpage>40</lpage>
        <pub-id pub-id-type="doi">10.1016/S0092-8674(02)00727-4</pub-id>
        <pub-id pub-id-type="pmid">12007398</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hüttenhofer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Schattner</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Polacek</surname>
          <given-names>N</given-names>
        </name>
        <article-title>Non-coding RNAs: hope or hype?</article-title>
        <source>Trends Genet</source>
        <year>2005</year>
        <volume>21</volume>
        <issue>5</issue>
        <fpage>289</fpage>
        <lpage>97</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tig.2005.03.007</pub-id>
        <pub-id pub-id-type="pmid">15851066</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Zuker</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Stiegler</surname>
          <given-names>P</given-names>
        </name>
        <article-title>Optimal computer folding of large RNA sequences using thermodynamics and auxiliary information</article-title>
        <source>Nucleic Acids Res</source>
        <year>1981</year>
        <volume>9</volume>
        <fpage>133</fpage>
        <lpage>48</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/9.1.133</pub-id>
        <pub-id pub-id-type="pmid">6163133</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal">
        <name>
          <surname>McCaskill</surname>
          <given-names>JS</given-names>
        </name>
        <article-title>The equilibrium partition function and base pair binding probabilities for RNA secondary structure</article-title>
        <source>Biopolymers</source>
        <year>1990</year>
        <volume>29</volume>
        <issue>6-7</issue>
        <fpage>1105</fpage>
        <lpage>19</lpage>
        <pub-id pub-id-type="doi">10.1002/bip.360290621</pub-id>
        <pub-id pub-id-type="pmid">1695107</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Athanasius</surname>
          <given-names>F</given-names>
        </name>
        <collab>Bompfünewerer Consortium</collab>
        <name>
          <surname>Backofen</surname>
          <given-names>R</given-names>
        </name>
        <name>
          <surname>Bernhart</surname>
          <given-names>SH</given-names>
        </name>
        <name>
          <surname>Flamm</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Fried</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Fritzsch</surname>
          <given-names>G</given-names>
        </name>
        <name>
          <surname>Hackermüller</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hertel</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Hofacker</surname>
          <given-names>IL</given-names>
        </name>
        <name>
          <surname>K</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Mosig</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Prohaska</surname>
          <given-names>SJ</given-names>
        </name>
        <name>
          <surname>Rose</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>PF</given-names>
        </name>
        <name>
          <surname>Tanzer</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Washietl</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Will</surname>
          <given-names>S</given-names>
        </name>
        <article-title>RNAs everywhere: genome-wide annotation of structured RNAs</article-title>
        <source>J Exp Zool B Mol Dev Evol</source>
        <year>2007</year>
        <volume>308</volume>
        <fpage>1</fpage>
        <lpage>25</lpage>
        <pub-id pub-id-type="pmid">17171697</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Washietl</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Hofacker</surname>
          <given-names>IL</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>PF</given-names>
        </name>
        <article-title>Fast and reliable prediction of noncoding RNAs</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>2005</year>
        <volume>102</volume>
        <issue>7</issue>
        <fpage>2454</fpage>
        <lpage>59</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.0409169102</pub-id>
        <pub-id pub-id-type="pmid">15665081</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gruber</surname>
          <given-names>AR</given-names>
        </name>
        <name>
          <surname>Findeiß</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Washietl</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Hofacker</surname>
          <given-names>IL</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>PF</given-names>
        </name>
        <article-title>RNAZ 2.0: IMPROVED NONCODING RNA DETECTION</article-title>
        <source>Pac Symp Biocomput</source>
        <year>2010</year>
        <volume>15</volume>
        <fpage>69</fpage>
        <lpage>79</lpage>
        <pub-id pub-id-type="pmid">19908359</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sato</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Mituyama</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Asai</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Sakakibara</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>Directed acyclic graph kernels for structural RNA analysis</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>318</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-318</pub-id>
        <pub-id pub-id-type="pmid">18647390</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sakakibara</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Popendorf</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Ogawa</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Asai</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Sato</surname>
          <given-names>K</given-names>
        </name>
        <article-title>Stem kernels for RNA sequence analyses</article-title>
        <source>J Bioinform Comput Biol</source>
        <year>2007</year>
        <volume>5</volume>
        <issue>5</issue>
        <fpage>1103</fpage>
        <lpage>22</lpage>
        <pub-id pub-id-type="doi">10.1142/S0219720007003028</pub-id>
        <pub-id pub-id-type="pmid">17933013</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Prakash</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Tompa</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Measuring the accuracy of genome-size multiple alignments</article-title>
        <source>Genome Biol</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>6</issue>
        <fpage>R124</fpage>
        <pub-id pub-id-type="doi">10.1186/gb-2007-8-6-r124</pub-id>
        <pub-id pub-id-type="pmid">17594489</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Wang</surname>
          <given-names>AX</given-names>
        </name>
        <name>
          <surname>Ruzzo</surname>
          <given-names>WL</given-names>
        </name>
        <name>
          <surname>Tompa</surname>
          <given-names>M</given-names>
        </name>
        <article-title>How accurately is ncRNA aligned within whole-genome multiple alignments?</article-title>
        <source>BMC Bioinformatics</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>417</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-417</pub-id>
        <pub-id pub-id-type="pmid">17963514</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Kiryu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Kin</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Asai</surname>
          <given-names>K</given-names>
        </name>
        <article-title>Robust prediction of consensus secondary structures using averaged base pairing probability matrices</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <issue>4</issue>
        <fpage>434</fpage>
        <lpage>41</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl636</pub-id>
        <pub-id pub-id-type="pmid">17182698</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Torarinsson</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Sawera</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Havgaard</surname>
          <given-names>JH</given-names>
        </name>
        <name>
          <surname>Fredholm</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Gorodkin</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Thousands of corresponding human and mouse genomic regions unalignable in primary sequence contain common RNA structure</article-title>
        <source>Genome Res</source>
        <year>2006</year>
        <volume>16</volume>
        <issue>7</issue>
        <fpage>885</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.5226606</pub-id>
        <pub-id pub-id-type="pmid">16751343</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Torarinsson</surname>
          <given-names>E</given-names>
        </name>
        <name>
          <surname>Yao</surname>
          <given-names>Z</given-names>
        </name>
        <name>
          <surname>Wiklund</surname>
          <given-names>ED</given-names>
        </name>
        <name>
          <surname>Bramsen</surname>
          <given-names>JB</given-names>
        </name>
        <name>
          <surname>Hansen</surname>
          <given-names>C</given-names>
        </name>
        <name>
          <surname>Kjems</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Tommerup</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Ruzzo</surname>
          <given-names>WL</given-names>
        </name>
        <name>
          <surname>Gorodkin</surname>
          <given-names>J</given-names>
        </name>
        <article-title>Comparative genomics beyond sequence-based alignments: RNA structures in the ENCODE regions</article-title>
        <source>Genome Res</source>
        <year>2008</year>
        <volume>18</volume>
        <issue>2</issue>
        <fpage>242</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1101/gr.6887408</pub-id>
        <pub-id pub-id-type="pmid">18096747</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="other">
        <name>
          <surname>Kuhn</surname>
          <given-names>RM</given-names>
        </name>
        <name>
          <surname>Karolchik</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Zweig</surname>
          <given-names>AS</given-names>
        </name>
        <name>
          <surname>Wang</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Smith</surname>
          <given-names>KE</given-names>
        </name>
        <name>
          <surname>Rosenbloom</surname>
          <given-names>KR</given-names>
        </name>
        <name>
          <surname>Rhead</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Raney</surname>
          <given-names>BJ</given-names>
        </name>
        <name>
          <surname>Pohl</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Pheasant</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Meyer</surname>
          <given-names>L</given-names>
        </name>
        <name>
          <surname>Hsu</surname>
          <given-names>F</given-names>
        </name>
        <name>
          <surname>Hinrichs</surname>
          <given-names>AS</given-names>
        </name>
        <name>
          <surname>Harte</surname>
          <given-names>RA</given-names>
        </name>
        <name>
          <surname>Giardine</surname>
          <given-names>B</given-names>
        </name>
        <name>
          <surname>Fujita</surname>
          <given-names>P</given-names>
        </name>
        <name>
          <surname>Diekhans</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Dreszer</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Clawson</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Barber</surname>
          <given-names>GP</given-names>
        </name>
        <name>
          <surname>Haussler</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Kent</surname>
          <given-names>WJ</given-names>
        </name>
        <article-title>The UCSC Genome Browser Database: update 2009</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <issue>37 Database</issue>
        <fpage>D755</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn875</pub-id>
        <pub-id pub-id-type="pmid">18996895</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Morita</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Saito</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Sato</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Oka</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Hotta</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Sakakibara</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>Genome-wide searching with base-pairing kernel functions for noncoding RNAs: computational and expression analysis of snoRNA families in Caenorhabditis elegans</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <volume>37</volume>
        <issue>3</issue>
        <fpage>999</fpage>
        <lpage>1009</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn1054</pub-id>
        <pub-id pub-id-type="pmid">19129214</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Smith</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Waterman</surname>
          <given-names>M</given-names>
        </name>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bonhoeffer</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>McCaskill</surname>
          <given-names>JS</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>PF</given-names>
        </name>
        <name>
          <surname>Schuster</surname>
          <given-names>P</given-names>
        </name>
        <article-title>RNA multi-structure landscapes. A study based on temperature dependent partition functions</article-title>
        <source>Eur Biophys J</source>
        <year>1993</year>
        <volume>22</volume>
        <fpage>13</fpage>
        <lpage>24</lpage>
        <pub-id pub-id-type="doi">10.1007/BF00205808</pub-id>
        <pub-id pub-id-type="pmid">7685689</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="book">
        <name>
          <surname>Vapnik</surname>
          <given-names>VN</given-names>
        </name>
        <source>Statistical Learning Theory</source>
        <year>1998</year>
        <publisher-name>New York: Wiley</publisher-name>
      </mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Saigo</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Vert</surname>
          <given-names>JP</given-names>
        </name>
        <name>
          <surname>Ueda</surname>
          <given-names>N</given-names>
        </name>
        <name>
          <surname>Akutsu</surname>
          <given-names>T</given-names>
        </name>
        <article-title>Protein homology detection using string alignment kernels</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <issue>11</issue>
        <fpage>1682</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bth141</pub-id>
        <pub-id pub-id-type="pmid">14988126</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Dalli</surname>
          <given-names>D</given-names>
        </name>
        <name>
          <surname>Wilm</surname>
          <given-names>A</given-names>
        </name>
        <name>
          <surname>Mainz</surname>
          <given-names>I</given-names>
        </name>
        <name>
          <surname>Steger</surname>
          <given-names>G</given-names>
        </name>
        <article-title>STRAL: progressive alignment of non-coding RNA using base pairing probability vectors in quadratic time</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <issue>13</issue>
        <fpage>1593</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl142</pub-id>
        <pub-id pub-id-type="pmid">16613908</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hofacker</surname>
          <given-names>IL</given-names>
        </name>
        <article-title>Vienna RNA secondary structure server</article-title>
        <source>Nucleic Acids Res</source>
        <year>2003</year>
        <volume>31</volume>
        <issue>13</issue>
        <fpage>3429</fpage>
        <lpage>31</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkg599</pub-id>
        <pub-id pub-id-type="pmid">12824340</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Klein</surname>
          <given-names>RJ</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <article-title>RSEARCH: finding homologs of single structured RNA sequences</article-title>
        <source>BMC Bioinformatics</source>
        <year>2003</year>
        <volume>4</volume>
        <fpage>44</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-4-44</pub-id>
        <pub-id pub-id-type="pmid">14499004</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Hamada</surname>
          <given-names>M</given-names>
        </name>
        <name>
          <surname>Kiryu</surname>
          <given-names>H</given-names>
        </name>
        <name>
          <surname>Sato</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Mituyama</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Asai</surname>
          <given-names>K</given-names>
        </name>
        <article-title>Prediction of RNA secondary structure using generalized centroid estimators</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>4</issue>
        <fpage>465</fpage>
        <lpage>73</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn601</pub-id>
        <pub-id pub-id-type="pmid">19095700</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="other">
        <name>
          <surname>Gardner</surname>
          <given-names>PP</given-names>
        </name>
        <name>
          <surname>Daub</surname>
          <given-names>J</given-names>
        </name>
        <name>
          <surname>Tate</surname>
          <given-names>JG</given-names>
        </name>
        <name>
          <surname>Nawrocki</surname>
          <given-names>EP</given-names>
        </name>
        <name>
          <surname>Kolbe</surname>
          <given-names>DL</given-names>
        </name>
        <name>
          <surname>Lindgreen</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Wilkinson</surname>
          <given-names>AC</given-names>
        </name>
        <name>
          <surname>Finn</surname>
          <given-names>RD</given-names>
        </name>
        <name>
          <surname>Griffiths-Jones</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <name>
          <surname>Bateman</surname>
          <given-names>A</given-names>
        </name>
        <article-title>Rfam: updates to the RNA families database</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <issue>37 Database</issue>
        <fpage>D136</fpage>
        <lpage>40</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkn766</pub-id>
        <pub-id pub-id-type="pmid">18953034</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Do</surname>
          <given-names>CB</given-names>
        </name>
        <name>
          <surname>Foo</surname>
          <given-names>CS</given-names>
        </name>
        <name>
          <surname>Batzoglou</surname>
          <given-names>S</given-names>
        </name>
        <article-title>A max-margin model for efficient simultaneous alignment and folding of RNA sequences</article-title>
        <source>Bioinformatics</source>
        <year>2008</year>
        <volume>24</volume>
        <issue>13</issue>
        <fpage>i68</fpage>
        <lpage>i76</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btn177</pub-id>
        <pub-id pub-id-type="pmid">18586747</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Thompson</surname>
          <given-names>JD</given-names>
        </name>
        <name>
          <surname>Higgins</surname>
          <given-names>DG</given-names>
        </name>
        <name>
          <surname>Gibson</surname>
          <given-names>TJ</given-names>
        </name>
        <article-title>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>
        <source>Nucleic Acids Res</source>
        <year>1994</year>
        <volume>22</volume>
        <issue>22</issue>
        <fpage>4673</fpage>
        <lpage>80</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/22.22.4673</pub-id>
        <pub-id pub-id-type="pmid">7984417</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Gesell</surname>
          <given-names>T</given-names>
        </name>
        <name>
          <surname>Washietl</surname>
          <given-names>S</given-names>
        </name>
        <article-title>Dinucleotide controlled null models for comparative RNA gene prediction</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>248</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-248</pub-id>
        <pub-id pub-id-type="pmid">18505553</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Sato</surname>
          <given-names>K</given-names>
        </name>
        <name>
          <surname>Saito</surname>
          <given-names>Y</given-names>
        </name>
        <name>
          <surname>Sakakibara</surname>
          <given-names>Y</given-names>
        </name>
        <article-title>Gradient-based optimization of hyperparameters for base-pairing profile local alignment kernels</article-title>
        <source>Genome Inform</source>
        <year>2009</year>
        <volume>23</volume>
        <fpage>128</fpage>
        <lpage>138</lpage>
        <comment>full_text</comment>
        <pub-id pub-id-type="pmid">20180268</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Altschul</surname>
          <given-names>SF</given-names>
        </name>
        <name>
          <surname>Erickson</surname>
          <given-names>BW</given-names>
        </name>
        <article-title>Significance of nucleotide sequence alignments: a method for random sequence permutation that preserves dinucleotide and codon usage</article-title>
        <source>Mol Biol Evol</source>
        <year>1985</year>
        <volume>2</volume>
        <issue>6</issue>
        <fpage>526</fpage>
        <lpage>538</lpage>
        <pub-id pub-id-type="pmid">3870875</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <article-title>Profile hidden Markov models</article-title>
        <source>Bioinformatics</source>
        <year>1998</year>
        <volume>14</volume>
        <issue>9</issue>
        <fpage>755</fpage>
        <lpage>63</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/14.9.755</pub-id>
        <pub-id pub-id-type="pmid">9918945</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Nawrocki</surname>
          <given-names>EP</given-names>
        </name>
        <name>
          <surname>Kolbe</surname>
          <given-names>DL</given-names>
        </name>
        <name>
          <surname>Eddy</surname>
          <given-names>SR</given-names>
        </name>
        <article-title>Infernal 1.0: inference of RNA alignments</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>10</issue>
        <fpage>1335</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp157</pub-id>
        <pub-id pub-id-type="pmid">19307242</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Bernhart</surname>
          <given-names>SH</given-names>
        </name>
        <name>
          <surname>Hofacker</surname>
          <given-names>IL</given-names>
        </name>
        <name>
          <surname>Will</surname>
          <given-names>S</given-names>
        </name>
        <name>
          <surname>Gruber</surname>
          <given-names>AR</given-names>
        </name>
        <name>
          <surname>Stadler</surname>
          <given-names>PF</given-names>
        </name>
        <article-title>RNAalifold: improved consensus structure prediction for RNA alignments</article-title>
        <source>BMC Bioinformatics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>474</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-474</pub-id>
        <pub-id pub-id-type="pmid">19014431</pub-id>
      </mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal">
        <name>
          <surname>Fan</surname>
          <given-names>RE</given-names>
        </name>
        <name>
          <surname>Chen</surname>
          <given-names>PH</given-names>
        </name>
        <name>
          <surname>Lin</surname>
          <given-names>CJ</given-names>
        </name>
        <article-title>Working set selection using second order information for training support vector machines</article-title>
        <source>Journal of Machine Learning Research</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>1889</fpage>
        <lpage>918</lpage>
      </mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="book">
        <name>
          <surname>Pacheco</surname>
          <given-names>P</given-names>
        </name>
        <source>Parallel Programming with MPI</source>
        <year>1996</year>
        <publisher-name>San Francisco: Morgan Kaufmann</publisher-name>
      </mixed-citation>
    </ref>
  </ref-list>
</back>
