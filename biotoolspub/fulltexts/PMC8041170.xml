<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS One</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8041170</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-20-30121</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0249850</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
            <subj-group>
              <subject>Qubits</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Computing Systems</subject>
          <subj-group>
            <subject>Quantum Computing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Optimization</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Earth Sciences</subject>
        <subj-group>
          <subject>Geography</subject>
          <subj-group>
            <subject>Human Geography</subject>
            <subj-group>
              <subject>Urban Geography</subject>
              <subj-group>
                <subject>Cities</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Social Sciences</subject>
        <subj-group>
          <subject>Human Geography</subject>
          <subj-group>
            <subject>Urban Geography</subject>
            <subj-group>
              <subject>Cities</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and life sciences</subject>
        <subj-group>
          <subject>Biophysics</subject>
          <subj-group>
            <subject>Nucleic acid thermodynamics</subject>
            <subj-group>
              <subject>Genetic annealing</subject>
              <subj-group>
                <subject>DNA annealing</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical sciences</subject>
        <subj-group>
          <subject>Physics</subject>
          <subj-group>
            <subject>Biophysics</subject>
            <subj-group>
              <subject>Nucleic acid thermodynamics</subject>
              <subj-group>
                <subject>Genetic annealing</subject>
                <subj-group>
                  <subject>DNA annealing</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and life sciences</subject>
        <subj-group>
          <subject>Biochemistry</subject>
          <subj-group>
            <subject>Nucleic acids</subject>
            <subj-group>
              <subject>Nucleic acid thermodynamics</subject>
              <subj-group>
                <subject>Genetic annealing</subject>
                <subj-group>
                  <subject>DNA annealing</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Applied Mathematics</subject>
            <subj-group>
              <subject>Algorithms</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Simulation and Modeling</subject>
          <subj-group>
            <subject>Algorithms</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Chemistry</subject>
          <subj-group>
            <subject>Quantum Chemistry</subject>
            <subj-group>
              <subject>Ground State</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>QuASeR: Quantum Accelerated de novo DNA sequence reconstruction</article-title>
      <alt-title alt-title-type="running-head">QuASeR: Quantum Accelerated de novo DNA sequence reconstruction</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">https://orcid.org/0000-0002-3026-6892</contrib-id>
        <name>
          <surname>Sarkar</surname>
          <given-names>Aritra</given-names>
        </name>
        <role content-type="https://casrai.org/credit/">Conceptualization</role>
        <role content-type="https://casrai.org/credit/">Formal analysis</role>
        <role content-type="https://casrai.org/credit/">Investigation</role>
        <role content-type="https://casrai.org/credit/">Methodology</role>
        <role content-type="https://casrai.org/credit/">Project administration</role>
        <role content-type="https://casrai.org/credit/">Resources</role>
        <role content-type="https://casrai.org/credit/">Software</role>
        <role content-type="https://casrai.org/credit/">Validation</role>
        <role content-type="https://casrai.org/credit/">Visualization</role>
        <role content-type="https://casrai.org/credit/">Writing – original draft</role>
        <role content-type="https://casrai.org/credit/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Al-Ars</surname>
          <given-names>Zaid</given-names>
        </name>
        <role content-type="https://casrai.org/credit/">Conceptualization</role>
        <role content-type="https://casrai.org/credit/">Investigation</role>
        <role content-type="https://casrai.org/credit/">Methodology</role>
        <role content-type="https://casrai.org/credit/">Project administration</role>
        <role content-type="https://casrai.org/credit/">Resources</role>
        <role content-type="https://casrai.org/credit/">Supervision</role>
        <role content-type="https://casrai.org/credit/">Visualization</role>
        <role content-type="https://casrai.org/credit/">Writing – original draft</role>
        <role content-type="https://casrai.org/credit/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bertels</surname>
          <given-names>Koen</given-names>
        </name>
        <role content-type="https://casrai.org/credit/">Conceptualization</role>
        <role content-type="https://casrai.org/credit/">Investigation</role>
        <role content-type="https://casrai.org/credit/">Methodology</role>
        <role content-type="https://casrai.org/credit/">Project administration</role>
        <role content-type="https://casrai.org/credit/">Resources</role>
        <role content-type="https://casrai.org/credit/">Supervision</role>
        <role content-type="https://casrai.org/credit/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>Department of Quantum and Computer Engineering, Faculty of Electrical Engineering, Mathematics and Computer Science, Delft University of Technology, Delft, The Netherlands</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Department of Informatics Engineering, Faculty of Engineering, University of Porto, Porto, Portugal</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Kamal</surname>
          <given-names>Archana</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>University of Massachusetts Lowell, UNITED STATES</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>a.sarkar-3@tudelft.nl</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>4</month>
      <year>2021</year>
    </pub-date>
    <volume>16</volume>
    <issue>4</issue>
    <elocation-id>e0249850</elocation-id>
    <history>
      <date date-type="received">
        <day>24</day>
        <month>9</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>24</day>
        <month>3</month>
        <year>2021</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2021 Sarkar et al</copyright-statement>
      <copyright-year>2021</copyright-year>
      <copyright-holder>Sarkar et al</copyright-holder>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="pmc" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0249850.pdf"/>
    <abstract>
      <p>In this article, we present QuASeR, a reference-free DNA sequence reconstruction implementation via de novo assembly on both gate-based and quantum annealing platforms. This is the first time this important application in bioinformatics is modeled using quantum computation. Each one of the four steps of the implementation (TSP, QUBO, Hamiltonians and QAOA) is explained with a proof-of-concept example to target both the genomics research community and quantum application developers in a self-contained manner. The implementation and results on executing the algorithm from a set of DNA reads to a reconstructed sequence, on a gate-based quantum simulator, the D-Wave quantum annealing simulator and hardware are detailed. We also highlight the limitations of current classical simulation and available quantum hardware systems. The implementation is open-source and can be found on <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR">https://github.com/QE-Lab/QuASeR</ext-link>.</p>
    </abstract>
    <funding-group>
      <funding-statement>The author(s) received no specific funding for this work.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="9"/>
      <table-count count="0"/>
      <page-count count="23"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>The data underlying this study are publicly accessible at: <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR">https://github.com/QE-Lab/QuASeR</ext-link>.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>The data underlying this study are publicly accessible at: <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR">https://github.com/QE-Lab/QuASeR</ext-link>.</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>Understanding the genome of an organism reveals insights [<xref rid="pone.0249850.ref001" ref-type="bibr">1</xref>] with scientific and clinical significance like causes that drive cancer progression, intra-genomic processes influencing evolution, enhancing food quality and quantity from plants and animals. Genomics data is projected to become the largest producer of big data within the decade [<xref rid="pone.0249850.ref002" ref-type="bibr">2</xref>], eclipsing all other sources of information generation, including astronomical as well as social data. At the same time, genomics is expected to become an integral part of our daily life, providing insight and control over many of the processes taking place within our bodies and in our environment. An exciting prospect is personalized medicine [<xref rid="pone.0249850.ref003" ref-type="bibr">3</xref>], in which accurate diagnostics can identify patients who can benefit from precisely targeted therapies. Despite the continual development of tools to process genomic data, current approaches are yet to meet the requirements for large-scale clinical genomics. In this case, patient turnaround time, ease-of-use, robustness and running costs are critical. As the cost of whole-genome sequencing (WGS) continues to drop [<xref rid="pone.0249850.ref004" ref-type="bibr">4</xref>], more and more data is churned out creating a staggering computational demand. Therefore, efficient and cost-effective computational solutions are necessary to allow society to benefit from the potential positive impact of genomics. This paper provides more efficient solutions to the high computational demands in the field of genomics.</p>
    <p>The last decade in computer architecture has focused on the emergence of accelerators [<xref rid="pone.0249850.ref005" ref-type="bibr">5</xref>] as specialized processing units to which the host processor offloads suitable computational tasks. This is motivated by the various technological bottleneck (such as power use, frequency, memory access, level of parallelism) to increasing the computational capabilities of generic CPUs. Different accelerators, as shown in <xref ref-type="fig" rid="pone.0249850.g001">Fig 1</xref>, are chosen based on the their strengths that enable better execution of a particular type of logical manipulation. Commonly used accelerators today include field-programmable gate arrays (FPGA), graphics-processing units (GPU), neural processing units (NPU), digital signal processors (DSP), etc.</p>
    <fig id="pone.0249850.g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>The accelerator model of computing.</title>
      </caption>
      <graphic xlink:href="pone.0249850.g001"/>
    </fig>
    <p>An alternate computing paradigm that is receiving a lot of attention lately in computer architecture is quantum computing—which uses fundamental properties of quantum mechanics to achieve a computational advantage over classical computation. Within the next decade, it is likely that applications will be a hybrid combination of a classical computer and a quantum accelerator, with multiple computational kernels, than a universal quantum processing unit. As a holistic view we consider two classes of quantum accelerator [<xref rid="pone.0249850.ref006" ref-type="bibr">6</xref>] as additional co-processors. One is based on quantum gates and the second is based on quantum annealing. The classical host processor keeps the control over the total system and delegates the execution of certain parts to the available accelerators.</p>
    <p>In this paper, we propose an implementation of a DNA sequence reconstruction technique (called de novo assembly) on a quantum computing platform. De novo assembly using the overlap-layout-consensus method has many advantages over other simpler methods, but suffers from large computational complexity, which motivates targeting a quantum accelerator. We target both a gate-based quantum system as well as a quantum annealer. Each step of the formulation is explained with simple examples [<xref rid="pone.0249850.ref007" ref-type="bibr">7</xref>] to target both the genomics research community and quantum application developers. The implementation is evaluated on the D-Wave simulator, the D-Wave annealer in the cloud and the QX Simulator. The current limitations in solving real problem sizes to achieve a quantum advantage are discussed. It is the first time this important computational problem of de novo assembly in bioinformatics is targeted on a quantum accelerator with the full description of the pipeline.</p>
    <p>Recently [<xref rid="pone.0249850.ref008" ref-type="bibr">8</xref>], also discussed de novo sequencing on quantum annealing and quantum-inspired annealing, citing a preprint of our research as presented in this paper. We appreciate this research done independently to ours echoing a similar motivation to explore the applicability of quantum computing to DNA sequence reconstruction and reaching similar results. In contrast to their work, we additionally target the gate based quantum computing model, which is considered to be the future standard of quantum acceleration. Furthermore, this paper is presented from the perspective of a quantum application developer, with details from genomics, quantum and computer science formulated in a self-contained matter. In addition, an example is implemented via the various steps of the algorithm and the execution results are demonstrated as a proof-of-concept to evaluate the quality, scalability and limitations.</p>
    <p>This paper is organized as follows. In the section “DNA sequence reconstruction”, we introduce the specific problem of sequence reconstruction via de novo assembly using the overlap-layout-consensus approach. This is the target algorithm for which the quantum kernel is formulated. The section “Quantum accelerated optimization” first introduces the required technical background for the tools for formulating the de novo assembly problem, i.e. quantum accelerator, QUBO, TSP, Hamiltonians and the gate-based QAOA variational hybrid approach. In the section “Implementing de novo assembly”, the de novo assembly problem is mapped to a TSP and then the TSP is mapped to a QUBO. A small proof-of-concept example is detailed at each step. The section “Solving on a quantum system” systematically solves the QUBO formulation first on the D-Wave simulator and annealer system, and thereafter a QAOA on OpenQL is attempted. Then we discuss the limitations for scaling the formulation on real datasets using classical simulation and available quantum hardware systems. The “Conclusion” section concludes the paper.</p>
  </sec>
  <sec id="sec002">
    <title>DNA sequence reconstruction</title>
    <p>In order to sequence the DNA of an organism, DNA is broken down into fragments since DNA sequencing machines are not capable of reading the entire genome at once. Then these fragments are sequenced using modern sequencing technologies (such as Illumina), which produces reads of approximately 50-150 base pairs at a time, with some known error rate. To reconstruct the DNA from these fragments for further analysis, two different techniques are used (a) ab initio reference-based alignment of reads and (b) de novo reference-free assembly of reads. In our past research [<xref rid="pone.0249850.ref009" ref-type="bibr">9</xref>], we had implemented a quantum variants of reference-based alignment, while in this article, we focus on de novo assembly. Since the principles of quantum computation are fundamentally different, we will investigate the most basic algorithmic primitive for which the quantum kernel can be constructed. Thus, before presenting the corresponding quantum algorithm, the existing classical algorithms are reviewed here.</p>
    <sec id="sec003">
      <title>De novo reference-free assembly</title>
      <p>During sequencing, multiple copies of the DNA are made before fragmenting it. Thus, a portion of the data is preserved in multiple copies which are chopped off at different places resulting in data overlaps which facilitate stitching. This method is called de novo assembly, as no other data than the sequenced read is used for reconstruction. It is computationally expensive and done normally for the first time a new species is sequenced.</p>
      <p>There are different methods [<xref rid="pone.0249850.ref010" ref-type="bibr">10</xref>] for de novo assembly used by the available tools: Overlap-Layout-Consensus (OLC) methods, de Bruijn graph (DBG) methods, string graphs, greedy and hybrid algorithm, etc. Real-world WGS data induces various problems in all these methods. Examples are spurs (short, dead-end divergences from the main path), bubbles (paths that diverge then converge), frayed rope pattern (paths that converge then diverge) and cycles (paths that converge on themselves) [<xref rid="pone.0249850.ref011" ref-type="bibr">11</xref>]. Common causes of these complexities are attributed to repeats in the target and sequencing error in the reads. Most optimal graph reductions belong to the NP-hard class of problems, thus assemblers (like Euler, Velvet, ABySS, AllPaths, SOAPdenovo) rely on heuristics to remove redundancy, repair errors or otherwise simplify the graph. The choice of algorithms is based on the quality, quantity and structure of the genome data. Current short-read sequencing technologies produce very large numbers of reads favoring DBG methods. However, single molecule sequencing from third generation sequencing machines produces high-quality long reads, which could favor OLC methods.</p>
      <p>In DBG, the nodes represent all possible fixed-length strings of length K (K-mer graph). The edges represent fixed-length suffix-to-prefix perfect overlaps between sub-sequences that were consecutive in the larger sequence. In WGS assembly, the K-mer graph represents the input reads. Each read induces a path and those with perfect overlaps induce a common path as an advantage, however, compared to overlap graphs, K-mer graphs are more sensitive to repeats and sequencing errors as K is much less than read size. In an ideal construction, the Eulerian path corresponds to the original sequence, though graphs built from real sequencing data are more complicated.</p>
      <p>In the OLC method [<xref rid="pone.0249850.ref012" ref-type="bibr">12</xref>], as shown in <xref ref-type="fig" rid="pone.0249850.g002">Fig 2</xref>, an overlap graph represents the sequencing reads as nodes and their overlaps (pre-computed by pair-wise sequence alignments) as edges. Paths through the graph are the potential assembled DNA pieces and can be converted to sequence. Formally, this represents a Hamiltonian cycle, a path that travels to every node of the graph exactly once and ends at the starting node, including each read once in the assembly. There is no known efficient algorithm for finding a Hamiltonian cycle as it is in the NP-complete class. Though it was feasible for microbial genome (in 1995) and the human genome (in 2001), NGS projects have abandoned it due to the high computational burden to be commercially viable. This is the target for quantum acceleration in this research.</p>
      <fig id="pone.0249850.g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Overlap-layout-consensus genome assembly algorithm.</title>
        </caption>
        <graphic xlink:href="pone.0249850.g002"/>
      </fig>
    </sec>
  </sec>
  <sec id="sec004">
    <title>Quantum accelerated optimization</title>
    <p>The OLC method of de novo assembly requires solving the minimum Hamiltonian cycle problem. This is also famously known as the Traveling Salesman Problem (TSP), which belongs to the NP-hard class of computational complexity. Thus, we need to formulate it as an approximate optimization problem as even quantum computers cannot solve NP-hard problems in polynomial time.</p>
    <p>Mapping an NP-hard problem to quantum involves 2 steps as shown in <xref ref-type="fig" rid="pone.0249850.g003">Fig 3</xref>. The first step is to <italic>reduce</italic> the given application to a Quadratic Unconstrained Binary Optimization (QUBO). The second step is to <italic>embed</italic> the QUBO to the connectivity structure of the hardware.</p>
    <fig id="pone.0249850.g003" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g003</object-id>
      <label>Fig 3</label>
      <caption>
        <title>QUBO reduction from NP-hard problems.</title>
      </caption>
      <graphic xlink:href="pone.0249850.g003"/>
    </fig>
    <p>In this section, we first introduce the two models of quantum computation that we focus on: the gate-based circuit model and quantum annealing. Thereafter, we briefly review the formulation of a classical QUBO and TSP. Finally, we present the Hamiltonian formulation in adiabatic quantum computing, for optimization problems in quantum annealing and gate-based variational hybrid approach.</p>
    <sec id="sec005">
      <title>Quantum accelerator models</title>
      <p>There are several models of quantum computation. The theoretical models, like the quantum circuit model, adiabatic quantum computing, measurement-based (cluster state) quantum computation and topological quantum computing are equivalent to each other within polynomial time reduction.</p>
      <p>One of the most popular and by far the most extensively developed is the circuit model for gate-based quantum computation [<xref rid="pone.0249850.ref013" ref-type="bibr">13</xref>]. This is the conceptual generalization of Boolean logic gates (e.g. AND, OR, NOT, NAND, etc.) used for classical computation. The gate set for the quantum counterpart allows a richer diversity of states on the complex vector space (Hilbert space) formed by qubit registers. The quantum gates, by their unitary property, preserve the 2-norm of the amplitude of the states thereby undergoing a deterministic transformation of the probability distribution over bit strings. The power of quantum computation stems from this exponential state space evolving in superposition while interacting by interference of the amplitudes. Gate-based quantum algorithms are designed such that the solution states interfere constructively while the non-solutions interfere destructively, biasing the final probability distribution in favor of reading out the solution(s).</p>
      <p>Another common type of a quantum system is a quantum annealer. Quantum annealing is connected to the adiabatic quantum computing paradigm [<xref rid="pone.0249850.ref014" ref-type="bibr">14</xref>], although there are subtle differences. While the circuit model was inspired by Boolean logic circuits, quantum annealing was inspired by the metallurgical process of annealing where by virtue of thermal fluctuations, the material is able to explore more favorable parameters (e.g. crystal size) by thermally jumping over barriers in the parameter space. By imparting heat (energy), the solution parameters (like a ball) can climb a local minima (like a mountain and discover a deeper valley on the other side). Quantum annealing uses quantum fluctuations instead to tunnel through high but thin barriers in the target function. If the parameter landscape have these specific kind of barriers it can translate to a computational speedup in finding the minimum (ground state) of the function.</p>
      <p>The technique to formulate a problem and program the corresponding computing model is considerably different. This is presented in the next sections.</p>
    </sec>
    <sec id="sec006">
      <title>Quadratic unconstrained binary optimization</title>
      <p>A binary quadratic model (BQM) comprises a collection of binary-valued variables that can be assigned two chosen values (based on the model) with associated linear and quadratic biases. Two isomorphic BQM are:
<list list-type="bullet"><list-item><p>QUBO models: <italic>x</italic><sub><italic>i</italic></sub> ∈ {0, 1} Boolean values
<disp-formula id="pone.0249850.e001"><alternatives><graphic xlink:href="pone.0249850.e001.jpg" id="pone.0249850.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p></list-item><list-item><p>Ising models: <italic>σ</italic><sub><italic>i</italic></sub> ∈ {−1, + 1} spin states
<disp-formula id="pone.0249850.e002"><alternatives><graphic xlink:href="pone.0249850.e002.jpg" id="pone.0249850.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>σ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>μ</mml:mi><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msub><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>J</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>σ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p></list-item></list></p>
      <p>The choice of model depends on the problem. Using QUBO, it might be easier to write numbers in standard binary notation (e.g. 101<sub>2</sub> = 5<sub>10</sub>) in the optimization problem; or it might be required to destructively interfere two variable (e.g. two battling Pokemons) using the Ising model. Quantum processors like annealers use the Ising model, thus QUBO equations need to be converted into Ising under the hood.</p>
      <p>QUBO model [<xref rid="pone.0249850.ref015" ref-type="bibr">15</xref>, <xref rid="pone.0249850.ref016" ref-type="bibr">16</xref>] unifies a rich variety of combinatorial optimization problems as an alternative to traditional modeling and solution methodologies. These problems are concerned with making wise choices in settings where a large number of yes/no decisions must be made and each set of decisions yields a corresponding objective function value—like a cost or profit value. The QUBO model is expressed by the optimization problem:
<disp-formula id="pone.0249850.e003"><alternatives><graphic xlink:href="pone.0249850.e003.jpg" id="pone.0249850.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext mathvariant="monospace">minimize</mml:mtext><mml:mspace width="4pt"/><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>x</mml:mi><mml:mi>t</mml:mi></mml:msup><mml:mi>Q</mml:mi><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where <italic>x</italic> is a vector of binary decision variables and <italic>Q</italic> is a (symmetric or in upper triangular) square matrix of constants.</p>
      <p>Different types of constraining relationships arising in practice can be embodied within the unconstrained QUBO formulation using penalty functions. The penalties introduced are chosen so that the influence of the original constraints on the solution process can alternatively be achieved by the natural functioning of the optimizer as it looks for solutions that avoid incurring the penalties. Penalties are not unique, meaning that many different values can be successfully employed. For a particular problem, a workable value is typically set, based on domain knowledge and on what needs to be accomplished. If a constraint must be satisfied, i.e., a “hard” constraint, then the penalty must be large enough to preclude a violation. More moderate penalties are set for “soft” constraints, meaning that it is desirable to satisfy them but slight violations can be tolerated. Casting the QUBO model as a minimization problem permits a maximization problem to be solved by minimizing the negative of its objective function.</p>
      <p>QUBO models belong to the NP-hard class of problems. Thus exact solvers (e.g. CPLEX, Gurobi) work practically only for very small problem instances (around 100 variables) using mostly branch-and-bound or problem-specific techniques. However, impressive successes are being achieved by using meta-heuristic methods that are designed to find high quality but not necessarily optimal solutions in a modest amount of computer time. Among the best meta-heuristic methods for QUBO are those based on tabu search, path relinking, simulated annealing, genetic/memetic strategies, and their ensembles. Recently, with the availability of small-scale quantum processors, there is a huge research thrust in achieving quantum advantage for QUBO models.</p>
    </sec>
    <sec id="sec007">
      <title>Traveling salesman problem</title>
      <p>A Hamiltonian path is a graph path between two vertices of a graph that visits each vertex exactly once. If a Hamiltonian path exists whose endpoints are adjacent, then the resulting graph cycle is called a Hamiltonian cycle. It is a path that starts from one node and ends at the same node covering all the nodes of that graph.</p>
      <p>Given a directed complete graph <italic>G</italic> = (<italic>V</italic>, <italic>E</italic>) with weights <italic>w</italic><sub><italic>ij</italic></sub> on the directed edge <italic>i</italic> → <italic>j</italic>, the directed traveling salesman problem (TSP) aims to find a directed Hamiltonian cycle of minimum weight, i.e., a cycle that visits all nodes (cities) of the graph and such that the sum of the edge weights (travel cost) is minimum. Intuitively, given the ordered pair-wise distance between cities, the TSP involves finding the shortest route that visits every city once. The order of visiting the cities are not constrained.</p>
      <p>TSP falls under the NP-hard class (thus outside BQP), so the time to find the exact solution scales exponentially also on a quantum computer with the problem size. Often a good sub-optimal solution is admissible, thus heuristic algorithms of much lesser complexity can be employed. TSP solvers are used in many industrial applications in the domains of planning, scheduling, logistics, packing, DNA sequencing, network protocols, telescope control, VLSI testing, and many more.</p>
      <p>The first step to specifying a TSP is to create a (weighted) graph specifying the edges in the format (vertex-from; vertex-to; weight). Next, the TSP graph is transformed into a QUBO graph. QUBO variables are labeled (<italic>n</italic>, <italic>t</italic>) where <italic>n</italic> is a node (read) in the TSP graph and <italic>t</italic> is the time index of visiting it in order. E.g., if (<italic>a</italic>, 0) = 1 in the solution state, that means the node <italic>a</italic> is visited first. Since the total number of visits (time IDs) equals the total number of nodes (read IDs); the total possible combinations of (<italic>n</italic>, <italic>t</italic>) is |<italic>G</italic>|<sup>2</sup>. |<italic>G</italic>| is the number of nodes in the original TSP graph.</p>
      <p>The QUBO graph will have 2 * |<italic>G</italic>|<sup>2</sup> * (|<italic>G</italic>| − 1) interactions (or edges). The interactions denote pairs of 2 nodes that can/cannot coexist. The weight of the interaction shows the reward/penalty of coexisting. A higher positive value denotes more penalty. There are 3 types of penalty, for multi-location (being at 2 places at the same time), repetition (being at a city twice) and path cost for the tour.</p>
    </sec>
    <sec id="sec008">
      <title>Hamiltonian formulation</title>
      <p>In physical systems (classical or quantum), a Hamiltonian describes the energy of an object. More specifically, it describes the time-evolution of a system expressed by the Schrödinger equation:
<disp-formula id="pone.0249850.e004"><alternatives><graphic xlink:href="pone.0249850.e004.jpg" id="pone.0249850.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>i</mml:mi><mml:mi>ħ</mml:mi><mml:mfrac><mml:mi>d</mml:mi><mml:mrow><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>⟩</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi>H</mml:mi><mml:mo>|</mml:mo><mml:mi>ψ</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>⟩</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
The unitary operator underlying the Hamiltonian is obtained by solving the equation for some time duration:<italic>U</italic> = exp(−<italic>iHt</italic>/ℏ). The time-independent formulation of the equation reflects the total energy of the system <italic>E</italic> = <italic>H</italic>|<italic>ψ</italic>〉.</p>
      <p>The adiabatic theorem dictates that if the change in the time-dependent Hamiltonian occurs slowly, the resulting dynamics remain simple, i.e. starting close to an eigenstate, the system remains close to an eigenstate. For a quantum mechanical system, some initial Hamiltonian <italic>H</italic><sub><italic>i</italic></sub> is slowly changed to some other final Hamiltonian <italic>H</italic><sub><italic>f</italic></sub>. This implies that, if the system is started in the ground state (lowest eigenstate) of the initial Hamiltonian, the system will evolve to the ground state of the final configuration. The computational advantage comes from the choice of an easy-to-prepare quantum system like:
<disp-formula id="pone.0249850.e005"><alternatives><graphic xlink:href="pone.0249850.e005.jpg" id="pone.0249850.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>X</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
(the ground state is the equal superposition state) and evolve the Hamiltonian to a system such that the ground state encodes the solution of the optimization problem we are interested in.</p>
      <p>The change needs to be carried out by a defined schedule, for example, linear in the time scale <italic>t</italic> ∈ [0, 1] defined as:
<disp-formula id="pone.0249850.e006"><alternatives><graphic xlink:href="pone.0249850.e006.jpg" id="pone.0249850.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>t</mml:mi><mml:msub><mml:mi>H</mml:mi><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
The energy difference between the ground state and the first excited state is called the gap, Δ(<italic>t</italic>). If <italic>H</italic>(<italic>t</italic>) has a finite gap for each <italic>t</italic> during the transition the system can be evolved adiabatically with the evolution speed proportional to 1/min(Δ(<italic>t</italic>))<sup>2</sup>. The gap, however, is highly problem-dependent, tending to have an exponentially small gap for hard problems (like those in the NP-hard class), making the time exponentially long. Thus it is unlikely that an exact solution for these problems can be found in polynomial time.</p>
      <p>In adiabatic quantum computations, universal calculations are performed by mapping the problem to a final Hamiltonian defined as:
<disp-formula id="pone.0249850.e007"><alternatives><graphic xlink:href="pone.0249850.e007.jpg" id="pone.0249850.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>f</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>&gt;</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>J</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>Z</mml:mi></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>j</mml:mi><mml:mi>Z</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msub><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>Z</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>&gt;</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>X</mml:mi></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>j</mml:mi><mml:mi>X</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>Thus the system Hamiltonian <italic>H</italic>(<italic>t</italic>) becomes:
<disp-formula id="pone.0249850.e008"><alternatives><graphic xlink:href="pone.0249850.e008.jpg" id="pone.0249850.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>H</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>[</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>X</mml:mi></mml:msubsup><mml:mo>]</mml:mo><mml:mo>+</mml:mo><mml:mi>t</mml:mi><mml:mo>[</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>&gt;</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>J</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>Z</mml:mi></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>j</mml:mi><mml:mi>Z</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mi>i</mml:mi></mml:munder><mml:msub><mml:mi>h</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>Z</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>&gt;</mml:mo></mml:mrow></mml:munder><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>i</mml:mi><mml:mi>X</mml:mi></mml:msubsup><mml:msubsup><mml:mi>σ</mml:mi><mml:mi>j</mml:mi><mml:mi>X</mml:mi></mml:msubsup><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>The values of biases and couplings are set by the user/programmer for a quantum annealer.</p>
      <p>The major drawback to implementing an adiabatic quantum computing directly is calculating the speed limit, which is harder than solving the original problem of finding the ground state of a Hamiltonian. Quantum annealing [<xref rid="pone.0249850.ref017" ref-type="bibr">17</xref>] drops the strict requirements of respecting speed limits in favor of repeating the transition multiple times. Sampling from the solutions is likely to find the lowest energy state of the final Hamiltonian (though there is no theoretical guarantee). Going from ‘nearly correct’ to ‘correct’ is still NP in general if the original problem is in the NP class of complexity (the parameters for local optima aren’t necessarily going to be distributed anywhere near the global optima). However, annealing can be useful if a sub-optimal solution is acceptable for the application.</p>
    </sec>
    <sec id="sec009">
      <title>Variational hybrid approach</title>
      <p>Coherent quantum protocols have promising exponential speedups but assume a fault-tolerant quantum computing platform, with high quality of qubits, a large number of gates and circuit width. These popular algorithms like Shor’s factorization, HHL for matrix inversion, though primitives for many quantum algorithms are not of immediate practical relevance. Wrapping these protocols in state preparation (from classical data to quantum) and state tomography (from quantum probability amplitudes of final state to classical statistics) can overrule the entire speedup achieved by the protocol itself.</p>
      <p>Today, we are in the Noisy Intermediate-Scale Quantum (NISQ) era. These near-term quantum computers are more suited for hybrid quantum-classical (HQC) algorithms [<xref rid="pone.0249850.ref018" ref-type="bibr">18</xref>]. These are heuristic protocols based on the variational principle. In an HQC algorithm, all the power of the quantum computer is used for preparing a quantum state. The complexity of the algorithm is traded-off for multiple measurements over multiple cycles. The operations that require lots of gates on a quantum computer are offloaded to the classical computer (e.g. optimization, addition, division), which controls the quantum computer like an accelerator or a co-processor, as shown in <xref ref-type="fig" rid="pone.0249850.g004">Fig 4</xref>. A quantum circuit is defined as having a certain format <italic>A</italic> (or ansatz/stencil) with parameters. There are <italic>m</italic> parameters forming a parameter vector Λ<sub><italic>m</italic></sub>. These can be initialized randomly or with a classical guess. For the first cycle, the quantum computer takes the initial guess and evolves it using the circuit <inline-formula id="pone.0249850.e009"><alternatives><graphic xlink:href="pone.0249850.e009.jpg" id="pone.0249850.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:mrow><mml:mi>A</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mo>Λ</mml:mo><mml:mi>m</mml:mi><mml:mn>0</mml:mn></mml:msubsup><mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The Hamiltonian (energy) is measured out and sent to the classical computer. The variational principle updates the parameters in such a way that the energy of the Hamiltonian is lowered in each successive iteration. The optimization using <inline-formula id="pone.0249850.e010"><alternatives><graphic xlink:href="pone.0249850.e010.jpg" id="pone.0249850.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:mrow><mml:msubsup><mml:mo>Λ</mml:mo><mml:mi>m</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mo>Λ</mml:mo><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mo>Λ</mml:mo><mml:mi>m</mml:mi><mml:mn>3</mml:mn></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> continues until the acceptable threshold is satisfied, very similar to training in neural networks.</p>
      <fig id="pone.0249850.g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g004</object-id>
        <label>Fig 4</label>
        <caption>
          <title>Variational hybrid quantum-classical approach for optimization.</title>
        </caption>
        <graphic xlink:href="pone.0249850.g004"/>
      </fig>
      <p>The variational principle forms the core theoretical basis behind the working of near-term quantum heuristic algorithms. It states that, for a trial wave-function (defining the family of quantum states reachable by varying the <italic>m</italic> parameters of <italic>A</italic>),
<disp-formula id="pone.0249850.e011"><alternatives><graphic xlink:href="pone.0249850.e011.jpg" id="pone.0249850.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:msub><mml:mo>Ψ</mml:mo><mml:mi>T</mml:mi></mml:msub></mml:msub><mml:mo>=</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mo>Ψ</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mo>Λ</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>Q</mml:mi><mml:mi>C</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mo>Ψ</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mo>Λ</mml:mo><mml:mo>)</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mo>〈</mml:mo><mml:msub><mml:mo>Ψ</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mo>Λ</mml:mo><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mo>Ψ</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mo>Λ</mml:mo><mml:mo>)</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>≥</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
The normalization term 〈Ψ<sub><italic>T</italic></sub>(Λ)|Ψ<sub><italic>T</italic></sub>(Λ)〉 = 1 as we assume no leakage errors from the computational basis. Thus, it is possible to reach the ground-state energy by finding the right parameters. The more free the state is to represent quantum states (determined by the choice of <italic>A</italic>), the better it will be able to lower the energy.</p>
      <p>Since adiabatic and gate systems offer effectively the same potential for achieving the gains inherent in quantum computing processes, analogous advances associated with QUBO models may ultimately be realized through quantum circuit systems as well.</p>
      <p>An example of HQC algorithms is the Quantum Approximate Optimization Algorithm (QAOA) [<xref rid="pone.0249850.ref019" ref-type="bibr">19</xref>]. It is a hybrid variational algorithm that produces approximate solutions for combinatorial optimization problems. In theory, QAOA methods can be applied to more types of combinatorial optimization problems than embraced by the QUBO model [<xref rid="pone.0249850.ref016" ref-type="bibr">16</xref>]. The parameters of the QAOA framework must be modified to produce different algorithms to appropriately handle different problem types. QAOA is a polynomial-time HQC algorithm which can be seen as the Trotterization of an infinite time adiabatic algorithm. Since the AQC always gives the optimal solution for Hamiltonians with a non-zero gap, QAOA for infinite cycles also converges to the global optima.</p>
      <p>The generalization of QAOA called the Quantum Alternating Operator Ansatz [<xref rid="pone.0249850.ref020" ref-type="bibr">20</xref>], consists of 2 Hamiltonians: a cost/problem Hamiltonian <italic>H</italic><sub><italic>C</italic></sub> (similar to the transverse field in AQC) and a driver/mixing Hamiltonian <italic>H</italic><sub><italic>M</italic></sub> (similar to the longitudinal field in AQC). This is repeated over <italic>p</italic> cycles with each Hamiltonian parameterized by the <italic>γ</italic> and <italic>β</italic> real values (rotation angles similar to the adiabatic evolution time). After this unitary evolution, the state is measured for the expectation value with respect to the ground state of the cost Hamiltonian. The initial state |<italic>ψ</italic><sub>0</sub>〉 depends on the problem (typically either the all-zero or the equal superposition state).
<disp-formula id="pone.0249850.e012"><alternatives><graphic xlink:href="pone.0249850.e012.jpg" id="pone.0249850.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mi>U</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>〉</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>…</mml:mo><mml:msub><mml:mi>H</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>M</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>ψ</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo>〉</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>For an optimization instance, the user specifies the driver Hamiltonian ansatz, cost Hamiltonian ansatz, and the approximation order (cycles) of the algorithm. If the number of cycles in QAOA increases, theoretically, the sub-optimal solutions obtained can only get better, as the sub-optimal solutions defined by fewer cycles (with fewer free parameters) are always contained in more cycles (if the new rotation parameters are set to zero). However, practically, having more cycles causes difficulty for the classical optimizer to deal with more free parameters and can affect the convergence.</p>
      <p>Since HQC trades off the decoherence issue of a long quantum circuit in the NISQ era with multiple low-depth, the number of repetitions required is high. To estimate the expectation of the prepared state in each optimization step, it needs to be (pre-rotated in the basis and) measured with respect to each Pauli term in the problem Hamiltonian and aggregated. Each Pauli term measurement in turn requires state tomographic trials.</p>
      <p>Moreover, the optimizer might get stuck in local optima or barren plateaus [<xref rid="pone.0249850.ref021" ref-type="bibr">21</xref>] in the parameter landscape, requiring a few reruns to build confidence in the obtained optima. The HQC algorithms depend a lot on the choice of the classical optimizer as well. Here we experiment with the basic Nelder-Mead gradient-free optimizer, but many gradient-based and gradient-free choices exist (for example in libraries like SciPy in Python and TOMLAB in MATLAB) which needs to be chosen based on empirical testing of a particular formulation of the specific problem.</p>
      <p>The pseudo-code for our OpenQL implementation of the QAOA algorithm is shown in <xref ref-type="boxed-text" rid="pone.0249850.box001">Box 1</xref>.</p>
      <boxed-text id="pone.0249850.box001" position="float" orientation="portrait">
        <sec id="sec010">
          <title>Box 1. Pseudo-code for OpenQL QAOA.</title>
          <p>• Invoke QAOA:</p>
          <p> ◊ Form parameterized cQasm [Input: reference circuit, ansatz, steps, coefficients, angle ids]</p>
          <p> ◊ Form parameters list [Input: gammas, betas]</p>
          <p> ◊ Set runtime deparameterized cQasm filename</p>
          <p> ◊ For each iteration:</p>
          <p>  ⋆ For each Pauli product term in cost Hamiltonian (wsopp):</p>
          <p>   ∘ Deparameterize cQasm [Input: parameterized QASM, parameter list]</p>
          <p>   ∘ Add measurement basis rotation based on Pauli product term</p>
          <p>   ∘ Invoke Qxelerator to aggregate measurement over shots</p>
          <p>  ⋆ Calculate total Expectation value of trail state in cost Hamiltonian basis</p>
          <p>  ⋆ Return value to optimizer. Save intermediate results via callback.</p>
          <p>  ⋆ Classical optimizer updates parameter list</p>
          <p> ◊ Display cost function convergence, final parameters and optimized cost</p>
        </sec>
      </boxed-text>
    </sec>
  </sec>
  <sec id="sec011">
    <title>Implementing de novo assembly</title>
    <p>In this section, first, we present a mapping from DNA to TSP, as common in the OLC method. Then the TSP is converted to a QUBO. A fully worked out example is presented as a proof-of-concept for quantum accelerated sequence reconstruction. The example is chosen based on the limit of currently available quantum computing hardware and classical simulators, however, the formulation and implementation is generic and scalable to industrial scale pipelines.</p>
    <sec id="sec012">
      <title>DNA reads to TSP formulation</title>
      <p>Suppose the sequencer produces reads of size 10 nucleotide bases and after removing duplicates, the reads obtained are:</p>
      <p>read 0: ATGGCGTGCA</p>
      <p>read 1: GCGTGCAATG</p>
      <p>read 2: TGCAATGGCG</p>
      <p>read 3: AATGGCGTGC</p>
      <p>The pairwise overlap is calculated for each ordered pair based on how many prefix characters of the second string match exactly with the suffix of the first string. The edge weight is set to the negation of the overlap, as the constraints need to be formulated such that the path that <italic>minimizes the overlap</italic> is found.</p>
      <p>The edge weights are {<italic>(0,1):-7, (1,2):-7, (2,3):-7, (3,0):-9, (1,0):-3, (2,1):-3, (3,2):-3, (0,3):-1, (0,2):-4, (1,3):-4, (2,0):-6, (3,1):-6</italic>}</p>
      <p>The overlap depends on the ordering of the read pairs and thus this formulation is a directed graph. There are 6 possible unique tours (choosing a different starting city in the tour is equivalent in cost). Note that the reads are spliced from an original circular DNA, so the final stitched DNA solutions for all these tours are repeats of <italic>read 0</italic> of variable length. Such cases occur in practice when arranging the reads in different ways gives different repeat lengths. The tours are emulated in <xref ref-type="fig" rid="pone.0249850.g005">Fig 5</xref>. The TSP solution is expected to find the lowest cost (and shortest assembly) tour, i.e. Type-A. There are 4 acceptable solutions (based on starting node) of Type-A:
<list list-type="bullet"><list-item><p>(0 → 1 → 2 → 3 → 0)</p></list-item><list-item><p>(1 → 2 → 3 → 0 → 1)</p></list-item><list-item><p>(2 → 3 → 0 → 1 → 2)</p></list-item><list-item><p>(3 → 0 → 1 → 2 → 3)</p></list-item></list></p>
      <fig id="pone.0249850.g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g005</object-id>
        <label>Fig 5</label>
        <caption>
          <title>All possible TSP tours for given example.</title>
        </caption>
        <graphic xlink:href="pone.0249850.g005"/>
      </fig>
      <p>This process is automated in the classical pre-processing <monospace>align</monospace> and <monospace>reads_to_tspAdjM</monospace> functions in <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py">https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py</ext-link>. It can be invoked as</p>
      <p>1 reads = [‘ATGGCGTGCA’, ‘GCGTGCAATG’, ‘TGCAATGGCG’, ‘AATGGCGTGC’]</p>
      <p>2 tspAdjM = reads_to_tspAdjM (reads)</p>
    </sec>
    <sec id="sec013">
      <title>TSP to QUBO model</title>
      <p>Next, the directed TSP is encoded as a QUBO model. Let <italic>n</italic> = |<italic>V</italic>| = 4 be the number of nodes. This formulation [<xref rid="pone.0249850.ref022" ref-type="bibr">22</xref>] requires <italic>n</italic><sup>2</sup> = 16 binary variables as qubits, so it scales quadratically rather than linearly in the problem size. For <italic>i</italic>, <italic>p</italic> ∈ {0…(<italic>n</italic> − 1)}, let <italic>x</italic><sub><italic>i</italic>,<italic>p</italic></sub> be True if node <italic>i</italic> appears in position <italic>p</italic> in the cycle, False otherwise.</p>
      <p>To derive a Hamiltonian for this problem, we penalize the violation of the constraints in the objective function inserting terms of the form <inline-formula id="pone.0249850.e013"><alternatives><graphic xlink:href="pone.0249850.e013.jpg" id="pone.0249850.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mrow><mml:mi>α</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, where the penalty term is sufficiently large, e.g., <italic>α</italic> = <italic>n</italic> * <italic>max</italic><sub>(<italic>i</italic>, <italic>j</italic>)∈<italic>E</italic></sub>
<italic>w</italic><sub><italic>ij</italic></sub>. The TSP can be formulated as:
<disp-formula id="pone.0249850.e014"><alternatives><graphic xlink:href="pone.0249850.e014.jpg" id="pone.0249850.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>The interactions are shown in <xref ref-type="fig" rid="pone.0249850.g006">Fig 6</xref> and are categorized as:
<list list-type="order"><list-item><p>Every node must be assigned. Thus self-interactions have large negative weight (favorable bias). Since there are no preferred order of the route, for each time slot, the value is the same (top-left blue interactions).</p></list-item><list-item><p>Same node assigned to two different time slots incurs a penalty (top-middle violet interactions). Thus, for each node, there should be only one assigned time slot:
<disp-formula id="pone.0249850.e015"><alternatives><graphic xlink:href="pone.0249850.e015.jpg" id="pone.0249850.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p></list-item><list-item><p>Same time slot assigned to two different nodes incurs a penalty (top-right violet interactions). Thus, for each time slot, there should be only one assigned node:
<disp-formula id="pone.0249850.e016"><alternatives><graphic xlink:href="pone.0249850.e016.jpg" id="pone.0249850.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>∀</mml:mo><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mo>,</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p></list-item><list-item><p>The additional cost of including an edge in the route to two consecutive time slots is the weight of the edge in the TSP. These 6 graphs show the 4 possible routes for each of the 6 types (type A in middle-left green, others in red). Each edge (<italic>i</italic>, <italic>j</italic>) is taken and all possible configurations of assigning them next to each other are tried (the addition being modulo <italic>n</italic>), with the edge weight being the cost of choosing from those configurations. Thus, given the above constraints:
<disp-formula id="pone.0249850.e017"><alternatives><graphic xlink:href="pone.0249850.e017.jpg" id="pone.0249850.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext mathvariant="monospace">minimize</mml:mtext><mml:mo>:</mml:mo><mml:mspace width="4pt"/><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p></list-item></list></p>
      <fig id="pone.0249850.g006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g006</object-id>
        <label>Fig 6</label>
        <caption>
          <title>QUBO interactions.</title>
        </caption>
        <graphic xlink:href="pone.0249850.g006"/>
      </fig>
      <p>These arrows can be made into an adjacency matrix for the graph, resulting in the Q-matrix as shown in <xref ref-type="fig" rid="pone.0249850.g007">Fig 7</xref> (with the colors of the cells representing the terms from the corresponding colored arrows). The addition of these 6 matrices gives the <italic>Q</italic> matrix for the QUBO. Note that, if we have only the lower 6 matrices (coupling), the all 1’s assignment is the most favorable and gives the minimum solution to the QUBO equation <italic>y</italic> = <italic>x</italic><sup><italic>T</italic></sup>
<italic>Qx</italic>. Thus, we need to add the reward for assigning a node {<italic>a</italic>} and penalties {<italic>b</italic>, <italic>c</italic>} for assigning the same node to multiple different time slots, or same time slots to multiple nodes, respectively. Since these are bi-directional arrows, these can be symmetric.</p>
      <fig id="pone.0249850.g007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g007</object-id>
        <label>Fig 7</label>
        <caption>
          <title>Q-matrix for de novo example.</title>
        </caption>
        <graphic xlink:href="pone.0249850.g007"/>
      </fig>
      <p>For our experiment, we empirically found that setting a penalty value of <italic>b</italic> = <italic>c</italic> ≥ 13 is sufficient, and the reward <italic>a</italic> = 0 still finds the 4 favorable minima of Type A. It is easy to verify that a minimum value of <italic>y</italic> = <italic>x</italic><sup><italic>T</italic></sup>
<italic>Qx</italic> is obtained for:
<list list-type="bullet"><list-item><p><italic>x</italic><sup><italic>T</italic></sup> = [1000010000100001]</p></list-item><list-item><p><italic>x</italic><sup><italic>T</italic></sup> = [0100001000011000]</p></list-item><list-item><p><italic>x</italic><sup><italic>T</italic></sup> = [0010000110000100]</p></list-item><list-item><p><italic>x</italic><sup><italic>T</italic></sup> = [0001100001000010]</p></list-item></list></p>
      <p specific-use="continuation">for the binary encoding
<disp-formula id="pone.0249850.e018"><alternatives><graphic xlink:href="pone.0249850.e018.jpg" id="pone.0249850.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>x</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mrow><mml:mo>=</mml:mo><mml:mo>[</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>The process of generating the Q matrix is automated in the function <monospace>tspAdjM_to_quboAdjM</monospace> in <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py">‥/denovo_009.py</ext-link>. It can be invoked with the adjacency matrix from the <monospace>reads_to_tspAdjM</monospace> function as</p>
      <p>1 #Parameters: adj matrix, self–bias, multi − location, repetation</p>
      <p>2 quboAdjM = tspAdjM_to_quboAdjM (tspAdjM, 0, 13, 13)</p>
    </sec>
  </sec>
  <sec id="sec014">
    <title>Solving on a quantum system</title>
    <p>In this section, we show how to solve the QUBO on both a quantum annealer (D-Wave Ocean tools) and a gate-based optimizer (QX/OpenQL) using QAOA.</p>
    <sec id="sec015">
      <title>QUBO using quantum annealing</title>
      <p>The QUBO is mapped to a quantum annealer using the biases and couplings in the Ising model. A bias value is defined for each qubit and a coupling for each pair of qubits. In the graph view, each node (bias) and each edge (coupling) can have a real-number value (weight). Since this example requires 16 QUBO variables (qubits), the exact solver is used to better understand the output.</p>
      <p>For the de novo example, the Q matrix from (with <italic>a</italic> = 0, <italic>b</italic> = <italic>c</italic> = 13) is shown in <xref ref-type="fig" rid="pone.0249850.g007">Fig 7</xref>.</p>
      <p>The Q matrix is converted to a dictionary of node names and reward/penalty for biases and couplings. Then the QUBO solver is used to solve the Q matrix using the assignment of {0, 1} (instead of the Ising {−1, + 1}). This is coded in the <monospace>quboAdjM_to_quboDict</monospace> and <monospace>solve_qubo_exact</monospace> functions in <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py">‥/denovo_009.py</ext-link>. It can be invoked with the qubo adjacency matrix from the <monospace>tspAdjM_to_quboAdjM</monospace> function as</p>
      <p>1 Q = quboAdjM_to_quboDict (Q_matrix)</p>
      <p>2 solve_qubo_exact (Q)</p>
      <p>We find that there are 4 minimum solutions (the 4 Type A solutions). This matches with the expected analytical results.</p>
      <p>Though the QUBO solution now works on D-Wave’s solver, it needs to be converted to the Ising model for it to run on the D-Wave Quantum Annealer. This can be done using the qubo_to_ising function in D-Wave’s toolset, which maps the definitions of binary variables to an Ising model defined on spins (variables with -1, +1 values). The following script solves the Ising model for our formulation.</p>
      <p>Mathematically, the transform is: <italic>x</italic><sup><italic>T</italic></sup>
<italic>Qx</italic> = offset + <italic>s</italic><sup><italic>T</italic></sup>
<italic>Js</italic> + <italic>h</italic><sup><italic>T</italic></sup>
<italic>s</italic>. For every linear (diagonal) bias term in Q, <italic>h</italic>[<italic>i</italic>] + = 0.5 * <italic>Q</italic>[<italic>i</italic>][<italic>i</italic>], while for each couplings, <italic>J</italic>[(<italic>i</italic>, <italic>j</italic>)] = 0.25 * <italic>Q</italic>[<italic>i</italic>][<italic>j</italic>], <italic>h</italic>[<italic>i</italic>] + = 0.25 * <italic>Q</italic>[<italic>i</italic>][<italic>j</italic>], <italic>h</italic>[<italic>j</italic>] + = 0.25 * <italic>Q</italic>[<italic>i</italic>][<italic>i</italic>]. The offset value is the weighted sum of the linear offset (sum of all diagonal terms in Q), and the quadratic offset (sum of all off-diagonal terms in Q), with the weights as 0.5 and 0.25, respectively. The offset is not important for our case as we want the qubit state of the minimum energy, not the exact value of the minimized energy. This is coded in the <monospace>solve_ising_exact</monospace> function in <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py">‥/denovo_009.py</ext-link>. It can be invoked with the output of <monospace>dimod.qubo_to_ising</monospace> function as</p>
      <p>1 hii, Jij, offset = dimod.qubo_to_ising (Q)</p>
      <p>2 solve_ising_exact (hii, Jij)</p>
      <p>As expected, we find that there are 4 minimum solutions (the 4 Type A solutions).</p>
      <p>{‘n0t0’: +1, ‘n0t1’: −1, ‘n0t2’: −1, ‘n0t3’: −1,</p>
      <p>‘n1t0’: −1, ‘n1t1’: +1, ‘n1t2’: −1, ‘n1t3’: −1,</p>
      <p>‘n2t0’: −1, ‘n2t1’: −1, ‘n2t2’: +1, ‘n2t3’: −1,</p>
      <p>‘n3t0’: −1, ‘n3t1’: −1, ‘n3t2’: −1, ‘n3t3’: +1}</p>
      <p>{‘n0t0’: −1, ‘n0t1’: +1, ‘n0t2’: −1, ‘n0t3’: −1,</p>
      <p>‘n1t0’: −1, ‘n1t1’: −1, ‘n1t2’: +1, ‘n1t3’: −1,</p>
      <p>‘n2t0’: −1, ‘n2t1’: −1, ‘n2t2’: −1, ‘n2t3’: +1,</p>
      <p>‘n3t0’: +1, ‘n3t1’: −1, ‘n3t2’: −1, ‘n3t3’: −1}</p>
      <p>{‘n0t0’: −1, ‘n0t1’: −1, ‘n0t2’: +1, ‘n0t3’: −1,</p>
      <p>‘n1t0’: −1, ‘n1t1’: −1, ‘n1t2’: −1, ‘n1t3’: +1,</p>
      <p>‘n2t0’: +1, ‘n2t1’: −1, ‘n2t2’: −1, ‘n2t3’: −1,</p>
      <p>‘n3t0’: −1, ‘n3t1’: +1, ‘n3t2’: −1, ‘n3t3’: −1}</p>
      <p>{‘n0t0’: −1, ‘n0t1’: −1, ‘n0t2’: −1, ‘n0t3’: +1,</p>
      <p>‘n1t0’: +1, ‘n1t1’: −1, ‘n1t2’: −1, ‘n1t3’: −1,</p>
      <p>‘n2t0’: −1, ‘n2t1’: +1, ‘n2t2’: −1, ‘n2t3’: −1,</p>
      <p>‘n3t0’: −1, ‘n3t1’: −1, ‘n3t2’: +1, ‘n3t3’: −1}</p>
      <sec id="sec016">
        <title>Using D-Wave quantum annealer</title>
        <p>D-Wave offers a connection to the cloud to solve an Ising model. The problem needs to be embedded in the connectivity graph of the annealer. It is called a Chimera graph for the D-Wave 2000Q systems. Each of the 16 logical qubits is embedded over multiple qubits on the actual hardware so that each qubit shares a coupling based on the required interaction for the Ising model. The embedding process is a hard problem in itself and heuristics are employed in the D-Wave’s embedding function. Thus, with each run, the number of qubits and the longest chain length (i.e. the number of physical qubits encoding a single qubit) might vary, and even fail at times. The embedding process can be separately tested.</p>
        <p>This is coded in the <monospace>embed_qubo_chimera</monospace> function in <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py">‥/denovo_009.py</ext-link>. It can be invoked with the output of <monospace>dimod.qubo_to_ising</monospace> function as</p>
        <p>1 embed_qubo_chimera (quboAdjM)</p>
        <p>After multiple attempts, the best embedding obtained for our example de novo problem uses 60 qubits with a maximum chain length of 5, as shown in <xref ref-type="fig" rid="pone.0249850.g008">Fig 8</xref>. Each color represents one of the 16 logical qubits.</p>
        <fig id="pone.0249850.g008" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g008</object-id>
          <label>Fig 8</label>
          <caption>
            <title>Embedding the QUBO in Chimera graph topology for the D-Wave quantum annealer.</title>
            <p>Each color represents one of the 16 logical qubits.</p>
          </caption>
          <graphic xlink:href="pone.0249850.g008"/>
        </fig>
        <p>The following code connects to the D-Wave cloud and solves the de novo example. The code to connects to the D-Wave cloud and solve the de novo is in the <monospace>solve_ising_dwave</monospace> function in <ext-link ext-link-type="uri" xlink:href="https://github.com/QE-Lab/QuASeR/blob/master/QA_DeNovoAsb/denovo_009.py">‥/denovo_009.py</ext-link>. It can be invoked with the biases and coupling output of the <monospace>dimod.qubo_to_ising</monospace> function as</p>
        <p>1 solve_ising_dwave (hii, Jij)</p>
        <p>The top 10 (out of 65536) maximum sampled configurations are shown below. It is important to note that, the highest sampled configuration is not the global minima in terms of energy, showing the heuristic nature of the annealer.</p>
        <p>Maximum Sampled Configurations from D−Wave ⇒</p>
        <p>([−1,−1,−1,+1,−1,−1,−1,−1,+1,−1,−1,−1,−1,−1,+1,−1], −27.92288250, 4562)</p>
        <p>([−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1,−1,+1,−1,−1,−1], −22.70124548, 611)</p>
        <p>([−1,−1,+1,+1,−1,−1,−1,−1,−1,+1,−1,−1,+1,−1,−1,−1], −26.16476862, 481)</p>
        <p>([−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1,−1,+1,−1,−1,−1], −22.70124548, 474)</p>
        <p>([−1,−1,−1,+1,−1,−1,−1,−1,−1,+1,−1,−1,−1,−1,+1,−1], −28.08099638, 470)</p>
        <p>([−1,−1,−1,+1,−1,−1,−1,−1,+1,−1,−1,−1,−1,−1,+1,−1], −27.92288250, 343)</p>
        <p>([+1,−1,−1,−1,−1,−1,−1,−1,−1,+1,−1,−1,−1,−1,+1,−1], −27.81747324, 295)</p>
        <p>([−1,−1,−1,+1,−1,−1,−1,−1,+1,−1,−1,−1,−1,−1,+1,−1], −27.92288250, 259)</p>
        <p>([−1,−1,−1,+1,−1,−1,−1,−1,−1,−1,+1,−1,+1,−1,−1,−1], −27.60665473, 200)</p>
        <p>([−1,−1,−1,+1,−1,−1,−1,−1,−1,−1,+1,−1,+1,−1,−1,−1], −27.60665473, 187)</p>
        <p>The top 10 (out of 65536) minimum energy configurations are shown below. The list shows that, though the D−Wave was able to sample two of the four correct solutions, it has not sampled it with a high probability. Also, we find two other solution configurations are missed. Each run of the sampler would be slightly different varying both on environmental errors of the physical qubit system as well as the heuristics of embedding and schedule. Thus, while we were able to find an acceptable solution by the physical system, it might not be practical for larger problems.</p>
        <p>Minimum Energy Configurations from D−Wave ⇒</p>
        <p>([−1,−1,+1,−1,−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1], −30.41886117, 26)</p>
        <p>([−1,−1,+1,−1,−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1], −30.41886117, 2)</p>
        <p>([−1,−1,+1,−1,−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1], −30.41886117, 2)</p>
        <p>([−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1,−1,−1,+1,−1], −30.41886117, 29)</p>
        <p>([−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1,−1,−1,+1,−1], −30.41886117, 1)</p>
        <p>([−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1,−1,−1,+1,−1], −30.41886117, 7)</p>
        <p>([−1,−1,+1,−1,−1,−1,−1,+1,+1,−1,−1,−1,−1,+1,−1,−1], −30.41886117, 1)</p>
        <p>([−1,−1,−1,+1,−1,+1,−1,−1,+1,−1,−1,−1,−1,−1,+1,−1], −29.89181489, 23)</p>
        <p>([+1,−1,−1,−1,−1,−1,+1,−1,−1,−1,−1,+1,−1,+1,−1,−1], −29.89181489, 5)</p>
        <p>([−1,−1,−1,+1,−1,+1,−1,−1,+1,−1,−1,−1,−1,−1,+1,−1], −29.89181489, 3)</p>
        <p>A 16 qubit system was required for solving the above problem. When mapping the 16 qubits to a realistic hardware like D-Wave 2000Q, the connectivity of the qubits in the physical topology is important. The embedding process considerably increases the number of required qubits and also the quality of the solution. The highest number of DNA reads that can be solved on a D-Wave 2000Q machine is 9. The amount of qubits needed to solve the problem grows as <italic>N</italic><sup>2</sup> and finding embedding for the case with 10 reads will fail in most (if not all) cases. However, the time to solution is independent of the problem size and depends on a heuristic annealing schedule while affecting the quality of the sampled solution. In classical computation however, the record for exact solutions to the problem, using branch and bound algorithms is 85900 cities TSP [<xref rid="pone.0249850.ref023" ref-type="bibr">23</xref>]. Heuristics like Monte Carlo methods are used for larger inputs. This experiment infers the need for a much enhanced D-Wave system to do practical de novo assembly. Steps in this direction can be either in reducing the errors, having a custom anneal schedule, having more qubits and better connectivity (like the Pegasus architecture of the 5000 qubit model). At the current state of development, we were able to show a simple proof of concept both on the simulator and the quantum annealer on the cloud. The implementation is focused on the correctness of the pipeline design instead of quantifying the time and qubit resource metrics, that need radical improvements for benchmarking with real world datasets. De novo sequencing on quantum annealers needs to be evaluated with each release of improved hardware to reach a quantum advantage in computation over existing high-performance computing systems.</p>
      </sec>
    </sec>
    <sec id="sec017">
      <title>QUBO using QAOA</title>
      <p>Formulating a problem on QAOA involves specifying the ansatz for the cost and driver Hamiltonian. Other optimization hyper-parameters involve the initialization circuit, approximation order (cycles), initial parameters and threshold on classical optimizer iterations/precision. The pseudo-code for the formulation steps in an OpenQL implementation is shown in <xref ref-type="boxed-text" rid="pone.0249850.box002">Box 2</xref>.</p>
      <boxed-text id="pone.0249850.box002" position="float" orientation="portrait">
        <sec id="sec018">
          <title>Box 2. Pseudo-code for applying QAOA in OpenQL for optimization.</title>
          <p>• PQC encoding (e.g. Traveling salesman problem, Maximum cut problem):</p>
          <p> ◊ Create (weighted) graph with networkx</p>
          <p> ◊ Converts graph to weighted-Sum-of-Product-of-Paulis (wsopp). Encoding depends on problem. This is the problem/cost Hamiltonian for QUBO/Ising model.</p>
          <p> ◊ Convert graph to ansatz with cost and mixing Hamiltonian as parameterized QASM (ansatz, coefficients, angle ids)</p>
          <p>• Initialization:</p>
          <p> ◊ Classical optimizer object from SciPy:</p>
          <p>  ⋆ name [Default: Nelder-Mead]</p>
          <p>  ⋆ convergence function tolerance [Default: 1.0e–6]</p>
          <p>  ⋆ iteration limit</p>
          <p> ◊ Reference/initial state quantum circuit [Default: equal superposition, Hadamard on all qubits]</p>
          <p> ◊ Steps (ansatz blocks per iteration) [Default: 1]</p>
          <p> ◊ Parameters:</p>
          <p>  ⋆ for cost Hamiltonians (gammas) for each step</p>
          <p>  ⋆ for mixing/driving Hamiltonians (betas) for each step</p>
          <p>  [Default: random angles in 0 to 2<italic>π</italic>]</p>
          <p> ◊ Shots (for state tomography measurement aggregate) [Default: 0, QX internal state vector is accessed]</p>
          <p>• Invoke QAOA</p>
        </sec>
      </boxed-text>
      <p>First, the TSP city-graph is created based on the previous example. The networkx Python package is used to create a directed weighted complete graph based on the pair-wise read edge-weights.</p>
      <p>The graph is then converted to the problem Hamiltonian. The problem Hamiltonian is stored as a weighted sum-of-product of Paulis. For <italic>n</italic> cities (TSP graph nodes), <italic>n</italic><sup>2</sup> qubits are required representing the city nodes and the time slots, encoded as:
<disp-formula id="pone.0249850.e019"><alternatives><graphic xlink:href="pone.0249850.e019.jpg" id="pone.0249850.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>q</mml:mi><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mi>q</mml:mi><mml:mn>15</mml:mn><mml:mo>≡</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>…</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:msub><mml:mi>t</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
On each qubit, there can be either of the 4 Pauli operators, {<italic>I</italic>, <italic>X</italic>, <italic>Y</italic>, <italic>Z</italic>}, thus a maximum of <inline-formula id="pone.0249850.e020"><alternatives><graphic xlink:href="pone.0249850.e020.jpg" id="pone.0249850.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:msup><mml:mn>4</mml:mn><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup></mml:msup></mml:math></alternatives></inline-formula> weighted sum-of-product Pauli terms are possible. This amounts to 4294967296 Pauli terms when <italic>n</italic> = 4 (in our example), thus, we store only the non-zero terms. For TSP optimization, however, only the {<italic>I</italic>, <italic>Z</italic>} operator is required.</p>
      <p>Firstly, each city and each time-slot must be assigned, but not all together. Thus, a term is added with a positive penalty (<italic>w</italic> = 100000.0) for each qubit (the term being a <italic>Z</italic> operator on the specific qubit and <italic>I</italic> otherwise). We will abbreviate the sum-of-product of Pauli term notation henceforth by assuming Identity for qubits not mentioned in a Pauli term. Thus:
<disp-formula id="pone.0249850.e021"><alternatives><graphic xlink:href="pone.0249850.e021.jpg" id="pone.0249850.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>w</mml:mi><mml:mo>*</mml:mo><mml:mo>{</mml:mo><mml:mi>Z</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mi>I</mml:mi><mml:mi>Z</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>I</mml:mi><mml:mi>Z</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
<disp-formula id="pone.0249850.e022"><alternatives><graphic xlink:href="pone.0249850.e022.jpg" id="pone.0249850.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mo>*</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>…</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>Z</mml:mi><mml:mn>15</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mi>w</mml:mi><mml:msub><mml:mi>Z</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>Then, for each penalty of co-location (two cities, same time slot), a term with 2 <italic>Z</italic> operators for the two conflicting qubits is added with a positive penalty weight, and two separate terms for each penalty qubits with a 1 <italic>Z</italic> are added with a negative penalty.
<disp-formula id="pone.0249850.e023"><alternatives><graphic xlink:href="pone.0249850.e023.jpg" id="pone.0249850.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>Similar terms are added for repetition (two time slots, same city).
<disp-formula id="pone.0249850.e024"><alternatives><graphic xlink:href="pone.0249850.e024.jpg" id="pone.0249850.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>3</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
      <p>For each TSP edge, the edge pair is assigned to consecutive time slots. The edge weight is added as a penalty for the 2 <italic>Z</italic> operator terms, while assigning the individual terms with a negative penalty.
<disp-formula id="pone.0249850.e025"><alternatives><graphic xlink:href="pone.0249850.e025.jpg" id="pone.0249850.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>4</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mrow><mml:mtable><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="center"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>%</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mo>{</mml:mo><mml:mo>−</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mn>4</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mn>4</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mn>4</mml:mn></mml:mfrac></mml:mstyle><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mi>Z</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
Thus, these negative penalty terms in the overall equation stand out among the positive penalty terms for all qubits in <inline-formula id="pone.0249850.e026"><alternatives><graphic xlink:href="pone.0249850.e026.jpg" id="pone.0249850.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:math></alternatives></inline-formula>, so that only a valid path is assigned as a solution. The final cost Hamiltonian is <inline-formula id="pone.0249850.e027"><alternatives><graphic xlink:href="pone.0249850.e027.jpg" id="pone.0249850.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:mrow><mml:msub><mml:mi>H</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>1</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>3</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>H</mml:mi><mml:mi>C</mml:mi><mml:mn>4</mml:mn></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>.</p>
      <p>Now the ansatz needs to be formed. For the cost Hamiltonian ansatz, for each single <italic>Z</italic> terms, the Pauli-Z is replaced with a parameterized Z-Rotation gate <italic>R</italic><sub><italic>Z</italic></sub>(<italic>γ</italic>). The double <italic>Z</italic> terms between qubits (<italic>a</italic>, <italic>b</italic>) are replaced with a <inline-formula id="pone.0249850.e028"><alternatives><graphic xlink:href="pone.0249850.e028.jpg" id="pone.0249850.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:mrow><mml:mi>C</mml:mi><mml:mi>N</mml:mi><mml:mi>O</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mi>R</mml:mi><mml:mi>Z</mml:mi><mml:mi>b</mml:mi></mml:msubsup><mml:mrow><mml:mo>(</mml:mo><mml:mi>γ</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mi>C</mml:mi><mml:mi>N</mml:mi><mml:mi>O</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> (where <italic>b</italic> is the target qubit). For the mixing Hamiltonian, a <italic>R</italic><sub><italic>X</italic></sub>(<italic>β</italic>) is used on all qubit (or <italic>HR</italic><sub><italic>Z</italic></sub>(<italic>β</italic>)<italic>H</italic>).</p>
      <p>The reference state is set to an equal superposition (Hadamard over all qubits). The cost and mixing Hamiltonian ansatz is alternated for the set number of steps (1 in our case). This forms the parametric circuit for the quantum computer. Along with this, the random initial parameters vector (Γ, <italic>B</italic>) is passed to the classical optimizer wrapper for the QAOA. The QAOA is run as explained in <xref ref-type="boxed-text" rid="pone.0249850.box001">Box 1</xref>.</p>
      <p>We simulated our algorithm on the QX Simulator to validate the results. To speed up the simulation, we access the internal state vector from the QX Simulator instead of applying the state tomographic trials. However, optimizing the parameters on 16 qubits for single iteration over a single QAOA step proved to be cumbersome, reaching the limit of the working memory for most runs. While we obtain good results for the Max-Cut problem (which requires as many qubits as nodes in the graph), the <italic>n</italic><sup>2</sup> qubit space for TSP is costly for simulation. Similarly, most online tools only offer examples for the trivial case of an undirected triangle graph (where only one Hamiltonian cycle is possible). We used the Nelder-Mead, Powell and BFGS optimizers in SciPy. We found that the optimizers are able to explore only a small space near the initial guess before settling at a suboptimal solution. This is shown in <xref ref-type="fig" rid="pone.0249850.g009">Fig 9</xref>, where the dotted vertical green lines indicate the 4 optimal type A solution states out of the 2<sup>16</sup> = 65536 basis states (represented on the x-axis). The experiment uses a QAOA depth of 1, a random angle initialization, an equal superposed initial state (Hadamard on all qubits) and 40 reruns for the QAOA optimizer. When the initial guess is bad, the highest probability states (high blue circles) are not close to the optimal lines, whereas for good initial conditions case (red pluses), the optimizer eventually reaches solutions that are quite close to the optimal. The optimal solutions lie in near vicinity of the found solutions (high red pluses) and can be subsequently explored via an exhaustive search near these sub-optima suggested by QAOA. QAOA is able to improve 2 out of the 4 solutions of Type A. Development of new classical optimizers [<xref rid="pone.0249850.ref024" ref-type="bibr">24</xref>, <xref rid="pone.0249850.ref025" ref-type="bibr">25</xref>] and their hyper-parameter settings [<xref rid="pone.0249850.ref026" ref-type="bibr">26</xref>] for HQC algorithms is a research field of its own, which is not the focus of this paper. Thus, while we were able to formulate a generic de novo assembly problem to QAOA, we were not able to obtain satisfactory results from the simulation. This motivates the need for both faster simulation and the access to better NISQ devices where this entire pipeline can be executed and benchmarked—a common challenge for quantum computing today.</p>
      <fig id="pone.0249850.g009" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0249850.g009</object-id>
        <label>Fig 9</label>
        <caption>
          <title>Result of simulating QuASeR example using QAOA on the QX simulator.</title>
        </caption>
        <graphic xlink:href="pone.0249850.g009"/>
      </fig>
      <p>QAOA, though promising for exhibiting “quantum supremacy” does not imply that it will be able to outperform classical algorithms on important combinatorial optimization problems such as Constraint Satisfaction Problems. Current implementations of QAOA are subject to a gate fidelity limitation, where the potential advantages of larger values of the parameter <italic>p</italic> in QAOA applications are likely to be countered by a decrease in solution accuracy.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec019">
    <title>Conclusion</title>
    <p>In this paper, we formulated a de novo assembly DNA sequence reconstruction algorithm called QuASeR using the overlap-layout-consensus approach for acceleration on a quantum computing platform. The quantum kernel is formulated for both a gate-based quantum system as well as a quantum annealer. The required technical background for formulating the de novo sequencing problem (i.e. QUBO, TSP, and Hamiltonians) is introduced with simple examples to target both the genomics research community and quantum application developers. A proof-of-concept de novo sequence assembly is mapped to TSP and then to a QUBO. This is firstly solved on the D-Wave simulator and D-Wave Quantum Annealer. All 4 correct results are obtained on the simulator while only 2 of the solutions are sampled on the Quantum Annealer (though with less probability). The connectivity topology of the D-Wave architecture limits embedding larger problem instances. The variational algorithm approach for gate-based quantum computing is introduced for solving optimization problems using QAOA. This algorithm performs two optimization steps, one executed on a quantum circuit and another on a classical computer. The proposed de novo algorithm is solved using QAOA, and then simulated on the QX simulator. Simulation showed that the results are heavily dependent on the exploratory capabilities of the classical optimizer. A gate-based quantum computer is not targeted as the coherance time, connectivity topology and number of qubits prevents any meaningful result at the current state of available quantum hardware. This research is part of a full-stack domain-specific quantum accelerator project [<xref rid="pone.0249850.ref006" ref-type="bibr">6</xref>] undertaken in the Quantum Computer Architecture lab at the Delft University of Technology. It is the first time this important computation problem in bioinformatics is attempted on a quantum accelerator.</p>
  </sec>
</body>
<back>
  <ack>
    <p>We would like to appreciate the support of Imran Ashraf on the OpenQL programming platform and the QX simulation tool to enable the QAOA simulations in this paper.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0249850.ref001">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Sarkar</surname><given-names>A</given-names></name>, <name><surname>Al-Ars</surname><given-names>Z</given-names></name>, <name><surname>Bertels</surname><given-names>K</given-names></name>. <article-title>Estimating Algorithmic Information Using Quantum Computing for Genomics Applications</article-title>. <source>Applied Sciences</source>. <year>2021</year>;<volume>11</volume>(<issue>6</issue>). <pub-id pub-id-type="doi">10.3390/app11062696</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Stephens</surname><given-names>ZD</given-names></name>, <name><surname>Lee</surname><given-names>SY</given-names></name>, <name><surname>Faghri</surname><given-names>F</given-names></name>, <name><surname>Campbell</surname><given-names>RH</given-names></name>, <name><surname>Zhai</surname><given-names>C</given-names></name>, <name><surname>Efron</surname><given-names>MJ</given-names></name>, <etal>et al</etal>. <article-title>Big data: astronomical or genomical?</article-title><source>PLoS biology</source>. <year>2015</year>;<volume>13</volume>(<issue>7</issue>):<fpage>e1002195</fpage>. <pub-id pub-id-type="doi">10.1371/journal.pbio.1002195</pub-id><?supplied-pmid 26151137?><pub-id pub-id-type="pmid">26151137</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Hamburg</surname><given-names>MA</given-names></name>, <name><surname>Collins</surname><given-names>FS</given-names></name>. <article-title>The path to personalized medicine</article-title>. <source>New England Journal of Medicine</source>. <year>2010</year>;<volume>363</volume>(<issue>4</issue>):<fpage>301</fpage>–<lpage>304</lpage>. <pub-id pub-id-type="doi">10.1056/NEJMp1006304</pub-id><?supplied-pmid 20551152?><pub-id pub-id-type="pmid">20551152</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref004">
      <label>4</label>
      <mixed-citation publication-type="other">Wetterstrand KA. The cost of sequencing a human genome; 2018. Available from: <ext-link ext-link-type="uri" xlink:href="https://www.genome.gov/27565109/the-cost-of-sequencing-a-human-genome/">https://www.genome.gov/27565109/the-cost-of-sequencing-a-human-genome/</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Vassiliadis</surname><given-names>S</given-names></name>, <name><surname>Wong</surname><given-names>S</given-names></name>, <name><surname>Gaydadjiev</surname><given-names>GN</given-names></name>, <name><surname>Bertels</surname><given-names>K</given-names></name>, <name><surname>Kuzmanov</surname><given-names>GK</given-names></name>, <name><surname>Moscu Panainte</surname><given-names>E</given-names></name>. <article-title>The Molen Polymorphic Processor</article-title>. <source>IEEE Transactions on Computers</source>. <year>2004</year>;<volume>53</volume>:<fpage>1363</fpage>–<lpage>1375</lpage>. <pub-id pub-id-type="doi">10.1109/TC.2004.104</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref006">
      <label>6</label>
      <mixed-citation publication-type="other">Bertels K, Sarkar A, Hubregtsen T, Serrao M, Mouedenne A, Yadav A, et al. Quantum computer architecture: Towards full-stack quantum accelerators. In: 2020 Design, Automation &amp; Test in Europe Conference &amp; Exhibition (DATE). IEEE; 2020. p. 1–6.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref007">
      <label>7</label>
      <mixed-citation publication-type="other">Sarkar A, Al-Ars Z, Bertels K. QuASeR–Quantum Accelerated De Novo DNA Sequence Reconstruction. arXiv preprint arXiv:200405078. 2020.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref008">
      <label>8</label>
      <mixed-citation publication-type="other">Boev A, Rakitko A, Usmanov S, Kobzeva A, Popov I, Ilinsky V, et al. Genome assembly using quantum and quantum-inspired annealing. arXiv preprint arXiv:200406719. 2020.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref009">
      <label>9</label>
      <mixed-citation publication-type="other">Sarkar A, Al-Ars Z, Almudever CG, Bertels K. An algorithm for DNA read alignment on quantum accelerators. arXiv preprint arXiv:190905563. 2019.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Khan</surname><given-names>AR</given-names></name>, <name><surname>Pervez</surname><given-names>MT</given-names></name>, <name><surname>Babar</surname><given-names>ME</given-names></name>, <name><surname>Naveed</surname><given-names>N</given-names></name>, <name><surname>Shoaib</surname><given-names>M</given-names></name>. <article-title>A comprehensive study of de novo genome assemblers: current challenges and future prospective</article-title>. <source>Evolutionary Bioinformatics</source>. <year>2018</year>;<volume>14</volume>:<fpage>1176934318758650</fpage>. <pub-id pub-id-type="doi">10.1177/1176934318758650</pub-id><?supplied-pmid 29511353?><pub-id pub-id-type="pmid">29511353</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Miller</surname><given-names>JR</given-names></name>, <name><surname>Koren</surname><given-names>S</given-names></name>, <name><surname>Sutton</surname><given-names>G</given-names></name>. <article-title>Assembly algorithms for next-generation sequencing data</article-title>. <source>Genomics</source>. <year>2010</year>;<volume>95</volume>(<issue>6</issue>):<fpage>315</fpage>–<lpage>327</lpage>. <pub-id pub-id-type="doi">10.1016/j.ygeno.2010.03.001</pub-id><?supplied-pmid 20211242?><pub-id pub-id-type="pmid">20211242</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Commins</surname><given-names>J</given-names></name>, <name><surname>Toft</surname><given-names>C</given-names></name>, <name><surname>Fares</surname><given-names>MA</given-names></name>. <article-title>Computational biology methods and their application to the comparative genomics of endocellular symbiotic bacteria of insects</article-title>. <source>Biological procedures online</source>. <year>2009</year>;<volume>11</volume>(<issue>1</issue>):<fpage>52</fpage>. <pub-id pub-id-type="doi">10.1007/s12575-009-9004-1</pub-id><?supplied-pmid 19495914?><pub-id pub-id-type="pmid">19495914</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref013">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Deutsch</surname><given-names>DE</given-names></name>. <article-title>Quantum computational networks</article-title>. <source>Proceedings of the Royal Society of London A Mathematical and Physical Sciences</source>. <year>1989</year>;<volume>425</volume>(<issue>1868</issue>):<fpage>73</fpage>–<lpage>90</lpage>. <pub-id pub-id-type="doi">10.1098/rspa.1989.0099</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref014">
      <label>14</label>
      <mixed-citation publication-type="other">Farhi E, Goldstone J, Gutmann S, Sipser M. Quantum computation by adiabatic evolution. arXiv preprint quant-ph/0001106. 2000.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref015">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Kochenberger</surname><given-names>G</given-names></name>, <name><surname>Hao</surname><given-names>JK</given-names></name>, <name><surname>Glover</surname><given-names>F</given-names></name>, <name><surname>Lewis</surname><given-names>M</given-names></name>, <name><surname>Lü</surname><given-names>Z</given-names></name>, <name><surname>Wang</surname><given-names>H</given-names></name>, <etal>et al</etal>. <article-title>The unconstrained binary quadratic programming problem: a survey</article-title>. <source>Journal of Combinatorial Optimization</source>. <year>2014</year>;<volume>28</volume>(<issue>1</issue>):<fpage>58</fpage>–<lpage>81</lpage>. <pub-id pub-id-type="doi">10.1007/s10878-014-9734-0</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref016">
      <label>16</label>
      <mixed-citation publication-type="other">Glover F, Kochenberger G. A Tutorial on Formulating QUBO Models. arXiv preprint arXiv:181111538. 2018.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref017">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Hauke</surname><given-names>P</given-names></name>, <name><surname>Katzgraber</surname><given-names>HG</given-names></name>, <name><surname>Lechner</surname><given-names>W</given-names></name>, <name><surname>Nishimori</surname><given-names>H</given-names></name>, <name><surname>Oliver</surname><given-names>WD</given-names></name>. <article-title>Perspectives of quantum annealing: Methods and implementations</article-title>. <source>Reports on Progress in Physics</source>. <year>2020</year>;<volume>83</volume>(<issue>5</issue>):<fpage>054401</fpage>. <pub-id pub-id-type="doi">10.1088/1361-6633/ab85b8</pub-id><?supplied-pmid 32235066?><pub-id pub-id-type="pmid">32235066</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref018">
      <label>18</label>
      <mixed-citation publication-type="other">Cao Y, Romero J, Olson JP, Degroote M, Johnson PD, Kieferová M, et al. Quantum Chemistry in the Age of Quantum Computing. arXiv preprint arXiv:181209976. 2018.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref019">
      <label>19</label>
      <mixed-citation publication-type="other">Farhi E, Goldstone J, Gutmann S. A quantum approximate optimization algorithm. arXiv preprint arXiv:14114028. 2014.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref020">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Hadfield</surname><given-names>S</given-names></name>, <name><surname>Wang</surname><given-names>Z</given-names></name>, <name><surname>O’Gorman</surname><given-names>B</given-names></name>, <name><surname>Rieffel</surname><given-names>EG</given-names></name>, <name><surname>Venturelli</surname><given-names>D</given-names></name>, <name><surname>Biswas</surname><given-names>R</given-names></name>. <article-title>From the quantum approximate optimization algorithm to a quantum alternating operator ansatz</article-title>. <source>Algorithms</source>. <year>2019</year>;<volume>12</volume>(<issue>2</issue>):<fpage>34</fpage>. <pub-id pub-id-type="doi">10.3390/a12020034</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref021">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>McClean</surname><given-names>JR</given-names></name>, <name><surname>Boixo</surname><given-names>S</given-names></name>, <name><surname>Smelyanskiy</surname><given-names>VN</given-names></name>, <name><surname>Babbush</surname><given-names>R</given-names></name>, <name><surname>Neven</surname><given-names>H</given-names></name>. <article-title>Barren plateaus in quantum neural network training landscapes</article-title>. <source>Nature communications</source>. <year>2018</year>;<volume>9</volume>(<issue>1</issue>):<fpage>1</fpage>–<lpage>6</lpage>. <pub-id pub-id-type="doi">10.1038/s41467-018-07090-4</pub-id><?supplied-pmid 30446662?><pub-id pub-id-type="pmid">30446662</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref022">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Nannicini</surname><given-names>G</given-names></name>. <article-title>Performance of hybrid quantum-classical variational heuristics for combinatorial optimization</article-title>. <source>Physical Review E</source>. <year>2019</year>;<volume>99</volume>(<issue>1</issue>):<fpage>013304</fpage>. <pub-id pub-id-type="doi">10.1103/PhysRevE.99.013304</pub-id><?supplied-pmid 30780378?><pub-id pub-id-type="pmid">30780378</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0249850.ref023">
      <label>23</label>
      <mixed-citation publication-type="book"><name><surname>Cook</surname><given-names>WJ</given-names></name>. <source>In pursuit of the traveling salesman: mathematics at the limits of computation</source>. <publisher-name>Princeton University Press</publisher-name>; <year>2011</year>.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref024">
      <label>24</label>
      <mixed-citation publication-type="other">Guerreschi GG, Smelyanskiy M. Practical optimization for hybrid quantum-classical algorithms. arXiv preprint arXiv:170101450. 2017.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref025">
      <label>25</label>
      <mixed-citation publication-type="other">Khairy S, Shaydulin R, Cincio L, Alexeev Y, Balaprakash P. Learning to Optimize Variational Quantum Circuits to Solve Combinatorial Problems. arXiv preprint arXiv:191111071. 2019.</mixed-citation>
    </ref>
    <ref id="pone.0249850.ref026">
      <label>26</label>
      <mixed-citation publication-type="other">Shaydulin R, Safro I, Larson J. Multistart methods for quantum approximate optimization. In: 2019 IEEE High Performance Extreme Computing Conference (HPEC). IEEE; 2019. p. 1–8.</mixed-citation>
    </ref>
  </ref-list>
</back>
