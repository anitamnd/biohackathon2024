<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9805553</article-id>
    <article-id pub-id-type="pmid">36440908</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btac734</article-id>
    <article-id pub-id-type="publisher-id">btac734</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Syllable-PBWT for space-efficient haplotype long-match query</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Victor</given-names>
        </name>
        <aff><institution>School of Biomedical Informatics, University of Texas Health Science Center at Houston</institution>, Houston, TX 77030, <country country="US">USA</country></aff>
        <xref rid="btac734-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Naseri</surname>
          <given-names>Ardalan</given-names>
        </name>
        <aff><institution>School of Biomedical Informatics, University of Texas Health Science Center at Houston</institution>, Houston, TX 77030, <country country="US">USA</country></aff>
        <xref rid="btac734-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-4051-5549</contrib-id>
        <name>
          <surname>Zhang</surname>
          <given-names>Shaojie</given-names>
        </name>
        <aff><institution>Department of Computer Science, University of Central Florida</institution>, Orlando, FL 32816, <country country="US">USA</country></aff>
        <xref rid="btac734-cor1" ref-type="corresp"/>
        <!--shzhang@cs.ucf.edu-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7754-1890</contrib-id>
        <name>
          <surname>Zhi</surname>
          <given-names>Degui</given-names>
        </name>
        <aff><institution>School of Biomedical Informatics, University of Texas Health Science Center at Houston</institution>, Houston, TX 77030, <country country="US">USA</country></aff>
        <xref rid="btac734-cor1" ref-type="corresp"/>
        <!--degui.zhi@uth.tmc.edu-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Kendziorski</surname>
          <given-names>Christina</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <fn id="btac734-FM1">
        <p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.</p>
      </fn>
      <corresp id="btac734-cor1">To whom correspondence should be addressed. Email: <email>degui.zhi@uth.tmc.edu</email> or <email>shzhang@cs.ucf.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2022-11-28">
      <day>28</day>
      <month>11</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>28</day>
      <month>11</month>
      <year>2022</year>
    </pub-date>
    <volume>39</volume>
    <issue>1</issue>
    <elocation-id>btac734</elocation-id>
    <history>
      <date date-type="received">
        <day>29</day>
        <month>3</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>6</month>
        <year>2022</year>
      </date>
      <date date-type="editorial-decision">
        <day>11</day>
        <month>11</month>
        <year>2022</year>
      </date>
      <date date-type="corrected-typeset">
        <day>09</day>
        <month>12</month>
        <year>2022</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2022. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btac734.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The positional Burrows–Wheeler transform (PBWT) has led to tremendous strides in haplotype matching on biobank-scale data. For genetic genealogical search, PBWT-based methods have optimized the asymptotic runtime of finding long matches between a query haplotype and a predefined panel of haplotypes. However, to enable fast query searches, the full-sized panel and PBWT data structures must be kept in memory, preventing existing algorithms from scaling up to modern biobank panels consisting of millions of haplotypes. In this work, we propose a space-efficient variation of PBWT named Syllable-PBWT, which divides every haplotype into syllables, builds the PBWT positional prefix arrays on the compressed syllabic panel, and leverages the polynomial rolling hash function for positional substring comparison. With the Syllable-PBWT data structures, we then present a long match query algorithm named Syllable-Query.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Compared to the most time- and space-efficient previously published solution to the long match query problem, Syllable-Query reduced the memory use by a factor of over 100 on both the UK Biobank genotype data and the 1000 Genomes Project sequence data. Surprisingly, the smaller size of our syllabic data structures allows for more efficient iteration and CPU cache usage, granting Syllable-Query even faster runtime than existing solutions.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>
          <ext-link xlink:href="https://github.com/ZhiGroup/Syllable-PBWT" ext-link-type="uri">https://github.com/ZhiGroup/Syllable-PBWT</ext-link>
        </p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01HG010086</award-id>
        <award-id>R56HG011509</award-id>
        <award-id>OT2OD002751</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Developments in genotyping technologies have accelerated the growth of genotype databases, paving the way for systematically comparing the haplotype sequences inherited by individuals (<xref rid="btac734-B3" ref-type="bibr">Campbell <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btac734-B19" ref-type="bibr">Nielsen <italic toggle="yes">et al.</italic>, 2011</xref>). Long shared DNA segments, known as Identical by Descent (IBD) segments, between the haplotypes of two or more individuals are highly indicative of a recent common ancestor (<xref rid="btac734-B26" ref-type="bibr">Thompson, 2013</xref>). To efficiently analyze large panels of haplotypes, Durbin proposed the positional Burrows–Wheeler transform (PBWT) (<xref rid="btac734-B6" ref-type="bibr">Durbin, 2014</xref>), a data structure that reorders haplotypes at every site (i.e. position within a haplotype) to concisely represent local substring matches within sets of aligned haplotypes, and has a construction runtime proportional to the size of the panel. Beyond IBD segment detection (<xref rid="btac734-B8" ref-type="bibr">Freyman <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btac734-B17" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic>, 2019c</xref>; <xref rid="btac734-B27" ref-type="bibr">Zhou <italic toggle="yes">et al.</italic>, 2020</xref>), PBWT has found applications in genotype imputation (<xref rid="btac734-B14" ref-type="bibr">Loh <italic toggle="yes">et al.</italic>, 2016</xref>; <xref rid="btac734-B21" ref-type="bibr">Rubinacci <italic toggle="yes">et al.</italic>, 2020</xref>) and studying recombination events (<xref rid="btac734-B18" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic>, 2021</xref>).</p>
    <p>PBWT algorithms come in two flavors: finding all within-panel pairwise haplotype matches (all-vs-all matching), or finding all pairwise haplotype matches between an out-of-panel haplotype and any in-panel haplotype (one-vs-all query). In this work, we are concerned with the one-vs-all query problem, of which an important application is genealogical search. Durbin’s Algorithm 5 (<xref rid="btac734-B6" ref-type="bibr">Durbin, 2014</xref>) is able to find all set-maximal matches from a query haplotype to any panel haplotype, where a set-maximal match is said to exist from a haplotype <italic toggle="yes">s</italic><sub>1</sub> to a haplotype <italic toggle="yes">s</italic><sub>2</sub> if no other haplotype in the panel has a longer match with <italic toggle="yes">s</italic><sub>1</sub> that completely contains the range of sites over which <italic toggle="yes">s</italic><sub>1</sub> and <italic toggle="yes">s</italic><sub>2</sub> match.</p>
    <p>However, as noted by <xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic> (2019a</xref>), reporting only set-maximal matches is likely to exclude a lot of valuable match information, since many considerably long matches would not be reported simply because they were overshadowed by a longer match. (Note too that the quality of being set-maximal is not necessarily symmetric; i.e. that a match is set-maximal from <italic toggle="yes">s</italic><sub>1</sub> to <italic toggle="yes">s</italic><sub>2</sub> does not imply that it is set-maximal from <italic toggle="yes">s</italic><sub>2</sub> to <italic toggle="yes">s</italic><sub>1</sub>, which is unintuitive for genealogical search.) Instead, setting a match length cutoff is more theoretically justifiable and has been the common practice in real-world genealogical search deployed by direct-to-consumer (DTC) genetics companies. In spite of the occasional errors present in haplotype data, DTC genetics companies and other researchers have demonstrated the efficacy of using long matches to determine genealogical relationships (<xref rid="btac734-B1" ref-type="bibr">23andMe, 2021</xref>; <xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic>, 2019a</xref>; <xref rid="btac734-B20" ref-type="bibr">Roberts <italic toggle="yes">et al.</italic>, 2011</xref>). In the PBWT-Query work, <xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic> (2019a</xref>) defined an <italic toggle="yes">L</italic>-long match (abbreviated to ‘long match’) to be a match spanning at least <italic toggle="yes">L</italic> sites (or, for genetic distance, at least <italic toggle="yes">L</italic> cM) and presented an algorithm to find all long matches between a query haplotype and a panel in average-case <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where there are <italic toggle="yes">N</italic> sites and <italic toggle="yes">c</italic> reported matches. Remarkably, since <italic toggle="yes">O</italic>(<italic toggle="yes">N</italic>) time is indispensable to read in the query haplotype, and <italic toggle="yes">O</italic>(<italic toggle="yes">c</italic>) to output matches, <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the fastest time complexity theoretically achievable.</p>
    <p>However, existing PBWT query algorithms are not space-efficient. Although all-vs-all PBWT matching consumes minimal memory as the scanning algorithms only store data relevant to the current site, one-vs-all PBWT query entails retaining data for all sites in memory to enable pointer lookups that are independent in runtime from the number of haplotypes. To bypass previously visited matches and achieve efficient runtime, <xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic> (2019a</xref>) introduced data structures called LEAP arrays, which increase the memory burden on top of what is already required by the original PBWT data structures. To lighten memory usage, <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref> developed Algorithms 3 and 4 of d-PBWT, which solve the long match query problem without LEAP arrays in worst-case and average-case runtimes, respectively, of <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Despite the memory improvement, storing PBWT data structures in memory for the whole genome remains a bottleneck for potential applications, such as online whole-genome query services. For example, to query on the 22 autosomal chromosomes from UK Biobank consisting of 974 818 haplotypes and 658 720 markers, Algorithms 3 and 4 of <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref> require 10.1 TB of memory. Accommodating memory usage of this magnitude demands dedicating expensive servers with massive amounts of RAM. Moreover, even the size of UK Biobank’s database pales in comparison to the tens of millions of genotype samples collected by DTC companies, and this number is only set to rise (<xref rid="btac734-B12" ref-type="bibr">Khan and Mittelman, 2018</xref>).</p>
    <p>For servers with relatively limited memory, current alternatives include keeping data on the solid-state drive (SSD) or hard disk drive (HDD), often in tandem with memory-mapped files. However, accessing these sources is accompanied by a significant runtime overhead, which, when memory-mapped files are used, also heavily depends on the similarity between previous and subsequent queries, as discussed by the authors of PBWT-Query (<xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic>, 2019a</xref>). Alternatively, distributing the PBWT panel into multiple servers may lower the memory footprint for individual servers but at the incurred cost of synchronization.</p>
    <p>In this work, we present a space-efficient variation of the PBWT data structure, named Syllable-PBWT, with which we in turn present Syllable-Query, an algorithm that solves the <italic toggle="yes">L</italic>-long match query problem with more optimal memory usage and runtime than existing algorithms. One theoretical contribution featured in this work is the replacement of the divergence array, which in past works has gone hand in hand with the PBWT data structure, with polynomial hashing. While the basic idea of chunking into syllables is core to our approach, the innovation mainly lies in our adaptation of PBWT algorithms, which traditionally were geared toward bi-allelic (or at best multi-allelic) sequences, to function on general sequences.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Overview</title>
      <p>The existing algorithms for the <italic toggle="yes">L</italic>-long match query problem, as presented by <xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic> (2019a</xref>) and <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref>, use the binary haplotype sequences to construct the PBWT, which we refer to as bit-PBWT. To query with bit-PBWT, said algorithms maintain four full-panel-sized (comprising <italic toggle="yes">MN</italic> integers) data structures: the positional prefix arrays <italic toggle="yes">a</italic>, the divergence arrays <italic toggle="yes">d</italic> and the virtual extension arrays <italic toggle="yes">u</italic> and <italic toggle="yes">v</italic>. We reasoned that the dense encoding by bit-PBWT would be redundant for identifying <italic toggle="yes">L</italic>-long matches for large <italic toggle="yes">L</italic>, since short matches could simply be skipped in applications like genealogical search and association analysis. Thus, we propose Syllable-PBWT, which treats every <italic toggle="yes">B</italic> contiguous sites as one syllable (where <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>≤</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mi>L</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.1</xref>) and builds data structures for only every syllable rather than for every site, a technique that can be loosely likened to others in bioinformatics (<xref rid="btac734-B7" ref-type="bibr">Ekim <italic toggle="yes">et al.</italic>, 2021</xref>). In doing so, Syllable-PBWT reduces the size of positional prefix arrays by a factor of <italic toggle="yes">B</italic>. Further, Syllable-PBWT introduces prefix hash arrays to replace the divergence arrays and virtual insertion arrays. To further reduce the panel size, we perform coordinate compression and build dictionaries at each syllable, leveraging the linkage disequilibrium of the haplotype sequences to collapse the panel until the discovered coarse matches must be restored to site-level detail using the dictionaries. Overall, the space usage of Syllable-PBWT is about <italic toggle="yes">B</italic> times smaller than that of bit-PBWT, as outlined in <xref rid="btac734-T1" ref-type="table">Table 1</xref>. In order to identify all <italic toggle="yes">L</italic>-long matches, we develop the Syllable-Query algorithm using the Syllable-PBWT data structure. The following subsections elaborate upon the presented algorithms and their correctness.</p>
      <table-wrap position="float" id="btac734-T1">
        <label>Table 1.</label>
        <caption>
          <p>Space comparison between bit-PBWT and Syllable-PBWT data structures used to query in Algorithm 3 of <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref> and Syllable-Query, respectively</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Space usage</th>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">Bit-PBWT</th>
              <th rowspan="1" colspan="1">Syllable-PBWT</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Panel of sequences</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE5">
                  <mml:math id="IM5" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mrow>
                        <mml:mover accent="true">
                          <mml:mi>X</mml:mi>
                          <mml:mo>˙</mml:mo>
                        </mml:mover>
                      </mml:mrow>
                      <mml:mo>/</mml:mo>
                      <mml:mi>X</mml:mi>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE6">
                  <mml:math id="IM6" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mrow>
                          <mml:mn>32</mml:mn>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE7">
                  <mml:math id="IM7" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mi>B</mml:mi>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Syllable dictionaries</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">r</italic>
              </td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE8">
                  <mml:math id="IM8" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mrow>
                          <mml:mn>32</mml:mn>
                          <mml:mo>ρ</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Positional prefix arrays</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">a</italic>
              </td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE9">
                  <mml:math id="IM9" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mi>B</mml:mi>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Prefix hash arrays</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">h</italic>
              </td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE10">
                  <mml:math id="IM10" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mn>2</mml:mn>
                        <mml:mi>B</mml:mi>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Divergence arrays</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">d</italic>
              </td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Virtual extension arrays</td>
              <td rowspan="1" colspan="1"><italic toggle="yes">u</italic>, <italic toggle="yes">v</italic></td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Total space</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE11">
                  <mml:math id="IM11" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mn>4</mml:mn>
                      <mml:mo>+</mml:mo>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mrow>
                          <mml:mn>32</mml:mn>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE12">
                  <mml:math id="IM12" display="inline" overflow="scroll">
                    <mml:mrow>
                      <mml:mfrac>
                        <mml:mn>4</mml:mn>
                        <mml:mi>B</mml:mi>
                      </mml:mfrac>
                      <mml:mo>+</mml:mo>
                      <mml:mfrac>
                        <mml:mn>1</mml:mn>
                        <mml:mrow>
                          <mml:mn>32</mml:mn>
                          <mml:mo>ρ</mml:mo>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Values are in units of <italic toggle="yes">MN</italic> 32-bit integers, where there are <italic toggle="yes">M</italic> haplotypes with <italic toggle="yes">N</italic> sites each (assume <italic toggle="yes">N</italic> is a multiple of <italic toggle="yes">B</italic>). <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>ρ</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> is defined in Section 2.3.1. The hashes are stored as 64-bit integers, hence the <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mfrac><mml:mn>2</mml:mn><mml:mi>B</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> memory from <italic toggle="yes">h</italic>.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>2.2 Notation</title>
      <p>The data we are dealing with is a haplotype panel consisting of aligned binary haplotype sequences. In a sequence <italic toggle="yes">s</italic> (with positions indexed starting from 0), <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> denotes the value at position <italic toggle="yes">b</italic>, and <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denotes the sequence of values from position <italic toggle="yes">b</italic> to position <italic toggle="yes">e −</italic> 1, inclusive. An <italic toggle="yes">L</italic>-long match (abbreviated to ‘match’) between sequences <italic toggle="yes">s</italic><sub>1</sub> and <italic toggle="yes">s</italic><sub>2</sub> is said to start at <italic toggle="yes">b</italic> and end at <italic toggle="yes">e</italic> if <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (or <italic toggle="yes">b </italic>=<italic toggle="yes"> </italic>0), <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (or <italic toggle="yes">e</italic> is the length of the sequences), and <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mi>b</mml:mi><mml:mo>≥</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> for some specified <italic toggle="yes">L</italic>. Let <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the panel of <italic toggle="yes">M</italic> haplotype sequences, each with <italic toggle="yes">N</italic> sites, with which queries are to be matched. Off of the haplotype panel <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, we will construct a raw syllabic panel <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and, in turn, a (compressed) syllabic panel <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The construction and the length <italic toggle="yes">n</italic> of every raw/compressed syllabic sequence is later described. For any collection of sequences <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and any position <italic toggle="yes">k</italic>, we define <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> as <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>M</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>2.3 Syllable-PBWT</title>
      <p>The Syllable-PBWT data structure consists of the syllabic panel <italic toggle="yes">X</italic> with dictionaries <italic toggle="yes">r</italic>, the positional prefix arrays <italic toggle="yes">a</italic> and the polynomial prefix hash arrays <italic toggle="yes">h</italic>.</p>
      <sec>
        <title>2.3.1 Syllabic panel</title>
        <p>To shorten the length of the sequences, we split the panel into syllables of <italic toggle="yes">B</italic> sites each, padding the ends of the haplotypes with 0s as necessary. For the <italic toggle="yes">k</italic>th <italic toggle="yes">B</italic>-site syllable of the <italic toggle="yes">i</italic>th haplotype, we parse the binary allele values spanning the <italic toggle="yes">B</italic> sites, i.e. the reverse of <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, as a binary number, whose value we assign to <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, syllable <italic toggle="yes">k</italic> of the raw syllabic sequence <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula>. Constructing <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> takes <italic toggle="yes">O</italic>(<italic toggle="yes">MN</italic>) time since it is computationally equivalent to reading in the panel.</p>
        <p>Although we have reduced the length of the sequences by a factor of <italic toggle="yes">B</italic> to get <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mi>N</mml:mi><mml:mi>B</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> syllables, our raw syllabic panel <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> still contains the same underlying information, merely arranged into <italic toggle="yes">B</italic>-bit integers, as <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. To reduce the space required to store our syllabic sequences, we observe that the number of distinct raw syllable values at a given syllable is bounded by the number of haplotypes <italic toggle="yes">M</italic>. If <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>≪</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>B</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, we can apply coordinate compression (i.e. mapping sparse values in a large space to dense values in a small space) to the raw syllable values at a given syllable to obtain the compressed syllable values (abbreviated to ‘syllable values’). To enable conversion between raw and compressed syllable values, we build <italic toggle="yes">r<sub>k</sub></italic>, a sorted dictionary of the distinct raw syllable values at syllable <italic toggle="yes">k</italic>. Then, every (compressed) syllabic sequence <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> can be built as follows: <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the index of <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">r<sub>k</sub></italic>, where said index can be found with binary search. The second step of <xref rid="btac734-F1" ref-type="fig">Figure 1</xref> illustrates the compression. The raw syllable values can later be recovered using the dictionary: <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math></inline-formula></p>
        <fig position="float" id="btac734-F1">
          <label>Fig. 1.</label>
          <caption>
            <p>The reverse of every <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>4 binary allele values is parsed as a binary number to obtain raw syllable values, written in hexadecimal (<inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>F</mml:mi><mml:mo>=</mml:mo><mml:mn>15</mml:mn></mml:mrow></mml:math></inline-formula>), which undergo coordinate compression to produce the compressed syllable values. Underlines indicate the reverse prefix match before site/syllable <italic toggle="yes">k</italic> with the preceding sequence in the positional prefix order <italic toggle="yes">a<sub>k</sub></italic>. Although the panel compression appears lossy, the dictionaries <italic toggle="yes">r<sub>k</sub></italic> can serve to recover the site-level data</p>
          </caption>
          <graphic xlink:href="btac734f1" position="float"/>
        </fig>
        <p>Since <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> can be written in terms of <italic toggle="yes">r<sub>k</sub></italic> and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we can avoid the redundancy of keeping <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> in memory after precomputation on syllable <italic toggle="yes">k</italic>. Instead, we store <italic toggle="yes">X</italic> with <italic toggle="yes">O</italic>(<italic toggle="yes">Mn</italic>) memory and <italic toggle="yes">r</italic> with <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory. In the worst case, in which at every syllable, all the sequences have distinct syllable values, then <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>M</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> implies <italic toggle="yes">r</italic> will require <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">MnB</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory. Fortunately, in genetic data, linkage disequilibrium [i.e. non-random association of alleles across sites (<xref rid="btac734-B25" ref-type="bibr">Slatkin, 2008</xref>)] gives rise to repetitive syllable values at any given syllable. Therefore, the ratio <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mo>ρ</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>r</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> will likely be considerable, and <italic toggle="yes">r</italic> will use <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mfrac><mml:mrow><mml:mi>M</mml:mi><mml:mi>N</mml:mi></mml:mrow><mml:mo>ρ</mml:mo></mml:mfrac><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula> memory. Due to the sorting and binary search on the raw syllable values to compute <italic toggle="yes">r</italic> and <italic toggle="yes">X</italic>, respectively, they each take <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>M</mml:mi><mml:mi>n</mml:mi><mml:mo>β</mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time to compute, for some small factor <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; due to the efficiency of 64-bit architectures, <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo>β</mml:mo><mml:mo>≪</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.1</xref> for details).</p>
      </sec>
      <sec>
        <title>2.3.2 Positional prefix array and PBWT array</title>
        <p>The positional prefix array <italic toggle="yes">a<sub>k</sub></italic> serves as the backbone of PBWT by storing the ordering of the sequences’ reverse prefixes before position <italic toggle="yes">k</italic>. In other words, for the syllabic panel <italic toggle="yes">X</italic>, the position of <italic toggle="yes">i</italic> in <italic toggle="yes">a<sub>k</sub></italic> is the rank of the reverse of <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> when sorted (in lexicographical order) among, for all <italic toggle="yes">j</italic>, the reverse of <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. To simplify notation, the PBWT array <italic toggle="yes">y<sup>k</sup></italic> is defined such that <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, i.e. the sequence at position <italic toggle="yes">i</italic> in <italic toggle="yes">a<sub>k</sub></italic> (<inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> are similarly defined according to <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, respectively); the <italic toggle="yes">y</italic> arrays need not be kept in memory as they can be expressed in terms of <italic toggle="yes">X</italic> and <italic toggle="yes">a</italic>. Algorithm 1 of Durbin’s PBWT makes use of the binary nature of allele values in bit-PBWT so that two pointers can be used to build <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">O</italic>(<italic toggle="yes">M</italic>) time, given <italic toggle="yes">a<sub>k</sub></italic> and <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>To build <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for sequences with up to <italic toggle="yes">M</italic> possible syllable values in Syllable-PBWT, we employ similar reasoning to that in bit-PBWT. <xref rid="btac734-F1" ref-type="fig">Figure 1</xref> visualizes the syllabic PBWT array in relation to the binary PBWT array. <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the most significant syllable in determining the ordering of <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. If two sequences have the same value at syllable <italic toggle="yes">k</italic>, then the tie is to be broken with their reverse prefixes over syllables <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In other words, <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be calculated by sorting the sequences by their <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> value and, for ties, retaining the ordering from <italic toggle="yes">a<sub>k</sub></italic>. This can be accomplished in <italic toggle="yes">O</italic>(<italic toggle="yes">M</italic>) time and memory with counting sort, a stable sorting algorithm, since the syllable values are bounded by <italic toggle="yes">M</italic>. Therefore, the positional prefix arrays over the <italic toggle="yes">n</italic> syllables require <italic toggle="yes">O</italic>(<italic toggle="yes">Mn</italic>) time and memory to compute and store.</p>
      </sec>
      <sec>
        <title>2.3.3 Polynomial prefix hash function and array for substring matching</title>
        <p>The polynomial rolling hash function (<xref rid="btac734-B11" ref-type="bibr">Karp and Rabin, 1987</xref>) is a simple and efficient hash function for substring matching and has seen use in bioinformatics (<xref rid="btac734-B4" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic>, 2021</xref>). One of our main observations is that the divergence arrays are not the only efficient bookkeeping method for positional substring matching in PBWT. The polynomial rolling hash function too can efficiently check if a pair of aligned sequences match over an interval. Specifically, the polynomial rolling hash function of the first <italic toggle="yes">k</italic> elements of <italic toggle="yes">x<sub>i</sub></italic> is defined as
<disp-formula id="E1"><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>·</mml:mo><mml:mi mathvariant="italic">BAS</mml:mi><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mi mathvariant="italic">MOD</mml:mi></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">BASE</italic> and <italic toggle="yes">MOD</italic> are distinct large primes (<xref rid="btac734-B2" ref-type="bibr">Alomair <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btac734-B11" ref-type="bibr">Karp and Rabin, 1987</xref>). In other words, we add 1 to every syllable value, parse the reverse of the resulting <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as a number in base <italic toggle="yes">BASE</italic>, and confine it to the range <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="italic">MOD</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The benefit of this hash function is that the hash value for any positional substring <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be calculated by <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">MOD</mml:mi></mml:mrow></mml:math></inline-formula>. Thus, the polynomial rolling hash enables efficient substring matching given the prefix hashes. For justification on the dependability of our hash function despite possible collisions (&lt;<inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> probability of collision over 10<sup>10</sup> lookups), see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.2</xref>. For notation, we define the polynomial prefix hash array <italic toggle="yes">h<sub>i</sub></italic> such that <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>Every syllable value is added to exactly one prefix hash exactly once, since every hash can simply build off of the previous syllable’s hash. Therefore, the arrays <italic toggle="yes">h</italic> require <italic toggle="yes">O</italic>(<italic toggle="yes">Mn</italic>) time and memory to compute and store.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Syllable-Query</title>
      <p>Using the Syllable-PBWT data structures described above (<italic toggle="yes">X</italic>, <italic toggle="yes">r</italic>, <italic toggle="yes">a</italic>, <italic toggle="yes">h</italic>), we present the Syllable-Query algorithm to find long matches between a query haplotype and the panel. Crucial to Syllable-Query will be the hash arrays <italic toggle="yes">h</italic>, designed to replace the data structures <italic toggle="yes">d</italic>, <italic toggle="yes">u</italic>, <italic toggle="yes">v</italic> used for virtual insertion and finding matches. For the binary query haplotype sequence <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, we let <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> be its raw syllabic sequence and <italic toggle="yes">z</italic> be its (compressed) syllabic sequence. In the case that <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we let <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> be a value distinct from the other <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> values, such as the size of <italic toggle="yes">r<sub>k</sub></italic>. We define <italic toggle="yes">h<sub>M</sub></italic> by the same hash function as above according to <italic toggle="yes">z</italic>. Similarly to before, after reading in the query haplotype in <italic toggle="yes">O</italic>(<italic toggle="yes">N</italic>) time, these sequences require <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>β</mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time to compute.</p>
      <sec>
        <title>2.4.1 Virtual insertion of query haplotype into panel without <italic toggle="yes">u</italic> and <italic toggle="yes">v</italic></title>
        <p>Out-of-panel query is facilitated by virtually inserting the query haplotype into the panel (<xref rid="btac734-B15" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic>, 2019a</xref>). The virtual locations of the query sequence are stored in an array <italic toggle="yes">t</italic> such that <italic toggle="yes">t<sub>k</sub></italic> is the position in <italic toggle="yes">a<sub>k</sub></italic> in which the query sequence would be, had it been included in the original panel. To calculate <italic toggle="yes">t<sub>k</sub></italic>, past solutions utilize the precomputed auxiliary arrays <italic toggle="yes">u</italic> and <italic toggle="yes">v</italic> at every site <italic toggle="yes">k</italic> to facilitate computing <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> based on <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">t<sub>k</sub></italic>, where <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the number of <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> for which <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> plus the number of <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> for which <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow></mml:mrow><mml:mi>j</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Specifically, <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>z</mml:mi><mml:mo>˙</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> otherwise. However, past solutions require binary sequences, and the notions of <italic toggle="yes">u</italic> and <italic toggle="yes">v</italic> do not efficiently generalize to <italic toggle="yes">M</italic> possible syllable values.</p>
        <p>To find the value of <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we binary search among the in-panel sequences for where <italic toggle="yes">z</italic> belongs. To compare <italic toggle="yes">z</italic> with another sequence <italic toggle="yes">x<sub>i</sub></italic> in one step of the sequence-wise binary search, we first compare their values at syllable <italic toggle="yes">k</italic>, and if they are equal, we binary search for the maximum <italic toggle="yes">b </italic>&lt;<italic toggle="yes"> k</italic> for which <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> to compare <italic toggle="yes">z</italic> and <italic toggle="yes">x<sub>i</sub></italic>. Once again, these fast comparisons are enabled by our hash arrays <italic toggle="yes">h</italic>. Our worst-case time complexity for virtual insertion over the <italic toggle="yes">n</italic> syllables is <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>M</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, since we binary search over <italic toggle="yes">M</italic> sequences and <italic toggle="yes">n</italic> syllables. In the average case, the <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time binary search would only occur in the small proportion of comparisons for which <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi>z</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (the expected number of such comparisons is <italic toggle="yes">ρ</italic>), and the range of the syllable-wise binary search can be minimized by setting its lower bound to the greatest value of <italic toggle="yes">b</italic> when <italic toggle="yes">t<sub>k</sub></italic> was being computed, since it is impossible for the start of the longest reverse prefix match with <italic toggle="yes">z</italic> at syllable <italic toggle="yes">k </italic>+<italic toggle="yes"> </italic>1 to be earlier than that at syllable <italic toggle="yes">k</italic>.</p>
      </sec>
      <sec>
        <title>2.4.2 Identifying long matches virtually near <italic toggle="yes">z</italic></title>
        <p>We define <italic toggle="yes">l</italic> as the minimum number of full syllables within any <italic toggle="yes">L</italic>-site match. To derive the expression for <italic toggle="yes">l</italic>, we must consider the case in which a match extends far into a syllable without completely covering it, i.e. <italic toggle="yes">B −</italic> 1 out of the <italic toggle="yes">B</italic> sites. If the remaining <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> sites are to minimize the number of full syllables covered, they would not complete the nearly filled syllable but rather extend in the opposite direction. The number of full syllables covered would then be <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌊</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mi>B</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>B</mml:mi></mml:mfrac></mml:mrow><mml:mo>⌋</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We consider matches spanning <italic toggle="yes">l</italic> syllables to be potential long matches, which we will abbreviate to ‘long matches’ or ‘matches’ with the implication that only matches spanning <italic toggle="yes">L</italic> sites after refinement will be reported; using bitwise operations on the raw syllable values, we can refine the single-site resolution boundaries for the <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> potential long matches in <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>β</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.3</xref> for details).</p>
        <p>In Syllable-Query, we search for ongoing long matches, as opposed to past solutions’ focus on terminated matches, due to the chaotic behavior upon match termination of general sequences in reverse prefix order. The definition of the positional prefix array guarantees that the sequences with the longest ongoing matches with a sequence <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> at syllable <italic toggle="yes">k</italic> occur in a contiguous block around position <italic toggle="yes">i</italic> in <italic toggle="yes">a<sub>k</sub></italic>. Thus, at syllable <italic toggle="yes">k</italic>, we can iterate upwards and downwards within <italic toggle="yes">a<sub>k</sub></italic> starting from <italic toggle="yes">t<sub>k</sub></italic> until no more long matches are available. Since the process for finding matches above <italic toggle="yes">z</italic> is analogous to that below <italic toggle="yes">z</italic>, we will only describe the process for finding matches above <italic toggle="yes">z</italic> with the implication that a similar process is performed for matches below <italic toggle="yes">z</italic> (‘above’ and ‘below’ refer to relative positions in the positional prefix array, with position 0 at the top and position <italic toggle="yes">M</italic> at the bottom).</p>
        <p>To search for matches above <italic toggle="yes">z</italic>, we maintain a pointer <italic toggle="yes">p</italic> in <italic toggle="yes">a<sub>k</sub></italic>. When there are no ongoing matches above <italic toggle="yes">z</italic>, we set <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and every time a match above <italic toggle="yes">z</italic> is found, <italic toggle="yes">p</italic> is decremented. We check for a match between <italic toggle="yes">z</italic> and <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>p</mml:mi><mml:mi>k</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> by checking whether <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Once this is false, there are no more matches above <italic toggle="yes">z</italic> to be found as of the current syllable <italic toggle="yes">k</italic>. Alternatively, we can cut back on the number of hash comparisons by binary searching for the final value of <italic toggle="yes">p</italic> (i.e. scouting out the block of new matches) before linearly iterating through the matches.</p>
      </sec>
      <sec>
        <title>2.4.3 Avoiding redundant counting of matches</title>
        <p>From the process for identifying matches described above, it is evident that a match spanning <italic toggle="yes">s </italic>&gt;<italic toggle="yes"> l</italic> syllables will be counted <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> times, since that is the number of syllables <italic toggle="yes">k</italic> for which the matching sequence and <italic toggle="yes">z</italic> will match over syllables <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If a query yields matches with an average length significantly greater than the minimum length <italic toggle="yes">l</italic>, then the runtime would suffer. Thus, we seek to count every match exactly once.<statement id="mthst1"><p><sc>Lemma</sc> 1. <italic toggle="yes">Once a match with sequence x<sub>i</sub> is identified immediately above z, sequence x<sub>i</sub> must remain immediately above z until the match ends.</italic></p></statement></p>
        <p>Using Lemma 1 (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.4</xref> for the proof), we can avoid redundantly visiting a match immediately above <italic toggle="yes">z</italic> at every syllable <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, after identifying it for the first time at syllable <italic toggle="yes">k</italic>, by preemptively setting our pointer <italic toggle="yes">p</italic> to <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> rather than reconsidering the match. We further observe that Lemma 1 and its accompanying optimization can be generalized to any number of ongoing matches above <italic toggle="yes">z</italic>. That is, we maintain a running counter <italic toggle="yes">up<sub>on</sub></italic>, and at every syllable <italic toggle="yes">k</italic>, we set <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>u</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and every time another match is identified above <italic toggle="yes">z</italic>, we decrement <italic toggle="yes">p</italic> and increment <italic toggle="yes">up<sub>on</sub></italic>, thereby bypassing previously identified matches.</p>
        <p>The remaining task is to decrement <italic toggle="yes">up<sub>on</sub></italic> every time we reach the end of a previously ongoing match. Let us maintain an array <italic toggle="yes">up<sub>end</sub></italic> such that <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">end</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> stores the number of ongoing matches that end at syllable <italic toggle="yes">k</italic>, so that we can reduce <italic toggle="yes">up<sub>on</sub></italic> by <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">end</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> before looking for matches at syllable <italic toggle="yes">k</italic>. To keep <italic toggle="yes">up<sub>end</sub></italic> updated, we must find the total match length <italic toggle="yes">s</italic> of every match we identify and increment <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">end</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. To do so efficiently, we binary search for the end of the match, checking whether <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to test if a syllable <italic toggle="yes">m</italic> is a valid match end. <xref rid="btac734-F2" ref-type="fig">Figure 2</xref> summarizes the process for finding long matches. Since there are <italic toggle="yes">n</italic> syllables over which we potentially must binary search, the runtime of extending the <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> potential matches is <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>c</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <fig position="float" id="btac734-F2">
          <label>Fig. 2.</label>
          <caption>
            <p>The process of finding long matches. The states of the algorithm at <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>4, 5, 6 are shown. The arrows indicate setting the pointer <italic toggle="yes">p</italic> to skip over the previously found matches. At <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>4, no matches have been previously found, so <italic toggle="yes">p</italic> is set to the sequence immediately above <italic toggle="yes">z</italic>, and the block of two matches above <italic toggle="yes">z</italic> are found. At <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>5, the two previously found matches are skipped, but no new matches are found. At <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>6, one of the previously found matches has terminated, so we skip over the remaining ongoing match to find the new match</p>
          </caption>
          <graphic xlink:href="btac734f2" position="float"/>
        </fig>
        <p>In genetic sequence data, recombination events result in match lengths of non-uniform distribution. To take advantage of the disproportionately large number of relatively short matches, we formulate the following heuristic: we begin by linear searching for the match end using the syllabic panel for several iterations (e.g. 10, covering 10<italic toggle="yes">B</italic> sites). If our match is among the few exceptionally long ones, we then switch to binary search with hashes for the remaining syllables. This way, we are able to find the match end in a small constant time without hashing in the average case, while bounding the runtime by <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the worst case.</p>
      </sec>
      <sec>
        <title>2.4.4 Allowing for queries in panels with unevenly distributed sites</title>
        <p>When querying with genetic distance (cM) or physical distance (bps), site locations are non-decreasing but not necessarily uniformly distributed. With proper bookkeeping and traversal, we can query with unevenly distributed sites without affecting the time or space complexity. For the sake of brevity, refer to our code for details.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We benchmarked Syllable-Query using <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>64 and <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>128 for reasons discussed in <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.1</xref>. For comparison, we refer to Algorithm 3 of <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref> as the full memory algorithm. We chose this algorithm because it is the most time- and space-efficient previously published solution to the <italic toggle="yes">L</italic>-long match query problem, according to the theoretical and empirical evidences in <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref>. Between the static and dynamic versions of the algorithms presented with d-PBWT, we chose to implement the static version of the full memory algorithm for consistency with the static nature of Syllable-Query and because the static version is more competitive in terms of memory. <xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic> (2021)</xref> also presented Algorithm 4, which solves the same problem, but we exclude it from our benchmarks because their benchmarks show that its runtime is not notably different from that of Algorithm 3.</p>
    <p>We observed the full memory usage on chromosome 21 (9793 sites) and chromosome 17 (22 215 sites) from UK Biobank (974 818 haplotypes) to be 150.4 GB and 341.2 GB. Since the asymptotic memory usage of the full memory algorithm is known to be proportional to the panel size <italic toggle="yes">MN</italic>, we extrapolated the full memory requirement for querying on the 22 autosomal chromosomes from UK Biobank consisting of 974 818 haplotypes and 658 720 markers to be 10.1 TB. In comparison, Syllable-Query used only 162 GB and 91.4 GB with <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>64 and <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>128, respectively, for the same task, yielding respective memory reduction factors of 62 and 110. <xref rid="btac734-F3" ref-type="fig">Figure 3</xref> provides the memory usage reductions for every chromosome based on its size. The positive trend between memory reduction and the number of sites is due to the positive trend between the number of sites and marker density per genetic distance, allowing the syllable dictionaries <italic toggle="yes">r</italic> to use less space per syllable. Over the 22 autosomal chromosomes collectively, we observed <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo>ρ</mml:mo><mml:mo>≈</mml:mo><mml:mn>28.3</mml:mn></mml:mrow></mml:math></inline-formula> for <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>64 and <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mo>ρ</mml:mo><mml:mo>≈</mml:mo><mml:mn>7.2</mml:mn></mml:mrow></mml:math></inline-formula> for <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>128, demonstrating that <italic toggle="yes">ρ</italic>, which is inversely proportional to the space taken by our dictionaries <italic toggle="yes">r</italic>, is likely to be of considerable magnitude for genetic sequence data due to linkage disequilibrium.</p>
    <fig position="float" id="btac734-F3">
      <label>Fig. 3.</label>
      <caption>
        <p>Memory reduction factors of Syllable-Query compared to the full memory algorithm versus the number of sites <italic toggle="yes">N</italic> over the UK Biobank autosomal chromosome genotype data (<italic toggle="yes">M </italic>=<italic toggle="yes"> </italic>974 818). Each dot is labeled with its chromosome number</p>
      </caption>
      <graphic xlink:href="btac734f3" position="float"/>
    </fig>
    <p>We benchmarked the runtime of Syllable-Query with respect to the number of matches, sites, and haplotypes on data from UK Biobank and the 1000 Genomes Project. In every panel, we randomly removed 50 individuals to use for our 100 query haplotypes and recorded the average CPU runtime (on a single core of an AMD EPYC 7763 64-Core Processor) and the average number of matches over the 100 queries. Our intention behind running many queries in succession was to stabilize the degree of runtime volatility due to factors such as the CPU cache, as well as to simulate the practical setting of matching a query panel against a predefined panel.</p>
    <p><xref rid="btac734-F4" ref-type="fig">Figure 4a</xref> shows the runtime of Syllable-Query to scale about linearly with the number of matches <italic toggle="yes">c</italic> and puts it into perspective with the full memory algorithm runtime. The most observable increases in the Syllable-Query runtime trend occur when <italic toggle="yes">L</italic> drops below <italic toggle="yes">kB −</italic> 1 for some small integer <italic toggle="yes">k</italic> (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.5</xref> for why). <xref rid="btac734-F4" ref-type="fig">Figure 4b</xref> motivates our match extension heuristic by confirming the relative shortness of the average match length. Moreover, the comparable slopes of the trendlines in <xref rid="btac734-F4" ref-type="fig">Figure 4a</xref> demonstrate that our virtual insertion and match extension heuristics are satisfactorily fast for real data (recall that the full memory algorithm is known to scale very well with the number of matches as it processes matches upon termination only). The <italic toggle="yes">y</italic>-intercepts of the trendlines further reveal that Syllable-Query is significantly faster than the full memory algorithm, even in the computationally unfavorable situations with small <italic toggle="yes">L</italic> mentioned above. We attribute the speedup in performance primarily to two reasons: (i) with <italic toggle="yes">B</italic> times fewer syllables than sites, the syllabic panel is much faster to iterate through. Although the reduced number of syllables is accompanied by a slight runtime factor <italic toggle="yes">β</italic> mentioned in <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.1</xref>, <italic toggle="yes">β</italic> only appears in the match refinement stage and therefore minimally affects runtime, evident in the only slightly higher slope of the <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>128 trendline than that of <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>64 in <xref rid="btac734-F4" ref-type="fig">Figure 4a</xref>. (ii) The CPU cache grants the CPU fast access to frequently used memory locations. Therefore, with less memory required by Syllable-Query, the CPU cache loads in data pertaining to more sites at a time, thereby saving time on data retrieval.</p>
    <fig position="float" id="btac734-F4">
      <label>Fig. 4.</label>
      <caption>
        <p>Benchmarking on UK Biobank and 1000 Genomes data. (<bold>a</bold>) The average query runtime versus the average number of matches <italic toggle="yes">c</italic> for each algorithm on chromosome 16 of UK Biobank (<inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mn>974</mml:mn><mml:mo>,</mml:mo><mml:mn>718</mml:mn><mml:mo>;</mml:mo><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>23</mml:mn><mml:mo>,</mml:mo><mml:mn>774</mml:mn></mml:mrow></mml:math></inline-formula>). (<bold>b</bold>) The average number of matches <italic toggle="yes">c</italic> versus the minimum match length <italic toggle="yes">L</italic>, where the <italic toggle="yes">x</italic>-axis of part (a) corresponds to the <italic toggle="yes">y</italic>-axis of part (b). (<bold>c</bold>) Average query runtime versus <italic toggle="yes">N</italic> on chromosome 1 sequence data from the 1000 Genomes Project (<italic toggle="yes">M </italic>=<italic toggle="yes"> </italic>4908). <italic toggle="yes">N</italic> was varied by choosing roughly uniformly distributed subsets of sites. (<bold>d</bold>) Average query runtime versus <italic toggle="yes">M</italic> on chromosome 1 of UK Biobank (<italic toggle="yes">N </italic>=<italic toggle="yes"> </italic>53 260). (Due to the high memory demands of the full memory algorithm, we ran it only for the first 4 data points; however, for readability they are not shown, since each of its runtimes is more than 50 times either one of the corresponding Syllable-Query runtimes.)</p>
      </caption>
      <graphic xlink:href="btac734f4" position="float"/>
    </fig>
    <p><xref rid="btac734-F4" ref-type="fig">Figure 4c</xref> confirms the roughly linear runtime of Syllable-Query with respect to <italic toggle="yes">N</italic>. The memory usage for the benchmark on sequence data depicted in <xref rid="btac734-F4" ref-type="fig">Figure 4c</xref> (<inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>908</mml:mn><mml:mo>;</mml:mo><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>468</mml:mn><mml:mo>,</mml:mo><mml:mn>094</mml:mn></mml:mrow></mml:math></inline-formula>) using <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>64 and <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>128 was, respectively, 7.9 GB (<inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mo>ρ</mml:mo><mml:mo>≈</mml:mo><mml:mn>61</mml:mn></mml:mrow></mml:math></inline-formula>) and 4.1 GB (<inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mo>ρ</mml:mo><mml:mo>≈</mml:mo><mml:mn>28</mml:mn></mml:mrow></mml:math></inline-formula>), as opposed to an extrapolated 500 GB required by the full memory algorithm. The significantly higher <italic toggle="yes">ρ</italic> values compared to those for the UK Biobank autosomal genotype data are to be expected, since genotype data, unlike sequence data, are limited to genetic variants, giving rise to more distinct syllable values. <xref rid="btac734-F4" ref-type="fig">Figure 4d</xref> shows a diminishingly positive correlation between query runtime and <italic toggle="yes">M</italic>, as to be expected by the <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula> factor involved in virtual insertion; note too that another cause of the positive correlation is the more effective CPU cache usage for smaller <italic toggle="yes">M</italic>. Due to the term <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>, as <italic toggle="yes">M</italic> approaches infinity, our time complexity (but not the full memory algorithm’s) approaches infinity, but our benchmarking reveals this growth rate to be negligible in practice.</p>
    <p>To verify the empirical correctness of Syllable-Query beyond the prior theoretical discussion, especially concerning the reliability of our hash function, we ran 1000 distinct queries each for <italic toggle="yes">L</italic> in terms of sites and cM on UK Biobank data, totaling over one million matches. For every query, Syllable-Query reported the same matches as the full memory algorithm.</p>
    <p>For genealogical search, query lengths of at least 5 or 7 cM and 700 single nucleotide polymorphisms (SNPs) are typically chosen, as established by simulations conducted by the DTC company 23andMe (<xref rid="btac734-B1" ref-type="bibr">23andMe, 2021</xref>; <xref rid="btac734-B20" ref-type="bibr">Roberts <italic toggle="yes">et al.</italic>, 2011</xref>). Despite the minimum query length required by Syllable-Query (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.1</xref>), we found that our site and cM requirements using deCODE genetic maps were well below these cutoffs (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix S5.6</xref>), so our requirements would not limit the application of Syllable-Query to genealogical search.</p>
  </sec>
  <sec>
    <title>4 Discussion and conclusions</title>
    <p>We have presented the Syllable-PBWT framework as a space-efficient alternative to the conventional binary PBWT. The main methodological contribution of this work is the redesign of the PBWT long match query algorithm by stripping away the most memory-intensive PBWT data structures. Transforming the binary panel into a syllabic panel can be viewed as abstracting away fine detail to lighten the memory load while retaining the information required for finding long matches. Most importantly, we introduce hash arrays to underpin Syllable-Query’s ability to query without the full-panel-sized arrays <italic toggle="yes">d</italic>, <italic toggle="yes">u</italic>, <italic toggle="yes">v</italic>. Although using <italic toggle="yes">d</italic>, <italic toggle="yes">u</italic>, <italic toggle="yes">v</italic> in a transient fashion for all-vs-all matching is appropriate, making them persistent for one-vs-all query is overly memory-costly. With the hash arrays <italic toggle="yes">h</italic>, we maintain the constant runtime exhibited by <italic toggle="yes">d</italic> for checking whether a match is long enough. Moreover, <italic toggle="yes">h</italic> can substitute <italic toggle="yes">u</italic> and <italic toggle="yes">v</italic> for virtual insertion but with the incurrence of a small worst-case <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>M</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> runtime factor for binary search.</p>
    <p>While in this article, we aimed to present the most space-efficient solution by putting all the above design elements together, it is worth reviewing their individual contributions. The biggest memory reduction comes from creating the syllabic panel and replacing the full-panel-sized <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> with syllabic versions of <italic toggle="yes">a</italic> and <italic toggle="yes">h</italic>. To reduce the size of the panel itself, we use coordinate compression to bring the overall memory reduction factor to about <italic toggle="yes">B</italic>. If memory efficiency is not the sole priority, one may mix-and-match the design elements to create simpler alternative algorithms with lower degrees of space efficiency.</p>
    <p>Although the primary goal of this work is to reduce the memory footprint of the long match query algorithms, some elements of our algorithms can be used for other purposes. For example, the coordinate compression in Syllable-PBWT can be a solution for lossless compression of the PBWT panel. Unlike run-length compression of the divergence array mentioned by <xref rid="btac734-B6" ref-type="bibr">Durbin (2014)</xref> which is not friendly for real-time querying, our Syllable-PBWT data structures support regular PBWT algorithms within the compressed format without decompression. Therefore, our algorithm can also be applied to all-vs-all matching; a naive method is to query each haplotype against the rest, although there may be a more efficient method.</p>
    <p>Conceptually, Syllable-PBWT is reminiscent of multiallelic-PBWT (mPBWT) (<xref rid="btac734-B16" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic>, 2019b</xref>) in that the sequence values are elements of a variably-sized alphabet. However, <xref rid="btac734-B16" ref-type="bibr">Naseri <italic toggle="yes">et al.</italic> (2019b</xref>) only presented algorithms for panel construction and all-vs-all matching in multiallelic data but none for one-vs-all query. A contribution of this work is the long match query algorithm absent from mPBWT. Of note, the Graph BWT (GBWT) is another multi-allelic extension of PBWT (<xref rid="btac734-B24" ref-type="bibr">Sirén <italic toggle="yes">et al.</italic>, 2019</xref>). GBWT builds a haplotype index in the space of a graph rather than linear sequences. While GBWT is more general, it is also quite heavy. There is a potential application of the syllable compression concept to GBWT.</p>
    <p>Please note that for applications such as phasing and imputation (<xref rid="btac734-B5" ref-type="bibr">Delaneau <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btac734-B21" ref-type="bibr">Rubinacci <italic toggle="yes">et al.</italic>, 2020</xref>) when searching for informative conditioning states, high <italic toggle="yes">B</italic> values such as 128 will result in missing short matches, especially in low SNP density array data. In such cases, it would be preferable to use a smaller <italic toggle="yes">B</italic>. Assuming a marker density of one site on average in every 3.5 kb, if <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>128, then the minimum cutoff for finding all matches should be at least 255 sites, corresponding to ∼0.893 Mb. For <italic toggle="yes">B </italic>=<italic toggle="yes"> </italic>64, the minimum cutoff will be ∼0.445 Mb.</p>
    <p>Despite the utility of <italic toggle="yes">L</italic>-long matches, one drawback is their requirement for match exactness, whereas real data often contain genotyping and phasing errors. Encouragingly, the contributions in this work could be adapted to a mismatch-tolerant variation of the <italic toggle="yes">L</italic>-long match query problem. Since past efficient solutions only consider matches upon termination, little potential remains for looking past match interruptions. In Syllable-Query, on the other hand, matches are considered as soon as they reach the threshold length and are then manually extended. Therefore, the extension process can be modified to continue as long as the number of mismatches remains below a specified parameter. The various starts and ends of the fragmented match could then be recorded in an event schedule, a more intricate development of the match end tracker in our current algorithm, to swiftly bypass the fragments composing previously found matches.</p>
    <p>Beyond methodological contributions, we showed that Syllable-PBWT and Syllable-Query delivered a memory reduction factor of over 100 in real sequences from the 1000 Genomes Project and the UK Biobank. For UK Biobank, while the state-of-the-art query algorithm (<xref rid="btac734-B22" ref-type="bibr">Sanaullah <italic toggle="yes">et al.</italic>, 2021</xref>) requires 10 TB of memory, Syllable-Query only requires 91 GB. This innovation will allow online genealogical search to be conducted with much more modest hardware and on even larger data sets in the future.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btac734_Supplementary_Data</label>
      <media xlink:href="btac734_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Acknowledgements</title>
    <p>This research has been conducted using the UK Biobank Resource under Application Number 24247.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Institutes of Health [R01HG010086 and R56HG011509 and OT2OD002751].</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btac734-B1">
      <mixed-citation publication-type="other"><collab>23andMe</collab> (<year>2022</year>) <italic toggle="yes">DNA Relatives: Detecting Relatives and Predicting Relationships</italic>. <ext-link xlink:href="https://customercare.23andme.com/hc/en-us/articles/212170958-DNA-Relatives-Detecting-Relatives-and-Predicting-Relationships" ext-link-type="uri">https://customercare.23andme.com/hc/en-us/articles/212170958-DNA-Relatives-Detecting-Relatives-and-Predicting-Relationships</ext-link> (7 January 2004, date last accessed).</mixed-citation>
    </ref>
    <ref id="btac734-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alomair</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2010</year>) <article-title>The power of primes: security of authentication based on a universal hash-function family</article-title>. <source>J. Math. Cryptol</source>., <volume>4</volume>, <fpage>121</fpage>–<lpage>148</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Campbell</surname><given-names>N.R.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>Genotyping-in-Thousands by sequencing (GT-seq): a cost effective SNP genotyping method based on custom amplicon sequencing</article-title>. <source>Mol. Ecol. Resour</source>., <volume>15</volume>, <fpage>855</fpage>–<lpage>867</lpage>.<pub-id pub-id-type="pmid">25476721</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Data structures to represent a set of k-long DNA sequences</article-title>. <source>ACM Comput. Surv</source>., <volume>54</volume>, <fpage>1</fpage>–<lpage>22</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Delaneau</surname><given-names>O.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Accurate, scalable and integrative haplotype estimation</article-title>. <source>Nat. Commun</source>., <volume>10</volume>, <fpage>5436</fpage>.<pub-id pub-id-type="pmid">31780650</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group> (<year>2014</year>) <article-title>Efficient haplotype matching and storage using the positional burrows–wheeler transform (PBWT)</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1266</fpage>–<lpage>1272</lpage>.<pub-id pub-id-type="pmid">24413527</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ekim</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Minimizer-space de Bruijn graphs: whole-genome assembly of long reads in minutes on a personal computer</article-title>. <source>Cell Syst</source>., <volume>12</volume>, <fpage>958</fpage>–<lpage>968.e6</lpage>.<pub-id pub-id-type="pmid">34525345</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Freyman</surname><given-names>W.A.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Fast and robust identity-by-descent inference with the templated positional burrows–wheeler transform</article-title>. <source>Mol. Biol. Evol</source>., <volume>38</volume>, <fpage>2131</fpage>–<lpage>2151</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karp</surname><given-names>R.M.</given-names></string-name>, <string-name><surname>Rabin</surname><given-names>M.O.</given-names></string-name></person-group> (<year>1987</year>) <article-title>Efficient randomized pattern-matching algorithms</article-title>. <source>IBM J. Res. Dev</source>., <volume>31</volume>, <fpage>249</fpage>–<lpage>260</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Khan</surname><given-names>R.</given-names></string-name>, <string-name><surname>Mittelman</surname><given-names>D.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Consumer genomics will change your life, whether you get tested or not</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>120</fpage>.<pub-id pub-id-type="pmid">30124172</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loh</surname><given-names>P.-R.</given-names></string-name></person-group><etal>et al</etal> (<year>2016</year>) <article-title>Reference-based phasing using the haplotype reference consortium panel</article-title>. <source>Nat. Genet</source>., <volume>48</volume>, <fpage>1443</fpage>–<lpage>1448</lpage>.<pub-id pub-id-type="pmid">27694958</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Naseri</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2019a</year>) <article-title>Efficient haplotype matching between a query and a panel for genealogical search</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>i233</fpage>–<lpage>i241</lpage>.<pub-id pub-id-type="pmid">31510689</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Naseri</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2019b</year>) <article-title>Multi-allelic positional Burrows-Wheeler transform</article-title>. <source>BMC Bioinformatics</source>, <volume>20</volume>, <fpage>279</fpage>.<pub-id pub-id-type="pmid">31167638</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Naseri</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2019c</year>) <article-title>RaPID: ultra-fast, powerful, and accurate detection of segments identical by descent (IBD) in biobank-scale cohorts</article-title>. <source>Genome Biol</source>., <volume>20</volume>, <fpage>143</fpage>.<pub-id pub-id-type="pmid">31345249</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Naseri</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>). <part-title>Efficient haplotype block matching in bi-directional PBWT</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Carbone</surname><given-names>A.</given-names></string-name>, <string-name><surname>El-Kebir</surname><given-names>M.</given-names></string-name></person-group> (eds.) <source>21st International Workshop on Algorithms in Bioinformatics (WABI 2021), Volume 201 of Leibniz International Proceedings in Informatics (LIPIcs)</source>. <publisher-name>Schloss Dagstuhl—Leibniz-Zentrum für Informatik</publisher-name>, <publisher-loc>Dagstuhl, Germany</publisher-loc>, pp. <fpage>19:1</fpage>–<lpage>19:13</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nielsen</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Genotype and SNP calling from next-generation sequencing data</article-title>. <source>Nat. Rev. Genet</source>., <volume>12</volume>, <fpage>443</fpage>–<lpage>451</lpage>.<pub-id pub-id-type="pmid">21587300</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M.E.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Self diagnosis of lynch syndrome using direct to consumer genetic testing: a case study</article-title>. <source>J. Genet. Couns</source>., <volume>20</volume>, <fpage>327</fpage>–<lpage>329</lpage>.<pub-id pub-id-type="pmid">21448764</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rubinacci</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Genotype imputation using the positional burrows wheeler transform</article-title>. <source>PLoS Genet</source>., <volume>16</volume>, <fpage>e1009049</fpage>.<pub-id pub-id-type="pmid">33196638</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sanaullah</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>d-PBWT: dynamic positional burrows–wheeler transform</article-title>. <source>Bioinformatics. btab117</source>, <volume>37</volume>, <fpage>2390</fpage>–<lpage>2397</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sirén</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Haplotype-aware graph indexes</article-title>. <source>Bioinformatics</source>, <volume>36</volume>, <fpage>400</fpage>–<lpage>407</lpage>.</mixed-citation>
    </ref>
    <ref id="btac734-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Slatkin</surname><given-names>M.</given-names></string-name></person-group> (<year>2008</year>) <article-title>Linkage disequilibrium—understanding the evolutionary past and mapping the medical future</article-title>. <source>Nat. Rev. Genet</source>., <volume>9</volume>, <fpage>477</fpage>–<lpage>485</lpage>.<pub-id pub-id-type="pmid">18427557</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Thompson</surname><given-names>E.A.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Identity by descent: variation in meiosis, across genomes, and in populations</article-title>. <source>Genetics</source>, <volume>194</volume>, <fpage>301</fpage>–<lpage>326</lpage>.<pub-id pub-id-type="pmid">23733848</pub-id></mixed-citation>
    </ref>
    <ref id="btac734-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname><given-names>Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>A fast and simple method for detecting identity-by-descent segments in large-scale data</article-title>. <source>Am. J. Hum. Genet</source>., <volume>106</volume>, <fpage>426</fpage>–<lpage>437</lpage>.<pub-id pub-id-type="pmid">32169169</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
