<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612829</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz341</article-id>
    <article-id pub-id-type="publisher-id">btz341</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Comparative and Functional Genomics</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Fully-sensitive seed finding in sequence graphs using a hybrid index</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Ghaffaari</surname>
          <given-names>Ali</given-names>
        </name>
        <xref ref-type="aff" rid="btz341-aff1">1</xref>
        <xref ref-type="aff" rid="btz341-aff2">2</xref>
        <xref ref-type="corresp" rid="btz341-cor1"/>
        <!--<email>ghaffari@mpi-inf.mpg.de</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Marschall</surname>
          <given-names>Tobias</given-names>
        </name>
        <xref ref-type="aff" rid="btz341-aff1">1</xref>
        <xref ref-type="aff" rid="btz341-aff2">2</xref>
        <xref ref-type="corresp" rid="btz341-cor1"/>
        <!--<email>t.marschall@mpi-inf.mpg.de</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz341-aff1"><label>1</label>Center for Bioinformatics, Saarland University, Saarbrücken, Germany</aff>
    <aff id="btz341-aff2"><label>2</label>Max Planck Institute for Informatics, Saarbrücken, Germany</aff>
    <author-notes>
      <corresp id="btz341-cor1">To whom correspondence should be addressed. <email>ghaffari@mpi-inf.mpg.de</email> or <email>t.marschall@mpi-inf.mpg.de</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i81</fpage>
    <lpage>i89</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz341.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Sequence graphs are versatile data structures that are, for instance, able to represent the genetic variation found in a population and to facilitate genome assembly. Read mapping to sequence graphs constitutes an important step for many applications and is usually done by first finding exact seed matches, which are then extended by alignment. Existing methods for finding seed hits prune the graph in complex regions, leading to a loss of information especially in highly polymorphic regions of the genome. While such complex graph structures can indeed lead to a combinatorial explosion of possible alleles, the query set of reads from a diploid individual realizes only two alleles per locus—a property that is not exploited by extant methods.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present the <italic>Pan-genome Seed Index (PSI)</italic>, a fully-sensitive hybrid method for seed finding, which takes full advantage of this property by combining an index over selected paths in the graph with an index over the query reads. This enables PSI to find all seeds while eliminating the need to prune the graph. We demonstrate its performance with different parameter settings on both simulated data and on a whole human genome graph constructed from variants in the 1000 Genome Project dataset. On this graph, PSI outperforms GCSA2 in terms of index size, query time and sensitivity.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The C++ implementation is publicly available at: <ext-link ext-link-type="uri" xlink:href="https://github.com/cartoonist/psi">https://github.com/cartoonist/psi</ext-link>.</p>
      </sec>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The reference genome of a species is intended to be the representative genome of its population. The ‘linear’ reference genomes in use today, at best, reflect a consensus genome of all individuals, but do not capture small variants and structural diversity of a population (<xref rid="btz341-B7" ref-type="bibr">Church <italic>et al.</italic>, 2015</xref>). When mapping reads to such references, this leads to a <italic>reference bias</italic>: reads supporting the reference allele have a higher chance of being aligned compared to reads supporting an alternative allele (<xref rid="btz341-B17" ref-type="bibr">Garrison <italic>et al.</italic>, 2018</xref>; <xref rid="btz341-B27" ref-type="bibr">Paten <italic>et al.</italic>, 2017</xref>; <xref rid="btz341-B30" ref-type="bibr">Rakocevic <italic>et al.</italic>, 2019</xref>; ). This limitation hampers the performance of downstream analyses such as variant calling. In particular, short reads coming from highly divergent regions, such as the human leukocyte antigen (HLA) genes, often remain unmapped or misaligned (<xref rid="btz341-B10" ref-type="bibr">Dilthey <italic>et al.</italic>, 2015</xref>).</p>
    <p>At the same time, advances in high-throughput sequencing technologies have enabled gathering extensive catalogs of genetic variation, for instance by the 1000 Genomes Project (1 KGP) (<xref rid="btz341-B2" ref-type="bibr">Auton <italic>et al.</italic>, 2015</xref>). With the advent of long-read technologies, the <italic>de novo</italic> assembly of individual human genomes has now become feasible, which additionally uncovers substantial amounts of structural variation missed in short-read-based studies (<xref rid="btz341-B1" ref-type="bibr">Audano <italic>et al.</italic>, 2019</xref>; <xref rid="btz341-B5" ref-type="bibr">Chaisson <italic>et al.</italic>, 2015</xref>, <xref rid="btz341-B6" ref-type="bibr">2017</xref>). Importantly, such assembly-based approaches are able to resolve the full sequences of alternative alleles. Translating this growing knowledge about genomic diversity in humans into improved analysis pipelines for (re-)sequencing data constitutes a pressing challenge in bioinformatics.</p>
    <p>Consequently, there is a growing interest in data structures capable of representing a species’ <italic>pan-genome</italic>, that is, to encode a comprehensive amount of sequence found in the genomes of a population (<xref rid="btz341-B8" ref-type="bibr">Computational Pan-Genomics Consortium, 2018</xref>). Pan-genomes can be represented in different ways that come with varying computational advantages and limitations. One simple approach consists in augmenting the reference genome with alternative alleles for important loci, a strategy that is implemented (to a limited extend) in the current version of the human reference genome GRCh38 (<xref rid="btz341-B7" ref-type="bibr">Church <italic>et al.</italic>, 2015</xref>). Graph-based representations, in contrast, can express polymorphisms more flexibly and succinctly, but introduce substantial computational challenges (<xref rid="btz341-B8" ref-type="bibr">Computational Pan-Genomics Consortium, 2018</xref>; <xref rid="btz341-B27" ref-type="bibr">Paten <italic>et al.</italic>, 2017</xref>). Initial studies have demonstrated clear benefits, including a reduced reference bias (<xref rid="btz341-B17" ref-type="bibr">Garrison <italic>et al.</italic>, 2018</xref>; <xref rid="btz341-B30" ref-type="bibr">Rakocevic <italic>et al.</italic>, 2019</xref>), enhanced variant calling (<xref rid="btz341-B13" ref-type="bibr">Eggertsson <italic>et al.</italic>, 2017</xref>), as well as improved allele inference of difficult loci, such as the HLA genes (<xref rid="btz341-B10" ref-type="bibr">Dilthey <italic>et al.</italic>, 2015</xref>, <xref rid="btz341-B11" ref-type="bibr">2016</xref>).</p>
    <p>Despite these successes, considerable algorithmic challenges remain. In particular, we are not aware of any read alignment tool able to map reads to (arbitrary) graphs at speeds comparable to tools for mapping reads to linear sequences. Most read aligners, both for mapping to linear sequences and for mapping to graphs, rely on a <italic>seed-and-extend</italic> approach (<xref rid="btz341-B20" ref-type="bibr">Li and Homer, 2010</xref>; <xref rid="btz341-B32" ref-type="bibr">Reinert <italic>et al.</italic>, 2015</xref>). That is, they first find short (exact or approximate) matches, called <italic>seed hits</italic>, and subsequently <italic>extend</italic> these seed hits to obtain alignments. The seed finding step can be fundamentally more challenging on graphs than on sequences, because complex regions in the graph can give rise to a combinatorial explosion in the number of possible paths. Notably, the process of <italic>aligning</italic> reads to graphs is not disturbed by this, and efficient algorithms for aligning sequences to graphs exist (<xref rid="btz341-B24" ref-type="bibr">Myers and Miller, 1989</xref>; <xref rid="btz341-B25" ref-type="bibr">Navarro, 2000</xref>; <xref rid="btz341-B31" ref-type="bibr">Rautiainen <italic>et al.</italic>, 2019</xref>). In this article, we therefore focus on the seed finding step with a particular focus on handling variant-dense regions in the input graph.</p>
    <sec>
      <title>1.1 Related work</title>
      <p>Collections of similar sequences can be indexed using Burrows–Wheeler transform (BWT)-based techniques (<xref rid="btz341-B22" ref-type="bibr">Mäkinen <italic>et al.</italic>, 2010</xref>), which exploit similarities between the sequences in order to save space. We refer the reader to the review by <xref rid="btz341-B16" ref-type="bibr">Gagie and Puglisi (2015)</xref> for further discussion of related techniques for indexing collections of sequences and focus on specific techniques to index sequence-labeled graphs in the following.</p>
      <p>Most existing indexing schemes for sequence graphs attempt to index <italic>k</italic>-mers in the graph, and they can broadly be categorized as being either hashing based or BWT based. The first hashing-based approach was introduced by <xref rid="btz341-B35" ref-type="bibr">Schneeberger <italic>et al.</italic> (2009)</xref>, and several related approaches based on hashing <italic>k</italic>-mers have been put forward since then (<xref rid="btz341-B9" ref-type="bibr">Danek <italic>et al.</italic>, 2014</xref>; <xref rid="btz341-B13" ref-type="bibr">Eggertsson <italic>et al.</italic>, 2017</xref>; <xref rid="btz341-B21" ref-type="bibr">Limasset <italic>et al.</italic>, 2016</xref>; <xref rid="btz341-B28" ref-type="bibr">Petrov <italic>et al.</italic>, 2018</xref>).</p>
      <p>Instead of hashing methods, <italic>de Bruijn graphs</italic> can be used as a basis for indexing <italic>k</italic>-mers occurring in sequence graphs. The <italic>XBW transform</italic> (<xref rid="btz341-B15" ref-type="bibr">Ferragina <italic>et al.</italic>, 2009</xref>), which is an extension of the FM index (<xref rid="btz341-B14" ref-type="bibr">Ferragina and Manzini, 2005</xref>) to labeled trees, has inspired approaches like <italic>Succinct de Bruijn graphs</italic> by <xref rid="btz341-B4" ref-type="bibr">Bowe <italic>et al.</italic> (2012)</xref>, kFM-index by <xref rid="btz341-B34" ref-type="bibr">Rødland (2013)</xref> and GCSA by <xref rid="btz341-B36" ref-type="bibr">Sirén <italic>et al.</italic> (2014)</xref>. Later, GCSA2 (<xref rid="btz341-B38" ref-type="bibr">Sirén, 2017</xref>) was introduced to improve the original GCSA by employing the ideas of succinct de Bruijn graphs. This modification relaxed the constraints on cycles in the graph while it imposed an upper-bound limit on the length of query searches.</p>
      <p>The key limitation of all above approaches is the combinatorial explosion of the <italic>k</italic>-mer space as more variants are added to the sequence graph. Thus, the index size can grow exponentially which, consequently, increases the memory footprint and runtime of the read alignment. In order to handle human genomes, these methods therefore need to prune the input graph, which can potentially lead to breaking haplotype paths, or to removing known variants from the sequence graph.</p>
    </sec>
    <sec>
      <title>1.2 Contributions</title>
      <p>In this article, we propose the first scalable, fully-sensitive method for finding seeds in a node-labeled directed graph. We call our approach PSI, which is short for <italic>Pan-genome Seed Index</italic>. PSI is a hybrid approach that utilizes the indexes of both reference graph and query reads. We leverage the idea that the <italic>k</italic>-mer space in the read library is much more limited than that in the graph. In particular, it is independent of the number of variants in the graph.</p>
      <p>In a preprocessing phase, we construct a collection of paths through the graph and index them using a conventional FM index. Our method for selecting these paths is designed to cover as many <italic>k</italic>-mers present in the graph as possible. Our evaluation shows that this path index alone outperforms GCSA2—a highly optimized indexing method proposed by (<xref rid="btz341-B38" ref-type="bibr">Sirén, 2017</xref>)—in terms of index size, query time and sensitivity when indexing all SNVs with allele frequency above 1% found in the 1000 Genomes Project.</p>
      <p>Still, our path index does not reach full sensitivity; that is, it misses <italic>k</italic>-mers in variant-dense regions of the graph. We refer to such loci in the graph where the path index misses <italic>k</italic>-mers as <italic>uncovered loci</italic>. To rescue missed <italic>k</italic>-mers at uncovered loci, we index a <italic>chunk</italic> (=subset) of input reads at a time. We then <italic>traverse</italic> the graph, starting from all uncovered loci, and the read index in parallel. The full workflow is illustrated in <xref ref-type="fig" rid="btz341-F1">Figure 1</xref>. This approach turns out to be efficient in practice for multiple reasons: (i) by traversing read index and graph simultaneously, <italic>k</italic>-mers that are not represented in the read set are avoided, circumventing extra <italic>k</italic>-mers present in the graph; (ii) even when including all variants from the 1000 Genomes Project, the number of these uncovered loci remains manageable and (iii) the size of the chunks is a tuning parameter that can be adjusted such that the read index fits into the processor cache, which makes traversing it very fast. As a result, our hybrid indexing strategy reaches full sensitivity at a moderate overhead compared to the path-only index, and is (to our knowledge) the first scalable technique providing full sensitivity for large, variant-dense graphs.
</p>
      <fig id="btz341-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Conceptual overview of the PSI approach. A sequence graph and a set of reads are provided as inputs (yellow). The graph is preprocessed to create a path index (left/dark blue). The read set is split into chunks and seeds are indexed (right/red). Seed finding proceeds in two stages (middle/light blue)</p>
        </caption>
        <graphic xlink:href="btz341f1"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>2 Background</title>
    <sec>
      <title>2.1 Notation</title>
      <p>A <italic>sequence S</italic> of length <italic>n</italic> is a tuple <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mi>S</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> where Σ is a finite set <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> called <italic>alphabet</italic>. The alphabet set for a DNA sequence can be defined as <inline-formula id="IE3"><mml:math id="IM3"><mml:mrow><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>DNA</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi mathvariant="monospace">A</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">C</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">G</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="monospace">N</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <monospace>N</monospace> represents an unknown or ambiguous nucleotide. Since we primarily focus on DNA sequences in this study, the alphabet set is assumed to be the nucleotide alphabet denoted by Σ for simplicity throughout the article. The <italic>i</italic>th element of the sequence can be referred to as <italic>s<sub>i</sub></italic> and the sequence can be represented by concatenating all its elements <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. The <italic>text string T</italic> is a sequence terminated by a sentinel <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mo>$</mml:mo><mml:mo>∉</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>. A <italic>substring</italic> of sequence <italic>S</italic> is indicated by <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>…</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. The substring <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>…</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> are called <italic>prefix</italic> and <italic>suffix</italic> of <italic>S</italic> and are denoted by <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo>…</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>…</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. The term <italic>k</italic>-mer refers to any substring of length <italic>k</italic> in a string.</p>
    </sec>
    <sec>
      <title>2.2 Sequence graphs</title>
      <p>Given an alphabet Σ, a tuple <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a <italic>sequence graph</italic> over Σ; where <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is a set of <italic>nodes</italic>, <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mi>E</mml:mi><mml:mo>⊆</mml:mo><mml:mi>V</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> is a set of directed edges, and <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:mo>λ</mml:mo><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is a function that maps each node in the graph to a <italic>label</italic> (see <xref ref-type="fig" rid="btz341-F3">Fig. 3a</xref>). We define <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> as a short hand for the label length of node <italic>v</italic>. We additionally assume that the graph is ‘deterministic’, in the sense that two outgoing edges starting at the same node are assumed to never target two nodes whose labels start with the same character. For a given node <inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, the <italic>out-degree</italic> of <italic>v</italic> is the number of outward edges from <italic>v</italic>, denoted by <italic>G<sub>out</sub></italic>(<italic>v</italic>), and <italic>in-degree G<sub>in</sub></italic>(<italic>v</italic>) is the number of incoming edges. Any base <italic>c</italic> in the graph can be located by a tuple (<italic>v</italic>, <italic>o</italic>) where <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> is the corresponding node containing <italic>c</italic> and <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is the offset of <italic>c</italic> in <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We call such a tuple <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> a <italic>locus</italic> in the graph.</p>
      <p>In the literature, sequence graphs are sometimes defined such that each node implicitly represents a sequences and its reverse complement. For simplicity, we stick to the simpler definition here and consider the graph representing only the forward strand. However, it can be easily extended to bi-directed sequence graphs. Alternatively, this complication can be avoided by additionally querying the reverse complement seeds.</p>
      <p>A path <italic>P</italic> in the graph is a sequence of nodes <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; where any two consecutive nodes in the path are connected by an edge in the graph. We define the sequence corresponding to the path <italic>P</italic> as the concatenation of its nodes: <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>…</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. A path in the graph that starts at offset <italic>l</italic> of the first node and ends at offset <italic>r</italic> – 1 of the last node is indicated by <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>l</mml:mi><mml:mi>r</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
      <p>The sequence graph of a species usually consists of multiple connected components corresponding to the multiple chromosomes. For each connected component <italic>M</italic>, we augment the graph with two additional nodes: a <italic>head node h<sub>M</sub></italic> and a <italic>tail node t<sub>M</sub></italic> with label <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>ϵ</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>ϵ</italic> denotes the empty string. We also add edges (<italic>h</italic>, <italic>v</italic>) for all <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> which has zero in-degree and edges (<italic>v</italic>, <italic>t</italic>) for all <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that has zero out-degree. There are some special paths of interest: a <italic>spanning path</italic> of the component <italic>M</italic> is a path starting from head node <italic>h<sub>M</sub></italic> and ending in tail node <italic>t<sub>M</sub></italic>. For any locus <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the graph <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, a <italic>k-path</italic> is defined to be a path starting at <italic>l</italic> whose corresponding sequence length is <italic>k</italic>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Methods</title>
    <p>We consider a <italic>set of reads</italic><inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mi>R</mml:mi><mml:mo>⊂</mml:mo><mml:msup><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>. First, a seed set <italic>Q</italic> is extracted from <italic>R</italic>:</p>
    <p>
      <statement id="mthst1">
        <label>Definition 1</label>
        <p><italic>(Seed set)</italic>. Given the set <italic>R</italic> of reads sequences, a length <italic>k </italic>&gt;<italic> </italic>0 and a distance <italic>d </italic>&gt;<italic> </italic>0. The <italic>seed set</italic><inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined as the set of all <italic>k</italic>-mers starting at positions <italic>md</italic> in the read sequences for any <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <p>Note that for <italic>d </italic>=<italic> </italic>1, the seed set <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is simply the set of all <italic>k</italic>-mers in reads <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula>, while for <italic>d </italic>=<italic> k</italic> it contains all <italic>non-overlapping k</italic>-mers. We now formalize the problem of seed finding as follows.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst2">
        <label>Problem 2</label>
        <p><italic>(Seed finding)</italic>. Given a set <italic>R</italic> of read sequences, a sequence graph <italic>G</italic>, and parameters <italic>k </italic>&gt;<italic> </italic>0, <italic>d </italic>&gt;<italic> </italic>0. Find all occurrences of seeds <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in paths in the graph <italic>G</italic>, where <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the seed set according to Definition 1.</p>
        <p>As discussed above, seed finding is a filtering strategy to limit the search space of sequence alignment algorithms. The choice of the seed length <italic>k</italic> controls the trade-off between specificity and sensitivity of this filter. Longer seeds increase specificity while reducing sensitivity. In this article, we assume the value of <italic>k</italic> to be given as a parameter, which is usually chosen dependent on read length and error rate of the underlying sequencing technology.
</p>
        <p>
          <boxed-text id="btz341-BOX1" position="float" orientation="portrait">
            <label>Algorithm 1.</label>
            <caption>
              <p> Path selection</p>
            </caption>
            <p><bold>Require:</bold> sequence graph <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, path count <italic>N</italic></p>
            <p>1: <bold>function</bold><sc>SelectNextNode</sc>(<italic>p</italic>, <italic>P</italic>)</p>
            <p>2:  <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>←</mml:mo><mml:mi>p</mml:mi><mml:mo>.</mml:mo><mml:mo> </mml:mo></mml:mrow></mml:math></inline-formula><sc>CoverableFrontierPath</sc>(|<italic>P</italic>|)</p>
            <p>3:  <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:mi>v</mml:mi><mml:mo>←</mml:mo><mml:mi>p</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula><sc>LastNode</sc>()</p>
            <p>4:  <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:mi mathvariant="italic">co</mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>5:  <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p>
            <p>6:  <bold>for</bold><inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mi>u</mml:mi><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mi>G</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula><sc>Adjacent</sc>(<italic>v</italic>) <bold>do</bold></p>
            <p>7:   <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mi mathvariant="italic">cov</mml:mi><mml:mo>←</mml:mo><mml:mi>P</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">C</mml:mi><mml:mi mathsize="small">OVERAGE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>′</mml:mo><mml:mo>·</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>8:   <bold>if</bold><inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:mi mathvariant="italic">co</mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo><mml:mi mathvariant="italic">cov</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>9:    <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:mi mathvariant="italic">co</mml:mi><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mi mathvariant="italic">cov</mml:mi></mml:mrow></mml:math></inline-formula></p>
            <p>10:   <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mi>u</mml:mi></mml:mrow></mml:math></inline-formula></p>
            <p>11: <bold>report</bold><italic>v<sub>c</sub></italic></p>
            <p>12: <bold>function</bold><sc>SelectPaths</sc>(<italic>G</italic>, <italic>N</italic>)</p>
            <p>13:  <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:mi>P</mml:mi><mml:mo>←</mml:mo><mml:mtext>empty</mml:mtext><mml:mo> </mml:mo><mml:mtext>set</mml:mtext></mml:mrow></mml:math></inline-formula></p>
            <p>14:  <bold>while</bold><italic>P</italic> contains less than <italic>N</italic> paths <bold>do</bold></p>
            <p>15:   <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:mi>p</mml:mi><mml:mo>←</mml:mo><mml:mi>G</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">H</mml:mi><mml:mi mathsize="small">EAD</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathsize="small">ODE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>16:   <bold>while</bold><italic>p</italic> can be extended <bold>do</bold></p>
            <p>17:    <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:mi>c</mml:mi><mml:mo>←</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathsize="small">ELECT</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathsize="small">EXT</mml:mi><mml:mi mathvariant="normal">N</mml:mi><mml:mi mathsize="small">ODE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>18:    <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:mi>p</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathsize="small">PPEND</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>19:  <bold>report</bold><italic>P</italic></p>
          </boxed-text>
        </p>
      </statement>
    </p>
    <sec>
      <title>3.1 Path index</title>
      <p>In the preprocessing phase, we create a <italic>path index</italic> of the genome graph (<xref ref-type="fig" rid="btz341-F1">Fig. 1</xref>, left/dark blue). The path index is essentially a compressed full-text index of a set of selected paths through the graph. Once constructed, it can be re-used for fast queries to find exact matches on these paths. The number of paths <italic>N</italic> is a tuning parameter of our indexing strategy; it can range from zero, which turns the path index off and seed finding happens purely in the traversal phase, to high numbers that lead to covering every <italic>k</italic>-path present in the graph. Constructing the path index proceeds in multiple steps:</p>
      <sec>
        <title>3.1.1 Path selection</title>
        <p>The first step for constructing the path index is selecting a set of <italic>N</italic> paths. This step aims to cover as many <italic>k</italic>-paths in the graph as possible.</p>
        <p>
          <statement id="mthst3">
            <label>Definition 3</label>
            <p><italic>(Path set coverage)</italic>. A path <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is <italic>covered</italic> by another path <italic>p</italic> if the node sequence of <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is a contiguous subsequence of the node sequence of <italic>p</italic>. We can generalize this to path sets: a set of paths <italic>P covers</italic> another path <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> if and only if there is a path <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> such that <italic>p</italic> covers <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. We define the <italic>coverage</italic> of path <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> by set <italic>P</italic> as the number of paths in <italic>P</italic> that cover <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:mi>p</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
          </statement>
        </p>
        <p>
          <statement id="mthst4">
            <label>Definition 4</label>
            <p>. A set of paths <italic>P</italic> in the graph <italic>k-covers</italic> a locus <inline-formula id="IE57"><mml:math id="IM57"><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> if and only if, for all <italic>k</italic>-paths <italic>p</italic> starting at <italic>l</italic>, there is a path in <italic>P</italic> that covers <italic>p</italic>.</p>
            <p>Based on Definition 4, <italic>P</italic> partitions the loci in the graph into two sets of <italic>covered</italic> and <italic>uncovered</italic> loci (for a given value of <italic>k</italic>). Every uncovered locus lowers the sensitivity of our path index. In order to reach full sensitivity, all uncovered loci later need to be visited in the <italic>graph traversal</italic> phase, which we discuss below in Section 3.3. Consequently, maximizing the number of loci covered by the <italic>N</italic> selected paths minimizes the number of loci to be traversed. On the other hand, longer paths, ideally spanning paths, represent all covered <italic>k</italic>-paths in a more memory efficient way than shorter paths covering the same set of <italic>k</italic>-paths. So, the goal of path selection is finding a subset of <inline-formula id="IE58"><mml:math id="IM58"><mml:mrow><mml:mi>P</mml:mi><mml:mo>⊂</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:math></inline-formula> such that the number of loci covered by <italic>P</italic> would be maximized, where <italic>U</italic> is the set of all possible paths that start from the head node <italic>h</italic> and end at tail node <italic>t</italic>. More precisely, we seek to select <italic>N</italic> paths for each connected components of the graph (e.g. corresponding to the different chromosomes), resulting in a set <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>·</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>m</italic> is the number components in the graph. For the sake of simplicity (and without loss of generality), we assume that the graph has only one component in the following.</p>
            <p>We propose a heuristic greedy algorithm for selecting a set of paths that aims at covering as many loci as possible. This algorithm assumes that the input sequence graph is a <italic>directed acyclic graph</italic> (DAG). Although we do not pursue this further in this article, the ideas we present could be extended to cyclic graphs, for instance by locally ‘unrolling’ the graph into a DAG as done by VG (<xref rid="btz341-B17" ref-type="bibr">Garrison <italic>et al.</italic>, 2018</xref>).</p>
            <p>Our algorithm starts from an empty set <italic>P</italic>, and proceeds by incrementally adding paths to the set until it contains the desired number of paths. The basic idea is simple: To select an additional path, we walk the graph from the head to the tail node and greedily try to cover sub-paths that we have not covered before. That is, we want to extend a new path <italic>p</italic> such that it contains a little piece that is not yet covered by any other path selected thus far. To do this, we examine a local window around the present end of our new path <italic>p</italic> and refer to this window as the <italic>frontier sub-path</italic> (<xref ref-type="fig" rid="btz341-F2">Fig. 2</xref>). But how far should we look back, i.e. how many nodes should be included in this frontier sub-path? To determine this, we use a heuristic that reflects how many paths might possibly exist in this local neighborhood: We call a path <italic>i-coverable</italic>, if the product of the out-degrees of the nodes in that path is at most <italic>i</italic>. Assume that we have selected <italic>i</italic> paths so far and <italic>p</italic> is the (<italic>i </italic>+<italic> </italic>1)-th path that we are presently selecting. We consider the shortest frontier sub-path of <italic>p</italic> that is <italic>i</italic>-coverable. Assume that <italic>v</italic> is the last node in <italic>p</italic>. To decide which node to append to <italic>p</italic> (i.e. choosing between <italic>u</italic> and <italic>w</italic> in <xref ref-type="fig" rid="btz341-F2">Fig. 2</xref>), we consider the paths selected so far and determine their coverage (see Definition 3) of the frontier sub-path extended by each node adjacent to <italic>v</italic>. We then choose the node with the lowest coverage, where ties are broken randomly.
</p>
            <p>Pseudocode for the path selection algorithm is given in Algorithm 1. We have visualized the outcome of this path selection algorithm for different numbers of paths in <xref ref-type="fig" rid="btz341-F3">Figure 3</xref> by using Sequence Tube Maps (<ext-link ext-link-type="uri" xlink:href="https://github.com/vgteam/sequenceTubeMap">https://github.com/vgteam/sequenceTubeMap</ext-link>). This greedy choice ultimately enumerates all paths in the graph for large values of <italic>N</italic>, while prioritizing them such that the first <italic>m</italic> paths aim to cover as many <italic>k</italic>-paths as possible in the graph. For simple graph topologies, such as the ones shown in <xref ref-type="fig" rid="btz341-F3">Figure 3</xref>, this strategy maximizes the number of covered <italic>k</italic>-paths.
</p>
          </statement>
        </p>
        <fig id="btz341-F2" orientation="portrait" position="float">
          <label>Fig. 2.</label>
          <caption>
            <p>Illustration of path selection algorithm. The path <italic>p</italic> that is currently being generated is shown in dark blue. The <italic>i</italic>-coverable frontier sub-path is indicated in yellow. The product of the out-degrees on this path (1 × 3 × 2 = 6) is smaller than <italic>i</italic></p>
          </caption>
          <graphic xlink:href="btz341f2"/>
        </fig>
        <fig id="btz341-F3" orientation="portrait" position="float">
          <label>Fig. 3.</label>
          <caption>
            <p>(<bold>a</bold>) Sequence graph with nodes displayed as boxes and edges indicated by blue arrows. The remaining three panels show the result of our path selection algorithm for different number of paths: (<bold>b</bold>) <italic>N </italic>=<italic> </italic>2, (<bold>c</bold>) <italic>N </italic>=<italic> </italic>4 and (<bold>d</bold>) <italic>N </italic>=<italic> </italic>8. Selected paths are represented by red lines and <italic>k</italic>-covered loci for <italic>k </italic>=<italic> </italic>10 are shown by dots</p>
          </caption>
          <graphic xlink:href="btz341f3"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.2 From paths to patches</title>
        <p>The set of selected paths <italic>P</italic> can contain redundancies. That is, there can be sub-paths shared between multiple paths in <italic>P</italic>. This redundancy not only affects the memory footprint of our index, it also slows down the process of locating the occurrences in the graph. We therefore modify the selection procedure to generate <italic>compressed</italic> path sequences that avoid duplicate sub-paths. To this end, we define a parameter <italic>T</italic>, named <italic>context length</italic>. The idea is to produce the same paths as before but to ‘cut out’ any redundant sub-paths while ensuring that all sub-paths of size <italic>T</italic> remain represented. Therefore, we add paths one-by-one and, before adding each path, determine which of its length-<italic>T</italic> sub-paths are not yet contained in any other path and refer to these sub-paths as <italic>novel</italic>. We remove all parts of the path that do not overlap with such a <italic>novel</italic> sub-path, and hence retain a set of disconnected <italic>patches</italic> of the path. This procedure ensures that all queries for strings of length at most <italic>T</italic> will remain unaffected. As a result, we usually obtain few genome-wide paths along with many smaller paths, the <italic>patches</italic>, cover variation sites.</p>
      </sec>
      <sec>
        <title>3.1.3 Indexing</title>
        <p>To build an index, we concatenate the set of these patches to form one sequence <italic>S<sub>P</sub></italic> wherein the patches <italic>p<sub>i</sub></italic> and <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are separated by a sentinel $<sub><italic>i</italic></sub> and <italic>S<sub>P</sub></italic> is terminated by $<sub><italic>M</italic></sub><sub>–1</sub>, with <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:msub><mml:mrow><mml:mo>$</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∉</mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>DNA</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>. Then, we construct an FM index of <italic>S<sub>P</sub></italic> (<xref rid="btz341-B14" ref-type="bibr">Ferragina and Manzini, 2005</xref>), which we refer to as <italic>path index</italic>. The path index is accompanied by a two auxiliary data structures that allow us to later locate the nodes (and offsets within the nodes) for seed hits on these paths, which we will refer to as the <sc>Locate</sc> operation in Algorithm 2. This is facilitated by a data structure to support rank/select queries and a self-delimited integer vector encoded by Elias delta for storing the node IDs. The constructed path index can be used effectively to query any string shorter than the context length <italic>T</italic>. Note that smaller values of <italic>T</italic> usually lead to a smaller path index. In practice, we set <italic>T</italic> to the length of the seed hits we want to query. For the path index and the auxiliary data structures, we rely on the implementations available as part of the <monospace>sdsl-lite</monospace> library (<xref rid="btz341-B19" ref-type="bibr">Gog <italic>et al.</italic>, 2014</xref>).</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Chunk index</title>
      <p>One of the central ideas to enable full-sensitivity seed finding consists in processing the input read set <italic>R</italic> in chunks <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>C</mml:mi></mml:msub><mml:mo>⊂</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:math></inline-formula> and finding all seeds within a chunk simultaneously. To achieve this, we build an index over all seeds we want to query for the present read chunk <italic>R<sub>c</sub></italic>, that is, we index the seed set <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as introduced in Definition 1 (<xref ref-type="fig" rid="btz341-F1">Fig. 1</xref>, right/red). The underlying index structure could be a suffix tree, enhanced suffix array or an FM index as long as top-down traversal operations are supported. After some preliminary experimentation, we decided to employ suffix trees constructed in a write-only top-down (<sc>wotd</sc>) manner (<xref rid="btz341-B18" ref-type="bibr">Giegerich and Kurtz, 1995</xref>), since we observed best performance in practice and can tolerate the larger memory footprint compared to an FM index. <sc>Wotd</sc> trees are <italic>lazy</italic> suffix trees that are constructed during traversal and only evaluate parts of the tree that are actually traversed. Our key motivation for proceeding in chunks—rather than indexing the full read set—is rooted in the idea that the index over a chunk can fit in the processor cache (e.g. in L3 cache) and hence can answer queries swiftly in practice.</p>
    </sec>
    <sec>
      <title>3.3 Traversing graph, path index and chunk index</title>
      <p>Given a set of reads <italic>R</italic>, a seed length <italic>k</italic> and a seed distance <italic>d</italic>, our goal is to find all seed hits in a sequence graph <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, that is, to solve Problem 2. For this purpose, we propose a novel strategy that proceeds in two phases. First, we perform a simultaneous traversal of path index and chunk index, yielding all seed hits represented in the selected paths. Second, we perform a simultaneous traversal of all uncovered graph loci and the chunk index, yielded seed hits missed by the path index, typically in variant-dense regions of the graph.</p>
      <p>Even though represented by quite different data structures, sequence graph, path index and chunk index support a common set of abstract traversal operations. In the following, we describe our method in terms of such abstract operations and refer the reader to excellent text books on the details of these data structures (<xref rid="btz341-B23" ref-type="bibr">Mäkinen <italic>et al.</italic>, 2015</xref>; <xref rid="btz341-B26" ref-type="bibr">Ohlebusch, 2013</xref>) as well as to mature implementations in libraries such as Seqan (<xref rid="btz341-B12" ref-type="bibr">Döring <italic>et al.</italic>, 2008</xref>; <xref rid="btz341-B33" ref-type="bibr">Reinert <italic>et al.</italic>, 2017</xref>) and SDSL (<xref rid="btz341-B19" ref-type="bibr">Gog <italic>et al.</italic>, 2014</xref>).</p>
      <p>More concretely, all three data structures (graph, path index and chunk index) can be traversed using the following three operations:
<list list-type="bullet"><list-item><p><sc>InitTraversal</sc> returns an initial <italic>traversal location ℓ</italic></p></list-item><list-item><p><inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathsize="small">DVANCE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> starts from traversal location <italic>ℓ</italic>, consumes character <italic>σ</italic>, outputs the resulting location <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE68"><mml:math id="IM68"><mml:mo>∅</mml:mo></mml:math></inline-formula> in case reading <italic>σ</italic> from location <italic>ℓ</italic> is not possible</p></list-item><list-item><p><sc>Extensions</sc><inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> returns the set of possible characters <italic>σ</italic> for which <sc>Advance</sc><inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item></list></p>
      <p>In case of the suffix tree for the chunk index, a <italic>traversal location</italic> is described by a suffix tree node and an offset inside the node label, <sc>InitTraversal</sc> returns the root node and <sc>Advance</sc> walks down the tree along the corresponding labels. For an FM index (which we use as path index), a <italic>traversal location</italic> is usually characterized by an interval in the BWT, but just like for a suffix tree, traversal can be implemented such that <sc>Advance</sc> returns a non-empty location as long as the spelled string is a substring of the indexed text. For the graph, a traversal can start from any locus and <sc>InitTraversal</sc> therefore needs to be supplied with a graph locus (which consists of node <italic>v</italic> and offset <italic>o</italic>, as described above). <sc>Advance</sc> then walks along the graph in accordance with the node labels.</p>
      <sec>
        <title>3.3.1 Phase 1: finding seeds on paths</title>
        <p>To find seeds represented on the selected paths, we can simply query the path index. While, in principle, one could query each seed separately, we prefer to query all seeds in a chunk of reads at once through the simultaneous traversal of chunk index and path index (Algorithm 2 and <xref ref-type="fig" rid="btz341-F1">Fig. 1</xref>, Box 1). In this way, we benefit from the same chunk index that is also used in Phase 2 described below. Algorithm 2 assumes that the path index supports the additional operation <sc>Locate</sc>, which translates a traversal location in the path index into a set of corresponding locations in the graph (see Section 3.1).
</p>
        <p>
          <boxed-text id="btz341-BOX2" position="float" orientation="portrait">
            <label>Algorithm 2.</label>
            <caption>
              <p> Finding seed hits <italic>on</italic> paths by simultaneous traversal of path index and chunk index</p>
            </caption>
            <p><bold>Require:</bold> chunk index CI, path index PI, length <italic>k</italic></p>
            <p>1: <bold>function</bold><sc>FindSeedsOnPaths</sc>(CI, PI, <italic>k</italic>)</p>
            <p>2:  <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula><sc>InitTraversal</sc>()</p>
            <p>3:  <inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>PI</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula><sc>InitTraversal</sc>()</p>
            <p>4:  <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:mi mathvariant="italic">states</mml:mi><mml:mo>←</mml:mo><mml:mtext>empty</mml:mtext><mml:mo> </mml:mo><mml:mtext>queue</mml:mtext></mml:mrow></mml:math></inline-formula></p>
            <p>5:  <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:mi mathvariant="italic">states</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Push</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>6:  <bold>while</bold><italic>states</italic> is not empty <bold>do</bold></p>
            <p>7:   <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="italic">states</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula><sc>Pop</sc>()</p>
            <p>8:   <bold>if</bold><inline-formula id="IE77"><mml:math id="IM76"><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>9:     <inline-formula id="IE76"><mml:math id="IM77"><mml:mrow><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>ext</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathsize="small">XTENSIONS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mtext>PI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathsize="small">XTENSIONS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>10:    <bold>for</bold><inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:mo>σ</mml:mo><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>ext</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
            <p>11:     <inline-formula id="IE79"><mml:math id="IM79"><mml:mrow><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathsize="small">DVANCE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>12:     <inline-formula id="IE80"><mml:math id="IM80"><mml:mrow><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>PI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathsize="small">DVANCE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>13:     <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:mi mathvariant="italic">states</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathsize="small">USH</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>14:  <bold>else</bold></p>
            <p>15:    <bold>report</bold><inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:mtext>PI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathsize="small">OCATE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>PI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathsize="small">OCATE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
          </boxed-text>
        </p>
      </sec>
      <sec>
        <title>3.3.2 Phase 2: finding seeds off paths</title>
        <p>Since the path index can occasionally miss <italic>k</italic>-paths, we handle variant-dense parts of the graph in a second phase. During the selection of paths, we keep track of loci that are not covered by paths and store the set <italic>L</italic> of these uncovered loci. For each chunk, we examine all these uncovered loci and, starting from these loci, simultaneously traverse the graph and the chunk index (Algorithm 3 and <xref ref-type="fig" rid="btz341-F1">Fig. 1</xref>, Box 2). In this way, the seeds that are contained in the chunk of reads guide the traversal of the graph. This allows us to avoid enumerating all <italic>k</italic>-paths at the uncovered loci, which would be infeasible. For traversing an uncovered graph locus, the number of <sc>Advance</sc> operations is bounded by the size of the chunk sequence, i.e. <italic>C</italic> × <italic>m</italic>; where <italic>C</italic> is the number of reads in the chunk, and <italic>m</italic> is the average reads length. Thus, the total time complexity of finding seeds off paths is <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mi>C</mml:mi><mml:mi>m</mml:mi><mml:mo>Σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>L</italic> is the set of uncovered loci.
</p>
        <boxed-text id="btz341-BOX3" position="float" orientation="portrait">
          <label>Algorithm 3.</label>
          <caption>
            <p> Finding seed hits <italic>off</italic> paths by simultaneous traversal of graph and chunk index</p>
          </caption>
          <p><bold>Require:</bold> chunk index CI, graph <inline-formula id="IE84"><mml:math id="IM84"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>,</mml:mo><mml:mo>λ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, set of uncovered locations <italic>L</italic>, length <italic>k</italic></p>
          <p>1: <bold>function</bold><sc>FindSeedsOffPaths</sc>(CI, <italic>G</italic>, <italic>L k</italic>)</p>
          <p>2:  <bold>for</bold><inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
          <p>3:   <inline-formula id="IE86"><mml:math id="IM86"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>←</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></p>
          <p>4:   <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula><sc>InitTraversal</sc>()</p>
          <p>5:   <inline-formula id="IE88"><mml:math id="IM88"><mml:mrow><mml:mi mathvariant="italic">states</mml:mi><mml:mo>←</mml:mo><mml:mtext>empty</mml:mtext><mml:mo> </mml:mo><mml:mtext>queue</mml:mtext></mml:mrow></mml:math></inline-formula></p>
          <p>6:   <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:mi mathvariant="italic">states</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Push</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>7:   <bold>while</bold><italic>states</italic> is not empty <bold>do</bold></p>
          <p>8:    <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="italic">states</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">Pop</mml:mi></mml:mrow></mml:math></inline-formula>()</p>
          <p>9:    <bold>if</bold><inline-formula id="IE92"><mml:math id="IM91"><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
          <p>10:    <inline-formula id="IE91"><mml:math id="IM92"><mml:mrow><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>ext</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathsize="small">XTENSIONS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi>G</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mi mathsize="small">XTENSIONS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi mathvariant="normal">G</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>11:    <bold>for</bold><inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:mo>σ</mml:mo><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mrow><mml:mtext>ext</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><bold>do</bold></p>
          <p>12:     <inline-formula id="IE94"><mml:math id="IM94"><mml:mrow><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mi>G</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathsize="small">DVANCE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>13:     <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>←</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathsize="small">DVANCE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>14:     <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:mi mathvariant="italic">states</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathsize="small">USH</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mi>G</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>15:    <bold>else</bold></p>
          <p>16:     <bold>report</bold><inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:mo>{</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>}</mml:mo><mml:mo>×</mml:mo><mml:mtext>CI</mml:mtext><mml:mo>.</mml:mo><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathsize="small">OCATE</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mrow><mml:mtext>CI</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </boxed-text>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>4 Experimental results</title>
    <sec>
      <title>4.1 Implementation</title>
      <p>PSI has been implemented in C++. It gets the reads set in <monospace>FASTQ</monospace> and the graph in <monospace>vg</monospace> format as inputs, and finds occurrences of all seeds with given length <italic>k</italic> and distance <italic>d</italic>. The output is provided in <monospace>GAM</monospace> format which represents seed alignments to the graph. Both <monospace>vg</monospace> and <monospace>GAM</monospace> are file formats introduced by the VG toolkit to represent sequence graph and sequence alignment, respectively (<xref rid="btz341-B17" ref-type="bibr">Garrison <italic>et al.</italic>, 2018</xref>). In order to maintain interoperability between tools in this domain, we reuse these file formats. For internal usage, the graph is represented by xg, the succinct graph data structure of VG, which allows to access node sequences and connectivities efficiently. We use the <monospace>sdsl-lite</monospace> library (<xref rid="btz341-B19" ref-type="bibr">Gog <italic>et al.</italic>, 2014</xref>) for succinct and compressed data structures: bit vector with efficient <monospace>rank</monospace> and <monospace>select</monospace> operations, compressed integer vector using Elias delta coding and FM index. The <sc>wotd</sc>-tree we use is provided by the SeqAn2 library (<xref rid="btz341-B33" ref-type="bibr">Reinert <italic>et al.</italic>, 2017</xref>).</p>
      <p>All running times are measured on a system with a 3-GHz Intel Xeon E7-8857 processor running Debian 9.4 with Linux kernel 4.9.91. We used libvg version 1.7.0 and <monospace>sdsl-lite</monospace> version 2.1.1 for the benchmarks. Seed finding is done using a single thread.</p>
    </sec>
    <sec>
      <title>4.2 Datasets</title>
      <p>We benchmark our algorithm using both synthetic and real graphs. In both cases, we start from a linear reference genome and a set of small variants and use VG version 1.7.0 (<xref rid="btz341-B17" ref-type="bibr">Garrison <italic>et al.</italic>, 2018</xref>) to construct a corresponding graph (using vg construct command). This process results in a DAG with one bubble for each implanted variant.</p>
      <p><italic>Simulated graphs.</italic> To systematically explore parameter settings and to benchmark the performance across a wide range of graphs with different complexities, we created a simulated dataset. This dataset is constructed from the complete genome of <italic>Nasuia deltocephalinicola</italic>, a bacterial species with a short genome of around 112 kb (<xref rid="btz341-B3" ref-type="bibr">Bennett <italic>et al.</italic>, 2016</xref>). Starting from this linear genome, single-nucleotide variants (SNVs) are implanted uniformly at random throughout the genome with three different mutation rates (0.01, 0.1, 0.3) to obtain three graphs ranging from moderate variant density (0.01) to an extreme variant density (0.3).</p>
      <p><italic>1000 Genomes graphs.</italic> The real dataset consists of graphs constructed from the autosomes of the human reference genome (hs37d5) and small variants reported by Phase 3 of the 1000 Genome Project (<xref rid="btz341-B2" ref-type="bibr">Auton <italic>et al.</italic>, 2015</xref>). We created two versions of this graph, one constructed from all small variants, and a second one that only includes variants with an allele frequency above 1%. Statistics for the resulting graphs are reported in <xref rid="btz341-T1" ref-type="table">Table 1</xref>.</p>
      <table-wrap id="btz341-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Human genome variation graph statistics</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">Nodes</th>
              <th rowspan="1" colspan="1">Edges</th>
              <th rowspan="1" colspan="1">Loci</th>
              <th rowspan="1" colspan="1">SNPs</th>
              <th rowspan="1" colspan="1">Indels</th>
              <th rowspan="1" colspan="1">Multiallelic sites</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">AF &gt; 1%</td>
              <td rowspan="1" colspan="1">40 M</td>
              <td rowspan="1" colspan="1">54 M</td>
              <td rowspan="1" colspan="1">2 895 M</td>
              <td rowspan="1" colspan="1">13 M</td>
              <td rowspan="1" colspan="1">1 M</td>
              <td rowspan="1" colspan="1">167 K</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">All</td>
              <td rowspan="1" colspan="1">236 M</td>
              <td rowspan="1" colspan="1">323 M</td>
              <td rowspan="1" colspan="1">2 963 M</td>
              <td rowspan="1" colspan="1">81 M</td>
              <td rowspan="1" colspan="1">3 M</td>
              <td rowspan="1" colspan="1">447 K</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p><italic>Read simulation.</italic> To benchmark our seed finding method, we simulated one million reads of length 150 bp with error rate 1% for each graph. The reads were simulated from random haplotypes, created by a random walk through the respective graph. The number of haplotypes used for read simulation corresponds to the ploidy of underlying genome: one haplotype for the simulated graph (bacteria) and two haplotypes for the 1000 Genomes graphs (human). During seed finding, we query all non-overlapping seeds of length 30 bp.</p>
    </sec>
    <sec>
      <title>4.3 Performance on simulated graphs</title>
      <p>We used the controlled environments provided by the simulated graphs to comprehensively explore the properties of our path index when confronted with graphs of varying variant densities.</p>
      <p><italic>Index size.</italic> First, we examined the influence of the number of paths <italic>N</italic> on the path index size. When turning off the path compression, that is, indexing all paths in full without removing redundant parts, then the index size increases linearly in the number of paths (<xref ref-type="fig" rid="btz341-F4">Fig. 4</xref>, red curves). As shown by the cyan curves, the compression/patching considerably decreases the size of the index, particularly for simple graphs. In complex graphs, paths share fewer identical substrings that can be dropped. Another factor that affects the compression rate is the <italic>context length T</italic>. Higher value of <italic>T</italic> results in longer patches which leads to a bigger index. <xref ref-type="fig" rid="btz341-F4">Figure 4</xref> includes results for two context lengths 32 and 64. Recall that the <italic>context length</italic> imposes an upper limit for query pattern length, where 32 constitutes a typical value for seed finding in Illumina short reads.
</p>
      <fig id="btz341-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Compressed (patched) path index size in MB versus different number of paths with context lengths 32 and 64 compared to uncompressed (full) one for simulated dataset with mutation rates: (<bold>a</bold>) 0.01, (<bold>b</bold>) 0.1 and (<bold>c</bold>) 0.3</p>
        </caption>
        <graphic xlink:href="btz341f4"/>
      </fig>
      <p><italic>Indexing time.</italic><xref ref-type="fig" rid="btz341-F5">Figure 5</xref> shows the time spent on different phases of creating the path index, namely on path selection (‘pick’) on creating the FM index (‘index’) and on writing the index to disk (‘save’). As <xref ref-type="fig" rid="btz341-F5">Figure 5</xref> shows, the times spent on the indexing phase are dominated by the path selection phase, while the time for saving is negligible. The growth of the runtime of the path selection is slightly super-linear in practice.
</p>
      <fig id="btz341-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>Time spent on different phases of path indexing for simulated dataset with mutation rates: (<bold>a</bold>) 0.01, (<bold>b</bold>) 0.1 and (<bold>c</bold>) 0.3</p>
        </caption>
        <graphic xlink:href="btz341f5"/>
      </fig>
      <p><italic>Path coverage.</italic> The efficiency of the path selection algorithm in terms of covering <italic>k</italic>-mers (for <italic>k </italic>=<italic> </italic>30, referred to as ‘loci’) and graph nodes is plotted in <xref ref-type="fig" rid="btz341-F6">Figure 6</xref>. The number of uncovered loci is shown for different sizes of the path set <italic>P</italic>. These curves show a behavior that is consistent with the distribution of the number of SNPs covered by each <italic>k</italic>-mers (<xref ref-type="fig" rid="btz341-F7">Fig. 7</xref>). For the intermediate SNP density of 0.1 (middle), for example, we expect a 30-mer to cover 3 SNPs on average, which translates into 2<sup>3</sup> = 8 paths needed to cover all ‘versions’ of this 30-mer.
</p>
      <fig id="btz341-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>Number of uncovered loci/nodes by indexes with different number of paths for simulated dataset with mutation rates: (<bold>a</bold>) 0.01, (<bold>b</bold>) 0.1 and (<bold>c</bold>) 0.3</p>
        </caption>
        <graphic xlink:href="btz341f6"/>
      </fig>
      <fig id="btz341-F7" orientation="portrait" position="float">
        <label>Fig. 7.</label>
        <caption>
          <p>Histogram of SNPs frequency in 30-mers for simulated dataset with mutation rates: (<bold>a</bold>) 0.01, (<bold>b</bold>) 0.1 and (<bold>c</bold>) 0.3</p>
        </caption>
        <graphic xlink:href="btz341f7"/>
      </fig>
      <p><italic>Seed finding.</italic> We now employ the hybrid index using both the stages of querying the path index and traversing the graph to recover seeds that are missed by the path index. We measure the total runtime of both phases. To make the numbers comparable to the human data, where the same seed can sometimes occur many times, we divide the total runtime by the number of occurrences found to obtain the average runtime per seed query. <xref ref-type="fig" rid="btz341-F8">Figure 8</xref> shows the resulting seed query times for the three graphs as a function of number of selected paths and the chunk size. In line with our expectation, the query time decreases when adding more paths and when increasing the chunk size. For more variant-rich graphs, the queries become slower.
</p>
      <fig id="btz341-F8" orientation="portrait" position="float">
        <label>Fig. 8.</label>
        <caption>
          <p>Average query time per <italic>k</italic>-mer occurrence for different number of paths and chunk sizes (given in the number of reads/chunk) on simulated dataset with mutation rates: (<bold>a</bold>) 0.01, (<bold>b</bold>) 0.1 and (<bold>c</bold>) 0.3</p>
        </caption>
        <graphic xlink:href="btz341f8"/>
      </fig>
    </sec>
    <sec>
      <title>4.4 Performance on 1000 Genomes graphs</title>
      <p>Experiments on the large 1000 Genomes graphs reveal that the path index behaves similarly favorable as for the small simulated graphs. <xref ref-type="fig" rid="btz341-F9">Figure 9</xref> shows different measurements for the graph with all variants with allele frequency of 1% and above. We observe that our path compression (patching) routine is very effective in limiting the size of the index. Even when indexing patches corresponding to 256 paths through the full human genome, we observe path index sizes below 7 GB (<xref ref-type="fig" rid="btz341-F9">Fig. 9a</xref>). While we see the same super-linear growth in runtime as for the simulated graphs, the construction of the path index is easily feasible, with less than 10 h for 128 paths and less than 30 h for 256 paths (<xref ref-type="fig" rid="btz341-F9">Fig. 9b</xref>). Again, the number of uncovered <italic>k</italic>-mers is quickly driven down by adding more paths (<xref ref-type="fig" rid="btz341-F9">Fig. 9c</xref>).
</p>
      <fig id="btz341-F9" orientation="portrait" position="float">
        <label>Fig. 9.</label>
        <caption>
          <p>Human genome path index benchmark for different number of paths: (<bold>a</bold>) path index size, (<bold>b</bold>) indexing time and (<bold>c</bold>) number of uncovered loci/nodes</p>
        </caption>
        <graphic xlink:href="btz341f9"/>
      </fig>
      <p>In <xref ref-type="fig" rid="btz341-F10">Figure 10</xref>, we examine the dependency of the <italic>k</italic>-mer query performance on the chunk size, which reveals that finding seeds in chunks of 100 000 reads is most favorable. The performance becomes worse when using even larger chunks, which we attribute to cache effects.
</p>
      <fig id="btz341-F10" orientation="portrait" position="float">
        <label>Fig. 10.</label>
        <caption>
          <p>Average query time per <italic>k</italic>-mer for different number of paths and chunk sizes (given in the number of reads/chunk) on the human genome dataset: (<bold>a</bold>) allele frequency above 1%, (<bold>b</bold>) all variants</p>
        </caption>
        <graphic xlink:href="btz341f10"/>
      </fig>
      <p>Finally, we compare the performance to GCSA2, a state-of-the-art method for indexing graphs developed by <xref rid="btz341-B38" ref-type="bibr">Sirén (2017)</xref> and used in VG (<xref rid="btz341-B17" ref-type="bibr">Garrison <italic>et al.</italic>, 2018</xref>). The results are displayed in <xref rid="btz341-T2" ref-type="table">Table 2</xref>. For the graph with variants of AF &gt; 1%, we obtain an index less than half the size (6.3 GB) of that produced by GCSA2 (15 GB), while we only need slightly longer to construct it (28 h versus 22 h). Our path index (‘PSI/Path-only’) covers more <italic>k</italic>-mers (99.24% versus 99.09%) and allows for faster queries, 4.8 <underline>μ</underline>s per occurrence where GCSA2 needs 6.28 μs per occurrence—a speedup of 30.8%. When additionally using the graph traversal (‘PSI/Hybrid’) to rescue the uncovered <italic>k</italic>-mers, our query time is virtually the same as GCSA2 while reaching full sensitivity, which is not feasible with GSCA2.</p>
      <table-wrap id="btz341-T2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>Seed finding performance on the 1000 Genomes graphs</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">Index</th>
              <th align="center" rowspan="1" colspan="1">Indexing</th>
              <th align="center" rowspan="1" colspan="1">Covered</th>
              <th align="center" rowspan="1" colspan="1">Query</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">size</th>
              <th align="center" rowspan="1" colspan="1">time</th>
              <th align="center" rowspan="1" colspan="1">k-mers</th>
              <th align="center" rowspan="1" colspan="1">time</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">AF&gt;1%</td>
              <td rowspan="1" colspan="1">PSI/path-only</td>
              <td rowspan="1" colspan="1">6.3 GB</td>
              <td rowspan="1" colspan="1">28 h</td>
              <td rowspan="1" colspan="1">6 721 M (99.24%)</td>
              <td rowspan="1" colspan="1">4.82 μs/occ</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">PSI/hybrid</td>
              <td rowspan="1" colspan="1">6.3 GB</td>
              <td rowspan="1" colspan="1">28 h</td>
              <td rowspan="1" colspan="1">6 773 M (100%)</td>
              <td rowspan="1" colspan="1">6.20 μs/occ</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">GCSA2 order-128</td>
              <td rowspan="1" colspan="1">15 GB</td>
              <td rowspan="1" colspan="1">22 h<xref ref-type="table-fn" rid="tblfn1"><sup>a</sup></xref></td>
              <td rowspan="1" colspan="1">6 712 M (99.09%)</td>
              <td rowspan="1" colspan="1">6.28 μs/occ</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">All</td>
              <td rowspan="1" colspan="1">PSI/path-only</td>
              <td rowspan="1" colspan="1">64 GB</td>
              <td rowspan="1" colspan="1">56 h</td>
              <td rowspan="1" colspan="1">214 394 M (96.50%)</td>
              <td rowspan="1" colspan="1">8.12 μs/occ</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">PSI/hybrid</td>
              <td rowspan="1" colspan="1">64 GB</td>
              <td rowspan="1" colspan="1">56 h</td>
              <td rowspan="1" colspan="1">222 180 M (100%)</td>
              <td rowspan="1" colspan="1">21.05 μs/occ</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">GCSA2 order-128</td>
              <td rowspan="1" colspan="1">34 GB</td>
              <td rowspan="1" colspan="1">30 h<xref ref-type="table-fn" rid="tblfn1"><sup>a</sup></xref></td>
              <td rowspan="1" colspan="1">13 863 M (6.24%)</td>
              <td rowspan="1" colspan="1">20.03 μs/occ</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <label>a</label>
            <p>Excluding time spent on pruning the original graph.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The graph with all variants contains drastically more <italic>k</italic>-mers (22.2 × 10<sup>10</sup>) than the graph with variants of AF &gt; 1% (6.7 × 10<sup>9</sup>). In this setting, the pruning steps required to build the GCSA2 index (which we run as described in the GCSA2 documentation) lead to a drastic loss in the number of indexed <italic>k</italic>-mers: the GCSA2 index only captures 6.24% of all <italic>k</italic>-mers in the graph. Even though the lost <italic>k</italic>-mers are concentrated in the complex regions of the graph, we argue that making such regions accessible is one important objectives of switching from linear reference genomes to graphs in the first place. Using PSI/Hybrid, we reach full sensitivity for this graph with a comparable query time (21.05 μs for PSI/Hybrid and 20.03 μs for GCSA2).</p>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p>We have introduced an approach to index sequence graphs that scales to human genomes while delivering full sensitivity. Our path selection procedure coupled with an FM index results in a competitive index structure, even when used in isolation without the graph traversal phase. By traversing the graph and the chunk index simultaneously, we take advantage of the fact that the set of <italic>k</italic>-mers in the reads is more restricted than the one represented in the graph. In other words, we let the reads guide the traversal of the graph and, in this way, circumvent the combinatorial explosion of <italic>k</italic>-mers in the graph. For the first time, this techniques enables <italic>scalable full-sensitivity seed finding in variation graphs</italic>.</p>
    <p>Here, we focused on introducing a new algorithmic technique for finding seeds in variation graphs. Our results show that full-sensitivity seed finding is indeed possible in polynomial time and that it can be done efficiently in practice. We plan to use this method to build a full-read mapper by combining it with our recent algorithm for bit-parallel sequence-to-graph alignment (<xref rid="btz341-B31" ref-type="bibr">Rautiainen <italic>et al.</italic>, 2019</xref>).</p>
    <p>Recently, Sirén <italic>et al.</italic> (2018) have proposed to augment sequence graphs with paths that represent haplotypes found in a population, to then restrict the indexing to those haplotypes. This idea could naturally be combined with our method by replacing the path selection step accordingly, which we plan to explore in future research. Beyond that, <xref rid="btz341-B29" ref-type="bibr">Pritt <italic>et al.</italic> (2018)</xref> have argued that it might be beneficial to restrict the set of variants used for graph construction to a well-selected subset for two reasons: to avoid introducing unnecessary ambiguity and to simplify indexing. By providing a full-sensitivity index, we have removed the necessity for the latter, creating the opportunity for comprehensive evaluations on the trade-off between added ambiguity and reduced read mapping bias.</p>
  </sec>
  <sec>
    <title>Acknowledgement</title>
    <p>We thank Mikko Rautiainen for pointing out the polynomial time complexity of finding seeds off paths.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz341-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Audano</surname><given-names>P.A.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Characterizing the major structural variant alleles of the human genome</article-title>. <source>Cell</source>, <volume>176</volume>, <fpage>663</fpage>–<lpage>675.e19</lpage>.<pub-id pub-id-type="pmid">30661756</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Auton</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>A global reference for human genetic variation</article-title>. <source>Nature</source>, <volume>526</volume>, <fpage>68</fpage>–<lpage>74</lpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bennett</surname><given-names>G.M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Complete Genome sequences of the obligate symbionts “<italic>Candidatus Sulcia muelleri</italic>” and “Ca. <italic>Nasuia deltocephalinicola</italic>” from the Pestiferous Leafhopper Macrosteles quadripunctulatus (Hemiptera: Cicadellidae)</article-title>. <source>Genome Announ</source>., <volume>4</volume>, <fpage>e01604</fpage>–<lpage>e01615</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Bowe</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) <chapter-title>Succinct de Bruijn graphs</chapter-title> In: Raphael,B. and Tang,J. (eds) <source>Lecture Notes in Computer Science</source>. 
<publisher-name>Springer</publisher-name>, 
<publisher-loc>Berlin, Heidelberg</publisher-loc>, pp. <fpage>225</fpage>–<lpage>235</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Chaisson</surname><given-names>M.J.P.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Resolving the complexity of the human genome using single-molecule sequencing</article-title>. <source>Nature</source>, <volume>517</volume>, <fpage>608</fpage>–<lpage>611</lpage>.<pub-id pub-id-type="pmid">25383537</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Chaisson</surname><given-names>M.J.P.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) Multi-platform discovery of haplotype-resolved structural variation in human genomes. <source>Nat. Commun.</source>, doi: 10.1038/s41467-018-08148-z.</mixed-citation>
    </ref>
    <ref id="btz341-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Church</surname><given-names>D.M.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Extending reference assembly models</article-title>. <source>Genome Biol</source>., <volume>16</volume>, <fpage>13</fpage>.<pub-id pub-id-type="pmid">25651527</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B8">
      <mixed-citation publication-type="journal">Computational Pan-Genomics Consortium. (<year>2018</year>) 
<article-title>Computational pan-genomics: status, promises and challenges</article-title>. <source>Brief. Bioinform</source>., <volume>19</volume>, <fpage>118</fpage>–<lpage>135</lpage>.<pub-id pub-id-type="pmid">27769991</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Danek</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Indexes of large genome collections on a PC</article-title>. <source>PLoS One</source>, <volume>9</volume>, <fpage>e109384.</fpage><pub-id pub-id-type="pmid">25289699</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dilthey</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Improved genome inference in the MHC using a population reference graph</article-title>. <source>Nat. Genet</source>., <volume>47</volume>, <fpage>682</fpage>–<lpage>688</lpage>.<pub-id pub-id-type="pmid">25915597</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dilthey</surname><given-names>A.T.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>High-accuracy HLA type inference from whole-genome sequencing data using population reference graphs</article-title>. <source>PLoS Comput. Biol</source>., <volume>12</volume>, <fpage>1</fpage>–<lpage>16</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Döring</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2008</year>) 
<article-title>SeqAn an efficient, generic C++ library for sequence analysis</article-title>. <source>BMC Bioinform</source>., <volume>9</volume>, <fpage>11</fpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Eggertsson</surname><given-names>H.P.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Graphtyper enables population-scale genotyping using pangenome graphs</article-title>. <source>Nat. Genet</source>., <volume>49</volume>, <fpage>1654</fpage>–<lpage>1660</lpage>.<pub-id pub-id-type="pmid">28945251</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ferragina</surname><given-names>P.</given-names></name>, <name name-style="western"><surname>Manzini</surname><given-names>G.</given-names></name></person-group> (<year>2005</year>) 
<article-title>Indexing compressed text</article-title>. <source>J. ACM</source>, <volume>52</volume>, <fpage>552</fpage>–<lpage>581</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ferragina</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Compressing and indexing labeled trees, with applications</article-title>. <source>J. ACM</source>, <volume>57</volume>, <fpage>1</fpage>–<lpage>33</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gagie</surname><given-names>T.</given-names></name>, <name name-style="western"><surname>Puglisi</surname><given-names>S.J.</given-names></name></person-group> (<year>2015</year>) 
<article-title>Searching and indexing genomic databases via kernelization</article-title>. <source>Bioinform. Comput. Biol</source>., <volume>3</volume>, <fpage>12</fpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Garrison</surname><given-names>E.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title>. <source>Nat. Biotechnol</source>., <volume>36</volume>, <fpage>875</fpage>–<lpage>879</lpage>.<pub-id pub-id-type="pmid">30125266</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Giegerich</surname><given-names>R.</given-names></name>, <name name-style="western"><surname>Kurtz</surname><given-names>S.</given-names></name></person-group> (<year>1995</year>) 
<article-title>A comparison of imperative and purely functional suffix tree constructions</article-title>. <source>Sci. Comput. Program</source>., <volume>25</volume>, <fpage>187</fpage>–<lpage>218</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Gog</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) <chapter-title>From theory to practice: plug and play with succinct data structures</chapter-title> In: Gudmundsson,J. and Katajainen,J. (eds) <source>Experimental Algorithms</source>. 
<publisher-name>Springer International Publishing</publisher-name>, Switzerland, pp. <fpage>326</fpage>–<lpage>337</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Li</surname><given-names>H.</given-names></name>, <name name-style="western"><surname>Homer</surname><given-names>N.</given-names></name></person-group> (<year>2010</year>) 
<article-title>A survey of sequence alignment algorithms for next-generation sequencing</article-title>. <source>Brief. Bioinform</source>., <volume>11</volume>, <fpage>473</fpage>–<lpage>483</lpage>.<pub-id pub-id-type="pmid">20460430</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Limasset</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Read mapping on de Bruijn graphs</article-title>. <source>BMC Bioinform</source>., <volume>17</volume>, <fpage>237</fpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Mäkinen</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2010</year>) 
<article-title>Storage and retrieval of highly repetitive sequence collections</article-title>. <source>J. Comput. Biol</source>., <volume>17</volume>, <fpage>281</fpage>–<lpage>308</lpage>.<pub-id pub-id-type="pmid">20377446</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B23">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Mäkinen</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) <source>Genome-Scale Algorithm Design</source>. 
<publisher-name>Cambridge University Press, UK</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btz341-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Myers</surname><given-names>E.W.</given-names></name>, <name name-style="western"><surname>Miller</surname><given-names>W.</given-names></name></person-group> (<year>1989</year>) 
<article-title>Approximate matching of regular expressions</article-title>. <source>Bull. Mathemat. Biol</source>., <volume>51</volume>, <fpage>5</fpage>–<lpage>37</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Navarro</surname><given-names>G.</given-names></name></person-group> (<year>2000</year>) 
<article-title>Improved approximate pattern matching on hypertext</article-title>. <source>Theoret. Comput. Sci</source>., <volume>237</volume>, <fpage>455</fpage>–<lpage>463</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B26">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Ohlebusch</surname><given-names>E.</given-names></name></person-group> (<year>2013</year>) <source>Bioinformatics Algorithms</source>. 
<publisher-name>Oldenbusch Verlag, Germany</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btz341-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Paten</surname><given-names>B.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Genome graphs and the evolution of genome inference</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>665</fpage>–<lpage>676</lpage>.<pub-id pub-id-type="pmid">28360232</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Petrov</surname><given-names>S.N.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>An efficient algorithm for mapping of reads to a genome graph using an index based on Hash tables and dynamic programming</article-title>. <source>Biophysics</source>, <volume>63</volume>, <fpage>311</fpage>–<lpage>317</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Pritt</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) FORGe: prioritizing variants for graph genomes. bioRxiv10.1101/311720.</mixed-citation>
    </ref>
    <ref id="btz341-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rakocevic</surname><given-names>G.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Fast and accurate genomic analyses using genome graphs</article-title>. <source>Nat. Genet</source>., <volume>51</volume>, <fpage>354</fpage>–<lpage>362</lpage>.<pub-id pub-id-type="pmid">30643257</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rautiainen</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Bit-parallel sequence-to-graph alignment</article-title>. <source>Bioinformatics</source>.</mixed-citation>
    </ref>
    <ref id="btz341-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Reinert</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Alignment of next-generation sequencing reads</article-title>. <source>Ann. Rev. Genomics Human Genetics</source>, <volume>16</volume>, <fpage>133</fpage>–<lpage>151</lpage>.<pub-id pub-id-type="pmid">25939052</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Reinert</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>The SeqAn C++ template library for efficient sequence analysis: a resource for programmers</article-title>. <source>J. Biotechnol</source>., <volume>261</volume>, <fpage>157</fpage>–<lpage>168</lpage>.<pub-id pub-id-type="pmid">28888961</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rødland</surname><given-names>E.</given-names></name></person-group> (<year>2013</year>) 
<article-title>Compact representation of k-mer de Bruijn graphs for genome read assembly</article-title>. <source>BMC Bioinformatics</source>, <volume>14</volume>, <fpage>313.</fpage><pub-id pub-id-type="pmid">24152242</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Schneeberger</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2009</year>) 
<article-title>Simultaneous alignment of short reads against multiple genomes</article-title>. <source>Genome Biol</source>., <volume>10</volume>, <fpage>R98</fpage>.<pub-id pub-id-type="pmid">19761611</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Sirén</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Indexing graphs for path queries with applications in genome research</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>., <volume>11</volume>, <fpage>375</fpage>–<lpage>388</lpage>.<pub-id pub-id-type="pmid">26355784</pub-id></mixed-citation>
    </ref>
    <ref id="btz341-B37">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Sirén</surname><given-names>J.</given-names></name></person-group><etal>et al</etal><chapter-title>Haplotype-aware graph indexes</chapter-title> In: <person-group person-group-type="editor"><name name-style="western"><surname>Parida</surname><given-names>L.</given-names></name>, <name name-style="western"><surname>Ukkonen</surname><given-names>E.</given-names></name></person-group> (eds), <source>Proceedings of WABI</source>. 
<publisher-name>Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik GmbH</publisher-name>, 
<publisher-loc>Wadern/Saarbruecken, Germany</publisher-loc>, pp. <fpage>4:1</fpage>–<lpage>4:13</lpage>.</mixed-citation>
    </ref>
    <ref id="btz341-B38">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Sirén</surname><given-names>J.</given-names></name></person-group> (<year>2017</year>) Indexing variation graphs. In: <italic>2017 Proceedings of the Nineteenth Workshop on Algorithm Engineering and Experiments (ALENEX), Philadelphia, USA</italic> Society for Industrial and Applied Mathematics (SIAM), pp. <fpage>13</fpage>–<lpage>27</lpage>.</mixed-citation>
    </ref>
  </ref-list>
</back>
