<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311405</article-id>
    <article-id pub-id-type="pmid">37387139</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad272</article-id>
    <article-id pub-id-type="publisher-id">btad272</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RawHash: enabling fast and accurate real-time analysis of raw nanopore signals for large genomes</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6548-7863</contrib-id>
        <name>
          <surname>Firtina</surname>
          <given-names>Can</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
        <xref rid="btad272-cor1" ref-type="corresp"/>
        <!--firtinac@ethz.ch-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-0833-0042</contrib-id>
        <name>
          <surname>Mansouri Ghiasi</surname>
          <given-names>Nika</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-2581-8637</contrib-id>
        <name>
          <surname>Lindegger</surname>
          <given-names>Joel</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-3502-7401</contrib-id>
        <name>
          <surname>Singh</surname>
          <given-names>Gagandeep</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-4475-6945</contrib-id>
        <name>
          <surname>Cavlak</surname>
          <given-names>Meryem Banu</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-7393-4504</contrib-id>
        <name>
          <surname>Mao</surname>
          <given-names>Haiyu</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-0075-2312</contrib-id>
        <name>
          <surname>Mutlu</surname>
          <given-names>Onur</given-names>
        </name>
        <aff><institution>Department of Information Technology and Electrical Engineering, ETH Zurich</institution>, 8092 Zurich, <country country="CH">Switzerland</country></aff>
        <!--omutlu@ethz.ch-->
        <xref rid="btad272-cor1" ref-type="corresp"/>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad272-cor1">Corresponding author. Department of Information Technology and Electrical Engineering, ETH Zurich, Gloriastrasse 35, 8092 Zurich, Switzerland. E-mail: <email>firtinac@ethz.ch</email> (C.F.), <email>omutlu@ethz.ch</email> (O.M.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i297</fpage>
    <lpage>i307</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad272.pdf"/>
    <abstract>
      <title>Abstract</title>
      <p><bold>Summary:</bold> Nanopore sequencers generate electrical raw signals in real-time while sequencing long genomic strands. These raw signals can be analyzed as they are generated, providing an opportunity for real-time genome analysis. An important feature of nanopore sequencing, Read Until, can eject strands from sequencers without fully sequencing them, which provides opportunities to computationally reduce the sequencing time and cost. However, existing works utilizing Read Until either (i) require powerful computational resources that may not be available for portable sequencers or (ii) lack scalability for large genomes, rendering them inaccurate or ineffective. We propose RawHash, the first mechanism that can accurately and efficiently perform real-time analysis of nanopore raw signals for large genomes using a hash-based similarity search. To enable this, RawHash ensures the signals corresponding to the same DNA content lead to the same hash value, regardless of the slight variations in these signals. RawHash achieves an accurate hash-based similarity search via an effective quantization of the raw signals such that signals corresponding to the same DNA content have the same quantized value and, subsequently, the same hash value. We evaluate RawHash on three applications: (i) read mapping, (ii) relative abundance estimation, and (iii) contamination analysis. Our evaluations show that RawHash is the only tool that can provide high accuracy and high throughput for analyzing large genomes in real-time. When compared to the state-of-the-art techniques, UNCALLED and Sigmap, RawHash provides (i) <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mn>25.8</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.4</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> better average throughput and (ii) significantly better accuracy for large genomes, respectively. Source code is available at <ext-link xlink:href="https://github.com/CMU-SAFARI/RawHash" ext-link-type="uri">https://github.com/CMU-SAFARI/RawHash</ext-link>.</p>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union’s Horizon</institution>
          </institution-wrap>
        </funding-source>
        <award-id>101047160</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Swiss National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/501100001711</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>200021_213084</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="11"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>High-throughput sequencing (HTS) devices can generate a large amount of genomic data at a relatively low cost. HTS can be used to analyze a wide range of samples, from small amounts of DNA or RNA to entire genomes. Oxford Nanopore Technologies (ONT) is one of the most widely used HTS technologies that can sequence long genomic regions, called reads, with up to a few million bases. ONT devices use the nanopore sequencing technique, which involves passing a single DNA or RNA strand through a tiny pore, nanopore or channel, at an average speed of 450 bases per second (<xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>) and measuring the electrical current as the strand passes through. Nanopore sequencing enables two key features. First, nanopores provide the electrical raw signals in <italic toggle="yes">real-time</italic> as the DNA strand passes through a nanopore. Second, nanopore sequencing provides a functionality, known as Read Until (<xref rid="btad272-B11" ref-type="bibr">Loose et al. 2016</xref>), that can partially sequence DNA strands without fully sequencing them. These two features of nanopores provide opportunities for (i) real-time genome analysis and (ii) significantly reducing sequencing time and cost.</p>
    <p>Real-time analysis of nanopore raw signals using Read Until can reduce the sequencing time and cost per read by terminating the sequencing of a read whenever sequencing the full read is not necessary. The freed-up nanopore can then be used to sequence a different read. A purely computational mechanism can send a signal to eject a read from a nanopore by reversing the voltage if the partial sequencing of a read meets certain conditions for particular genome analysis, such as (i) reaching a desired coverage for a species in a sample (<xref rid="btad272-B14" ref-type="bibr">Payne et al. 2021</xref>) or (ii) identifying that a read does not originate from a certain genome of interest (i.e. a target region; <xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>) and hence, does not need to be fully sequenced. By terminating the sequencing of reads that do not correspond to the target region, the sequencer can spend time and resources on higher coverage sequencing of the reads that correspond to the target. This process is referred to as nanopore adaptive sampling. By providing high coverage at target regions and avoiding unessential sequencing of reads outside those regions, this approach can improve the quality of sequencing and the downstream analysis utilizing the obtained data.</p>
    <p>To effectively utilize adaptive sampling in nanopore sequencing, it is crucial to have computational methods that can accurately analyze the raw output signals from nanopores in real-time. These methods must provide (i) low latency and (ii) throughput matching or exceeding that of the sequencer (<xref rid="btad272-B4" ref-type="bibr">Dunn et al. 2021</xref>; <xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>). Several works propose adaptive sampling methods for real-time analysis of raw nanopore signals (<xref rid="btad272-B6" ref-type="bibr">Edwards et al. 2019</xref>; <xref rid="btad272-B1" ref-type="bibr">Bao et al. 2021</xref>; <xref rid="btad272-B4" ref-type="bibr">Dunn et al. 2021</xref>; <xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B14" ref-type="bibr">Payne et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>; <xref rid="btad272-B20" ref-type="bibr">Shih et al. 2022</xref>; <xref rid="btad272-B23" ref-type="bibr">Ulrich et al. 2022</xref>; <xref rid="btad272-B17" ref-type="bibr">Sadasivan et al. 2023</xref>; <xref rid="btad272-B19" ref-type="bibr">Senanayake et al. 2023</xref>). However, these works have three key limitations. First, most techniques mainly use powerful computational resources, such as GPUs (<xref rid="btad272-B1" ref-type="bibr">Bao et al. 2021</xref>; <xref rid="btad272-B14" ref-type="bibr">Payne et al. 2021</xref>), or specialized hardware (<xref rid="btad272-B4" ref-type="bibr">Dunn et al. 2021</xref>; <xref rid="btad272-B20" ref-type="bibr">Shih et al. 2022</xref>) due to the use of computationally intensive algorithms such as basecalling as we explain in detail in <xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>. This can make real-time genome analysis challenging for portable and low-cost nanopore-based sequencers, such as the ONT Flongle or MinION, which are not typically equipped with such resources. Therefore these techniques introduce challenges for using them in resource-constrained environments. Second, the sheer size of genomic data at the scale of large genomes (e.g. human genome) makes it challenging to process the data in real-time. This is because such large genomes require efficient and accurate similarity identification across a large number of regions. This renders many current methods (<xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>) inaccurate or useless for large genomes as they cannot either provide accurate results or match the throughput of nanopores for these genomes. Third, machine learning models used in past works (<xref rid="btad272-B6" ref-type="bibr">Edwards et al. 2019</xref>; <xref rid="btad272-B14" ref-type="bibr">Payne et al. 2021</xref>; <xref rid="btad272-B1" ref-type="bibr">Bao et al. 2021</xref>; <xref rid="btad272-B23" ref-type="bibr">Ulrich et al. 2022</xref>; <xref rid="btad272-B19" ref-type="bibr">Senanayake et al. 2023</xref>) to analyze raw nanopore signals often require retraining or reconfiguring the model to improve accuracy for a certain experiment, which can be a barrier to flexibly and easily performing real-time analysis without retraining or reconfiguring these models. To our knowledge, there is no work that can efficiently and accurately perform real-time analysis of raw nanopore signals on a large scale (e.g. whole-genome analysis for human) without requiring powerful computational resources, which can easily and flexibly be applied to a wide range of applications that could benefit from real-time nanopore raw signal analysis.</p>
    <p>Our goal is to enable efficient and accurate real-time genome analysis for large genomes. To this end, we propose <italic toggle="yes">RawHash</italic>, the <italic toggle="yes">first</italic> mechanism that can efficiently and accurately perform real-time analysis of raw nanopore signals for large genomes in resource-contained environments. Unlike all the past works, RawHash is the only mechanism that can efficiently scale to large genomes and perform accurate real-time genomic analysis without requiring computationally intensive algorithms such as basecalling. Our key idea is to encode regions of the raw nanopore signal into hash values such that similar signal regions can efficiently be identified by matching their hash values, facilitating efficient similarity identification between signals. However, enabling accurate hashing-based similarity identification in the raw signal domain is challenging because raw signals corresponding to the same DNA content are unlikely to have exactly the same signal amplitudes. This is because the raw signals generated by nanopores can vary each time the same DNA fragment is sequenced due to several factors impacting nanopores during sequencing, such as variations in the properties of the nanopores or the conditions in which the sequencing is performed (<xref rid="btad272-B3" ref-type="bibr">David et al. 2017</xref>). Although the similarity identification of raw signals is possible via calculating the Euclidean distance between a sequence of signals in a multi-dimensional space (<xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>), such an approach can become impractical when dealing with larger sequences as the number of dimensions increases with the length of the sequences. This increase in dimensionality can lead to computational complexity and the curse of dimensionality, making it expensive and impractical.</p>
    <p>To address these challenges, RawHash provides three key mechanisms for efficient signal encoding and similarity identification. First, RawHash encodes signal values that have a wider range of values into a smaller set of values using a quantization technique, such that signal values within a certain range are assigned to the same encoded value. This helps to alleviate the probability of having varying signal values for the same DNA content and enables RawHash to directly match these values using a hashing technique. Second, RawHash concatenates the quantized values of multiple consecutive signals and generates a single hash value for them. The hashing mechanism enables RawHash to efficiently identify similar signal regions of these consecutive signal values by directly matching their corresponding hash values. Representing many consecutive signals with a single hash value increases the size of the regions examined during similarity identification without suffering from the curse of dimensionality. Using larger regions can substantially reduce the number of possible matching regions that need to be examined. RawHash is the <italic toggle="yes">first</italic> work that can accurately use hash values in the raw signal domain, which enables using efficient data structures commonly used in the sequence domain (e.g. hash tables in minimap2; <xref rid="btad272-B10" ref-type="bibr">Li 2018</xref>). Third, RawHash uses an existing algorithm, known as chaining (<xref rid="btad272-B10" ref-type="bibr">Li 2018</xref>), to find the colinear matches of hash values <italic toggle="yes">between</italic> signals to identify similar signal regions. These efficient and accurate mechanisms enable RawHash to perform real-time genome analysis for large genomes.</p>
    <p>While our proposed three key mechanisms have the potential to be used for various purposes in raw signal similarity identification, we design RawHash as a tool for mapping nanopore raw signals to their corresponding reference genomes in real-time. RawHash operates the mapping in two steps (i) indexing and (ii) mapping. First, in the indexing step, RawHash (i) converts the reference genome sequence into expected signal values by simulating the expected behavior of nanopores based on a previously known model, (ii) generates the hash values from these signals, and (iii) stores the hash values in a hash table for efficient matching. Second, in the mapping step, RawHash (i) generates the hash values from the raw signals in a streaming fashion, (ii) queries the hash table from the indexing step with these hash values to find the matching regions in the reference genome with the same hash value, and (iii performs chaining to find the similar region between the reference genome and the raw signal of a read.</p>
    <p>RawHash can utilize the unique functionalities of nanopore sequencing to reduce the sequencing time and cost in two ways. First, to avoid redundant sequencing and processing of each read, RawHash can use Read Until to eject a read before it is fully sequenced if RawHash identifies that the sequenced portion of the read can already be mapped to a reference genome. Second, to perform a cost- and time-efficient relative abundance estimation, RawHash can utilize Run Until to fully stop the entire sequencing of all subsequent reads after sequencing a certain amount of reads i.e. sufficient to make an accurate relative abundance estimation. We refer to such usage during abundance estimation as Sequence Until. Avoiding the redundant sequencing of further reads that are unlikely to substantially change the relative abundance estimation has the potential to significantly reduce the sequencing time and cost. To utilize Sequence Until, RawHash integrates a confidence calculation mechanism that evaluates the relative abundance estimations in real-time and fully stops the entire sequencing run if using more reads does not change its estimation. To stop the entire sequencing run for further reads, Run Until can be used to stop the entire sequencing run, which can enable the better utilization of nanopores. We find that Sequence Until can be applied to other mechanisms (e.g. UNCALLED) that can perform real-time relative abundance estimations. Prior work (<xref rid="btad272-B24" ref-type="bibr">Weilguny et al. 2023</xref>) proposes a technique to terminate the sequencing process when species in the sample reach a certain coverage depth. The key difference of Sequence Until is that it reduces the cost of sequencing for relative abundance estimation and is based on our adaptive, accurate, and low-cost confidence calculation during real-time abundance estimation.</p>
    <p>We evaluate RawHash on three important applications that can benefit from real-time genome analysis: (i) read mapping, (ii) relative abundance estimation, and (iii) contamination analysis. We compare RawHash with the state-of-the-art approaches, UNCALLED and Sigmap, which can be used with nanopore sequencers that may not be equipped with GPUs, such as the MinION devices. We evaluate RawHash, UNCALLED, and Sigmap in terms of their performance, accuracy, and their estimated benefits in reducing the sequencing time and cost.</p>
    <p>This article provides the following key contributions and major results:</p>
    <list list-type="bullet">
      <list-item>
        <p>We propose RawHash, the first mechanism that can efficiently and accurately find the similarities between raw nanopore signals and a reference genome for large genomes without requiring powerful computational resources such as GPUs.</p>
      </list-item>
      <list-item>
        <p>We propose the first sampling mechanism that can stop the entire sequencing run for certain applications when an accurate decision can be made without sequencing the entire sample, which we call Sequence Until.</p>
      </list-item>
      <list-item>
        <p>We extensively evaluate RawHash by comparing it with state-of-the-art approaches, UNCALLED and Sigmap, on various datasets ranging from small genomes (i.e. genomes with up to 100 million bases) to large genomes (e.g. human genome). Our results show that RawHash provides (i) comparable accuracy to UNCALLED and Sigmap for small genomes and (ii) significantly better accuracy for large genomes than UNCALLED and Sigmap.</p>
      </list-item>
      <list-item>
        <p>We show that Sigmap cannot perform real-time genome analysis for large genomes as it cannot match the throughput of nanopores.</p>
      </list-item>
      <list-item>
        <p>We provide the open source implementation of RawHash and the complete set of scripts to reproduce the results shown in this paper at <ext-link xlink:href="https://github.com/CMU-SAFARI/RawHash" ext-link-type="uri">https://github.com/CMU-SAFARI/RawHash</ext-link>.</p>
      </list-item>
    </list>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p>We propose RawHash, a mechanism that can efficiently and accurately identify similarities between raw nanopore signals of a read and a large reference genome in real-time (i.e. while the read is sequenced). The raw nanopore signal of each read is a series of electrical current measurements as a strand of DNA passes through a nanopore. The reference genome is a set of strings over the alphabet <monospace>A, C, G, T</monospace>. RawHash provides the mechanisms for generating hash values from both a raw nanopore signal and a reference genome such that similar regions between the two can be efficiently and accurately found by matching their hash values.</p>
    <sec>
      <title>2.1 Overview</title>
      <p><xref rid="btad272-F1" ref-type="fig">Figure 1</xref> shows the overview of how RawHash identifies similarities between raw nanopore signals of a read and a reference genome in four steps. First, RawHash pre-processes both (i) the raw nanopore signal and (ii) the reference genome into values that are comparable to each other. For raw signals, RawHash segments the raw signal into non-overlapping regions such that each region is expected to contain a certain amount of signal values that are generated from reading a fixed number <italic toggle="yes">k</italic> of DNA bases. Each such region is called an event (<xref rid="btad272-B3" ref-type="bibr">David et al. 2017</xref>). Each event is usually represented with a value derived from the signal values in the segment. For the reference genome, RawHash translates each substring of length <italic toggle="yes">k</italic> (called a <italic toggle="yes">k-mer</italic>) into their expected event values based on the nanopore model.</p>
      <fig position="float" id="btad272-F1">
        <label>Figure 1.</label>
        <caption>
          <p>Overview of RawHash.</p>
        </caption>
        <graphic xlink:href="btad272f1" position="float"/>
      </fig>
      <p>The event values from the reference genome are not directly comparable to the event values from raw nanopore signals due to variability in the current measurements in nanopores generating slightly different event values for the same k-mer (<xref rid="btad272-B3" ref-type="bibr">David et al. 2017</xref>). To generate the same values from slightly different events that may contain the same k-mer information, the second step of RawHash quantizes the event values from a larger set of values into a smaller set. The quantization technique ensures that the event values within a certain range are likely to be assigned to the same quantized value such that the effect of signal variation is alleviated, i.e. the same k-mer is likely assigned the same quantized value.</p>
      <p>Due to the nature of nanopores, each event usually represents a very small k-mer of length around <italic toggle="yes">k</italic> = 6 bases, depending on the nanopore model (<xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>). Such a short k-mer is likely to exist in a large number of locations in the reference genome, making it challenging to efficiently identify the correct one. To make the events more unique (i.e. such that they exist only in a small number of locations in the reference genome), the third step of RawHash combines multiple consecutive quantized events into a single hash value. These hash values can then be used to efficiently identify similar regions between raw signals and the reference genome by matching the hash values generated from their events using efficient data structures such as hash tables.</p>
      <p>Fourth, to map a raw nanopore signal of a read to a reference genome, RawHash uses a chaining algorithm (<xref rid="btad272-B10" ref-type="bibr">Li 2018</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>) that find colinear matching hash values generated from regions that are close to each other both in the reference genome and the raw nanopore signal.</p>
    </sec>
    <sec>
      <title>2.2 Event generation</title>
      <p>Our goal is to translate a reference genome sequence and a raw nanopore signal into comparable values. To this end, RawHash converts (i) each k-mer of the reference genome and (ii) each segmented region of the raw signal into its corresponding event.</p>
      <p><italic toggle="yes">Sequence-to-event conversion</italic>: To convert a reference genome sequence into a form that can be compared with raw nanopore signals, RawHash converts the reference genome sequence into event values in three steps, as shown in <xref rid="btad272-F2" ref-type="fig">Fig. 2</xref>.</p>
      <fig position="float" id="btad272-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Converting sequences to event values based on the k-mer model of a nanopore.</p>
        </caption>
        <graphic xlink:href="btad272f2" position="float"/>
      </fig>
      <p>First, RawHash extracts all k-mers from the reference genome sequence, where <italic toggle="yes">k</italic> depends on the nanopore. The <italic toggle="yes">k-mer model</italic> of a nanopore includes the information about the <italic toggle="yes">expected</italic> k-mer length of an event and the expected average event value for each k-mer based on certain variables affecting the signal outcome of the nanopore’s current measurements. For many nanopore models, ONT provides the k-mer model including recent R10 and R10.4. These models can also be generated by users (<xref rid="btad272-B21" ref-type="bibr">Simpson et al. 2017</xref>).</p>
      <p>Second, RawHash queries the k-mer model for each k-mer of the reference genome to convert k-mers into their expected event values. Although the k-mer model of a nanopore provides an extensive set of information for each possible k-mer, RawHash uses only the mean values of events that provide an average value for the signals in the same event since these mean values provide a sufficient level of meaningful information for comparison with the raw nanopore signals.</p>
      <p>Third, RawHash normalizes the event values from the same reference genome sequence (e.g. entire chromosome sequence or a contig) by calculating the standard scores (i.e. z-scores) of these events. RawHash uses these normalized values as event values since the same normalization step is taken for raw signals to avoid certain variables that may affect the range of raw signal amplitudes during sequencing (<xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>).</p>
      <p><italic toggle="yes">Signal-to-event conversion</italic>: Our goal is to accurately convert the series of raw nanopore signals into a set of values where each value corresponds to certain DNA sequences of fixed length <italic toggle="yes">k</italic>, k-mers, and consecutive values differ by one base. To achieve this, RawHash converts the raw signals into their corresponding values in three steps, as shown in <xref rid="btad272-F3" ref-type="fig">Fig. 3</xref>. First, to accurately identify the distinct regions in the raw signal that correspond to a certain k-mer from DNA, RawHash performs a segmentation step as described in a basecalling tool, Scrappie, and used by earlier works UNCALLED and Sigmap. The segmentation step aims to eliminate the factors that affect the speed of the DNA molecules passing through a nanopore, as the speed affects the number of signal measurements taken for a certain amount of bases in DNA. To perform the segmentation step, RawHash identifies the boundaries in the signal where the signal value changes significantly compared to the certain amount of previously measured signal values, which indicates a base change in the nanopore. Such boundaries are computed using a statistical test, known as Welch’s t-test (<xref rid="btad272-B16" ref-type="bibr">Ruxton 2006</xref>), over a rolling window of consecutive signals. RawHash performs this t-test for multiple windows of different lengths to avoid the variables that cause a change in the number of current measurements due to the varying speed of DNA through a nanopore, known as skip and stay errors (<xref rid="btad272-B3" ref-type="bibr">David et al. 2017</xref>). Signals that fall within the same segment (i.e. between the same measured boundaries) are usually called events since each event contains the signals from a reading of a fixed amount of DNA bases, k-mers.</p>
      <fig position="float" id="btad272-F3">
        <label>Figure 3.</label>
        <caption>
          <p>Detecting events from raw signals.</p>
        </caption>
        <graphic xlink:href="btad272f3" position="float"/>
      </fig>
      <p>Second, since the number of signals that each event includes is not constant across different events due to the stay and skip errors, RawHash generates a single value for each event to quickly avoid these potential errors and other factors that cause variations from reading the same amount of DNA bases. To this end, RawHash measures the mean value of the signals that fall within the same segment and uses this mean value for an event.</p>
      <p>Third, since the amplitudes of the signal measurements may significantly vary when reading k-mers at different times, RawHash normalizes the mean event values using the event values generated from the nanopore within the same certain time interval in a streaming fashion. Although this time interval parameter can be modified in our tool, the default configuration of RawHash processes the events of signals generated by the nanopore within one second. For normalization, RawHash uses the same z-score calculation that it uses for normalizing the event values generated from reference sequences as described earlier. RawHash uses these normalized values as event values when comparing with the event values from reference sequences.</p>
    </sec>
    <sec>
      <title>2.3 Quantization of events</title>
      <p>Our goal is to avoid the effects of generating different event values when reading the same k-mer content from nanopores so that we can identify k-mer matches by directly matching events. Although the segmentation and normalization steps explained in Section 2.2 can avoid the potential sequencing errors, such as stay and skip errors and significant changes in the current readings at different times, these approaches still do not guarantee to generate exactly the same event values when reading the same k-mer content. This is because slight changes in the normalized event values may occur when reading the same DNA content due to the high sensitivity and stochasticity of nanopores (<xref rid="btad272-B3" ref-type="bibr">David et al. 2017</xref>). Thus, it is challenging to generate the same event value for the same k-mer content after the segmentation and normalization steps. Since these event values generated from reading the same k-mer content are expected to be close to each other (<xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>), we propose a quantization mechanism that encodes event values so that events with close mean values can have the same quantized value in two steps as shown in <xref rid="btad272-F4" ref-type="fig">Fig. 4</xref>.</p>
      <fig position="float" id="btad272-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Quantization of two event values.</p>
        </caption>
        <graphic xlink:href="btad272f4" position="float"/>
      </fig>
      <p>First, to increase the probability of assigning the same value for similar event values, RawHash trims the least significant fractional part of mean values by using only the most significant <italic toggle="yes">Q</italic> bits of these mean event values from their binary format, which we represent as <italic toggle="yes">E[</italic>1, <italic toggle="yes">Q]</italic> for simplicity where <italic toggle="yes">E</italic> is the event value and <italic toggle="yes">E[</italic>1, <italic toggle="yes">Q]</italic> gives the most significant <italic toggle="yes">Q</italic> bits of <italic toggle="yes">E</italic>. We assume that the mean event values are represented by the standard single-precision floating-point format with the sign, exponent, and fraction bits. This enables RawHash to reduce the wide range of floating-point numbers into a smaller range <italic toggle="yes">without</italic> significantly losing from the accuracy such that event values closer to each other can be represented by the same value in the smaller range of values. We can perform this trimming technique without significant sensitivity loss because we observe that these normalized event values mostly use at most six digits from the fractional part of their values, leaving a large number of fractional bits useless.</p>
      <p>Second, to avoid using redundant bits that may carry little or no information in the most significant <italic toggle="yes">Q</italic> bits of an event value, RawHash prunes <italic toggle="yes">p</italic> bits after the most significant two bits of <italic toggle="yes">E[</italic>1, <italic toggle="yes">Q]</italic> such that <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> and the resulting <italic toggle="yes">quantized value</italic> is <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>Q</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. For simplicity, we show the quantized value of <italic toggle="yes">E</italic> as <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. By ignoring these <italic toggle="yes">p</italic> bits, we effectively pack <italic toggle="yes">Q</italic> bits into <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> bits without losing significant information from event values. We can perform such a pruning operation because we observe that the normalized event values are usually in the range <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>−</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that these <italic toggle="yes">p</italic> bits provide little information in distinguishing different event values due to the small range of values. We note that these <italic toggle="yes">Q</italic> and <italic toggle="yes">p</italic> values are parameters to RawHash and can empirically be adjusted based on the required sensitivity and quantization efficiency. This quantization technique enables RawHash to assign the same quantized values for a pair of <italic toggle="yes">close</italic> event values, <italic toggle="yes">E</italic> and <italic toggle="yes">F</italic>, that may be generated from reading the same k-mer such that <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>−</mml:mo><mml:mi>F</mml:mi><mml:mo>|</mml:mo><mml:mo>&lt;</mml:mo><mml:mo>ϵ</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mo>ϵ</mml:mo></mml:math></inline-formula> is small enough for two events to represent the same k-mer content. RawHash always uses the most significant two bits as these two bits consistently carry the most significant information of the normalized event values, including the sign bit.</p>
    </sec>
    <sec>
      <title>2.4 Generating the Hash values</title>
      <p>Our goal is to generate values for large regions of raw nanopore signals and reference sequences such that these values can be used to efficiently and accurately identify similarities between raw signals and a reference genome. To this end, RawHash generates hash values using quantized values of events in two steps, as shown in <xref rid="btad272-F5" ref-type="fig">Fig. 5</xref>. First, to avoid finding a large number of matches, RawHash uses the quantized values of <italic toggle="yes">n</italic> consecutive events to pack them in <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> bits while preserving the order information of these consecutive events. RawHash uses several consecutive events in a single hash value because matching a single event is likely to generate a larger number of matches for larger genomes as a single event usually corresponds to a k-mer of 6–9 bases depending on the nanopore model (<xref rid="btad272-B3" ref-type="bibr">David et al. 2017</xref>). It is essential to use several consecutive events to reduce the number of matching regions between raw signals and the reference genome by increasing the region that these consecutive events span.</p>
      <fig position="float" id="btad272-F5">
        <label>Figure 5.</label>
        <caption>
          <p>Generating a hash value from <italic toggle="yes">n</italic> consecutive quantized event values.</p>
        </caption>
        <graphic xlink:href="btad272f5" position="float"/>
      </fig>
      <p>Second, to efficiently and accurately find matches between large regions of raw signals and a reference genome using a constrained space, RawHash uses a low collision hash function to generate a 32-bit hash value from <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> bits of <italic toggle="yes">n</italic> consecutive quantized event values. Since <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be ˃32, using such a hash function is likely to increase the collision rate for dissimilar regions. To avoid inaccurate similarity identifications due to these incorrect collisions, RawHash requires several matches of hash values within close proximity for similarity identification, which we explain next.</p>
    </sec>
    <sec>
      <title>2.5 Seeding and mapping</title>
      <p>To efficiently identify similarities, RawHash uses hash values generated from raw nanopore signals and the reference genome in two steps. First, RawHash efficiently identifies matching regions between raw nanopore signals and a reference genome by matching their hash values. These hash values used for matching are usually known as seeds. Matching seeds enable efficiently finding similar regions between raw nanopore signals and a reference genome. Second, RawHash uses the chaining algorithm proposed in Sigmap (<xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>) to identify the best colinear matching seeds that are close to each other in both raw nanopore signal and a reference genome. The region that the best chain of seed matches cover is the mapping position that RawHash identifies as a similar region.</p>
      <p>The chaining algorithm is useful for two reasons. First, the chaining algorithm can tolerate mismatches and indels as it allows including gaps between seed matches, which enables finding similar regions with many seed matches without requiring the entire region to match exactly, as shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>. Second, incorrect seed matches due to collisions or our quantization mechanism that may generate the same quantized value for distinctly dissimilar events are likely to be filtered in the chaining step due to the difficulty of finding colinear seed matches in highly dissimilar regions. We note that we modify the original chaining algorithm in Sigmap by disabling the distance coefficient as RawHash does not calculate the distance between seed matches.</p>
      <p>To efficiently map raw signals to a reference genome, RawHash provides efficient data structures. To this end, RawHash uses hash tables to store the hash values generated from reference genomes (i.e. the indexing step) and efficiently query the same hash table with the hash values generated from the raw signal as the read is sequenced from a nanopore to find positions in the reference genome with matching hash values. RawHash uses the events in chunks (i.e. collection of events generated within a certain time interval) to find seed matches and perform chaining in a streaming fashion such that the chaining computation from previous chunks (i.e. seed matches) is transferred to the next chunk if the mapping is unsuccessful for the current chunk.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Evaluation methodology</title>
      <p>We implement RawHash as a tool for mapping raw nanopore signals to a reference genome. Similar to regular read mapping tools, RawHash has two steps to complete the mapping process: (i) indexing the reference genome and (ii) mapping raw signals. Although indexing is usually a one-time task that can be performed prior to the mapping step, the indexing of RawHash can be performed relatively quickly within a few minutes for large genomes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>). RawHash provides the mapping information using a standard pairwise mapping format. In our implementation, we provide an extensive set of parameters that allow configuring several options to fit RawHash for many other applications and nanopore models that we do not evaluate, such as configuring details about the nanopore model (e.g. number of bases per second), number of events that can be included in a single hash value, range of bits to quantize, enabling seeding techniques such as minimizers and fuzzy seed matching. We also provide a default set of parameters that we empirically choose for each common application of real-time genome analysis. These default parameters are set to accurately and efficiently analyze (i) very small (e.g. viral) genomes, (ii) small and mid-sized genomes (i.e. genomes with less than a few hundred million bases), (iii) large genomes (e.g. genomes with a few billion bases such as a human genome). We show the details regarding these parameter selections and the versions of tools in <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S5–S7</xref>.</p>
      <p>We evaluate RawHash in terms of its performance, peak memory usage, accuracy, and estimated benefits in sequencing time and cost compared to two state-of-the-art tools UNCALLED and Sigmap. For performance, we evaluate the throughput and overall runtime of each tool in terms of the number of bases they can process per second. Throughput determines if the tool is at least as fast as the speed of DNA passing through a nanopore. For many nanopore models (e.g. R9.4), a DNA strand passes through a pore at around 450 bases per second (<xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>). It is essential to provide a throughput higher than the throughput of the nanopore to enable real-time genome analysis. To calculate the throughput, we use the tool that UNCALLED provides, <monospace>UNCALLED pafstats</monospace>, which measures the throughput of the tool from the number of bases that the tool processes and the time it takes to process those bases. Although theoretically, it is not possible to exceed the throughput of a nanopore due to the speed of raw signal generation, for comparison purposes, such a limitation is ignored by <monospace>UNCALLED pafstats</monospace>. For overall runtime, we calculate CPU time and real-time using 32 threads. CPU time shows the overall amount of CPU seconds spent running a tool, while real-time shows the overall elapsed (i.e. wall clock) time. All of these tools support multi-threading, where multiple reads can be mapped simultaneously using a single thread for each read. For all of these tools, assigning a larger number of threads enables processing a larger number of reads in parallel, similar to the behavior of nanopore sequencers with hundreds to thousands of pores (i.e. channels). We note that the throughput and mapping time per read values are not affected by the thread counts as (i) these are measured per read and (ii) single thread performs the mapping of a single read.</p>
      <p>For accuracy, we evaluate the correctness of the mapping positions that each tool provides when compared to the ground truth mapping positions. To generate the ground truth mapping, we use a read mapping tool, minimap2 (<xref rid="btad272-B10" ref-type="bibr">Li 2018</xref>), to map the basecalled sequences of raw nanopore signals to their corresponding whole-genome references. We use <monospace>UNCALLED pafstats</monospace> to compare the mapping output of a tool with the ground truth mapping to find the number of true positives or <italic toggle="yes">TP</italic> (i.e. correct mappings), false positives or <italic toggle="yes">FP</italic> (i.e. incorrect mappings), and false negatives or <italic toggle="yes">FN</italic> (i.e. unmapped reads that are mapped in ground truth). Correct and incorrect mappings are identified based on the distance of the mapping positions between ground truth and the tool. To evaluate the accuracy, we calculate the precision (<inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>), recall (<inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) and the <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> (<inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>×</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) values.</p>
      <p>For estimating the benefits in sequencing time and cost of each tool, we calculate the average length of sequenced bases per read when using UNCALLED and RawHash and the average number sequenced chunk of signals for Sigmap and RawHash. We compare RawHash with Sigmap in terms of the number of chunks because Sigmap does not provide the number of bases when a read is unmapped, while both tools provide the number of chunks used when a read is mapped or unmapped. These chunks include a portion of the signal produced by a nanopore within a certain time interval, which is by default set as one second of data for both RawHash and Sigmap. The average length of bases and the number of chunks determine the estimations of how quickly each tool can make a mapping decision to activate Read Until before sequencing the remaining portion of a read, which indicates the potential savings from overall sequencing time and cost.</p>
      <p>We evaluate RawHash, UNCALLED, and Sigmap for three applications (i) read mapping, (ii) relative abundance estimation, and (iii) contamination analysis. Read mapping aims to map the raw signals to their corresponding reference genomes. Relative abundance estimation measures the abundance of each genome relative to other genomes in the same sample by mapping raw signals to a given set of reference genomes. Contamination analysis aims to identify if a sample is contaminated with a certain genome (e.g. a viral genome) by mapping raw signals to the reference genome that the sample may be contaminated with. For each tool, we use their default parameter settings in our evaluation.</p>
      <p>To evaluate each of these applications, we use real datasets that we list in <xref rid="btad272-T1" ref-type="table">Table 1</xref>. These datasets include both raw nanopore signals in the FAST5 format and their corresponding basecalled sequences in the FASTA format. We note that RawHash can also use POD5 files. For relative abundance estimation, we create a mock community using all the read sets from datasets D1 to D5, and the reference genome is the combination of reference genomes used in these datasets. We slightly modify the reference genome we use in the relative abundance estimation such that the sequence IDs in the reference genome provide additional information about the species (e.g. taxonomy IDs) to enable calculating relative abundance in real-time. For contamination analysis, we combine the SARS-CoV-2 read sets (D1) with human read sets (D5) to identify if the combined sample is contaminated with the SARS-CoV-2 sample by mapping raw signals in the combined set to the SARS-CoV-2 reference genome. For all evaluations, we use the AMD EPYC 7742 processor at 2.26 GHz to run the tools.</p>
      <table-wrap position="float" id="btad272-T1">
        <label>Table 1.</label>
        <caption>
          <p>Details of datasets used in our evaluation.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">Organism</th>
              <th align="center" rowspan="1" colspan="1">Reads (#)</th>
              <th align="center" rowspan="1" colspan="1">Bases (#)</th>
              <th align="center" rowspan="1" colspan="1">SRA accession</th>
              <th align="center" rowspan="1" colspan="1">Reference genome</th>
              <th align="center" rowspan="1" colspan="1">Genome size</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td colspan="7" rowspan="1">Read mapping</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D1</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">SARS-CoV-2</italic>
              </td>
              <td rowspan="1" colspan="1">1 382 016</td>
              <td rowspan="1" colspan="1">594M<xref rid="tblfn2" ref-type="table-fn"><sup>b</sup></xref></td>
              <td rowspan="1" colspan="1">CADDE Centre</td>
              <td rowspan="1" colspan="1">GCF_009858895.2</td>
              <td rowspan="1" colspan="1">29 903</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D2</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">E.coli</italic>
              </td>
              <td rowspan="1" colspan="1">353 317</td>
              <td rowspan="1" colspan="1">2365M</td>
              <td rowspan="1" colspan="1">ERR9127551</td>
              <td rowspan="1" colspan="1">GCA_000007445.1</td>
              <td rowspan="1" colspan="1">5M</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D3</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">Yeast</italic>
              </td>
              <td rowspan="1" colspan="1">49 989</td>
              <td rowspan="1" colspan="1">380M</td>
              <td rowspan="1" colspan="1">SRR8648503</td>
              <td rowspan="1" colspan="1">GCA_000146045.2</td>
              <td rowspan="1" colspan="1">12M</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D4</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">Green algae</italic>
              </td>
              <td rowspan="1" colspan="1">29 933</td>
              <td rowspan="1" colspan="1">609M</td>
              <td rowspan="1" colspan="1">ERR3237140</td>
              <td rowspan="1" colspan="1">GCF_000002595.2</td>
              <td rowspan="1" colspan="1">111M</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D5</td>
              <td rowspan="1" colspan="1">
                <italic toggle="yes">Human HG001</italic>
              </td>
              <td rowspan="1" colspan="1">269 507</td>
              <td rowspan="1" colspan="1">1584M</td>
              <td rowspan="1" colspan="1">FAB42260 Nanopore WGS</td>
              <td rowspan="1" colspan="1">T2T-CHM13 (v2)</td>
              <td rowspan="1" colspan="1">3117M</td>
            </tr>
            <tr>
              <td colspan="7" rowspan="1">Relative abundance estimation</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> </td>
              <td rowspan="1" colspan="1">D1–D5<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref></td>
              <td rowspan="1" colspan="1">2 084 762</td>
              <td rowspan="1" colspan="1">5531M</td>
              <td rowspan="1" colspan="1">D1–D5</td>
              <td rowspan="1" colspan="1">D1-D5</td>
              <td rowspan="1" colspan="1">3246M</td>
            </tr>
            <tr>
              <td colspan="7" rowspan="1">Contamination analysis</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> </td>
              <td rowspan="1" colspan="1">D1, D5</td>
              <td rowspan="1" colspan="1">1 651 523</td>
              <td rowspan="1" colspan="1">2 178M</td>
              <td rowspan="1" colspan="1">D1, D5</td>
              <td rowspan="1" colspan="1">D1</td>
              <td rowspan="1" colspan="1">29 903</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <label>a</label>
            <p>Dataset numbers (e.g. D1–D5) show the combined datasets.</p>
          </fn>
          <fn id="tblfn2">
            <label>b</label>
            <p>Base counts in millions (M).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p><italic toggle="yes">Evaluating Sequence Until</italic>: Our goal is to avoid redundant sequencing to reduce sequencing time and cost for relative abundance estimation. We find that the Run Until mechanism can be utilized to fully stop the sequencing run when the real-time relative abundance estimation reaches a certain confidence level to achieve accurate estimations, which we call Sequence Until. While a similar mechanism is evaluated to enrich the coverage depth of low-abundance species (<xref rid="btad272-B24" ref-type="bibr">Weilguny et al. 2023</xref>) using Read Until, we evaluate the potential benefits of Run Until for low-cost relative abundance estimations. We integrate a real-time confidence calculation mechanism in RawHash to activate the Sequence Until mechanism in three steps. First, RawHash measures the relative abundance estimation after every <italic toggle="yes">n</italic> reads that can be mapped to a reference genome in real-time. Second, to identify if the recently mapped reads provide substantial changes in the abundance estimations, RawHash performs a cross-correlation calculation between the last <italic toggle="yes">w</italic> estimations. Cross-correlation can identify outliers from a set of estimations to identify if the outlier is substantially different than other estimations, which indicates that recent reads can still change the relative abundance estimation, and more reads should be sequenced from the sample. Third, RawHash activates Sequence Until by fully stopping the sequencing using Run Until when there are no outliers in the last <italic toggle="yes">w</italic> estimations, which indicates a convergence to a certain relative abundance estimation, and further sequencing is unlikely to change this estimation. RawHash provides a set of parameters to adjust these parameters related to Sequence Until.</p>
      <p>We evaluate the benefits of Sequence Until by comparing (i) RawHash without Sequence Until and (ii) RawHash with Sequence Until in terms of (i) the difference in the relative abundance estimations and (ii) the estimated benefits in sequencing time and cost. To evaluate Sequence Until in a realistic sequencing environment where reads from different species can be sequenced in a random order, we randomly shuffle the reads in the relative abundance dataset and generate a set of 50 000 reads with a random order of species so that we can simulate this random behavior. We also find that Sequence Until can be applied to other mechanisms. To evaluate the potential benefits of Sequence Until, we simulate the benefits when using UNCALLED with Sequence Until and compare it with RawHash.</p>
    </sec>
    <sec>
      <title>3.2 Performance and peak memory</title>
      <p><xref rid="btad272-F6" ref-type="fig">Figure 6</xref> shows the throughput of regular nanopores that we use as a baseline and the throughput of the tools when mapping raw nanopore signals to each dataset for read mapping, contamination analysis, and relative abundance estimation. <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S3 and S4</xref> show the mapping time per read, and the computational resources required for indexing and mapping, respectively. We make six key observations. First, RawHash and UNCALLED are the only tools that can perform real-time genome analysis for large genomes, as they can provide higher throughputs than nanopores for all datasets. Sigmap cannot perform real-time genome analysis for large genomes as it can provide <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.6</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> throughput of a nanopore for human genome mapping and relative abundance estimations, respectively. RawHash can achieve high throughput as its seeding mechanism is based on efficiently matching hash values compared to the costly distance calculations that Sigmap performs for matching seeds, which shows poor scalability for larger genomes. Second, the throughput of UNCALLED is not affected by the genome size as it provides a near-constant throughput of around <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mn>16</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> for all applications. This is because UNCALLED uses FM-index (<xref rid="btad272-B7" ref-type="bibr">Ferragina and Manzini 2000</xref>) and a branching algorithm that provides robust scaling with respect to the reference genome size (<xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>). Third, the throughput of RawHash decreases with larger genomes as the seeding and chaining steps start taking up a larger fraction of the entire runtime of RawHash as shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>. Fourth, RawHash provides an average throughput <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mn>25.8</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.4</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> better than UNCALLED and Sigmap, while providing an average mapping speedup of <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mn>32.1</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.1</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> per read, respectively. Higher throughput with faster mapping times suggests that the mapping time improvements of RawHash are mainly due to its computational efficiency rather than the ability to sequence shorter prefixes of reads than UNCALLED and Sigmap. Fifth, for indexing, Sigmap usually requires a larger amount of computational resources in terms of both runtime and peak memory usage. Sixth, for mapping, UNCALLED is the most efficient tool in terms of the peak memory usage as it requires at most 10GB of peak memory while (i) RawHash requires ˂12GB of memory for almost all the datasets and (ii) Sigmap requires significantly larger memory space than both tools. RawHash has a larger memory footprint, <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>52</mml:mn></mml:mrow></mml:math></inline-formula>GB, than UNCALLED for large genomes. Although such large memory requirements for larger genomes can lead to challenges in using RawHash for mobile devices with limited computational resources, such a requirement can be mitigated by using more efficient seeding techniques such as minimizers, which we leave as future work. We conclude that RawHash provides significant benefits in improving the throughput and performance for the real-time analysis of large genomes while matching the throughput of nanopores.</p>
      <fig position="float" id="btad272-F6">
        <label>Figure 6.</label>
        <caption>
          <p>Throughput of each tool. Values inside the bars show the throughput ratio between each tool and a nanopore.</p>
        </caption>
        <graphic xlink:href="btad272f6" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.3 Accuracy</title>
      <p><xref rid="btad272-T2" ref-type="table">Table 2</xref> shows the accuracy results of tools for each dataset and application. We make four key observations. First, RawHash provides the best accuracy in terms of precision, recall, and <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> values compared to UNCALLED and Sigmap when mapping reads to large genomes (i.e. the human genome and the relative abundance estimation). RawHash can efficiently match several events using hash values, which is specifically beneficial in reducing the number of matching regions in large genomes and increasing the specificity due to finding longer matches compared to UNCALLED and Sigmap.</p>
      <table-wrap position="float" id="btad272-T2">
        <label>Table 2.</label>
        <caption>
          <p>Mapping accuracy.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">UNCALLED</th>
              <th align="center" rowspan="1" colspan="1">Sigmap</th>
              <th align="center" rowspan="1" colspan="1">RawHash</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td colspan="5" rowspan="1">Read mapping</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D1</td>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">0.9547</td>
              <td rowspan="1" colspan="1">
                <bold>0.9929</bold>
                <xref rid="tblfn3" ref-type="table-fn">
                  <sup>a</sup>
                </xref>
              </td>
              <td rowspan="1" colspan="1">0.9868</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes"> SARS-CoV-2</italic>
              </td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">
                <bold>0.9910</bold>
              </td>
              <td rowspan="1" colspan="1">0.5540</td>
              <td rowspan="1" colspan="1">0.8735</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">
                <bold>0.9725</bold>
              </td>
              <td rowspan="1" colspan="1">0.7112</td>
              <td rowspan="1" colspan="1">0.9267</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D2</td>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">0.9816</td>
              <td rowspan="1" colspan="1">
                <bold>0.9842</bold>
              </td>
              <td rowspan="1" colspan="1">0.9573</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes"> E.coli</italic>
              </td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">
                <bold>0.9647</bold>
              </td>
              <td rowspan="1" colspan="1">0.9504</td>
              <td rowspan="1" colspan="1">0.9009</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">
                <bold>0.9731</bold>
              </td>
              <td rowspan="1" colspan="1">0.9670</td>
              <td rowspan="1" colspan="1">0.9282</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D3</td>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">0.9459</td>
              <td rowspan="1" colspan="1">0.9856</td>
              <td rowspan="1" colspan="1">
                <bold>0.9862</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes"> Yeast</italic>
              </td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">
                <bold>0.9366</bold>
              </td>
              <td rowspan="1" colspan="1">0.9123</td>
              <td rowspan="1" colspan="1">0.8412</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">0.9412</td>
              <td rowspan="1" colspan="1">
                <bold>0.9475</bold>
              </td>
              <td rowspan="1" colspan="1">0.9079</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D4</td>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">0.8836</td>
              <td rowspan="1" colspan="1">
                <bold>0.9741</bold>
              </td>
              <td rowspan="1" colspan="1">0.9691</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes"> Green algae</italic>
              </td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">0.7778</td>
              <td rowspan="1" colspan="1">
                <bold>0.8987</bold>
              </td>
              <td rowspan="1" colspan="1">0.7015</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">0.8273</td>
              <td rowspan="1" colspan="1">
                <bold>0.9349</bold>
              </td>
              <td rowspan="1" colspan="1">0.8139</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D5</td>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">0.4867</td>
              <td rowspan="1" colspan="1">0.4287</td>
              <td rowspan="1" colspan="1">
                <bold>0.8959</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">
                <italic toggle="yes"> Human HG001</italic>
              </td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">0.2379</td>
              <td rowspan="1" colspan="1">0.2641</td>
              <td rowspan="1" colspan="1">
                <bold>0.4054</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">0.3196</td>
              <td rowspan="1" colspan="1">0.3268</td>
              <td rowspan="1" colspan="1">
                <bold>0.5582</bold>
              </td>
            </tr>
            <tr>
              <td colspan="5" rowspan="1">Relative abundance estimation</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">0.7683</td>
              <td rowspan="1" colspan="1">0.7928</td>
              <td rowspan="1" colspan="1">
                <bold>0.9484</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D1–D5</td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">0.1273</td>
              <td rowspan="1" colspan="1">0.2739</td>
              <td rowspan="1" colspan="1">
                <bold>0.3076</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">0.2184</td>
              <td rowspan="1" colspan="1">0.4072</td>
              <td rowspan="1" colspan="1">
                <bold>0.4645</bold>
              </td>
            </tr>
            <tr>
              <td colspan="5" rowspan="1">Contamination analysis</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">
                <bold>0.9378</bold>
              </td>
              <td rowspan="1" colspan="1">0.7856</td>
              <td rowspan="1" colspan="1">0.8733</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"> D1, D5</td>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">
                <bold>0.9910</bold>
              </td>
              <td rowspan="1" colspan="1">0.5540</td>
              <td rowspan="1" colspan="1">0.8735</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"> <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">
                <bold>0.9637</bold>
              </td>
              <td rowspan="1" colspan="1">0.6498</td>
              <td rowspan="1" colspan="1">0.8734</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <label>a</label>
            <p>Best results are highlighted with bold text.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Second, RawHash and UNCALLED can accurately perform contamination analysis while Sigmap suffers from significantly lower precision and recall values. Due to the nature of a contamination analysis, it is essential to correctly eliminate the genomes other than the contaminating genome (precision) without missing the correct mappings of reads from the contaminating genome (recall). Unfortunately, Sigmap cannot provide high values in any of these categories, making it significantly unsafe for contamination detection.</p>
      <p>Third, the precision of RawHash does not drop with the increased length in the reference genome due to the benefits of finding long matches, which provides a higher confidence in read mapping.</p>
      <p>Fourth, although RawHash does not provide the best accuracy when mapping reads to genomes smaller than the human genome, its accuracy is on par with UNCALLED and Sigmap for these genomes. UNCALLED and Sigmap can achieve high recall values as their mechanisms are best optimized for accurately handling matches in relatively smaller genomes with fewer repeats and ambiguous mappings (<xref rid="btad272-B9" ref-type="bibr">Kovaka et al. 2021</xref>; <xref rid="btad272-B25" ref-type="bibr">Zhang et al. 2021</xref>). We conclude that RawHash is the only tool that can accurately scale to performing real-time genome analysis for large genomes, especially with significantly high precision rates.</p>
      <p><italic toggle="yes">Relative abundance estimations</italic>: <xref rid="btad272-T3" ref-type="table">Table 3</xref> shows the relative abundance estimations that each tool makes and the Euclidean distance of their estimation to the ground truth estimation. We make two key observations. First, we find that RawHash provides the most accurate relative abundance estimations in terms of the estimation distance to the ground truth compared to UNCALLED and Sigmap. This observation correlates with the accuracy results we show in <xref rid="btad272-T2" ref-type="table">Table 2</xref> where RawHash provides the best overall accuracy for relative estimation, which results in generating the most accurate relative abundance estimations. Second, although Sigmap cannot perform real-time relative abundance estimation due to its throughput being lower than a nanopore (<xref rid="btad272-F6" ref-type="fig">Fig. 6</xref>), Sigmap provides accurate estimations that are on par with RawHash. This observation shows that while Sigmap provides mappings with more incorrect positions due to lower precision than RawHash (<xref rid="btad272-T2" ref-type="table">Table 2</xref>), these reads with incorrect mapping positions are mostly mapped to their correct species. We conclude that RawHash is the only tool that can accurately be applied to analyze relative abundance estimations while matching the throughput of nanopores at a large-scale based on the prior knowledge of the set of reference genomes to map the reads.</p>
      <table-wrap position="float" id="btad272-T3">
        <label>Table 3.</label>
        <caption>
          <p>Relative abundance estimations.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="6" align="center" rowspan="1">Estimated relative abundance ratios<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">SARS-CoV-2</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">E.coli</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Yeast</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Green algae</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Human</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">Distance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Ground Truth</td>
              <td rowspan="1" colspan="1">0.0929</td>
              <td rowspan="1" colspan="1">0.4365</td>
              <td rowspan="1" colspan="1">0.0698</td>
              <td rowspan="1" colspan="1">0.1179</td>
              <td rowspan="1" colspan="1">0.2828</td>
              <td align="center" rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED</td>
              <td rowspan="1" colspan="1">0.0026</td>
              <td rowspan="1" colspan="1">0.5884</td>
              <td rowspan="1" colspan="1">0.0615</td>
              <td rowspan="1" colspan="1">0.1313</td>
              <td rowspan="1" colspan="1">0.2161</td>
              <td rowspan="1" colspan="1">0.1895</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Sigmap</td>
              <td rowspan="1" colspan="1">0.0419</td>
              <td rowspan="1" colspan="1">0.4191</td>
              <td rowspan="1" colspan="1">0.1038</td>
              <td rowspan="1" colspan="1">0.0962</td>
              <td rowspan="1" colspan="1">0.3390</td>
              <td rowspan="1" colspan="1">0.0877</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash</td>
              <td rowspan="1" colspan="1">0.1249</td>
              <td rowspan="1" colspan="1">0.4701</td>
              <td rowspan="1" colspan="1">0.0957</td>
              <td rowspan="1" colspan="1">0.0629</td>
              <td rowspan="1" colspan="1">0.2464</td>
              <td rowspan="1" colspan="1">
                <bold>0.0847</bold>
                <xref rid="tblfn4" ref-type="table-fn">
                  <sup>a</sup>
                </xref>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn4">
            <label>a</label>
            <p>Best results are highlighted with bold text.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <table-wrap position="float" id="btad272-T4">
        <label>Table 4.</label>
        <caption>
          <p>The average sequenced length of bases and the number of chunks.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">SARS-CoV-2</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">E.coli</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Yeast</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Green algae</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Human</italic>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td colspan="6" rowspan="1">Average sequenced base length per read</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED</td>
              <td rowspan="1" colspan="1">
                <bold>184.51</bold>
                <xref rid="tblfn5" ref-type="table-fn">
                  <sup>a</sup>
                </xref>
              </td>
              <td rowspan="1" colspan="1">
                <bold>580.52</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1233.20</bold>
              </td>
              <td rowspan="1" colspan="1">5300.15</td>
              <td rowspan="1" colspan="1">6060.23</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash</td>
              <td rowspan="1" colspan="1">513.95</td>
              <td rowspan="1" colspan="1">1376.14</td>
              <td rowspan="1" colspan="1">2565.09</td>
              <td rowspan="1" colspan="1">
                <bold>4760.59</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>4773.58</bold>
              </td>
            </tr>
            <tr>
              <td colspan="6" rowspan="1">Average sequenced number of chunks per read</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Sigmap</td>
              <td rowspan="1" colspan="1">
                <bold>1.01</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>2.11</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>4.14</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5.76</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>10.40</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash</td>
              <td rowspan="1" colspan="1">1.24</td>
              <td rowspan="1" colspan="1">3.20</td>
              <td rowspan="1" colspan="1">5.83</td>
              <td rowspan="1" colspan="1">10.72</td>
              <td rowspan="1" colspan="1">10.70</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn5">
            <label>a</label>
            <p>Best results are highlighted with bold text.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>3.4 Sequencing time and cost</title>
      <p>Our goal is to estimate the benefits that each tool provides in reducing the sequencing time and cost. To this end, we measure the average length of sequenced bases and the average number of sequenced chunks per read as shown in <xref rid="btad272-T4" ref-type="table">Table 4.</xref> We make two key observations. First, RawHash provides significant benefits in reducing the sequencing time and cost for large genomes (e.g. Green Algae and Human) compared to UNCALLED, as RawHash can complete the mapping process per read by using smaller prefixes of reads. Second, RawHash uses on average <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.58</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> more chunks compared to Sigmap when mapping reads, which can proportionally lead to worse sequencing time and cost for RawHash compared to Sigmap. We conclude that although UNCALLED and Sigmap provide better advantages in reducing sequencing time and cost for smaller genomes, RawHash can provide significant reductions in sequencing time and cost for larger genomes compared to UNCALLED.</p>
    </sec>
    <sec>
      <title>3.5 Benefits of Sequence Until</title>
      <p><italic toggle="yes">Simulated Sequence Until</italic>: Our goal is to estimate the benefits of implementing the Sequence Until mechanism in UNCALLED and compare it with RawHash when they both use Sequence Until under the same conditions. To this end, we use <monospace>shuf</monospace> in Linux to randomly shuffle the mapping files that both RawHash and UNCALLED generate for relative abundance and extract a certain portion of the randomly shuffled file to identify their relative abundance estimations after <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.01</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mn>10</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mn>25</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of the overall reads in the sample are randomly sequenced from nanopores.</p>
      <p><xref rid="btad272-T5" ref-type="table">Table 5</xref> shows the distance of relative abundance estimations after a certain portion of the read is randomly sequenced from nanopores. We make two key observations. First, both RawHash and UNCALLED can significantly benefit from Sequence Until by stopping sequencing after processing a smaller portion of the entire sample since their estimations using smaller portions are close to those using the entire set of reads (<xref rid="btad272-T3" ref-type="table">Table 3</xref>) in terms of their distance to the ground truth. This suggests that many other tools can benefit from Sequence Until as their sensitivity to relative abundance estimations may not significantly change while providing opportunities for reducing the sequencing time and cost up to a certain threshold based on the tool.</p>
      <table-wrap position="float" id="btad272-T5">
        <label>Table 5.</label>
        <caption>
          <p>Relative abundance with simulated Sequence Until.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="6" align="center" rowspan="1">Estimated relative abundance ratios<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">SARS-CoV-2</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">E.coli</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Yeast</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Green algae</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">
                <italic toggle="yes">Human</italic>
              </th>
              <th align="center" rowspan="1" colspan="1">Distance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Ground Truth</td>
              <td rowspan="1" colspan="1">0.0929</td>
              <td rowspan="1" colspan="1">0.4365</td>
              <td rowspan="1" colspan="1">0.0698</td>
              <td rowspan="1" colspan="1">0.1179</td>
              <td rowspan="1" colspan="1">0.2828</td>
              <td align="center" rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED (<inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mn>25</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)<xref rid="tblfn6" ref-type="table-fn"><sup>a</sup></xref></td>
              <td rowspan="1" colspan="1">0.0026</td>
              <td rowspan="1" colspan="1">0.5890</td>
              <td rowspan="1" colspan="1">0.0613</td>
              <td rowspan="1" colspan="1">0.1332</td>
              <td rowspan="1" colspan="1">0.2139</td>
              <td rowspan="1" colspan="1">0.1910</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash (<inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mn>25</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0271</td>
              <td rowspan="1" colspan="1">0.4853</td>
              <td rowspan="1" colspan="1">0.0920</td>
              <td rowspan="1" colspan="1">0.0786</td>
              <td rowspan="1" colspan="1">0.3170</td>
              <td rowspan="1" colspan="1">
                <bold>0.0995</bold>
                <xref rid="tblfn7" ref-type="table-fn">
                  <sup>b</sup>
                </xref>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED (<inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mn>10</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0026</td>
              <td rowspan="1" colspan="1">0.5906</td>
              <td rowspan="1" colspan="1">0.0611</td>
              <td rowspan="1" colspan="1">0.1316</td>
              <td rowspan="1" colspan="1">0.2141</td>
              <td rowspan="1" colspan="1">0.1920</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash (<inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mn>10</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0273</td>
              <td rowspan="1" colspan="1">0.4869</td>
              <td rowspan="1" colspan="1">0.0963</td>
              <td rowspan="1" colspan="1">0.0772</td>
              <td rowspan="1" colspan="1">0.3124</td>
              <td rowspan="1" colspan="1">
                <bold>0.1004</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED (<inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0026</td>
              <td rowspan="1" colspan="1">0.5750</td>
              <td rowspan="1" colspan="1">0.0616</td>
              <td rowspan="1" colspan="1">0.1506</td>
              <td rowspan="1" colspan="1">0.2103</td>
              <td rowspan="1" colspan="1">0.1836</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash (<inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0259</td>
              <td rowspan="1" colspan="1">0.4783</td>
              <td rowspan="1" colspan="1">0.0987</td>
              <td rowspan="1" colspan="1">0.0882</td>
              <td rowspan="1" colspan="1">0.3088</td>
              <td rowspan="1" colspan="1">
                <bold>0.0928</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED (<inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0040</td>
              <td rowspan="1" colspan="1">0.4565</td>
              <td rowspan="1" colspan="1">0.0380</td>
              <td rowspan="1" colspan="1">0.1910</td>
              <td rowspan="1" colspan="1">0.3105</td>
              <td rowspan="1" colspan="1">0.1242</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash (<inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0212</td>
              <td rowspan="1" colspan="1">0.5045</td>
              <td rowspan="1" colspan="1">0.1120</td>
              <td rowspan="1" colspan="1">0.0810</td>
              <td rowspan="1" colspan="1">0.2814</td>
              <td rowspan="1" colspan="1">
                <bold>0.1136</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">UNCALLED (<inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.01</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0000</td>
              <td rowspan="1" colspan="1">0.5551</td>
              <td rowspan="1" colspan="1">0.0000</td>
              <td rowspan="1" colspan="1">0.0000</td>
              <td rowspan="1" colspan="1">0.4449</td>
              <td rowspan="1" colspan="1">0.2602</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash (<inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.01</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1">0.0906</td>
              <td rowspan="1" colspan="1">0.6122</td>
              <td rowspan="1" colspan="1">0.0000</td>
              <td rowspan="1" colspan="1">0.0000</td>
              <td rowspan="1" colspan="1">0.2972</td>
              <td rowspan="1" colspan="1">
                <bold>0.2232</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn6">
            <label>a</label>
            <p>Percentages show the portion of the overall reads used.</p>
          </fn>
          <fn id="tblfn7">
            <label>b</label>
            <p>Best results are highlighted with bold text.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Second, RawHash can provide more accurate relative abundance estimations when using only <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mn>0.1</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of the reads than the estimation that UNCALLED provides using the entire set of reads (<xref rid="btad272-T3" ref-type="table">Table 3</xref>). We conclude that Sequence Until provides significant opportunities in reducing sequencing time and cost while more accurate tools such as RawHash can benefit further from Sequence Until by using fewer portions of the entire read set than the portions that less accurate tools would need to achieve similar accuracy.</p>
      <p><italic toggle="yes">Sequence Until with RawHash</italic>: Our goal is to evaluate Sequence Until when used in real-time with RawHash for relative abundance estimation. <xref rid="btad272-T6" ref-type="table">Table 6</xref> shows the relative abundance estimations that RawHash makes with and without Sequence Until. We note that the estimations we show for RawHash in <xref rid="btad272-T6" ref-type="table">Table 6</xref> are different than the estimations in <xref rid="btad272-T3" ref-type="table">Table 3</xref> since we randomly subsample the reads in the relative abundance estimation dataset, as explained in Section 3.1. We make two key observations. First, we observe that the distance between the relative abundance estimations between these two configurations of RawHash is substantially low. This indicates that our outlier detection mechanism can accurately detect the convergence to the relative abundance estimations without using a full set of reads. Second, Sequence Until enables accurately stopping the entire sequencing after processing <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mn>7</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of the reads in the entire set without substantially sacrificing accuracy. We conclude that Sequence Until has the potential to significantly reduce the sequencing time and cost by using only fewer reads from a sample while producing accurate results.</p>
      <table-wrap position="float" id="btad272-T6">
        <label>Table 6.</label>
        <caption>
          <p>Relative abundance with Sequence Until.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="6" rowspan="1">Estimated relative abundance ratios in 50 000 random reads<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">SARS-CoV-2</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">E.coli</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">Yeast</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">Green algae</italic>
              </th>
              <th rowspan="1" colspan="1">
                <italic toggle="yes">Human</italic>
              </th>
              <th rowspan="1" colspan="1">Distance</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">RawHash (<inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mn>100</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)<xref rid="tblfn8" ref-type="table-fn"><sup>a</sup></xref></td>
              <td rowspan="1" colspan="1">0.0270</td>
              <td rowspan="1" colspan="1">0.3636</td>
              <td rowspan="1" colspan="1">0.3062</td>
              <td rowspan="1" colspan="1">0.1951</td>
              <td rowspan="1" colspan="1">0.1081</td>
              <td rowspan="1" colspan="1">N/A</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RawHash +</td>
              <td rowspan="1" colspan="1">0.0283</td>
              <td rowspan="1" colspan="1">0.3539</td>
              <td rowspan="1" colspan="1">0.3100</td>
              <td rowspan="1" colspan="1">0.1946</td>
              <td rowspan="1" colspan="1">0.1133</td>
              <td rowspan="1" colspan="1">0.0118</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Sequence Until (<inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mn>7</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>)</td>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn8">
            <label>a</label>
            <p>Percentages show the portion of the overall reads used. </p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We discuss the benefits we expect RawHash can immediately make, the limitations of RawHash, and future work. We envision that RawHash can be useful mainly for two directions. First, RawHash provides a low-cost solution for analyzing large genomes in real-time. Such an analysis can be significantly useful when using nanopore sequencers with limited computational resources to enable portable real-time genome analysis at a large scale.</p>
    <p>Second, we expect that RawHash can also be useful for genome analysis that does not require real-time solutions by reducing the time and energy that further steps in genome analysis may require. One of the immediate steps after generating raw nanopore signals is their translation to their corresponding DNA bases as sequences of characters with a computationally intensive step, basecalling. Basecalling approaches are usually computationally costly and consume significant energy as they use complex deep learning models (<xref rid="btad272-B13" ref-type="bibr">Mao et al. 2022</xref>; <xref rid="btad272-B22" ref-type="bibr">Singh et al. 2022</xref>). Although we do not evaluate in this work, we expect that RawHash can be used as a low-cost filter (<xref rid="btad272-B2" ref-type="bibr">Cavlak et al. 2022</xref>) to eliminate the reads that are unlikely to be useful in downstream analysis, which can reduce the overall workload of basecallers and downstream analysis.</p>
    <p><italic toggle="yes">Future work</italic>: We find three key directions for future work. First, we find that our efficient hash-based similarity identification mechanism can be used to efficiently find overlaps between signals as the reads are sequenced in real-time. Although we observe that our indexing technique is efficient in terms of the amount it requires to construct an index even for large genomes, such an overlapping technique requires substantially more optimized indexing methods and techniques that can efficiently find overlaps as more reads are sequenced and evolves the index. Finding overlaps between signals can be beneficial in (i) providing enriched information to basecallers to increase their accuracy and (ii) identifying redundant signals that fully overlap with already sequenced reads in an effort for generating assemblies from signals.</p>
    <p>Second, since RawHash generates hash values for matching similar regions, it provides opportunities to use the hash-based seeding techniques that are optimized for identifying sequence similarities accurately without requiring large memory space, such as minimizers (<xref rid="btad272-B15" ref-type="bibr">Roberts et al. 2004</xref>; <xref rid="btad272-B10" ref-type="bibr">Li 2018</xref>), spaced seeds (<xref rid="btad272-B12" ref-type="bibr">Ma et al. 2002</xref>), syncmers (<xref rid="btad272-B5" ref-type="bibr">Edgar 2021</xref>), strobemers (<xref rid="btad272-B18" ref-type="bibr">Sahlin 2021</xref>), and fuzzy seed matching as in BLEND (<xref rid="btad272-B8" ref-type="bibr">Firtina et al. 2023</xref>). Although we do not evaluate in this work, we implement the minimizer seeding technique in RawHash. Our initial observation motivates us that future work can exploit these seeding techniques with slight modifications in their seeding mechanisms to significantly improve the performance of certain applications without reducing the accuracy.</p>
    <p>Third, we find that RawHash can also benefit from a GPU implementation as its low-cost and accurate implementation can effectively be scaled to nanopore sequencers that include thousands of nanopores such that these pores can be analyzed in parallel with an efficient GPU implementation, which we leave as future work.</p>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>We propose RawHash, a novel mechanism that provides a low-cost and accurate approach for real-time genome analysis for large genomes. RawHash can efficiently and accurately perform real-time analysis of raw nanopore signals to identify similarities between the signals and a reference genome in real-time at a large-scale (e.g. whole-genome analysis for human or communities with multiple samples). To efficiently and accurately identify similarities, RawHash (i) generates events from both raw signals and the reference genome, (ii) quantizes the events into values such that slightly different events that correspond to the same DNA content can have the same value, and (iii) generates hash values from multiple events to efficiently find matching regions between raw signals and a reference genome using hash values with efficient data structures such as hash tables. We compare RawHash with the state-of-the-art approaches, UNCALLED and Sigmap, on three important applications in terms of their performance, accuracy, and estimated benefits in reducing sequencing time and cost. Our results show that (i) RawHash is the only tool that can be accurately applied to analyze raw nanopore signals at large-scale, (ii) provides <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mn>25.8</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mn>3.4</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> better average throughput, and (iii) can map reads <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mn>32.1</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.1</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than UNCALLED and Sigmap, respectively.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad272_Supplementary_Data</label>
      <media xlink:href="btad272_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank the SAFARI Research Group members for their valuable feedback and the stimulating intellectual and scholarly environment they provide. We thank the anonymous reviewers of ISMB/ECCB 2023.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>We acknowledge the generous gifts of our industrial partners, including Intel and VMware. This work is also partially supported by the European Union’s Horizon programme for research and innovation [101047160 - BioPIM] and the Swiss National Science Foundation (SNSF) [200021_213084].</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>We provide the accession numbers of all the available public datasets we use in <xref rid="btad272-T1" ref-type="table">Table 1</xref>. We provide the scripts to download all the datasets and to fully reproduce our results at <ext-link xlink:href="https://github.com/CMU-SAFARI/RawHash/tree/main/test" ext-link-type="uri">https://github.com/CMU-SAFARI/RawHash/tree/main/test</ext-link>. The source code of RawHash is available at <ext-link xlink:href="https://github.com/CMU-SAFARI/RawHash" ext-link-type="uri">https://github.com/CMU-SAFARI/RawHash</ext-link>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad272-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bao</surname><given-names>Y</given-names></string-name>, <string-name><surname>Wadden</surname><given-names>J</given-names></string-name>, <string-name><surname>Erb-Downward</surname><given-names>JR</given-names></string-name></person-group><etal>et al</etal><article-title>SquiggleNet: real-time, direct classification of nanopore signals</article-title>. <source>Genome Biol</source><year>2021</year>;<volume>22</volume>:<fpage>298</fpage>.<pub-id pub-id-type="pmid">34706748</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Cavlak</surname><given-names>MB</given-names></string-name>, <string-name><surname>Singh</surname><given-names>G</given-names></string-name>, <string-name><surname>Alser</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal> Targetcall: eliminating the wasted computation in basecalling via pre-basecalling filtering. <italic toggle="yes">bioRxiv</italic>, <year>2022</year>, preprint: not peer reviewed.</mixed-citation>
    </ref>
    <ref id="btad272-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>David</surname><given-names>M</given-names></string-name>, <string-name><surname>Dursi</surname><given-names>LJ</given-names></string-name>, <string-name><surname>Yao</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>Nanocall: an open source basecaller for oxford nanopore sequencing data</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>49</fpage>–<lpage>55</lpage>.<pub-id pub-id-type="pmid">27614348</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B4">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Dunn</surname><given-names>T</given-names></string-name>, <string-name><surname>Sadasivan</surname><given-names>H</given-names></string-name>, <string-name><surname>Wadden</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal> SquiggleFilter: an accelerator for portable virus detection. In: <italic toggle="yes">MICRO, New York, NY, USA.</italic><year>2021</year>.</mixed-citation>
    </ref>
    <ref id="btad272-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edgar</surname><given-names>R.</given-names></string-name></person-group><article-title>Syncmers are more sensitive than minimizers for selecting conserved k-mers in biological sequences</article-title>. <source>PeerJ</source><year>2021</year>;<volume>9</volume>:<fpage>e10805</fpage>.<pub-id pub-id-type="pmid">33604186</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Edwards</surname><given-names>HS</given-names></string-name>, <string-name><surname>Krishnakumar</surname><given-names>R</given-names></string-name>, <string-name><surname>Sinha</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>Real-time selective sequencing with RUBRIC: read until with basecall and reference-informed criteria</article-title>. <source>Sci Rep</source><year>2019</year>;<volume>9</volume>:<fpage>11475</fpage>.<pub-id pub-id-type="pmid">31391493</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B7">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Ferragina</surname><given-names>P</given-names></string-name>, <string-name><surname>Manzini</surname><given-names>G.</given-names></string-name></person-group> Opportunistic data structures with applications. In: <italic toggle="yes">Proceedings 41st Annual Symposium on Foundations of Computer Science, Redondo Beach, CA, USA</italic>. <year>2000</year>, <fpage>390</fpage>–<lpage>98</lpage>.</mixed-citation>
    </ref>
    <ref id="btad272-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Firtina</surname><given-names>C</given-names></string-name>, <string-name><surname>Park</surname><given-names>J</given-names></string-name>, <string-name><surname>Alser</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>BLEND: a fast, memory-efficient and accurate mechanism to find fuzzy seed matches in genome analysis</article-title>. <source>NAR Genom Bioinform</source><year>2023</year>;<volume>5</volume>:<fpage>lqad004</fpage>.<pub-id pub-id-type="pmid">36685727</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kovaka</surname><given-names>S</given-names></string-name>, <string-name><surname>Fan</surname><given-names>Y</given-names></string-name>, <string-name><surname>Ni</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>Targeted nanopore sequencing by real-time mapping of raw electrical signal with UNCALLED</article-title>. <source>Nat Biotechnol</source><year>2021</year>;<volume>39</volume>:<fpage>431</fpage>–<lpage>41</lpage>.<pub-id pub-id-type="pmid">33257863</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group><article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>3094</fpage>–<lpage>100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loose</surname><given-names>M</given-names></string-name>, <string-name><surname>Malla</surname><given-names>S</given-names></string-name>, <string-name><surname>Stout</surname><given-names>M.</given-names></string-name></person-group><article-title>Real-time selective sequencing using nanopore technology</article-title>. <source>Nat Methods</source><year>2016</year>;<volume>13</volume>:<fpage>751</fpage>–<lpage>4</lpage>.<pub-id pub-id-type="pmid">27454285</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ma</surname><given-names>B</given-names></string-name>, <string-name><surname>Tromp</surname><given-names>J</given-names></string-name>, <string-name><surname>Li</surname><given-names>M.</given-names></string-name></person-group><article-title>PatternHunter: faster and more sensitive homology search</article-title>. <source>Bioinformatics</source><year>2002</year>;<volume>18</volume>:<fpage>440</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">11934743</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Mao</surname><given-names>H</given-names></string-name>, <string-name><surname>Alser</surname><given-names>M</given-names></string-name>, <string-name><surname>Sadrosadati</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal> Genpip: in-memory acceleration of genome analysis via tight integration of basecalling and read mapping. In: <italic toggle="yes">2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO), Chicago, IL, USA</italic>. IEEE, <year>2022</year>, <fpage>710</fpage>–<lpage>26</lpage>.</mixed-citation>
    </ref>
    <ref id="btad272-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Payne</surname><given-names>A</given-names></string-name>, <string-name><surname>Holmes</surname><given-names>N</given-names></string-name>, <string-name><surname>Clarke</surname><given-names>T</given-names></string-name></person-group><etal>et al</etal><article-title>Readfish enables targeted nanopore sequencing of gigabase-sized genomes</article-title>. <source>Nat Biotechnol</source><year>2021</year>;<volume>39</volume>:<fpage>442</fpage>–<lpage>50</lpage>.<pub-id pub-id-type="pmid">33257864</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ruxton</surname><given-names>GD.</given-names></string-name></person-group><article-title>The unequal variance t-test is an underused alternative to student’s t-test and the Mann–Whitney U test</article-title>. <source>Behav Ecol</source><year>2006</year>;<volume>17</volume>:<fpage>688</fpage>–<lpage>90</lpage>.</mixed-citation>
    </ref>
    <ref id="btad272-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sadasivan</surname><given-names>H</given-names></string-name>, <string-name><surname>Wadden</surname><given-names>J</given-names></string-name>, <string-name><surname>Goliya</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal> Rapid Real-time Squiggle Classification for Read until using RawMap. In: <italic toggle="yes">Archives of Clinical and Biomedical Research</italic>, <year>2023</year>;<volume>7</volume>:<fpage>45</fpage>–<lpage>57</lpage>. <pub-id pub-id-type="doi">10.26502/acbr.50170318</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sahlin</surname><given-names>K.</given-names></string-name></person-group><article-title>Effective sequence similarity detection with strobemers</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>2080</fpage>–<lpage>94</lpage>.<pub-id pub-id-type="pmid">34667119</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Senanayake</surname><given-names>A</given-names></string-name>, <string-name><surname>Gamaarachchi</surname><given-names>H</given-names></string-name>, <string-name><surname>Herath</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>DeepSelectNet: deep neural network based selective sequencing for oxford nanopore sequencing</article-title>. <source>BMC Bioinformatics</source><year>2023</year>;<volume>24</volume>:<fpage>31</fpage>.<pub-id pub-id-type="pmid">36709261</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B20">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Shih</surname><given-names>PJ</given-names></string-name>, <string-name><surname>Saadat</surname><given-names>H</given-names></string-name>, <string-name><surname>Parameswaran</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal> Efficient real-time selective genome sequencing on resource-constrained devices. <italic toggle="yes">arXiv</italic>, <year>2022</year>, preprint: not peer reviewed.</mixed-citation>
    </ref>
    <ref id="btad272-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Simpson</surname><given-names>JT</given-names></string-name>, <string-name><surname>Workman</surname><given-names>RE</given-names></string-name>, <string-name><surname>Zuzarte</surname><given-names>PC</given-names></string-name></person-group><etal>et al</etal><article-title>Detecting DNA cytosine methylation using nanopore sequencing</article-title>. <source>Nat Methods</source><year>2017</year>;<volume>14</volume>:<fpage>407</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">28218898</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B22">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Singh</surname><given-names>G</given-names></string-name>, <string-name><surname>Alser</surname><given-names>M</given-names></string-name>, <string-name><surname>Khodamoradi</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal> A framework for designing efficient deep learning-based genomic basecallers. <italic toggle="yes">bioRxiv</italic>, <year>2022</year>, preprint: not peer reviewed.</mixed-citation>
    </ref>
    <ref id="btad272-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ulrich</surname><given-names>JU</given-names></string-name>, <string-name><surname>Lutfi</surname><given-names>A</given-names></string-name>, <string-name><surname>Rutzen</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>ReadBouncer: precise and scalable adaptive sampling for nanopore sequencing</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>i153</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">35758774</pub-id></mixed-citation>
    </ref>
    <ref id="btad272-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Weilguny</surname><given-names>L</given-names></string-name>, <string-name><surname>De Maio</surname><given-names>N</given-names></string-name>, <string-name><surname>Munro</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Dynamic, adaptive sampling during nanopore sequencing using Bayesian experimental design</article-title>. <source>Nat Biotechnol</source><year>2023</year>:<fpage>1</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="btad272-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>H</given-names></string-name>, <string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Jain</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Real-time mapping of nanopore raw signals</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>i477</fpage>–<lpage>83</lpage>.<pub-id pub-id-type="pmid">34252938</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
