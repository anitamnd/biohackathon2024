<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6815017</article-id>
    <article-id pub-id-type="publisher-id">3086</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-019-3086-9</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>GASAL2: a GPU accelerated sequence alignment library for high-throughput NGS data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Ahmed</surname>
          <given-names>Nauman</given-names>
        </name>
        <address>
          <email>n.ahmed@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lévy</surname>
          <given-names>Jonathan</given-names>
        </name>
        <address>
          <email>j.levy@student.tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ren</surname>
          <given-names>Shanshan</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mushtaq</surname>
          <given-names>Hamid</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bertels</surname>
          <given-names>Koen</given-names>
        </name>
        <address>
          <email>k.l.m.bertels@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Al-Ars</surname>
          <given-names>Zaid</given-names>
        </name>
        <address>
          <email>z.al-ars@tudelft.nl</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.444938.6</institution-id><institution>Delft University of Technology, Delft, Netherlands and University of Engineering and Technology, </institution></institution-wrap>Lahore, Pakistan </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2097 4740</institution-id><institution-id institution-id-type="GRID">grid.5292.c</institution-id><institution>Delft University of Technology, Netherlands, </institution></institution-wrap>Delft, Netherlands </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 0480 1382</institution-id><institution-id institution-id-type="GRID">grid.412966.e</institution-id><institution>Maastricht UMC+, Netherlands, </institution></institution-wrap>Maastricht, Netherlands </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>25</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>25</day>
      <month>10</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>520</elocation-id>
    <history>
      <date date-type="received">
        <day>2</day>
        <month>4</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>6</day>
        <month>9</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Due the computational complexity of sequence alignment algorithms, various accelerated solutions have been proposed to speedup this analysis. NVBIO is the only available GPU library that accelerates sequence alignment of high-throughput NGS data, but has limited performance. In this article we present <italic>GASAL2</italic>, a GPU library for aligning DNA and RNA sequences that outperforms existing CPU and GPU libraries.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">The GASAL2 library provides specialized, accelerated kernels for local, global and all types of semi-global alignment. Pairwise sequence alignment can be performed with and without traceback. GASAL2 outperforms the fastest CPU-optimized SIMD implementations such as SeqAn and Parasail, as well as NVIDIA’s own GPU-based library known as NVBIO. GASAL2 is unique in performing sequence packing on GPU, which is up to 750x faster than NVBIO. Overall on Geforce GTX 1080 Ti GPU, GASAL2 is up to 21x faster than Parasail on a dual socket hyper-threaded Intel Xeon system with 28 cores and up to 13x faster than NVBIO with a query length of up to 300 bases and 100 bases, respectively. GASAL2 alignment functions are asynchronous/non-blocking and allow full overlap of CPU and GPU execution. The paper shows how to use GASAL2 to accelerate BWA-MEM, speeding up the local alignment by 20x, which gives an overall application speedup of 1.3x vs. CPU with up to 12 threads.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">The library provides high performance APIs for local, global and semi-global alignment that can be easily integrated into various bioinformatics tools.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Genomics</kwd>
      <kwd>Sequence alignment</kwd>
      <kwd>NGS</kwd>
      <kwd>GPU library</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Many applications for processing NGS sequencing data depend heavily on sequence alignment algorithms to identify similarity between the DNA fragments in the datasets. Well known programs for DNA mapping such as BWA-MEM [<xref ref-type="bibr" rid="CR1">1</xref>] and Bowtie2 [<xref ref-type="bibr" rid="CR2">2</xref>], DNA assemblers such PCAP [<xref ref-type="bibr" rid="CR3">3</xref>] and PHRAP [<xref ref-type="bibr" rid="CR4">4</xref>], make repeated use of these alignment algorithms. Furthermore, in various practical multiple sequence alignment algorithms, many pairwise sequence alignments are performed to align sequences with each other. Also, alignment based read error correction algorithms, like Coral [<xref ref-type="bibr" rid="CR5">5</xref>] and ECHO [<xref ref-type="bibr" rid="CR6">6</xref>], perform a large number of pairwise sequence alignments. In addition, variant callers for NGS data e.g. GATK HaplotypeCaller [<xref ref-type="bibr" rid="CR7">7</xref>], also make use of sequence alignment.</p>
    <p>Sequence alignment is the process of editing two or more sequences using gaps and substitutions such that they closely match each other. It is performed using dynamic programming. There are two types of sequence alignment algorithms for biological sequences: <italic>global alignment</italic> and <italic>local alignment</italic>. The former is performed using the Needleman-Wunsch algorithm [<xref ref-type="bibr" rid="CR8">8</xref>] (NW), while Smith-Waterman algorithm [<xref ref-type="bibr" rid="CR9">9</xref>] (SW) is used for the latter. Both algorithms have been improved by Gotoh [<xref ref-type="bibr" rid="CR10">10</xref>] to use affine-gap penalties. These alignment algorithms can be divided into the following classes: 
<list list-type="bullet"><list-item><p><italic>Global alignment</italic>: In global alignment, also known as end-to-end alignment, the goal is to align the sequences in their entirety while maximizing the alignment score.</p></list-item><list-item><p><italic>Semi-global alignment</italic>: Unlike global alignment, semi-global alignment finds the overlap between the two sequences, allowing to skip the ends of a sequence without penalty. In semi-global alignment the gaps at the leading or trailing edges of the sequences can be ignored, without inducing any score penalty. Different kinds of semi-global alignments are possible depending on which sequence can have its beginning or end be skipped. GASAL2 supports all kinds of semi-global alignments where any combination of beginning or end of a pair of sequences can be ignored.</p></list-item><list-item><p><italic>Local alignment</italic>: In local alignment, the goal is to align two sequences so that the alignment score is maximized. As opposed to global alignment, the final alignment may not contain the whole of the sequences. No penalty is induced by misalignments in the beginning and end of the sequences, and the score is kept positive.</p></list-item></list></p>
    <p>Figure <xref rid="Fig1" ref-type="fig">1</xref> shows the alignment of the two sequences shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. The bases enclosed in the box constitute the alignment. Match score is 3; mis-match penalty is 4; gap open and gap extension penalties are 6 and 1, respectively. For global alignment the alignment score is -5. In case of semi-global alignment the gaps at the end of <italic>S</italic><sub>1</sub> are not penalized. The alignment score is 7, while the start and end positions of the alignment on <italic>S</italic><sub>2</sub> are 2 and 10, respectively. For local alignment, the final alignment score is 10. The end-positions of the alignment on <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> are 12 and 10, respectively. The start-position is 3 on both sequences.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Alignment of <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> sequences shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. <bold>a</bold> Global alignment example. <bold>b</bold> Semi-global alignment example. <bold>c</bold> Local alignment example</p></caption><graphic xlink:href="12859_2019_3086_Fig1_HTML" id="MO1"/></fig>
<fig id="Fig2"><label>Fig. 2</label><caption><p>Identical <italic>H</italic>, <italic>E</italic> and <italic>F</italic> matrix</p></caption><graphic xlink:href="12859_2019_3086_Fig2_HTML" id="MO2"/></fig>
</p>
    <sec id="Sec2">
      <title>Graphical processing units</title>
      <p>Graphical Processing Units (GPUs) were developed for rendering graphics, but are now being used to accelerate many other applications due to their massively parallel architecture. The GPU architecture varies from one vendor to the other and even across different GPU generations from the same vendor. Here we give a general overview of state-of-the-art NVIDIA GPUs. The cores of a GPU, known as streaming processors (SPs), groups of which are organized into a number of streaming multiprocessors (SMs). Each SM has a set of SPs, a register file, one or more thread schedulers, a read only memory, L1 cache, shared memory, and some other hardware units. All SMs access the DRAM (known as global memory) through a shared L2 cache. The programming language for NVIDIA GPUs is known as <italic>CUDA</italic> which is an extension of C/C++. The function that executes on the GPU is known as <italic>kernel</italic>. The data to be processed by the kernel is first copied from the CPU memory into the global memory of the GPU. The CPU (known as the <italic>host</italic>) then launches the kernel. Once the kernel is finished the results are copied from the global memory back into CPU memory. This copying of data back and forth between host and GPU is quite time expensive. Therefore, data is transferred between the host and GPU in the form of large batches to keep number of transfers at minimum. Moreover, the batch should be large enough to fully utilize the GPU resources.</p>
      <p>At every clock cycle each SM executes instructions from a group of threads known as a <italic>warp</italic>. A <italic>warp</italic> is a set of 32 GPU threads that execute in lock-step (i.e., they share the instruction pointer). Therefore, if one or more threads execute a different instruction, different execution paths are serialized causing performance loss. This phenomenon is known as <italic>divergent execution</italic> and should be avoided as much as possible. Moreover, to achieve good memory throughput the memory accesses should be coalesced (i.e., all the threads in a warp should access consecutive memory locations).</p>
      <p>To allow the overlapping of GPU and CPU execution, all the GPU kernel launches are asynchronous i.e. control is immediately returned to the CPU after the kernel launch. In this way, the launching thread can perform other tasks instead of waiting for the kernel to complete. Using <italic>CUDA streams</italic>, it is possible to launch one or more kernels on GPU before the results of a previously launched kernel has been copied back to the CPU. CUDA streams also allow to asynchronously perform the copying operations. Hence, one can just launch all the operations and perform other tasks on the CPU. Subsequently, the cudaStreamQuery() API function can be used to test whether all the operations in a given stream have completed or not.</p>
    </sec>
    <sec id="Sec3">
      <title>Previous research works</title>
      <p>GPU acceleration of sequence alignment has been the topic of many research papers like [<xref ref-type="bibr" rid="CR11">11</xref>–<xref ref-type="bibr" rid="CR13">13</xref>]. Apart from sequence alignment, GPUs are also used for accelerating many other bioinformatics algorithms, such as, described in [<xref ref-type="bibr" rid="CR14">14</xref>, <xref ref-type="bibr" rid="CR15">15</xref>]. Moreover, various biomedical image analysis applications are accelerated with GPUs. Kalaiselvi et al. [<xref ref-type="bibr" rid="CR16">16</xref>] surveys the GPU acceleration of medical image analysis algorithms. In [<xref ref-type="bibr" rid="CR17">17</xref>, <xref ref-type="bibr" rid="CR18">18</xref>], GPUs are used to accelerate the processing of MRI images for brain tumour detection and segmentation. Most of the previous work on accelerating sequence alignment, was focused on developing search engines for databases of protein sequences. The alignment of DNA and RNA sequences during the processing of high-throughput NGS data poses a different set of challenges than database searching as described below. 
<list list-type="order"><list-item><p>The sequences to be aligned in NGS processing are generated specifically for each experiment. In contrast, in database searching, the database of sequences is known in advance and may be preprocessed for higher performance.</p></list-item><list-item><p>In database search programs, one or few query sequences are aligned against all the sequences in the database (may be regarded as target sequences), whereas the processing of NGS data requires pairwise one-to-one, one-to-many or all-to-all pairwise sequence alignment. Due to this, a common performance improvement technique in database search programs, like using <italic>query profile</italic>, is not feasible in NGS data alignment.</p></list-item><list-item><p>In programs containing GPU accelerated sequence alignment, the alignment step is tightly coupled with the rest of the program. The GPU alignment kernel is specifically tailored to meet the requirements of the program. Therefore, reusing the kernel to accelerate the sequence alignment in other programs is not easy.</p></list-item></list></p>
      <p>Due to these differences, GPU accelerated database search cannot be used to accelerate the alignment step in NGS data processing programs. gpu-pairAlign [<xref ref-type="bibr" rid="CR19">19</xref>] and GSWABE [<xref ref-type="bibr" rid="CR20">20</xref>] present only all-to-all pairwise local alignment of sequences. All-to-all alignment is easier to accelerate on GPU. Since, only one query sequence is being aligned to all other sequences, the query sequence may reside in the GPU cache, substantially reducing global memory accesses. On the other hand, in one-to-one alignment each query sequence is different limiting the effectiveness of caching these sequences. In many NGS data processing applications, one-to-one pairwise alignment is required (e.g., DNA read mapping). In DNA read mapping, local alignment takes a substantial percentage of the total run time. For example, in the BWA-MEM DNA read aligner the local alignment takes about 30% of the total execution time with query lengths of 250bp (or base pairs), while calculating only the score, start-position and end-position.</p>
      <p>None of the previously published research efforts have developed any GPU accelerated sequence alignment library that can be easily integrated in other programs that require to perform pairwise alignments. NVBIO [<xref ref-type="bibr" rid="CR21">21</xref>] is the only public library that contains GPU accelerated functions for the analysis of DNA sequences. Although this library contains a GPU accelerated function for sequence alignments, its performance is limited. Therefore, in this paper we present a GPU accelerated library for pairwise alignment of DNA and RNA sequences, GASAL2 (GPU Accelerated Sequence Alignment Library v2), as an extension of our previously developed GASAL library described in [<xref ref-type="bibr" rid="CR22">22</xref>]. The library contains functions that enable fast alignment of sequences and can be easily integrated in other programs developed for NGS data analysis. Functions for all three types of alignment algorithms (i.e., local, global and semi-global) are available in GASAL2. One-to-one as well as all-to-all and one-to-many pairwise alignments can be performed using affine-gap penalties. The contributions of the paper are as follows: 
<list list-type="bullet"><list-item><p>A GPU accelerated DNA/RNA sequence alignment library that can perform global, semi-global (all types) as well as local alignment between pair of sequences. The library can compute the alignment score and the actual alignment between two sequences by performing traceback. The actual alignment is generated in CIGAR format and contains the exact position of matches, mismatches, insertion and deletion in the alignment. Optionally it can compute the alignment score with only the end, and if required, the start position of the alignment.</p></list-item><list-item><p>The library uses CUDA streams so that the alignment functions can be called asynchronously and the host CPU can perform other tasks instead of waiting for the alignment to complete on the GPU.</p></list-item><list-item><p>GASAL2 is the fastest sequence alignment library for high-throughput Illumina DNA sequence reads in comparison to highly optimized CPU-based libraries, and it is also much faster than NVBIO, NVIDIA’s own GPU library for sequence analysis.</p></list-item><list-item><p>GASAL2 can be easily integrated in bioinformatics applications, such as accelerating the seed-extension stage of BWA-MEM read mapper.</p></list-item></list></p>
    </sec>
  </sec>
  <sec id="Sec4">
    <title>Implementation</title>
    <p>In this paper, we describe GASAL2, a GPU accelerated library for pairwise sequence alignment. The sequences are first transferred to the GPU memory, where they are <italic>packed</italic> into unsigned 32-bit integers. If needed, any number of sequences can then be reverse-complemented. Finally, the alignment is performed and the results are fetched back from the GPU memory to the CPU memory. This section gives an overview of the implementation choices of GASAL2 and describes various stages in the data processing pipeline performed on the GPU.</p>
    <sec id="Sec5">
      <title>Stage-1: data packing</title>
      <p>The user passes the two batches of sequences to be pairwise aligned. A batch is a concatenation of the sequences. Each base is represented in a byte (8-bits). DNA and RNA sequences are made up of only 5 nucleotide bases, A, C, G, T/U (T in case of DNA and U in RNA) and N (unknown base), 3 bits are enough to represent each symbol of a sequence. However, we represent each base in 4 bits for faster packing. Due to the compute bound nature of the GASAL2 alignment kernel, using 3-bits does not result in any significant speedup over the 4-bit representation, but instead complicates the data packing process. Registers in the GPU are 32-bits wide. Therefore, a batch of sequences is packed in an array of 32-bit unsigned integers in which each base is represented by 4 bits. NVBIO also packs the sequences on CPU using 4 bits per base. As the total number of bases in a batch is quite large, packing the data on the CPU is very slow. Figure <xref rid="Fig3" ref-type="fig">3</xref> shows the percentage of data packing in the total execution time for one-to-one pairwise alignment of the input dataset. The input dataset and GPU platform are described in “<xref rid="Sec13" ref-type="sec">Input dataset and execution platforms</xref>” section on page 6. Figure <xref rid="Fig3" ref-type="fig">3</xref> shows that NVBIO data packing takes around 80% of the total time. Hence, in NVBIO preparing the sequences for the alignment on GPU takes much more time then actually aligning the sequences. Based on this observation, we accelerate the data packing process on GPU and unpacked batches of sequences are copied to the GPU global memory for this purpose. Figure <xref rid="Fig4" ref-type="fig">4</xref> shows how the GPU data packing kernel works on GPU. Each GPU thread loads eight bases at a time from global memory. Each base is converted from 8-bit to 4-bit representation by masking the upper 4 bits, and then packed into an unsigned 32-bit integer which is written back to global memory. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the achieved speedup of our novel approach of packing the sequences on GPU as compared to sequence packing performed by NVBIO on CPU. GASAL2 is at least 580x faster than NVBIO. Since, only few milliseconds are required to pack the sequences in GASAL2, the data packing time is completely eliminated. After the data packing is complete, packed sequences reside on the GPU memory and all subsequent operations are completely done on the GPU, only the final results of the alignment need to be copied from GPU to CPU.
<fig id="Fig3"><label>Fig. 3</label><caption><p>NVBIO data packing time as percentage of total execution time</p></caption><graphic xlink:href="12859_2019_3086_Fig3_HTML" id="MO3"/></fig><fig id="Fig4"><label>Fig. 4</label><caption><p>Packing the sequences on GPU. <italic>b</italic><sub>1</sub>,<italic>b</italic><sub>2</sub>,…, are the bases</p></caption><graphic xlink:href="12859_2019_3086_Fig4_HTML" id="MO4"/></fig><fig id="Fig5"><label>Fig. 5</label><caption><p>Data packing time, GASAL2 vs NVBIO</p></caption><graphic xlink:href="12859_2019_3086_Fig5_HTML" id="MO5"/></fig>
</p>
    </sec>
    <sec id="Sec6">
      <title>Stage-2 (optional): reverse-complementing kernel</title>
      <p>GASAL2 is able to reverse and/or complement any number of sequences from any batch. Any sequence can be flagged to be reversed, complemented, or reverse-complemented. The reverse-complementing process is performed on the GPU on already packed sequences to take advantage of the high parallelism of the task.</p>
    </sec>
    <sec id="Sec7">
      <title>Stage-3: alignment</title>
      <p>The sequence alignment kernel is launched to perform pairwise alignment of the sequences using affine-gap scoring scheme. GASAL2 employs inter-sequence parallelization and each GPU thread is assigned a pair of sequences to be aligned. All pairs of sequences are independent of the others, so there is no data dependency and all the alignments run in parallel. An alignment algorithm using affine-gap penalties compute cells in three dynamic programming (DP) matrices. These matrices are usually named as <italic>H</italic>, <italic>E</italic> and <italic>F</italic>. The matrices are shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. Each cell needs the results of 3 other cells: the one on top, the one on the left, and the one on the top-left diagonal. Since the sequences are packed into 32-bits words of 8 bases each, the alignment fetches a word of both sequences from memory and computes an 8x8 tile of the matrix. Hence, 64 cells of the DP matrices are computed with a single memory fetch reducing the number of memory requests. All the tiles are computed from left to right, then top to bottom. To jump from one tile to the next one on the right, we need to store 8 intermediate values (which are the values of the cell of the left for the next tile). To jump from one row of tiles to the next row, we need to store a full row of intermediate values (which are the values of the cell of the top for the next row of tiles). Hence, instead of storing the whole matrix, we only store an 8-element column and a full row, which reduces the memory requirement from <italic>O</italic>(<italic>n</italic><sup>2</sup>) to <italic>O</italic>(<italic>n</italic>). Since, the stored column has only 8 elements it can easily reside in the GPU register file. For ease of representation, Fig. <xref rid="Fig2" ref-type="fig">2</xref> shows a 4 x 4 tile, and the intermediate values that are stored are shown shaded. Our library can also compute the start-position of the alignment without computing the traceback. To do so, we restart the computation, but now from the end-position in the backward direction, and exit where the score becomes equal to the previously found score. The coordinates of the cells at the exit point give the start-position of the alignment.</p>
      <p>For computing the traceback a <italic>direction</italic> matrix is stored in the global memory of the GPU while computing the alignment. The direction matrix is similar to the one shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref> with |<italic>S</italic><sub>1</sub>|×|<italic>S</italic><sub>2</sub>| cells. Each cell is represented by 4-bits in the memory. The lower 2 bits are used to encode whether the current cell is match, mismatch, insertion or deletion. The upper two bits are for the next cell on the alignment path. If the next cell is a gap then the upper bits of the current cell represent whether it is a gap-open or gap-extension, one bit each for insertion and deletion. The direction matrix is stored in the memory using uint4 CUDA vector data type. uint4 has 4 aligned 32-bit unsigned integers. A single store/load instruction is required to access uint4 data from the memory. A single uint4 data element can store 32 direction matrix cells, and hence half the cells in a tile. Moreover, the direction matrices of all the pairs aligned on the GPU are stored in an interleaved fashion for coalesced memory access. The actual alignment is generated using the direction matrix by starting from the end cell and tracing back to the start of the alignment to compute the exact location of matches, mismatches, deletions and insertions.</p>
      <p>The output of this stage depends on the users choice. There are three possible outputs: 1) only score and end-position of the alignment. 2) score, end-position and start-position of the alignment without performing traceback. 3) score, end-position, start-position and actual alignment in CIGAR format.</p>
    </sec>
    <sec id="Sec8">
      <title>Kernel specialization through templates</title>
      <p>GASAL2 supports various kinds of parameters for kernel launches, to tailor the results to the user’s need. For example, the traceback will only be calculated if the user requests it. In addition, GASAL2 can adapt to any kind of semi-global alignment where the initialization or the search for a maximum can vary, depending on the user requesting the beginning and/or the end of any sequence.</p>
      <p>Dealing with this kind of issue is not trivial in the case of GPU programming, as creating a simple branch through an <italic>if</italic> statement slows down the whole kernel dramatically (for a single <italic>if</italic> in the innermost loop of an alignment kernel, this can cause an approximate slowdown of 40%). Duplicating the kernels is not a viable solution for code maintenance: for example, for the semi-global kernel, there are 2<sup>4</sup>=16 types; and adding the possibility of asking for the start-position doubles this number.</p>
      <p>The solution that we adopted allows to generate all the possible kernels at compilation time, so that they are all ready to run at full speed without branches. CUDA implementation of C++ templates (according to C++11 specifications) allows to generate all template-kernels at compile time. The programming model that we adopted allows to create a new kernel specialization by writing <italic>if</italic> statements that are resolved at compilation time, to prune the useless branches.</p>
    </sec>
    <sec id="Sec9">
      <title>GPU launch parameters choice</title>
      <p>GPU threads are organized in <italic>blocks</italic>, and blocks are grouped into <italic>kernel grid</italic>. A <italic>block</italic> is run on a SM that has several hardware resources such as cores, register file, cache, etc. Two parameters characterize the kernel launch: 
<list list-type="bullet"><list-item><p>the block size, which is the number of threads in a block.</p></list-item><list-item><p>the grid size, which is the total number of blocks.</p></list-item></list></p>
      <p>Block size affects the <italic>SM occupancy</italic>. The SM occupancy is the ratio of number of active warps and the maximum number of warps allowed on a SM. Increasing the occupancy helps in memory-bound applications. Large occupancy makes sure that they are always enough number of warps that are ready to be scheduled to the streaming processors so that all cores (SP’s) in the SM are fully utilized. GASAL2 alignment kernel is not memory-bound. It can compute a 8x8 tile of cells in only 2-3 memory requests. Thus, increasing the occupancy does not help much. However, GASAL2 alignment kernels use a block size of 128 for reasonable occupancy value. GASAL2 uses the inter-sequence parallelization and each GPU thread performs only one alignment. Hence, the grid size is always the ratio of number of alignments to be performed and the block size (128).</p>
    </sec>
    <sec id="Sec10">
      <title>GASAL2 asynchronous execution</title>
      <p>GASAL2 allows the user to overlap GPU and CPU execution. This is known as <italic>asynchronous</italic> or <italic>non-blocking</italic> alignment function call as opposed to <italic>synchronous</italic> or <italic>blocking</italic> call used in GASAL [<xref ref-type="bibr" rid="CR22">22</xref>]. In a blocking alignment function call, the calling thread is blocked until the alignment on the GPU is complete. GASAL2 uses CUDA streams to enable asynchronous execution. In asynchronous calls, the calling thread is not blocked and immediately returns after launching various tasks on the GPU. In GASAL2 these tasks are CPU-GPU memory transfers, and the GPU kernels for data packing, reverse-complementing (optional), and pairwise-alignment. The application can perform other tasks on the CPU rather than waiting for the GPU tasks to complete. This helps to eliminate idle CPU cycles in case of a blocking call. Hence, the time spent in the alignment function is merely a small overhead to call the CUDA API asynchronous memory copy functions and launch the kernels.</p>
    </sec>
    <sec id="Sec11">
      <title>GASAL2 versus GASAL and NVBIO</title>
      <p>The advantages of GASAL2 over GASAL and NVBIO are listed below: 
<list list-type="order"><list-item><p>GASAL2 can generate the actual alignment between a pair of sequences by computing traceback. The traceback contains the exact position of matches, mismatches, insertion and deletion in the alignment. This facility is not provided in GASAL.</p></list-item><list-item><p>GASAL2 is much faster than NVBIO.</p></list-item><list-item><p>Asynchronous execution. This is a unique facility that is not available in NVBIO or GASAL.</p></list-item><list-item><p>In NVBIO and GASAL, an ambiguous base (N) is treated as a ordinary base having the same match and mismatch scores as A, C, G or T. But, in most sequence analysis programs, the match/mismatch score of "N" is different. For example, in BWA-MEM the score of aligning "N" against any other base (A, C, G, T or N) is always -1. Extending NVBIO to adopt this new scoring scheme to handle "N" increases the execution time of GPU kernels by 30% for global and semi-global alignment, and by 38% for local alignment. In GASAL2 the score of aligning "N" against any other base is configurable. Due to this, the execution time of global, semi-global and local kernels is higher than that of GASAL by 17%, 15% and 6%, respectively.</p></list-item><list-item><p>In GASAL, the GPU memory allocations are performed just before the batch of sequences are copied from CPU to GPU. The allocated memory is freed after the alignment is complete and the results are copied from GPU to CPU. If the input batch is not very large, the time spent in memory allocation and de-allocations may become significant and, thus reduces the performance. In GASAL2, we have a separate API function for memory allocation and de-allocation which is called only once at the beginning and end of the program, respectively. At the beginning of the program, user calls the memory allocation function by passing an estimated input batch size. Separate data structures are maintained to keep track of the allocated memory. If the actual input batch is larger, GASAL2 automatically handles the situation by seamlessly allocating more memory. The allocated memory is freed up at the end of the application.</p></list-item><list-item><p>GASAL2 supports all types of semi-global alignments. NVBIO and GASAL supports only one type of semi-global alignment in which the gaps at the beginning and end of the query sequence are ignored.</p></list-item><list-item><p>GASAL2 can also compute the second-best local alignment score. GASAL only computes the best score.</p></list-item><list-item><p>GASAL2 has a reverse-complementing GPU kernel. In NVBIO and GASAL, the user has to manually reverse-complement the sequence before writing it to the input batch.</p></list-item></list></p>
    </sec>
  </sec>
  <sec id="Sec12" sec-type="results">
    <title>Results</title>
    <sec id="Sec13">
      <title>Input dataset and execution platforms</title>
      <p>To evaluate the performance of GASAL2 we performed <italic>one-to-one pairwise</italic> alignments between two set of sequences. We considered the case of DNA read mapping. Read mappers have to perform billions of one-to-one pairwise alignments between short segments of DNA and substrings of the reference genome. In this paper, we also perform one-to-one pairwise alignments between two set of sequences for evaluation purposes. Affine-gap scoring scheme is used in which the match score, mis-match penalty, gap open penalty and gap extension penalty is 6, 4, 11 and 1, respectively. In the rest of the paper,we will refer to the substrings of the reference genome as <italic>target</italic> sequences. The length of the read sequence is fixed, while the length of the target sequence may vary. Table <xref rid="Tab1" ref-type="table">1</xref> shows the different datasets used in this paper. The read set consists of reads simulated with Wgsim [<xref ref-type="bibr" rid="CR23">23</xref>] using UCSC hg19 as the reference genome. To generate the target set, these reads and the hg19 reference genome are used as the input for BWA-MEM. During the seed-extension phase of BWA-MEM, the mapper aligns the reads with the substrings of the reference genome. These substrings are stored and used as the target set. Three typical read lengths generated by Illumina high-throughput DNA sequencing machines are used: DS100, DS150 and DS300 representing 100, 150 and 300bp, respectively. Table <xref rid="Tab1" ref-type="table">1</xref> shows the number of sequences in the read and target set and the corresponding maximum and average length of the sequences in each set. Minimum target sequence length in each case is approximately equal to the length of the read.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Characteristics of the input dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Dataset</th><th align="left" colspan="3">Read Set</th><th align="left" colspan="3">Target Set</th></tr><tr><th align="left"/><th align="left">avg. len.</th><th align="left">max. len.</th><th align="left">No. of seq.</th><th align="left">avg. len.</th><th align="left">max. len.</th><th align="left">No. of seq.</th></tr></thead><tbody><tr><td align="left">DS100</td><td align="left">100</td><td align="left">100</td><td align="left">10e6</td><td align="left">162</td><td align="left">177</td><td align="left">10e6</td></tr><tr><td align="left">DS150</td><td align="left">150</td><td align="left">150</td><td align="left">10e6</td><td align="left">260</td><td align="left">277</td><td align="left">10e6</td></tr><tr><td align="left">DS300</td><td align="left">300</td><td align="left">300</td><td align="left">10e6</td><td align="left">538</td><td align="left">571</td><td align="left">10e6</td></tr></tbody></table></table-wrap>
</p>
      <p>The CPU-based libraries are executed on a high end machine consisting of two 2.4 GHz Intel Xeon E5-2680 v4 (Broadwell) processors and 192 gigabytes of RAM. Each processor has 14 two-way hyper-threaded cores. Hence, there are 28 physical and 56 logical cores in total. We measured the execution time of the CPU-based libraries with 28 and 56 threads and reported the smallest execution time of the two. GASAL2 and NVBIO are executed on a NVIDIA Geforce GTX 1080 Ti GPU. Only one CPU thread is used in case of GASAL2 and NVBIO. GASAL2 is compiled with CUDA version 10.0.</p>
    </sec>
    <sec id="Sec14">
      <title>Libraries compared with GASAL2</title>
      <p>We compared GASAL2 against the fastest CPU and GPU based libraries available, which are: 
<list list-type="bullet"><list-item><p><italic>SeqAn</italic> contains the vectorized implementation of all types of alignments using SSE4, AVX2 and AVX512 SIMD instructions [<xref ref-type="bibr" rid="CR24">24</xref>]. For SeqAn we used the test-suite provided by the developers of the library [<xref ref-type="bibr" rid="CR25">25</xref>]. AVX2 implementation of SeqAn is used in the experiments with 16 bits per score. Since the test data set is based on Illumina reads, we have used align_bench_par and align_bench_par_trace which follows the <italic>chunked</italic> execution policy giving the fastest execution for short DNA reads. The chunked policy is also used to generate the results in [<xref ref-type="bibr" rid="CR24">24</xref>] for Illumina reads. align_bench_par calculates the alignment score and does not report the start and end positions of the alignment. We have not used the banded version of align_bench_par as it does not guarantee correct results. align_bench_par_trace is used for computing alignment with traceback. In this paper, we are performing one-to-one alignment for the experiments. The timings reported in the SeqAn paper [<xref ref-type="bibr" rid="CR24">24</xref>] are not for the one-to-one alignment. The paper used a so-called "olc" alignment mode which is similar to the different one-to-many alignments. The library is compiled with GCC 7.3.1.</p></list-item><list-item><p><italic>ksw</italic> module in klib [<xref ref-type="bibr" rid="CR26">26</xref>] contains a fast SSE based implementation local alignment algorithm. It can also compute the start-position, but does not compute the traceback for local alignment. It has a function for computing the traceback for global alignment, but it is not vectorized, and hence very slow. ksw is faster than SSW [<xref ref-type="bibr" rid="CR27">27</xref>]. We developed our own test program for ksw (commit:cc7e69f) which uses OpenMP to distribute the alignment tasks among the CPU threads. The test program is compiled with GCC 4.8.5 using O3 optimization flag.</p></list-item><list-item><p><italic>Parasail</italic> [<xref ref-type="bibr" rid="CR28">28</xref>] contains the SIMD implementation of the local, global and semi-global alignment with and without traceback. Ten types of semi-global alignments are supported. We developed our own test program for Parasail (version-2.4) which uses OpenMP to distribute the alignment tasks among the CPU threads. The test program is compiled with GCC 4.8.5 using O3 optimization flag. Parasail allows the user to choose between SSE and AVX2 SIMD implementations. It also consists of different vectorization approaches namely <italic>scan</italic>, <italic>striped</italic>, <italic>diagonal</italic> and <italic>blocked</italic>. We have used the <italic>scan</italic> approach implemented with AVX2 instructions as it is the fastest for our dataset. Parasail does not compute the start-position directly without computing traceback. Therefore, the original sequences are aligned to obtain score and end-position, then both sequences are reversed to calculate the start-position without traceback.</p></list-item><list-item><p><italic>NVBIO</italic> contains the GPU implementations of local global and semi-global alignment with and without traceback. Only one type of semi-global alignment is supported shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. We used sw-benchmark program in the NVBIO repository. The original program performs one-to-all alignments. We modified sw-benchmark to perform one-to-one alignments. Moreover, in the original program reading the sequences from the files and packing the sequences is done in a single API function call. To exclude the I/O time from the measurements, we first loaded the sequences in an array of strings and then pack the sequences using NVBIO API functions. NVBIO does not contain any function that directly computes the start-position of the alignment without computing the traceback. To compute the start-position without traceback, we make two copies of each sequence, one in original form and other reversed. The alignment of original sequences is used to compute the score and end-position, while the reverse sequence are aligned to compute the start-position. Moreover, as described before, NVBIO considers "N" as an ordinary base and extending the library to correctly handle the ambiguous base makes it more than 30% slower. In our comparison we have used the original NVBIO implementation. NVBIO is compiled with CUDA version 8 as it cannot be compiled with latest CUDA version.</p></list-item></list></p>
      <p>There are also very fast CPU-based libraries that compute the edit distance or sequence alignment with linear-gap penalty e.g. EDlib [<xref ref-type="bibr" rid="CR29">29</xref>], BitPAl [<xref ref-type="bibr" rid="CR30">30</xref>] and [<xref ref-type="bibr" rid="CR31">31</xref>]. EDlib computes the Levenshtein distance between two sequences. Edit distance is the minimum number of substitution, insertions and deletion required to transform one sequence to the other. BitPAl and BGSA [<xref ref-type="bibr" rid="CR31">31</xref>] can perform global and semi-global alignments with linear-gap penalty. Many bioinformatics applications require sequence alignment with affine-gap penalty which allows to have different penalties for gap opening and gap extension. Moreover EDlib, BitPAl and BGSA cannot compute local alignment.</p>
    </sec>
    <sec id="Sec15">
      <title>GASAL2 alignment kernel performance</title>
      <p>Table <xref rid="Tab2" ref-type="table">2</xref> shows a comparison of the alignment kernel execution times of NVBIO and GASAL2. The times listed in the table represent the total time spent in the GPU alignment kernel while performing all the one-to-one pairwise alignment between the sequences in the read and target set. These times do not include data packing and data copying time. Three different types of kernels are timed. The “only score” kernels only compute the score and end position. The “with start” kernels compute the score as well as start and end position without computing the traceback. There is no need to compute the start position for global alignment. The “with traceback” computes the actual alignment along with the score, start-position and end-position. The table shows that the alignment kernel execution times of NVBIO and GASAL2 are almost the same with and without computing the start-position. For finding the start-position GASAL2 kernel first finds the score and end-position. It then again aligns the two sequences in the backward direction beginning form the cell corresponding to the end-position. This backward alignment is halted as soon as its score reaches the previously calculated maximum score. This approach helps to reduce the number of DP cells need to be computed for finding the start-position. With traceback computation GASAL2 GPU kernels are around 4x faster than NVBIO. On the other hand, NVBIO is more space efficient and uses an approach similar to Myers-Miller algorithm [<xref ref-type="bibr" rid="CR32">32</xref>] to compute the traceback.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Alignment kernel times (in seconds) for NVBIO and GASAL2</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"/><th align="left" colspan="2">DS100</th><th align="left" colspan="2">DS150</th><th align="left" colspan="2">DS300</th></tr><tr><th align="left">GPU kernel</th><th align="left">NVBIO</th><th align="left">GASAL2</th><th align="left">NVBIO</th><th align="left">GASAL2</th><th align="left">NVBIO</th><th align="left">GASAL2</th></tr></thead><tbody><tr><td align="left">Local (only score)</td><td align="left">1</td><td align="left">1</td><td align="left">2.2</td><td align="left">2.2</td><td align="left">8.4</td><td align="left">9.6</td></tr><tr><td align="left">Local with start</td><td align="left">2</td><td align="left">1.9</td><td align="left">4.4</td><td align="left">3.3</td><td align="left">16.8</td><td align="left">13.6</td></tr><tr><td align="left">Local with traceback</td><td align="left">6</td><td align="left">1.58</td><td align="left">14</td><td align="left">3.6</td><td align="left">57.8</td><td align="left">15.5</td></tr><tr><td align="left">Semi-global (only score)</td><td align="left">0.9</td><td align="left">1</td><td align="left">2</td><td align="left">2.2</td><td align="left">8</td><td align="left">9.3</td></tr><tr><td align="left">Semi-global with start</td><td align="left">1.8</td><td align="left">1.8</td><td align="left">4</td><td align="left">3.9</td><td align="left">16</td><td align="left">16</td></tr><tr><td align="left">Semi-global with traceback</td><td align="left">6</td><td align="left">1.43</td><td align="left">14</td><td align="left">3.4</td><td align="left">62</td><td align="left">15</td></tr><tr><td align="left">Global (only score)</td><td align="left">0.9</td><td align="left">1</td><td align="left">2</td><td align="left">2.3</td><td align="left">8</td><td align="left">9.5</td></tr><tr><td align="left">Global with traceback</td><td align="left">6</td><td align="left">1.4</td><td align="left">14</td><td align="left">3.5</td><td align="left">63</td><td align="left">15</td></tr></tbody></table></table-wrap>
</p>
    </sec>
    <sec id="Sec16">
      <title>Total execution time</title>
      <p>In this section, we compare the performance of GASAL2 and other libraries in terms of the total execution time. The total execution time is the total time required to perform all the one-to-one pairwise alignment between the sequences in the read and target set. Figure <xref rid="Fig6" ref-type="fig">6</xref> shows the flow chart of the test program used to measure the total execution time of the GASAL2. While filling the parameters we specify the type of alignment algorithm and one of the three following types of computations: 1) only score and end-position. 2) score, start and end-position without traceback. 3)score, end-position start-position and actual alignment in CIGAR format. Two batches of 500K sequences each are filled in each iteration. Hence, there are 20 iterations in total for the dataset of 10 million pair of sequences. GASAL2 initializes 5 CUDA streams and each stream performs one-to-one alignment of 100K pair of sequences. The total execution time of GASAL2 is the time starting from selecting an available stream till the time all the streams are completed i.e. allowing all the operations, from copying batches to copying results, to finish. Since the data transfer time is much smaller than the GPU alignment kernel time (at most 30% of kernel time) and GASAL2 uses CUDA streams, the data transfer is almost entirely overlapped with GPU execution. For the experiments, we are not reverse-complementing the sequences.
<fig id="Fig6"><label>Fig. 6</label><caption><p>The flow chart of the test program used to measure the total execution time of GASAL2</p></caption><graphic xlink:href="12859_2019_3086_Fig6_HTML" id="MO6"/></fig>
</p>
      <sec id="Sec17">
        <title>Local alignment</title>
        <p>Figure <xref rid="Fig7" ref-type="fig">7</xref> shows the total execution times computing only the score and end-position of the alignment. In this case GASAL2, NVBIO, ksw and Parasail are reporting the score as well as the end-position of the alignment. SeqAn only reports the alignment score. The execution times for SeqAn, ksw and Parasail shown in Fig. <xref rid="Fig7" ref-type="fig">7</xref> are obtained with 56 CPU threads. For DS100, the figure shows that GASAL2 is 5.35x, 4.3x, 10x and 2x faster than ksw, Parasail, NVBIO and SeqAn, respectively. With DS150 the speedup of GASAL2 over ksw, Parasail, NVBIO and SeqAn is 4.75x, 3.6x, 7x and 2.4x, respectively. GASAL2 is 3.4x, 2.3x, 3.4x and 2.4x faster than ksw, Parasail, NVBIO and SeqAn, respectively for DS300. These results indicate that the speedup achieved by GASAL2 over ksw and Parasail decreases with longer reads. This is due to the fact that the ksw and Parasail use the striped heuristic that limits the computational complexity for longer reads, as compared to the GPU implementation. The results also show that the speedup achieved by GASAL2 compared to NVBIO decreases with longer reads. The reason for this decreasing speedup over NVBIO with increasing read lengths is the reduction of the data packing percentage (Fig. <xref rid="Fig3" ref-type="fig">3</xref>) as the alignment time continues to increase. GASAL2 speeds up the data packing while its alignment kernel performance remains similar to that of NVBIO. The speedup of GASAL2 over SeqAn remains constant around 2x with increasing read lengths. This is because both of them employ inter-sequence parallelization and use the standard DP algorithm having the complexity of |<italic>S</italic>1|×|<italic>S</italic>2| (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). Hence, the execution time increases quadratically with read length for both GASAL2 and SeqAn.
<fig id="Fig7"><label>Fig. 7</label><caption><p>Total execution times for local alignment computing only the score and end-position. The execution time of CPU-based libraries is obtained with 56 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig7_HTML" id="MO7"/></fig>
</p>
        <p>Figure <xref rid="Fig8" ref-type="fig">8</xref> shows the total execution time computing the start-position of the alignment without traceback. Since SeqAn neither reports the end-position nor the start-position, it is omitted in this comparison. The execution time values shown for ksw and Parasail are obtained with 56 CPU threads. The figure shows that GASAL2 is 6x, 5.3x and 4x faster than ksw; 4.8x, 3.7x and 2.4x faster than Prasail; 13x, 8.7x and 4.4x faster than NVBIO for DS100, DS150 and DS300 respectively. The reason for decreasing speedup of GASAL2 over CPU-based libraries is the same as described for local alignment without computing the start-position. The speedup over NVBIO is more in this case as compared to alignment without start-position computation. With start-position computation the packing time of NVBIO nearly doubles but the packing time of GASAL2 remains the same. Another interesting point to note is that the GASAL2 total execution time with start-position computation is smaller than the total alignment kernel time shown in Table <xref rid="Tab2" ref-type="table">2</xref>. This happens because the alignment kernels of 5 batches are launched in parallel and their execution may overlap on GPU.
<fig id="Fig8"><label>Fig. 8</label><caption><p>Total execution times for local alignment computing start-position without traceback. The execution time of CPU-based libraries is obtained with 56 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig8_HTML" id="MO8"/></fig>
</p>
        <p>Figure <xref rid="Fig9" ref-type="fig">9</xref> shows the total execution of the local alignment with traceback. The traceback computation gives the actual alignment between the pair of sequences along with the score, end-position and start-position. SeqAn and Parasail timings are obtained with 56 CPU threads. GASAL2 is 8.5x, 7.25x and 5x faster than NVBIO for DS100, DS150 and DS300, respectively. With increasing read lengths the data packing percentage in NVBIO decreases but the kernel speedup of GASAL2 over NVBIO remains constant (4x). The speedup of GASAL2 over SeqAn and Parasail is around 8x and 20X for all datasets.
<fig id="Fig9"><label>Fig. 9</label><caption><p>Total execution times for local alignment with traceback computation. The execution time of CPU-based libraries is obtained with 56 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig9_HTML" id="MO9"/></fig>
</p>
      </sec>
      <sec id="Sec18">
        <title>Semi-global and global alignment</title>
        <p>There are many types of semi-global alignments. All types of semi-global alignments are possible with GASAL2. SeqAn supports all types of semi-global alignments. Prasail support 10 types. NVBIO supports only one type. In the paper we are showing the results for semi-global alignment supported by all the libraries i.e. gaps at end and beginning of the read sequence are not penalized. The relative performance of GASAL2, Parasail and SeqAn for the remaining types is similar. Figure <xref rid="Fig10" ref-type="fig">10</xref> shows the total execution time of semi-global alignment computing only the score and end-position. Like local alignment, SeqAn only reports the alignment score. Whereas, GASAL2, Prasail and NVBIO compute the alignment score as well as the end-position of the alignment. The execution times for SeqAn and Parasail are obtained with 56 CPU threads. GASAL2 is 4x, 10x and 1.7x faster than Parasail, NVBIO and SeqAn, respectively for DS100. For DS150 the speedup of GASAL2 over Parasail, NVBIO and SeqAn is 3.4x, 6.8x and 1.9x, respectively. In case of DS300 GASAL2 is 2.2x, 3.75x and 2x faster than Parasail, NVBIO and SeqAn, respectively. The reasons for decreasing speedup over Parasail and NVBIO with increasing read lengths are the same as described for local alignment.
<fig id="Fig10"><label>Fig. 10</label><caption><p>Total execution times for semi-global alignment computing only the score and end-position. The execution time of CPU-based libraries is obtained with 56 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig10_HTML" id="MO10"/></fig>
</p>
        <p>Figure <xref rid="Fig11" ref-type="fig">11</xref> shows the total execution time of the semi-global alignment computing start-position without traceback. SeqAn does not compute the start-position, which is hence omitted in the comparison. The results for Parasail are obtained with 56 CPU threads. The figure shows that GASAL2 is 4.7x, 3.7x and 2.6x faster than Parasail and 13x, 8.4x and 4.4x faster than NVBIO for DS100, DS150 and DS300, respectively.
<fig id="Fig11"><label>Fig. 11</label><caption><p>Total execution times for semi-global alignment computing start-position without traceback. The execution time of CPU-based libraries is obtained with 56 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig11_HTML" id="MO11"/></fig>
</p>
        <p>Figure <xref rid="Fig12" ref-type="fig">12</xref> shows the total execution of the semi-global alignment with traceback. The speedups of GASAL2 over NVBIO and Parasail (56 CPU threads) are similar to local alignment. For SeqAn the fastest execution time for DS100 is obtained with 56 threads, whereas for DS150 and DS300 28 threads are faster than 56 threads. GASAL2 is 3x, 3.5x and 13.5x faster than SeqAn for DS100, DS150 and DS300 respectively.
<fig id="Fig12"><label>Fig. 12</label><caption><p>Total execution times for semi-global alignment with traceback computation. The execution time of CPU-based libraries is obtained with 56 threads except of SeqAn. For SeqAn the DS100 results are with 56 threads, whereas the DS150 and DS300 results are with 28 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig12_HTML" id="MO12"/></fig>
</p>
        <p>Figure <xref rid="Fig13" ref-type="fig">13</xref> and <xref rid="Fig14" ref-type="fig">14</xref> shows the total execution time required for global alignment without and with traceback, respectively. The thread settings and the speedups achieved by GASAL2 are similar to that of semi-global alignment. With traceback computation GASAL2 becomes even more faster than other CPU libraries. For semi-global and global alignments with traceback the speedup of GASAL2 over SeqAn increases with increasing read lengths.
<fig id="Fig13"><label>Fig. 13</label><caption><p>Total execution times for global alignment without traceback. The execution time of CPU-based libraries is obtained with 56 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig13_HTML" id="MO13"/></fig><fig id="Fig14"><label>Fig. 14</label><caption><p>Total execution times for global alignment with traceback computation. The execution time of CPU-based libraries is obtained with 56 threads except for SeqAn. For SeqAn the DS100 results are with 56 threads, whereas the DS150 and DS300 results are with 28 threads</p></caption><graphic xlink:href="12859_2019_3086_Fig14_HTML" id="MO14"/></fig>
</p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec19" sec-type="discussion">
    <title>Discussion</title>
    <p>GASAL2 is a GPU accelerated sequence alignment library. It can perform global alignment, local alignment and all types of semi-global alignment with and without traceback. It returns the alignment score, end-position and optionally the start-position of the alignment. It can also compute the second best local alignment score. Results show that GASAL2 is faster than NVBIO and state-of-the-art CPU-based SIMD libraries, making it a good choice for sequence alignment in high-throughput NGS data processing libraries. In the following, we show how to use the library to accelerate the BWA-MEM application.</p>
    <sec id="Sec20">
      <title>Case Study:</title>
      <p>BWA-MEM is a well known <italic>seed-and-extend</italic> DNA read mapper. In the seeding step, it finds substrtings of the read that match exactly somewhere in the reference genome. In the extension step, BWA-MEM tries to align the whole read around that match. The algorithm used in the extension step is similar to local alignment, where the start-position is also calculated. We accelerated BWA-MEM using GASAL2. Two paired-end read datasets of length 150 bp (SRR949537) and 250 bp (SRR835433) are used. The experiments are run on an NVIDIA Tesla K40c GPU. The GPU host machine has two 2.4GHz Intel Xeon E5-2620 v3 processors and 32 gigabytes of RAM. Each processor has six cores with 2-way hyper-threading. The BWA-MEM version used in this case study is 0.7.13. We also accelerated BWA-MEM using GASAL and compared it with the results obtained with GASAL2. The original GASAL published in [<xref ref-type="bibr" rid="CR22">22</xref>] has two shortcomings described in “<xref rid="Sec11" ref-type="sec">GASAL2 versus GASAL and NVBIO</xref>” section: a) GASAL treats base ’N’ as an ordinary base. This causes BWA-MEM to abort due to an error. We updated GASAL so that it treats base ’N’ in the same manner as GASAL2, b) GASAL allocates and de-allocates the GPU memory just before and after the memory transfers between CPU and GPU, respectively. This causes the whole BWA-MEM application to slow down substantially due to repetitive GPU memory allocations and de-allocations. We updated GASAL so that the memory allocation and de-allocation are performed same as in GASAL2 i.e. only once, at the beginning and end of the application. The accelerated BWA-MEM is executed in the same manner as the original BWA-MEM (same command line arguments). The only difference between the accelerated BWA-MEM and the original version is that the seed-extension is performed on the GPU instead of CPU.</p>
      <sec id="Sec21">
        <title>Execution timeline</title>
        <p>Figure <xref rid="Fig15" ref-type="fig">15</xref> shows the execution timeline of BWA-MEM before and after acceleration. Figure <xref rid="Fig15" ref-type="fig">15</xref>a shows the execution in the original BWA-MEM. Figure <xref rid="Fig15" ref-type="fig">15</xref>b shows the BWA-MEM execution with the extension step accelerated using GASAL. Note that the seeding and extension steps are performed for a batch of reads to mitigate the CPU-GPU memory transfer overhead and to fully utilize GPU resources. Furthermore, the thread running on the CPU remains idle while the extension is performed on the GPU. Figure <xref rid="Fig15" ref-type="fig">15</xref>c shows how the GASAL2 alignment function can be used for overlapping CPU and GPU execution. A batch of reads is further broken down into <italic>sub-batches</italic>, numbered 1, 2 and 3. CPU execution is overlapped with the seed extension on GPU. This is achieved via the GASAL2 asynchrnous alignment function call facility. Empty time slots on the CPU timeline are also present in (c), but these are much smaller than (b). These empty slots in (c) will not be present if extension on GPU is faster than post-extension processing or vice-versa. We test both approaches i.e. (b) and (c), to accelerate the extension step of BWA-MEM. In practice, due to load balancing (explained below) we used a batch size that varies between 5000 to 800 reads. The number of sub-batches are either 5 or 4.
<fig id="Fig15"><label>Fig. 15</label><caption><p>Execution timeline of original and accelerated BWA-MEM</p></caption><graphic xlink:href="12859_2019_3086_Fig15_HTML" id="MO15"/></fig>
</p>
      </sec>
      <sec id="Sec22">
        <title>Load balancing</title>
        <p>In the original BWA-MEM, each thread is assigned a number of reads to process and one read is processed by a thread at a time. If a thread has finished processing all of its allocated reads, it will process the remaining reads of unfinished threads. Due to this, all of the threads remain busy until the whole data is processed resulting in maximum CPU utilization. On the other hand, in case of GPU acceleration reads are processed in the form of batches. Therefore, some threads may finish earlier than others and remain idle while waiting for all of the threads to finish. The idle time of these threads causes underutilization of the CPU. Decreasing the batch size helps to increase the CPU utilization, but at the same time may reduce the alignment function speedup due to increased data transfer overhead and poor GPU utilization. To circumvent this problem, we used dynamic batch sizes in our implementation. At the start, the batch size for each CPU thread is 5000 reads, but can be reduced to as low as 800 reads, depending upon the number of free threads which have finished processing there allocated reads. Doing so help to reduce the time wasted by a CPU thread in waiting for other threads to finish. We measured the <italic>wasted time</italic> as the difference between the finishing times of slowest and the fastest thread. By applying our dynamic batch size approach the wasted time is reduced by 3x for 150bp reads and 2x for 250 bp reads with 12 CPU threads.</p>
      </sec>
      <sec id="Sec23">
        <title>Performance with 150bp reads</title>
        <p>For 150bp reads, Fig. <xref rid="Fig16" ref-type="fig">16</xref> shows the comparison of time spent in the seed extension for the original BWA-MEM executed on the host CPU and the GPU accelerated BWA-MEM in which the seed extension is performed using GASAL2 alignment functions. The extension performed using GASAL2 (GASAL2-extend) is the sum of time to asynchronously call the GASAL2 alignment function and the time required in getting back the results using gasal_is_aln_async_done() function, in addition to the time of the empty slots before the post-processing of the last sub-batch. GASAL2-extend is more than 42x faster than the CPU time represented by original BWA-MEM extension function(orig-extend) for one thread, and over 20x faster for 12 CPU threads. Hence, the GASAL2 asynchronous alignment function allows to completely eliminate the seed extension time. The GASAL alignment function (GASAL-extend) is 3-4x slower than GASAL2-extend and is hence around 7-10x fassimilarter than orig-extend.
<fig id="Fig16"><label>Fig. 16</label><caption><p>Time spent in the extension step of BWA-MEM for 150bp reads</p></caption><graphic xlink:href="12859_2019_3086_Fig16_HTML" id="MO16"/></fig>
</p>
        <p>Figure <xref rid="Fig17" ref-type="fig">17</xref> shows the total execution times of the original BWA-MEM and GASAL2 for 150bp data. The <italic>ideal-total</italic> is total execution time for the case in which the time spent in the extension step is zero, and thus, represents the maximum achievable speedup. For 1 to 4 CPU thread, the GPU speedup is almost identical to the ideal one. For higher CPU threads, the speedup is slightly smaller than ideal. For 12 threads, the GASAL2 speedup and ideal speedup are 1.3 and 1.36, respectively. Since the time consumed by the seed extension function in BWA-MEM is 25-27%, the total execution time of GASAL is only slightly higher than GASAL2. For 12 threads, the GASAL speedup is 1.26. The main cause of the difference between ideal and actual speedup for higher number of CPU threads is imperfect load balancing between the CPU threads.
<fig id="Fig17"><label>Fig. 17</label><caption><p>Total execution time of BWA-MEM for 150 bp reads</p></caption><graphic xlink:href="12859_2019_3086_Fig17_HTML" id="MO17"/></fig>
</p>
      </sec>
      <sec id="Sec24">
        <title>Performance with 250 bp reads</title>
        <p>Same analysis is repeated for 250 bp reads. Figure <xref rid="Fig18" ref-type="fig">18</xref> shows the seed extension time of original BWA-MEM and GASAL2 alignment functions. GASAL2-extend is 32x to 14x faster than orig-extend for 1 to 12 CPU threads, respectively. The reduction in speed-up as compared to 150bp reads is due to reduction in GPU alignment kernel speed for longer reads, which widens the empty slots in the CPU timeline of Fig. <xref rid="Fig15" ref-type="fig">15</xref>c. GASAL-extend is 7x to 3x faster than CPU extension for 1 to 12 CPU threads, respectively. This means that GASAL-extend is 4-5x slower than GASAL2-extend. Hence, for longer reads the speedup of GASAL2 over GASAL increases.
<fig id="Fig18"><label>Fig. 18</label><caption><p>Time spent in the extension step of BWA-MEM for 250bp reads</p></caption><graphic xlink:href="12859_2019_3086_Fig18_HTML" id="MO18"/></fig>
</p>
        <p>Figure <xref rid="Fig19" ref-type="fig">19</xref> shows the total execution time for 250 bp reads. For up to 2 CPU threads, GASAL2-total, GASAL-total and ideal-total all are the same. Above 2 CPU threads, GASAL2-total becomes faster than GASAL-total. For 12 CPU threads, the ideal speedup is 1.49 whereas the speedup with GASAL2 and GASAL is 1.35 and 1.2, respectively. The gap between the ideal speedup and speedup achieved with GASAL2 is larger for 250 bp reads as compared to 150 bp reads. This happened due to imperfect load balancing between threads as well as decreased speedup of the seed extension step for 250bp reads.
<fig id="Fig19"><label>Fig. 19</label><caption><p>Total execution time of BWA-MEM for 250 bp reads</p></caption><graphic xlink:href="12859_2019_3086_Fig19_HTML" id="MO19"/></fig>
</p>
        <p>In summary GASAL2 gives seed-extension speedup in excess of 10x even when 12 CPU threads share a single NVIDIA Tesla K40c GPU.</p>
      </sec>
    </sec>
  </sec>
  <sec id="Sec25" sec-type="conclusion">
    <title>Conclusions</title>
    <p>In this paper, we presented GASAL2, a high performance and GPU accelerated library, for pairwise sequence alignment of DNA and RNA sequences. The GASAL2 library provides accelerated kernels for local, global as well as semi-global alignment, allowing the computation of the alignment with and without traceback. It can also compute the start position without traceback. In addition, one-to-one as well as all-to-all and one-to-many pairwise alignments can be performed. GASAL2 uses the novel approach of also performing the sequence packing on GPU, which is over 750x faster than the NVBIO approach. GASAL2 alignment functions are asynchronous/non-blocking which allow fully overlapping CPU and GPU execution. GASAL2 can compute all types of semi-global alignments. These represent unique capabilities not available in any earlier GPU sequence alignment library. The paper compared GASAL2’s performance with the fastest CPU-optimized SIMD implementations such as SeqAn, ksw, Parasail and NVBIO (NVIDIA’s own GPU library for sequence analysis of high-throughput sequencing data). Experimental results performed on the Geforce GTX 1080 Ti GPU show that GASAL2 is up to 5.35x faster than 56 Intel Xeon threads and up to 10x faster than NVBIO with a read length of 100bp, computing only the score and end-position. For 150bp reads, the speedup of GASAL2 over CPU implementations (56 Intel Xeon threads) and NVBIO is up to 4.75x and up to 7x, respectively. With 300bp reads, GASAL2 is up to 3.4x faster than CPU (56 Intel Xeon threads) and NVBIO. The speedup of GASAL2 over CPU implementations (56 Intel Xeon threads) computing start-position without traceback is up to 6x, 5.3x and 4x for 100, 150 and 300bp reads, respectively. With start-position computation, the speedup of GASAL2 over NVBIO is up to 13x, 8.7x and 4.4x for 100, 150 and 300bp reads, respectively. With traceback computation GASAL2 becomes even faster. GASAL2 traceback alignment is 13x and 20x faster than SeqAn and Parasail for read lengths of up to 300 bases. The GPU traceback alignment kernel of GASAL2 is 4x faster than NVBIO’s kernel, giving an overall speedup of 9x, 7x and 5x for 100, 150 and 300bp reads, respectively. GASAL2 is used to accelerate the seed extension function of BWA-MEM DNA read mapper. It is more than 20x faster than the CPU seed extension functions with 12 CPU threads. This allows us to achieve nearly ideal speedup for 150 bp reads. The library provides easy to use APIs to allow integration into various bioinformatics tools. GASAL2 is publicly available and can be downloaded from: <ext-link ext-link-type="uri" xlink:href="https://github.com/nahmedraja/GASAL2">https://github.com/nahmedraja/GASAL2</ext-link>.</p>
  </sec>
  <sec id="Sec26">
    <title>Availability and requirements</title>
    <p><bold>Project name:</bold> GASAL2- GPU Accelerated Sequence Alignment Library.</p>
    <p>
      <bold>Project home page:</bold>
      <ext-link ext-link-type="uri" xlink:href="https://github.com/nahmedraja/GASAL2">https://github.com/nahmedraja/GASAL2</ext-link>
    </p>
    <p><bold>Operating system(s):</bold> Linux</p>
    <p><bold>Programming language:</bold> C++, CUDA</p>
    <p><bold>Other requirements:</bold> CUDA toolkit version 8 or higher.</p>
    <p><bold>License:</bold> Apache 2.0</p>
    <p><bold>Any restrictions to use by non-academics:</bold> Not applicable</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>AVX2</term>
        <def>
          <p>Advanced vector extensions version-2</p>
        </def>
      </def-item>
      <def-item>
        <term>CPU</term>
        <def>
          <p>Central processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>CUDA</term>
        <def>
          <p>Compute unified device architecture</p>
        </def>
      </def-item>
      <def-item>
        <term>GPU</term>
        <def>
          <p>Graphical processing unit</p>
        </def>
      </def-item>
      <def-item>
        <term>NGS</term>
        <def>
          <p>Next generation sequencing</p>
        </def>
      </def-item>
      <def-item>
        <term>SIMD</term>
        <def>
          <p>Single instruction multiple data</p>
        </def>
      </def-item>
      <def-item>
        <term>SM</term>
        <def>
          <p>Streaming multiprocessor</p>
        </def>
      </def-item>
      <def-item>
        <term>SP</term>
        <def>
          <p>Streaming processor</p>
        </def>
      </def-item>
      <def-item>
        <term>SSE</term>
        <def>
          <p>Streaming SIMD extensions</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>NA carried out the study, developed the library, performed the experiments and wrote the manuscript. JL contributed in the library development and writing the manuscript. SR and HM provide useful suggestions and revised the manuscript. KB headed the research and revised the manuscript. ZA proposed the idea, supervised the research and helped in writing the manuscript. All authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Not applicable.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>Not applicable.</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p>Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <mixed-citation publication-type="other">Li H. Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM. arXiv. 2013.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>S</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <lpage>59</lpage>
        <?supplied-pmid 22388286?>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">Huang X, Yang S-P. Generating a Genome Assembly with PCAP. 2002.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <mixed-citation publication-type="other">de la Bastide M, McCombie WR. Assembling Genomic DNA Sequences with PHRAP. 2002.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salmela</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Schröder</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Correcting errors in short reads by multiple alignments</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>11</issue>
        <fpage>1455</fpage>
        <lpage>61</lpage>
        <?supplied-pmid 21471014?>
        <pub-id pub-id-type="pmid">21471014</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kao</surname>
            <given-names>W-C</given-names>
          </name>
          <name>
            <surname>Chan</surname>
            <given-names>AH</given-names>
          </name>
          <name>
            <surname>Song</surname>
            <given-names>YS</given-names>
          </name>
        </person-group>
        <article-title>ECHO: a reference-free short-read error correction algorithm</article-title>
        <source>Genome Res</source>
        <year>2011</year>
        <volume>21</volume>
        <issue>7</issue>
        <fpage>1181</fpage>
        <lpage>92</lpage>
        <?supplied-pmid 21482625?>
        <pub-id pub-id-type="pmid">21482625</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <mixed-citation publication-type="other">Poplin R, et al. Scaling accurate genetic variant discovery to tens of thousands of samples. bioRxiv. 2017.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J Mole Biol</source>
        <year>1970</year>
        <volume>48</volume>
        <issue>3</issue>
        <fpage>443</fpage>
        <lpage>53</lpage>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mole Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <issue>1</issue>
        <fpage>195</fpage>
        <lpage>7</lpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>J Mole Biol</source>
        <year>1982</year>
        <volume>162</volume>
        <issue>3</issue>
        <fpage>705</fpage>
        <lpage>8</lpage>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="book">
        <person-group person-group-type="editor">
          <name>
            <surname>Alexandrov</surname>
            <given-names>VN</given-names>
          </name>
          <name>
            <surname>van Albada</surname>
            <given-names>GD</given-names>
          </name>
          <name>
            <surname>Sloot</surname>
            <given-names>PMA</given-names>
          </name>
          <name>
            <surname>Dongarra</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <source>GPU Accelerated Smith-Waterman</source>
        <year>2006</year>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Wirawan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>CUDASW++ 3.0: Accelerating Smith-Waterman protein database search by coupling CPU and GPU SIMD instructions</article-title>
        <source>BMC Bioinformatics</source>
        <year>2013</year>
        <volume>14</volume>
        <issue>1</issue>
        <fpage>117</fpage>
        <?supplied-pmid 23557111?>
        <pub-id pub-id-type="pmid">23557111</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hasan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Kentie</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>DOPA: GPU-based protein alignment using database and memory access optimizations</article-title>
        <source>BMC Res Notes</source>
        <year>2011</year>
        <volume>4</volume>
        <issue>1</issue>
        <fpage>261</fpage>
        <?supplied-pmid 21798061?>
        <pub-id pub-id-type="pmid">21798061</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Bertels</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Al-Ars</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Efficient Acceleration of the Pair-HMMs Forward Algorithm for GATK HaplotypeCaller on Graphics Processing Units</article-title>
        <source>Evol Bioinforma</source>
        <year>2018</year>
        <volume>14</volume>
        <fpage>1176934318760543</fpage>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Ren S, Ahmed N, Bertels K, Al-Ars Z. An Efficient GPU-Based de Bruijn Graph Construction Algorithm for Micro-Assembly. In: 2018 IEEE 18th International Conference on Bioinformatics and Bioengineering (BIBE): 2018. p. 67–72.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kalaiselvi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Sriramakrishnan</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Somasundaram</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Survey of using gpu cuda programming model in medical image analysis</article-title>
        <source>Informa Med Unlocked</source>
        <year>2017</year>
        <volume>9</volume>
        <fpage>133</fpage>
        <lpage>44</lpage>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sriramakrishnan</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Kalaiselvi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rajeswaran</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Modified local ternary patterns technique for brain tumour segmentation and volume estimation from mri multi-sequence scans with gpu cuda machine</article-title>
        <source>Biocyber Biomed Eng</source>
        <year>2019</year>
        <volume>39</volume>
        <issue>2</issue>
        <fpage>470</fpage>
        <lpage>87</lpage>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <mixed-citation publication-type="other">Bhosale P, Staring M, Al-Ars Z, Berendsen FF. GPU-based stochastic-gradient optimization for non-rigid medical image registration in time-critical applications. In: SPIE Medical Imaging 2018: 2018.</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Blazewicz</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Frohmberg</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Kierzynka</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Pesch</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Wojciechowski</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Protein alignment algorithms with an efficient backtracking routine on multiple GPUs</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <issue>1</issue>
        <fpage>181</fpage>
        <?supplied-pmid 21599912?>
        <pub-id pub-id-type="pmid">21599912</pub-id>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>GSWABE: faster GPU-accelerated sequence alignment with optimal alignment retrieval for short DNA sequences</article-title>
        <source>Concurr Comput: Pract Exp</source>
        <year>2015</year>
        <volume>27</volume>
        <issue>4</issue>
        <fpage>958</fpage>
        <lpage>72</lpage>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <mixed-citation publication-type="other">Pantaleoni J, Subtil N. NVBIO. 2015. <ext-link ext-link-type="uri" xlink:href="https://nvlabs.github.io/nvbio">https://nvlabs.github.io/nvbio</ext-link>. Accessed 1 October, 2017.</mixed-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <mixed-citation publication-type="other">Ahmed N, Mushtaq H, Bertels K, Al-Ars Z. GPU accelerated API for alignment of genomics sequencing data. In: 2017 IEEE International Conference on Bioinformatics and Biomedicine (BIBM): 2017. p. 510–5.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Li H. wgsim: Reads simulator. <ext-link ext-link-type="uri" xlink:href="https://github.com/lh3/wgsim">https://github.com/lh3/wgsim</ext-link>. Accessed 1 October, 2017.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ehrhardt</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rahn</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Budach</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Costanza</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Hancox</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Generic accelerated sequence alignment in SeqAn using vectorization and multi-threading</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <issue>20</issue>
        <fpage>3437</fpage>
        <lpage>45</lpage>
        <?supplied-pmid 29726911?>
        <pub-id pub-id-type="pmid">29726911</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <mixed-citation publication-type="other">R R. DP Bench - A benchmark tool for SeqAn’s alignment engine.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <mixed-citation publication-type="other">Chaos A. Klib: a Generic Library in C. <ext-link ext-link-type="uri" xlink:href="https://github.com/attractivechaos/klib">https://github.com/attractivechaos/klib</ext-link>. Accessed 2 January, 2019.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>Mengyao</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>Wan-Ping</given-names>
          </name>
          <name>
            <surname>Garrison</surname>
            <given-names>Erik P.</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>Gabor T.</given-names>
          </name>
        </person-group>
        <article-title>SSW Library: An SIMD Smith-Waterman C/C++ Library for Use in Genomic Applications</article-title>
        <source>PLoS ONE</source>
        <year>2013</year>
        <volume>8</volume>
        <issue>12</issue>
        <fpage>e82138</fpage>
        <?supplied-pmid 24324759?>
        <pub-id pub-id-type="pmid">24324759</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Daily</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Parasail: SIMD C library for global, semi-global, and local pairwise sequence alignments</article-title>
        <source>BMC Bioinformatics</source>
        <year>2016</year>
        <volume>17</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <lpage>11</lpage>
        <pub-id pub-id-type="pmid">26817711</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Šošić</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Šikić</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Edlib: a C/C++ library for fast, exact sequence alignment using edit distance</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>33</volume>
        <issue>9</issue>
        <fpage>1394</fpage>
        <lpage>5</lpage>
        <?supplied-pmid 28453688?>
        <pub-id pub-id-type="pmid">28453688</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Benson</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Loving</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Hernandez</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>22</issue>
        <fpage>3166</fpage>
        <lpage>73</lpage>
        <?supplied-pmid 25075119?>
        <pub-id pub-id-type="pmid">25075119</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <mixed-citation publication-type="other">Lan H, Zhang J, Chan Y, Liu W, Shang Y, Schmidt B. BGSA: a bit-parallel global sequence alignment toolkit for multi-core and many-core architectures. 2018.</mixed-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Optimal alignments in linear space</article-title>
        <source>Bioinformatics</source>
        <year>1988</year>
        <volume>4</volume>
        <issue>1</issue>
        <fpage>11</fpage>
        <lpage>7</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
