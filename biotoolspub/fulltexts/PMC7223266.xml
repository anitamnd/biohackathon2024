<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7223266</article-id>
    <article-id pub-id-type="pmid">31406990</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz575</article-id>
    <article-id pub-id-type="publisher-id">btz575</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Haplotype-aware graph indexes</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Sirén</surname>
          <given-names>Jouni</given-names>
        </name>
        <xref rid="btz575-cor1" ref-type="corresp"/>
        <aff><institution>UC Santa Cruz Genomics Institute, University of California</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
        <aff><institution>Wellcome Sanger Institute, Wellcome Genome Campus</institution>, Hinxton CB10 1SA, <country country="GB">UK</country></aff>
        <!--jouni.siren@iki.fi-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Garrison</surname>
          <given-names>Erik</given-names>
        </name>
        <aff><institution>Wellcome Sanger Institute, Wellcome Genome Campus</institution>, Hinxton CB10 1SA, <country country="GB">UK</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Novak</surname>
          <given-names>Adam M</given-names>
        </name>
        <aff><institution>UC Santa Cruz Genomics Institute, University of California</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Paten</surname>
          <given-names>Benedict</given-names>
        </name>
        <aff><institution>UC Santa Cruz Genomics Institute, University of California</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Durbin</surname>
          <given-names>Richard</given-names>
        </name>
        <aff><institution>Wellcome Sanger Institute, Wellcome Genome Campus</institution>, Hinxton CB10 1SA, <country country="GB">UK</country></aff>
        <aff><institution>Department of Genetics, University of Cambridge</institution>, Cambridge CB2 3EH, <country country="GB">UK</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Valencia</surname>
          <given-names>Alfonso</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btz575-cor1">To whom correspondence should be addressed. Email: <email>jouni.siren@iki.fi</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>15</day>
      <month>1</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-26">
      <day>26</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>26</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <volume>36</volume>
    <issue>2</issue>
    <fpage>400</fpage>
    <lpage>407</lpage>
    <history>
      <date date-type="received">
        <day>20</day>
        <month>2</month>
        <year>2019</year>
      </date>
      <date date-type="rev-recd">
        <day>29</day>
        <month>5</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>18</day>
        <month>7</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz575.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The variation graph toolkit (VG) represents genetic variation as a graph. Although each path in the graph is a potential haplotype, most paths are non-biological, unlikely recombinations of true haplotypes.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We augment the VG model with haplotype information to identify which paths are more likely to exist in nature. For this purpose, we develop a scalable implementation of the graph extension of the positional Burrows–Wheeler transform. We demonstrate the scalability of the new implementation by building a whole-genome index of the 5008 haplotypes of the 1000 Genomes Project, and an index of all 108 070 Trans-Omics for Precision Medicine Freeze 5 chromosome 17 haplotypes. We also develop an algorithm for simplifying variation graphs for <italic toggle="yes">k</italic>-mer indexing without losing any <italic toggle="yes">k</italic>-mers in the haplotypes.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>Our software is available at <ext-link xlink:href="https://github.com/vgteam/vg" ext-link-type="uri">https://github.com/vgteam/vg</ext-link>, <ext-link xlink:href="https://github.com/jltsiren/gbwt" ext-link-type="uri">https://github.com/jltsiren/gbwt</ext-link> and <ext-link xlink:href="https://github.com/jltsiren/gcsa2" ext-link-type="uri">https://github.com/jltsiren/gcsa2</ext-link>.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="doi">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>5U41HG007234</award-id>
        <award-id>1U01HL137183-01</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Wellcome Trust</institution>
            <institution-id institution-id-type="doi">10.13039/100010269</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>WT206194</award-id>
        <award-id>WT207492</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>W. M. Keck Foundation</institution>
            <institution-id institution-id-type="doi">10.13039/100000888</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>DT06172015</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Sequence analysis pipelines often start by mapping the sequence reads to a <italic toggle="yes">reference genome</italic> of the same species. A read aligner first uses a <italic toggle="yes">text index</italic> to find candidate positions for the read. Then it aligns the read to the candidate positions, trying to find the best mapping.</p>
    <p>A reference genome that takes the form of a single sequence may represent a new dataset poorly if the sequenced individual diverges substantially at some location. Mapping reads to such a reference can introduce <italic toggle="yes">reference bias</italic> into the subsequent analysis. Richer reference models can help to avoid the bias, but challenges remain in choosing the right model and working with it effectively (<xref rid="btz575-B23" ref-type="bibr">Paten <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btz575-B31" ref-type="bibr">The Computational Pan-Genomics Consortium, 2018</xref>).</p>
    <p>We can replace the single reference sequence with a collection of haplotypes. Because individual genomes are similar, compressed text indexes can store such collections in very little space (<xref rid="btz575-B18" ref-type="bibr">Mäkinen <italic toggle="yes">et al.</italic>, 2010</xref>). However, due to this similarity, most reads map equally well to many haplotypes. If the reference model is a simple collection, we cannot tell whether a read maps to the same position in different haplotypes or not.</p>
    <p>If the haplotypes are aligned, we can use the alignment to determine whether the mappings are equivalent. Text indexes can also take advantage of the alignment by storing shared substrings only once (<xref rid="btz575-B13" ref-type="bibr">Huang <italic toggle="yes">et al.</italic>, 2010</xref>). The FM-index of alignment (<xref rid="btz575-B20" ref-type="bibr">Na <italic toggle="yes">et al.</italic>, 2016</xref>, <xref rid="btz575-B21" ref-type="bibr">2018</xref>) goes one step further by collapsing the multiple alignment into a <italic toggle="yes">directed acyclic graph</italic> (DAG), where each node is labeled by a sequence. It indexes the graph and stores some additional information for determining which paths correspond to valid haplotypes.</p>
    <p>We can also build a reference graph directly from a reference sequence and a set of variants (<xref rid="btz575-B26" ref-type="bibr">Schneeberger <italic toggle="yes">et al.</italic>, 2009</xref>). This approach has been used in many tools such as BWBBLE (<xref rid="btz575-B12" ref-type="bibr">Huang <italic toggle="yes">et al.</italic>, 2013</xref>), GCSA (<xref rid="btz575-B29" ref-type="bibr">Sirén <italic toggle="yes">et al.</italic>, 2014</xref>), vBWT (<xref rid="btz575-B17" ref-type="bibr">Maciuca <italic toggle="yes">et al.</italic>, 2016</xref>), the Seven Bridges Graph Pipeline (<xref rid="btz575-B24" ref-type="bibr">Rakocevic <italic toggle="yes">et al.</italic>, 2019</xref>), Graphtyper (<xref rid="btz575-B6" ref-type="bibr">Eggertsson <italic toggle="yes">et al.</italic>, 2017</xref>) and VG (<xref rid="btz575-B10" ref-type="bibr">Garrison <italic toggle="yes">et al.</italic>, 2018</xref>). It will always produce a DAG if structural variants are not considered. Algorithms for working with sequences are often easy to generalize to DAGs. On the other hand, because an acyclic graph imposes a global alignment on the haplotypes, allowing only matches, mismatches and indels, it cannot represent structural variation such as duplications or inversions adequately.</p>
    <p>Assembly graphs such as <italic toggle="yes">de Bruijn graphs</italic> collapse sequences by local similarity instead of global alignment. They are better suited to handling structural variation than DAGs. However, the lack of a global coordinate system limits their usefulness as references.</p>
    <p>Graph-based reference models share certain weaknesses. Because they collapse sequences between variants, they represent both the original haplotypes and their <italic toggle="yes">recombinations</italic>: paths that switch between haplotypes. This may cause false positives when a read maps better to an unobserved recombination than to the correct path. Graph regions with many variants in close proximity can give rise to very large numbers of recombinant paths, and be too complex to allow an index to cover all possible paths in the graph. Graph tools try to deal with such regions by, for example, limiting the amount of variation in the graph, artificially simplifying complex regions and making trade-offs between query performance, index size and maximum query length.</p>
    <p>CHOP (<xref rid="btz575-B19" ref-type="bibr">Mokveld <italic toggle="yes">et al.</italic>, 2018</xref>) embeds haplotypes into a graph and indexes the corresponding paths. For a given parameter <italic toggle="yes">k</italic>, the graph is transformed into a collection of short strings such that adjacent strings overlap by <italic toggle="yes">k</italic> – 1 characters. Each haplotype can be represented as a sequence of adjacent strings. Any read aligner can be used to map reads to the strings. However, because the aligner sees only short strings, it cannot map long reads or paired-end reads.</p>
    <p>The <italic toggle="yes">variation graph toolkit</italic> (VG) (<xref rid="btz575-B10" ref-type="bibr">Garrison <italic toggle="yes">et al.</italic>, 2018</xref>) works with many kinds of graphs. While some other graph tools use graphs to represent other data types (e.g. aligned sequences, or variants), the graph itself is the primary object in the VG model. A global coordinate system can be provided by designating certain paths as <italic toggle="yes">reference paths</italic>.</p>
    <p>VG uses GCSA2 (<xref rid="btz575-B28" ref-type="bibr">Sirén, 2017</xref>) as its text index. GCSA2 represents a <italic toggle="yes">k</italic>-mer index as a de Bruijn graph and compresses it structurally by merging redundant nodes. VG handles complex graph regions by indexing a <italic toggle="yes">simplified graph</italic>, in which the complex regions are replaced by simpler graph structures, although the final alignment is done in the original graph. The drawback of this approach is that simplification can break paths corresponding to known haplotypes, while leaving paths representing recombinations intact.</p>
    <p>In this paper, we augment the VG model with haplotype information. We develop the Graph BWT (GBWT), a scalable implementation of the graph extension of the positional Burrows–Wheeler transform (gPBWT) (<xref rid="btz575-B5" ref-type="bibr">Durbin, 2014</xref>; <xref rid="btz575-B22" ref-type="bibr">Novak <italic toggle="yes">et al.</italic>, 2017</xref>), to store the haplotypes as paths in the graph. To demonstrate the scalability of the GBWT, we build a whole-genome index for the 1000 Genomes Project (<xref rid="btz575-B30" ref-type="bibr">The 1000 Genomes Project Consortium, 2015</xref>) haplotypes and a chromosome 17 index for the <italic toggle="yes">Trans-Omics for Precision Medicine</italic> (TOPMed) haplotypes. We also describe an algorithm that adds the haplotype paths back to the simplified graph, without re-introducing too much complexity, in order to make the text index more complete.</p>
    <p>The main differences from the old gPBWT implementation (<xref rid="btz575-B22" ref-type="bibr">Novak <italic toggle="yes">et al.</italic>, 2017</xref>) are:
<list list-type="bullet"><list-item><p>We use local structures for each node instead of global structures for the graph. The index is smaller and faster and takes better advantage of memory locality.</p></list-item><list-item><p>The GBWT is implemented as an ordinary text index instead of a special-purpose index for paths. Most FM-index algorithms can be used with it. For example, we can use the GBWT as an FMD-index (<xref rid="btz575-B15" ref-type="bibr">Li, 2012</xref>) and support bi-directional search.</p></list-item><list-item><p>We have a fast and space-efficient incremental construction algorithm that does not need access to the entire collection of haplotypes at the same time.</p></list-item><list-item><p>Our implementation can be used independently of VG.</p></list-item></list></p>
    <p>A preliminary version of this paper appeared in WABI 2018. In addition to a more extensive description and discussion, for this paper, we have improved the GBWT implementation in the following ways:
<list list-type="bullet"><list-item><p>VG now parses the VCF files once and stores the information in a format directly usable by GBWT construction. This makes index construction for the 1000 Genomes Project haplotypes almost three times faster than in the preliminary paper.</p></list-item><list-item><p>We further demonstrate the scalability of the GBWT by building a chromosome 17 index for the 108 070 TOPMed haplotypes from Freeze 5b, showing that we can build indexes for population cohorts more than an order of magnitude larger than in the original paper.</p></list-item><list-item><p>We adapt the BWT-merge algorithm (<xref rid="btz575-B27" ref-type="bibr">Sirén, 2016</xref>) for merging GBWT indexes over the same chromosome. By building indexes for multiple batches in parallel and merging them with the new algorithm, we make GBWT construction for the TOPMed haplotypes several times faster.</p></list-item><list-item><p>We can now remove paths from a GBWT index.</p></list-item></list></p>
    <p>The haplotype information stored in GBWT can also be used to improve read mapping, and, potentially, variant inference. For example, when we extend the seeds we get from a GCSA2 index, we can restrict the extension to paths corresponding to the haplotypes in the GBWT index. Alternatively, we may use the haplotype information for alignment scoring. We intend to explore these applications in a subsequent paper.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Background</title>
      <sec>
        <label>2.1.1</label>
        <title>Strings and graphs</title>
        <p>A <italic toggle="yes">string</italic> <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of length <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is a sequence of <italic toggle="yes">characters</italic> over an <italic toggle="yes">alphabet</italic> <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Text</italic> strings <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> are terminated by an <italic toggle="yes">end-marker</italic> <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>$</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> that does not occur anywhere else in the text. <italic toggle="yes">Substrings</italic> of string <italic toggle="yes">S</italic> are sequences of the form <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We call substrings of length <italic toggle="yes">k k</italic>-mers and substrings of the type <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">prefixes</italic> and <italic toggle="yes">suffixes</italic>, respectively.</p>
        <p>Let <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> be a string. We define <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the number of occurrences of character <italic toggle="yes">c</italic> in the prefix <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We also define <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">select</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo>∣</mml:mo><mml:mi>S</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as the position of the occurrence of rank <italic toggle="yes">i </italic>&gt;<italic toggle="yes"> </italic>0. A <italic toggle="yes">bit-vector</italic> is a data structure that stores a binary sequence and supports efficient <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula>/<inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">select</mml:mi></mml:mrow></mml:math></inline-formula> queries over it.</p>
        <p>A <italic toggle="yes">graph</italic> <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> consists of a finite set of <italic toggle="yes">nodes</italic> <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>⊂</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></inline-formula> and a set of <italic toggle="yes">edges</italic> <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo>⊆</mml:mo><mml:mi>V</mml:mi><mml:mo>×</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>. We assume that the edges are <italic toggle="yes">directed</italic>: <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> is an edge <italic toggle="yes">from</italic> node <italic toggle="yes">u to</italic> node <italic toggle="yes">v</italic>. The <italic toggle="yes">in-degree</italic> of node <italic toggle="yes">v</italic> is the number of <italic toggle="yes">incoming</italic> edges to <italic toggle="yes">v</italic>, while the <italic toggle="yes">out-degree</italic> is the number of <italic toggle="yes">outgoing</italic> edges from <italic toggle="yes">v</italic>. Let <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be a string over the set of nodes <italic toggle="yes">V</italic>. We say that <italic toggle="yes">P</italic> is a <italic toggle="yes">path</italic> in graph <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, if <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
        <p>The VG model (<xref rid="btz575-B10" ref-type="bibr">Garrison <italic toggle="yes">et al.</italic>, 2018</xref>) is based on <italic toggle="yes">bi-directed</italic> graphs, where each node has two <italic toggle="yes">orientations</italic>. We simulate them with directed graphs. We partition the set of nodes <italic toggle="yes">V</italic> into <italic toggle="yes">forward</italic> nodes <italic toggle="yes">V<sub>f</sub></italic> and <italic toggle="yes">reverse</italic> nodes <italic toggle="yes">V<sub>r</sub></italic>, with <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. We match each forward node <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with the corresponding reverse node <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. For all nodes <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we also require that <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>⇔</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>v</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>u</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <label>2.1.2</label>
        <title>FM-index</title>
        <p>The <italic toggle="yes">suffix array</italic> <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of text <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is an array of pointers to the suffixes of the text in <italic toggle="yes">lexicographic order</italic>. For all <italic toggle="yes">i </italic>&lt;<italic toggle="yes"> j</italic>, we have <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. The <italic toggle="yes">Burrows–Wheeler transform</italic> (BWT) (<xref rid="btz575-B2" ref-type="bibr">Burrows and Wheeler, 1994</xref>) is a permutation of the text with a similar combinatorial structure. We define it as the permuted string <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Let <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> be the number of occurrences of characters <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula> in the text. The main operation provided by the BWT is the last-first or <italic toggle="yes">LF-mapping</italic>, which we define as <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We use shorthand <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and note that <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mi>mod</mml:mi><mml:mo> </mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>Let <italic toggle="yes">X</italic> be a string and let <italic toggle="yes">c</italic> be a character. If <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> for <italic toggle="yes">i</italic> suffixes <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> of text <italic toggle="yes">T</italic>, we say that string <italic toggle="yes">X</italic> has <italic toggle="yes">lexicographic rank i</italic> among the suffixes of text <italic toggle="yes">T</italic>. The number of suffixes starting with any character <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>c</mml:mi></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and the number of suffixes <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> preceded by character <italic toggle="yes">c</italic> is <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Hence the lexicographic rank of string <italic toggle="yes">cX</italic> is <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>The FM-index (<xref rid="btz575-B7" ref-type="bibr">Ferragina and Manzini, 2005</xref>) is a text index based on the BWT. Assume that we can compute <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">t<sub>r</sub></italic> time. Further assume that we have stored <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> divisible by some integer <italic toggle="yes">d </italic>&gt;<italic toggle="yes"> </italic>0. The FM-index supports the following queries:
<list list-type="bullet"><list-item><p><inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">find</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: Return the <italic toggle="yes">lexicographic range</italic> <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of suffixes starting with <italic toggle="yes">pattern X</italic>. If <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the lexicographic range for pattern <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the range for pattern <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>e</mml:mi><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. By extending the pattern backwards, we can support <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">find</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> time.</p></list-item><list-item><p><inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: Return the list of <italic toggle="yes">occurrences</italic> <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. For each position <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we iterate <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> until we find a stored pair <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>L</mml:mi><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>L</mml:mi><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. Locating each occurrence <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> takes <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> time.</p></list-item><list-item><p><inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">extract</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: Return the substring <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We start from the nearest stored <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and iterate <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>←</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> until <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. As <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we extract the substring backwards in <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>−</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> time.</p></list-item></list></p>
        <p>A generalized FM-index can index <italic toggle="yes">multiple texts</italic> <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Each text <italic toggle="yes">T<sub>j</sub></italic> is terminated by a distinct end-marker <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>$</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>$</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mo>$</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for all <italic toggle="yes">j</italic>. As the suffixes of the texts are all distinct, we can sort them unambiguously. In the final BWT, we replace each <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>$</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mo>$</mml:mo></mml:math></inline-formula> in order to reduce alphabet size. The index works as with a single text, except that we cannot compute <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo>$</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We also define the <italic toggle="yes">document array</italic> <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DA</mml:mi></mml:mrow></mml:math></inline-formula> as an array of <italic toggle="yes">text identifiers</italic>. If <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> points to a suffix of text <italic toggle="yes">T<sub>j</sub></italic>, we define <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
    </sec>
    <sec>
      <title>2.2 Indexing haplotypes</title>
      <p>The positional BWT (<xref rid="btz575-B5" ref-type="bibr">Durbin, 2014</xref>) and its graph extension (<xref rid="btz575-B22" ref-type="bibr">Novak <italic toggle="yes">et al.</italic>, 2017</xref>) can be understood as ordinary FM-indexes. We develop the GBWT explicitly from this point of view, making it an FM-index of multiple texts over an integer alphabet <italic toggle="yes">V</italic>. Instead of storing the BWT as a single string, we partition it into substrings <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> corresponding to the most significant character <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> in the lexicographic ordering. We also use the substrings as the basic blocks for computing <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula> over the BWT. By storing the substring <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula> information in each node <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, the resulting index can take advantage of memory locality when the graph has a cache-friendly memory layout.</p>
      <sec>
        <label>2.2.1</label>
        <title>Positional BWT</title>
        <p>Assume that we have <italic toggle="yes">m</italic> haplotype strings <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of equal length over alphabet Σ. At each variant site <italic toggle="yes">i</italic>, character <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> tells whether haplotype <italic toggle="yes">j</italic> contains the reference allele (<inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) or an alternate allele (<inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>). Given a pattern <italic toggle="yes">X</italic> and a range of sites <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we want to find the haplotypes <italic toggle="yes">S<sub>j</sub></italic> matching the pattern at the specified sites (<inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula>). Ordinary FM-indexes do not support such queries, as they find all occurrences of the pattern, not just those at a particular position.</p>
        <p>The <italic toggle="yes">positional BWT</italic> (PBWT) (<xref rid="btz575-B5" ref-type="bibr">Durbin, 2014</xref>) is an FM-index that supports <italic toggle="yes">positional queries</italic>. We can interpret it as the FM-index of texts <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btz575-B8" ref-type="bibr">Gagie <italic toggle="yes">et al.</italic>, 2017</xref>). If we want to search for pattern <italic toggle="yes">X</italic> in range <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we search for pattern <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the FM-index. The texts are over a large alphabet, but their first-order empirical entropy is low. We can encode the BWT using alphabet Σ with a simple model. Assume that <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">SA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> points to a suffix starting with <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We often know the character from a previous query, and we can determine it using the <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mi>C</mml:mi></mml:math></inline-formula> array. Then <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mo>Σ</mml:mo></mml:mrow></mml:math></inline-formula>, and we can encode it as <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. (Note that we build the <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula> structure for the original BWT, not the encoded BWT.) When the collection of haplotype strings is repetitive, as it typically is with sufficiently large collections of biological haplotypes, we can compress the PBWT further by run-length encoding the BWT (<xref rid="btz575-B18" ref-type="bibr">Mäkinen <italic toggle="yes">et al.</italic>, 2010</xref>).</p>
      </sec>
      <sec>
        <label>2.2.2</label>
        <title>Graph extension</title>
        <p>Haplotypes correspond to paths in the VG model. Because chromosome-length phasings are often not available, there may be multiple paths for each haplotype. The <italic toggle="yes">graph extension</italic> of the PBWT (<xref rid="btz575-B22" ref-type="bibr">Novak <italic toggle="yes">et al.</italic>, 2017</xref>), or gPBWT, generalizes the PBWT to indexing such paths. While the original extension was specific to VG graphs, we present a general version over directed graphs. We call this structure the <italic toggle="yes">Graph BWT</italic> (GBWT), as it both represents arbitrary collections of paths over graphs and is encoded locally within the graph.</p>
        <p>Let <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be paths in graph <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We can interpret the paths as strings over alphabet <italic toggle="yes">V</italic>. Assume that <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, as we use it as the end-marker. We build an FM-index for the reverse strings. We sort reverse prefixes in lexicographic order, so the LF-mapping traverses edges in the correct direction and place the end-marker before the string.</p>
        <p>The GBWT supports the following variants of the basic FM-index queries:
<list list-type="bullet"><list-item><p><inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">find</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> returns the lexicographic range of reverse prefixes starting with the reverse pattern (the range of prefixes ending with the pattern).</p></list-item><list-item><p><inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> returns the text identifiers <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">DA</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We do not return text offsets, as the node corresponding to the range <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> already provides similar information.</p></list-item><list-item><p><inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">extract</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> returns the path <italic toggle="yes">P<sub>j</sub></italic>. We save memory by not supporting substring extraction.</p></list-item></list></p>
        <p>These queries should be understood as examples of what we can support. Because the GBWT is an FM-index of multiple texts, most algorithms using an FM-index can be adapted to use the GBWT. For example, let <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be a path. The <italic toggle="yes">reverse path</italic> of <italic toggle="yes">P</italic> is the path <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mo>·</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> traversing the reverse nodes in the reverse order. If we also index <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> for every path <italic toggle="yes">P</italic>, the GBWT becomes an FMD-index (<xref rid="btz575-B15" ref-type="bibr">Li, 2012</xref>) that supports bi-directional search.</p>
      </sec>
      <sec>
        <label>2.2.3</label>
        <title>Records</title>
        <p>For each node <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we define the <italic toggle="yes">local alphabet</italic> <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo>∣</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. We also add $ to Σ<sub><italic toggle="yes">v</italic></sub> if <italic toggle="yes">v</italic> is the last node on a path, and define <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mo>$</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> as the set of the initial nodes on each path. We partition the BWT into substrings <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> corresponding to the prefixes ending with <italic toggle="yes">v</italic>, and encode each substring <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> using the local alphabet Σ<sub><italic toggle="yes">v</italic></sub>. If <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">k</italic>th character in the local alphabet in sorted order, we encode it as <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
        <p>We develop a representation based on the following assumptions:
<list list-type="order"><list-item><p>Almost all nodes <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> have a low out-degree, making the local alphabet Σ<sub><italic toggle="yes">v</italic></sub> small. Hence we can afford storing the <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula> of all <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> at the start of <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Decompressing that information every time we access the node does not take too much time either.</p></list-item><list-item><p>The number of occurrences of almost all nodes is bounded by the number of haplotypes. As the length of <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is bounded for almost all <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, we can afford scanning it every time we compute <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula> within it.</p></list-item><list-item><p>The collection of paths is repetitive. Run-length encoding compresses the BWT well, reducing both index size and the time required for scanning <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>There exists an integer range <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that the set of nodes <italic toggle="yes">V</italic> is a dense subset of the range. Hence, we can afford storing some information for all <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> without using too much space.</p></list-item><list-item><p>The graph is almost linear and almost topologically sorted. The closer to topological order we can store the nodes, the less space we need for graph topology and the better we can take advantage of memory locality.</p></list-item></list></p>
        <p>All these are reasonable assumptions for a large set of biological haplotype sequences over a variation graph.</p>
        <p>We store a <italic toggle="yes">record</italic> consisting of a <italic toggle="yes">header</italic> and a <italic toggle="yes">body</italic> for each node <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula> and for the end-marker $. For each character <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mi>w</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in sorted order, the header stores a pair <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the total number of occurrences of character <italic toggle="yes">w</italic> in all <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mtext>with</mml:mtext><mml:mo> </mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>. The body run-length encodes <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, representing a run of <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> copies of character <italic toggle="yes">w</italic> as a pair <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Σ</mml:mo></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. See <xref rid="btz575-F1" ref-type="fig">Figure 1</xref> for an example.
</p>
        <fig position="float" id="btz575-F1">
          <label>Fig. 1.</label>
          <caption>
            <p>Top: A graph with three paths (lines above the nodes). Bottom: The GBWT of the paths, with lines connecting the paths' entries in each node's record</p>
          </caption>
          <graphic xlink:href="btz575f1" position="float"/>
        </fig>
        <p>Because the BWT is a set of records, we use node/offset pairs as <italic toggle="yes">positions</italic>. Pair (<italic toggle="yes">v</italic>, <italic toggle="yes">i</italic>) refers to offset <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We define <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">rank</mml:mi></mml:mrow></mml:math></inline-formula> queries over positions as
<disp-formula id="E1"><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>Similarly, we define <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">BWT</mml:mi><mml:mo>.</mml:mo><mml:mi mathvariant="italic">rank</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and use it in place of ordinary LF-mapping in the FM-index (Section 2.1.2).</p>
        <p>The FM-index is based on iterating LF-mapping. Because LF-mapping in a standard BWT tends to jump randomly around the BWT, this can be a significant bottleneck. The GBWT achieves better memory locality, if we store the records for adjacent nodes close to each other. When we iterate LF-mapping over a path in the graph, we traverse adjacent memory regions.</p>
        <p>As a run-length encoded FM-index, the GBWT supports the <italic toggle="yes">fast</italic> <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">algorithm</italic> (<xref rid="btz575-B18" ref-type="bibr">Mäkinen <italic toggle="yes">et al.</italic>, 2010</xref>). The <italic toggle="yes">direct algorithm</italic>, as described in Section 2.1.2, locates each position <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> separately. If we instead process the entire range at once, advancing every position by one step of LF-mapping at the same time, we achieve better memory locality. We can also compute LF-mapping for an entire run <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">BW</mml:mi><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> in the same time as for a single position <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <label>2.2.4</label>
        <title>GBWT encodings</title>
        <p>We have two representations for the GBWT. The <italic toggle="yes">dynamic GBWT</italic> is a representation of the GBWT optimised for index construction, where speed is more important than size. The <italic toggle="yes">compressed GBWT</italic> balances query performance with index size. We use it when the set of haplotypes is fixed and for storing the index on disk. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Material S1</xref> for further details.</p>
      </sec>
    </sec>
    <sec>
      <title>2.3 GBWT construction</title>
      <p>The assumptions in Section 2.2.3 make the GBWT easier to build than an ordinary FM-index. <italic toggle="yes">Inserting</italic> new texts into the collection updates adjacent records, just like searching traverses adjacent records. Because the local alphabet is small, because the number of occurrences of each character is limited and because run-length encoding compresses the BWT well, records tend to be small. Hence, we can afford <italic toggle="yes">re-building</italic> a record each time we update it.</p>
      <p>On the other hand, the GBWT is harder to build than the PBWT. In the PBWT, all strings are of the same length and have the same variant site at the same position. Hence, we can build the final record for a site in a single step. In the GBWT, indels in the haplotypes become indels on the haplotype paths and hence we have to update the same record multiple times. We also have to buffer the strings instead of indexing them as we generate them.</p>
      <sec>
        <label>2.3.1</label>
        <title>Construction algorithms</title>
        <p>Our basic GBWT construction algorithm is similar to RopeBWT2 (<xref rid="btz575-B16" ref-type="bibr">Li, 2014</xref>). We have a dynamic FM-index (<xref rid="btz575-B3" ref-type="bibr">Chan <italic toggle="yes">et al.</italic>, 2007</xref>) and insert multiple texts into the index in a single <italic toggle="yes">batch</italic> using the BCR algorithm (<xref rid="btz575-B1" ref-type="bibr">Bauer <italic toggle="yes">et al.</italic>, 2013</xref>). The algorithm is sequential and hence not suitable for large datasets. Parallelizing it is difficult, because the algorithm interleaves queries with index updates.</p>
        <p>When the basic algorithm is too slow, we partition the dataset into <italic toggle="yes">super-batches</italic> and build a separate GBWT index for each super-batch. We then merge the indexes using the BWT-merge algorithm (<xref rid="btz575-B27" ref-type="bibr">Sirén, 2016</xref>). The merging algorithm can also be reversed to remove texts from the index. This can be useful, if we want to remove a sample from the dataset without having to rebuild the entire index.</p>
        <p>Indexes for different chromosomes can be merged quickly with a simple algorithm. Because each chromosome uses different node identifiers, we can simply reuse the existing records in the merged index.</p>
        <p>See <xref rid="sup1" ref-type="supplementary-material">Supplementary Material S2</xref> for further details on the construction algorithms.</p>
      </sec>
      <sec>
        <label>2.3.2</label>
        <title>Construction in VG</title>
        <p>We provide support in VG to construct a GBWT from a VCF file (<xref rid="btz575-B4" ref-type="bibr">Danecek <italic toggle="yes">et al.</italic>, 2011</xref>) with phasing information. The construction parses the VCF file, determines the path corresponding to each allele and builds haplotype paths from the allele paths. Because we need two layers of buffering, we process the VCF file in batches of <italic toggle="yes">s</italic> samples (default 200) in order to save memory. Heuristics are required to deal with situations where VCF sites overlap and paths may not be well defined.</p>
        <p>The GBWT stores texts with integer identifiers. A <italic toggle="yes">metadata</italic> layer maps the identifiers to structured names. While the metadata supports genomes with arbitrary ploidy, our current VCF parsing code does not take full advantage of it. The parser expects a diploid genome, where some regions may be haploid.</p>
        <p>As repeated VCF parsing can be slower than GBWT construction, we start by parsing the VCF file and storing the information in a directly usable format in a number of files. The <italic toggle="yes">main file</italic> contains the reference path and the paths corresponding to each allele of each variant. For each batch, we create a <italic toggle="yes">phasing file</italic> containing the run-length encoded phasing information for the corresponding samples. The total size of the files is usually comparable to a compressed VCF file. If the VCF file contains interleaved diploid and haploid samples (e.g. female and male samples for chromosome X), the files can be several times larger. After the files have been written, we can continue the construction in VG or use separate GBWT construction tools.</p>
        <p>We generate a path for each haplotype in the current batch. At each variant site and for every haplotype, we first append reference nodes until the site. Then we check whether the reference coordinates of the site overlap with the path we have already generated. If there is an overlap, we try to resolve it by removing reference nodes from the generated path or by skipping reference nodes on the path corresponding to the allele at the current site. If we cannot resolve the overlap, we can treat it as a <italic toggle="yes">phase break</italic> and start a new path. Alternatively, we can replace the alternate allele with the reference allele. Finally we append the path corresponding to the allele to the end of the path we are generating.</p>
        <p>When we have finished the haplotype or there is a phase break, we insert the path <italic toggle="yes">P</italic> and its reverse <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> into the GBWT <italic toggle="yes">construction buffer</italic>. Once the buffer is full (the default size is 100 million nodes), we launch a background thread to insert the buffer into the index.</p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Haplotype-aware graph simplification</title>
      <p>VG uses a series of pruning heuristics to simplify graphs for <italic toggle="yes">k</italic>-mer indexing. First it removes edges used by <italic toggle="yes">k</italic>-mers that make too many edge choices (e.g. more than 3 choices in a 24-mer). Edges with no alternatives are not deleted, as there is no choice in taking them. Then it deletes connected components with too little sequence (e.g. less than 33 bases). Finally, if the graph contains reference paths, it may add them back to the pruned graph.</p>
      <p>Heuristic pruning often breaks paths taken by known haplotypes. This may cause errors in read mapping, if we cannot find candidate positions for a read in the correct graph region. On the other hand, indexing too many recombinations may increase the number of false positives. Hence, we would like to prune recombinations while leaving the haplotypes intact.</p>
      <p>We describe an algorithm that <italic toggle="yes">unfolds</italic> the haplotype paths in pruned regions, restoring support for them in the graph and duplicating nodes when necessary. Our algorithm works with any pruning algorithm that removes nodes from the graph. See <xref rid="btz575-F2" ref-type="fig">Figure 2</xref> for an example of the algorithm in action. We work with bi-directed VG graphs, unless otherwise noted. Reference paths can also be unfolded with a similar algorithm.
</p>
      <fig position="float" id="btz575-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Unfolding the paths in the graph in <xref rid="btz575-F1" ref-type="fig">Figure 1</xref>. Border nodes have been highlighted. Left: The graph after removing nodes 4, 5 and 6. Center: Complement graph. The maximal paths are <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>∣</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo>∣</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>∣</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>7</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with the bar splitting a path into a prefix and a suffix. Right: Unfolded graph. Dashed edges cross from prefixes to suffixes. Duplicated nodes have the original ids below the node</p>
        </caption>
        <graphic xlink:href="btz575f2" position="float"/>
      </fig>
      <p>Let <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the graph induced by GBWT paths and <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a pruned graph. We build a <italic toggle="yes">complement graph</italic> induced by edges <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and consider each connected component <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in it separately. The set <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>∩</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">border</italic> of the component, as the nodes exist both in the component and in the pruned graph. Nodes in the set <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are <italic toggle="yes">internal nodes</italic>.</p>
      <p>Each connected component <italic toggle="yes">G<sub>c</sub></italic> represents a graph region that was removed from the original graph. We build an unfolded component consisting of the paths in <italic toggle="yes">G<sub>c</sub></italic> supported by GBWT paths and insert it into the pruned graph <italic toggle="yes">G<sub>p</sub></italic>. We achieve this by duplicating the internal nodes that would otherwise cause recombinations.</p>
      <p>In order to build the unfolded component, we must find all <italic toggle="yes">maximal</italic> paths <italic toggle="yes">P</italic> of length <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> supported by GBWT paths in the component. A path starting from a border node is maximal if it reaches the border again or cannot be extended any further. GBWT paths consisting entirely of internal nodes of the component are also maximal.</p>
      <p>Let <italic toggle="yes">v</italic> be a GBWT node and <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> the corresponding VG node. If <inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a border node, we create a <italic toggle="yes">search state</italic> <inline-formula id="IE162"><mml:math id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">find</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> consisting of a pattern and a range. For internal nodes, we create search state <inline-formula id="IE163"><mml:math id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">find</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>$</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, for each search state <inline-formula id="IE164"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE165"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>:
<list list-type="order"><list-item><p>If <inline-formula id="IE166"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and the last node <inline-formula id="IE167"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a border node, we stop the search for this state. If <inline-formula id="IE168"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is also a border node, <italic toggle="yes">X</italic> is a maximal path and we output it.</p></list-item><list-item><p>We try to extend the search with all GBWT nodes <italic toggle="yes">v</italic> corresponding to the successors <inline-formula id="IE169"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, taking the orientation of <italic toggle="yes">v</italic> from the VG edge. If <inline-formula id="IE170"><mml:math id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">LF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≠</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>, we create a new state <inline-formula id="IE171"><mml:math id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">Xv</mml:mi><mml:mo>,</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi mathvariant="italic">sp</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">ep</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p>If no extension was successful and <inline-formula id="IE172"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mo>≥</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, path <italic toggle="yes">X</italic> is maximal and we output it.</p></list-item></list></p>
      <p>Let <italic toggle="yes">P</italic> be a maximal path we output. If <italic toggle="yes">P</italic> is not a border-to-border path, we try to extend the lexicographically smaller of <inline-formula id="IE173"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> with reference paths, replacing <italic toggle="yes">P</italic> with the extended path. To avoid having the same path in both orientations, we replace each path <italic toggle="yes">P</italic> with the smaller of <inline-formula id="IE174"><mml:math id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>We could create new duplicates of all internal nodes on <italic toggle="yes">P</italic> and insert the path into <italic toggle="yes">G<sub>p</sub></italic>, but this would create too much non-determinism for GCSA2 (If VG node <italic toggle="yes">v</italic> has predecessors <italic toggle="yes">u</italic> and <italic toggle="yes">u</italic>ʹ with identical labels, <italic toggle="yes">k</italic>-mers starting from <italic toggle="yes">u</italic> and <italic toggle="yes">u</italic>ʹ and passing through <italic toggle="yes">v</italic> cannot be distinguished. GCSA2 construction has to extend these <italic toggle="yes">k</italic>-mers until the order of the index (e.g. <italic toggle="yes">k</italic> = 256), which may increase the size of the temporary ﬁles signiﬁcantly). Instead, we split each path into a prefix and a suffix of equal length and build a trie of the prefixes and a trie of the reverse suffixes. Every edge in the tries becomes a node in the unfolded component.</p>
      <p>Let <italic toggle="yes">v</italic> be the label of a trie edge starting from the root. If <inline-formula id="IE175"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a border node, it already exists in <italic toggle="yes">G<sub>p</sub></italic>. Otherwise, we add a new duplicate of <inline-formula id="IE176"><mml:math id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Now let <inline-formula id="IE177"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> be the labels of two successive trie edges, and let <italic toggle="yes">u</italic> be the VG node we used for <italic toggle="yes">v</italic>. We create a new duplicate <inline-formula id="IE178"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>′</mml:mo><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="italic">vg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and add node <inline-formula id="IE179"><mml:math id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>′</mml:mo><mml:mo> </mml:mo><mml:mtext>to</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We also add edge <inline-formula id="IE180"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mtext>or</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, depending on whether we are in a prefix or a suffix. Finally, if we used VG node <italic toggle="yes">u</italic> for the end of a prefix and VG node <inline-formula id="IE181"><mml:math id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> for the start of the corresponding suffix, we add edge <inline-formula id="IE182"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mtext>to</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>After we have handled all components, the simplified graph <italic toggle="yes">G<sub>p</sub></italic> contains all GBWT paths. The GCSA2 index of <italic toggle="yes">G<sub>p</sub></italic> contains all <italic toggle="yes">k</italic>-mers (e.g. 256-mers) in the haplotypes. This allows us to prune the graph more aggressively, removing more <italic toggle="yes">k</italic>-mers corresponding to recombinations. In order to map reads to the original graph <inline-formula id="IE183"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> instead of the simplified graph <italic toggle="yes">G<sub>p</sub></italic>, we replace the node identifiers <inline-formula id="IE184"><mml:math id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in the GCSA2 index with the original identifiers <inline-formula id="IE185"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We have implemented the GBWT in C++ using the SDSL library (<xref rid="btz575-B11" ref-type="bibr">Gog <italic toggle="yes">et al.</italic>, 2014</xref>). The following experiments were done using VG v1.12.1 with GCSA2 v1.2 and a pre-release version of GBWT v0.8. All code was compiled using GCC 7.3. We used a single Amazon EC2 i3.8xlarge instance with 16 physical (32 logical) cores of an Intel Xeon E5 2686 v4 and 244 GiB of memory (Sizes measured in MiB, GiB and TiB are based on 1024-byte kibibytes. Sizes measured in MB, GB and TB are based on 1000-byte kilobytes.). The system was running Ubuntu 18.04 with Linux kernel 4.15.0. Temporary files were stored on a local RAID 0 volume consisting of four 1.9 TB SSDs.</p>
    <p>In the following, we discuss GBWT construction benchmarks and experiments with haplotype-aware graph simplification. <xref rid="sup1" ref-type="supplementary-material">Supplementary Material S3</xref> contains low-level query benchmarks that show how the GBWT can take advantage of memory locality.</p>
    <sec>
      <title>3.1 Datasets</title>
      <p>We built VG graphs for two datasets: <italic toggle="yes">1000 Genomes Project</italic> (1000 GP) final phase (<xref rid="btz575-B30" ref-type="bibr">The 1000 Genomes Project Consortium, 2015</xref>) whole-genome haplotypes and TOPMed Freeze 5 b haplotypes for chromosome 17. The 1000 GP graphs were built relative to the GRCh37 human reference genome, while the TOPMed graph used the GRCh38 reference. As the 1000 GP haplotypes have issues with overlapping variants, we generated both <italic toggle="yes">short paths</italic> by creating phase breaks at unresolvable overlaps and <italic toggle="yes">long paths</italic> by ignoring the variants that caused such overlaps. The TOPMed haplotypes had only 0.29 unresolvable overlaps per haplotype on the average, so we generated only long paths.</p>
      <p>See <xref rid="btz575-T1" ref-type="table">Table 1</xref> for further details on the datasets and <xref rid="sup1" ref-type="supplementary-material">Supplementary Material S4</xref> for a comparison of input (reference, VCF) and output (graph, GBWT) sizes. We have also included the 1000 GP chromosome 17 for comparison. The TOPMed graph was built with the old VG maximal node size default of 1000 bp, while the 1000 GP graphs use the new 32 bp default. The effect of this difference is negligible: the average distance between variants in the TOPMed graph is only 6.5 bp.
</p>
      <table-wrap position="float" id="btz575-T1">
        <label>Table 1.</label>
        <caption>
          <p>Datasets and direct GBWT construction</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th colspan="3" rowspan="1">Dataset<hr/></th>
              <th colspan="4" align="left" rowspan="1">Graph<hr/></th>
              <th colspan="4" align="left" rowspan="1">Construction<hr/></th>
              <th colspan="3" align="left" rowspan="1">Index<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Name</th>
              <th rowspan="1" colspan="1">Samples</th>
              <th rowspan="1" colspan="1">Variants</th>
              <th rowspan="1" colspan="1">Nodes</th>
              <th rowspan="1" colspan="1">Out-degree</th>
              <th rowspan="1" colspan="1">Paths</th>
              <th rowspan="1" colspan="1">Length</th>
              <th rowspan="1" colspan="1">Batch</th>
              <th rowspan="1" colspan="1">Buffer</th>
              <th rowspan="1" colspan="1">Interval</th>
              <th rowspan="1" colspan="1">Time</th>
              <th rowspan="1" colspan="1">GBWT</th>
              <th rowspan="1" colspan="1">Text IDs</th>
              <th rowspan="1" colspan="1">Total</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">1000 GP-all-S</td>
              <td rowspan="1" colspan="1">2504</td>
              <td rowspan="1" colspan="1">84.7 M</td>
              <td rowspan="1" colspan="1">612 M</td>
              <td rowspan="1" colspan="1">1.3/13</td>
              <td rowspan="1" colspan="1">50.6 M</td>
              <td rowspan="1" colspan="1">2.19 T</td>
              <td rowspan="1" colspan="1">200</td>
              <td rowspan="1" colspan="1">100 M</td>
              <td rowspan="1" colspan="1">1024</td>
              <td rowspan="1" colspan="1">12 h</td>
              <td rowspan="1" colspan="1">8.74 GiB</td>
              <td rowspan="1" colspan="1">9.90 GiB</td>
              <td rowspan="1" colspan="1">18.6 GiB</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1000 GP-all-L</td>
              <td rowspan="1" colspan="1">2504</td>
              <td rowspan="1" colspan="1">84.7 M</td>
              <td rowspan="1" colspan="1">612 M</td>
              <td rowspan="1" colspan="1">1.3/13</td>
              <td rowspan="1" colspan="1">240 232</td>
              <td rowspan="1" colspan="1">2.19 T</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">200 M</td>
              <td rowspan="1" colspan="1">1024</td>
              <td rowspan="1" colspan="1">17 h</td>
              <td rowspan="1" colspan="1">8.43 GiB</td>
              <td rowspan="1" colspan="1">8.17 GiB</td>
              <td rowspan="1" colspan="1">16.6 GiB</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1000 GP-17-S</td>
              <td rowspan="1" colspan="1">2504</td>
              <td rowspan="1" colspan="1">2.33 M</td>
              <td rowspan="1" colspan="1">16.6 M</td>
              <td rowspan="1" colspan="1">1.3/7</td>
              <td rowspan="1" colspan="1">1.67 M</td>
              <td rowspan="1" colspan="1">60.1 G</td>
              <td rowspan="1" colspan="1">200</td>
              <td rowspan="1" colspan="1">100 M</td>
              <td rowspan="1" colspan="1">1024</td>
              <td rowspan="1" colspan="1">3.7 h</td>
              <td rowspan="1" colspan="1">258 MiB</td>
              <td rowspan="1" colspan="1">242 MiB</td>
              <td rowspan="1" colspan="1">500 MiB</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1000 GP-17-L</td>
              <td rowspan="1" colspan="1">2504</td>
              <td rowspan="1" colspan="1">2.33 M</td>
              <td rowspan="1" colspan="1">16.6 M</td>
              <td rowspan="1" colspan="1">1.3/7</td>
              <td rowspan="1" colspan="1">10 016</td>
              <td rowspan="1" colspan="1">60.1 G</td>
              <td rowspan="1" colspan="1">100</td>
              <td rowspan="1" colspan="1">200 M</td>
              <td rowspan="1" colspan="1">1024</td>
              <td rowspan="1" colspan="1">4.2 h</td>
              <td rowspan="1" colspan="1">252 MiB</td>
              <td rowspan="1" colspan="1">193 MiB</td>
              <td rowspan="1" colspan="1">444 MiB</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">TOPMed-17-L</td>
              <td rowspan="1" colspan="1">54 035</td>
              <td rowspan="1" colspan="1">12.9 M</td>
              <td rowspan="1" colspan="1">67.6 M</td>
              <td rowspan="1" colspan="1">1.3/11</td>
              <td rowspan="1" colspan="1">216 140</td>
              <td rowspan="1" colspan="1">4.66 T</td>
              <td rowspan="1" colspan="1">200</td>
              <td rowspan="1" colspan="1">1000 M</td>
              <td rowspan="1" colspan="1">16 384</td>
              <td rowspan="1" colspan="1">25 d</td>
              <td rowspan="1" colspan="1">1.13 GiB</td>
              <td rowspan="1" colspan="1">1.03 GiB</td>
              <td rowspan="1" colspan="1">2.16 GiB</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: The name of each dataset is a combination of source, chromosome and path length (S for short paths with phase breaks, L for long chromosome-length paths). For each dataset, we give the number of samples and variants, as well as the number of nodes, average/maximum out-degree, number of paths (including reverse paths) and the total length of the paths in the graph. For construction, we give batch size in samples, buffer size in millions of nodes, interval for stored text identifiers and wall-clock time for index construction in hours or days. We also report GBWT size, space used by text identifiers and total index size. M, G and T suffixes indicate millions, billions and trillions, respectively.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>3.2 Index construction</title>
      <p>For 1000 GP, we first built separate indexes for each chromosome, running 14 jobs in parallel. We used the default construction parameters with short paths. For long paths, we used a larger buffer size (to speed up the construction) and a smaller batch size (to save memory). The number of parallel jobs was determined by memory usage (almost 1 GiB for each 10 Mb) and the number of CPU cores (2 threads per job). We ordered the jobs <inline-formula id="IE186"><mml:math id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>22</mml:mn><mml:mo>,</mml:mo><mml:mi>Y</mml:mi></mml:mrow></mml:math></inline-formula>, as large chromosomes take longer to finish. The last job to finish was chromosome 2, which determined the total construction time (11.8 h and 16.3 h for short and long paths, respectively). Merging the single-chromosome indexes into a whole-genome index took 12 min and 38 GiB memory for short paths and 12 min and 33 GiB for long paths. See <xref rid="btz575-T1" ref-type="table">Table 1</xref> for further details.</p>
      <p>Because the direct construction algorithm is sequential, it is too slow for building the TOPMed index (<xref rid="btz575-T1" ref-type="table">Table 1</xref>). We used the BWT-merge algorithm for faster parallel construction. Parsing the VCF file and writing the phasing information in batches of 100 samples took 42 h and 39 GiB memory. We then grouped the batches into 22 super-batches of 2500 samples each and built GBWT indexes for the super-batches in parallel. With a buffer size of 500 million, the construction took 15 h and 33 GiB memory for each of the first 21 super-batches and 9 h and 21 GiB for the partially-filled last one. We had enough memory to run 7 jobs in parallel, so the total wall-clock time for indexing the super-batches was 54 h.</p>
      <p>We merged the super-batch indexes in 46 h and 102 GiB memory. The total construction time was 5.9 days or 4.2 times less than with the direct construction algorithm. By building all super-batch indexes in parallel, the construction time can be reduced further to 4.3 days, out of which 1.7 days is spent for VCF parsing. See <xref rid="sup1" ref-type="supplementary-material">Supplementary Material S2</xref> for further details.</p>
      <p>The size of the compressed 1000 GP whole-genome GBWT was 18.6 GiB with short paths and 16.6 GiB with long paths. Roughly half of this was for the GBWT itself and half for the stored text identifiers. See <xref rid="btz575-T1" ref-type="table">Table 1</xref> for further details. The decompressed end-marker (<xref rid="sup1" ref-type="supplementary-material">Supplementary Material S1</xref>) adds another 386 MiB with short paths and 1.83 MiB with long paths. The TOPMed chromosome 17 index took 2.16 GiB, which was also split roughly in half between the GBWT and the text identifiers. It was 5.0 times larger than the corresponding 1000 GP index with long paths, while containing 22 times more samples over 5.5 times more variants. The dynamic indexes are roughly 10 times larger than the corresponding compressed indexes. Their exact sizes are not well-defined due to a large number of memory allocations and unused space in the arrays.</p>
      <p>All the assumptions in Section 2.2.3 were valid for our datasets:
<list list-type="order"><list-item><p>All nodes except the end-marker have low out-degrees.</p></list-item><list-item><p>As the graphs are acyclic, no path can visit the same node twice. When phase breaks or overlapping variants break a haplotype into multiple paths, there will be some overlap between the paths.</p></list-item><list-item><p>The 1000 GP indexes take 0.03 to 0.04 bits per character and the TOPMed index takes 0.002 bits per character, excluding the text identifiers.</p></list-item><list-item><p>VG construction tries to avoid leaving gaps between node identifiers.</p></list-item><list-item><p>The VG graphs built from a VCF file are almost in topological order.</p></list-item></list></p>
    </sec>
    <sec>
      <title>3.3 Haplotype-aware graphs</title>
      <p>VG originally used 128-mer GCSA2 indexes. When pruning the graph for indexing, we could allow 4 edge choices in a 16-mer. Such indexes were unsatisfactory, however, because they could not map exactly matching 150 bp reads in one piece. When we double the order of the index to 256-mers, we need more aggressive pruning to avoid exponential growth during index construction. By default, we now double the distance between edge choices, allowing only 3 edge choices in a 24-mer.</p>
      <p>Pruning removes <italic toggle="yes">k</italic>-mers corresponding to both true haplotypes and their recombinations. To determine the effect of more aggressive pruning, we built several whole-genome GCSA2 indexes for the 1000 GP graph and compared their <italic toggle="yes">k</italic>-mer contents. In the following, graph pruned-<italic toggle="yes">k</italic> has been pruned with the parameters for a <italic toggle="yes">k</italic>-mer index, and the reference paths have been restored afterwards. Similarly, unfolded-<italic toggle="yes">k</italic> is a graph where the haplotype paths and reference paths have been unfolded after pruning, using the GBWT index with long paths. See <xref rid="btz575-T2" ref-type="table">Table 2</xref> for the results.
</p>
      <table-wrap position="float" id="btz575-T2">
        <label>Table 2.</label>
        <caption>
          <p>GCSA2 indexes for simplified 1000 GP graphs</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="3" rowspan="1">GCSA2 index<hr/></th>
              <th colspan="3" rowspan="1">64-mers<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Graph</th>
              <th rowspan="1" colspan="1">Pruning</th>
              <th rowspan="1" colspan="1">Constr</th>
              <th rowspan="1" colspan="1">Size</th>
              <th rowspan="1" colspan="1">Shared</th>
              <th rowspan="1" colspan="1">Haplotype</th>
              <th rowspan="1" colspan="1">Recomb</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Pruned-128</td>
              <td rowspan="1" colspan="1">3.1 h</td>
              <td rowspan="1" colspan="1">25.6 h</td>
              <td rowspan="1" colspan="1">36.3 GiB</td>
              <td rowspan="1" colspan="1">27.0 G</td>
              <td rowspan="1" colspan="1">3.11 G</td>
              <td rowspan="1" colspan="1">11.4 G</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Pruned-256</td>
              <td rowspan="1" colspan="1">3.3 h</td>
              <td rowspan="1" colspan="1">25.5 h</td>
              <td rowspan="1" colspan="1">30.0 GiB</td>
              <td rowspan="1" colspan="1">27.0 G</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Unfolded-256</td>
              <td rowspan="1" colspan="1">3.7 h</td>
              <td rowspan="1" colspan="1">29.0 h</td>
              <td rowspan="1" colspan="1">34.0 GiB</td>
              <td rowspan="1" colspan="1">27.0 G</td>
              <td rowspan="1" colspan="1">3.46 G</td>
              <td rowspan="1" colspan="1">—</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: For each graph, we give the pruning time in hours, construction time in hours and index size in GiB. We also show a comparison of unique 64-mer content versus pruned-256, including the number of 64-mers shared with pruned-256, the number of additional (real) haplotype 64-mers over pruned-256 and the number of additional (spurious) recombination 64-mers over pruned-256. The G suffix indicates billions.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>There are 27.0 billion 64-mers in the pruned-256 index. Unfolding the haplotype paths adds 3.46 billion 64-mers to the unfolded-256 index. While most of these additional <italic toggle="yes">k</italic>-mers correspond to haplotypes, some of them may be recombinations covering multiple complex regions. The pruned-128 index contains 90% of the haplotype <italic toggle="yes">k</italic>-mers that were missing from pruned-256, but it also adds 11.4 billion 64-mers arising from recombinations of the haplotypes. Overall, by switching from the old pruned-128 index to the new unfolded-256 index, we add the last missing haplotype <italic toggle="yes">k</italic>-mers to the index while getting rid of a large number of recombination <italic toggle="yes">k</italic>-mers and supporting direct matches of sequencing reads up to 256 bp.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>We have developed the GBWT, a scalable implementation of the graph extension of the PBWT. The earlier gPBWT implementation used 9.3 h and 278 GiB of memory for indexing the 1000 GP chromosome 22 using a single thread (<xref rid="btz575-B22" ref-type="bibr">Novak <italic toggle="yes">et al.</italic>, 2017</xref>). In comparison, our implementation takes 2.0 h and 4.0 GiB (short paths) or 1.9 h and 5.9 GiB (long paths) using two threads. We also reduced the final index size from 321 MiB to 134 MiB (short paths) or 131 MiB (long paths) without text identifiers. By running multiple jobs in parallel, we were able to build a whole-genome index in 12 h (short paths) or 17 h (long paths) on a single system.</p>
    <p>Contemporary sequencing projects are sequencing in excess of 100 000 diploid genomes. Our aim is to scale the GBWT to allow working with such large collections, providing a compressed, indexed and searchable representation that should fit into the memory of a single server. Potential applications in genome inference and imputation, as well as for powering population genomic queries, are myriad. For example, we are exploring using the GBWT for additionally scoring read mappings by the number of recombinations of the underlying haplotypes they induce, using the model described by <xref rid="btz575-B25" ref-type="bibr">Rosen <italic toggle="yes">et al.</italic> (2017)</xref>.</p>
    <p>Our experiments with the TOPMed dataset suggest we are almost there. We can build a 2.16 GiB chromosome 17 index for 54 035 diploid samples in 4.3 days. Extrapolating from this, it should take 13–14 days and 76 000 CPU hours to build an 80–90 GiB whole-genome index. See <xref rid="btz575-T3" ref-type="table">Table 3</xref> for further details. While GBWT merging uses more CPU hours than the other phases, GBWT construction for super-batches requires five times more memory per CPU core, so its actual cost may be higher.
</p>
    <table-wrap position="float" id="btz575-T3">
      <label>Table 3.</label>
      <caption>
        <p>Estimated resource usage of whole-genome TOPMed GBWT construction</p>
      </caption>
      <table frame="hsides" rules="groups">
        <colgroup span="1">
          <col valign="top" align="left" span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="char" char="." span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
          <col valign="top" align="center" span="1"/>
        </colgroup>
        <thead>
          <tr>
            <th rowspan="1" colspan="1"/>
            <th rowspan="1" colspan="1"/>
            <th rowspan="1" colspan="1"/>
            <th align="left" colspan="2" rowspan="1">Chr 17<hr/></th>
            <th align="left" colspan="2" rowspan="1">Chr 2<hr/></th>
            <th align="left" rowspan="1" colspan="1"/>
          </tr>
          <tr>
            <th rowspan="1" colspan="1">Phase</th>
            <th align="left" rowspan="1" colspan="1">Jobs</th>
            <th align="left" rowspan="1" colspan="1">Cores</th>
            <th align="left" rowspan="1" colspan="1">Time</th>
            <th align="left" rowspan="1" colspan="1">Memory</th>
            <th align="left" rowspan="1" colspan="1">Time</th>
            <th align="left" rowspan="1" colspan="1">Memory</th>
            <th align="left" rowspan="1" colspan="1">CPU hours</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td rowspan="1" colspan="1">Parsing</td>
            <td rowspan="1" colspan="1">1</td>
            <td rowspan="1" colspan="1">1</td>
            <td rowspan="1" colspan="1">42 h</td>
            <td rowspan="1" colspan="1">39 GiB</td>
            <td rowspan="1" colspan="1">5–6 d</td>
            <td rowspan="1" colspan="1">128 GiB</td>
            <td rowspan="1" colspan="1">1500</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Construction</td>
            <td rowspan="1" colspan="1">22</td>
            <td rowspan="1" colspan="1">2</td>
            <td rowspan="1" colspan="1">15 h</td>
            <td rowspan="1" colspan="1">33 GiB</td>
            <td rowspan="1" colspan="1">2 d</td>
            <td rowspan="1" colspan="1">100 GiB</td>
            <td rowspan="1" colspan="1">23 000</td>
          </tr>
          <tr>
            <td rowspan="1" colspan="1">Merging</td>
            <td rowspan="1" colspan="1">1</td>
            <td rowspan="1" colspan="1">32</td>
            <td rowspan="1" colspan="1">46 h</td>
            <td rowspan="1" colspan="1">102 GiB</td>
            <td rowspan="1" colspan="1">5–6 d</td>
            <td rowspan="1" colspan="1">320 GiB</td>
            <td rowspan="1" colspan="1">51 500</td>
          </tr>
        </tbody>
      </table>
      <table-wrap-foot>
        <fn id="tblfn3">
          <p><italic toggle="yes">Note</italic>: For each phase (VCF parsing, GBWT construction for super-batches, GBWT merging), we give the number of jobs per chromosome, number of CPU cores per job, time (in hours or days) and memory usage (in GiB) per job for chromosome 17 (measured) and chromosome 2 (estimated) and estimated CPU hours for building a whole-genome index.</p>
        </fn>
      </table-wrap-foot>
    </table-wrap>
    <p>We can probably improve the resource usage with a better choice of batch/super-batch sizes and other construction parameters. For wall-clock time, the main bottleneck is the sequential VCF parsing, which takes 40% of the total construction time. Improvements to this may involve integrating the parsing into VG graph construction, parsing multiple graph regions in parallel, or switching to a more efficient input format.</p>
    <p>Storing the text identifiers for <inline-formula id="IE187"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> queries is another bottleneck. When the number of samples increases, the product of <inline-formula id="IE188"><mml:math id="IM188" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and the space taken by the stored text identifiers increases linearly. In the 1000 GP dataset, storing the identifiers at one out of 1024 positions takes roughly as much space as the GBWT itself. With the TOPMed dataset, we achieve similar proportions by storing the identifiers at one out of 16 384 positions, making <inline-formula id="IE189"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> 16 to 22 times slower. There is a theoretical proposal for supporting fast <inline-formula id="IE190"><mml:math id="IM190" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">locate</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> queries in space proportional to the size of the run-length encoded BWT (<xref rid="btz575-B9" ref-type="bibr">Gagie <italic toggle="yes">et al.</italic>, 2018</xref>). While there has been some progress in building the proposed index for large datasets (<xref rid="btz575-B14" ref-type="bibr">Kuhnle <italic toggle="yes">et al.</italic>, 2019</xref>), scaling it up to TOPMed scale is still an open problem.</p>
    <p>We used the haplotype information in the GBWT to simplify VG graphs for <italic toggle="yes">k</italic>-mer indexing. This allowed us to prune the <italic toggle="yes">k</italic>-mers corresponding to recombinations more aggressively, while still having all <italic toggle="yes">k</italic>-mers from the haplotypes in the index. CHOP, the other haplotype-aware graph indexing approach, can only use short-range haplotype information in read mapping. Because VG graphs are connected, we can use the long-range information in the GBWT for mapping long reads and paired-end reads. We will investigate this in a subsequent paper.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the National Institutes of Health [5U41HG007234 and 1U01HL137183-01 to J.S., A.N. and B.P.]; the Wellcome Trust [WT206194 to J.S., E.G. and R.D.; WT207492 to R.D.] and the W. M. Keck Foundation [DT06172015 to J.S., A.N. and B.P.]. </p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btz575_Supplementary_Data</label>
      <media xlink:href="btz575_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz575-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bauer</surname>
 <given-names>M.J.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2013</year>) 
<article-title>Lightweight algorithms for constructing and inverting the BWT of string collections</article-title>. <source>Theor. Comput. Sci</source>., <volume>483</volume>, <fpage>134</fpage>–<lpage>148</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Burrows</surname>
 <given-names>M.</given-names></string-name>, <string-name><surname>Wheeler</surname><given-names>D.J.</given-names></string-name></person-group> (<year>1994</year>) A block sorting lossless data compression algorithm. <italic toggle="yes">Technical report 124.</italic> Digital Equipment Corporation, Palo Alto, CA.</mixed-citation>
    </ref>
    <ref id="btz575-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chan</surname>
 <given-names>H.-L.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2007</year>) 
<article-title>Compressed indexes for dynamic text collections</article-title>. <source>ACM Trans. Algorithms</source>, <volume>3</volume>, <fpage>21.</fpage></mixed-citation>
    </ref>
    <ref id="btz575-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Danecek</surname>
 <given-names>P.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2011</year>) 
<article-title>The variant call format and VCFtools</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>2156</fpage>–<lpage>2158</lpage>.<pub-id pub-id-type="pmid">21653522</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Durbin</surname>
 <given-names>R.</given-names></string-name></person-group> (<year>2014</year>) 
<article-title>Efficient haplotype matching and storage using the Positional Burrows–Wheeler transform (PBWT)</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>1266</fpage>–<lpage>1272</lpage>.<pub-id pub-id-type="pmid">24413527</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Eggertsson</surname>
 <given-names>H.P.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>Graphtyper enables population-scale genotyping using pangenome graphs</article-title>. <source>Nat. Genet</source>., <volume>49</volume>, <fpage>1654</fpage>–<lpage>1660</lpage>.<pub-id pub-id-type="pmid">28945251</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ferragina</surname>
 <given-names>P.</given-names></string-name>, <string-name><surname>Manzini</surname><given-names>G.</given-names></string-name></person-group> (<year>2005</year>) 
<article-title>Indexing compressed text</article-title>. <source>J. ACM</source>, <volume>52</volume>, <fpage>552</fpage>–<lpage>581</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gagie</surname>
 <given-names>T.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>Wheeler graphs: a framework for BWT-based data structures</article-title>. <source>Theor. Comput. Sci</source>., <volume>698</volume>, <fpage>67</fpage>–<lpage>78</lpage>.<pub-id pub-id-type="pmid">29276331</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B9">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Gagie</surname>
 <given-names>T.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) <part-title>Optimal-time text indexing in BWT-runs bounded space</part-title>. In: <source>Proceedings of SODA 2018</source>, 
<publisher-name>SIAM</publisher-name>, New Orleans, LA, pp. <fpage>1459</fpage>–<lpage>1477</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Garrison</surname>
 <given-names>E.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) 
<article-title>Variation graph toolkit improves read mapping by representing genetic variation in the reference</article-title>. <source>Nat. Biotechnol</source>., <volume>36</volume>, <fpage>875</fpage>–<lpage>879</lpage>.<pub-id pub-id-type="pmid">30125266</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Gog</surname>
 <given-names>S.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2014</year>) <part-title>From theory to practice: plug and play with succinct data structures</part-title>. In: <source>Proceedings of SEA 2014, Vol. 8504 of LNCS</source>, 
<publisher-name>Springer</publisher-name>, Copenhagen, Denmark, pp. <fpage>326</fpage>–<lpage>337</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huang</surname>
 <given-names>L.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2013</year>) 
<article-title>Short read alignment with populations of genomes</article-title>. <source>Bioinformatics</source>, <volume>29</volume>, <fpage>i361</fpage>–<lpage>i370</lpage>.<pub-id pub-id-type="pmid">23813006</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B13">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Huang</surname>
 <given-names>S.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2010</year>) <part-title>Indexing similar DNA sequences</part-title>. In: <source>Proceedings of AAIM 2010, Vol. 6124 of LNCS</source>, 
<publisher-name>Springer</publisher-name>, Weihai, China, pp. <fpage>180</fpage>–<lpage>190</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B14">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kuhnle</surname>
 <given-names>A.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2019</year>) <part-title>Efficient construction of a complete index for pan-genomics read alignment</part-title>. In: <source>Proceedings of RECOMB 2019, Vol. 11467 of LNCS</source>, 
<publisher-name>Springer</publisher-name>, Washington, DC, pp. <fpage>158</fpage>–<lpage>173</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname>
 <given-names>H.</given-names></string-name></person-group> (<year>2012</year>) 
<article-title>Exploring single-sample SNP and INDEL calling with whole-genome de novo assembly</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1838</fpage>–<lpage>1844</lpage>.<pub-id pub-id-type="pmid">22569178</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname>
 <given-names>H.</given-names></string-name></person-group> (<year>2014</year>) 
<article-title>Fast construction of FM-index for long sequence reads</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3274</fpage>–<lpage>3275</lpage>.<pub-id pub-id-type="pmid">25107872</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B17">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Maciuca</surname>
 <given-names>S.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>) <part-title>A natural encoding of genetic variation in a Burrows-Wheeler transform to enable mapping and genome inference</part-title>. In: <source>Proceedings of WABI 2016, Vol. 9838 of LNCS</source>, 
<publisher-name>Springer</publisher-name>, Aarhus, Denmark, pp. <fpage>222</fpage>–<lpage>233</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mäkinen</surname>
 <given-names>V.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2010</year>) 
<article-title>Storage and retrieval of highly repetitive sequence collections</article-title>. <source>J. Comput. Biol</source>., <volume>17</volume>, <fpage>281</fpage>–<lpage>308</lpage>.<pub-id pub-id-type="pmid">20377446</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B19">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Mokveld</surname>
 <given-names>T.O.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) CHOP: haplotype-aware path indexing in population graphs. <italic toggle="yes">bioRxiv</italic>. doi: 10.1101/305268.</mixed-citation>
    </ref>
    <ref id="btz575-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Na</surname>
 <given-names>J.C.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2016</year>) 
<article-title>FM-index of alignment: a compressed index for similar strings</article-title>. <source>Theor. Comp. Sci</source>., <volume>638</volume>, <fpage>159</fpage>–<lpage>170</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Na</surname>
 <given-names>J.C.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2018</year>) 
<article-title>FM-index of alignment with gaps</article-title>. <source>Theor. Comp. Sci</source>., <volume>710</volume>, <fpage>148</fpage>–<lpage>157</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Novak</surname>
 <given-names>A.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>A graph extension of the positional Burrows-Wheeler transform and its applications</article-title>. <source>Algorith. Mol. Biol</source>., <volume>12</volume>, <fpage>18.</fpage></mixed-citation>
    </ref>
    <ref id="btz575-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Paten</surname>
 <given-names>B.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>Genome graphs and the evolution of genome inference</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>665</fpage>–<lpage>676</lpage>.<pub-id pub-id-type="pmid">28360232</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rakocevic</surname>
 <given-names>G.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2019</year>) 
<article-title>Fast and accurate genomic analyses using genome graphs</article-title>. <source>Nat. Genet</source>., <volume>51</volume>, <fpage>354</fpage>–<lpage>362</lpage>.<pub-id pub-id-type="pmid">30643257</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosen</surname>
 <given-names>Y.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2017</year>) 
<article-title>Modelling haplotypes with respect to reference cohort variation graphs</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>i118</fpage>–<lpage>i123</lpage>.<pub-id pub-id-type="pmid">28881971</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Schneeberger</surname>
 <given-names>K.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2009</year>) 
<article-title>Simultaneous alignment of short reads against multiple genomes</article-title>. <source>Genome Biol</source>., <volume>10</volume>, <fpage>R98.</fpage><pub-id pub-id-type="pmid">19761611</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Sirén</surname>
 <given-names>J.</given-names></string-name></person-group> (<year>2016</year>) <part-title>Burrows-Wheeler transform for terabases</part-title>. In: <source>Proceedings of DCC 2016</source>, 
<publisher-name>IEEE</publisher-name>, Snowbird, UT, pp. <fpage>211</fpage>–<lpage>220</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B28">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Sirén</surname>
 <given-names>J.</given-names></string-name></person-group> (<year>2017</year>) <part-title>Indexing variation graphs</part-title>. In: <source>Proceedings of ALENEX 2017</source>, 
<publisher-name>SIAM</publisher-name>, Barcelona, Spain, pp. <fpage>13</fpage>–<lpage>27</lpage>.</mixed-citation>
    </ref>
    <ref id="btz575-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sirén</surname>
 <given-names>J.</given-names></string-name></person-group>
 <etal>et al</etal> (<year>2014</year>) 
<article-title>Indexing graphs for path queries with applications in genome research</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>., <volume>11</volume>, <fpage>375</fpage>–<lpage>388</lpage>.<pub-id pub-id-type="pmid">26355784</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B30">
      <mixed-citation publication-type="journal">The 1000 Genomes Project Consortium. (<year>2015</year>) 
<article-title>A global reference for human genetic variation</article-title>. <source>Nature</source>, <volume>526</volume>, <fpage>68</fpage>–<lpage>64</lpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btz575-B31">
      <mixed-citation publication-type="journal">The Computational Pan-Genomics Consortium. (<year>2018</year>) 
<article-title>Computational pan-genomics: status, promises and challenges</article-title>. <source>Brief. Bioinform</source>., <volume>19</volume>, <fpage>118</fpage>–<lpage>135</lpage>.<pub-id pub-id-type="pmid">27769991</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
