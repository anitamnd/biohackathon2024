<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genes (Basel)</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genes (Basel)</journal-id>
    <journal-id journal-id-type="publisher-id">genes</journal-id>
    <journal-title-group>
      <journal-title>Genes</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2073-4425</issn>
    <publisher>
      <publisher-name>MDPI</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6896194</article-id>
    <article-id pub-id-type="doi">10.3390/genes10110886</article-id>
    <article-id pub-id-type="publisher-id">genes-10-00886</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PipeMEM: A Framework to Speed Up BWA-MEM in Spark with Low Overhead</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-2452-1551</contrib-id>
        <name>
          <surname>Zhang</surname>
          <given-names>Lingqi</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Cheng</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0003-0153-850X</contrib-id>
        <name>
          <surname>Dong</surname>
          <given-names>Shoubin</given-names>
        </name>
        <xref rid="c1-genes-10-00886" ref-type="corresp">*</xref>
      </contrib>
    </contrib-group>
    <aff id="af1-genes-10-00886">Communication &amp; Computer Network Lab of Guangdong, School of Computer Science &amp; Engineering, South China University of Technology, Wushan Road 381, Guangzhou 51000, China; <email>cslingqizhang@gmail.com</email> (L.Z.); <email>ztcattlepatato@gmail.com</email> (C.L.)</aff>
    <author-notes>
      <corresp id="c1-genes-10-00886"><label>*</label>Correspondence: <email>sbdong@scut.edu.cn</email>; Tel.: +86-20-87110014</corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>04</day>
      <month>11</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <month>11</month>
      <year>2019</year>
    </pub-date>
    <volume>10</volume>
    <issue>11</issue>
    <elocation-id>886</elocation-id>
    <history>
      <date date-type="received">
        <day>14</day>
        <month>9</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>01</day>
        <month>11</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2019 by the authors.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="open-access">
        <license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p>
      </license>
    </permissions>
    <abstract>
      <p>(1) Background: DNA sequence alignment process is an essential step in genome analysis. BWA-MEM has been a prevalent single-node tool in genome alignment because of its high speed and accuracy. The exponentially generated genome data requiring a multi-node solution to handle large volumes of data currently remains a challenge. Spark is a ubiquitous big data platform that has been exploited to assist genome alignment in handling this challenge. Nonetheless, existing works that utilize Spark to optimize BWA-MEM suffer from higher overhead. (2) Methods: In this paper, we presented PipeMEM, a framework to accelerate BWA-MEM with lower overhead with the help of the pipe operation in Spark. We additionally proposed to use a pipeline structure and in-memory-computation to accelerate PipeMEM. (3) Results: Our experiments showed that, on paired-end alignment tasks, our framework had low overhead. In a multi-node environment, our framework, on average, was 2.27× faster compared with BWASpark (an alignment tool in Genome Analysis Toolkit (GATK)), and 2.33× faster compared with SparkBWA. (4) Conclusions: PipeMEM could accelerate BWA-MEM in the Spark environment with high performance and low overhead.</p>
    </abstract>
    <kwd-group>
      <kwd>BWA-MEM</kwd>
      <kwd>Spark</kwd>
      <kwd>low overhead</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="sec1-genes-10-00886">
    <title>1. Introduction</title>
    <p>The development of next-generation sequencing (NGS) technique generates data faster compared to the previous techniques. The increasing rate of sequencing data is even faster than the Moor Law in computer architecture. This situation raised a challenge for genome data analysis, which further put the first step of it, sequence alignment, into the breach of overwhelming data. All of these call for proper alignment methods with high accuracy that can also process such a large amount of data effectively.</p>
    <p>Under this background, many great single-node alignment tools have been developed, for example, BWA-SW [<xref rid="B1-genes-10-00886" ref-type="bibr">1</xref>], BWA-MEM [<xref rid="B2-genes-10-00886" ref-type="bibr">2</xref>], bowtie2 [<xref rid="B3-genes-10-00886" ref-type="bibr">3</xref>], cushaw [<xref rid="B4-genes-10-00886" ref-type="bibr">4</xref>], etc. Among them, the experimental study conducted by Li [<xref rid="B2-genes-10-00886" ref-type="bibr">2</xref>] shows that BWA-MEM is faster and more accurate than most of the others. Because of that, BWA-MEM is a prevalent tool for genome analysis now. Numerous genome analysis pipelines deploy it for their alignment step, for example, GenomeScope [<xref rid="B5-genes-10-00886" ref-type="bibr">5</xref>], PhyResSe [<xref rid="B6-genes-10-00886" ref-type="bibr">6</xref>], SpeedSeq [<xref rid="B7-genes-10-00886" ref-type="bibr">7</xref>], GPCG [<xref rid="B8-genes-10-00886" ref-type="bibr">8</xref>], and GATK (genome analysis toolkit) [<xref rid="B9-genes-10-00886" ref-type="bibr">9</xref>].</p>
    <p>Additionally, many multi-node alignment algorithms are proposed. The pattern that differently reads the alignment tasks is independent, making it well suited to be implemented in a parallel environment. There are many successful implementations of multi-node alignment algorithms, such as pBWA [<xref rid="B10-genes-10-00886" ref-type="bibr">10</xref>] and mpiBLAST [<xref rid="B11-genes-10-00886" ref-type="bibr">11</xref>], that used MPI (Message Passing Interface) to run BWA and BLAST [<xref rid="B12-genes-10-00886" ref-type="bibr">12</xref>] in multi-node. MerAligner [<xref rid="B13-genes-10-00886" ref-type="bibr">13</xref>] and S-Aligner [<xref rid="B14-genes-10-00886" ref-type="bibr">14</xref>] applied the HPC (High Performance Computing) technique. MerAligner was based on a successful single-node SIMD (Single Instruction Multiple Data) implementation [<xref rid="B15-genes-10-00886" ref-type="bibr">15</xref>] of the Smith–Waterman Algorithm [<xref rid="B16-genes-10-00886" ref-type="bibr">16</xref>], while S-Aligner designed a new algorithm similar to the alignment pipeline of RazerS3 [<xref rid="B17-genes-10-00886" ref-type="bibr">17</xref>]. parSRA [<xref rid="B18-genes-10-00886" ref-type="bibr">18</xref>] used OS (Operation System) APIs (Application Programming Interfaces) to run alignment tools. parSRA is a portable tool with relatively lower overhead. But all of the tools above dismissed a vital fact that big data platform is playing an increasingly critical role in the genome analysis pipeline. Alignment tools are only the beginning of a genome analysis pipeline. There would be some overhead to assemble these tools to the existing genome analysis pipeline that depends on big data technique.</p>
    <p>The utilization of big data techniques in genome analysis resulted in the famous Genome Analysis Toolkit (GATK). GATK relied on Hadoop when it was first released. After the first release, GATK has been a widely used tool for genome analysis for a long time.</p>
    <p>However, the map-reduce programming model in Hadoop relies on iterative access to HDFS (Hadoop Distributed File System), which drawbacks the performance improvement of applications run in the Hadoop platform. The solving of this problem gave birth to Spark. Instead of accessing HDFS, Spark processes data with a data structure, named resilient distributed dataset (RDD). Thus, Spark would bring about a higher performance for those applications that require multi-time hardware access compared with Hadoop.</p>
    <p>GATK also exploited the power of Spark, which leads to GATK 4.0. Apart from GATK, many efforts have been done to implement genome analysis tools in the big data environment, for example, Biodoop [<xref rid="B19-genes-10-00886" ref-type="bibr">19</xref>], BioPig [<xref rid="B20-genes-10-00886" ref-type="bibr">20</xref>], Eoulsan [<xref rid="B21-genes-10-00886" ref-type="bibr">21</xref>], SparkSeq [<xref rid="B22-genes-10-00886" ref-type="bibr">22</xref>], HIVE [<xref rid="B23-genes-10-00886" ref-type="bibr">23</xref>], etc. Nonetheless, GATK is still the dominant one.</p>
    <p>Under this circumstance, we believe that two tasks for the development of genome algorithm are equally important: <list list-type="order"><list-item><p>developing a multi-node framework that supports BWA-MEM and supports the future development of a single-node alignment tool.</p></list-item><list-item><p>the result of the alignment should be adaptable to the existing prevalent genome analysis tools in a big data environment, i.e., GATK.</p></list-item></list></p>
    <p>There are some research works related to these tasks, such as BigBWA [<xref rid="B24-genes-10-00886" ref-type="bibr">24</xref>] and SEAL [<xref rid="B25-genes-10-00886" ref-type="bibr">25</xref>], that tried to run the BWA in the Hadoop environment. SparkBWA [<xref rid="B26-genes-10-00886" ref-type="bibr">26</xref>] is an improvement of BigBWA. Considering that BigBWA is faster than SEAL [<xref rid="B25-genes-10-00886" ref-type="bibr">25</xref>] and SparkBWA is faster than BigBWA [<xref rid="B24-genes-10-00886" ref-type="bibr">24</xref>], this research would only consider SparkBWA. Besides, BWASpark [<xref rid="B27-genes-10-00886" ref-type="bibr">27</xref>] is a tool in GATK4. Because GATK is a popular tool, we would also discuss the performance of BWASpark. </p>
    <p>BWASpark (GATK) integrates BWA-MEM inside tightly. It creates BWA threads instead of calling a whole BWA program with JNI (Java Native Interface). Before the main computation, preparations are necessary to conduct. BWASpark requires fastq files to be transformed into sam files. BWASpark also creates a self-defined index based on the index files created by BWA. These files should be loaded to HDFS firstly. In the main computation part, BWASpark would process only part of data to BWA-MEM because only sequence information is required to perform an alignment. This effort would improve its performance if the network transferring is in bottleneck condition. After alignment by BWA-MEM, the alignment result is integrated with the data extracted from the original file to generate a complete result. Results from the different tasks would then be stored in HDFS. After that, BWASpark also provides the methods for merging all separated files.</p>
    <p>SparkBWA calls the BWA program directly. It can run all kinds of BWA tools in the Spark environment. It consists of three stages: RDD creations, map, and reduce phases. But this program requires some preparation before these main stages can be processed. For preparation, fastq files (the sequences that need to be aligned) need to be uploaded into HDFS, and the index file needs to be put to a path that can be accessible for any node. For the main stage, there are three separate stages: <list list-type="order"><list-item><p>RDD creation step is in charge of data distribution.</p></list-item><list-item><p>Mapper calls the BWA program with the help of JNI.</p></list-item><list-item><p>Reducer merges the results produced by BWA in mapper together.</p></list-item></list></p>
    <p>The reducer step can be disabled. RDD creation in SparkBWA provides two methods to handle the pair-end situation: Spark-Join and SortHDFS. Both of them use line numbers as a key-value to conduct join operation or sort operation. Spark-Join consumes a large amount of memory, but it is faster. SortHDFS is slower while saving in memory.</p>
    <p>Now, we considered alignment as the first step of genome analysis. Loading data from local disk into HDFS was unavoidable, considering all of the following analyses were done in Spark.</p>
    <p>Nonetheless, we believed it is unnecessary to merge the results after the main computation because the future step would also require the data to be separated and distributed again.</p>
    <p>The current implementations of BWA in Spark have some shortcomings. BWASpark (GATK) might suffer from additional overheads of assembling and dissembling input and output data. We used a parquet, a column-oriented data storage format, to handle this problem. This storage format enhanced us to update only part of the results. We used this as part of our genome analysis pipeline, which belongs to another work. So, we would not discuss much of it in this paper, but this is not a big issue here. SparkBWA suffered from redundant works. We thought that it was possible to avoid the iteration throughout input data by adding some additional work in the preparation stage. It was also possible to prevent unnecessary disk access before calling the BWA-MEM. Besides, the usage of JNI made both projects not so easy to maintain and not so portable if users want to use another alignment tool.</p>
    <p>The result of 61.05% and 33.64% showed that it was slower than the original C code in a single-node environment. Therefore, we proposed light and portable fame work, PipeMEM, that could avoid most of the overhead existed in counterpart products.</p>
  </sec>
  <sec sec-type="methods" id="sec2-genes-10-00886">
    <title>2. Methods</title>
    <sec id="sec2dot1-genes-10-00886">
      <title>2.1. Framework Structure of PipeMEM</title>
      <sec id="sec2dot1dot1-genes-10-00886">
        <title>2.1.1. Workflow of PipeMEM</title>
        <p>Similar to BWASpark (GATK) and SparkBWA, PipeMEM consists of a pre-processing stage and the main computation stage. We would not consider merging the output files since these distributed files would be processed to the next step in genome analysis.
<list list-type="bullet"><list-item><p>In the pre-processing stage: (1) Change the data format of input files so that there is no need to iterate and merge input data in the main computation step. (2) Upload data to HDFS.</p></list-item><list-item><p>In the main computation stage: (1) Distribute data from HDFS to different nodes. (2) Transform the data into the original format, so that the BWA-MEM program can process it. (3) Call BWA-MEM. (4) Upload the results to HDFS.</p></list-item></list></p>
        <p><xref ref-type="fig" rid="genes-10-00886-f001">Figure 1</xref> shows the workflow of PipeMEM. We have to mention that this framework also works on other single-node programs that belong to map pattern parallelism, which include other alignment tools.</p>
        <p><xref rid="genes-10-00886-t001" ref-type="table">Table 1</xref> shows how this framework is different from BWASpark(GATK) and SparkBWA. From this table, we could see that PipeMEM involves fewer operations compared with BWASpark. Accordingly, we could make some modifications in the data format so that we could avoid iterating fastq files in the main computation stage. Admittedly, this operation would increase the time consumption in the pre-processing stage. But our experiments showed that the benefit brought by this design outweighed its overhead.</p>
      </sec>
      <sec id="sec2dot1dot2-genes-10-00886">
        <title>2.1.2. Data Flow of PipeMEM</title>
        <p>As <xref ref-type="fig" rid="genes-10-00886-f002">Figure 2</xref> shows, every four-line composes one unique read, and every four-lines in two paired-end read files make up a data unit. For Spark, textFile API can separate the text files based on the line. In other words, the texFile treat line as a data unit. So, all we need to do is to design a data format to adapt the data unit concept of the fastq file to the concept of textFile.</p>
        <p>Some identifiers are chosen that are not existed in the fastq file to replace the line breaker inside a data unit of the fastq file. In this way, after the data is distributed by Spark, it’s easy to regenerate original data, by replacing the identifier with the line breaker.</p>
        <p><xref ref-type="fig" rid="genes-10-00886-f003">Figure 3</xref> shows how pre-processing was developed in a paired-end situation. It uses paired-end read as an example because the paired-end is more complicated than a single end. <xref ref-type="fig" rid="genes-10-00886-f003">Figure 3</xref> also shows how the modified data format was changed back to the original format that could be processed by BWA-MEM. We used a smart pairing parameter in BWA-MEM, with which BWA-MEM would be able to read paired-end from a single file instead of two files.</p>
        <p>Next, we have discussed two main optimization techniques: pipeline in pre-processing and in-memory-computation in main computation.</p>
        <p>PipeMEM program is publicly available at <uri xlink:href="https://github.com/SCUT-CCNL/PipeMEM">https://github.com/SCUT-CCNL/PipeMEM</uri>.</p>
      </sec>
    </sec>
    <sec id="sec2dot2-genes-10-00886">
      <title>2.2. Pipeline in Pre-Processing</title>
      <sec id="sec2dot2dot1-genes-10-00886">
        <title>2.2.1. Design Principle</title>
        <p>In the pre-processing, there are three tasks: (1) loading data from local disk, (2) altering data format, and (3) uploading data to HDFS. Luckily, loading and uploading belong to I/O (Input/Output) task, which can be handled by DMA (Direct Memory Access). Additionally, uploading data relies on the channel of the network, while loading data depends upon the channel of disk access, which means they are independent of each other. Moreover, modifying the data format is done by CPU. So, three different kinds of hardware can handle these three tasks separately.</p>
        <p>According to [<xref rid="B28-genes-10-00886" ref-type="bibr">28</xref>], if there are a series of operations, and each operation can be mapped into a specific hardware structure, a pipeline parallel pattern is a good solution. </p>
        <p>We hereby proposed to use a pipeline structure. <xref ref-type="fig" rid="genes-10-00886-f004">Figure 4</xref> shows the structure of the pipeline in the pre-processing from a hardware perspective. There are three kinds of hardware structure: the first one handling loading data, the second one in charge of data format, and the third one handling the task of uploading data. Every time-unit, a set of data is processed into an independent hardware structure. </p>
      </sec>
      <sec id="sec2dot2dot2-genes-10-00886">
        <title>2.2.2. Implementation</title>
        <p>In the situation of single-end, three processes are created; each process correlates to one hardware stage.</p>
        <p>The situation of the paired-end is a little tricky. The four processes are utilized:<list list-type="bullet"><list-item><p>Two of them handling loading data</p></list-item><list-item><p>One handling data format transformation</p></list-item><list-item><p>One handling uploading data to HDFS</p></list-item></list></p>
        <p>Though there are more processes compared with the single-end situation, 2 of the processes require the same hardware channel and corresponds to the first stage of the pipeline. This implementation would alleviate the complexity of programming, while it would not harm the performance.</p>
        <p><xref ref-type="fig" rid="genes-10-00886-f005">Figure 5</xref> shows how processes are mapped to different stages of pipeline in the pre-processing step when processing paired-end data.</p>
        <p>According to Hennessy and Patterson’s work [<xref rid="B29-genes-10-00886" ref-type="bibr">29</xref>], if there is no overhead of pipeline, the speedup of the pipeline would be equal to the depth of the pipeline, in other words, the number of stages of the pipeline.
<disp-formula id="FD1-genes-10-00886"><label>(1)</label><mml:math id="mm1"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mo> </mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula>
where C is the total number of stages in a pipeline or the depth of a pipeline.</p>
        <p>In this situation, we can expect at most 3× speedup in the pre-processing.</p>
      </sec>
    </sec>
    <sec id="sec2dot3-genes-10-00886">
      <title>2.3. In-Memory-Computation in Main Computation</title>
      <sec id="sec2dot3dot1-genes-10-00886">
        <title>2.3.1. Design Principle</title>
        <p>In the main computation stage, SparkBWA would firstly store data from HDFS to local disk. Then, it would start a BWA-MEM to process this data. Though this method is easy to implement, it results in overhead.</p>
        <p>In order to deal with it, the data designed from HDFS would directly be feed to BWA-MEM, which is similar to BWASpark (GATK).</p>
        <p>Moreover, the result of BWA-MEM would also directly be stored in HDFS.</p>
      </sec>
      <sec id="sec2dot3dot2-genes-10-00886">
        <title>2.3.2. Implementation</title>
        <p>The implementation of PipeMEM relied on standard stream and PipeRDD. It consists of several steps:<list list-type="order"><list-item><p>Separate data from HDFS and distribute them to different nodes to create RDDs</p></list-item><list-item><p>Pipe the data in RDD to a program that modifies the format of input data. This step generates data format that could be utilized by BWA-MEM</p></list-item><list-item><p>Call single-node BWA-MEM</p></list-item><list-item><p>Pipe the result of BWA-MEM to generate new RDDs, and these RDDs would then store the data in HDFS.</p></list-item></list></p>
        <p><xref ref-type="fig" rid="genes-10-00886-f006">Figure 6</xref> shows the data from the main computation stage of PipeMEM. After loading data from HDFS, all the data is preserved in memory throughout all the computation, until the result is uploaded to HDFS again.</p>
        <p>This optimization would alleviate the overhead of data access to hardware disk. </p>
        <p>But, admittedly, BWA-MEM leveraged the pipeline structure to overlap the hardware data access with computation. So, the overhead of hardware access in BWA-MEM is not notable. Thus, the benefit might also not be remarkable.</p>
      </sec>
    </sec>
    <sec id="sec2dot4-genes-10-00886">
      <title>2.4. Experimental Setup</title>
      <sec id="sec2dot4dot1-genes-10-00886">
        <title>2.4.1. Metrics</title>
        <p>Apart from latency, we used three different kinds of metrics for the experiments: throughput, overhead, and scale efficiency.</p>
        <sec>
          <title>Throughput</title>
          <p>Throughput implies the speed of a framework. Higher throughput is better. We computed throughput with the following equation:<disp-formula id="FD2-genes-10-00886"><label>(2)</label><mml:math id="mm2"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>h</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>g</mml:mi><mml:mi>h</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>d</mml:mi><mml:mo> </mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>T</mml:mi></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula>
where N is the total number of reads in a data set, and T is the total time consumption to process these reads.</p>
        </sec>
        <sec>
          <title>Overhead</title>
          <p>There is no guarantee that parallelism would always bring about better performance. Empirically, some overheads [<xref rid="B28-genes-10-00886" ref-type="bibr">28</xref>] might drawback the performance of a parallel program:<list list-type="order"><list-item><p>Overhead in launching more workers</p></list-item><list-item><p>Overhead in synchronization</p></list-item><list-item><p>Overhead in network communication</p></list-item></list></p>
          <p>Now that we designed a framework to accelerate BWA-MEM in the multi-node environment, the time consumed for the BWA-MEM computation is a valid consumption, while all the other time consumption caused by different frameworks means overhead. Therefore, we proposed to measure overhead with the following equation:<disp-formula id="FD3-genes-10-00886"><label>(3)</label><mml:math id="mm3"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>h</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>B</mml:mi><mml:mi>W</mml:mi><mml:mi>A</mml:mi><mml:mo>−</mml:mo><mml:mi>M</mml:mi><mml:mi>E</mml:mi><mml:mi>M</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>f</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula></p>
          <p>However, because BWA-MEM is a single-node program, this metric is meaningful only in a single-node environment.</p>
        </sec>
        <sec>
          <title>Scale Efficiency</title>
          <p>Scalability is one metric that used countlessly when discussing parallel programming. But this metric sometimes does not indicate a good performance according to McSherry’s work [<xref rid="B30-genes-10-00886" ref-type="bibr">30</xref>].</p>
          <p>We used the concept of scale efficiency (Hennessy and Patterson 2011), to measure scalability. We computed scalability with the following equation. Higher efficiency implies better performance.
<disp-formula id="FD4-genes-10-00886"><label>(4)</label><mml:math id="mm4"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>f</mml:mi><mml:mi>f</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>i</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>P</mml:mi><mml:mo>×</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>P</mml:mi><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>d</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></disp-formula></p>
        </sec>
      </sec>
      <sec id="sec2dot4dot2-genes-10-00886">
        <title>2.4.2. Dataset and Experimental Environment</title>
        <p>We conducted the following experiments on a cluster with 10 nodes. The network was 1 GigE. Each node equipped with two E5-2670 CPU (2.6 GHz, 8 cores) with 64 GB memory. The Hadoop version was 2.6.4. The Spark version was 2.1.0. The BWA version was 0.7.15.</p>
        <p>We used part of 1000 Genomes Project data (NA12750, 3.5 million read pairs, 0.98GB) and part of NA12878 data (60 million read pairs, 31 GB) to perform most of the experiments. <xref rid="genes-10-00886-t002" ref-type="table">Table 2</xref> shows the details of the data we used.</p>
        <p>This research has also compared PipeMEM with SparkBWA and BWASpark (GATK) in the following section. Instead of using the same setting, we used a parameter that we found could achieve the best performance in our experiment environment. We used a method similar to PipeMEM we discussed in <xref ref-type="sec" rid="sec3dot2dot1-genes-10-00886">Section 3.2.1</xref> to discover the best parameter setting of counterpart methods. <xref rid="genes-10-00886-t003" ref-type="table">Table 3</xref> shows the parameter setting of SparkBWA and BWASpark.</p>
        <p>Admittedly, BWASpark (GATK)’s setting would not possibly use all the CPU resources. But our experiment showed that 16-task BWASpark was about 1.4 times faster than the 32-task version. From our experiment, 32-thread BWA-MEM could leverage the power of hyper-threading in the CPU. So, the implementation of BWA-MEM in Spark is theoretically able to make use of all the logical resources in CPU. The reason why BWASpark cannot achieve a better performance when utilizing physical CPU cores than utilizing logical CPU cores is probably that BWASpark treats Java task and C thread equally.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="results" id="sec3-genes-10-00886">
    <title>3. Results and Discussion</title>
    <sec id="sec3dot1-genes-10-00886">
      <title>3.1. Pre-Processing</title>
      <p>Uploading data to HDFS is unavoidable for every Spark-based alignment tool. But, considering that alignment is the first step in a whole-genome analysis pipeline, sooner or later, data should be loaded to HDFS. So, many papers dismiss this overhead [<xref rid="B24-genes-10-00886" ref-type="bibr">24</xref>,<xref rid="B25-genes-10-00886" ref-type="bibr">25</xref>,<xref rid="B26-genes-10-00886" ref-type="bibr">26</xref>].</p>
      <p>In this sub-section, we proved that the pipeline pattern could accelerate the pre-processing of PipeMEM.</p>
      <p>We only utilized the D2 dataset here since the size of the dataset would not influence the relative performance of different methods.</p>
      <p><xref rid="genes-10-00886-t004" ref-type="table">Table 4</xref> shows that utilizing pipeline can achieve 2.86× speedup in the pre-processing step of PipeMEM. This result was consistent with our analysis in the previous section, where we expected the max speedup of the pipeline pattern to be threefold. We leveraged a rather simple implementation of pipeline pattern with Python code. We believe it’s possible to accelerate the program further if we tried a C implementation.</p>
    </sec>
    <sec id="sec3dot2-genes-10-00886">
      <title>3.2. Main Computation</title>
      <sec id="sec3dot2dot1-genes-10-00886">
        <title>3.2.1. Parameter Setting of Tasks and Threads </title>
        <p>Before starting the experiment of the main computation stage, it is necessary to find out the most suitable parameters for the framework.</p>
        <p>In the situation of PipeMEM, we needed to figure out two parameters: the task count and the thread count.</p>
        <p>Task count is related to Spark. In the main computation stage, a single task would call a single BWA-MEM program. The thread count is related to BWA-MEM. The BWA-MEM leverage threads to handle alignment tasks. These are similar to SparkBWA while different from BWASpark (GATK), which treat tasks in Spark and thread in BWA-MEM equally.</p>
        <p>We tested every possible parameter groups of task count and thread count with dataset D1. Since every node only had 32 logical cores, thread count larger than 32 would only harm performance. So, we thought it was not necessary to test thread count larger than 32.</p>
        <p>We also tested a situation when the task counter was larger than eight. But in these cases, the operating system sometimes starts to use swap memory, even though system memory is still sufficient enough. The use of swap memory would no doubt decrease the performance dramatically. So, we chose not to present it here.</p>
        <p><xref ref-type="fig" rid="genes-10-00886-f007">Figure 7</xref> shows the performance comparison of different pairs of task count and thread count. It was easy to see that four tasks with eight threads brought about the highest performance. The following experiments would be conducted under this parameter setting.</p>
        <p>We also used this method to discover the best parameter of BWASpark (GATK) and SparkBWA. The results are presented in <xref rid="genes-10-00886-t003" ref-type="table">Table 3</xref>.</p>
      </sec>
      <sec id="sec3dot2dot2-genes-10-00886">
        <title>3.2.2. In Memory Computation</title>
        <p>We tested two different versions of implementations: local disk access and in-memory optimization. This experiment was under the dataset D2. <xref rid="genes-10-00886-t005" ref-type="table">Table 5</xref> shows the result.</p>
        <p>From <xref rid="genes-10-00886-t006" ref-type="table">Table 6</xref>, it is easy to see that in-memory optimization can speed up the main computation of PipeMEM. It is not so notable because BWA-MEM has already implemented a pipeline pattern to alleviate the disk accessing overhead of the program.</p>
      </sec>
    </sec>
    <sec id="sec3dot3-genes-10-00886">
      <title>3.3. Comparison of PipeMEM, BWASpark(GATK), and SparkBWA</title>
      <p>In this sub-section, we first compared the pre-processing and the main computation stage of different frameworks separately. Then, we wrapped these stages together to compare the performance of these frameworks.</p>
      <sec id="sec3dot3dot1-genes-10-00886">
        <title>3.3.1. Pre-Processing </title>
        <p>In this sub-section, we tested the time consumption of the pre-processing of PipeMEM, BWASpark (GATK), and SparkBWA. We included all the time consumed before putting sequence data into HDFS. But we did not include the time consumption for creating index because it is static to the data set. Besides, in addition to the time consumed by BWA to create an index, BWASpark (GATK) needed another 1.7 minutes to create a self-defined index file. We did not include this either.</p>
        <p><xref rid="genes-10-00886-t005" ref-type="table">Table 5</xref> shows the time consumption of the pre-processing of different methods. SparkBWA was the fastest because it used HDFS API to finish this task, which reduced overhead dramatically.</p>
        <p>BWASpark was the slowest one because it conducted tasks serially. There were many tasks at this stage. We believed this stage could be accelerated further if it also applied a pipeline parallel pattern.</p>
        <p>We only leveraged Python to conduct the pre-processing. But it was still comparable with SparkBWA, which utilizes native API in the Hadoop. We believed the performance of PipeMEM would be further improved if this step was implemented with C. This would be a part of our future work. </p>
      </sec>
      <sec id="sec3dot3dot2-genes-10-00886">
        <title>3.3.2. Main Computation</title>
        <p>We tested the overhead of the main computation of PipeMEM. We reported the overhead of PipeMEM, BWASpark, and BWASpark in <xref rid="genes-10-00886-t007" ref-type="table">Table 7</xref>.</p>
        <p>It was easy to see that PipeMEM was the lightest one among all three frameworks. This performance was achieved by removing all unnecessary operations in the counterpart implementations.</p>
        <p>It’s not easy to explain why BWASpark (GATK) suffered such an overhead. BWASpark integrated BWA-MEM tightly. It was a little hard to analyze their code. We guessed this comes from the dissembling of reads and then reassembling it into the sam structure. So, this overhead might come from implementation. Additionally, BWASpark treated processes in Java and threads in C equally, which would also harm performance. This could be another overhead from implementation.</p>
        <p>The reason why SparkBWA’s overhead was so high is that before the main computation, when processing paired-end sequencing data, it would firstly iterate throughout the input files, merge them, and then distribute data. When all of these tasks finished, the computation of BWA could be processed. Additionally, writing the data, coming from HDFS into a local disk, before it is processed to BWA-MEM, also increased the overhead. According to our knowledge of BWA-MEM, these steps are redundant. So, overhead in this framework came from unnecessary synchronization. Interestingly, this result conflicted with [<xref rid="B26-genes-10-00886" ref-type="bibr">26</xref>], which stated that SparkBWA could be faster than BWA in a single node. Two reasons could explain this difference: (1) They did not report the paired-end situation. (2) The CPUs they used (AMD Opteron 6262HE) do not support hyper-threading, while the CPUs we used, support this feature. According to our experiments, BWA-MEM could make good use of this feature.</p>
        <p><xref ref-type="fig" rid="genes-10-00886-f008">Figure 8</xref> shows the throughput of all tools run through 10 nodes. The ideal line was drawn under the assumption that BWA-MEM could be scaled with the efficiency of one.</p>
        <p>It was easy to see that the performance of PipeMEM was the best among the three tools, and it was the closest one to the ideal line.</p>
        <p>The throughput of BWASpark reached its highest point at seven nodes and started decreasing. This was because the speedup brought by using more nodes was less than the overhead caused by additional nodes.</p>
        <p>The trend of SparkBWA and PipeMEM were similar because they used a similar strategy. </p>
        <p>It is worth mention that the distances of each point to the ideal line in the figure imply the overhead at that point. This indicates that PipeMEM had the lowest overhead among all the tools.</p>
        <p><xref ref-type="fig" rid="genes-10-00886-f009">Figure 9</xref> shows the scale efficiency between PipeMEM, BWASpark, and SparkBWA. It is interesting to note that SparkBWA scaled quite well in this experiment. This was consistent with the experiment done by SparkBWA [<xref rid="B26-genes-10-00886" ref-type="bibr">26</xref>]. However, considering the worst performance of SparkBWA in a single-node, the scalability of SparkBWA does not imply a good performance in general. It’s a normal trend that as the node increases, the efficiency of the program decreases. This decline is caused by the overhead of parallelism. The reason why the efficiency of SparkBWA increased in a two-node situation was more or less because its performance in a single-node was too bad.</p>
        <p>The trend of the efficiency of PipeMEM and SparkBWA was similar to each other. This implies that they suffered from similar overhead for additional nodes. This is reasonable because they utilized a similar parallel strategy. </p>
        <p>On the other hand, the efficiency of BWASpark decreased faster. This implied its higher overhead in parallelism. We guessed this phenomenon was caused by it dissembling reads and re-assembling reads, which increase the overhead from network communication because the original data might not be stored in the node in which the computation is performed. On the other hand, PipeMEM and SparkBWA only saved results at the closest data node of HDFS (supported by the HDFS API).</p>
        <p>To better understand the different performance between PipeMEM and BWASpark (GATK) and between PipeMEM and SparkBWA, we further reported the relative performance of PipeMEM to BWASpark (GATK) and PipeMEM to SparkBWA. <xref ref-type="fig" rid="genes-10-00886-f010">Figure 10</xref> shows the results.</p>
        <p>From <xref ref-type="fig" rid="genes-10-00886-f010">Figure 10</xref>, we could see that PipeMEM was at least 2.2 times faster than SparkBWA and at least 1.5 times faster than BWASpark. The relative performance between PipeMEM and SparkBWA was relatively stable. The relative speedup of PipeMEM to SparkBWA was increasing as the number of nodes increased. It achieved about 2.66× speedup in the 10-node environment. On average, PipeMEM was 2.33 times faster than SparkBWA and 2.27 times faster than BWASpark.</p>
      </sec>
      <sec id="sec3dot3dot3-genes-10-00886">
        <title>3.3.3. Integrate Analysis </title>
        <p>To better understand the different performance of the whole process, PipeMEM, SparkBWA, and BWASpark (GATK), we took all parts, including the pre-processing and the main computation, and compared them in this section.</p>
        <p>Because BWASpark (GATK) achieved its best performance in seven nodes, we compared the performance of different tools in a seven-node environment. The results are shown in <xref ref-type="fig" rid="genes-10-00886-f011">Figure 11</xref>.</p>
        <p>From <xref ref-type="fig" rid="genes-10-00886-f011">Figure 11</xref>, it is easy to see that the pre-processing of BWASpark was too long compared with the time consumed by its main computation. Though the time consumption of the pre-processing in PipeMEM was higher compared with SparkBWA, the total performance of PipeMEM was still better. </p>
        <p>In order to understand the relative performance of SparkBWA and PipeMEM, we further reported the relative speedup of PipeMEM compared with SparkBWA. The result is shown in <xref ref-type="fig" rid="genes-10-00886-f012">Figure 12</xref>. It was easy to see a flatter trend of this line, and the relative speedup ended at about 1.2×. This means that even considering the overhead of pre-computation, which could not be scaled, PipeMEM was still about 20% faster than SparkBWA.</p>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec4-genes-10-00886">
    <title>4. Conclusions</title>
    <p>In this paper, we presented PipeMEM, a framework to run BWA-MEM in Spark easily while having a high performance and low overhead. The framework mainly consists of two stages: pre-processing and main computation. We further designed a data format that could be used by Spark to separate data without compromising the atomicity of the original data. We optimized the pre-processing step with a pipeline parallel pattern that achieved 2.86× speedup. We also optimized the main computation stages by utilizing standard stream and PipeRDD to ensure that there is no local disk access. We tested our framework from various performance perspectives and proved that the proposed optimization could improve the performance of PipeMEM. Our solution was significantly faster than existing tools, i.e., BWASpark (GATK) and SparkBWA, with lower overhead.</p>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgments</title>
    <p>The authors would like to thank Yong Zhang and Shengkang Li of the Beijing Genomics Institute (BGI) for great help and guidance in the processing of genes data and providing test platforms for tools in our research.</p>
  </ack>
  <notes>
    <title>Author Contributions</title>
    <p>Software, L.Z. and C.L.; Supervision, S.D.; Writing—original draft, L.Z.; Writing—review and editing, S.D.</p>
  </notes>
  <notes>
    <title>Funding</title>
    <p>This work was supported by the Guangdong Natural Science Foundation (2015A030308017) of China, the National Natural Science Foundation of China (61976239).</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Conflicts of Interest</title>
    <p>The authors declare no conflict of interest.</p>
  </notes>
  <ref-list>
    <title>References</title>
    <ref id="B1-genes-10-00886">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate long-read alignment with Burrows–Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>589</fpage>
        <lpage>595</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp698</pub-id>
        <pub-id pub-id-type="pmid">20080505</pub-id>
      </element-citation>
    </ref>
    <ref id="B2-genes-10-00886">
      <label>2.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H.</given-names>
          </name>
        </person-group>
        <article-title>Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM</article-title>
        <source>arXiv</source>
        <year>2013</year>
        <pub-id pub-id-type="arxiv">1303.3997</pub-id>
      </element-citation>
    </ref>
    <ref id="B3-genes-10-00886">
      <label>3.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>S.L.</given-names>
          </name>
        </person-group>
        <article-title>Fast gapped-read alignment with Bowtie 2</article-title>
        <source>Nat. Methods</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>357</fpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id>
        <pub-id pub-id-type="pmid">22388286</pub-id>
      </element-citation>
    </ref>
    <ref id="B4-genes-10-00886">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Maskell</surname>
            <given-names>D.L.</given-names>
          </name>
        </person-group>
        <article-title>CUSHAW: A CUDA compatible short read aligner to large genomes based on the Burrows–Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>1830</fpage>
        <lpage>1837</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts276</pub-id>
        <?supplied-pmid 22576173?>
        <pub-id pub-id-type="pmid">22576173</pub-id>
      </element-citation>
    </ref>
    <ref id="B5-genes-10-00886">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vurture</surname>
            <given-names>G.W.</given-names>
          </name>
          <name>
            <surname>Sedlazeck</surname>
            <given-names>F.J.</given-names>
          </name>
          <name>
            <surname>Nattestad</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Underwood</surname>
            <given-names>C.J.</given-names>
          </name>
          <name>
            <surname>Fang</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Gurtowski</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Schatz</surname>
            <given-names>M.C.</given-names>
          </name>
        </person-group>
        <article-title>GenomeScope: Fast reference-free genome profiling from short reads</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>33</volume>
        <fpage>2202</fpage>
        <lpage>2204</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btx153</pub-id>
        <?supplied-pmid 28369201?>
        <pub-id pub-id-type="pmid">28369201</pub-id>
      </element-citation>
    </ref>
    <ref id="B6-genes-10-00886">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Feuerriegel</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Schleusener</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Beckert</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Kohl</surname>
            <given-names>T.A.</given-names>
          </name>
          <name>
            <surname>Miotto</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Cirillo</surname>
            <given-names>D.M.</given-names>
          </name>
          <name>
            <surname>Cabibbe</surname>
            <given-names>A.M.</given-names>
          </name>
          <name>
            <surname>Niemann</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Fellenberg</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>PhyResSE: Web tool delineating Mycobacterium tuberculosis antibiotic resistance and lineage from whole-genome sequencing data</article-title>
        <source>J. Clin. Microbiol.</source>
        <year>2015</year>
        <pub-id pub-id-type="doi">10.1128/JCM.00025-15</pub-id>
        <?supplied-pmid 25854485?>
        <pub-id pub-id-type="pmid">25854485</pub-id>
      </element-citation>
    </ref>
    <ref id="B7-genes-10-00886">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chiang</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Layer</surname>
            <given-names>R.M.</given-names>
          </name>
          <name>
            <surname>Faust</surname>
            <given-names>G.G.</given-names>
          </name>
          <name>
            <surname>Lindberg</surname>
            <given-names>M.R.</given-names>
          </name>
          <name>
            <surname>Rose</surname>
            <given-names>D.B.</given-names>
          </name>
          <name>
            <surname>Garrison</surname>
            <given-names>E.P.</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>G.T.</given-names>
          </name>
          <name>
            <surname>Quinlan</surname>
            <given-names>A.R.</given-names>
          </name>
          <name>
            <surname>Hall</surname>
            <given-names>I.M.</given-names>
          </name>
        </person-group>
        <article-title>SpeedSeq: Ultra-fast personal genome analysis and interpretation</article-title>
        <source>Nat. Methods</source>
        <year>2015</year>
        <volume>12</volume>
        <fpage>966</fpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.3505</pub-id>
        <pub-id pub-id-type="pmid">26258291</pub-id>
      </element-citation>
    </ref>
    <ref id="B8-genes-10-00886">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Torri</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Dinov</surname>
            <given-names>I.D.</given-names>
          </name>
          <name>
            <surname>Zamanyan</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Hobel</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Genco</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Petrosyan</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Clark</surname>
            <given-names>A.P.</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>Z.</given-names>
          </name>
          <name>
            <surname>Eggert</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Pierce</surname>
            <given-names>J.</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Next generation sequence analysis and computational genomics using graphical pipeline workflows</article-title>
        <source>Genes</source>
        <year>2012</year>
        <volume>3</volume>
        <fpage>545</fpage>
        <lpage>575</lpage>
        <pub-id pub-id-type="doi">10.3390/genes3030545</pub-id>
        <pub-id pub-id-type="pmid">23139896</pub-id>
      </element-citation>
    </ref>
    <ref id="B9-genes-10-00886">
      <label>9.</label>
      <element-citation publication-type="web">
        <article-title>Genome Analysis Toolkit</article-title>
        <comment>Available online: <ext-link ext-link-type="uri" xlink:href="https://software.broadinstitute.org/gatk/">https://software.broadinstitute.org/gatk/</ext-link></comment>
        <date-in-citation content-type="access-date" iso-8601-date="2019-08-15">(accessed on 15 August 2019)</date-in-citation>
      </element-citation>
    </ref>
    <ref id="B10-genes-10-00886">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ping</surname>
            <given-names>L.</given-names>
          </name>
        </person-group>
        <article-title>Speeding up large-scale next generation sequencing data analysis with pBWA</article-title>
        <source>J. Appl. Bioinform. Comput. Biol.</source>
        <year>2012</year>
        <volume>1</volume>
        <pub-id pub-id-type="doi">10.4172/jbcg.1000101</pub-id>
      </element-citation>
    </ref>
    <ref id="B11-genes-10-00886">
      <label>11.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Darling</surname>
            <given-names>A.E.</given-names>
          </name>
          <name>
            <surname>Carey</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Feng</surname>
            <given-names>W.C.</given-names>
          </name>
        </person-group>
        <source>The Design, Implementation and Evaluation of mpiBLAST</source>
        <publisher-name>Los Alamos National Laboratory</publisher-name>
        <publisher-loc>Los Alamos, NM, USA</publisher-loc>
        <year>2003</year>
      </element-citation>
    </ref>
    <ref id="B12-genes-10-00886">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>S.F.</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W.</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E.W.</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D.J.</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J. Mol. Biol.</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="doi">10.1016/S0022-2836(05)80360-2</pub-id>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </element-citation>
    </ref>
    <ref id="B13-genes-10-00886">
      <label>13.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Georganas</surname>
            <given-names>E.</given-names>
          </name>
          <name>
            <surname>Buluç</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Chapman</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Oliker</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Rokhsar</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Yelick</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>Meraligner: A fully parallel sequence aligner</article-title>
        <source>Proceedings of the 2015 IEEE International Parallel and Distributed Processing Symposium (IPDPS)</source>
        <conf-loc>Hyderabad, India</conf-loc>
        <conf-date>25–29 May 2015</conf-date>
        <fpage>561</fpage>
        <lpage>570</lpage>
      </element-citation>
    </ref>
    <ref id="B14-genes-10-00886">
      <label>14.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Duan</surname>
            <given-names>X.</given-names>
          </name>
          <name>
            <surname>Xu</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Chan</surname>
            <given-names>Y.</given-names>
          </name>
          <name>
            <surname>Hundt</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B.</given-names>
          </name>
          <name>
            <surname>Balaji</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>W.</given-names>
          </name>
        </person-group>
        <article-title>S-Aligner: Ultrascalable Read Mapping on Sunway Taihu Light</article-title>
        <source>Proceedings of the 2017 IEEE International Conference on Cluster Computing (CLUSTER)</source>
        <conf-loc>Honolulu, HI, USA</conf-loc>
        <conf-date>5–8 September 2017</conf-date>
        <fpage>36</fpage>
        <lpage>46</lpage>
      </element-citation>
    </ref>
    <ref id="B15-genes-10-00886">
      <label>15.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>W.-P.</given-names>
          </name>
          <name>
            <surname>Garrison</surname>
            <given-names>E.P.</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>G.T.</given-names>
          </name>
        </person-group>
        <article-title>SSW library: An SIMD Smith-Waterman C/C++ library for use in genomic applications</article-title>
        <source>PLoS ONE</source>
        <year>2013</year>
        <volume>8</volume>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0082138</pub-id>
        <?supplied-pmid 24324759?>
        <pub-id pub-id-type="pmid">24324759</pub-id>
      </element-citation>
    </ref>
    <ref id="B16-genes-10-00886">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Waterman</surname>
            <given-names>M.</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequence</article-title>
        <source>Mol. Biol.</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
      </element-citation>
    </ref>
    <ref id="B17-genes-10-00886">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weese</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Holtgrewe</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K.</given-names>
          </name>
        </person-group>
        <article-title>RazerS 3: Faster, fully sensitive read mapping</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>2592</fpage>
        <lpage>2599</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts505</pub-id>
        <?supplied-pmid 22923295?>
        <pub-id pub-id-type="pmid">22923295</pub-id>
      </element-citation>
    </ref>
    <ref id="B18-genes-10-00886">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>González-Domínguez</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Hundt</surname>
            <given-names>C.</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B.</given-names>
          </name>
        </person-group>
        <article-title>parSRA: A framework for the parallel execution of short read aligners on compute clusters</article-title>
        <source>J. Comput. Sci.</source>
        <year>2018</year>
        <volume>25</volume>
        <fpage>134</fpage>
        <lpage>139</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jocs.2017.01.008</pub-id>
      </element-citation>
    </ref>
    <ref id="B19-genes-10-00886">
      <label>19.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>Leo</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Santoni</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Zanetti</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>Biodoop: Bioinformatics on hadoop</article-title>
        <source>Proceedings of the 2009 International Conference Parallel Processing Workshops</source>
        <conf-loc>Vienna, Austria</conf-loc>
        <conf-date>22–25 September 2009</conf-date>
        <fpage>415</fpage>
        <lpage>422</lpage>
      </element-citation>
    </ref>
    <ref id="B20-genes-10-00886">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nordberg</surname>
            <given-names>H.</given-names>
          </name>
          <name>
            <surname>Bhatia</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>K.</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>Z.</given-names>
          </name>
        </person-group>
        <article-title>BioPig: A Hadoop-based analytic toolkit for large-scale sequence data</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>3014</fpage>
        <lpage>3019</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btt528</pub-id>
        <pub-id pub-id-type="pmid">24021384</pub-id>
      </element-citation>
    </ref>
    <ref id="B21-genes-10-00886">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jourdren</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Bernard</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Dillies</surname>
            <given-names>M.-A.</given-names>
          </name>
          <name>
            <surname>Le Crom</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>Eoulsan: A cloud computing-based framework facilitating high throughput sequencing analyses</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>1542</fpage>
        <lpage>1543</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bts165</pub-id>
        <pub-id pub-id-type="pmid">22492314</pub-id>
      </element-citation>
    </ref>
    <ref id="B22-genes-10-00886">
      <label>22.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wiewiórka</surname>
            <given-names>M.S.</given-names>
          </name>
          <name>
            <surname>Messina</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Pacholewska</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Maffioletti</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Gawrysiak</surname>
            <given-names>P.</given-names>
          </name>
          <name>
            <surname>Okoniewski</surname>
            <given-names>M.J.</given-names>
          </name>
        </person-group>
        <article-title>SparkSeq: Fast, scalable and cloud-ready tool for the interactive genomic data analysis with nucleotide precision</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>2652</fpage>
        <lpage>2653</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu343</pub-id>
        <pub-id pub-id-type="pmid">24845651</pub-id>
      </element-citation>
    </ref>
    <ref id="B23-genes-10-00886">
      <label>23.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simonyan</surname>
            <given-names>V.</given-names>
          </name>
          <name>
            <surname>Mazumder</surname>
            <given-names>R.</given-names>
          </name>
        </person-group>
        <article-title>High-Performance Integrated Virtual Environment (HIVE) tools and applications for big data analysis</article-title>
        <source>Genes</source>
        <year>2014</year>
        <volume>5</volume>
        <fpage>957</fpage>
        <lpage>981</lpage>
        <pub-id pub-id-type="doi">10.3390/genes5040957</pub-id>
        <pub-id pub-id-type="pmid">25271953</pub-id>
      </element-citation>
    </ref>
    <ref id="B24-genes-10-00886">
      <label>24.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abuín</surname>
            <given-names>J.M.</given-names>
          </name>
          <name>
            <surname>Pichel</surname>
            <given-names>J.C.</given-names>
          </name>
          <name>
            <surname>Pena</surname>
            <given-names>T.F.</given-names>
          </name>
          <name>
            <surname>Amigo</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>BigBWA: Approaching the Burrows–Wheeler aligner to Big Data technologies</article-title>
        <source>Bioinformatics</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>4003</fpage>
        <lpage>4005</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv506</pub-id>
        <pub-id pub-id-type="pmid">26323715</pub-id>
      </element-citation>
    </ref>
    <ref id="B25-genes-10-00886">
      <label>25.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pireddu</surname>
            <given-names>L.</given-names>
          </name>
          <name>
            <surname>Leo</surname>
            <given-names>S.</given-names>
          </name>
          <name>
            <surname>Zanetti</surname>
            <given-names>G.</given-names>
          </name>
        </person-group>
        <article-title>SEAL: A distributed short read mapping and duplicate removal tool</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>2159</fpage>
        <lpage>2160</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr325</pub-id>
        <pub-id pub-id-type="pmid">21697132</pub-id>
      </element-citation>
    </ref>
    <ref id="B26-genes-10-00886">
      <label>26.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abuín</surname>
            <given-names>J.M.</given-names>
          </name>
          <name>
            <surname>Pichel</surname>
            <given-names>J.C.</given-names>
          </name>
          <name>
            <surname>Pena</surname>
            <given-names>T.F.</given-names>
          </name>
          <name>
            <surname>Amigo</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <article-title>SparkBWA: Speeding up the alignment of high-throughput DNA sequencing data</article-title>
        <source>PLoS ONE</source>
        <year>2016</year>
        <volume>11</volume>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0155461</pub-id>
        <?supplied-pmid 27182962?>
        <pub-id pub-id-type="pmid">27182962</pub-id>
      </element-citation>
    </ref>
    <ref id="B27-genes-10-00886">
      <label>27.</label>
      <element-citation publication-type="web">
        <article-title>BWASpark</article-title>
        <comment>Available online: <ext-link ext-link-type="uri" xlink:href="https://gatkforums.broadinstitute.org/gatk/discussions/tagged/bwaspark">https://gatkforums.broadinstitute.org/gatk/discussions/tagged/bwaspark</ext-link></comment>
        <date-in-citation content-type="access-date" iso-8601-date="2019-08-15">(accessed on 15 August 2019)</date-in-citation>
      </element-citation>
    </ref>
    <ref id="B28-genes-10-00886">
      <label>28.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>McCool</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Robison</surname>
            <given-names>A.</given-names>
          </name>
          <name>
            <surname>Reinders</surname>
            <given-names>J.</given-names>
          </name>
        </person-group>
        <source>Structured Parallel Programming: Patterns for Efficient Computation</source>
        <publisher-name>Elsevier</publisher-name>
        <publisher-loc>Waltham, MA, USA</publisher-loc>
        <year>2012</year>
      </element-citation>
    </ref>
    <ref id="B29-genes-10-00886">
      <label>29.</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hennessy</surname>
            <given-names>J.L.</given-names>
          </name>
          <name>
            <surname>Patterson</surname>
            <given-names>D.A.</given-names>
          </name>
        </person-group>
        <source>Computer Architecture: A quantitative Approach</source>
        <publisher-name>Elsevier</publisher-name>
        <publisher-loc>Waltham, MA, USA</publisher-loc>
        <year>2011</year>
      </element-citation>
    </ref>
    <ref id="B30-genes-10-00886">
      <label>30.</label>
      <element-citation publication-type="confproc">
        <person-group person-group-type="author">
          <name>
            <surname>McSherry</surname>
            <given-names>F.</given-names>
          </name>
          <name>
            <surname>Isard</surname>
            <given-names>M.</given-names>
          </name>
          <name>
            <surname>Murray</surname>
            <given-names>D.G.</given-names>
          </name>
        </person-group>
        <article-title>Scalability! but at what COST?</article-title>
        <source>Proceedings of the HotOS</source>
        <conf-loc>Kartause Ittingen, Switzerland</conf-loc>
        <conf-date>18–20 May 2015</conf-date>
        <volume>Volume 15</volume>
        <fpage>14</fpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="genes-10-00886-f001" orientation="portrait" position="float">
    <label>Figure 1</label>
    <caption>
      <p>The workflow of PipeMEM in the paired-end situation. In the pre-processing stage, two input fastq files are merged and transformed, and then uploaded to HDFS (Hadoop Distributed File System). In the main computation stage, the merged file is distributed to computing nodes by Spark API (Application Programming Interfaces). In local-node, PipeMEM would redo the modification, then evoke BWA-MEM to process these data. After that, PipeMEM would upload these results to HDFS with Spark API.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g001"/>
  </fig>
  <fig id="genes-10-00886-f002" orientation="portrait" position="float">
    <label>Figure 2</label>
    <caption>
      <p>Example of paired-end reads. Four lines compose a read: (1) sequence identifier, (2) raw sequence, (3) optional line, (4) quality score. Paired-end reads share same identifiers, except the last character as showed in red circle in the figure.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g002"/>
  </fig>
  <fig id="genes-10-00886-f003" orientation="portrait" position="float">
    <label>Figure 3</label>
    <caption>
      <p>Data flow in PipeMEM in the paired-end situation. The upper part explains the process of PipeMEM with a “data unit” point of view; The lower part explains in detail how data format is modified throughout the PipeMEM process. In the pre-processing, PipeMEM would merge and transform the data unit in fastq files. Then, PipeMEM would upload the modified data unit to HDFS. In the main computation, PipeMEM would distribute the modified data unit to different nodes. PipeMEM would then transform the distributed data unit back to the original format and process them to BWA-MEM. After all of that, PipeMEM would upload the results of that data unit to HDFS again. The below part shows how data format changes in different stages of PipeMEM. In the pre-processing, PipeMEM would replace the line breaker in the data unit by a splitter. Then, PipeMEM would merge the data units in paired-end reads. In the main computation, PipeMEM would replace the splitter inside the modified data unit by line breaker again. After that, PipeMEM would feed this data unit to BWA-MEM.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g003"/>
  </fig>
  <fig id="genes-10-00886-f004" orientation="portrait" position="float">
    <label>Figure 4</label>
    <caption>
      <p>The pipeline structure in the pre-processing stage (hardware perspective). At the first time-unit, loading data hardware would process the first set of data. At the next time-unit, loading data hardware would process the next set of data, while manipulating data format hardware would start to process the first set of data. This process continues until uploading data hardware finishes the processing of the last data set.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g004"/>
  </fig>
  <fig id="genes-10-00886-f005" orientation="portrait" position="float">
    <label>Figure 5</label>
    <caption>
      <p>Implementation of the pre-processing stage in the paired-end situation. Process 1 and process 2 are in charge of loading data, each one handling one fastq file. They pass the input data to process 3, which is in charge of manipulating data format. Process 3 passes the result to process 4. Process 4 would upload this data to HDFS.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g005"/>
  </fig>
  <fig id="genes-10-00886-f006" orientation="portrait" position="float">
    <label>Figure 6</label>
    <caption>
      <p>Data flow of the main computation stage. It shows that data are not stored in local-disk through the whole main computation.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g006"/>
  </fig>
  <fig id="genes-10-00886-f007" orientation="portrait" position="float">
    <label>Figure 7</label>
    <caption>
      <p>Alignment speed of different pairs of thread count and task count. Throughput of different pairs of thread count and task count, four tasks with eight threads bring about the highest performance.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g007"/>
  </fig>
  <fig id="genes-10-00886-f008" orientation="portrait" position="float">
    <label>Figure 8</label>
    <caption>
      <p>Comparison of throughput between PipeMEM, BWASpark, and SparkBWA. The ideal line is drawn under the assumption that BWA-MEM can be scaled with the efficiency of one. It’s easy to see that the performance of PipeMEM is the best among three tools, and it is the closest one to the ideal line. The throughput of BWASpark reaches its highest point at seven nodes and start decreasing. This is because the speedup brought by using more nodes is less than the overhead caused by additional nodes. The trend of SparkBWA and PipeMEM are similar because they used a similar strategy.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g008"/>
  </fig>
  <fig id="genes-10-00886-f009" orientation="portrait" position="float">
    <label>Figure 9</label>
    <caption>
      <p>Comparison of scale efficiency between PipeMEM, BWASpark, and SparkBWA. It’s a normal trend that as the node increases, the efficiency of the program decreases. This decline is caused by the overhead of parallelism. The reason why the efficiency of SparkBWA increases in a two-node situation is more or less because its performance in single-node is too bad. The trend of the efficiency of PipeMEM and SparkBWA is similar to each other. Besides, the efficiency of BWASpark (GATK) decreases the fastest. This implies its higher overhead in parallelism.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g009"/>
  </fig>
  <fig id="genes-10-00886-f010" orientation="portrait" position="float">
    <label>Figure 10</label>
    <caption>
      <p>Relative speed of PipeMEM to BWASpark (GATK) and PipeMEM to SparkBWA. At every different node environment, PipeMEM maintains a higher performance compared with BWASpark and SparkBWA. PipeMEM is at least 2.2 times faster than SparkBWA and at least 1.5 times faster than BWASpark. The relative performance between PipeMEM and SparkBWA is relatively stable. The relative speedup of PipeMEM to SparkBWA is increasing as the number of nodes increases. It achieves about 2.66 × speedup at the 10-node environment. On average, PipeMEM is 2.33 times faster than SparkBWA and 2.27 times faster than BWASpark.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g010"/>
  </fig>
  <fig id="genes-10-00886-f011" orientation="portrait" position="float">
    <label>Figure 11</label>
    <caption>
      <p>Comparison of the integrated program in seven nodes. The pre-processing of BWASpark is too long compared with the time consumed by its main computation. PipeMEM spends a relatively long time in the pre-processing compared with SparkBWA, but PipeMEM is faster, even including pre-processing.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g011"/>
  </fig>
  <fig id="genes-10-00886-f012" orientation="portrait" position="float">
    <label>Figure 12</label>
    <caption>
      <p>Relative speedup of PipeMEM compared with SparkBWA (including the pre-processing and the main computation). Relative speedup of PipeMEM to SparkBWA as a whole. There is a flatter trend in this line. The relative speedup ends at about 1.2×.</p>
    </caption>
    <graphic xlink:href="genes-10-00886-g012"/>
  </fig>
  <table-wrap id="genes-10-00886-t001" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t001_Table 1</object-id>
    <label>Table 1</label>
    <caption>
      <p>Differences between PipeMEM, BWASpark (GATK), and SparkBWA.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PipeMEM</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BWASpark (GATK)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">SparkBWA</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pre-processing</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">(1) Change the data format<break/>(2) Upload data to HDFS</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">(1) Change the data format (fastq to sam)<break/>(2) Create a self-defined index file<break/>(3) Upload data to HDFS</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">(1) Upload data to HDFS</td>
        </tr>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Main Computation</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">(1) Distribute data<break/>(2) Transform data back to the original format<break/>(3) BWA-MEM<break/>(4) Upload results to HDFS</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">(1) District sequence from the original file<break/>(2) Distribute data (sequence)<break/>(3) Modified-BWA-MEM<break/>(4) Merge results with original data<break/>(5) Store results to HDFS</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">(1) Iterate and then merge fastq files<break/>(2) Distribute data<break/>(3) BWA-MEM<break/>(4) Upload results to HDFS</td>
        </tr>
      </tbody>
    </table>
    <table-wrap-foot>
      <fn>
        <p>HDFS, Hadoop Distributed File System.</p>
      </fn>
    </table-wrap-foot>
  </table-wrap>
  <table-wrap id="genes-10-00886-t002" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t002_Table 2</object-id>
    <label>Table 2</label>
    <caption>
      <p>Dataset.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Tag of Dataset</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Number of Paired Read</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Read Length (bp)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Size (GB)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Comment</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">40 pD1</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">350,000</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">51</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">0.98</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">Cut from NA12750</td>
        </tr>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">D2</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">60,000,000</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">100</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">31</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Cut from NA12878</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-10-00886-t003" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t003_Table 3</object-id>
    <label>Table 3</label>
    <caption>
      <p>Parameter Setting.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Item</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Task</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Thread</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Comment</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">PipeMEM</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">4</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">8</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">
</td>
        </tr>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">BWASpark (GATK)</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">16</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">-</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">Every task corresponds to a thread</td>
        </tr>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">SparkBWA</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">16</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Use Spark-Join instead of SortHDFS</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-10-00886-t004" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t004_Table 4</object-id>
    <label>Table 4</label>
    <caption>
      <p>Latency of pre-processing in PipeMEM.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">D2</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PipeMEM</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PipeMEM (pipeline)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Speedup</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pre-processing (min)</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">23.31</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">8.16</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2.86×</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-10-00886-t005" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t005_Table 5</object-id>
    <label>Table 5</label>
    <caption>
      <p>Time consumption of the pre-processing in PipeMEM, BWASpark, and SparkBWA.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">D2</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PipeMEM</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BWASpark (GATK)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">SparkBWA</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pre-processing (min)</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">8.16</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">34.06</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">5.9</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-10-00886-t006" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t006_Table 6</object-id>
    <label>Table 6</label>
    <caption>
      <p>Time consumption between whether applying disk access optimization strategy in PipeMEM.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Nodes (min)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">1</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">2</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">3</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">4</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">5</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">6</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">7</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">8</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">9</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">10</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Average</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">Local disk access</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">27.60</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">14.00</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">9.70</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">7.30</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">6.04</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">5.26</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">4.82</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">4.32</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">3.95</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">3.70</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">-</td>
        </tr>
        <tr>
          <td align="center" valign="middle" rowspan="1" colspan="1">In-memory (optimize)</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">27.00</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">14.00</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">9.50</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">7.20</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">5.90</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">5.15</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">4.60</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">4.20</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">3.80</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">3.58</td>
          <td align="center" valign="middle" rowspan="1" colspan="1">-</td>
        </tr>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Differential</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.60</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.00</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.20</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.10</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.14</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.11</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.22</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.12</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.15</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.12</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.18</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="genes-10-00886-t007" orientation="portrait" position="float">
    <object-id pub-id-type="pii">genes-10-00886-t007_Table 7</object-id>
    <label>Table 7</label>
    <caption>
      <p>Overhead of PipeMEM, BWASpark, and SparkBWA.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <thead>
        <tr>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">D2</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PipeMEM</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BWASpark (GATK)</th>
          <th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">SparkBWA</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Overhead</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">3.70%</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">33.65%</td>
          <td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">61.05%</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
</floats-group>
