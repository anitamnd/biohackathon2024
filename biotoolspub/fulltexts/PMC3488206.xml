<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="publisher-id">nar</journal-id>
    <journal-id journal-id-type="hwp">nar</journal-id>
    <journal-title-group>
      <journal-title>Nucleic Acids Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">0305-1048</issn>
    <issn pub-type="epub">1362-4962</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3488206</article-id>
    <article-id pub-id-type="doi">10.1093/nar/gks678</article-id>
    <article-id pub-id-type="publisher-id">gks678</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methods Online</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>MetaVelvet: an extension of Velvet assembler to <italic>de novo</italic> metagenome assembly from short sequence reads</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Namiki</surname>
          <given-names>Toshiaki</given-names>
        </name>
        <xref ref-type="aff" rid="gks678-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="gks678-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hachiya</surname>
          <given-names>Tsuyoshi</given-names>
        </name>
        <xref ref-type="aff" rid="gks678-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tanaka</surname>
          <given-names>Hideaki</given-names>
        </name>
        <xref ref-type="aff" rid="gks678-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Sakakibara</surname>
          <given-names>Yasubumi</given-names>
        </name>
        <xref ref-type="aff" rid="gks678-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="gks678-COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="gks678-AFF1"><sup>1</sup>Department of Biosciences and Informatics, Keio University, 3-14-1 Hiyoshi, Kohoku-ku, Yokohama 223-8522 and <sup>2</sup>Japan Post Network Co., Ltd. 1-3-2 Kasumigaseki, Chiyoda-ku, Tokyo 100-8798, Japan</aff>
    <author-notes>
      <corresp id="gks678-COR1">*To whom correspondence should be addressed. Tel: <phone>+81 45 566 1791</phone>; Fax: <fax>+81 45 566 1791</fax>; Email: <email>yasu@bio.keio.ac.jp</email></corresp>
      <fn>
        <p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors.</p>
      </fn>
    </author-notes>
    <!--For NAR both ppub and collection dates generated for PMC processing 1/27/05 beck-->
    <pub-date pub-type="collection">
      <month>11</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <month>11</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>19</day>
      <month>7</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>19</day>
      <month>7</month>
      <year>2012</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>40</volume>
    <issue>20</issue>
    <fpage>e155</fpage>
    <lpage>e155</lpage>
    <history>
      <date date-type="received">
        <day>24</day>
        <month>1</month>
        <year>2012</year>
      </date>
      <date date-type="rev-recd">
        <day>30</day>
        <month>5</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>20</day>
        <month>6</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2012. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">http://creativecommons.org/licenses/by-nc/3.0</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>An important step in ‘metagenomics’ analysis is the assembly of multiple genomes from mixed sequence reads of multiple species in a microbial community. Most conventional pipelines use a single-genome assembler with carefully optimized parameters. A limitation of a single-genome assembler for <italic>de novo</italic> metagenome assembly is that sequences of highly abundant species are likely misidentified as repeats in a single genome, resulting in a number of small fragmented scaffolds. We extended a single-genome assembler for short reads, known as ‘Velvet’, to metagenome assembly, which we called ‘MetaVelvet’, for mixed short reads of multiple species. Our fundamental concept was to first decompose a de Bruijn graph constructed from mixed short reads into individual sub-graphs, and second, to build scaffolds based on each decomposed de Bruijn sub-graph as an isolate species genome. We made use of two features, the coverage (abundance) difference and graph connectivity, for the decomposition of the de Bruijn graph. For simulated datasets, MetaVelvet succeeded in generating significantly higher N50 scores than any single-genome assemblers. MetaVelvet also reconstructed relatively low-coverage genome sequences as scaffolds. On real datasets of human gut microbial read data, MetaVelvet produced longer scaffolds and increased the number of predicted genes.</p>
    </abstract>
    <counts>
      <page-count count="12"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>INTRODUCTION</title>
    <p>The pioneering work in metagenomics analysis was done by Venter <italic>et al.</italic> (<xref ref-type="bibr" rid="gks678-B1">1</xref>) for the Sargasso Sea environmental genome analysis. The bulk extraction of diverse microbial genomes from the environment without prior laboratory cultivation is one of the most fascinating features of metagenomics. There have been several analyses of various kinds of environmental genomes, such as (<xref ref-type="bibr" rid="gks678-B2">2</xref>). Recent progress in next-generation sequencing technology offers more opportunities for metagenome analyses and permits deep sequencing (especially the Illumina Genome Analyzer) for highly diverse microbial populations. However, while a number of metagenomes have been sequenced using next-generation sequencers and deposited into public genome databases, only a few studies have reported their assembly results (<xref ref-type="bibr" rid="gks678-B3">3</xref>,<xref ref-type="bibr" rid="gks678-B4">4</xref>). This is mainly because of the short length of sequence reads from next-generation sequencers. Furthermore, there is also a fundamental difficulty of metagenomics analysis compared with isolated genome analysis. In a microbial community, the number of strains is initially unknown, and their relative abundance is also unknown and potentially skewed (<xref ref-type="bibr" rid="gks678-B5">5</xref>).</p>
    <p>There are currently a few ‘<italic>de novo</italic>’ assemblers specifically devoted to metagenome assembly from mixed sequence reads of multiple species (<xref ref-type="bibr" rid="gks678-B6">6</xref>,<xref ref-type="bibr" rid="gks678-B7">7</xref>). In contrast, there are two alternative approaches to ‘<italic>de novo</italic>’ analysis for mixtures of sequence reads from environmental genomes: (i) applying a single-genome assembler to metagenome sequence reads (<xref ref-type="bibr" rid="gks678-B3">3</xref>,<xref ref-type="bibr" rid="gks678-B4">4</xref>,<xref ref-type="bibr" rid="gks678-B8">8</xref>,<xref ref-type="bibr" rid="gks678-B9">9</xref>) and (ii) binning (clustering) a set of sequence reads into different clusters (<xref ref-type="bibr" rid="gks678-B10">10</xref>,<xref ref-type="bibr" rid="gks678-B11">11</xref>,<xref ref-type="bibr" rid="gks678-B12">12</xref>). However, single-genome assemblers were not designed to assemble multiple genomes from a mixture of sequence reads with nonuniform sequence coverages. On the other hand, the unsupervised binning of sequence reads also has the limitation of clustering the input reads based only on <italic>k</italic>-mer frequencies in the ‘short’ reads without assembly. A third approach (not <italic>de novo</italic>) is comparative genome analysis mapping reads or aligning contigs to reference genomes (<xref ref-type="bibr" rid="gks678-B5">5</xref>,<xref ref-type="bibr" rid="gks678-B13">13</xref>,<xref ref-type="bibr" rid="gks678-B14">14</xref>). Unfortunately, the comparative approach cannot cover any microbial species whose reference genomes or closely related genomes have not been assembled.</p>
    <p>In spite of such difficulties, our primary goal was ‘to reconstruct the whole genomes of multiple species in a microbial community, particularly from very short sequence reads generated by a next-generation sequencer’. To accomplish such <italic>de novo</italic> metagenome assembly, we extended a single-genome assembly program (assembler), named ‘Velvet’, using a de Bruijn graph (<xref ref-type="bibr" rid="gks678-B15">15</xref>,<xref ref-type="bibr" rid="gks678-B16">16</xref>), to a metagenome assembly program for mixed short reads of multiple species. A de Bruijn graph is a data structure for genome assembly programs that compactly represents an overlap between short reads. The de Bruijn graph-based assembly program identifies the overlaps between reads using a de Bruijn graph and merges the reads to reconstruct longer sequences. Note that the de Bruijn graph representation was first used for sequencing by hybridization by (<xref ref-type="bibr" rid="gks678-B17">17</xref>).</p>
    <p>Our fundamental strategy for metagenome assembly was to consider that a de Bruijn graph constructed from mixed sequence reads of multiple species is equivalent to the mixture of multiple de Bruijn subgraphs, each of which is constructed from sequence reads of individual species and to decompose the mixed de Bruijn graph into individual subgraphs and build scaffolds based on each decomposed subgraph (<xref ref-type="fig" rid="gks678-F1">Figure 1</xref>).
<fig id="gks678-F1" position="float"><label>Figure 1.</label><caption><p>The MetaVelvet strategy to decompose a mixed de Bruijn graph.</p></caption><graphic xlink:href="gks678f1"/></fig></p>
    <p>From the ‘monotonic increasing’ property of de Bruijn graph construction, it is obvious that the de Bruijn graph, denoted <italic>d</italic>Bg(<italic>X</italic><sub>1</sub> + <italic>X</italic><sub>2</sub> + ··· <italic>X</italic><sub><italic>m</italic></sub>), constructed from the mixture, denoted <italic>X</italic><sub>1</sub> + <italic>X</italic><sub>2</sub> + ··· <italic>X</italic><sub><italic>m</italic></sub>, of sequence reads of multiple species contains each de Bruijn graph <italic>d</italic>Bg(<italic>X</italic><sub><italic>i</italic></sub>) constructed from sequence reads <italic>X</italic><sub><italic>i</italic></sub> of individual species (1 ≤ <italic>i</italic> ≤ <italic>m</italic>) as subgraphs. Therefore, it clearly holds that
<disp-formula><graphic xlink:href="gks678u1"/></disp-formula>
and the strategy of decomposing the de Bruijn graph is proven to be reasonable.</p>
    <p>In the decomposition step of the de Bruijn graph of multiple species, the coverage (abundance) difference and graph connectivity are used to distinguish a subgraph composed of a single species from the other subgraphs, where the ‘coverage’ is defined to be <italic>k</italic>-mer frequency in the input sequence reads. When two subgraphs, say <italic>d</italic>Bg(<italic>X</italic><sub>1</sub>) and <italic>d</italic>Bg(<italic>X</italic><sub>2</sub>), contained in the main de Bruijn graph have distinguishable read coverages, we disconnect the two subgraphs based on the coverage difference, such that metagenome assembly problem would be reduced to a set of easier problems of single-genome assemblies based on the decomposed subgraphs <italic>d</italic>Bg(<italic>X</italic><sub>1</sub>) and <italic>d</italic>Bg(<italic>X</italic><sub>2</sub>). For the graph disconnection task, an algorithm to identify shared nodes was developed, called the ‘chimeric node’, between two subgraphs <italic>d</italic>Bg(<italic>X</italic><sub>1</sub>) and <italic>d</italic>Bg(<italic>X</italic><sub>2</sub>). On the other hand, when two species are sufficiently evolutionarily distant, two genomes cannot share any <italic>k</italic>-mers, and therefore the main de Bruijn graph constructed from mixed reads of two species must be already separated and consist of two separated subgraphs.</p>
    <p>For simulated datasets, the MetaVelvet metagenome assembler succeeded in generating higher N50 scores than any comparable assemblers and produced high-quality scaffolds, as well as separate genome assemblies from isolated species sequence reads, where the N50 score is a standard statistical measure that evaluates the assembly quality and indicates the scaffold length such that 50% of the assembled sequences lie in scaffolds of this size or larger. The scaffolds with longer N50 scores especially benefit the identification of protein-coding genes. In fact, the number of predicted complete protein-coding genes from MetaVelvet scaffolds is significantly larger than that produced by any of the other assemblers. Furthermore, MetaVelvet could reconstruct relatively low-coverage genome sequences as scaffolds. On real datasets of human gut microbial short read data sequenced as part of the MetaHIT project (<xref ref-type="bibr" rid="gks678-B3">3</xref>), our MetaVelvet produced longer scaffolds, and significantly increased the number of predicted genes. The source code of MetaVelvet is freely available at <ext-link ext-link-type="uri" xlink:href="http://metavelvet.dna.bio.keio.ac.jp">http://metavelvet.dna.bio.keio.ac.jp</ext-link> under the GNU General Public License and is distributed as a bundle with ‘Velvet’.</p>
  </sec>
  <sec sec-type="materials|methods">
    <title>MATERIALS AND METHODS</title>
    <p>Information obtained from the DNA sequencer is a set of sequence fragments, called <italic>reads</italic>, rather than the entire genomic DNA sequence. Therefore, genome assembly is required to reconstruct the original genome sequence from sequence reads. Although each read is short, it is possible to reconstruct longer sequences, called <italic>contigs</italic>, by identifying an overlap between reads and merging the reads. Genome assembly is generally performed in the following steps:<list list-type="order"><list-item><p>The input is a set of the nucleotide sequences of DNA fragments.</p></list-item><list-item><p>The overlap between every pair of sequences is calculated by pairwise alignment.</p></list-item><list-item><p>A pair of sequences with significant overlap is merged to obtain a longer sequence.</p></list-item><list-item><p>The above Steps 2 and 3 are repeated.</p></list-item></list>
If a large amount of reads sufficient to ‘cover’ the genome are given to the assembly program, overlaps exist between the reads and the contigs are obtained by merging the reads. The term ‘coverage’ for a position in a contig is defined as the number of reads that overlap at that position. The ‘coverage’ of a ‘contig’ is defined to be the average of coverages for all positions in the contig.</p>
    <p>First, we briefly review the de Bruijn graph-based assembly method for single genomes and the Velvet assembler upon which our method is based. Second, we describe our extension of Velvet to metagenome assembly.</p>
    <sec>
      <title>De Bruijn graph-based assembly</title>
      <p>The previous conventional assembly method is based on the so-called ‘overlap graph’, where each read is assigned to a node and an edge connects two nodes if the corresponding reads overlap. The assembly problem is reduced to finding a path visiting every node exactly once in the overlap graph, that is, a Hamiltonian path problem. However, the Hamiltonian path problem is nondeterministic polynomial time-complete (NP-complete). Furthermore, the overlap-graph-based assembly method cannot work effectively when applied to very short reads generated from a next-generation sequencer, because there are so many short overlaps between short reads and most of these overlaps are false. Therefore, several <italic>de novo</italic> assembly methods based on de Bruijn graphs have been proposed for short reads generated from next-generation sequencers (<xref ref-type="bibr" rid="gks678-B15">15</xref>,<xref ref-type="bibr" rid="gks678-B18">18</xref>,<xref ref-type="bibr" rid="gks678-B19">19</xref>,<xref ref-type="bibr" rid="gks678-B20">20</xref>). A de Bruijn graph is a data structure that compactly represents an overlap between short reads. A notable difference between a de Bruijn graph and an overlap graph is that each <italic>k</italic>-mer (word of length <italic>k</italic>) instead of a read is assigned to a node, and thus, the size of a de Bruijn graph becomes independent of the size of the input of reads. The detailed definition of de Bruijn graph is shown below.</p>
      <p>Given a set of sequence reads, the de Bruijn graph-based assemblers first break each read according to a predefined <italic>k</italic>-mer length. It is clear that two adjacent <italic>k</italic>-mers in the read overlap at <italic>k</italic> − 1 nucleotides. Second, a directed graph (de Bruijn graph) is constructed from the given sequence reads as follows: each overlapping (<italic>k</italic> − 1)-mer is encoded into a node in the directed graph so that each <italic>k</italic>-mer is represented by a directed edge in the graph. Each <italic>k</italic>-mer is encoded into a directed edge that connects a node labeled the first (<italic>k</italic> − 1)-mer of the <italic>k</italic>-mer and a node labeled the second (<italic>k</italic> − 1)-mer. On the constructed de Bruijn graph, each read is mapped to a path traversing the graph. Therefore, the assembly (reconstruction) of the target genome from the de Bruijn graph can be reduced to finding a Eulerian path (<xref ref-type="fig" rid="gks678-F2">Figure 2</xref>).
<fig id="gks678-F2" position="float"><label>Figure 2.</label><caption><p>Illustration of de Bruijn graph-based assembly.</p></caption><graphic xlink:href="gks678f2"/></fig></p>
    </sec>
    <sec>
      <title>Brief outline of Velvet and its de Bruijn graph representation</title>
      <p>In Velvet, the de Bruijn graph is implemented slightly differently, such that each node represents a series of overlapping <italic>k</italic>-mers where adjacent <italic>k</italic>-mers overlap by <italic>k</italic> − 1 nucleotides. Each node is labeled by the sequence of the last nucleotides of the <italic>k</italic>-mers (<xref ref-type="fig" rid="gks678-F1">Figure 1</xref>). Furthermore, each node is attached to a twin node that represents the reverse series of reverse complement <italic>k</italic>-mers for reads from opposite strands.</p>
      <p>For each input read, the ordered set of overlapping <italic>k</italic>-mers is defined. Next, the ordered set is cut whenever an overlap with another read begins or ends. For each uninterrupted ordered subset of original <italic>k</italic>-mers, a node is created. Two nodes can be connected by a directed edge. If two nodes are connected, the last <italic>k</italic>-mer of an origin node overlaps by <italic>k</italic> − 1 nucleotides with the first of its destination node. New directed edges are created by tracing the read through the constructed graph.</p>
      <p>Second, Velvet executes three functions, ‘simplification’ for node merging, and ‘removing tips’ and ‘removing bubbles’ for error removal. Simplification merges two nodes where one node has only one outgoing edge and the other has only one incoming edge. A ‘tip’, which is defined as a chain of nodes disconnected on one end, is removed. A ‘bubble’, which is defined as two redundant paths that start and end at the same nodes and contain similar sequences, is merged. Those tips and bubbles are created by sequencing errors or biological variants, such as single nuleotide polymorphisms (SNPs). Then, the ‘coverage of a node’ is defined as the coverage of the contig assigned to the node.</p>
      <p>Finally, two functions, ‘Pebble’ and ‘Rock Band’, are called for constructing the scaffold and for repeat resolution using paired-end information and long read information. In these functions, Velvet distinguishes the unique nodes from the repeat nodes based on node coverage. A repeat node represents a sequence that occurs several times in the genome. Simply put, a repeat node is at a crossing point between two paths with multiple incoming and outgoing edges. Note that in multiple genome assembly, the nodes at a crossing point between two paths are not necessarily repeats. Such nodes are sometimes shared between the genomes of two closely related species and represent orthologous sequences, conserved sequences (such as rRNA sequences) and horizontal transfer sequences.</p>
    </sec>
    <sec>
      <title>Extension to metagenome assembly</title>
      <p>The MetaVelvet assembler consists of four major steps: [1] Construction of a de Bruijn graph from the input reads. [2] Detection of multiple peaks on <italic>k</italic>-mer frequency distribution. [3] Decomposition of the constructed de Bruijn graph into individual subgraphs. [4] Assembly of contigs and scaffolds based on the decomposed subgraphs. The flowchart of MetaVelvet is shown in <xref ref-type="fig" rid="gks678-F3">Figure 3</xref>.
<fig id="gks678-F3" position="float"><label>Figure 3.</label><caption><p>Flowchart of the main procedure of MetaVelvet.</p></caption><graphic xlink:href="gks678f3"/></fig></p>
      <p>In Step [1], for a given set of mixed sequence reads generated from multiple species, MetaVelvet constructs the main de Bruijn graph using Velvet functions. In Step [2], MetaVelvet calculates the histogram of <italic>k</italic>-mer frequencies and detects multiple peaks on the histogram, each of which would correspond to the genome of one species in a microbial community. The expected frequencies of <italic>k</italic>-mer occurrences were shown to follow a Poisson distribution in a single-genome assembly (<xref ref-type="bibr" rid="gks678-B21">21</xref>) and the expected <italic>k</italic>-mer frequencies in metagenome assembly were shown to follow a mixture of Poisson distributions (<xref ref-type="bibr" rid="gks678-B12">12</xref>). Hence, MetaVelvet approximates the empirical histogram of <italic>k</italic>-mer frequencies by a mixture of Poisson distributions and detects multiple peaks in the Poisson mixture. Furthermore, MetaVelvet classifies every node into one peak of the Poisson mixture. In Step [3], MetaVelvet distinguishes a subgraph composed of nodes belonging to a same peak from the other subgraphs in the main de Bruijn graph. MetaVelvet identifies shared nodes (chimeric nodes) between two subgraphs and disconnects two subgraphs by separating the shared nodes. In step [4], MetaVelvet builds contigs and scaffolds based on the decomposed subgraphs using Velvet functions.</p>
      <p>The essential part of Step [3] is to design and develop an algorithm to identify and separate ‘chimeric nodes’ in the main de Bruijn graph. If two species contain a common or similar subsequence in their genomes, the main de Bruijn graph contains a node assigned to the subsequence with two incoming edges and two outgoing edges, one of which comes from one species and the other comes from the other species. On the other hand, if the genome of one species contains a repeat subsequence (that is, a subsequence with multiple occurrences in the genome), the de Bruijn graph also contains a node assigned to the repeat subsequence with two incoming edges and two outgoing edges. All other nodes in the main de Bruijn graph must have only one incoming edge and one outgoing edge. To distinguish the chimeric node from the repeat node, the method uses coverage difference. Although the origin nodes of two incoming edges for the repeat node have the same <italic>k</italic>-mer frequencies, the origin nodes of two incoming edges for the chimeric node belong to two different species and hence have different <italic>k</italic>-mer frequencies. The formal definition of ‘chimeric node’ is given as a crossing node satisfying the following three conditions: (i) (necessary condition) the number of incoming edges is 2 and the number of outgoing edges is 2; (ii) (sufficient condition) the origin nodes of two incoming edges (<italic>a</italic> and <italic>b</italic>) belong to two different peaks and the destination nodes of outgoing edges (<italic>c</italic> and <italic>d</italic>) also belong to the same two peaks as the origin nodes and (iii) (sufficient condition) the chimeric node has a confluent node coverage of the two origin nodes. More precisely, the node coverage of the candidate chimeric node should be between (<italic>a</italic>.cov + <italic>b</italic>.cov + <italic>c</italic>.cov + <italic>d</italic>.cov)/2 × (1 − <italic>y</italic>) and (<italic>a</italic>.cov + <italic>b</italic>.cov + <italic>c</italic>.cov + <italic>d</italic>.cov)/2 × (1 + <italic>y</italic>), where <italic>a</italic>.cov represents the node coverage of a node <italic>a</italic> and <italic>y</italic> is a parameter in MetaVelvet called ‘allowable coverage difference’. An example of the determination of a chimeric node is given in <xref ref-type="fig" rid="gks678-F4">Figure 4</xref>.
<fig id="gks678-F4" position="float"><label>Figure 4.</label><caption><p>An example of a chimeric node and its resolution by separating the node. The node is chimeric because [(28.5 + 59.6) + (31.3 + 62.7)]/2 ≃ 90.8.</p></caption><graphic xlink:href="gks678f4"/></fig></p>
      <p>Once a candidate for chimeric node is identified, the candidate node is checked for ‘consistency’ with paired-end information. If a significant amount of paired-end reads connect an origin node of an incoming edge of the chimeric node with a destination node labeled differently from the origin node (that is, the paired-end reads connect an origin node labeled ON and a destination node labeled OFF or vice versa, as shown in <xref ref-type="fig" rid="gks678-F4">Figure 4</xref>), the candidate node is discarded.</p>
      <p>The detailed procedure of MetaVelvet is as follows:<list list-type="simple"><list-item><label>[1]</label><p>Construction of the de Bruijn graph:<list list-type="simple"><list-item><label>1.</label><p>For a given set of sequence reads generated from mixed species, construct a de Bruijn graph by calling Velvet first stage functions.</p></list-item></list></p></list-item><list-item><label>[2]</label><p>Detection of multiple peaks on k-mer frequencies:<list list-type="simple"><list-item><label>2.</label><p>Calculate the empirical distribution of ‘length-weighted frequencies’ of node coverages, where a node coverage is assigned to each node by Velvet on the construction of the de Bruijn graph (<xref ref-type="fig" rid="gks678-F5">Figure 5</xref>).</p></list-item><list-item><label>3.</label><p>Approximate the empirical distribution by a mixture of Poisson distributions and detect multiple peaks in the Poisson mixture. Then, the highest peak of expected coverage is chosen as the ‘primary expected coverage’, and the next highest is chosen as the ‘secondary expected coverage’.</p></list-item><list-item><label>4.</label><p>Classify every node into one distribution of the Poisson mixture by calculating its posterior probability for the node coverage value.</p></list-item></list></p></list-item><list-item><label>[3]</label><p>Decomposition of the de Bruijn graph:<list list-type="simple"><list-item><label>5.</label><p>(Decomposition by connectivity) Decompose the initial de Bruijn graph into connected subgraphs.</p></list-item><list-item><label>6.</label><p>(Decomposition by coverage value) If the coverage of a node belongs to the primary expected coverage, the node is classified as a ‘primary node’. Subsequently, the primary nodes are labeled as ‘ON’ and the other nodes are labeled as ‘OFF’. Then, a chimeric node is detected as having two incoming edges whose origin nodes are labeled ON and OFF, and two outgoing edges whose destination nodes are labeled ON and OFF, and having a coverage value mostly equal (within 5% difference by default) to the average between the sum of the coverage values of the two origin nodes and the sum of the two destination nodes. Second, check the consistency of the ON and OFF labeling for the two origin nodes and two destination nodes using paired-end information. If the consistency is satisfied, resolve every chimeric node by separating the node into two nodes with only one incoming edge and one outgoing edge, whose origin and destination nodes have the same label, as shown in <xref ref-type="fig" rid="gks678-F4">Figure 4</xref>. After separating the chimeric nodes, further decompose the resulting graph into connected subgraphs.</p></list-item><list-item><label>7.</label><p>If a connected subgraph consists of more than <italic>x</italic>% (a predefined parameter, the default is set to 100%) of nodes labeled ‘ON’, the subgraph is unmasked. All other subgraphs are masked.</p></list-item></list></p></list-item><list-item><label>[4]</label><p>Assembly of contigs and scaffolds:<list list-type="simple"><list-item><label>8.</label><p>Apply the Velvet functions to the unmasked subgraphs to build contigs and then apply Pebble and Rock Band functions to build scaffolds.</p></list-item><list-item><label>9.</label><p>Remove the unmasked subgraphs and recursively apply Step 2–8 to the remaining de Bruijn graph until no node remains.</p></list-item></list></p></list-item></list>
It might be thought that in Substep 3 above, a chimeric node could have the highest expected coverage. However, the contigs of chimeric nodes are very short compared with the unique nodes; therefore, the length-weighted frequencies of coverage values for the chimeric nodes do not form any significant peaks.
<fig id="gks678-F5" position="float"><label>Figure 5.</label><caption><p>Detection of multiple peaks in the histogram of coverage values of the nodes.</p></caption><graphic xlink:href="gks678f5"/></fig></p>
    </sec>
  </sec>
  <sec>
    <title>EXPERIMENTAL RESULTS</title>
    <p>The performance of the MetaVelvet assembler was tested on simulated datasets and on real metagenome datasets obtained from human gut microbiome. The method was compared with the naive use of two single-genome assemblers, Velvet (<xref ref-type="bibr" rid="gks678-B15">15</xref>) and SOAPdenovo (<xref ref-type="bibr" rid="gks678-B22">22</xref>), and the recently proposed metagenome assembler Meta-IDBA (<xref ref-type="bibr" rid="gks678-B6">6</xref>). Furthermore, for the simulated datasets, we compared our results with those of a single-genome assembly from pure sequence reads of each single-isolate genome. We compared the following standard statistical measures to evaluate the performance of the assemblers for short read assembly and metagenome assembly: the number of scaffolds, the total length of scaffolds and N50, where N50 indicates the scaffold length such that 50% of the <italic>de novo</italic> assembled sequences lie in scaffolds of this size or larger. The precise definition of N50 is as follows. Let |A| denote the length of a sequence (contig, scaffold or genome) A. Let <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>, … , <italic>S</italic><sub><italic>n</italic></sub> denote the list of scaffolds in descending order of length as output by an assembler. Let <italic>L</italic> denote the total length of all scaffolds, that is, <inline-formula><inline-graphic xlink:href="gks678i1.jpg"/></inline-formula>. Then, N50 is defined by the following equation:
<disp-formula id="gks678-M1"><label>(1)</label><graphic xlink:href="gks678m1"/></disp-formula>
Furthermore, from the assembled scaffolds, protein-coding genes (that is, open reading frames (ORFs)) were predicted using the MetaGene (<xref ref-type="bibr" rid="gks678-B23">23</xref>) software, and the number of predicted genes was compared.</p>
    <p>For the simulated datasets, the following genome cover rate was calculated per species: the ‘cover rate’ of genome A is defined by the ratio of the sum of all scaffold lengths that are best aligned to genome A divided by the length of genome A. More precisely, the cover rate is defined by the following equation:
<disp-formula><graphic xlink:href="gks678u2"/></disp-formula>
Furthermore, we counted the total length of chimeric scaffolds. We determined whether a scaffold was chimeric by the following procedure. First, we calculated the best hit alignments between a scaffold and the set of input reference genomes using BLAST. Second, if a scaffold has more than two subsequences that are aligned to different genomes, and those subsequences are longer than 1% of the scaffold length, the scaffold was determined as chimeric.</p>
    <sec>
      <title>Performances on simulated datasets</title>
      <p>We used the ‘DWGSIM package’ in the DNAA package (available at <ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/dnaa/">http://sourceforge.net/projects/dnaa/</ext-link>) to artificially generate metagenome sequence reads. The read length was set at 80 bp, ‘very short’. The average and standard deviation of insert size for paired-end reads were set at 500 and 50 bp, respectively. Sequencing error rate was set at 1%. For species abundance settings, we applied the ‘log-normal distribution’, because the log-normal distribution has been generally used to model microbial abundance distributions (<xref ref-type="bibr" rid="gks678-B24">24</xref>). Thus, the simulated metagenomic datasets were generated to yield a <italic>k</italic>-mer coverage histogram following log-normal distribution.</p>
      <p>To test the performances on various taxonomic levels of diversity, we constructed four datasets with different taxonomic levels of diversity, that is, ‘order level’, ‘family level’, ‘genus level’, and ‘species level’. In general, at lower taxonomic levels, the genomes of two different species become more similar and share more <italic>k</italic>-mer subsequences. Therefore, the separation of the input sequence reads and the decomposition of the de Bruijn graph become harder and the metagenome assembly problem from mixed sequence reads of multiple species becomes harder at lower taxonomic levels. We selected the four datasets to range from distant taxonomic level (that is, order level) to closer taxonomic level (species level). For each dataset, 20 species genomes were selected, and short read datasets were generated from the 20 genomes. (The lists of the 20 selected genomes for each taxonomic level are provided in Supplementary Tables S1–S4.)</p>
      <p>Artificially generated short reads were assembled by two short read single-genome assemblers, Velvet (<xref ref-type="bibr" rid="gks678-B15">15</xref>) and SOAPdenovo (<xref ref-type="bibr" rid="gks678-B22">22</xref>), and two metagenome assemblers, Meta-IDBA (<xref ref-type="bibr" rid="gks678-B6">6</xref>), MetaVelvet, with default parameters except for SOAPdenovo, which used the ‘-M 3’ option, a parameter considered suitable for metagenomics assembly (<xref ref-type="bibr" rid="gks678-B3">3</xref>). The versions of these software packages used were Velvet 1.1.06, SOAPdenovo 1.05, Meta-IDBA 0.19 and MetaVelvet 1.3.1. Since Meta-IDBA does not have the scaffolding function, contigs instead of scaffolds were used to evaluate Meta-IDBA.</p>
      <sec>
        <title>Order-level metagenomic dataset</title>
        <p>Six orders from the ‘Alphaproteobacteria’ class and 14 orders from the ‘Gammaproteobacteria’ class were selected. Short read datasets were generated from the selected reference genomes belonging to the 20 orders, including <italic>Escherichia coli</italic>, <italic>Vibrio cholerae</italic> and <italic>Pseudomonas putida</italic>.</p>
      </sec>
      <sec>
        <title>Family-level metagenomic dataset</title>
        <p>Nine families from the Rhizobiales order, seven families from the Alteromonadales order and four families from the Bacillales order were selected. Short read datasets were generated from the selected reference genomes belonging to the 20 families including <italic>Bacillus subtilis</italic> and <italic>Listeria monocytogenes</italic>.</p>
      </sec>
      <sec>
        <title>Genus-level metagenomic dataset</title>
        <p>Twenty genera from the Enterobacteriaceae family were selected. Short read datasets were generated from the selected reference genomes belonging the 20 genera including <italic>E. coli</italic>, <italic>Salmonella bongori</italic> and <italic>Yersinia pestis</italic>.</p>
      </sec>
      <sec>
        <title>Species-level metagenomic dataset</title>
        <p>Eighteen species from the <italic>Bacillus</italic> genus and two species from the <italic>Bacillales</italic> genus were selected. Short read datasets were generated from the selected reference genomes belonging to the 20 species including <italic>Bacillus subtilis</italic>, <italic>Bacillus cereus</italic> and <italic>Bacillus anthracis</italic>.</p>
      </sec>
      <sec>
        <title>Experimental results</title>
        <p>Statistics of the assembly results are summarized in <xref ref-type="table" rid="gks678-T1">Table 1</xref>. Scaffolds of lengths &lt; 1000 bp were discarded. The percentage of chimeric scaffold length is shown compared with the total scaffold length. Every individual single genome was assembled by Velvet from each single species dataset, and those results are shown as ‘Separate assembly’ in <xref ref-type="table" rid="gks678-T1">Table 1</xref>.
<table-wrap id="gks678-T1" position="float"><label>Table 1.</label><caption><p>Performance comparison of assembly software packages</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Metagenome dataset</th><th rowspan="1" colspan="1">Separate assembly</th><th colspan="4" align="center" rowspan="1">MetaGenomic assembly<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">Velvet</th><th rowspan="1" colspan="1">MetaVelvet</th><th rowspan="1" colspan="1">Velvet</th><th rowspan="1" colspan="1">SOAPdenovo</th><th rowspan="1" colspan="1">Meta-IDBA</th></tr></thead><tbody align="left"><tr><td colspan="6" align="left" rowspan="1">Order level (total genome size = 71 929 175 bp; 93 423 332 reads)</td></tr><tr><td rowspan="1" colspan="1">Num. scaffolds</td><td rowspan="1" colspan="1">685</td><td rowspan="1" colspan="1">813</td><td rowspan="1" colspan="1">924</td><td rowspan="1" colspan="1">5 998</td><td rowspan="1" colspan="1">2 678</td></tr><tr><td rowspan="1" colspan="1">Total scaffold length</td><td rowspan="1" colspan="1">71 009 045</td><td rowspan="1" colspan="1">71 053 228</td><td rowspan="1" colspan="1">48 450 203</td><td rowspan="1" colspan="1">70 296 665</td><td rowspan="1" colspan="1">70 312 381</td></tr><tr><td rowspan="1" colspan="1">N50 size (bp)</td><td rowspan="1" colspan="1">288 838</td><td rowspan="1" colspan="1">268 350</td><td rowspan="1" colspan="1">142 471</td><td rowspan="1" colspan="1">43 796</td><td rowspan="1" colspan="1">55 575</td></tr><tr><td rowspan="1" colspan="1">Chimeric scaffold length (%)</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.46</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.00</td></tr><tr><td rowspan="1" colspan="1">Cover rate (%)</td><td rowspan="1" colspan="1">98.38</td><td rowspan="1" colspan="1">98.25</td><td rowspan="1" colspan="1">67.48</td><td rowspan="1" colspan="1">95.67</td><td rowspan="1" colspan="1">96.98</td></tr><tr><td rowspan="1" colspan="1">Number of predicted genes</td><td rowspan="1" colspan="1">66 268</td><td rowspan="1" colspan="1">66 241</td><td rowspan="1" colspan="1">43 729</td><td rowspan="1" colspan="1">60 319</td><td rowspan="1" colspan="1">62 833</td></tr><tr><td rowspan="1" colspan="1">Required CPU time (s)</td><td rowspan="1" colspan="1">4 994</td><td rowspan="1" colspan="1">8 685</td><td rowspan="1" colspan="1">7 076</td><td rowspan="1" colspan="1">11 564</td><td rowspan="1" colspan="1">7 375</td></tr><tr><td rowspan="1" colspan="1">Required memory (GB)</td><td rowspan="1" colspan="1">7.04</td><td rowspan="1" colspan="1">56.61</td><td rowspan="1" colspan="1">54.07</td><td rowspan="1" colspan="1">62.42</td><td rowspan="1" colspan="1">15.15</td></tr><tr><td colspan="6" align="left" rowspan="1">Family level (total genome size = 84 552 832 bp; 113 680 114 reads)</td></tr><tr><td rowspan="1" colspan="1">Num. scaffolds</td><td rowspan="1" colspan="1">784</td><td rowspan="1" colspan="1">1 019</td><td rowspan="1" colspan="1">2 889</td><td rowspan="1" colspan="1">9 039</td><td rowspan="1" colspan="1">4 421</td></tr><tr><td rowspan="1" colspan="1">Total scaffold length</td><td rowspan="1" colspan="1">83 275 357</td><td rowspan="1" colspan="1">83 322 440</td><td rowspan="1" colspan="1">65 789 192</td><td rowspan="1" colspan="1">81 739 588</td><td rowspan="1" colspan="1">81 990 799</td></tr><tr><td rowspan="1" colspan="1">N50 size (bp)</td><td rowspan="1" colspan="1">313 454</td><td rowspan="1" colspan="1">257 853</td><td rowspan="1" colspan="1">76 239</td><td rowspan="1" colspan="1">27 510</td><td rowspan="1" colspan="1">39 961</td></tr><tr><td rowspan="1" colspan="1">Chimeric scaffold length (%)</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.45</td><td rowspan="1" colspan="1">0.02</td><td rowspan="1" colspan="1">0.03</td><td rowspan="1" colspan="1">0.00</td></tr><tr><td rowspan="1" colspan="1">Cover rate (%)</td><td rowspan="1" colspan="1">98.12</td><td rowspan="1" colspan="1">97.81</td><td rowspan="1" colspan="1">77.60</td><td rowspan="1" colspan="1">94.09</td><td rowspan="1" colspan="1">96.03</td></tr><tr><td rowspan="1" colspan="1">Number of predicted genes</td><td rowspan="1" colspan="1">77 634</td><td rowspan="1" colspan="1">77 655</td><td rowspan="1" colspan="1">58 744</td><td rowspan="1" colspan="1">68 832</td><td rowspan="1" colspan="1">72 746</td></tr><tr><td rowspan="1" colspan="1">Required CPU time (s)</td><td rowspan="1" colspan="1">9585</td><td rowspan="1" colspan="1">11 409</td><td rowspan="1" colspan="1">9 813</td><td rowspan="1" colspan="1">14 803</td><td rowspan="1" colspan="1">12 664</td></tr><tr><td rowspan="1" colspan="1">Required memory (GB)</td><td rowspan="1" colspan="1">13.15</td><td rowspan="1" colspan="1">72.06</td><td rowspan="1" colspan="1">68.98</td><td rowspan="1" colspan="1">62.48</td><td rowspan="1" colspan="1">23.11</td></tr><tr><td colspan="6" align="left" rowspan="1">Genus level (total genome size = 88 595 850 bp; 103 990 387 reads)</td></tr><tr><td rowspan="1" colspan="1">Num. scaffolds</td><td rowspan="1" colspan="1">1288</td><td rowspan="1" colspan="1">2 325</td><td rowspan="1" colspan="1">3 633</td><td rowspan="1" colspan="1">10 282</td><td rowspan="1" colspan="1">10 643</td></tr><tr><td rowspan="1" colspan="1">Total scaffold length</td><td rowspan="1" colspan="1">86 489 808</td><td rowspan="1" colspan="1">84 342 495</td><td rowspan="1" colspan="1">53 450 902</td><td rowspan="1" colspan="1">79 334 848</td><td rowspan="1" colspan="1">74 808 521</td></tr><tr><td rowspan="1" colspan="1">N50 size (bp)</td><td rowspan="1" colspan="1">279 359</td><td rowspan="1" colspan="1">239 061</td><td rowspan="1" colspan="1">74 182</td><td rowspan="1" colspan="1">16 194</td><td rowspan="1" colspan="1">12 773</td></tr><tr><td rowspan="1" colspan="1">Chimeric scaffold length (%)</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">1.56</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.08</td><td rowspan="1" colspan="1">0.00</td></tr><tr><td rowspan="1" colspan="1">Cover rate (%)</td><td rowspan="1" colspan="1">98.17</td><td rowspan="1" colspan="1">97.13</td><td rowspan="1" colspan="1">73.31</td><td rowspan="1" colspan="1">91.73</td><td rowspan="1" colspan="1">90.93</td></tr><tr><td rowspan="1" colspan="1">Number of predicted genes</td><td rowspan="1" colspan="1">80 812</td><td rowspan="1" colspan="1">79 301</td><td rowspan="1" colspan="1">46 688</td><td rowspan="1" colspan="1">67 267</td><td rowspan="1" colspan="1">61 135</td></tr><tr><td rowspan="1" colspan="1">Required CPU time (s)</td><td rowspan="1" colspan="1">7275</td><td rowspan="1" colspan="1">10 395</td><td rowspan="1" colspan="1">8 712</td><td rowspan="1" colspan="1">12 889</td><td rowspan="1" colspan="1">15 071</td></tr><tr><td rowspan="1" colspan="1">Required memory (GB)</td><td rowspan="1" colspan="1">11.12</td><td rowspan="1" colspan="1">63.22</td><td rowspan="1" colspan="1">60.43</td><td rowspan="1" colspan="1">62.45</td><td rowspan="1" colspan="1">16.75</td></tr><tr><td colspan="6" align="left" rowspan="1">Species level (total genome size = 85 450 435 bp; 98 817 303 reads)</td></tr><tr><td rowspan="1" colspan="1">Num. scaffolds</td><td rowspan="1" colspan="1">818</td><td rowspan="1" colspan="1">3 447</td><td rowspan="1" colspan="1">2 403</td><td rowspan="1" colspan="1">9 317</td><td rowspan="1" colspan="1">6 657</td></tr><tr><td rowspan="1" colspan="1">Total scaffold length</td><td rowspan="1" colspan="1">83 865 679</td><td rowspan="1" colspan="1">80 628 784</td><td rowspan="1" colspan="1">40 619 181</td><td rowspan="1" colspan="1">70 762 160</td><td rowspan="1" colspan="1">64 880 992</td></tr><tr><td rowspan="1" colspan="1">N50 size (bp)</td><td rowspan="1" colspan="1">339 109</td><td rowspan="1" colspan="1">152 531</td><td rowspan="1" colspan="1">100 819</td><td rowspan="1" colspan="1">14 471</td><td rowspan="1" colspan="1">26 571</td></tr><tr><td rowspan="1" colspan="1">Chimeric scaffold length (%)</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.93</td><td rowspan="1" colspan="1">0.00</td><td rowspan="1" colspan="1">0.01</td><td rowspan="1" colspan="1">0.00</td></tr><tr><td rowspan="1" colspan="1">Cover rate (%)</td><td rowspan="1" colspan="1">97.79</td><td rowspan="1" colspan="1">94.56</td><td rowspan="1" colspan="1">60.29</td><td rowspan="1" colspan="1">84.62</td><td rowspan="1" colspan="1">82.50</td></tr><tr><td rowspan="1" colspan="1">Number of predicted genes</td><td rowspan="1" colspan="1">83 952</td><td rowspan="1" colspan="1">81 842</td><td rowspan="1" colspan="1">38 445</td><td rowspan="1" colspan="1">65 176</td><td rowspan="1" colspan="1">58 367</td></tr><tr><td rowspan="1" colspan="1">Required CPU time (s)</td><td rowspan="1" colspan="1">7618</td><td rowspan="1" colspan="1">12 001</td><td rowspan="1" colspan="1">8 775</td><td rowspan="1" colspan="1">12 858</td><td rowspan="1" colspan="1">20 755</td></tr><tr><td rowspan="1" colspan="1">Required memory (GB)</td><td rowspan="1" colspan="1">7.68</td><td rowspan="1" colspan="1">64.06</td><td rowspan="1" colspan="1">61.23</td><td rowspan="1" colspan="1">62.46</td><td rowspan="1" colspan="1">17.32</td></tr></tbody></table><table-wrap-foot><fn><p>All computations were executed with Intel(R) Xeon(R) E5540 processors (2.53 GHz), with 48 GB physical memory, except for a few cases. The figures in ‘separate assembly’ show the results of single-genome assembly from pure sequence reads of each single-isolate genome, which were not available in real-data analysis. MetaVelvet, Velvet and SOAPdenovo were run with default parameters, except for setting <italic>k</italic>-mer size at 51. Meta-IDBA was run with default parameters, except for setting the maximum <italic>k</italic>-mer size at 50.</p></fn></table-wrap-foot></table-wrap></p>
        <p><xref ref-type="fig" rid="gks678-F6">Figure 6</xref> shows that MetaVelvet assembled the metagenomic read data with significantly longer N50 sizes than the other assemblers, and MetaVelvet achieved almost the same N50 sizes as the separate assemblies at the order, family and genus levels.
<fig id="gks678-F6" position="float"><label>Figure 6.</label><caption><p>Experimental results on four simulated datasets. N50 scores of scaffolds for each assembler are shown.</p></caption><graphic xlink:href="gks678f6"/></fig></p>
        <p><xref ref-type="fig" rid="gks678-F7">Figure 7</xref> shows that the cover rates of all assemblers were decreased at the lower taxonomic levels. This is because the genomes of different species became more similar and share more <italic>k</italic>-mer subsequences, and hence the metagenome assembly became harder, at lower taxonomic levels. Nevertheless, MetaVelvet achieved the highest cover rates at every taxonomic level among all the assemblers. This is because MetaVelvet succeeded in covering even the genomes of low-coverage species by detecting multiple peaks on coverages and assembling scaffolds step by step at each coverage, while Velvet tended to miss low-coverage sequences. The other assemblers missed middle or low-coverage sequences, as shown in <xref ref-type="fig" rid="gks678-F8">Figure 8</xref>.
<fig id="gks678-F7" position="float"><label>Figure 7.</label><caption><p>Cover rates for every taxonomic level are shown. The cover rate for each taxonomic level is the average of the cover rates for the 20 genomes in the taxonomic level.</p></caption><graphic xlink:href="gks678f7"/></fig>
<fig id="gks678-F8" position="float"><label>Figure 8.</label><caption><p>Detailed analysis of cover rates for 20 genomes in the genus level. Cover rates for each genome are listed in the order of species abundance.</p></caption><graphic xlink:href="gks678f8"/></fig></p>
        <p><xref ref-type="fig" rid="gks678-F8">Figure 8</xref> shows the cover rates for 20 genomes with different abundances at the genus level. MetaVelvet achieved uniformly higher cover rates on all abundances. On the other hand, Velvet completely failed to reconstruct low-abundance species, and SOAPdenovo and Meta-IDBA showed low cover rates for certain species.</p>
        <p>To verify that the MetaVelvet algorithm for identifying and separating the chimeric node actually works on a metagenome assembly, we concretely analyzed one of our experiments using the genus-level metagenomic dataset. On this dataset, MetaVelvet first detected nine peaks, that is, peaks 54, 41, 37, 21, 18, 16, 14, 12 and 6, in the node coverage distribution. Second, MetaVelvet identified 770 nodes as chimeric and separated them; 750 of those identified nodes were truly chimeric and the rest were incorrect. Two examples of chimeric nodes correctly identified by MetaVelvet are shown in <xref ref-type="fig" rid="gks678-F9">Figure 9</xref>. The first example node was shared between the most dominant species of node coverage 54 and the third dominant species of node coverage 37. In contrast, an incorrect node misidentified by MetaVelvet is shown in the right example of <xref ref-type="fig" rid="gks678-F9">Figure 9</xref>. This node was actually a repeat node. This misidentification of the chimeric node resulted from the statistical variance of <italic>k</italic>-mer frequencies that caused misassignment of peaks to the nodes. In conclusion, MetaVelvet produced longer N50 scores by successfully identifying and separating chimeric nodes.
<fig id="gks678-F9" position="float"><label>Figure 9.</label><caption><p>(<bold>A</bold> and <bold>B</bold>) Two examples of chimeric nodes correctly identified by MetaVelvet. (<bold>C</bold>) Example of a repeat node misidentified by MetaVelvet as chimeric.</p></caption><graphic xlink:href="gks678f9"/></fig></p>
        <p>The percentages of chimeric scaffolds of all assemblers were very small (at most 1.56%). MetaVelvet showed slightly higher chimera rates compared with SOAPdenovo and Meta-IDBA. These higher chimeric rates can be considered as a tradeoff against the longer scaffold sizes.</p>
        <p>The longer N50 scores of the scaffolds particularly benefit the identification of protein-coding genes. <xref ref-type="fig" rid="gks678-F10">Figure 10</xref> clearly demonstrates this advantage: the number of predicted complete protein-coding genes from MetaVelvet scaffolds is significantly larger than any of the other assemblers at all taxonomic levels, where a complete protein-coding gene (complete ORF) denotes a gene (ORF) for which both of the 5′- and 3′-ends are included in a scaffold, and a partial genes (partial ORF) denotes a gene (ORF) whose 5′- and/or 3′-end is not included in a scaffold. In particular, the number of predicted genes from MetaVelvet scaffolds is more than twice that from Velvet scaffolds at the species level and is almost same as that from the separate assembly.
<fig id="gks678-F10" position="float"><label>Figure 10.</label><caption><p>The number of predicted complete protein-coding genes from scaffolds for each assembler.</p></caption><graphic xlink:href="gks678f10"/></fig></p>
        <p>In conclusion, the improvements gained by the MetaVelvet method strongly suggest that single-genome assemblers are not appropriate for metagenomic short read data. The MetaVelvet assembler can assemble metagenomic short read data with longer N50 sizes and can reconstruct scaffold sequences, even for low-abundance species.</p>
      </sec>
    </sec>
    <sec>
      <title>Metagenomics analysis of human gut microbial data</title>
      <p>To assess the assembly accuracy of the MetaVelvet assembler on real metagenomic datasets, we assembled three human gut microbial datasets, which were sequenced as a part of the MetaHIT project (<xref ref-type="bibr" rid="gks678-B3">3</xref>). Qin <italic>et al.</italic> (<xref ref-type="bibr" rid="gks678-B3">3</xref>) performed deep sequencing of fecal DNA samples obtained from 124 European adults. Assembly of the 124 human gut metagenomic datasets established a human gut microbial gene catalog. The work of Qin <italic>et al.</italic> (<xref ref-type="bibr" rid="gks678-B3">3</xref>) is an important milestone, which showed the potential effectiveness of metagenomic assembly of short reads. Here, human gut metagenomic datasets from three adults were selected (sample IDs are MH0006, MH0012 and MH0047) from the MetaHIT project and used to validate whether the MetaVelvet assembler could increase the number of protein-coding genes compared with a single-genome assembler, Velvet. Two datasets (MH0006 and MH0012) were the deepest and second-deepest datasets; the other dataset (MH0047) is one of the low-coverage datasets. The three metagenomic datasets were downloaded from the NCBI Sequence Read Archive (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/sra">http://www.ncbi.nlm.nih.gov/sra</ext-link>; ERR011101–ERR011104 for the MH0006 dataset; ERR011117–ERR011123 for the MH0012 dataset; ERR011192–ERR011193 for the MH0047 dataset).</p>
      <p>MetaVelvet was applied to the three datasets with a <italic>k</italic>-mer size set at 51. <xref ref-type="fig" rid="gks678-F11">Figure 11</xref> is the histogram of node coverages in the de Bruijn graph constructed from the MH0047 dataset, which clearly shows that multiple peaks were also observed in a real metagenomic dataset. Multiple peaks were observed in the MH0006 and MH0012 datasets (Supplementary Figures S1 and S2).
<fig id="gks678-F11" position="float"><label>Figure 11.</label><caption><p>Detection of multiple peaks on the node coverage histogram from the MH0047 human gut microbial dataset.</p></caption><graphic xlink:href="gks678f11"/></fig></p>
      <p>The assembly statistics of the three metagenomic datasets are summarized in <xref ref-type="table" rid="gks678-T2">Table 2</xref>. For comparison, Velvet was also applied to the three datasets with the <italic>k</italic>-mer size set at 51. MetaVelvet yielded significantly longer total scaffold lengths compared with Velvet. For the MH0006 dataset, MetaVelvet showed a 25% increase in total scaffold length, a 44% increase for MH0012 and a 51% increase for MH0047. From the scaffolds, the protein-coding genes were predicted using the MetaGene (<xref ref-type="bibr" rid="gks678-B23">23</xref>) software. 421 448 and 284 552 genes were predicted from MH0006 scaffolds assembled by MetaVelvet and Velvet, respectively, showing that MetaVelvet increased the number of predicted genes by 48.1%. Similarly, MetaVelvet increased the number of predicted genes by 106.5% for the MH0012 dataset and by 129.5% for the MH0047 dataset. More importantly, 90 617 and 84 811 complete genes were predicted from MH0006 scaffolds assembled by MetaVelvet and Velvet, respectively. This result showed that MetaVelvet increased the number of complete genes by 6.9% compared with a single-genome assembler Velvet. Similarly, MetaVelvet increased the number of complete genes by 10.1% for the MH0012 dataset and by 22.8% for the MH0047 dataset. These results evidently demonstrated that MetaVelvet substantially increased both the number of predicted genes and the number of complete genes.
<table-wrap id="gks678-T2" position="float"><label>Table 2.</label><caption><p>Assembly and gene prediction statistics for human gut microbial metagenomic datasets</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th colspan="2" align="center" rowspan="1">MH0006<hr/></th><th colspan="2" align="center" rowspan="1">MH0012<hr/></th><th colspan="2" align="center" rowspan="1">MH0047<hr/></th></tr><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">MetaVelvet</th><th rowspan="1" colspan="1">Velvet</th><th rowspan="1" colspan="1">MetaVelvet</th><th rowspan="1" colspan="1">Velvet</th><th rowspan="1" colspan="1">MetaVelvet</th><th rowspan="1" colspan="1">Velvet</th></tr></thead><tbody align="left"><tr><td align="left" colspan="7" rowspan="1">Scaffolds</td></tr><tr><td rowspan="1" colspan="1">    Num. scaffolds</td><td rowspan="1" colspan="1">293 805</td><td rowspan="1" colspan="1">174 794</td><td rowspan="1" colspan="1">368 879</td><td rowspan="1" colspan="1">125 387</td><td rowspan="1" colspan="1">69 380</td><td rowspan="1" colspan="1">21 833</td></tr><tr><td rowspan="1" colspan="1">    Total scaffold length (bp)</td><td rowspan="1" colspan="1">176534 240</td><td rowspan="1" colspan="1">141 464 165</td><td rowspan="1" colspan="1">239 717742</td><td rowspan="1" colspan="1">166 824 609</td><td rowspan="1" colspan="1">39 488 884</td><td rowspan="1" colspan="1">26 190 998</td></tr><tr><td rowspan="1" colspan="1">    AUC of N-len(<italic>x</italic>)</td><td rowspan="1" colspan="1">1 740 532</td><td rowspan="1" colspan="1">764 099</td><td rowspan="1" colspan="1">5 049 858</td><td rowspan="1" colspan="1">1 897 179</td><td rowspan="1" colspan="1">280 526</td><td rowspan="1" colspan="1">181 960</td></tr><tr><td rowspan="1" colspan="1">    AUC<sub>min</sub> of N-len(<italic>x</italic>)</td><td rowspan="1" colspan="1">1 732 914</td><td rowspan="1" colspan="1">764 099</td><td rowspan="1" colspan="1">5 027 177</td><td rowspan="1" colspan="1">1 897 179</td><td rowspan="1" colspan="1">277 057</td><td rowspan="1" colspan="1">181 960</td></tr><tr><td align="left" colspan="7" rowspan="1">Protein-coding genes</td></tr><tr><td rowspan="1" colspan="1">    Num. genes</td><td rowspan="1" colspan="1">421 448</td><td rowspan="1" colspan="1">284 552</td><td rowspan="1" colspan="1">531 824</td><td rowspan="1" colspan="1">257 502</td><td rowspan="1" colspan="1">92 411</td><td rowspan="1" colspan="1">40 267</td></tr><tr><td rowspan="1" colspan="1">    Num. complete genes</td><td rowspan="1" colspan="1">90 617</td><td rowspan="1" colspan="1">84 811</td><td rowspan="1" colspan="1">129 670</td><td rowspan="1" colspan="1">117 792</td><td rowspan="1" colspan="1">18 032</td><td rowspan="1" colspan="1">14 680</td></tr></tbody></table><table-wrap-foot><fn><p>AUC of N-len(<italic>x</italic>) denotes the area under the curve of the generalized score N-len(<italic>x</italic>), which is defined by Eq. (<xref ref-type="disp-formula" rid="gks678-M2">2</xref>), for 0 &lt; <italic>x</italic> ≤ <italic>L</italic>. AUC<sub>min</sub> of N-len(<italic>x</italic>) denotes the area under the curve of N-len(<italic>x</italic>) for 0 &lt; <italic>x</italic> ≤ min{<italic>L</italic>, <italic>L</italic>′}.</p></fn></table-wrap-foot></table-wrap></p>
      <p>To investigate how MetaVelvet yielded a larger number of genes, we analyzed the following generalized score of N50:
<disp-formula id="gks678-M2"><label>(2)</label><graphic xlink:href="gks678m2"/></disp-formula>
where <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>, … , <italic>S</italic><sub><italic>n</italic></sub> denote the list of scaffolds in descending order of length as output by an assembler. Note that the N50 score (Eq. (<xref ref-type="disp-formula" rid="gks678-M1">1</xref>)) corresponds to the N-len(<italic>x</italic>) score for <italic>x</italic> = <italic>L</italic>/2, where <italic>L</italic> denotes the total scaffold length. When the total scaffold lengths of two assemblies are quite different in the human gut microbial datasets, the naive use of N50 score is inadequate, because even for the same lists of scaffolds in descending order, the longer <italic>L</italic> decreases the N50 score at <italic>L</italic>/2. This generalized score N-len(<italic>x</italic>) is more appropriate to compare scaffold integrity than the raw N50 score. <xref ref-type="fig" rid="gks678-F12">Figure 12</xref> shows the N-len(<italic>x</italic>) plot for the MH0012 scaffolds assembled by MetaVelvet and Velvet, showing that MetaVelvet greatly improved the scaffold integrity compared with Velvet. For example, when <italic>x</italic> = 1 000 000, the N-len(<italic>x</italic>) score of MetaVelvet was 345 388, while the N-len(<italic>x</italic>) of Velvet was 84 683. Further, we calculated the area under the curve (AUC) of N-len(<italic>x</italic>) for 0 &lt; <italic>x</italic> ≤ <italic>L</italic> in units of 1 000 000 bp, that is, the cumulative sum of N-len(<italic>x</italic>) scores (0 &lt; <italic>x</italic> ≤ <italic>L</italic>), where <italic>L</italic> denotes the total scaffold length. To eliminate the effect of <italic>L</italic> on calculating the AUC (that is, the longer <italic>L</italic> could likely increase the AUC), we also define the AUC<sub>min</sub> of N-len(<italic>x</italic>) to be the AUC of N-len(<italic>x</italic>) for 0 &lt; <italic>x</italic> ≤ min{<italic>L</italic>, <italic>L</italic>′}, where <italic>L</italic> is the total scaffold length of the one assembler and <italic>L</italic>′ is that of the other assembler. The AUC and AUC<sub>min</sub> of N-len(<italic>x</italic>) of MetaVelvet were 5 049 858 and 5 027 177, respectively, for the MH0012 dataset, although the AUC and AUC<sub>min</sub> of Velvet were both 1 897 179. These results imply that MetaVelvet achieved much longer scaffolds by factor of three compared with Velvet. Similarly, MetaVelvet showed greater scaffold integrity than Velvet for the MH0006 and MH0047 datasets (Supplementary Figures S3 and S4). This improvement in scaffold integrity represents the main reason why MetaVelvet yields a larger number of genes from metagenomic short read assemblies.
<fig id="gks678-F12" position="float"><label>Figure 12.</label><caption><p>N-len(<italic>x</italic>) plot of Eq. (<xref ref-type="disp-formula" rid="gks678-M2">2</xref>).</p></caption><graphic xlink:href="gks678f12"/></fig></p>
    </sec>
  </sec>
  <sec>
    <title>SUMMARY AND DISCUSSION</title>
    <p>This study described an extension of the single-genome assembler Velvet to a metagenome assembler, MetaVelvet, and showed its effectiveness in several experiments using simulated datasets and human gut microbial sequence datasets. This work is the first step in the construction of a <italic>de novo</italic> metagenome assembler for the assembly of metagenomes from mixed ‘short’ sequence reads of multiple species.</p>
    <p>Meta-IDBA (<xref ref-type="bibr" rid="gks678-B6">6</xref>) is a currently available and practically executable <italic>de novo</italic> metagenome assembler. From the results using the simulated datasets, it can be seen that MetaVelvet outperformed Meta-IDBA. In fact, the Meta-IDBA project (<xref ref-type="bibr" rid="gks678-B6">6</xref>) pointed out that one of their future works is to make use of uneven abundance ratios in metagenomic datasets. On the other hand, Meta-IDBA is designed to solve the metagenome assembly problem caused by polymorphisms in similar species in metagenomic environments. In this aspect, Meta-IDBA might be more useful for analyzing slight variants in the genomes of subspecies within a same species. <xref ref-type="fig" rid="gks678-F13">Figure 13</xref> shows the comparisons of the N50 scores of contigs between MetaVelvet assemblies and Meta-IDBA assemblies. Since Meta-IDBA does not have the scaffolding function, this result shows a fair comparison on assembly performances between both assemblers. Nevertheless, MetaVelvet achieved higher N50 scores than Meta-IDBA at the order, family and genus levels. On the other hand, Meta-IDBA produced higher N50 score for contigs at the species level, which confirms the specific feature of Meta-IDBA mentioned above.
<fig id="gks678-F13" position="float"><label>Figure 13.</label><caption><p>N50 scores for contigs generated by MetaVelvet and Meta-IDBA.</p></caption><graphic xlink:href="gks678f13"/></fig></p>
    <p>Although we have designed the primary procedure for MetaVelvet, a key issue is how to identify and deal with ambiguous nodes, termed chimeric nodes in this article, with multiple incoming and outgoing edges in the de Bruijn graph. Most nodes in the de Bruijn graph are unique nodes with only one incoming edge and one outgoing edge, and as such, are reliable for building contigs. The single-genome assemblers recognize the ambiguous nodes as repeat nodes, where a repeat node represents a sequence that occurs several times in the genome, which is correct in single-genome assembly. MetaVelvet explicitly identifies chimeric nodes as causing misassemblies that combine reads from distinct species to generate chimeric scaffolds. MetaVelvet then identifies and separates the chimeric node into two unique nodes using node coverage differences. The results showed that this simple strategy worked well for metagenome assembly. The results demonstrate that MetaVelvet is a potentially valuable tool that can be widely used in metagenomic analyses. In particular, a significant increase of the number of predicted complete protein-coding genes is valuable in the search for novel enzymes in metagenome research.</p>
  </sec>
  <sec>
    <title>AVAILABILITY</title>
    <p>The Supplementary Data are also available at: <ext-link ext-link-type="uri" xlink:href="http://metavelvet.dna.bio.keio.ac.jp/supple.pdf">http://metavelvet.dna.bio.keio.ac.jp/supple.pdf</ext-link>.</p>
  </sec>
  <sec>
    <title>SUPPLEMENTARY DATA</title>
    <p><ext-link ext-link-type="uri" xlink:href="http://nar.oxfordjournals.org/cgi/content/full/gks245/DC1">Supplementary Data</ext-link> are available at NAR Online: Supplementary Tables 1–4 and Supplementary Figures 1–4.</p>
  </sec>
  <sec>
    <title>FUNDING</title>
    <p><funding-source>KAKENHI from the Ministry of Education, Culture, Sports, Science and Technology of Japan</funding-source> [<funding-source>Grant-in-Aid for Scientific Research on Innovative Areas</funding-source>
<award-id>No.221S0002</award-id>]. A grant program for bioinformatics research and development of the <funding-source>Japan Science and Technology Agency</funding-source> (in part). Funding for open access charge: <funding-source>KAKENHI</funding-source> from the <funding-source>Ministry of Education, Culture, Sports, Science and Technology of Japan</funding-source> [<funding-source>Grant-in-Aid for Scientific Research on Innovative Areas</funding-source> No.<award-id>221S0002</award-id>].</p>
    <p><italic>Conflict of interest statement</italic>. None declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_40_20_e155__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_gks678_nar-00177-met-n-2012-File021.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We thank Dr Daniel Zerbino for his permission to use and modify the source codes of Velvet and to name our software ‘MetaVelvet’.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="gks678-B1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Venter</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Remington</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Heidelberg</surname>
            <given-names>JF</given-names>
          </name>
          <name>
            <surname>Halpern</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Rusch</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Eisen</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Paulsen</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Nelson</surname>
            <given-names>KE</given-names>
          </name>
          <name>
            <surname>Nelson</surname>
            <given-names>W</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Environmental genome shotgun sequencing of the Sargasso Sea</article-title>
        <source>Science</source>
        <year>2004</year>
        <volume>304</volume>
        <fpage>66</fpage>
        <lpage>74</lpage>
        <pub-id pub-id-type="pmid">15001713</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kurokawa</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Itoh</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Kuwahara</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Oshima</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Toh</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Toyoda</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Takami</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Morita</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Sharma</surname>
            <given-names>VK</given-names>
          </name>
          <name>
            <surname>Srivastava</surname>
            <given-names>TP</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Comparative metagenomics revealed commonly enriched gene sets in human gut microbiomes</article-title>
        <source>DNA Res.</source>
        <year>2007</year>
        <volume>14</volume>
        <fpage>169</fpage>
        <lpage>181</lpage>
        <pub-id pub-id-type="pmid">17916580</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qin</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Raes</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Arumugam</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Burgdorf</surname>
            <given-names>KS</given-names>
          </name>
          <name>
            <surname>Manichanh</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Nielsen</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Pons</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Levenez</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Yamada</surname>
            <given-names>T</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A human gut microbial gene catalogue established by metagenomic sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>464</volume>
        <fpage>59</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">20203603</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hiatt</surname>
            <given-names>JB</given-names>
          </name>
          <name>
            <surname>Patwardhan</surname>
            <given-names>RP</given-names>
          </name>
          <name>
            <surname>Turner</surname>
            <given-names>EH</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>and Shendure</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Parallel, tag-directed assembly of locally derived short sequence reads</article-title>
        <source>Nat. Methods</source>
        <year>2010</year>
        <volume>7</volume>
        <fpage>119</fpage>
        <lpage>122</lpage>
        <pub-id pub-id-type="pmid">20081835</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Bioinformatics for whole-genome shotgun sequencing of microbial communities</article-title>
        <source>PLoS Comput. Biol.</source>
        <year>2005</year>
        <volume>1</volume>
        <fpage>106</fpage>
        <lpage>112</lpage>
        <pub-id pub-id-type="pmid">16110337</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Peng</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Leung</surname>
            <given-names>HC</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>FY</given-names>
          </name>
        </person-group>
        <article-title>Meta-IDBA: a <italic>de novo</italic> assembler for metagenomic data</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>i94</fpage>
        <lpage>i101</lpage>
        <pub-id pub-id-type="pmid">21685107</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Laserson</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Jojic</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Koller</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Genovo: de novo assembly for metagenomes</article-title>
        <source>J. Comput. Biol.</source>
        <year>2011</year>
        <volume>18</volume>
        <fpage>429</fpage>
        <lpage>443</lpage>
        <pub-id pub-id-type="pmid">21385045</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B8">
      <label>8</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Charuvaka</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Rangwala</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Evaluation of short read metagenomic assembly</article-title>
        <source>Proceedings of Bioinformatics and Biomedicine (BIBM), 2010 IEEE International Conference</source>
        <year>2010</year>
        <fpage>171</fpage>
        <lpage>178</lpage>
      </element-citation>
    </ref>
    <ref id="gks678-B9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ye</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>An ORFome assembly approach to metagenomics sequences analysis</article-title>
        <source>J. Bioinform. Comput. Biol.</source>
        <year>2009</year>
        <volume>7</volume>
        <fpage>455</fpage>
        <lpage>471</lpage>
        <pub-id pub-id-type="pmid">19507285</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Saeed</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Halgamuge</surname>
            <given-names>SK</given-names>
          </name>
        </person-group>
        <article-title>The oligonucleotide frequency derived error gradient and its application to the binning of metagenome fragments</article-title>
        <source>BMC Genomics</source>
        <year>2009</year>
        <volume>10</volume>
        <issue>Suppl. 3</issue>
        <fpage>S10</fpage>
        <pub-id pub-id-type="pmid">19958473</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Leung</surname>
            <given-names>HC</given-names>
          </name>
          <name>
            <surname>Yiu</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>FY</given-names>
          </name>
        </person-group>
        <article-title>Unsupervised binning of environmental genomic fragments based on an error robust selection of <italic>l</italic>-mers</article-title>
        <source>BMC Bioinformatics</source>
        <year>2010</year>
        <volume>11</volume>
        <issue>Suppl. 2</issue>
        <fpage>S5</fpage>
      </element-citation>
    </ref>
    <ref id="gks678-B12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>YW</given-names>
          </name>
          <name>
            <surname>Ye</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>A novel abundance-based algorithm for binning metagenomic sequences using <italic>l</italic>-tuples</article-title>
        <source>J. Comput. Biol.</source>
        <year>2011</year>
        <volume>18</volume>
        <fpage>523</fpage>
        <lpage>534</lpage>
        <pub-id pub-id-type="pmid">21385052</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kunin</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Copeland</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lapidus</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Mavromatis</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Hugenholtz</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>A bioinformatician's guide to metagenomics</article-title>
        <source>Microbiol. Mol. Biol. Rev.</source>
        <year>2008</year>
        <volume>72</volume>
        <fpage>557</fpage>
        <lpage>578</lpage>
        <pub-id pub-id-type="pmid">19052320</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nishito</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Osana</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Hachiya</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Popendorf</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Toyoda</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fujiyama</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Itaya</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sakakibara</surname>
            <given-names>Y</given-names>
          </name>
        </person-group>
        <article-title>Whole genome assembly of a natto production strain <italic>Bacillus subtilis natto</italic> from very short read data</article-title>
        <source>BMC Genomics</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>243</fpage>
        <pub-id pub-id-type="pmid">20398357</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Velvet: algorithms for de novo short read assembly using de Bruijn graphs</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>821</fpage>
        <lpage>829</lpage>
        <pub-id pub-id-type="pmid">18349386</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zerbino</surname>
            <given-names>DR</given-names>
          </name>
          <name>
            <surname>McEwen</surname>
            <given-names>GK</given-names>
          </name>
          <name>
            <surname>Margulies</surname>
            <given-names>EH</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Pebble and rock band: heuristic resolution of repeats and scaffolding in the velvet short-read de novo assembler</article-title>
        <source>PLoS One</source>
        <year>2009</year>
        <volume>4</volume>
        <fpage>e8407</fpage>
        <pub-id pub-id-type="pmid">20027311</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Idury</surname>
            <given-names>RM</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>A new algorithm for DNA sequence assembly</article-title>
        <source>J. Comput. Biol.</source>
        <year>1995</year>
        <volume>2</volume>
        <fpage>291</fpage>
        <lpage>306</lpage>
        <pub-id pub-id-type="pmid">7497130</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2001</year>
        <volume>98</volume>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Maccallum</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Przybylski</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Gnerre</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Burton</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Shlyakhter</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Gnirke</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Malek</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>McKernan</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>ALLPATHS 2: small genomes assembled accurately and with high continuity from short paired reads</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R103</fpage>
        <pub-id pub-id-type="pmid">19796385</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Jackman</surname>
            <given-names>SD</given-names>
          </name>
          <name>
            <surname>Schein</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>ABySS: a parallel assembler for short read sequence data</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lander</surname>
            <given-names>ES</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Genomic mapping by fingerprinting random clones: a mathematical analysis</article-title>
        <source>Genomics</source>
        <year>1988</year>
        <volume>2</volume>
        <fpage>231</fpage>
        <lpage>239</lpage>
        <pub-id pub-id-type="pmid">3294162</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Zhu</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Ruan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Qian</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Fang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Shi</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Shan</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kristiansen</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title>
        <source>Genome Res</source>
        <year>2010</year>
        <volume>20</volume>
        <fpage>265</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="pmid">20019144</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Noguchi</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Park</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Takagi</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>MetaGene: prokaryotic gene finding from environmental genome shotgun sequences</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2006</year>
        <volume>34</volume>
        <fpage>5623</fpage>
        <lpage>5630</lpage>
        <pub-id pub-id-type="pmid">17028096</pub-id>
      </element-citation>
    </ref>
    <ref id="gks678-B24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Unterseher</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jumpponen</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Opik</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tedersoo</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Moora</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Dormann</surname>
            <given-names>CF</given-names>
          </name>
          <name>
            <surname>Schnittler</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Species abundance distributions and richness estimations in fungal metagenomics — lessons learned from community ecology</article-title>
        <source>Mol. Ecol.</source>
        <year>2011</year>
        <volume>20</volume>
        <fpage>275</fpage>
        <lpage>285</lpage>
        <pub-id pub-id-type="pmid">21155911</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
