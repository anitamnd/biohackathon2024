<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6283589</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0207376</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-18-11418</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Applied Mathematics</subject>
            <subj-group>
              <subject>Algorithms</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Simulation and Modeling</subject>
          <subj-group>
            <subject>Algorithms</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Imaging Techniques</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Cell Biology</subject>
          <subj-group>
            <subject>Cellular Structures and Organelles</subject>
            <subj-group>
              <subject>Cell Membranes</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Physical Sciences</subject>
        <subj-group>
          <subject>Mathematics</subject>
          <subj-group>
            <subject>Numerical Analysis</subject>
            <subj-group>
              <subject>Interpolation</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Microscopy</subject>
          <subj-group>
            <subject>Light Microscopy</subject>
            <subj-group>
              <subject>Bright Field Microscopy</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Engineering and Technology</subject>
        <subj-group>
          <subject>Equipment</subject>
          <subj-group>
            <subject>Optical Equipment</subject>
            <subj-group>
              <subject>Cameras</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Mathematical and Statistical Techniques</subject>
          <subj-group>
            <subject>Fourier Analysis</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Cell Biology</subject>
          <subj-group>
            <subject>Cellular Structures and Organelles</subject>
            <subj-group>
              <subject>Vesicles</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A gradient-based, GPU-accelerated, high-precision contour-segmentation algorithm with application to cell membrane fluctuation spectroscopy</article-title>
      <alt-title alt-title-type="running-head">Membrane fluctuation spectroscopy</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Mell</surname>
          <given-names>Michael</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-6455-3083</contrib-id>
        <name>
          <surname>Monroy</surname>
          <given-names>Francisco</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Investigation</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Project administration</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff002">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <label>1</label>
      <addr-line>Mechanics of Biological Membranes and Biorheology, Dpto. Química Física I, Universidad Complutense, Madrid, Spain</addr-line>
    </aff>
    <aff id="aff002">
      <label>2</label>
      <addr-line>Translational Biophysics, Instituto de Investigacion Biomédica Hospital Doce de Octubre (i+12), Madrid, Spain</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Bernardino de la Serna</surname>
          <given-names>Jorge</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>Science and Technology Facilities Council, UNITED KINGDOM</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>michael.mell@gmx.net</email>(MM); <email>monroy@ucm.es</email>(FM)</corresp>
    </author-notes>
    <pub-date pub-type="epub">
      <day>6</day>
      <month>12</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <volume>13</volume>
    <issue>12</issue>
    <elocation-id>e0207376</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>4</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>30</day>
        <month>10</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2018 Mell, Monroy</copyright-statement>
      <copyright-year>2018</copyright-year>
      <copyright-holder>Mell, Monroy</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0207376.pdf"/>
    <abstract>
      <p>We present a novel intensity-gradient based algorithm specifically designed for nanometer-segmentation of cell membrane contours obtained with high-resolution optical microscopy combined with high-velocity digital imaging. The algorithm relies on the image oversampling performance and computational power of graphical processing units (GPUs). Both, synthetic and experimental data are used to quantify the sub-pixel precision of the algorithm, whose analytic performance results comparatively higher than in previous methods. Results from the synthetic data indicate that the spatial precision of the presented algorithm is only limited by the signal-to-noise ratio (SNR) of the contour image. We emphasize on the application of the new algorithm to membrane fluctuations (flickering) in eukaryotic cells, bacteria and giant vesicle models. The method shows promising applicability in several fields of cellular biology and medical imaging for nanometer-precise boundary-determination and mechanical fingerprinting of cellular membranes in optical microscopy images. Our implementation of this high-precision flicker spectroscopy contour tracking algorithm (HiPFSTA) is provided as open-source at <ext-link ext-link-type="uri" xlink:href="http://www.gitlab.com/michaelmell/hipfsta">www.github.com/michaelmell/hipfsta</ext-link>.</p>
    </abstract>
    <funding-group>
      <funding-statement>This work was supported by the Ministry of Economy and Competitiveness (MINECO), Spain (Grant No. FIS2015-70339-C2-1-R) and Comunidad de Madrid, Spain (Grant No. S2013/MIT-2807). MM thanks the FPU program (MEC) for financial support.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="10"/>
      <table-count count="2"/>
      <page-count count="26"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>All relevant data are within the paper and its Supporting Information files.</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>All relevant data are within the paper and its Supporting Information files.</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>Quantitative imaging is progressively empowering the analytic toolbox of cellular biology with high-performance observational facilities accessing new biophysical markers resolved in space and time [<xref rid="pone.0207376.ref001" ref-type="bibr">1</xref>,<xref rid="pone.0207376.ref002" ref-type="bibr">2</xref>]. Optical microscopy imaging combined with computational technologies are opening translational promise as provide the integrative biologist with unprecedented mines of data to be exploited in high-performance analytic approaches, which are allowing to gain further insight beyond conventional imaging with immunofluorescence [<xref rid="pone.0207376.ref003" ref-type="bibr">3</xref>]. Fluctuation spectroscopy with optical contrast microscopes is a simple, yet powerful biophysical method to probe non-invasively mechanical properties of biological cells by imaging the shape fluctuations of the cell membrane contour [<xref rid="pone.0207376.ref004" ref-type="bibr">4</xref>]. When applied to living cells undergoing metabolically-driven (non-equilibrium) fluctuations, the fluctuation method has allowed for getting new insights into cell mechanics, particularly in studies with red blood cells, hereinafter RBCs [<xref rid="pone.0207376.ref005" ref-type="bibr">5</xref>–<xref rid="pone.0207376.ref012" ref-type="bibr">12</xref>]. The performance of contour-segmentation algorithms for tracking membrane fluctuations from video-microscopy images has always played a crucial role in the advance of this technique by enabling a more precise determination of the cell contour-position [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. Accordingly, various segmentation methods have been proposed with contrast imaging [<xref rid="pone.0207376.ref007" ref-type="bibr">7</xref>,<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>–<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>], which were accompanied by technological advances in digital image processing and computational power. The contour-segmentation algorithm we present here harnesses the computational power of general purpose graphics processing units (GPGPU) having recently become available to significantly improve on current segmentation methods in the sub-pixel performance of nanometer resolution. The super-localization software here proposed may enable observation of novel dynamical phenomena in cell biology and may allow for significantly more precise results that could be exploited efficiently in cell phenotyping approaches useful in biomedical contexts. The new algorithm is potentially implementable to more sophisticated optical settings [<xref rid="pone.0207376.ref001" ref-type="bibr">1</xref>], including diffraction phase microscopy (DMP) [<xref rid="pone.0207376.ref022" ref-type="bibr">22</xref>] and phase-contrast modes in digital holographic microscopy (DHM) [<xref rid="pone.0207376.ref023" ref-type="bibr">23</xref>]. These adaptations could push quantitative imaging further into novel software developments that take advantage of the enhanced contour detection provided by our new method.</p>
    <p>Technically speaking, the new segmentation algorithm analyzes optically contrasted (either bright-field or phase-contrast) microscopy images of cells possessing a characteristic halo at the cell boundary. The so-called “halo effect” is nonlinearly tied to the coherence of the illumination and the optical contrast of the sample [<xref rid="pone.0207376.ref024" ref-type="bibr">24</xref>], and provides an exploitable framework for image formation in different contrast modes under varying degrees of coherence [<xref rid="pone.0207376.ref025" ref-type="bibr">25</xref>,<xref rid="pone.0207376.ref026" ref-type="bibr">26</xref>]. This contrast halo consists of an intensity minimum and maximum, which encodes the information on the membrane position as the result of a mismatch in the refractive indices of the medium inside and outside the cell (see <xref ref-type="fig" rid="pone.0207376.g001">Fig 1A and 1B</xref>). Early segmentation algorithms used the intensity maximum of the halo to determine the location of the cell-contour [<xref rid="pone.0207376.ref014" ref-type="bibr">14</xref>,<xref rid="pone.0207376.ref016" ref-type="bibr">16</xref>,<xref rid="pone.0207376.ref019" ref-type="bibr">19</xref>,<xref rid="pone.0207376.ref027" ref-type="bibr">27</xref>]. However, it was later pointed out by Döbereiner [<xref rid="pone.0207376.ref018" ref-type="bibr">18</xref>] and Pécréaux [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>] that the location of the interface is actually placed at the maximal gradient of the halo intensity [<xref rid="pone.0207376.ref028" ref-type="bibr">28</xref>] and this has become the preferred method for the membrane localization [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>,<xref rid="pone.0207376.ref016" ref-type="bibr">16</xref>–<xref rid="pone.0207376.ref018" ref-type="bibr">18</xref>,<xref rid="pone.0207376.ref020" ref-type="bibr">20</xref>,<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>]. Pécréaux and cols. [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>] proposed the currently widespread segmentation algorithm, where the interface location is defined by the intercept of a linear fit to the intensity profile at the contour halo and the average background intensity (see <xref ref-type="fig" rid="pone.0207376.g001">Fig 1B</xref>). This linear fit is performed to the pixel-intensity values along three of the four principle directions of the pixel-grid (2x parallel, 2x diagonal) to calculate the final position from their weighted average [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. In the Pécréaux’ algorithm segmentation is performed sequentially along the contour using a number of different conditions to determine the segmentation direction. More recently, new segmentation methods have been proposed to locate the contour positions by directly determining the maximum of the intensity gradient [<xref rid="pone.0207376.ref020" ref-type="bibr">20</xref>,<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>]. In particular, Usenik et al. [<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>] used interpolation to calculate the image intensity along radial directions starting from the center of the contour. The contour position is determined by the intensity gradient maximum along each individual line (see <xref ref-type="fig" rid="pone.0207376.g001">Fig 1(C))</xref>. By calculating an updated barycenter of the contour, the process is repeated for each image until the center of the contour converges to a fixed position. This allows the individual refinement of each contour-coordinate, an improvement that is not possible using previous methods. However, the direct usage of the numerical gradient in the Usenik’s method has drawbacks, since it amplifies image noise. Therefore, those authors use Gaussian image filter to reduce noise, which should be expected to reduce resolution [<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>].</p>
    <fig id="pone.0207376.g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g001</object-id>
      <label>Fig 1</label>
      <caption>
        <title>Phase contrast causes an intensity gradient at the location of the RBC membrane.</title>
        <p>(A) Bright-field image of a RBC. (B) Intensity profile along the black line in (A). The vertical line indicates the contour-position as found with the method described in [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. The background intensity and fit are also indicated (horizontal and diagonal line). (C) Intensity-gradient of (B). The vertical line indicates the maximum. The noise in the image cause two maxima at the peak, which makes localizing the absolute peak value difficult without filtering.</p>
      </caption>
      <graphic xlink:href="pone.0207376.g001"/>
    </fig>
    <p>To overcome the limitations of these two algorithms, our proposed method combines ideas from both, putting substantial emphasis on image oversampling as an original characteristic of the proposed method. In Pécréaux’ method each point in the contour is determined from the precedent one, which introduces an evident bias that makes that method especially sensible to the choice of the initial condition. To increase the robustness of our algorithm, we follow the Usenik’s method for which each contour coordinate <bold><italic>P</italic></bold><sub><italic>i</italic></sub> is refined independently at a fixed contour angle <italic>ϕ</italic><sub><italic>i</italic></sub> over various iterations per image. Motivated by Pécréaux, our method determines each contour coordinate <bold><italic>P</italic></bold><sub><italic>i</italic></sub> from the weighted sum of a large number of linear fits over a range of local angles <italic>φ</italic><sub><italic>j</italic></sub> centered on the contour normal <bold><italic>n</italic></bold><sub><italic>i</italic></sub> of the intensity halo. In our proposed method, the positions for performing the linear fits become independent of the pixel-grid by interpolating pixel-intensities, which overcomes a subtle, but significant issue with Pécréaux’ method that is related with the fixed positions of the centers of the pixels. These mutual improvements have allowed us to generate a new hybrid algorithm, more robust and precise than the previous ones, which enhances the accuracy of the segmentation method down to 2nm spatial precision in determining changes in the position of the contour halo. The new algorithm has been implemented with movies of dynamic fluctuations recorded by digital video-microscopy with high-velocity cameras at short exposition times (shorter than millisecond). This allows an ultrafast readout of the contour fluctuations (up to several tents kHz) that, applied to cell membranes, allows imaging the instantaneous snapshots necessary for probing the shape fluctuations of the cell membrane. A typical imaging session left less than one-second, the time necessary to record all the data required to perform the time-average involved in a statistically relevant fluctuation spectrum and to detect the time correlations due to the intrinsic dynamics of the fluctuation modes of membrane deformation. Further mathematical treatment of these membrane fluctuations, especially by Fourier analysis, makes possible a deep understanding of membrane mechanics in terms of usual elasticity models [<xref rid="pone.0207376.ref029" ref-type="bibr">29</xref>]. All these improvements empower the proposed method with a significantly higher performance than previous ones, particularly in terms of enhanced spatiotemporal accuracy that allows resolving the membrane fluctuations with a higher precision not only in amplitude but also in spatial and time resolution, both in real and reciprocal domains. Such a breakthrough in segmentation performance should be crucial to approach new problems of cell mechanics where membrane fluctuations can be exploited as a relevant observable. Imaging membrane fluctuations could thus become an excellent observational method for non-invasive and non-stressing probing the mechanical phenotypic traits of cellular membranes where the intrinsic rigidity of the cytoskeleton necessarily imposes low amplitudes and short correlation times and distances of the membrane fluctuations.</p>
  </sec>
  <sec sec-type="materials|methods" id="sec002">
    <title>Method</title>
    <sec id="sec003">
      <title>Microscopy hardware</title>
      <p>To observe the surrounding border of a cell, or of a lipid vesicle, we take advantage of wide-field transillumination video-microscopy [<xref rid="pone.0207376.ref030" ref-type="bibr">30</xref>]. Transillumination techniques require two lenses, condenser and objective, both used to focus the light on each side of the sample. In an inverted bright-field (BF) microscope, the sample is transilluminated from above by focusing light (with the condenser) on the entire field of view where the object to observe is placed. The resulting BF image is formed after the light has been transmitted through the sample and collected with the objective lens from its focal plane. Then, the image is recorded on a video camera. Because of the transmittance difference between the object interior and the outer medium, an Airy pattern due to edge-diffraction is produced at the border of the object. Consequently, when the BF image is formed, the object appears surrounded by a brighter “halo”, which delimits the contour of the border [<xref rid="pone.0207376.ref031" ref-type="bibr">31</xref>]. BF images of our biological samples tend to have low contrast, because vesicles and most cells are not strongly light-absorbing, however additional contrast can be gained in the phase-contrast mode [<xref rid="pone.0207376.ref030" ref-type="bibr">30</xref>]. In a Phase Contrast (PhC) microscope, phase shifts produced in light passing through a transparent specimen with contrasted optical densities are converted to brightness changes in the image. PhC is based on refractive index differences [<xref rid="pone.0207376.ref032" ref-type="bibr">32</xref>], indeed optical edges between regions with different refractive indices cause light to refract in an amount (phase-shift) that depends on how much the refractive index changes. Most simply, PhC microscopes generate an image by comparing how much phase-shift is produced at each location in the sample relative to how much light is not phase-shifted. Physically, this construction occurs via interference between refracted (phase-shifted) and non-refracted light beams. The PhC microscope is fitted with a special condenser and a phase-contrast objective, which contain both phase rings to control phase contrast. PhC images may be made to appear dark against a bright background (positive contrast) or bright against a dark background (negative contrast). The borders of images are surrounded by a characteristic phase-contrast “halo”. Both, BF and PhC techniques are highly sensitive and compatible with the short exposure times involved with high frame rate recording.</p>
      <p>The proposed contour-segmentation algorithm has been conceived to work with halo-edged contrasted microscopy images, indeed it can be interoperable with images obtainable from different transillumination modes used to generate optical contrast. Because the halo contrast is tied to the coherence of the illumination, it can be controlled by the aperture of the condenser. Here, we use indifferently both, BF and PhC images, although images from other contrast modes, such as dark-field, differential interference contrast (DIC) and cross-polarized microscopy are intrinsically different to typical halo-contrasted images, they could be also analyzed by introducing changes in the parameters that determine the definition of the contrast profile in the proposed algorithm.</p>
      <p>In this work, microscopy images are obtained with an inverted microscopy (Nikon Eclipse 80i), which is equipped with high-performance objectives with all possible aberrations, included chromatic, sufficiently minimized. The BF mode is implemented at wide-field illumination with white light from a mercury lamp, and an apochromatic bright-field objective (x100, 1.45 N.A.). The PhC mode is implemented with a condenser equipped with an annular phase plate that focusses the illuminating light from a cold-light LED source (150mW max) in the sample, and an apochromatic phase-contrast objective (x100, 1.45 N.A.). The optical system is equipped with auto-focus, which allows for automatic correction of eventual image defocusing once the equatorial-plane of the contour object has been defined. The microscopy images are continuously recorded with high-dynamical range digital camera (Photron FASTCAM SA-3). This camera has a CMOS sensor allowing for very high sample rates through the parallel and independent read-out of each individual pixel. Each pixel possesses separated electronics for converting the accumulated charge in a pixel into a digital signal. As a result, each pixel possesses different electronic characteristics regarding its read-out noise and dark-current. The whole setup is mechanically isolated by placing on top of an anti-vibration table (Integrity 1VCS, Newport).</p>
    </sec>
    <sec id="sec004">
      <title>Software: Algorithm description</title>
      <sec id="sec005">
        <title>Image preprocessing</title>
        <p>Because a CMOS high-velocity camera with an in-parallel pixel-grid readout is used, the contrast images possess embedded a pixel-grid structure, which if not corrected, can affect the segmentation results. Furthermore, aberrations in the optical path can lead to artifacts in the image that can affect the segmentation result. To correct both artifacts we perform a background-correction of each movie frame before segmentation. For this we record and average over a large number of dark-field images <italic>D</italic><sub><italic>d</italic></sub> as well as a large number of empty (“flat”) frames <italic>F</italic><sub><italic>f</italic></sub> (usually ~1000 frames each). The dark-field images are recorded once for the given exposure-time and serve to correct the cameras dark-current. The flat-fields are recorded previous to and for each measurement (each movie), since their image intensity needs to match that of the measurement as close as possible. The corrected frame <inline-formula id="pone.0207376.e001"><alternatives><graphic xlink:href="pone.0207376.e001.jpg" id="pone.0207376.e001g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M1"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">f</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> is then obtained from <italic>I</italic><sub><italic>i</italic></sub> by performing the following operation for each pixel:
<disp-formula id="pone.0207376.e002"><alternatives><graphic xlink:href="pone.0207376.e002.jpg" id="pone.0207376.e002g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M2"><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">f</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>〉</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>〉</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>〉</mml:mi></mml:mrow><mml:mrow><mml:mi>f</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></alternatives></disp-formula></p>
        <p>We perform the averaging over 〈<italic>D</italic><sub><italic>d</italic></sub>〉<sub><italic>d</italic></sub> and 〈<italic>F</italic><sub><italic>f</italic></sub>〉<sub><italic>f</italic></sub> in order to minimize any noise introduced when performing the correction above.</p>
      </sec>
      <sec id="sec006">
        <title>Contour determination</title>
        <p><bold>Coordinates.</bold> The segmentation algorithm uses both Cartesian <bold><italic>P</italic></bold><sub><italic>i</italic></sub> and polar (<italic>ϕ</italic><sub><italic>i</italic></sub>,<italic>R</italic><sub><italic>i</italic></sub>) coordinates relative to the contour center <bold><italic>O</italic></bold> to represent the <italic>i</italic> = 0…<italic>N</italic> − 1 contour coordinates (see <xref rid="pone.0207376.t001" ref-type="table">Table 1</xref> for parameter values) that define the <italic>N</italic> contour sites. Additionally, it uses the contour normal <bold><italic>n</italic></bold><sub><italic>i</italic></sub> which is calculated from the halo gradient at every contour site <italic>i</italic>. To perform its work, the algorithm uses the <inline-formula id="pone.0207376.e003"><alternatives><graphic xlink:href="pone.0207376.e003.jpg" id="pone.0207376.e003g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M3"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>, <bold><italic>n</italic></bold>′<sub><italic>i</italic></sub>, and <bold><italic>O</italic></bold>′ of the previous iteration (indicated by the prime) and uses them as the starting points to determine the <bold><italic>P</italic></bold><sub><italic>i</italic></sub>, <bold><italic>n</italic></bold><sub><italic>i</italic></sub> and <bold><italic>O</italic></bold> in the following iteration. This allows the positions contour sites <italic>i</italic> to be refined independently of each other in an iterative manner, as we will describe below. Initial segmentation of the first image is performed sequentially, since no previous coordinates <inline-formula id="pone.0207376.e004"><alternatives><graphic xlink:href="pone.0207376.e004.jpg" id="pone.0207376.e004g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M4"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> are available. It is initiated by providing an approximate starting point <bold><italic>P</italic></bold>′<sub><bold><italic>i</italic> = 0</bold></sub> on the halo and an approximate contour center <bold><italic>O</italic></bold>′. The point <bold><italic>P</italic></bold>′<sub><bold><italic>i</italic> = 0</bold></sub> is then refined once to obtain the refined coordinate <bold><italic>P</italic></bold><sub><bold><italic>i</italic> = 0</bold></sub> or (<italic>ϕ</italic><sub><italic>i</italic> = 0</sub>,<italic>R</italic><sub><italic>i</italic> = 0</sub>). The radius <italic>R</italic><sub><italic>i</italic></sub> is then used as the starting point (<italic>ϕ</italic><sub>i+1</sub>,<italic>R</italic><sub><italic>i</italic></sub>) to calculate the following coordinate <bold><italic>P</italic></bold>′<sub><bold><italic>i</italic> = 1</bold></sub>, which then is again refined to obtain <bold><italic>P</italic></bold><sub><bold><italic>i</italic> = 1</bold></sub>. This is then continued for all <italic>N</italic> contour angles, which are fixed to the values <italic>ϕ</italic><sub><italic>i</italic></sub> = (2<italic>π</italic>/<italic>N</italic>) × <italic>i</italic>. After initial segmentation is completed, the algorithm writes the obtained coordinate set <bold><italic>P</italic></bold><sub><bold><italic>i</italic></bold></sub> and <bold><italic>O</italic></bold> to <inline-formula id="pone.0207376.e005"><alternatives><graphic xlink:href="pone.0207376.e005.jpg" id="pone.0207376.e005g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M5"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> and <bold><italic>O</italic></bold>′ to use them as the input for the following segmentation iteration. From then on, all contour sites <italic>i</italic> are determined independently of each other by using the <inline-formula id="pone.0207376.e006"><alternatives><graphic xlink:href="pone.0207376.e006.jpg" id="pone.0207376.e006g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M6"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>,</mml:mo></mml:math></alternatives></inline-formula>
<bold><italic>n</italic></bold>′<sub><italic>i</italic></sub> and <bold><italic>O</italic></bold>′ of the previous iteration, even when switching from on video image to the next.</p>
        <table-wrap id="pone.0207376.t001" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0207376.t001</object-id>
          <label>Table 1</label>
          <caption>
            <title>Parameter values used for imaging and tracking RBCs.</title>
          </caption>
          <alternatives>
            <graphic id="pone.0207376.t001g" xlink:href="pone.0207376.t001"/>
            <table frame="hsides" rules="groups">
              <colgroup span="1">
                <col align="left" valign="middle" span="1"/>
                <col align="left" valign="middle" span="1"/>
                <col align="left" valign="middle" span="1"/>
                <col align="left" valign="middle" span="1"/>
                <col align="left" valign="middle" span="1"/>
              </colgroup>
              <thead>
                <tr>
                  <th align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">
                    <italic>N</italic>
                  </th>
                  <th align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">Φ</th>
                  <th align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">
                    <italic>M</italic>
                  </th>
                  <th align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">
                    <italic>f</italic>
                    <sub>interp</sub>
                  </th>
                  <th align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">
                    <italic>n</italic>
                    <sub>fit</sub>
                  </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td align="center" rowspan="1" colspan="1">2048</td>
                  <td align="center" rowspan="1" colspan="1">π/4</td>
                  <td align="center" rowspan="1" colspan="1">64</td>
                  <td align="center" rowspan="1" colspan="1">20 px<sup>-1</sup></td>
                  <td align="center" rowspan="1" colspan="1">100</td>
                </tr>
                <tr>
                  <td align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">
                    <italic>n</italic>
                    <sub>bkgr</sub>
                  </td>
                  <td align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">
                    <italic>L</italic>
                    <sub>
                      <italic>Y</italic>
                    </sub>
                  </td>
                  <td align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">Δ<sub>shift</sub></td>
                  <td align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">Δ<sub>coord</sub></td>
                  <td align="center" style="background-color:#D0CECE" rowspan="1" colspan="1">Δ<sub>center</sub></td>
                </tr>
                <tr>
                  <td align="center" rowspan="1" colspan="1">400</td>
                  <td align="center" rowspan="1" colspan="1">400</td>
                  <td align="center" rowspan="1" colspan="1">10 px</td>
                  <td align="center" rowspan="1" colspan="1">0.01 px</td>
                  <td align="center" rowspan="1" colspan="1">0.01 px</td>
                </tr>
              </tbody>
            </table>
          </alternatives>
          <table-wrap-foot>
            <fn id="t001fn001">
              <p>Parameter values used for imaging and tracking RBCs to obtain the results presented in this paper.</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p><bold>Pixel grid.</bold> The pixel size determines the maximal resolution for sampling image intensities from phase contrast halo. Without interpolation of image pixels, the processing of image intensities by an algorithm will therefore be confined to the location of pixels within the pixel grid. In particular, fitting of the halos intensity is then confined to the center position of individual pixels and can only be performed parallel and diagonal to the pixel-grid. However, for any closed contour the maximal gradient of the halo will point into every possible angular direction of the image, including direction not commensurate with those of the pixel grid. Without interpolation, the rectangular geometry of the pixel grid therefore represents a significant limitation to algorithms that are based on intensity gradients or the fitting of pixel intensities. Pécréaux and cols. handled this limitation by calculating <italic>local</italic> contour coordinates along three of the four pixel-grid directions, while excluding the direction closest to the contours tangent (see Fig 7 in ref. [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]). Each <italic>local</italic> contour coordinate is obtained by fitting a line to the halo intensity and calculating its intercept point with the background intensity at the outside contour region, which is calculated as an averaged value along the radial direction. To minimize mapping errors due to optical heterogeneities, only single cells that remain isolated from each other are considered. The final contour coordinate at a given pixel position is then defined by the weighted average of these <italic>local</italic> contour coordinate, where each direction is weighted by the corresponding slope of the intensity gradient in that direction. Consequently, the direction that is closest to the contour normal will be counted most since in that direction the slope will be the steepest. In our algorithm, we incorporate the concept of using weighted averages of different directions but use a more sophisticated sampling technique to find the direction and amplitude of the maximal normal gradient.</p>
        <p><bold>Image sampling and gradient fits.</bold> By interpolating and resampling the pixel intensities of the image during segmentation, we are neither limited to the discrete pixel positions nor the diagonal and parallel directions of the pixel grid. Instead, using the contour coordinate <inline-formula id="pone.0207376.e007"><alternatives><graphic xlink:href="pone.0207376.e007.jpg" id="pone.0207376.e007g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M7"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> from the previous segmentation iteration as the base-point, we determine a local contour positions <bold><italic>p</italic></bold><sub><bold><italic>j</italic></bold></sub> for a range of angles <italic>φ</italic><sub><italic>j</italic></sub> (<italic>j</italic> = 0…<italic>M</italic> − 1) (see <xref ref-type="fig" rid="pone.0207376.g002">Fig 2A</xref>) by fitting a line to the halo intensity and calculating its intercept with the background intensity similarly to Pécréaux’ method. The angle range Φ of <italic>φ</italic><sub><italic>j</italic></sub> is centered on the contour normal <bold><italic>n</italic></bold>′<sub><bold><italic>j</italic></bold></sub> of the previous iteration (see Eq (<xref ref-type="disp-formula" rid="pone.0207376.e012">2</xref>)). The intensity values that are used for the calculations are obtained by interpolating the pixel intensities along a line in each direction <italic>φ</italic><sub><italic>j</italic></sub>.</p>
        <fig id="pone.0207376.g002" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g002</object-id>
          <label>Fig 2</label>
          <caption>
            <title>The new algorithm uses oversampling of the intensity gradient to determine the membrane position with sub-pixel precision.</title>
            <p>(A) Illustration of the local angles <italic>φ</italic><sub><italic>j</italic></sub> and their position on the halo. (B) Determination of local coordinate <bold><italic>p</italic></bold><sub><italic>j</italic></sub> in a given direction <italic>φ</italic><sub><italic>j</italic></sub>. The fit is performed between the intensity minimum and maximum indicated by the arrows. This corresponds to <bold>Method 1</bold> explained in the text. Note that the fit position (horizontal arrow) lies in-between the positions and intensity values of the individual pixels (black squares). This is made possible by the linear interpolation. The background intensity is determined just outside the halo. (C) Fit slopes as a function of the local angle. The maximum is perpendicular to the halo.</p>
          </caption>
          <graphic xlink:href="pone.0207376.g002"/>
        </fig>
        <p>The gradient fit in the direction <italic>φ</italic><sub><italic>j</italic></sub> is determined by performing a linear fit to the intensity using the equation <italic>y</italic><sub><italic>j</italic></sub> = <italic>m</italic><sub><italic>j</italic></sub>
<italic>x</italic> + <italic>b</italic><sub><italic>j</italic></sub>. By using an oversampling factor <italic>f</italic><sub>interp</sub> (see <xref rid="pone.0207376.t001" ref-type="table">Table 1</xref>), we are able to finely adjust the location along the intensity profile at which the linear fit is performed. As we will see in the analysis section, this is important to avoid pixel artifacts. The background intensity 〈<italic>I</italic><sub><italic>j</italic></sub>〉 is calculated from a line in the direction of <italic>φ</italic><sub><italic>j</italic></sub> just outside the halo of the phase contrast image by averaging over <italic>n</italic><sub>bkgr</sub> interpolated intensity values (see <xref ref-type="fig" rid="pone.0207376.g002">Fig 2B</xref>). We determine the background intensity in this manner and not centered about <inline-formula id="pone.0207376.e008"><alternatives><graphic xlink:href="pone.0207376.e008.jpg" id="pone.0207376.e008g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M8"><mml:msubsup><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> (like Pécréaux does), because many cells, including RBCs, cause substantial light absorption and other image inhomogeneities, so that the light intensities inside are modified.</p>
        <p><bold>Contour vector-coordinates</bold>. The local contour positions <bold><italic>p</italic></bold><sub><bold><italic>j</italic></bold></sub> in the direction of each angle <italic>φ</italic><sub><italic>j</italic></sub> are then given by the intercept of the fitted straight with the background intensity
<disp-formula id="pone.0207376.e009"><alternatives><graphic xlink:href="pone.0207376.e009.jpg" id="pone.0207376.e009g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M9"><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mi>〉</mml:mi><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></alternatives></disp-formula>
using the expressions
<disp-formula id="pone.0207376.e010"><alternatives><graphic xlink:href="pone.0207376.e010.jpg" id="pone.0207376.e010g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M10"><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">e</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math></alternatives></disp-formula>
where <bold><italic>e</italic></bold><sub><italic>j</italic></sub> is the unit vector in the direction of the local angle <italic>φ</italic><sub><italic>j</italic></sub>. Finally, the updated contour coordinate <bold><italic>P</italic></bold><sub><italic>i</italic></sub> in the direction of <italic>ϕ</italic><sub><italic>i</italic></sub> is determined by calculating the weighted mean of the <bold><italic>p</italic></bold><sub><italic>j</italic></sub> using their corresponding inclines <italic>m</italic><sub><italic>j</italic></sub> as weights:
<disp-formula id="pone.0207376.e011"><alternatives><graphic xlink:href="pone.0207376.e011.jpg" id="pone.0207376.e011g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M11"><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">p</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:math></alternatives><label>(1)</label></disp-formula></p>
        <p>The updated contour normal <bold><italic>n</italic></bold><sub><italic>i</italic></sub> is calculated similarly through the weighted mean of the unit vectors <bold><italic>e</italic></bold><sub><italic>j</italic></sub> weighted by their corresponding gradient slopes <italic>m</italic><sub><italic>j</italic></sub> (indicated as black arrows in <xref ref-type="fig" rid="pone.0207376.g002">Fig 2A</xref>):
<disp-formula id="pone.0207376.e012"><alternatives><graphic xlink:href="pone.0207376.e012.jpg" id="pone.0207376.e012g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M12"><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">e</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">e</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:math></alternatives><label>(2)</label></disp-formula></p>
        <p>Since we perform this operation during various iterations for each video image, the algorithm iteratively finds the optimal contour position <bold><italic>P</italic></bold><sub><italic>i</italic></sub> and normal <bold><italic>n</italic></bold><sub><italic>i</italic></sub>, about which the final directions <italic>φ</italic><sub><italic>j</italic></sub>, at which we sample, are distributed symmetrically.</p>
      </sec>
      <sec id="sec007">
        <title>Coordinate sanity check</title>
        <p>After each segmentation iteration, the algorithm checks the contour coordinates <bold><italic>P</italic></bold><sub><italic>i</italic></sub> for any spurious outliers that could have been tracked incorrectly. This is important as the contour center in each iteration is determined as the weighted sum of <bold><italic>P</italic></bold><sub><italic>i</italic></sub>, which is weighted by the distance <italic>ds</italic><sub><italic>i</italic></sub> between them (see below). If a contour coordinate <bold><italic>P</italic></bold><sub><italic>i</italic></sub> is a strong outlier and far from its neighboring coordinates <bold><italic>P</italic></bold><sub><italic>i</italic>−1</sub> and <bold><italic>P</italic></bold><sub><italic>i</italic>+1</sub>, this can cause the center to jump and potentially lead to the failure of the algorithm. To avoid this, each coordinate <bold><italic>P</italic></bold><sub><italic>i</italic></sub> from the current iteration is compared to its value of the previous iteration <bold><italic>P</italic></bold>′<sub><italic>i</italic></sub>. If the distance between the two is larger than the tolerance Δ<sub>shift</sub>, then the value of <bold><italic>P</italic></bold><sub><italic>i</italic></sub> and the contour normal <bold><italic>n</italic></bold><sub><italic>i</italic></sub> is replaced with the linear interpolation of its closest neighboring coordinates that were tracked correctly, so that:
<disp-formula id="pone.0207376.e013"><alternatives><graphic xlink:href="pone.0207376.e013.jpg" id="pone.0207376.e013g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M13"><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">f</mml:mi><mml:mo>:</mml:mo><mml:mspace width="0.50em"/><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">Δ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">f</mml:mi><mml:mi mathvariant="normal">t</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></disp-formula>
<disp-formula id="pone.0207376.e014"><alternatives><graphic xlink:href="pone.0207376.e014.jpg" id="pone.0207376.e014g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M14"><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">e</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mo>:</mml:mo><mml:mspace width="0.50em"/><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold-italic">α</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">i</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">β</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>α</mml:mi><mml:mo>+</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:mfrac></mml:math></alternatives></disp-formula>
and calculate the normal vector as:
<disp-formula id="pone.0207376.e015"><alternatives><graphic xlink:href="pone.0207376.e015.jpg" id="pone.0207376.e015g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M15"><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">α</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">β</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mo>/</mml:mo><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mi>α</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>β</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">α</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">β</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula></p>
        <p>Here <italic>i</italic> − <italic>α</italic> and <italic>i</italic> + <italic>β</italic> are the indices of the closest neighboring coordinates that were tracked correctly. Note, that the value of Δ<sub>coord–shift</sub> needs to be chosen as function of the frequency at which the video is recorded, since for lower frequencies the movement of an object contour will likely be larger between consecutive movie frames.</p>
      </sec>
      <sec id="sec008">
        <title>Calculation of center coordinate</title>
        <p>The updated contour center <bold><italic>O</italic></bold> for the following segmentation iteration is calculated after the coordinates were checked and possibly corrected. Following Pécréaux the center is calculated as the weighted mean of the contour coordinates <bold><italic>P</italic></bold><sub><italic>i</italic></sub>
<disp-formula id="pone.0207376.e016"><alternatives><graphic xlink:href="pone.0207376.e016.jpg" id="pone.0207376.e016g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M16"><mml:mi mathvariant="bold-italic">O</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:math></alternatives></disp-formula>
where the weighting factors <italic>ds</italic><sub><italic>i</italic></sub> are the distances between adjacent contour points:
<disp-formula id="pone.0207376.e017"><alternatives><graphic xlink:href="pone.0207376.e017.jpg" id="pone.0207376.e017g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M17"><mml:mi>d</mml:mi><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:msqrt></mml:math></alternatives></disp-formula></p>
        <p>Calculating the contour center in this way, we weight coordinates that are farther apart (e.g. for fixed contour-angles farther from the center) more strongly than closely spaced coordinates. This makes the algorithm converge more rapidly to the optimal center of the contour than the barycenter of the points <bold><italic>P</italic></bold><sub><italic>i</italic></sub> would.</p>
      </sec>
      <sec id="sec009">
        <title>Coordinate interpolation</title>
        <p>Because we determine the contour coordinates <bold><italic>P</italic></bold><sub><italic>i</italic></sub> through the weighted mean of the local coordinates <bold><italic>p</italic></bold><sub><bold><italic>j</italic></bold></sub>, the contour coordinates <bold><italic>P</italic></bold><sub><italic>i</italic></sub> could start to “wander” away from their originally intended location at the desired angle <italic>ϕ</italic><sub><italic>i</italic></sub>. This can happen especially when, either the weighting factors <italic>m</italic><sub><italic>j</italic></sub> or the local coordinates <bold><italic>p</italic></bold><sub><italic>j</italic></sub>, are unevenly distributed tangentially to the contour. To correct this undesirable effect, the contour coordinates are updated after each segmentation iteration, using linear interpolation, to determine their position at the desired angle <italic>ϕ</italic><sub><italic>i</italic></sub>. Briefly, we first denote the coordinate value of <bold><italic>P</italic></bold><sub><italic>i</italic></sub> directly after averaging over its local coordinates <bold><italic>p</italic></bold><sub><italic>j</italic></sub> with <inline-formula id="pone.0207376.e018"><alternatives><graphic xlink:href="pone.0207376.e018.jpg" id="pone.0207376.e018g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M18"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> at contour angle <inline-formula id="pone.0207376.e019"><alternatives><graphic xlink:href="pone.0207376.e019.jpg" id="pone.0207376.e019g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M19"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>; then, we determine the intercept between the straight <inline-formula id="pone.0207376.e020"><alternatives><graphic xlink:href="pone.0207376.e020.jpg" id="pone.0207376.e020g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M20"><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>α</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">e</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">O</mml:mi></mml:math></alternatives></inline-formula> and the contour-segment <inline-formula id="pone.0207376.e021"><alternatives><graphic xlink:href="pone.0207376.e021.jpg" id="pone.0207376.e021g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M21"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> through which it passes, where <inline-formula id="pone.0207376.e022"><alternatives><graphic xlink:href="pone.0207376.e022.jpg" id="pone.0207376.e022g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M22"><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">e</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is the unit-vector in the direction of the desired angle <italic>ϕ</italic><sub><italic>i</italic></sub> and <bold><italic>O</italic></bold> is the updated contour center. Finally, this result yields the final position <bold><italic>P</italic></bold><sub><bold><italic>i</italic></bold></sub>. To determine the line-segment <inline-formula id="pone.0207376.e023"><alternatives><graphic xlink:href="pone.0207376.e023.jpg" id="pone.0207376.e023g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M23"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> through which <bold><italic>y</italic></bold><sub><italic>i</italic></sub> passes, we determine the two adjacent contour coordinates <inline-formula id="pone.0207376.e024"><alternatives><graphic xlink:href="pone.0207376.e024.jpg" id="pone.0207376.e024g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M24"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0207376.e025"><alternatives><graphic xlink:href="pone.0207376.e025.jpg" id="pone.0207376.e025g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M25"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold-italic">P</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> with corresponding angles <inline-formula id="pone.0207376.e026"><alternatives><graphic xlink:href="pone.0207376.e026.jpg" id="pone.0207376.e026g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M26"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pone.0207376.e027"><alternatives><graphic xlink:href="pone.0207376.e027.jpg" id="pone.0207376.e027g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M27"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, so that <inline-formula id="pone.0207376.e028"><alternatives><graphic xlink:href="pone.0207376.e028.jpg" id="pone.0207376.e028g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M28"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&lt;</mml:mo><mml:msub><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. The contour coordinates are then updated with the interpolated coordinates and written to <bold><italic>P</italic>′</bold><sub><italic>i</italic></sub> as input for the following iteration. Note that we do not interpolate the value of <bold><italic>n</italic></bold><sub><italic>i</italic></sub>, since we hope the contour normal to converge to its correct value by itself over the course of the iterations. Furthermore, the linear interpolation does not represent a loss in precision, since it only pins the position of each coordinate to its desired contour angle <italic>ϕ</italic><sub><italic>i</italic></sub>, but we still let the coordinate converge to its optimal position at that angle.</p>
      </sec>
      <sec id="sec010">
        <title>Segmentation termination</title>
        <p>To determine when to terminate the segmentation process of an image, the algorithm uses two conditions for the contour coordinates <bold><italic>P</italic></bold><sub><italic>i</italic></sub> and the contour center <bold><italic>O</italic></bold>. After each iteration it checks whether the positions of the <bold><italic>P</italic></bold><sub><italic>i</italic></sub> and <bold><italic>O</italic></bold> have changed more than a user-defined tolerance Δ<sub>coord</sub> and Δ<sub><italic>center</italic></sub> respectively. Thus, segmentation of an image is finished, when the following conditions are met:
<disp-formula id="pone.0207376.e029"><alternatives><graphic xlink:href="pone.0207376.e029.jpg" id="pone.0207376.e029g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M29"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:mi mathvariant="bold-italic">O</mml:mi><mml:mo>−</mml:mo><mml:mi mathvariant="bold-italic">O</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>&lt;</mml:mo><mml:mrow><mml:msub><mml:mi mathvariant="normal">Δ</mml:mi><mml:mrow><mml:mi mathvariant="normal">center</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.50em"/><mml:mi mathvariant="normal">and</mml:mi></mml:mrow><mml:mspace width="0.50em"/><mml:mo>|</mml:mo></mml:mrow><mml:msub><mml:mi mathvariant="bold-italic">P</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi mathvariant="bold-italic">P</mml:mi><mml:msub><mml:mo>′</mml:mo><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>&lt;</mml:mo><mml:msub><mml:mi mathvariant="normal">Δ</mml:mi><mml:mrow><mml:mi mathvariant="normal">coord</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mo>∀</mml:mo><mml:mspace width="0.12em"/><mml:mi>i</mml:mi><mml:mi>ϵ</mml:mi><mml:mi>N</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
where again <bold><italic>P</italic></bold>′<sub><italic>i</italic></sub> and <bold><italic>O</italic></bold>′ are the corresponding values from the previous iteration. Furthermore, the algorithm will terminate the segmentation process of an image after a user-defined, maximum number of segmentation iterations <italic>N</italic><sub><italic>max</italic></sub>, if the convergence condition was not achieved previously. Note that Δ<sub>coord</sub> does not correspond to the segmentation precision <italic>δ</italic><sub>1<italic>σ</italic></sub> of the algorithm, which is discussed further below. Δ<sub>coord</sub> usually has a significantly lower value than <italic>δ</italic><sub>1<italic>σ</italic></sub>, since it is the convergence criterion for an individual image only, while <italic>δ</italic><sub>1<italic>σ</italic></sub> is the result of coordinate fluctuations between images caused by their finite SNR. In case after maximal iterations the convergence criterion is not raised with a given image, the algorithm will restart the segmentation with the next image using the contour coordinates obtained in the former, although not converged. In practice, this does not pose a big problem, since only very few images (0 up to 10, maximum, among several tens thousands of frames in a movie) do not converge. If the criterion is continually not met, when the tolerance is increased, then the image material is considered o insufficient quality.</p>
      </sec>
      <sec id="sec011">
        <title>Refinement of linear fit position</title>
        <p>To avoid artifacts that can arise from performing the linear fit at a location away from where the gradient is the largest, the algorithm determines for each local direction <italic>φ</italic><sub><italic>j</italic></sub> at each <bold><italic>P</italic></bold><sub><italic>i</italic></sub> the position at which <italic>m</italic><sub><italic>j</italic></sub> is maximal. Two methods were conceived for doing this:</p>
        <p><bold>Method 1</bold> For each direction <italic>φ</italic><sub><italic>j</italic></sub> we determine the location of the intensity minimum <italic>I</italic><sub>min</sub> and maximum <italic>I</italic><sub>max</sub> of the halo and situates the center position for the linear fit at the location in-between the two extremes, where the intensity value is similar to <italic>I</italic><sub>center</sub> = <italic>I</italic><sub>min</sub> + (<italic>I</italic><sub>max</sub> − <italic>I</italic><sub>min</sub>)/2. On the programming level this is done by finding the maximum and minimum values in the array <italic>Y</italic><sub><italic>j</italic></sub> holding the intensity values of each direction <italic>φ</italic><sub><italic>j</italic></sub> and then determining the index <italic>ι</italic><sub>cen</sub> of the intensity value that comes closes to the value of <italic>I</italic><sub>center</sub>. The linear fit is then performed over the index-range [<italic>ι</italic><sub>cen</sub> − <italic>f</italic><sub>interp</sub> ∙ <italic>n</italic><sub>fit</sub>/2,<italic>ι</italic><sub>cen</sub> + <italic>f</italic><sub>interp</sub> ∙ <italic>n</italic><sub>fit</sub>/2] of <italic>Y</italic><sub><italic>j</italic></sub>, where <italic>n</italic><sub>fit</sub> is the length over which the linear fit is done (in [px]) and <italic>f</italic><sub>interp</sub> is the number of how many points will be interpolated for each pixel.</p>
        <p><bold>Method 2</bold> In this case the algorithm performs a direct search on <italic>Y</italic><sub><italic>j</italic></sub> for the array-index <italic>ι</italic><sub>cen</sub> at which the incline is maximal. It does this by performing linear fits centered at array-indexes <italic>ι</italic> over the range [<italic>L</italic><sub><italic>Y</italic></sub> − <italic>f</italic><sub>interp</sub> ∙ <italic>N</italic><sub><italic>ι</italic></sub>/2,<italic>L</italic><sub><italic>Y</italic></sub> + <italic>f</italic><sub>interp</sub> ∙ <italic>N</italic><sub><italic>ι</italic></sub>/2], where <italic>L</italic><sub><italic>Y</italic></sub> is the length of the array <italic>Y</italic><sub><italic>j</italic></sub> containing the intensity values (<italic>L</italic><sub><italic>Y</italic></sub> is the same for all <italic>φ</italic><sub><italic>j</italic></sub>), <italic>N</italic><sub><italic>ι</italic></sub> is the user-defined search range and again <italic>f</italic><sub>interp</sub> is the integer of how many points will be interpolated for each pixel. This refined search is performed for each local direction <italic>φ</italic><sub><italic>j</italic></sub>.</p>
        <p>Combined with the various segmentation iterations performed for each movie frame, both methods converge to the position where the intensity gradient is maximal. For images of quasi-circular cell contours, both of the described methods were found to give very similar segmentation performance for the final algorithm and will therefore not be treated separately in the following discussion. However, the second method has a significant advantage in cases, where the halo of the optical image is not pronounced, such as bright-field image recordings of RBC ghosts or of giant unilamellar vesicles (GUVs), which both exhibit poor contrast. In these cases, the first method can fail to correctly determine the position of the <italic>I</italic><sub>min</sub> and <italic>I</italic><sub>max</sub>, rendering the algorithm unusable. The second method is much more robust in these cases. A trade-off, however, is that it is more compute intensive due to the much higher number of linear fits being performed. This results in longer segmentation times. For dense cells, such as RBCs, which provide phase contrast images with high contrast, the first method is therefore usually preferred whose segmentation performance will be analyzed in the following sections.</p>
      </sec>
      <sec id="sec012">
        <title>Implementation on GPU</title>
        <p>The described algorithm was designed to be parallelizable in order to be run on consumer general purpose graphics processing units (GPGPUs). All operation for the local angles <italic>φ</italic><sub><italic>j</italic></sub>, such as the pixel interpolations, linear fits and intercept calculations are run in parallel for all contour coordinates <bold><italic>P</italic></bold><sub><italic>i</italic></sub>, so that all values <bold><italic>p</italic></bold><sub><italic>j</italic>,<italic>i</italic></sub>, <bold><italic>e</italic></bold><sub><italic>j</italic>,<italic>i</italic></sub> and <italic>m</italic><sub><italic>j</italic>,<italic>i</italic></sub> are determined independently of each other during each iteration. The obtained results are then reduced to obtain <bold><italic>P</italic></bold><sub><italic>i</italic></sub> and <bold><italic>n</italic></bold><sub><italic>i</italic></sub> using Eqs (<xref ref-type="disp-formula" rid="pone.0207376.e011">1</xref>) and (<xref ref-type="disp-formula" rid="pone.0207376.e012">2</xref>). A flow chart of the algorithm is shown in <xref ref-type="fig" rid="pone.0207376.g003">Fig 3</xref>, where the region inside the dashed rectangle represents the highly parallelizable section. This design makes the algorithm ideally suited for acceleration on GPUs. Furthermore, since GPUs are specially designed to handle graphics, they possess dedicated hardware units for performing the bi-linear interpolation of the pixel intensities, which greatly accelerates this operation.</p>
        <fig id="pone.0207376.g003" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g003</object-id>
          <label>Fig 3</label>
          <caption>
            <title>Flow-chart of the segmentation algorithm illustrating the steps that are taken in processing the movie.</title>
            <p>The section indicated by the red rectangle indicates the embarrassingly parallel part of the algorithm, which can easily be adapted for parallel processing on a GPU.</p>
          </caption>
          <graphic xlink:href="pone.0207376.g003"/>
        </fig>
        <p>The algorithm was implemented using the Open Compute Language (OpenCL), making the code portable and executable on GPUs from different vendors and also conventional CPUs. Comparing the execution time of our implementation on an AMD Radeon HD 7970 to that of an Intel Xeon 5760, we registered a 100 × speed-up on GPU with respect to the CPU version of the algorithm, when imaging RBCs using the segmentation parameters listed in <xref rid="pone.0207376.t001" ref-type="table">Table 1</xref>. Our implementation of this high-precision flicker spectroscopy contour tracking algorithm (HiPFSTA) has been made publicly available at: <ext-link ext-link-type="uri" xlink:href="http://www.github.com/michaelmell/hipfsta">www.github.com/michaelmell/hipfsta</ext-link></p>
        <p>Analysis of an individual image with five segmentation iterations takes roughly 0.1s. It depends on the number of iterations per image, which for RBCs is usually 3 to 5 iterations using the listed parameter values. Therefore, execution on the GPU enables the processing of movies recorded with the FASTCAM SA-3 in a reasonable time of ~2.2hours (for 8 ∙ 10<sup>4</sup> movie frames of a 40s video recorded at 2000FPS). On the CPU mentioned above this would not be feasible.</p>
      </sec>
    </sec>
  </sec>
  <sec id="sec013">
    <title>Analysis of segmentation performance</title>
    <sec id="sec014">
      <title>Tracked object examples</title>
      <p>In its current form, the algorithm can be applied to spherical and non-spherical objects, which fulfill two requirements: 1) They exhibit a sufficiently strong contrast halo necessary for the algorithm to function correctly. 2) It is possible to uniquely assign an individual radius value <italic>R</italic><sub><italic>i</italic></sub> to a corresponding angle <italic>ϕ</italic><sub><italic>i</italic></sub>, when describing the contour in polar coordinates. The second requirement is the result of the interpolation used to fix the angular position <italic>ϕ</italic><sub><italic>i</italic></sub> of the contour coordinates and could be relieved by conceiving a different method. The segmentation algorithm has so far been successfully applied to various objects including RBCs, <italic>E</italic>. <italic>coli</italic>, GUVs and lymphocytes for which we show example images overlaid with their tracked contour in <xref ref-type="fig" rid="pone.0207376.g004">Fig 4</xref>. All images where obtained using bright-field microscope setup except for the image of <italic>E</italic>. <italic>coli</italic>, which was obtained using a phase-contrast objective. As we will see in the next section, the segmentation precision crucially depends on the optical contrast afforded by the object.</p>
      <fig id="pone.0207376.g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g004</object-id>
        <label>Fig 4</label>
        <caption>
          <title>Examples of microscopic objects that have successfully been tracked using our new segmentation algorithm.</title>
          <p>The obtained contour is indicated by the black line that is overlaid on each image. All images were recorded with bright-field light-microscopy, except for the E. coli, which was recorded using a phase-contrast objective (100x, NA1.45).</p>
        </caption>
        <graphic xlink:href="pone.0207376.g004"/>
      </fig>
    </sec>
    <sec id="sec015">
      <title>Real-space</title>
      <p>Our segmentation algorithm has been developed to overcome the shortcomings detected in the previous algorithm proposed in Ref. [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>], for which we have found that the discretization of the pixel-grid leads to artifacts in the final contour coordinates in the algorithm. The reason for those artifacts is that the initial position for performing the linear fit is confined to the coordinates of the pixel-grid, <italic>i</italic>.<italic>e</italic>. the pixel centers, which determine the coordinates of every point in the halo. When the position of the halo moves against the pixel-grid, this will gradually change the position at which the linear fit is performed and therefore affect the incline <italic>m</italic> of the fitted line as the fit-position draws closer to the intensity minimum or maximum of the halo. This is illustrated in <xref ref-type="fig" rid="pone.0207376.g005">Fig 5A</xref>, where we show three fits at different positions of the intensity profile of the halo. Fitting close to the maximum or minimum alters the incline and consequently the final, tracked contour coordinate. While in reality fitting should not occur this close to the extremes, this effect is still appreciable. <xref ref-type="fig" rid="pone.0207376.g005">Fig 5B</xref> shows the effect of this on the tracked contour of a <italic>synthetic</italic> phase-contrast image of a smooth, structureless circle, where the solid red line represents the position of the phase boundary of the circle used for the image synthesis (see <xref ref-type="sec" rid="sec002">Methods</xref>). For illustration purposes, this synthetic dataset does not contain any noise and thus has an infinity signal-to-noise ratio (SNR = ∞; see <xref ref-type="sec" rid="sec002">Methods</xref>). The dashed black line and the black squares show the pixel position used for fitting in Pécréaux’ algorithm and the tracked contour coordinates. The white diamonds represent the tracked contour coordinates from our algorithm. As can be seen, the contour coordinates calculated from that algorithm move slightly in the opposite direction, when “jumps” in the pixel positions occur. This occurs whenever the pixel position, about which the linear fit is performed, “jumps” transversely to the halo and thus produces a slight change in the incline of the fitted straight <italic>m</italic> as illustrated in <xref ref-type="fig" rid="pone.0207376.g005">Fig 5A</xref>. Thus, although the image does not contain any noise, the algorithm itself causes artifacts in the final contour.</p>
      <fig id="pone.0207376.g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g005</object-id>
        <label>Fig 5</label>
        <caption>
          <title>Image pixilation causes jitter in the positions obtained with the classical algorithm.</title>
          <p>(A) Illustration of how fitting at an off<italic>s</italic>et from the gradient maximum affects the obtained fit-slope and results in a deviation in the final coordinate. (B) Comparison of the reference contour and the contour coordinates obtained from the previous method [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>], and our refined algorithm here described. The artifact described in (A) leads to transverse shifts in the final position (black squares), whenever the pixel-position about which the fit is performed (dashed line) shifts transversely to the contour. The red line represents reference position of the circle used in the synthesis of the image with SNR = ∞, which is shown in the inset indicating the shown area with a white rectangle. The tracked coordinates obtained from the new algorithm (white diamonds) follow the reference position precisely.</p>
        </caption>
        <graphic xlink:href="pone.0207376.g005"/>
      </fig>
      <p>Although this effect is subtle, it can lead to misinterpretations when analyzing the contour coordinates in real-space. This is evident when comparing time series of the contour radii <italic>R</italic>(<italic>ϕ</italic><sub><italic>i</italic></sub>,<italic>t</italic><sub><italic>n</italic></sub>) at a fixed angle <italic>ϕ</italic><sub><italic>i</italic></sub> as produced either by the algorithm in Ref. [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>] or by our algorithm for an artificial lipid vesicle. The distribution of <italic>R</italic>(<italic>ϕ</italic><sub><italic>i</italic></sub>,<italic>t</italic><sub><italic>n</italic></sub>) from the former algorithm exhibits maxima and minima, which are spaced approximately 1px apart as shown in <xref ref-type="fig" rid="pone.0207376.g006">Fig 6A</xref>. This behavior is the direct consequence of the artifact due to pixelation described above (with pixelation we refer to the discretization of the continuous image into the discrete pixel grid). It is the reason we take great care to optimize the fit-location in our algorithm (see <bold>Refinement of linear fit position</bold>) and is not observed in the radius time series obtained from the same dataset using the new segmentation algorithm shown in <xref ref-type="fig" rid="pone.0207376.g006">Fig 6B</xref>.</p>
      <fig id="pone.0207376.g006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g006</object-id>
        <label>Fig 6</label>
        <caption>
          <p>Comparison of the radius fluctuation time-series obtained from a measurement of a POPC GUV using Pécréaux’ algorithm (A) and our algorithm (B). The artifacts from imprecise fitting leads to various maxima in the displacement-distributions spaced 1px apart. This artifact is not present when using our new method.</p>
        </caption>
        <graphic xlink:href="pone.0207376.g006"/>
      </fig>
      <p>In order to quantify the precision of the new algorithm experimentally, we recorded and tracked movies of dried RBCs, which are used as static reference objects. The dried RBC are well suited as reference fluctuation-less objects, since they exhibit a similar level of contrast and halo-shape as living RBCs. Additionally we synthesized computer-generated phase contrast images as proposed by Usenik[<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>]. To determine the segmentation precision, we measure the variability of the contour coordinates obtained with our algorithm. For this, we calculate the distance <italic>δ</italic><sub><italic>i</italic>,<italic>n</italic></sub> between corresponding coordinates at the same contour angle <italic>ϕ</italic><sub><italic>i</italic></sub> from consecutive frames <italic>n</italic> − 1 and <italic>n</italic>, so that <italic>δ</italic><sub><italic>i</italic>,<italic>n</italic></sub> = |<bold><italic>P</italic></bold><sub><bold><italic>i</italic>,<italic>n</italic></bold></sub> − <bold><italic>P</italic></bold><sub><bold><italic>i</italic>,<italic>n</italic>−1</bold></sub>|. Since the contours in the recorded image of dried RBC and the synthetic images are static, this gives us information on how much the contour position varies between frames due to the finite precision of the algorithm. We then calculate the distribution <italic>P</italic> of the inter-coordinate distances <italic>δ</italic><sub><italic>i</italic>,<italic>n</italic></sub> and define its standard-deviation 1<italic>σ</italic> as the segmentation precision <italic>δ</italic><sub>1<italic>σ</italic></sub>. Note that since <italic>δ</italic><sub>1<italic>σ</italic></sub> is obtained from the differences of coordinates pairs its value is expected to be <inline-formula id="pone.0207376.e030"><alternatives><graphic xlink:href="pone.0207376.e030.jpg" id="pone.0207376.e030g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M30"><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:mo>×</mml:mo></mml:math></alternatives></inline-formula> larger than the error of the individual coordinates. The reason we determine the segmentation precision in this manner and not using the radius fluctuation 〈<italic>h</italic>(<italic>t</italic>)<sup>2</sup>〉 = 〈(<italic>R</italic>(<italic>t</italic>) − 〈<italic>R</italic>(<italic>t</italic>)〉)<sup>2</sup>〉 over the whole time-series, is because our method will not be affected by slight shifts in focus or vibrations of the experimental setup, which can occur on time-scales of various seconds. The positional accuracy can be estimated theoretically by determining the error in the x-position <italic>σ</italic><sub><italic>x</italic></sub> of the intercept between the linear regression of the intensity gradient with slope <italic>m</italic> and the average image intensity 〈<italic>I</italic>〉. This straight forward calculation yields (see SM):
<disp-formula id="pone.0207376.e031"><alternatives><graphic xlink:href="pone.0207376.e031.jpg" id="pone.0207376.e031g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M31"><mml:msub><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>I</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:mfrac><mml:msqrt><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>U</mml:mi></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:mfrac></mml:msqrt></mml:math></alternatives><label>(3)</label></disp-formula>
with standard deviation <italic>σ</italic><sub><italic>I</italic></sub> of the image intensity and the slope <italic>m</italic> of the intensity halo. The proportionality constant <inline-formula id="pone.0207376.e032"><alternatives><graphic xlink:href="pone.0207376.e032.jpg" id="pone.0207376.e032g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M32"><mml:msqrt><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>U</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>T</mml:mi></mml:msqrt></mml:math></alternatives></inline-formula> depends on the number of fitted values <italic>U</italic> and averaged intensity values <italic>T</italic>. Note that <italic>σ</italic><sub><italic>x</italic></sub> does not correspond directly to <italic>δ</italic><sub>1<italic>σ</italic></sub>. As mentioned above <italic>δ</italic><sub>1<italic>σ</italic></sub> is <inline-formula id="pone.0207376.e033"><alternatives><graphic xlink:href="pone.0207376.e033.jpg" id="pone.0207376.e033g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M33"><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:mo>×</mml:mo></mml:math></alternatives></inline-formula> larger than the coordinate error, which in turn are the weighted average of <italic>M</italic> fits in the directions of the local angles <italic>φ</italic><sub><italic>j</italic></sub>, each of which possess a different error <italic>σ</italic><sub><italic>x</italic></sub> due to different slopes <italic>m</italic> (see <xref ref-type="fig" rid="pone.0207376.g002">Fig 2(C)</xref>). However, the proportionality <italic>δ</italic><sub>1<italic>σ</italic></sub> ∝ <italic>σ</italic><sub><italic>I</italic></sub>/<italic>m</italic> should remain unchanged, since the directions with largest slope <italic>m</italic> will dominated the weighted sum. To test the theoretical estimate, we determine the segmentation precision for images with different signal-to-noise ratios (SNR) and contrast levels (different <italic>m</italic>) using synthetic images (see <xref ref-type="sec" rid="sec002">Methods</xref>). The segmentation precision <italic>δ</italic><sub>1<italic>σ</italic></sub> is inversely proportional to the image SNR, <italic>δ</italic><sub>1<italic>σ</italic></sub> ∝ 1/SNR as can be seen in <xref ref-type="fig" rid="pone.0207376.g007">Fig 7A</xref>. After renormalizing the abscissa to <italic>σ</italic><sub><italic>I</italic></sub>/<italic>m</italic> all data points fall onto single line confirming <italic>δ</italic><sub>1<italic>σ</italic></sub> = <italic>σ</italic><sub><italic>I</italic></sub>/<italic>m</italic> ∙ <italic>K</italic> with proportionality constant <italic>K</italic>. We can compare the value of <italic>K</italic> to that of <inline-formula id="pone.0207376.e034"><alternatives><graphic xlink:href="pone.0207376.e034.jpg" id="pone.0207376.e034g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M34"><mml:msqrt><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>U</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>T</mml:mi></mml:msqrt></mml:math></alternatives></inline-formula> to obtain an estimate of the precision improvement due to the weighted averages (see Eq (<xref ref-type="disp-formula" rid="pone.0207376.e011">1</xref>)) compared to a single fit. Although each fit consists of <italic>n</italic><sub>fit</sub> data-points (see <xref rid="pone.0207376.t001" ref-type="table">Table 1</xref>) the number of <italic>independent</italic> pixel values being fit is actually <italic>U</italic> = <italic>n</italic><sub>fit</sub>/<italic>f</italic><sub>interp</sub> = 5. Accordingly, <italic>T</italic> = <italic>n</italic><sub>bkgr</sub>/<italic>f</italic><sub>interp</sub> = 20 for the number of <italic>independent</italic> pixel values being averaged for the background intensity. We therefore have <inline-formula id="pone.0207376.e035"><alternatives><graphic xlink:href="pone.0207376.e035.jpg" id="pone.0207376.e035g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M35"><mml:msqrt><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>U</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>T</mml:mi></mml:msqrt><mml:mo>=</mml:mo><mml:mn>0.5</mml:mn></mml:math></alternatives></inline-formula>. From <xref ref-type="fig" rid="pone.0207376.g007">Fig 7B</xref>, we obtain the proportionality constant <italic>K</italic> = 0.54. Taking into account the factor <inline-formula id="pone.0207376.e036"><alternatives><graphic xlink:href="pone.0207376.e036.jpg" id="pone.0207376.e036g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M36"><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:math></alternatives></inline-formula> from calculating <italic>δ</italic><sub>1<italic>σ</italic></sub>, we estimate an improvement of <inline-formula id="pone.0207376.e037"><alternatives><graphic xlink:href="pone.0207376.e037.jpg" id="pone.0207376.e037g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M37"><mml:mn>0.5</mml:mn><mml:mo>/</mml:mo><mml:mo>(</mml:mo><mml:mn>0.54</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>1.31</mml:mn></mml:math></alternatives></inline-formula>.</p>
      <fig id="pone.0207376.g007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g007</object-id>
        <label>Fig 7</label>
        <caption>
          <title>Segmentation precision depends on image noise and the slope of the intensity gradient.</title>
          <p>(A) Segmentation precision <italic>δ</italic><sub>1<italic>σ</italic></sub> versus 1/<italic>SNR</italic> for a dried RBC at different exposure times (‘<sub>*</sub>’) and for three synthetic datasets (‘□,○ and Δ’) with different level of contrasts/slopes <italic>m</italic>. The precision values from each dataset fall onto a straight determined by the contrast/slope <italic>m</italic>. (B) After renormalizing x-axis to <italic>σ</italic><sub><italic>i</italic></sub>/<italic>m</italic> all values fall onto a straight <italic>y</italic> = 0.54 ∙ <italic>x</italic> allowing for easy estimation of the segmentation precision from the two known quantities <italic>σ</italic><sub><italic>i</italic></sub> and <italic>m</italic>. Note that the contrast/slope values are for to unit background intensity.</p>
        </caption>
        <graphic xlink:href="pone.0207376.g007"/>
      </fig>
      <p>From Eq (<xref ref-type="disp-formula" rid="pone.0207376.e031">3</xref>) it follows that we can improve segmentation precision by increasing the SNR of the image through higher illumination intensity or longer exposure times. Furthermore, the amount of contrast produced at the object boundary plays a crucial role in determining how precise the algorithm is able to track its contour, since it determines <italic>m</italic>. Moreover, since <italic>m</italic> and <italic>σ</italic><sub><italic>I</italic></sub> are easily obtained from a single image, this allows for simple estimation of the expected segmentation precision. <xref rid="pone.0207376.t002" ref-type="table">Table 2</xref> lists the data shown in <xref ref-type="fig" rid="pone.0207376.g007">Fig 7</xref>. As indicated, we achieve a positional accuracy <italic>δ</italic><sub>1<italic>σ</italic></sub> of 0.01px to 0.03px for SNR-values of 127 to 84 corresponding to typical experimental frame rates of 1500 to 3000fps. For our setup with an effective pixel-size of 50nm this translates into a positional accuracy of below 0.9nm to 1.25nm for dried RBCs specimens. We also estimated the precision for RBCs and GUVs in buffer, which exhibit a lower contrast and therefore lower value for <italic>m</italic>. We find 0.05px and 0.3px respectively using values for <italic>m</italic> taken from bright field microscopy observations. For completeness we also include the value of <inline-formula id="pone.0207376.e038"><alternatives><graphic xlink:href="pone.0207376.e038.jpg" id="pone.0207376.e038g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M38"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>σ</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:math></alternatives></inline-formula>, which is expected to represent the error an individual coordinate, instead of their difference. For a RBC in buffer, we estimate a value of <inline-formula id="pone.0207376.e039"><alternatives><graphic xlink:href="pone.0207376.e039.jpg" id="pone.0207376.e039g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M39"><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mi>σ</mml:mi></mml:mrow></mml:msub><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt><mml:mo>=</mml:mo><mml:mn>0.04</mml:mn><mml:mi mathvariant="normal">px</mml:mi></mml:math></alternatives></inline-formula> corresponding to 1.85nm.</p>
      <table-wrap id="pone.0207376.t002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0207376.t002</object-id>
        <label>Table 2</label>
        <caption>
          <title>Values for the dried RBC datasets compared to RBCs and GUVs in buffer solution.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0207376.t002g" xlink:href="pone.0207376.t002"/>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="1" colspan="1"/>
                <th align="center" rowspan="1" colspan="1">RBC<sub>dried</sub></th>
                <th align="center" rowspan="1" colspan="1">RBC<sub>dried</sub></th>
                <th align="center" rowspan="1" colspan="1">RBC<sub>dried</sub></th>
                <th align="center" rowspan="1" colspan="1">RBC<sub>dried</sub></th>
                <th align="center" rowspan="1" colspan="1">RBC<sub>dried</sub></th>
                <th align="center" rowspan="1" colspan="1">RBC<sub>dried</sub></th>
                <th align="center" rowspan="1" colspan="1">RBC<sub>buffer</sub></th>
                <th align="center" rowspan="1" colspan="1">GUV</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" rowspan="1" colspan="1">FPS</td>
                <td align="center" rowspan="1" colspan="1">1500</td>
                <td align="center" rowspan="1" colspan="1">2000</td>
                <td align="center" rowspan="1" colspan="1">3000</td>
                <td align="center" rowspan="1" colspan="1">6000</td>
                <td align="center" rowspan="1" colspan="1">10000</td>
                <td align="center" rowspan="1" colspan="1">15000</td>
                <td align="center" rowspan="1" colspan="1">2000</td>
                <td align="center" rowspan="1" colspan="1">1500</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">SNR</td>
                <td align="center" rowspan="1" colspan="1">127.3</td>
                <td align="center" rowspan="1" colspan="1">106.8</td>
                <td align="center" rowspan="1" colspan="1">83.9</td>
                <td align="center" rowspan="1" colspan="1">55.2</td>
                <td align="center" rowspan="1" colspan="1">40.1</td>
                <td align="center" rowspan="1" colspan="1">30.4</td>
                <td align="center" rowspan="1" colspan="1">101.5</td>
                <td align="center" rowspan="1" colspan="1">137.9</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <italic>m</italic>
                </td>
                <td align="center" rowspan="1" colspan="1">0.2355</td>
                <td align="center" rowspan="1" colspan="1">0.251</td>
                <td align="center" rowspan="1" colspan="1">0.259</td>
                <td align="center" rowspan="1" colspan="1">0.272</td>
                <td align="center" rowspan="1" colspan="1">0.272</td>
                <td align="center" rowspan="1" colspan="1">0.273</td>
                <td align="center" rowspan="1" colspan="1">0.1</td>
                <td align="center" rowspan="1" colspan="1">0.014</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1"><italic>σ</italic><sub>I</sub>/<italic>m</italic></td>
                <td align="center" rowspan="1" colspan="1">0.033</td>
                <td align="center" rowspan="1" colspan="1">0.037</td>
                <td align="center" rowspan="1" colspan="1">0.046</td>
                <td align="center" rowspan="1" colspan="1">0.067</td>
                <td align="center" rowspan="1" colspan="1">0.092</td>
                <td align="center" rowspan="1" colspan="1">0.120</td>
                <td align="center" rowspan="1" colspan="1">0.097</td>
                <td align="center" rowspan="1" colspan="1">0.517</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1"><italic>δ</italic><sub>1</sub><italic>σ</italic>[px]</td>
                <td align="center" rowspan="1" colspan="1">0.018</td>
                <td align="center" rowspan="1" colspan="1">0.021</td>
                <td align="center" rowspan="1" colspan="1">0.025</td>
                <td align="center" rowspan="1" colspan="1">0.037</td>
                <td align="center" rowspan="1" colspan="1">0.051</td>
                <td align="center" rowspan="1" colspan="1">0.068</td>
                <td align="center" style="background-color:#FFFFFF" rowspan="1" colspan="1">0.052*</td>
                <td align="center" style="background-color:#FFFFFF" rowspan="1" colspan="1">0.279*</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1"><italic>δ</italic><sub>1<italic>σ</italic></sub><italic>/</italic>2<sup>½</sup> [px]</td>
                <td align="center" rowspan="1" colspan="1">0.013</td>
                <td align="center" rowspan="1" colspan="1">0.015</td>
                <td align="center" rowspan="1" colspan="1">0.018</td>
                <td align="center" rowspan="1" colspan="1">0.026</td>
                <td align="center" rowspan="1" colspan="1">0.036</td>
                <td align="center" rowspan="1" colspan="1">0.048</td>
                <td align="center" style="background-color:#FFFFFF" rowspan="1" colspan="1">0.037*</td>
                <td align="center" style="background-color:#FFFFFF" rowspan="1" colspan="1">0.197*</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
        <table-wrap-foot>
          <fn id="t002fn001">
            <p>Values for the dried RBC datasets shown in <xref ref-type="fig" rid="pone.0207376.g007">Fig 7</xref> compared to typical values for measurements of RBCs and GUVs in buffer solution. The imaging precision δ<sub>1σ</sub> and δ<sub>1σ</sub>/2<sup>½</sup>for the latter two cases was extrapolated from their values for <italic>σ</italic><sub><italic>I</italic></sub>/<italic>m</italic> using the equation δ<sub>1σ</sub> = 0.54 σ<sub>I</sub>/m (indicated by *).</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The segmentation precisions for GUVs previously reported by Pécréaux [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>] and Usenik [<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>] are not exactly comparably to our results, since these authors used phase-contrast, instead of bright field microscopy. We can however attempt to estimate the precision that we would expect from our algorithm. From Eq (<xref ref-type="disp-formula" rid="pone.0207376.e011">1</xref>) and <xref ref-type="fig" rid="pone.0207376.g001">Fig 1</xref> we estimate an intensity-normalized <italic>m</italic> = ((<italic>I</italic><sub>max</sub> − <italic>I</italic><sub>min</sub>)/〈I〉)/<italic>n</italic><sub>pix</sub> = ((525 − 435)/480)/8px, where <italic>I</italic><sub>min</sub> and <italic>I</italic><sub>max</sub> are the minimum and maximum intensity of the halo, 〈<italic>I</italic>〉 is the average and <italic>n</italic><sub>pix</sub> is the number of pixels in the gradient-range. For <italic>σ</italic><sub><italic>I</italic></sub> we estimate <italic>σ</italic><sub><italic>I</italic></sub> = 3/〈<italic>I</italic>〉 = 0.007, assuming a standard deviation of 3 grey level units. Using these values we obtain an estimated segmentation precision of <italic>δ</italic><sub>1<italic>σ</italic></sub> = 0.54 ∙ <italic>σ</italic>/<italic>m</italic> = 0.16px, which is comparable to the 0.1px-precission that Pécréaux claimed for his algorithm [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. Usenik et al. [<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>] claimed a precision of 26.9 to 34.1nm for their algorithm at a pixel-size of 35nm. Therefore, their precision is not significantly below pixel-size and we expect our algorithm to perform significantly better. However, the value for the latter case was achieved at SNR = 23 dB, which for our SNR-definition corresponds to a very low SNR = 10<sup>23/20</sup> = 14.13 (see <xref ref-type="sec" rid="sec002">Methods</xref>). Finally, for RBCs, the accuracy of our new software implementable with contrast imaging is competitive with other sophisticated microscopy hardware such as the diffraction phase microscope [<xref rid="pone.0207376.ref033" ref-type="bibr">33</xref>] used by the authors of references [<xref rid="pone.0207376.ref009" ref-type="bibr">9</xref>,<xref rid="pone.0207376.ref012" ref-type="bibr">12</xref>,<xref rid="pone.0207376.ref034" ref-type="bibr">34</xref>], who report an accuracy of 3.3nm for the RBCs thickness-fluctuations due to the DPMs limited optical path stability [<xref rid="pone.0207376.ref022" ref-type="bibr">22</xref>,<xref rid="pone.0207376.ref033" ref-type="bibr">33</xref>]. However, their experimental setup uses a 40× (NA0.65) oil-immersion objective with 400nm resolution. Since we use an oil-immersion objective with 100 × magnification (NA 1.4), we should have better lateral resolution along the contour, which should translate into a diffraction-limited lateral resolution of around 200nm. The proposed method deals with the analysis of the contrast halo, which has been implemented as a super-localization software that allows contour segmentation at sub-pixel resolution with bright field/phase contrast images. However, our super-localization method can be considered broader in scope, as potentially implementable with other optical settings no dealing with contrast halos. In dark-field, for instance, amplitude dependent glows formed at the rim of the object are potentially detectable by our software. Cells with sufficient optical contrast, such as RBCs, may be efficiently segmented using images obtained upon a high scattering luminosity. Differential interference contrast (DIC) has no halo yet, however, contour segmentation could be performed after image integration leading to sufficient membrane contrast.</p>
      <sec id="sec016">
        <title>Fourier space analysis</title>
        <p>To analyze the performance of our algorithm in Fourier space and quantify the effect that limited segmentation accuracy has on, we calculate the spectra obtained from the synthesized datasets. Calculation of the spectra is done as described by Pécréaux [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. Briefly, a tracked contour (<italic>R</italic><sub><italic>i</italic></sub>,<italic>ϕ</italic><sub><italic>i</italic></sub>) is transformed into a height-profile (<italic>h</italic><sub><italic>i</italic></sub>,<italic>ϕ</italic><sub><italic>i</italic></sub>) above and below a circular equilibrium radius <italic>R</italic>. The <italic>h</italic><sub><italic>i</italic></sub> are then decomposed into their Fourier components, <italic>n</italic>, which for the continuous case can be written as
<disp-formula id="pone.0207376.e040"><alternatives><graphic xlink:href="pone.0207376.e040.jpg" id="pone.0207376.e040g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M40"><mml:mi>h</mml:mi><mml:mo>(</mml:mo><mml:mrow><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mrow><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi mathvariant="normal">∞</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mspace width="0.25em"/><mml:mrow><mml:mrow><mml:mi mathvariant="normal">cos</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mspace width="0.25em"/></mml:mrow></mml:msub><mml:mrow><mml:mrow><mml:mi mathvariant="normal">sin</mml:mi></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mi>ϕ</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:math></alternatives></disp-formula>
where <italic>R</italic> is the equilibrium radius of the contour. The spectrum is then given by the RMSD of the modulus <inline-formula id="pone.0207376.e041"><alternatives><graphic xlink:href="pone.0207376.e041.jpg" id="pone.0207376.e041g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M41"><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:msqrt></mml:math></alternatives></inline-formula>. The spectrum is then given by the RMSD of the modulus <inline-formula id="pone.0207376.e042"><alternatives><graphic xlink:href="pone.0207376.e042.jpg" id="pone.0207376.e042g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M42"><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:msqrt><mml:msubsup><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:msqrt></mml:math></alternatives></inline-formula>. Here we use the normalization proposed by Pécréaux [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>], so that absolute values are directly comparable to his work. The final spectrum is then given by
<disp-formula id="pone.0207376.e043"><alternatives><graphic xlink:href="pone.0207376.e043.jpg" id="pone.0207376.e043g" mimetype="image" position="anchor" orientation="portrait"/><mml:math id="M43"><mml:mi>〈</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mi>〉</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>π</mml:mi><mml:msup><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>〉</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>(</mml:mo><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mi>〉</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mi>〈</mml:mi><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>〉</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo><mml:mo>,</mml:mo></mml:math></alternatives></disp-formula>
where the wavenumber <italic>q</italic> relates to the mode number <italic>n</italic> through <italic>q</italic> = <italic>n</italic>/<italic>R</italic>.</p>
        <p>Above a given wavenumber compatible with a minimal resolvable wavelength, the segmentation algorithm in Ref. [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>] produces a spectrum dominated by noise, which continues to increase towards higher wavenumbers. The authors attribute this to the discrete detection of the contour, which causes an increased floor noise as the wavelength of the mode becomes smaller than 4 × pixel-size. He therefor argues that as a result of a such discretization there exist two main limitation to his algorithm: 1) the amplitude precision orthogonal to the contour, and 2) the sampling precision in parallel to the contour [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>].</p>
        <p>The spectra obtained for the synthetic spherical object with the new algorithm have a significantly different shape than the one obtained from Pécréaux’ algorithm (see Figs <xref ref-type="fig" rid="pone.0207376.g008">8</xref> and <xref ref-type="fig" rid="pone.0207376.g009">9</xref>). Whereas our algorithm yields a spectral shape that is compatible with the pixel-grid structure, the algorithm in Ref. [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>], however, yields spurious amplitudes in the whole range of wavenumbers analyzed. Indeed, our algorithm computes lower amplitudes, which are compatible with the level of noise artificially introduced for these ideal spherical objects. A representative example is shown in <xref ref-type="fig" rid="pone.0207376.g008">Fig 8</xref> and compared to the spectrum obtained from Pécréaux’ algorithm for a synthesized dataset (SNR = 106.7). The shape of the fluctuation spectrum is reminiscent of a sinc-function, with its first minimum located roughly at the wavenumber <italic>q</italic><sub>pix</sub> corresponding to the size of 1px. This spectrum represents the spectral noise floor resulting from the finite SNR of the synthesized images. It is the result of the noise of the individual pixels, whose influence on the final spectrum is convoluted with the frequency response of the linear interpolation used in the segmentation algorithm. A linear interpolation can be written as a convolution of the sample values with triangular pulse [<xref rid="pone.0207376.ref035" ref-type="bibr">35</xref>], whose Fourier transform and thus frequency response is proportional to a sinc<sup>2</sup> function. It is this dependency of the form factor of static objects, which causes the noise floor <italic>not</italic> to be evenly distributed across the spectrum, but to follow a sinc-like shape corresponding to the structure form factor of noisy pixels. By changing the pixel size in the synthesized images, we confirm the inverse scaling behavior expected for the pixel-structure form factor (see <xref ref-type="fig" rid="pone.0207376.g009">Fig 9A</xref>). Note that it is therefore possible to change the shape of the spectral noise floor by changing the effective pixel-size either experimentally or through binning and other forms of digital image pre-processing, such as rescaling with bi-cubic interpolation.</p>
        <fig id="pone.0207376.g008" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g008</object-id>
          <label>Fig 8</label>
          <caption>
            <title>Comparison of spectra obtained from the same dataset (SNR = 106.7) using the new and old algorithm.</title>
            <p>The spectrum from the old algorithm increase at high <italic>q</italic>, since the pixilation artifact causes increased noise as the wavelength draws closer to the pixel-size. The spectrum from the new algorithm exhibits a minimum at the location corresponding to wavenumber <italic>q</italic><sub>pix</sub> of a pixel.</p>
          </caption>
          <graphic xlink:href="pone.0207376.g008"/>
        </fig>
        <fig id="pone.0207376.g009" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g009</object-id>
          <label>Fig 9</label>
          <caption>
            <title>Shape and level of the noise floor depends on the pixel size and SNR.</title>
            <p>(A) Illustration of the inverse scaling behavior of the spectrum with pixel size. 1 × px corresponds to the experimental pixel size. The shape of the noise floor is the result of the pixel-noise being convoluted with kernel from the linear interpolation. (B) Plot of the spectra obtained for different SNRs. The noise floor decreases for higher (better) SNRs. At high SNRs (SNR ≥ 10<sup>4</sup>) it begins to enter the noise due to numeric imprecision. Since this noise is independent of pixels, spectrum for SNR = ∞ is flat (red line).</p>
          </caption>
          <graphic xlink:href="pone.0207376.g009"/>
        </fig>
        <p>Our findings lead us to a slightly different conclusion of the spectral increase of Pécréaux’ algorithm at large wavenumbers. Considering the Nyquist-Shannon sampling theorem the theoretical cutoff for spatial frequencies that can still be resolved is <italic>q</italic><sub>Ny</sub> = <italic>N</italic>/(2 ∙ <italic>R</italic>) [<xref rid="pone.0207376.ref036" ref-type="bibr">36</xref>]. For Pécréaux’ algorithm with on average one contour coordinate point per pixel this should approximately be the inverse of two times the wavenumber of the image pixel-size: <italic>q</italic><sub>Ny</sub> ~ <italic>q</italic><sub>pix</sub>/2. Modes with wavenumbers <italic>q</italic> &gt; <italic>q</italic><sub>Ny</sub> should exhibit aliasing and therefor increase in spectral amplitude. This is observed for synthetic datasets using our algorithm, when <italic>q</italic> &gt; <italic>q</italic><sub>Ny</sub> = <italic>N</italic>/(2 ∙ <italic>R</italic>) = 2048/(2 ∙ 61px) = 16.8px<sup>−1</sup> (see SM). The fact that the cross-over wavenumber <italic>q</italic><sub>c</sub> above which noise starts dominating in Pécréaux’ algorithm is much smaller than <italic>q</italic><sub>c</sub> = <italic>q</italic><sub>pix</sub>/2, suggests that the observed increase in spectral amplitude is primarily due to the artifacts in the determined orthogonal contour positions (see Figs <xref ref-type="fig" rid="pone.0207376.g005">5</xref> and <xref ref-type="fig" rid="pone.0207376.g006">6</xref>). These transverse artifacts due to pixelation will increasingly affect the mode amplitudeswhen the modes’ wavenumbers become similar to <italic>q</italic><sub>pix</sub>. The new segmentation algorithm does not produce these artifacts in the transverse coordinate, neither propagates errors along the longitudinal position in the contour, differently to the previous method, which determines coordinates in a given point from the formers. That method is thus prone to propagate possible errors to adjacent points in the contour, which favors (in Fourier space) multiplicative deviations at high wavenumbers (<italic>q</italic> ≥ <italic>q</italic><sub><italic>px</italic></sub>), just in the region where it becomes inapplicable.</p>
        <p>To better understand the effect of image noise on the resulting spectrum from our algorithm, we synthesized various datasets at different SNRs. The synthetized images correspond to ideal circular contours with a pixelation noise superposed. As expected, the noise floor decreases with increasing SNR (see <xref ref-type="fig" rid="pone.0207376.g009">Fig 9A</xref>), which can be interpreted as the form-factor of the noisy pixel-grid; this is, in Fourier space, the convolution between an instrumental white noise (the electronic noise introduced by the camera) with the linearly-interpolated square grid the contour is embedded. At very high SNRs the numerical precision of the segmentation algorithm itself becomes the limiting factor. Since it is independent of the images’ pixels, it results in a <italic>q</italic>-independent noise floor in the spectrum that for SNR ≥ 10<sup>4</sup> increasingly dominates the high-<italic>q</italic> range of the spectral noise floor from pixel-noise, until it is the only noise component at SNR = ∞. This suggests that the segmentation precision of our algorithm may experimentally only be limited by the image SNR and in the future could be improved by using new low-noise, digital imaging devices such as scientific CMOS (sCMOS) cameras [<xref rid="pone.0207376.ref037" ref-type="bibr">37</xref>].</p>
      </sec>
      <sec id="sec017">
        <title>Experimental fluctuation spectra</title>
        <p>Although this work is almost focused in the description of the algorithmic aspects of our improved segmentation method, we will finish by discussing on its applicability to study the spectrum of the membrane fluctuations in real fluctuating objects. <xref ref-type="fig" rid="pone.0207376.g010">Fig 10</xref> compares the results obtained from our proposed algorithm with those from the Pecréaux’ method, in two very different cases: A) Thermal fluctuations in giant unilamellar vesicles (GUVs) made of a very flexible, single lipid (POPC) bilayer membrane, and a relatively low optical contrast between the vesicle lumen and the exterior. B) Membrane fluctuations in healthy red blood cells (RBCs) with a complex lipid bilayer coupled to a rigid spectrin skeleton. Due to the presence of high amounts of hemoglobin, and other cytoplasmic proteins, the optical contrast is in this case much higher than with the former case of empty GUVs. The upper images correspond to instantaneous photographs of the near-circular fluctuating objects at the equatorial plane, and the lower plots represent the amplitude spectra of the membrane fluctuations as decomposed in Fourier space (see section “Fourier space analysis”). In the case of flexible GUVs, the amplitude of the shape fluctuations is large, which makes the spectral amplitudes to be quite high, and resolvable, at low wavenumbers corresponding to distances larger than the pixel grid (<italic>q</italic><sub><italic>pix</italic></sub> = 1.25 10<sup>−7</sup> m<sup>-1</sup>). At <italic>q</italic> &lt;&lt; <italic>q</italic><sub><italic>pix</italic></sub> both algorithms give almost identical results, which indicates the mutual robustness of the two segmentation algorithms to determine spatial correlations between membrane elements separated far beyond one pixel. However, since the optical contrast is low in this case, hence the SNR quite low, then the floor noise arising from contour pixelation is rather high, at <italic>q</italic> ≥ <italic>q</italic><sub><italic>pix</italic></sub> becoming of the same order as the fluctuation amplitudes (see <xref ref-type="fig" rid="pone.0207376.g010">Fig 10A</xref> bottom). In that high-q regime (<italic>q</italic> &gt; <italic>q</italic><sub><italic>pix</italic></sub>), the new algorithm calculates spectral amplitudes that correspond to the structure factor of the pixelized contour, which is nearly describable as a sinc-like function that can be considered the floor noise intrinsic to the considered optical configuration (see <xref ref-type="fig" rid="pone.0207376.g009">Fig 9</xref>). However, the Pecréaux’ algorithm returns in this regime spurious values of the spectral amplitudes, which arise from the sub-pixel artifacts described above. As a consequence, Pécréaux’ method is quite limited in this sub-pixel regime, where the spectral amplitudes become chiefly determined by a high pixelation noise, in this case dominated by the errors in discriminating the positions of very neighboring points in the contour. Our method, however, is very robust in determining the contour position independently of the radial direction chosen, which makes the segmentation uncertainty independent of the lateral distance between two points along the contour. In our method, consequently, the pixelation noise is just minimal, and stands at the value corresponding to the instrumental noise of the image obtained from a given optical configuration. This situation becomes especially evident with RBC images (see <xref ref-type="fig" rid="pone.0207376.g010">Fig 10B</xref>), where the higher optical contrast allows a higher SNR that translates into a much lower pixelation floor noise than in less contrasted GUV membranes. For RBCs, and other real cells, the sinc-like structure factor of the pixel grid is more than 10-fold lower than for GUVs, allowing for robust analysis of the fluctuation amplitudes at much higher wavenumbers than the previous methods. A notable advantage of the proposed algorithm, associated to its intrinsic robustness and low uncertainty in lateral segmentation, is that the floor noise due to pixelation is completely recognizable and predictable, which allows for correct identification and eventual subtraction from further deconvolution analysis. From the compared analysis above, it seems quite clear that the proposed algorithm can bring improved measurements that result in newer, and deeper, analyses than possible with former approaches.</p>
        <fig id="pone.0207376.g010" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0207376.g010</object-id>
          <label>Fig 10</label>
          <caption>
            <title>Example flicker spectra of GUV and RBC datasets obtained with the classical and new segmentation algorithms.</title>
            <p>Top panels: Instantaneous snapshot of a fluctuating GUV made of POPC (A) a healthy RBC undergoing flicker motions (B). The microscopy images are taken with a CMOS camera in the PhC mode at the equatorial plane of the quasi-spherical objects (see <xref ref-type="sec" rid="sec002">Methods</xref> for details), and correspond to one frame taken arbitrarily in a movie recorded at 6kfps. Lower panels: Fourier space fluctuation spectra obtained from the statistical analysis of the membrane contour fluctuations. Results from the proposed new contour-segmentation algorithm are compared with results from the classical algorithm described in [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. The pixelation form-factor, as empirically obtained from optically equivalent synthetic contours (non-fluctuating but including similar noise than the CMOS camera), are plotted as dashed lines with the characteristic sinc-like shape of a squared pixel grid. These lines represent the minimal floor noise corresponding to the instrumental “fluctuations” due to the electronic noise of the CMOS camera implemented with the current optical configuration. The wavenumber corresponding to a distance of one-pixel in Fourier space is plotted as a vertical dotted line labelled q<sub>px</sub> = 2π/px.</p>
          </caption>
          <graphic xlink:href="pone.0207376.g010"/>
        </fig>
      </sec>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec018">
    <title>Conclusion</title>
    <p>We have developed a high-precision flicker spectroscopy contour tracking algorithm based on an intensity-gradient segmentation schema (HiPFSTA, available open-source at <ext-link ext-link-type="uri" xlink:href="http://www.github.com/michaelmell/hipfsta">www.github.com/michaelmell/hipfsta</ext-link>), which is designed to run on graphical processing units and makes extensive use of image-oversampling using the processing power of these processors. Segmentation precision was tested using images of dried RBC and synthetic images and quantified in real-space as well as Fourier space, relevant for flickering spectroscopy. The algorithm was shown to achieve segmentation precision down to 2nm for experimental images of dried RBCs at SNRs of about 100, which corresponds to frames rate of 2000fps in our experimental setup using a high-velocity CMOS camera (FASTCAM SA-3, Photron). The segmentation precision was shown to depend on the optical contrast of the observed object and the SNR of the image. Results from the spectra in Fourier space of synthetic images suggest that segmentation precision is mainly limited by the image SNR opening the possibility for future improvements to the experimental setup with newly developed, low-noise scientific CMOS (sCMOS) sensors [<xref rid="pone.0207376.ref037" ref-type="bibr">37</xref>].</p>
    <p>The segmentation precision of our algorithm was found to be significantly better than that reported for the previous methods by Usenik [<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>] and Pécréaux [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>], who reported precisions of 25 to 36nm for the position of the cell contour and an estimated 0.1px, respectively. The latter method was directly compared to our algorithm and found to exhibit significant segmentation artifacts, the source of which was concluded to be its partial dependence on the pixel grid. These artifacts were also found to be the reason for the spurious increase in spectral amplitudes in Fourier space towards high wavenumbers, which limited the observable <italic>q</italic>-range to the first fifty modes in the previous method [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>]. This artifact, and associated properties, are not exhibited by the new algorithm, which can be practically extended up to much higher Fourier modes (<italic>n</italic><sub><italic>max</italic></sub> ≈ 1000), ranging in the microscopic domain (<italic>q</italic><sub><italic>max</italic></sub> ≈ 0.3 nm<sup>-1</sup>), where the fluctuation dynamics of the cytoskeleton elements can be probed over nanoscopic distances, <italic>d</italic> ≈ 2π/<italic>q</italic><sub><italic>max</italic></sub> ≈ 20 nm. The robustness of the proposed algorithm is largely superior to previous approaches to cell contour segmentation of microscopy images, in terms not only of transverse accuracy (essential to exactly determine the amplitude of the fluctuations with sub-pixel precision) but also of lateral resolution (crucial to extend spatial Fourier analysis below sub-pixel longitudinal distances). Our algorithm, and its implementation with GPU’s, has minimized the number of computational artifacts associated to any sub-pixel interpolation, so under optimal optical performance (high contrast and low camera noise), it is able to work within the instrumental limit, which determines a perfectly detectable and analyzable floor noise. The high precision of our optical microscopy method is comparable to the precision of much more sophisticated methods, such as interferometric microscopy. Our method is complementary, since their interferometric method gives a two-dimensional height map of the cell, while our method yields the membrane displacement at the equatorial plane. Finally, the spatial precision and temporal sampling rate of our method is comparable to those reported for tracking methods with optical traps. However, our method gives us access to the whole cell contour, whereas optical traps are only able to probe single points of the membrane. Finally, the new algorithm was shown to be usable for biological cells with different properties and shapes, including RBC, <italic>E</italic>. <italic>coli</italic> and lymphocytes as well as biomimetic objects such as giant unilamellar vesicles. It is expected that this method will allow for much more refined results, when applied to RBC and other mechanically compliant cells, which may yield new insights into their cell-mechanics using conventional optical contrast microscopy. The method is sufficiently robust and versatile that is potentially adaptable to other optical modes and microscopy settings.</p>
  </sec>
  <sec id="sec019">
    <title>Materials and preparation methods</title>
    <sec id="sec020">
      <title>Microscope and camera</title>
      <p>The experimental setup consisted of a Nikon Ti2000 microscope equipped with a 100 × (NA1.4) bright-field objective followed by additional 1.5 × and 2.25 × optical zooms giving a total 337.5 × zoom. This optical system images onto a Photron FASTCAM SA-3 high-speed digital camera with CMOS sensor capable of recording at 2000fps at full resolution of 1024 × 1024 pixels with a pixel-size of 17μm, yielding an effective pixel-size of (17μm/px)/337.5 = 50nm/px, which was confirmed experimentally. To reduce memory usage, the required pixel-area was reduced to 256 × 256 pixels, when recording videos of RBCs.</p>
    </sec>
    <sec id="sec021">
      <title>Preparation of dried RBC</title>
      <p>RBCs were extract using the finger pricking method from a voluntary, healthy donor. Approximately 20 − 30μL of blood was aspirated using a pipette and immediately diluted inside 1mL solution containing phosphate buffered saline (Sigma-Aldrich, Germany), 5mM glucose (Riedel-de Haen, Seelze, Germany) and 1mg/mL bovine serum albumin (Sigma-Aldrich, Germany). After extraction the blood is washed with a centrifuge (Mikro 120, Hettich, Germany) (5 × 10 min, 2347.8G). After each centrifugation pass the supernatant is removed and the remaining RBCs are resuspended in 1mL of centrifugation buffer. The RBCs were then incubated for 2 h in a fixation buffer with the same composition as the centrifugation buffer with an added 3% of glutaraldehyde (Sigma-Aldrich, Germany). After incubation, the buffer solvent is exchanged with pure water (Milli-Q) after centrifugation (2 × 10 min, 2347.8G) and substitution of the supernatant. Then, 80μL of the resulting RBC-containing solution is spread on a cover-slide and dried in an oven at 40°C.</p>
      <p><bold>Synthetic images</bold> were calculated following the method proposed by Usenik [<xref rid="pone.0207376.ref021" ref-type="bibr">21</xref>]. We convolute an image containing a circle consisting of 1’s on a background of 0’s with two Gaussians of two different widths <italic>σ</italic><sub>1</sub> and <italic>σ</italic><sub>2</sub>. The radius of the circle was chosen to be 61px, in order to approximately corresponds to the radius of RBC as recorded with our experimental setup, since 61px ∙ 50nm/px = 3μm is roughly the radius of RBC. By subtracting the two resulting images and choosing <italic>σ</italic><sub>1</sub> and <italic>σ</italic><sub>2</sub> accordingly, we obtain an image with a halo at the position of the circle boundary, which is very similar to that of the experimentally obtained images of the RBCs. Finally, white noise with a Gaussian amplitude distribution was added to the image pixels to simulate the image noise.</p>
      <p><bold>Signal-to-Noise Ratio</bold> of experimentally obtained images is determined by calculating the averaged image intensity 〈<italic>I</italic>〉 and its standard deviation <italic>σ</italic><sub><italic>I</italic></sub> inside a feature-less ROIs <italic>after</italic> the image corrections has been performed. The SNR definition we user here is then given by SNR = 〈<italic>I</italic>〉/<italic>σ</italic><sub><italic>I</italic></sub>. Note that this definition is different from the typical logarithmic definition used by Usenik (Usenik et al., 2011), where SNR<sub>Usenik</sub> = 20 log[〈<italic>I</italic>〉/<italic>σ</italic><sub><italic>I</italic></sub>].</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material" id="sec022">
    <title>Supporting information</title>
    <supplementary-material content-type="local-data" id="pone.0207376.s001">
      <label>S1 File</label>
      <caption>
        <title>High-precision flicker spectroscopy contour tracking algorithm: <ext-link ext-link-type="uri" xlink:href="http://www.gitlab.com/michaelmell/hipfsta">www.github.com/michaelmell/hipfsta</ext-link>.</title>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0207376.s001.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
    <supplementary-material content-type="local-data" id="pone.0207376.s002">
      <label>S2 File</label>
      <caption>
        <p>Containing S1 Fig: Distributions of the height fluctuations of glutaraldehyde-fixed RBC in aqueous buffer; S1 Table: RMSD of the distributions shown in S1 Fig; S2 Fig: Comparison of the spectra obtained from the synthetic dataset; S3 Fig: Fluctuation spectra at different SNR values obtained with the algorithm from reference [<xref rid="pone.0207376.ref013" ref-type="bibr">13</xref>].</p>
        <p>(PDF)</p>
      </caption>
      <media xlink:href="pone.0207376.s002.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <p>The authors wish to thank José A. Rodrigo (Department of Optics, UCM) for fruitful discussions on the noise structure factor. We also thank Julia Gala and Victor G. Almendro-Vedia for providing us with microscopy images of lymphocyte and <italic>E</italic>. <italic>coli</italic> cells. The work was supported in part by Ministerio de Economía y Competitividad (MINECO, Spain) under grant FIS2015-70339-C2-1-R and by Comunidad de Madrid under grant S2013/MIT-2807. MM thanks the FPU program (MEC) for financial support.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0207376.ref001">
      <label>1</label>
      <mixed-citation publication-type="other">Quantitative Imaging in Cell Biology, 1st ed. Edited by J. Waters and T. Wittmann, in Methods in Cell Biology series, Volume 123 (Academic Press, 2014).</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Nombela-Arrieta</surname><given-names>C.</given-names></name>, <name><surname>Pivarnik</surname><given-names>G.</given-names></name>, <name><surname>Winkel</surname><given-names>B.</given-names></name>, <name><surname>Canty</surname><given-names>K.J.</given-names></name>, <name><surname>Harley</surname><given-names>B.</given-names></name>, <name><surname>Mahoney</surname><given-names>J.E.</given-names></name>, <name><surname>Park</surname><given-names>S-Y</given-names></name>., <name><surname>Lu</surname><given-names>J</given-names></name>., <name><surname>Protopopov</surname><given-names>A</given-names></name>. and <name><surname>Silberstein</surname><given-names>L.E</given-names></name>. <year>2013</year><article-title>Quantitative imaging of haematopoietic stem and progenitor cell localization and hypoxic status in the bone marrow microenvironment</article-title>. <source>Nature Cell Biol</source>. <volume>15</volume>, <fpage>533</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/ncb2730">10.1038/ncb2730</ext-link><?supplied-pmid 23624405?><pub-id pub-id-type="pmid">23624405</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref003">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Carpenter</surname><given-names>A.E.</given-names></name><year>2007</year><article-title>Software opens the door to quantitative imaging</article-title>. <source>Nature Methods</source>. <volume>4</volume>, <fpage>120</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/nmeth0207-120">10.1038/nmeth0207-120</ext-link><?supplied-pmid 17264858?><pub-id pub-id-type="pmid">17264858</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Smith</surname><given-names>A.</given-names></name><year>2016</year><article-title>Biophysics: Alive and twitching</article-title>. <source>Nature Phys</source>. <volume>12</volume>, <fpage>378</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Rodriguez-Garcia</surname><given-names>R. I.</given-names></name><name><surname>Lopez-Montero</surname><given-names>M</given-names></name>. <name><surname>Mell</surname><given-names>G</given-names></name>. <name><surname>Egea</surname><given-names>N.S</given-names></name>. <collab>Gov and Francisco Monroy</collab>. <year>2015</year><article-title>Direct Cytoskeleton Forces Cause Membrane Softening in Red Blood Cells</article-title>. <source>Biophys. J</source><volume>108</volume>, <fpage>2794</fpage>–<lpage>2806</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.bpj.2015.05.005">10.1016/j.bpj.2015.05.005</ext-link><?supplied-pmid 26083919?><pub-id pub-id-type="pmid">26083919</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref006">
      <label>6</label>
      <mixed-citation publication-type="journal"><name><surname>Turlier</surname><given-names>H.</given-names></name>, <name><surname>Fedosov</surname><given-names>D. A.</given-names></name>, <name><surname>Audoly</surname><given-names>B.</given-names></name>, <name><surname>Auth</surname><given-names>T.</given-names></name>, <name><surname>Gov</surname><given-names>N. S.</given-names></name>, <name><surname>Sykes</surname><given-names>C.</given-names></name>, <name><surname>Joanny</surname><given-names>J.-F.</given-names></name>, <name><surname>Gompper</surname><given-names>G.</given-names></name> and <name><surname>Betz</surname><given-names>T.</given-names></name>
<article-title>2016. Equilibrium physics breakdown reveals the active nature of red blood cell flickering</article-title>. <source>Nature Phys</source>, <volume>12</volume>, <fpage>513</fpage>–<lpage>519</lpage> (<year>2016</year>)</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Yoon</surname><given-names>Y.Z.</given-names></name>, <name><surname>H Hong</surname><given-names>A.</given-names></name><name><surname>Brown</surname><given-names>D. C</given-names></name>. <name><surname>Kim</surname><given-names>D.J</given-names></name>. <name><surname>Kang</surname><given-names>V</given-names></name>. <name><surname>Lew</surname></name> and <name><surname>Cicuta</surname><given-names>P.</given-names></name>
<year>2009</year>
<article-title>Flickering analysis of erythrocyte mechanical properties: Dependence on oxygenation level, cell shape, and hydration level</article-title>. <source>Biophys J</source>
<volume>97</volume>, <fpage>1606</fpage>–<lpage>1615</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.bpj.2009.06.028">10.1016/j.bpj.2009.06.028</ext-link>
<?supplied-pmid 19751665?><pub-id pub-id-type="pmid">19751665</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Montzel</surname><given-names>C.</given-names></name>, <name><surname>Schmidt</surname><given-names>D.</given-names></name>, <name><surname>Kleusch</surname><given-names>C.</given-names></name>, <name><surname>Kirchenbüchler</surname><given-names>D.</given-names></name>, <name><surname>Seifert</surname><given-names>U.</given-names></name>, <name><surname>Smith</surname><given-names>A-S</given-names></name>, <name><surname>Sengupta</surname><given-names>K.</given-names></name> and <name><surname>Merkel</surname><given-names>R.</given-names></name>
<year>2015</year>
<article-title>Measuring fast stochastic displacements of bio-membranes with dynamic optical displacement spectroscopy</article-title>. <source>Nature Commun</source>
<volume>6</volume>, <fpage>8162</fpage><pub-id pub-id-type="pmid">26437911</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref009">
      <label>9</label>
      <mixed-citation publication-type="journal"><name><surname>Ben-Isaac</surname><given-names>E.</given-names></name>, <name><surname>Park</surname><given-names>Y.</given-names></name>, <name><surname>Popescu</surname><given-names>G.</given-names></name>, <name><surname>Brown</surname><given-names>F.L.H.</given-names></name>, <name><surname>Gov</surname><given-names>N.S.</given-names></name>, <name><surname>Shokef</surname><given-names>Y.</given-names></name>, <year>2011</year><article-title>Effective Temperature of Red-Blood-Cell Membrane Fluctuations</article-title>. <source>Phys. Rev. Lett</source>. <volume>106</volume>, <fpage>238103</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevLett.106.238103">10.1103/PhysRevLett.106.238103</ext-link><?supplied-pmid 21770546?><pub-id pub-id-type="pmid">21770546</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref010">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Betz</surname><given-names>T.</given-names></name>, <name><surname>Lenz</surname><given-names>M.</given-names></name>, <name><surname>Joanny</surname><given-names>J.-F.</given-names></name>, <name><surname>Sykes</surname><given-names>C.</given-names></name>, <year>2009</year><article-title>ATP-dependent mechanics of red blood cells</article-title>. <source>Proc. Natl. Acad. Sci. U. S. A</source>. <volume>106</volume>, <fpage>15320</fpage>–<lpage>5</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1073/pnas.0904614106">10.1073/pnas.0904614106</ext-link><?supplied-pmid 19717437?><pub-id pub-id-type="pmid">19717437</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref011">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Park</surname><given-names>Y.</given-names></name>, <name><surname>Best</surname><given-names>C. a.</given-names></name>, <name><surname>Kuriabova</surname><given-names>T.</given-names></name>, <name><surname>Henle</surname><given-names>M.L.</given-names></name>, <name><surname>Feld</surname><given-names>M.S.</given-names></name>, <name><surname>Levine</surname><given-names>A.J.</given-names></name>, <name><surname>Popescu</surname><given-names>G.</given-names></name>, <year>2011</year><article-title>Measurement of the nonlinear elasticity of red blood cell membranes</article-title>. <source>Phys. Rev. E</source><volume>83</volume>, <fpage>051925</fpage><ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevE.83.051925">10.1103/PhysRevE.83.051925</ext-link><?supplied-pmid 21728589?><pub-id pub-id-type="pmid">21728589</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref012">
      <label>12</label>
      <mixed-citation publication-type="journal"><name><surname>Park</surname><given-names>Y.</given-names></name>, <name><surname>Best</surname><given-names>C.A.</given-names></name>, <name><surname>Auth</surname><given-names>T.</given-names></name>, <name><surname>Gov</surname><given-names>N.S.</given-names></name>, <name><surname>Safran</surname><given-names>S.A.</given-names></name>, <name><surname>Popescu</surname><given-names>G.</given-names></name>, <name><surname>Suresh</surname><given-names>S.</given-names></name>, <name><surname>Feld</surname><given-names>M.S.</given-names></name>, <year>2010a</year><article-title>Metabolic remodeling of the human red blood cell membrane</article-title>. <source>Proc. Natl. Acad. Sci</source>. <volume>107</volume>, <fpage>1289</fpage>–<lpage>1294</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1073/pnas.0910785107">10.1073/pnas.0910785107</ext-link><?supplied-pmid 20080583?><pub-id pub-id-type="pmid">20080583</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref013">
      <label>13</label>
      <mixed-citation publication-type="journal"><name><surname>Pécréaux</surname><given-names>J.</given-names></name>, <name><surname>Döbereiner</surname><given-names>H.G.</given-names></name>, <name><surname>Prost</surname><given-names>J.</given-names></name>, <name><surname>Joanny</surname><given-names>J.F.</given-names></name>, <name><surname>Bassereau</surname><given-names>P.</given-names></name>, <year>2004</year><article-title>Refined contour analysis of giant unilamellar vesicles</article-title>. <source>Eur. Phys. J. E</source><volume>13</volume>, <fpage>277</fpage>–<lpage>290</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1140/epje/i2004-10001-9">10.1140/epje/i2004-10001-9</ext-link><?supplied-pmid 15103522?><pub-id pub-id-type="pmid">15103522</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref014">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Engelhardt</surname><given-names>H.</given-names></name>, <name><surname>Duwe</surname><given-names>H.P.P.</given-names></name>, <name><surname>Sack mann</surname><given-names>E.</given-names></name>, <year>1985</year><article-title>Bilayer bending elasticity measured by Fourier analysis of thermally excited surface undulations of flaccid vesicles</article-title>. <source>J. Phys. Lettres</source><volume>46</volume>, <fpage>395</fpage>–<lpage>400</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1051/jphyslet:01985004608039500">10.1051/jphyslet:01985004608039500</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref015">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Faucon</surname><given-names>J.F.</given-names></name>, <name><surname>Mitov</surname><given-names>M.D.</given-names></name>, <name><surname>Méléard</surname><given-names>P.</given-names></name>, <name><surname>Bivas</surname><given-names>I.</given-names></name>, <name><surname>Bothorel</surname><given-names>P.</given-names></name>, <name><surname>Meleard</surname><given-names>P.</given-names></name>, <name><surname>Mitov</surname><given-names>M. D.</given-names></name>, <name><surname>and P</surname><given-names>J.F.F.B.</given-names></name>, <year>1989</year><article-title>Bending elasticity and thermal fluctuations of lipid membranes. Theoretical and experimental requirements</article-title>. <source>J. Phys</source>. <volume>50</volume>, <fpage>2389</fpage>–<lpage>2414</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1051/jphys:0198900500170238900">10.1051/jphys:0198900500170238900</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref016">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Duwe</surname><given-names>H.P.</given-names></name>, <name><surname>Kaes</surname><given-names>J.</given-names></name>, <name><surname>Sackmann</surname><given-names>E.</given-names></name>, <name><surname>Bending</surname><given-names>E.S.</given-names></name>, <year>1990</year><source>Bending elastic moduli of lipid bilayers: modulation by solutes</source><volume>51</volume>, <fpage>945</fpage>–<lpage>962</lpage></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref017">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Strey</surname><given-names>H.</given-names></name>, <name><surname>Peterson</surname><given-names>M.A.</given-names></name>, <name><surname>Sackmann</surname><given-names>E.</given-names></name>, <year>1995</year><article-title>Measurement of erythrocyte membrane elasticity by flicker eigenmode decomposition</article-title>. <source>Biophys. J</source>. <volume>69</volume>, <fpage>478</fpage>–<lpage>488</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/S0006-3495(95)79921-0">10.1016/S0006-3495(95)79921-0</ext-link><?supplied-pmid 8527662?><pub-id pub-id-type="pmid">8527662</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref018">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Döbereiner</surname><given-names>H.-G.</given-names></name>, <name><surname>Evans</surname><given-names>E.</given-names></name>, <name><surname>Kraus</surname><given-names>M.</given-names></name>, <name><surname>Seifert</surname><given-names>U.</given-names></name>, <name><surname>Wortis</surname><given-names>M.</given-names></name>, <year>1997</year><article-title>Mapping vesicle shapes into the phase diagram: A comparison of experiment and theory</article-title>. <source>Phys. Rev. E</source><volume>55</volume>, <fpage>4458</fpage>–<lpage>4474</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1103/PhysRevE.55.4458">10.1103/PhysRevE.55.4458</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref019">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Häckl</surname><given-names>W.</given-names></name>, <name><surname>Seifert</surname><given-names>U.</given-names></name>, <name><surname>Sackmann</surname><given-names>E.</given-names></name>, <year>1997</year><article-title>Effects of fully and partially solubilized amphiphiles on bilayer bending stiffness and temperature dependence of the effective tension of giant vesicles</article-title>. <source>J. Phys</source>. <volume>II</volume><issue>7</issue>, <fpage>1141</fpage>–<lpage>1157</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref020">
      <label>20</label>
      <mixed-citation publication-type="journal"><name><surname>Evans</surname><given-names>J.J.</given-names></name>, <year>2008</year><article-title>An image-processing technique for measuring the dynamic movement of cell membranes</article-title>. <source>Comput. Biol. Med</source>. <volume>38</volume>, <fpage>545</fpage>–<lpage>54</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.compbiomed.2008.01.013">10.1016/j.compbiomed.2008.01.013</ext-link><?supplied-pmid 18358462?><pub-id pub-id-type="pmid">18358462</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref021">
      <label>21</label>
      <mixed-citation publication-type="journal"><name><surname>Usenik</surname><given-names>P.</given-names></name>, <name><surname>Vrtovec</surname><given-names>T.</given-names></name>, <name><surname>Pernuš</surname><given-names>F.</given-names></name>, <name><surname>Likar</surname><given-names>B.</given-names></name>, <year>2011</year><article-title>Automated imaging and analysis of phospholipid vesicle contours in phase contrast microscopy images</article-title>. <source>Med. Biol. Eng. Comput</source>. <volume>49</volume>, <fpage>957</fpage>–<lpage>66</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s11517-011-0789-0">10.1007/s11517-011-0789-0</ext-link><?supplied-pmid 21710319?><pub-id pub-id-type="pmid">21710319</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref022">
      <label>22</label>
      <mixed-citation publication-type="journal"><name><surname>Park</surname><given-names>Y.</given-names></name>, <name><surname>Popescu</surname><given-names>G.</given-names></name>, <name><surname>Badizadegan</surname><given-names>K.</given-names></name>, <year>2006</year><article-title>Diffraction phase and fluorescence microscopy</article-title>. <source>Opt. Express</source><volume>14</volume>, <fpage>8263</fpage>–<lpage>8</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1364/OE.14.008263">10.1364/OE.14.008263</ext-link><?supplied-pmid 19529201?><pub-id pub-id-type="pmid">19529201</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref023">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Kim</surname><given-names>M.K.</given-names></name><year>2010</year><article-title>Principles and techniques of digital holographic microscopy</article-title>. <source>SPIE Rev</source>. <volume>1</volume>. 018005.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref024">
      <label>24</label>
      <mixed-citation publication-type="journal"><name><surname>Zernike</surname><given-names>F.</given-names></name><year>1955</year><article-title>How I discovered phase contrast</article-title>. <source>Science</source><volume>121</volume>, <fpage>345</fpage>–<lpage>9</lpage>. <?supplied-pmid 13237991?><pub-id pub-id-type="pmid">13237991</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref025">
      <label>25</label>
      <mixed-citation publication-type="journal"><name><surname>Nguyen</surname><given-names>T.N.</given-names></name>, <name><surname>Edwards</surname><given-names>C.</given-names></name>, <name><surname>Goddard</surname><given-names>L.L.</given-names></name> and <name><surname>Popescu</surname><given-names>G.</given-names></name>
<year>2016</year>
<article-title>Quantitative phase imaging of weakly scattering objects using partially coherent illumination</article-title>. <source>Opt. Express</source>
<volume>24</volume>, <fpage>11683</fpage>–<lpage>93</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1364/OE.24.011683">10.1364/OE.24.011683</ext-link>
<?supplied-pmid 27410094?><pub-id pub-id-type="pmid">27410094</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref026">
      <label>26</label>
      <mixed-citation publication-type="journal"><name><surname>Kandel</surname><given-names>M.A.</given-names></name>, <name><surname>Fanous</surname><given-names>M.</given-names></name>, <name><surname>Best-Popescu</surname><given-names>C.</given-names></name> and <name><surname>Popescu</surname><given-names>G.</given-names></name>
<year>2018</year>
<article-title>Real-time halo correction in phase contrast imaging</article-title>. <source>Biomed. Opt. Express</source>
<volume>9</volume>, <fpage>623</fpage>–<lpage>35</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1364/BOE.9.000623">10.1364/BOE.9.000623</ext-link>
<?supplied-pmid 29552399?><pub-id pub-id-type="pmid">29552399</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref027">
      <label>27</label>
      <mixed-citation publication-type="journal"><name><surname>Méléard</surname><given-names>P.</given-names></name>, <name><surname>Gerbeaud</surname><given-names>C.</given-names></name>, <name><surname>Pott</surname><given-names>T.</given-names></name>, <name><surname>Fernandez-Puente</surname><given-names>L.</given-names></name>, <name><surname>Bivas</surname><given-names>I.</given-names></name>, <name><surname>Mitov</surname><given-names>M.D.</given-names></name>, <name><surname>Dufourcq</surname><given-names>J.</given-names></name>, <name><surname>Bothorel</surname><given-names>P.</given-names></name>, <year>1997</year><article-title>Bending elasticities of model membranes: influences of temperature and sterol content</article-title>. <source>Biophys. J</source>. <volume>72</volume>, <fpage>2616</fpage>–<lpage>29</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/S0006-3495(97)78905-7">10.1016/S0006-3495(97)78905-7</ext-link><?supplied-pmid 9168037?><pub-id pub-id-type="pmid">9168037</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref028">
      <label>28</label>
      <mixed-citation publication-type="journal"><name><surname>Wilson</surname><given-names>T.</given-names></name>, <name><surname>Sheppard</surname><given-names>C.J.R.J.R.</given-names></name>, <year>1981</year><article-title>The halo effect of image processing by spatial frequency filtering</article-title>. <source>Optik (Stuttg)</source>. <volume>59</volume>, <fpage>19</fpage>–<lpage>23</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref029">
      <label>29</label>
      <mixed-citation publication-type="book"><name><surname>Boal</surname><given-names>D.H.</given-names></name><chapter-title>Mechanics of the Cell</chapter-title>, <edition>2nd ed.</edition> (<publisher-name>Cambridge Univ Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>, <year>2012</year>)</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref030">
      <label>30</label>
      <mixed-citation publication-type="book"><name><surname>Inoué</surname><given-names>S.</given-names></name> and <name><surname>Spring</surname><given-names>K.R.</given-names></name>
<chapter-title>Videomicroscopy: The Fundamentals</chapter-title>, <edition>2nd ed</edition> (<publisher-name>Plenum Press</publisher-name>, <publisher-loc>New York</publisher-loc>, <year>1997</year>)</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref031">
      <label>31</label>
      <mixed-citation publication-type="journal"><name><surname>Wilson</surname><given-names>T.</given-names></name> and <name><surname>Sheppard</surname><given-names>C. J. R.</given-names></name>
<year>1981</year>
<article-title>The Halo Effect of Image-Processing by Spatial-Frequency Filtering</article-title>. <source>Optik</source>
<volume>59</volume>, <fpage>19</fpage>–<lpage>23</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref032">
      <label>32</label>
      <mixed-citation publication-type="journal"><name><surname>Zernike</surname><given-names>F.</given-names></name><year>1942</year><article-title>Phase contrast, a new method for the microscopic observation of transparent objects. Part I</article-title>. <source>Physica</source><volume>9</volume>, <fpage>686</fpage>–<lpage>698</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref033">
      <label>33</label>
      <mixed-citation publication-type="journal"><name><surname>Popescu</surname><given-names>G.</given-names></name>, <name><surname>Ikeda</surname><given-names>T.</given-names></name>, <name><surname>Dasari</surname><given-names>R.</given-names></name>, <name><surname>Feld</surname><given-names>M.</given-names></name>, <year>2006</year><article-title>Diffraction phase microscopy for quantifying cell structure and dynamics</article-title>. <source>Opt. Lett</source>. <volume>31</volume>, <fpage>775</fpage>–<lpage>777</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1364/OL.31.000775">10.1364/OL.31.000775</ext-link><?supplied-pmid 16544620?><pub-id pub-id-type="pmid">16544620</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref034">
      <label>34</label>
      <mixed-citation publication-type="journal"><name><surname>Park</surname><given-names>Y.</given-names></name>, <name><surname>Best</surname><given-names>C.A.</given-names></name>, <name><surname>Badizadegan</surname><given-names>K.</given-names></name>, <name><surname>Dasari</surname><given-names>R.R.</given-names></name>, <name><surname>Feld</surname><given-names>M.S.</given-names></name>, <name><surname>Kuriabova</surname><given-names>T.</given-names></name>, <name><surname>Henle</surname><given-names>M.L.</given-names></name>, <name><surname>Levine</surname><given-names>A.J.</given-names></name>, <name><surname>Popescu</surname><given-names>G.</given-names></name>, <year>2010</year>b. <article-title>Measurement of red blood cell mechanics during morphological changes</article-title>. <source>Proc. Natl. Acad. Sci. U. S. A</source>. <volume>107</volume>, <fpage>6731</fpage>–<lpage>6736</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1073/pnas.0909533107">10.1073/pnas.0909533107</ext-link><?supplied-pmid 20351261?><pub-id pub-id-type="pmid">20351261</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref035">
      <label>35</label>
      <mixed-citation publication-type="other">Smith, J.O. 2010. Linear interpolation frequency response in Phys Audio Sign Process. <ext-link ext-link-type="uri" xlink:href="https://ccrma.stanford.edu/~jos/pasp04/Linear_Interpolation_Frequency_Response.html">https://ccrma.stanford.edu/~jos/pasp04/Linear_Interpolation_Frequency_Response.html</ext-link></mixed-citation>
    </ref>
    <ref id="pone.0207376.ref036">
      <label>36</label>
      <mixed-citation publication-type="other">Guillemin, E.A., 2013. Theory of linear physical systems: theory of physical systems from the viewpoint of classical dynamics, including Fourier methods. Courier Corporation.</mixed-citation>
    </ref>
    <ref id="pone.0207376.ref037">
      <label>37</label>
      <mixed-citation publication-type="journal"><name><surname>Fowler</surname><given-names>B.</given-names></name>, <name><surname>Liu</surname><given-names>C.</given-names></name>, <name><surname>Mims</surname><given-names>S.</given-names></name>, <name><surname>Balicki</surname><given-names>J.</given-names></name>, <name><surname>Li</surname><given-names>W.</given-names></name>, <name><surname>Do</surname><given-names>H.</given-names></name>, <name><surname>Appelbaum</surname><given-names>J.</given-names></name>, <name><surname>Vu</surname><given-names>P.</given-names></name>, <year>2010</year><article-title>A 5.5Mpixel 100 frames/sec wide dynamic range low noise CMOS image sensor for scientific applications</article-title>. <source>Proc. SPIE</source>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1117/12.846975">10.1117/12.846975</ext-link></mixed-citation>
    </ref>
  </ref-list>
</back>
