<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9235500</article-id>
    <article-id pub-id-type="pmid">35758774</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btac223</article-id>
    <article-id pub-id-type="publisher-id">btac223</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>ISCB/Ismb 2022</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>ReadBouncer: precise and scalable adaptive sampling for nanopore sequencing</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Ulrich</surname>
          <given-names>Jens-Uwe</given-names>
        </name>
        <aff><institution>Hasso Plattner Institute, Digital Engineering Faculty, University of Potsdam</institution>, 14482 Potsdam, <country country="DE">Germany</country></aff>
        <aff><institution>Bioinformatics Unit (MF1), Robert Koch Institute</institution>, 13353 Berlin, <country country="DE">Germany</country></aff>
        <aff><institution>Department of Mathematics and Computer Science, Free University of Berlin</institution>, 14195 Berlin, <country country="DE">Germany</country></aff>
        <xref rid="btac223-cor1" ref-type="corresp"/>
        <!--jens-uwe.ulrich@hpi.de-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lutfi</surname>
          <given-names>Ahmad</given-names>
        </name>
        <aff><institution>Hasso Plattner Institute, Digital Engineering Faculty, University of Potsdam</institution>, 14482 Potsdam, <country country="DE">Germany</country></aff>
        <aff><institution>Department of Mathematics and Computer Science, Free University of Berlin</institution>, 14195 Berlin, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rutzen</surname>
          <given-names>Kilian</given-names>
        </name>
        <aff><institution>Genome Sequencing Unit (MF2), Robert Koch Institute</institution>, 13353 Berlin, <country country="DE">Germany</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-4589-9809</contrib-id>
        <name>
          <surname>Renard</surname>
          <given-names>Bernhard Y</given-names>
        </name>
        <aff><institution>Hasso Plattner Institute, Digital Engineering Faculty, University of Potsdam</institution>, 14482 Potsdam, <country country="DE">Germany</country></aff>
        <aff><institution>Bioinformatics Unit (MF1), Robert Koch Institute</institution>, 13353 Berlin, <country country="DE">Germany</country></aff>
        <xref rid="btac223-cor1" ref-type="corresp"/>
        <!--bernhard.renard@hpi.de-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btac223-cor1">To whom correspondence should be addressed. E-mail: <email>jens-uwe.ulrich@hpi.de</email> or <email>bernhard.renard@hpi.de</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2022-06-27">
      <day>27</day>
      <month>6</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>27</day>
      <month>6</month>
      <year>2022</year>
    </pub-date>
    <volume>38</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISCB ISMB 2022 Proceedings</issue-title>
    <fpage>i153</fpage>
    <lpage>i160</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2022. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btac223.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Nanopore sequencers allow targeted sequencing of interesting nucleotide sequences by rejecting other sequences from individual pores. This feature facilitates the enrichment of low-abundant sequences by depleting overrepresented ones in-silico. Existing tools for adaptive sampling either apply signal alignment, which cannot handle human-sized reference sequences, or apply read mapping in sequence space relying on fast graphical processing units (GPU) base callers for real-time read rejection. Using nanopore long-read mapping tools is also not optimal when mapping shorter reads as usually analyzed in adaptive sampling applications.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>Here, we present a new approach for nanopore adaptive sampling that combines fast CPU and GPU base calling with read classification based on Interleaved Bloom Filters. ReadBouncer improves the potential enrichment of low abundance sequences by its high read classification sensitivity and specificity, outperforming existing tools in the field. It robustly removes even reads belonging to large reference sequences while running on commodity hardware without GPUs, making adaptive sampling accessible for in-field researchers. Readbouncer also provides a user-friendly interface and installer files for end-users without a bioinformatics background.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The C++ source code is available at <ext-link xlink:href="https://gitlab.com/dacs-hpi/readbouncer" ext-link-type="uri">https://gitlab.com/dacs-hpi/readbouncer</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>BMBF</institution>
            <institution-id institution-id-type="DOI">10.13039/501100002347</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>German Center for Infection Research</institution>
            <institution-id institution-id-type="DOI">10.13039/100009139</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>TI 06.904—FP2019</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>During the last decade, the invention of nanopore sequencing instruments has democratized DNA sequencing in various aspects (<xref rid="btac223-B10" ref-type="bibr">Leggett and Clark, 2017</xref>; <xref rid="btac223-B15" ref-type="bibr">Mikheyev and Tin, 2014</xref>). For example, the small MinION devices of Oxford Nanopore Technologies (ONT) provide the possibility to sequence a sample at the place of its origin, without the need to ship the sample to a laboratory (<xref rid="btac223-B27" ref-type="bibr">Runtuwene <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btac223-B28" ref-type="bibr">Sim and Chapman, 2019</xref>). This point-of-care sequencing ability makes nanopore sequencing attractive for applications such as pathogen detection in a clinical setting and in the field (<xref rid="btac223-B16" ref-type="bibr">Mongan <italic toggle="yes">et al.</italic>, 2020</xref>; <xref rid="btac223-B25" ref-type="bibr">Quick <italic toggle="yes">et al.</italic>, 2016</xref>). It also can shorten the time to detect pathogens or antimicrobial resistance (AMR) genes when using it for point-of-care testing.</p>
    <p>While the size of the device and the easier and faster sample preparation are clear advantages, nanopore sequencing still lags the base quality of sequencing-by-synthesis instruments. However, recent improvements in base-calling algorithms showed per read accuracy exceeding 90% (<xref rid="btac223-B26" ref-type="bibr">Rang <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac223-B29" ref-type="bibr">Wick <italic toggle="yes">et al.</italic>, 2019</xref>). ONT even claims to boost per read accuracy up to 99% with their latest R10.4 pore version (<ext-link xlink:href="https://nanoporetech.com/accuracy" ext-link-type="uri">https://nanoporetech.com/accuracy</ext-link>). Another exciting feature of ONT’s instruments is sequencing DNA molecules in a targeted fashion. Oxford Nanopore provides an Application Programming Interface (API) that enables receiving electrical currents, measured while the molecule transverses the pore (<xref rid="btac223-B12" ref-type="bibr">Loose <italic toggle="yes">et al.</italic>, 2016</xref>). These signals can be translated into sequence space and analyzed in real-time. An uninteresting DNA molecule located in a pore can be ejected by sending an ‘unblock’ message back to the control software. This message leads the sequencer to reverse the voltage across the pore, causing the molecule to exit the pore in the reverse direction. The primary requirement for such a live depletion system is that the software making ejection decisions can keep up with the sequencing speed for up to 512 nanopores that concurrently sequence DNA molecules on a MinION sequencer.</p>
    <p>Two recent publications describe the implementation of such systems for specific settings. Payne <italic toggle="yes">et al.</italic> combined Oxford Nanopore’s Guppy base caller (<xref rid="btac223-B29" ref-type="bibr">Wick <italic toggle="yes">et al.</italic>, 2019</xref>) with the minimap2 read aligner (<xref rid="btac223-B11" ref-type="bibr">Li, 2018</xref>) in their Readfish workflow to make ejection decisions after mapping the reads to a reference genome in real-time. <xref rid="btac223-B9" ref-type="bibr">Kovaka <italic toggle="yes">et al.</italic> (2021)</xref> skipped the base-calling step and performed ejection decisions directly on nanopore current signals. While the latter is designed to run on a general-purpose CPU, it cannot handle large human size reference genomes. In contrast, Readfish can handle larger references but needs additional software like DeepNano-blitz (<xref rid="btac223-B4" ref-type="bibr">Boža <italic toggle="yes">et al.</italic>, 2020</xref>) or Oxford Nanopore’s Guppy graphical processing units (GPU) basecaller for real-time base calling.</p>
    <p>Furthermore, the usage of minimap2 (<xref rid="btac223-B11" ref-type="bibr">Li, 2018</xref>) for read classification is not optimal. In their study, Payne <italic toggle="yes">et al.</italic> showed that only 83% of target reads were correctly classified for rejection after 0.8 s of sequencing. <xref rid="btac223-B13" ref-type="bibr">Marquet <italic toggle="yes">et al.</italic> (2022)</xref> observed the same issue when they tried to deplete all human host reads from vaginal samples with ONT’s adaptive sampling option. Using the depletion method supported by MinKNOW, 25% of human reads could not accurately be rejected by the software, wasting many resources on sequencing uninteresting reads. Further, missed mappings to repetitive regions of the reference genome can lead to delayed classifications when longer parts of the DNA molecule must be sequenced to make a rejection decision. Both lower sensitivity and classification delay will cause decreased enrichment of clinically relevant sequences of undetected pathogens or antibiotic resistance markers.</p>
    <p>This study introduces <italic toggle="yes">ReadBouncer</italic> as a new tool for nanopore adaptive sampling that combines state-of-the-art base-calling software with the DREAM index (<xref rid="btac223-B7" ref-type="bibr">Dadi <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac223-B24" ref-type="bibr">Piro <italic toggle="yes">et al.</italic>, 2020</xref>). Readbouncer facilitates both GPU base-calling with ONTs Guppy as well as CPU base-calling with DeepNano-blitz (<xref rid="btac223-B4" ref-type="bibr">Boža <italic toggle="yes">et al.</italic>, 2020</xref>). Its Interleaved Bloom Filter (IBF) data structure allows for fast querying of hashed k-mers on large sequence datasets resulting in an improved read classification strategy. Within an integrated workflow, Readbouncer uses IBFs to classify base-called DNA fragments for ejection and finally communicates the decision to the sequencing control software.</p>
    <p>We first investigate our read classification approach by comparing it to other software tools used for read classification in a nanopore adaptive sampling context. ReadBouncer shows the best accuracy, recall, F1-Score and Matthews correlation coefficient (MCC) among all tools on a simulated and a real-world dataset, while having almost the same precision and specificity as the best competitor. Furthermore, our tool also has the smallest reference sequence index size and peak memory usage.</p>
    <p>We also compare ReadBouncer with Readfish and ONT’s MinKNOW software using a playback run of a whole human genome sequencing experiment to evaluate its adaptive sampling performance. In this comparison, we demonstrate that ReadBouncer outperforms the other tools in a targeted sequencing experiment. ReadBouncer results consistently show more sequenced bases for target references and significantly shorter mean read length of off-target or rejected nanopore reads. These results indicate that ReadBouncer can make faster and more reliable rejection decisions than Readfish and MinKNOW. ReadBouncer’s source code and installer files for Windows and Linux are freely available as a Git repository (<ext-link xlink:href="https://gitlab.com/dacs-hpi/readbouncer" ext-link-type="uri">https://gitlab.com/dacs-hpi/readbouncer</ext-link>) under GNU General Public License 3 (GPL-3.0).</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Read classification</title>
      <p>With the current nanopore sequencing speed of 450 nucleotides per second, an adaptive sampling approach ideally makes ejection decisions within 2 s after sequencing of a DNA molecule has started. This requires fast base calling and rapid and reliable classification of read fragments smaller than 500 nucleotides. Readfish (<xref rid="btac223-B22" ref-type="bibr">Payne <italic toggle="yes">et al.</italic>, 2021</xref>) uses the long-read alignment tool minimap2 (<xref rid="btac223-B11" ref-type="bibr">Li, 2018</xref>) for this purpose. Although being fast and accurate for long error-prone nanopore reads, the alignment approach poses some challenges when working with short error-prone fragments of less than 500 nucleotides. For optimal enrichment of low abundance genomic regions, we need to make reliable rejection decisions as fast as possible. Payne <italic toggle="yes">et al.</italic> showed in their study that it takes about 360 nucleotides for minimap2 to align 90% of those reads correctly. That means, if we want to get higher enrichment, we need to improve the classification sensitivity for the same read length. Mappings are also hard to use when there is no good quality reference sequence available for an organism that is the depletion target such as non-model organisms. In such scenarios, one would try to use the reference sequence of a closely related species for read classification. Mapping reads to the reference of a closely related species would fail to find numerous reads that we would aim to eject from the pore.</p>
      <p>All these findings motivated us to seek a different, fast classification strategy. To our knowledge, the fastest current sequence comparison algorithms use k-mer-based approaches, where a DNA sequence is divided into small overlapping substrings of size <italic toggle="yes">k</italic>. One approach, known as MinHash (<xref rid="btac223-B6" ref-type="bibr">Broder, 1997</xref>; <xref rid="btac223-B19" ref-type="bibr">Ondov <italic toggle="yes">et al.</italic>, 2016</xref>), computes a hash value for every k-mer of a sequence and stores the smallest hash values within a data structure called a sketch. The same procedure is applied to the second sequence, and the number of hash values present in both sketches gives an accurate approximation of the identity between the two sequences. Although this works well for sequences of similar size, it fails for sequence containment tests, where one sequence is much smaller than the other one, which is the case when we want to check if a nanopore read is part of a reference genome.</p>
      <p>A better approach for testing if the set of k-mers of a reference genome contains the k-mers of a read is using Bloom Filters (<xref rid="btac223-B3" ref-type="bibr">Bloom, 1970</xref>; <xref rid="btac223-B8" ref-type="bibr">Koslicki and Zabeti, 2019</xref>). A Bloom Filter simply is a bitvector of size n and a set of h independent hash functions. To insert a k-mer into a Bloom Filter, the bit positions that correspond to the <italic toggle="yes">h</italic> hash values of the k-mer are set to 1, and a k-mer is considered present in the Bloom Filter if all <italic toggle="yes">h</italic> positions return a 1 during the lookup phase. In our case, we would insert all k-mers of a reference genome into the Bloom Filter and lookup for the k-mers of a nanopore read in that Bloom Filter.</p>
      <p>The biggest problem of k-mer-based approaches is choosing the correct parameter value for <italic toggle="yes">k</italic>, which is always a tradeoff between sensitivity and specificity in the presence of sequencing errors. Larger values for <italic toggle="yes">k</italic> will result in more specific read classification results but will also fail to find many reads from the reference genome when the number of sequencing errors is high. When trying to classify nanopore reads with error rates of about 10%, the value for <italic toggle="yes">k</italic> will hardly become bigger than 13. The number of different k-mers of size 13 is combinatorially defined by <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mrow><mml:mn>13</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>67</mml:mn><mml:mo>,</mml:mo><mml:mn>108</mml:mn><mml:mo>,</mml:mo><mml:mn>864</mml:mn></mml:mrow></mml:math></inline-formula>, which is much too small when working with human-sized genomes that compose about 3 billion k-mers of size 13. To overcome this issue, we divide the reference genome into overlapping fragments of size <italic toggle="yes">m</italic> and construct a separate Bloom Filter for each fragment. However, querying one read against each of the Bloom Filters separately reduces the performance of the Bloom Filter approach. Thus, we decided to use IBF as proposed by <xref rid="btac223-B7" ref-type="bibr">Dadi <italic toggle="yes">et al.</italic> (2018)</xref> to index the reference genomes.</p>
      <p>An IBF combines several Bloom Filters (bins) in one single bitvector. The IBF can be divided into several subvectors, each having the size of the number of bins. Since one bin in the IBF corresponds to one fragment of the reference sequence, the size of each subvector corresponds to the number of fragments. In <xref rid="btac223-F1" ref-type="fig">Figure 1</xref>, for example, we divided the reference sequence into three overlapping fragments, each corresponding to one bin of the IBF. Thus, each subvector in the IBF consists of 3 bits. The <italic toggle="yes">i</italic>th bit of every subvector belongs to the Bloom Filter bin of fragment <italic toggle="yes">F<sub>i</sub></italic>. When inserting a k-mer from fragment <italic toggle="yes">F<sub>i</sub></italic> into the IBF, we compute all <italic toggle="yes">h</italic> hash values, which point us to the corresponding subvectors <italic toggle="yes">SV<sub>j</sub></italic> and then simply set the <italic toggle="yes">i</italic>th bit of this subvector to 1.</p>
      <fig position="float" id="btac223-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Example of an IBF construction. In the first step, we subdivide the reference sequence into three overlapping fragments. Then, for each k-mer of the differently colored fragments, all three hash values have to be calculated. The resulting hash values determine the subvector <italic toggle="yes">SV<sub>j</sub></italic> in which the corresponding bit is set to 1. For example, the second hash function for k-mer <italic toggle="yes">CAGGATT</italic> from fragment <italic toggle="yes">F</italic><sub>3</sub> returns <italic toggle="yes">k</italic>. Hence, we set the third bit of subvector <italic toggle="yes">SV<sub>k</sub></italic> to 1. In this way, the three Bloom Filters for the three fragments are combined in an interleaved fashion. Since we have three fragments in our example, the length of every subvector is three, and the length of the IBF is 3<italic toggle="yes">x</italic>, where <italic toggle="yes">x</italic> is the defined length for every Bloom Filter of the three fragments</p>
        </caption>
        <graphic xlink:href="btac223f1" position="float"/>
      </fig>
      <p>When querying a read <italic toggle="yes">p</italic> against the IBF in order to check if it maps to any of the fragments, every k-mer of that read is matched against the IBF. That means we first retrieve the <italic toggle="yes">h</italic> subvectors <italic toggle="yes">SV<sub>j</sub></italic> and apply a logical AND to them, resulting in the required binning bitvector indicating the membership of the k-mers in the bins. The example in <xref rid="btac223-F2" ref-type="fig">Figure 2</xref> visualizes this process. Here, the read consists of four 7-mers, for which we have to calculate the three hash values that point us to the corresponding subvectors <italic toggle="yes">SV<sub>j</sub></italic>, as can be seen in particular for the 7-mer <italic toggle="yes">CAGGATT</italic>. A logical AND of these three subvectors gives us the binning bitvector for that 7-mer. In our example, the binning vector 010 for <italic toggle="yes">CAGGATT</italic> tells us that this 7-mer only matches fragment <italic toggle="yes">F</italic><sub>2</sub>. Applying this procedure to every 7-mer of the read gives us four binning bit vectors. Finally, we only need to sum up the 1-bits in the binning vectors for every fragment, which gives us the number of matching 7-mers of the read for every fragment. Thus, instead of computing <italic toggle="yes">h</italic> hash values for every Bloom Filter separately, we only need to compute the <italic toggle="yes">h</italic> hash values once, which poses a significant reduction in computing time to investigate the membership of a k-mer in every Bloom Filter. This method enables us to quickly count the number of matching k-mers between the reference genome and a specific nanopore read. The challenge is to define a threshold value for the number of matching k-mers required to accept a certain nanopore read as a match against a fragment and thus as a match with the reference genome. In our example in <xref rid="btac223-F2" ref-type="fig">Figure 2</xref>, we consider the read matching fragment <italic toggle="yes">F</italic><sub>2</sub> because three of the four 7-mers match with that fragment. In general, the best threshold value depends on the length of the nanopore read and the expected sequencing error rate. We will describe our method for determining this value in the next section.</p>
      <fig position="float" id="btac223-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Finding the correct fragment for a given read <italic toggle="yes">p</italic>. For each k-mer of read <italic toggle="yes">p</italic>, we calculate the three hash values using the same hash functions as for the IBF construction. We use the resulting hash values to find the corresponding subvectors of the IBF. The sub bitvectors are combined with a bitwise AND to a binning bitvector. For all set bits in the binning vectors of the k-mers, we increment the counter of the corresponding bin in a counting vector. Bins whose counter is greater than or equal to a given threshold t are considered to contain the read <italic toggle="yes">p</italic>. In this example, we show the calculation of the binning bitvector for the 7-mer CAGGATT. Using the same three hash functions as for the IBF construction in <xref rid="btac223-F1" ref-type="fig">Figure 1</xref>, we get the subvectors SV2, SVk and SVx. We combine these three subvectors via logical AND to get the binning bitvector. The same procedure is applied to the other three 7-mers, and with the resulting four binning bitvectors, we can calculate the number of matching 7-mers of read <italic toggle="yes">p</italic> with each fragment. If at least three 7-mers match against one fragment, we accept the read as a match with the reference sequence</p>
        </caption>
        <graphic xlink:href="btac223f2" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Optimal bitvector size</title>
      <p>In a first step, ReadBouncer produces overlapping fragments of the given reference sequences, e.g. 100 000 nucleotide long fragments with an overlap of 500 base pairs. Each of those fragments represents a single bin in the IBF. The constituting k-mers of each fragment are hashed using three different hash functions, and the bits of the corresponding index positions in the IBF are set to one (<xref rid="btac223-F1" ref-type="fig">Fig. 1</xref>). Then, ReadBouncer automatically calculates the optimal IBF size in bits (Bits<sub>IBF</sub>) based on the following equations.
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>Bits</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>IBF</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>frag</mml:mtext></mml:mrow></mml:msub><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>Bits</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>SBF</mml:mtext></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic toggle="yes">n</italic><sub>frag</sub> is defined as the number of fragments with maximum size <italic toggle="yes">F</italic> and Bits<sub>SBF</sub> as a single Bloom filter size for a single fragment. Let max<sub>kmer</sub> be the maximum number of k-mers for a fragment of size <italic toggle="yes">F</italic>, and k-mer size <italic toggle="yes">k</italic> be defined as
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>kmer</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>F</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1.</mml:mn></mml:mrow></mml:math></disp-formula></p>
      <p>To calculate the optimal size for the IBF, we use the formula for finding the false positive (FP) rate in an IBF as proposed by <xref rid="btac223-B7" ref-type="bibr">Dadi <italic toggle="yes">et al.</italic> (2018)</xref>
 <disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>Bits</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>SBF</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>kmer</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow><mml:mi>h</mml:mi></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Then the optimal size of a single Bloom filter can be calculated by resolving the formula for Bits<sub>SBF</sub>:
<disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>Bits</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>SBF</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mi>h</mml:mi><mml:mo>×</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mtext>kmer</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>h</mml:mi></mml:mfrac></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">h</italic> is the number of used hash functions and <italic toggle="yes">p</italic> a predefined FP rate. ReadBouncer implicitly uses three hash functions and a maximum FP rate of 0.01 to minimize the number of false matches between the query sequence and a single bin of the IBF.</p>
    </sec>
    <sec>
      <title>2.3 Minimum number of k-mer matches</title>
      <p>During the read classification step, the k-mers of every read are hashed with the same three hash functions, and the number of matching k-mers for every bin is calculated as visualized in <xref rid="btac223-F2" ref-type="fig">Figure 2</xref>. We accept a read as part of the reference sequence if the number of matching k-mers is greater than or equal to a given threshold <italic toggle="yes">t</italic> for at least one bin. We calculate the threshold using the expected sequencing error rate <italic toggle="yes">e</italic> and the definition of a <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> confidence interval of the number of erroneous k-mers as recently provided by (<xref rid="btac223-B2" ref-type="bibr">Blanca <italic toggle="yes">et al.</italic>, 2022</xref>). They first defined the expected number of erroneous k-mers as follows:
<disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>err</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>×</mml:mo><mml:mi>q</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>For a given read <italic toggle="yes">r</italic> with length len(<italic toggle="yes">r</italic>) and k-mer length <italic toggle="yes">k</italic>, we denote the number of k-mers of read <italic toggle="yes">r</italic> as <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>=</mml:mo><mml:mtext>len</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and <italic toggle="yes">q</italic> is defined by <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In a second step, they show that the variance for the number of erroneous k-mers can be calculated by
<disp-formula id="E6"><label>(6)</label><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>err</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="true">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="true">(</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mfrac><mml:mn>2</mml:mn><mml:mi>e</mml:mi></mml:mfrac><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="true">)</mml:mo><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mo> </mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo stretchy="true">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>Finally, they define the <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> confidence interval by:
<disp-formula id="E7"><label>(7)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>err</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>±</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mo>α</mml:mo></mml:msub><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>err</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>with <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mo>α</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mo>α</mml:mo><mml:mn>2</mml:mn></mml:mfrac><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math></inline-formula>, where we denote <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mo>ϕ</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> as the inverse of the cumulative distribution function of the standard Gaussian distribution. Based on the calculation of the confidence interval for the number of erroneous k-mers, we define our threshold for the minimum number of matching k-mers for read <italic toggle="yes">r</italic> as:
<disp-formula id="E8"><label>(8)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:mtext>min</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>match</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>L</mml:mi><mml:mo>−</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>err</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mo>α</mml:mo></mml:msub><mml:msqrt><mml:mrow><mml:mtext>Var</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>err</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msqrt><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We classify a read as a match if the number of matching k-mers is bigger or equal to <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mtext>min</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mtext>match</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for at least one bin in the IBF. ReadBouncer per default calculates this threshold for a 95%-confidence-interval, an expected sequencing error rate of 10%, and k-mer length 13. However, these values as well as the fragment size are adjustable via configuration parameters of the command line or graphical user interface (GUI).</p>
    </sec>
    <sec>
      <title>2.4 Workflow</title>
      <p>The workflow of our tool consists of two consecutive parts. First, we build one or more indexes of the given reference sequence dataset, which can be used as target or depletion filters. These indexes can be used directly in the second part of the workflow or stored on the computer hard disk for later usage. The construction of this index, for which we apply IBFs, is explained in further detail in Section 2.1. The second part of our tool is the live-depletion or target-enrichment task (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>). Here, ReadBouncer initially loads the indexes and waits for the nanopore device to start sequencing. Immediately after sequencing has begun, the sequencer streams raw electrical currents for every single molecule from every single sequencing pore of the flow cell to our integrated Read-Until client. Oxford Nanopore provides this functionality via an API of its MinKNOW control software (<ext-link xlink:href="https://github.com/nanoporetech/minknow_api" ext-link-type="uri">https://github.com/nanoporetech/minknow_api</ext-link>), which allows our Read-Until client to receive the raw data while the molecule traverses through the pore. The client is implemented in C++ and communicates with the MinKNOW control software via gRPC remote procedure calls (<ext-link xlink:href="https://github.com/grpc/grpc" ext-link-type="uri">https://github.com/grpc/grpc</ext-link>).</p>
      <p>Received raw signal data get pushed onto a base-calling queue, and a separate thread takes raw signals of each read from the queue and sends it to the chosen base-calling algorithm, which translates the electrical currents into a nucleotide string. The user can choose GPU base-calling with ONT’s Guppy basecaller for which we integrated a guppy client that communicates with a guppy basecall server. In addition, we integrated DeepNano-blitz (<xref rid="btac223-B4" ref-type="bibr">Boža <italic toggle="yes">et al.</italic>, 2020</xref>) for the base-calling step, which is fast enough to perform the base-calling in real-time, even on CPUs.</p>
      <p>Base called reads get pushed to the classification queue if the read length is bigger than or equal to 200 nucleotides, and another thread takes each read from that queue and passes it to the classification framework. Otherwise, the thread marks this read as ‘pending’ and waits for the following data chunk to be base called and concatenates the base called sequences of the read until the minimum read length has been reached. The minimum read length of 200 nucleotides ensures higher confidence in the classification of the reads. In practice, this read length requirement will lead to most reads having about 360 nucleotides length, which corresponds to two data chunks sent by the MinKNOW software. The read classification thread then queries the read sequence against the loaded IBF indexes as described in more detail in Section 2.1. Based on the classification, reads can either be marked for a rejection or continue further sequencing. If a read was not classified for rejection on a first try, we mark it as <italic toggle="yes">once_seen</italic> and wait for further sequencing data to try further classification attempts of that read. After the read has reached a maximum read length of 1500 bp we stop trying to make ejection decisions and mark the read for continued sequencing as usual. Reads that have been classified for rejection or continued sequencing are finally pushed to the response queue and no further data chunks of that read are sent by the control software.</p>
      <p>The last thread takes the classified reads from the response queue, and our Read-Until client sends response messages back to the MinKNOW control software for each read. The client sends an unblock message for reads that could be matched to the IBF, telling the sequencer to eject the corresponding DNA molecule. A <italic toggle="yes">stop_further_data</italic> message is sent to the control software for reads that were not classified for rejection. This message tells MinKNOW to continue sequencing the corresponding DNA molecule and send no additional chunks of data for that read.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>In this study, we show how adaptive sampling benefits from our improved read classification approach. Therefore, we designed experiments that specifically focus on the evaluation of this approach when applied to both adaptive sampling strategies, depletion and targeted sequencing. In a first step, we compare ReadBouncer to minimap2 (<xref rid="btac223-B11" ref-type="bibr">Li, 2018</xref>), which is used for classification by Readfish, and the pan-genomics matching tool SPUMONI (<xref rid="btac223-B1" ref-type="bibr">Ahmed <italic toggle="yes">et al.</italic>, 2021</xref>), which is proposed as an alternative to minimap2 in targeted nanopore sequencing pipelines. Here, we assess all three tools on simulated and real reads from a recently published microbial mock community (<xref rid="btac223-B17" ref-type="bibr">Nicholls <italic toggle="yes">et al.</italic>, 2019</xref>). In a second experiment, we compare ReadBouncer with Readfish in an adaptive sampling setting using the playback feature offered by Oxford Nanopore’s MinKNOW software to replay an already completed sequencing run. We assess both tools by targeting chromosomes 21 and 22 in a human whole genome sequencing run, looking at their ability to correctly filter out all other human nanopore reads. Here, we do not compare against SPUMONI because there exists no adaptive sampling pipeline integrating SPUMONI for read classification.</p>
    <p>We perform all experiments for classification performance assessment on a laptop with a 2.8 GHz Intel Core i7-7700HQ CPU and 16 GB of memory with an Ubuntu 20.04 OS installed. For the classification evaluation, we run each tool with a single thread for runtime comparisons and record the wall clock time and peak resident set size (RSS) reported by the individual tools or GNU time 1.7.</p>
    <sec>
      <title>3.1 Evaluating read classification</title>
      <sec>
        <title>3.1.1 Experimental setup</title>
        <p>During a nanopore targeted sequencing experiment with ONT’s ReadUntil functionality, the sequencing device transmits electrical current data via the MinKNOW control software to ReadBouncer. This data is received as chunks, representing a maximum of 0.4 or 0.8 s of sequencing, depending on the MinKNOW configuration. Since a DNA molecule translocates through the pore at a speed of about 450 bases per second, 0.4 s of sequencing represents about 180 bases of data. In the following experiments, we mimic the situation where a chunk represents 0.4 s of sequencing data received and base called immediately by an adaptive sampling tool. Since we aim to make rejection decisions as early as possible while still being able to classify most of the reads correctly, we want to assess the classification accuracy of the 3 tools after two chunks of data, which correspond to 360 nucleotides or 0.8 s of sequencing. In this section, we assume that base-calling has already been performed. For a fair comparison, we set up all experiments in such a way that all three tools, minimap2, SPUMONI and ReadBouncer, attempt to classify reads based on the 360 bases long read prefix. In practice, all reads, both simulated and real reads, were cut to only the first 360 bases. ReadBouncer then hashes all k-mers of these 360 bases and compares the hash values to a prebuilt IBF of the depletion target references to make classification decisions.</p>
        <p>We use the software’s default settings for the SPUMONI approach, which means splitting the prefix into substrings of 90 nucleotides each for further read classification. SPUMONI also needs a prebuild index of the references but has to include the reverse complement of the depletion target references. SPUMONI matches the substrings against this positive index and a null index, consisting of the reverse sequences of the positive index. Finally, classification decisions are made by using a Kolmogorov-Smirnov test.</p>
        <p>For the minimap2-based approach, we evaluate two different parameter settings. First, we mimic the read classification of Readfish by using the mappy Python interface (<ext-link xlink:href="https://pypi.org/project/mappy/" ext-link-type="uri">https://pypi.org/project/mappy/</ext-link>) for minimap2. Here, we align the read prefixes with the <italic toggle="yes">map-ont</italic> settings, which are the same settings used by Readfish and correspond to k-mer size of 15. Since the choice of the k-mer size has an impact on the classification performance, we also aligned the read prefixes using a k-mer size of 13 in a second experiment to ensure a fair comparison with ReadBouncer.</p>
        <p>To evaluate the three tools, reads correctly classified as belonging to the depletion target are considered true positives (TP), while reads falsely classified for depletion are called FP. Consistently, reads that are correctly not classified as depletion target are considered true negatives (TN), and reads belonging to the depletion target but not classified for depletion are called false negatives (FN). We calculate the classification accuracy, precision, recall, specificity and F1-score for all three approaches based on those considerations. Since we assume an imbalanced number of sequenced reads between depletion and enrichment targets, we also report the MCC in every experiment.</p>
      </sec>
      <sec>
        <title>3.1.2 Simulated mock community</title>
        <p>In the first dataset, we consider simulated ONT-like reads derived from the identical genomes of the ZymoBIOMICS High Molecular Weight DNA Mock Microbial community (ZymoMC) (<xref rid="btac223-B17" ref-type="bibr">Nicholls <italic toggle="yes">et al.</italic>, 2019</xref>). This mock community consists of seven bacterial species—<italic toggle="yes">Enterococcus faecalis</italic>, <italic toggle="yes">Listeria monocytogenes</italic>, <italic toggle="yes">Bacillus subtilis</italic>, <italic toggle="yes">Salmonella enterica</italic>, <italic toggle="yes">Escherichia coli</italic>, <italic toggle="yes">Staphylococcus aureus</italic> and <italic toggle="yes">Pseudomonas aeruginosa</italic>—as well as <italic toggle="yes">Saccharomyces cerevisiae</italic>. We use PBSIM2 (<xref rid="btac223-B20" ref-type="bibr">Ono <italic toggle="yes">et al.</italic>, 2021</xref>) to simulate Oxford-Nanopore-like reads (R9.4 pores) from Zymo Mock Community references at varying levels of mean read accuracy: 80%, 85%, 90%, 95% and 98%. Furthermore, we simulated proportions of reads from each genome in such a way to mimic a scenario where only 2.16% of reads originate from <italic toggle="yes">S.cerevisiae</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>). The goal here is to enrich <italic toggle="yes">S.cerevisiae</italic> sequences by correctly classifying bacterial reads, which we would aim to eject from the pores in a real nanopore sequencing run. This can be considered as a depletion-only experiment, where a priori only the depletion references are known, but not the enrichment targets. Therefore, we build an index of the seven bacterial reference genomes and query all bacterial and yeast reads against the index. Consistent with our definition in Section 3.1.1, we consider correctly classified bacterial reads TP, while yeast reads found in the index are considered FP. In addition, we define bacterial reads that are missed to be found by a tool in the index as FN, and yeast reads that are not found in the index are considered TN.</p>
        <p>On all read accuracy levels, ReadBouncer consistently demonstrates best accuracy, recall, precision, F1-scores and MCC (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>). <xref rid="btac223-F3" ref-type="fig">Figure 3</xref> visualizes recall and specificity for the three tools across various read accuracies. It can be observed that recall improves with increasing read accuracy for all three tools while specificity stays almost unchanged. On all read accuracy levels, ReadBouncer demonstrates slightly but consistently better recall (sensitivity) than SPUMONI, while both tools outperform minimap2. Minimap2 is the only tool that shows 100% specificity, but ReadBouncer comes close to 100% as well. SPUMONI lags a bit behind the specificity scores of the other two tools. It can be seen that ReadBouncer is the best performing tool for this read classification task. It combines high recall (sensitivity) with high specificity. The other two tools either have high recall but lower specificity or high specificity but lower recall scores.</p>
        <fig position="float" id="btac223-F3">
          <label>Fig. 3.</label>
          <caption>
            <p>Visualization of (<bold>a</bold>) recall and (<bold>b</bold>) specificity with varying simulated read accuracies for ReadBouncer, minimap2 and SPUMONI</p>
          </caption>
          <graphic xlink:href="btac223f3" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>3.1.3 Real mock community</title>
        <p>Next, we applied our method to real nanopore reads from a Zymo Mock Community (NCBI BioProject PRJNA742838). After sample preparation, we sequenced the mock sample on a MinION flowcell (FLO-MIN106) with v. R9.4.1 pores (<xref rid="sup1" ref-type="supplementary-material">Supplementary Section S1</xref>). Obtained Fast5 files were base called with DeepNano-blitz using a recurrent neural network size of 48. For better comparison with minimap2, we first build a separately obtained minimap2 mapping as a gold standard. Therefore, we filter out all reads shorter than 2000 base pairs and trim the first 360 nucleotides from each read since we use these bases for later classification. Then, we mapped the trimmed reads with standard ONT settings to the ZymoMC reference genomes and only reads with a mapping quality score bigger or equal to 30 are considered confidently mapped. From these mapped reads, the trimmed 360 nucleotide long prefixes are used for the read classification by the three tools again. Proportions of reads from each genome are similar to the simulated experiment with 2.27% of reads from <italic toggle="yes">S.cerevisiae</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S4</xref>). In this experiment, we also measure the peak RSS and index size in GigaByte and the throughput for each of the tools in reads classified per second.</p>
        <p>Results in <xref rid="btac223-T1" ref-type="table">Table 1</xref> show that ReadBouncer achieves better accuracy, recall and F1-score than SPUMONI and minimap2, which both have similar results for those three measures. Minimap2 has slightly better precision and specificity than ReadBouncer. While SPUMONI has almost the same precision as ReadBouncer and minimap2, it shows significantly less specificity. These results are consistent with those for the simulated datasets in section <italic toggle="yes">Simulated Mock Community</italic> and show that ReadBouncer outperforms the other tools on read classification for short nanopore reads.</p>
        <table-wrap position="float" id="btac223-T1">
          <label>Table 1.</label>
          <caption>
            <p>Comparing ReadBouncer, SPUMONI and minimap2 across various metrics on a real Zymo Mock Community dataset consisting of seven bacterial species and <italic toggle="yes">S.cerevisiae</italic></p>
          </caption>
          <table frame="hsides" rules="groups">
            <colgroup span="1">
              <col valign="top" align="left" span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
              <col valign="top" align="char" char="." span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th rowspan="1" colspan="1">Tool</th>
                <th rowspan="1" colspan="1">ReadBouncer (<italic toggle="yes">k</italic> = 13)</th>
                <th rowspan="1" colspan="1">SPUMONI</th>
                <th rowspan="1" colspan="1">minimap2 (<italic toggle="yes">k</italic> = 15)</th>
                <th rowspan="1" colspan="1">minimap2 (<italic toggle="yes">k</italic> = 13)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td rowspan="1" colspan="1">Accuracy</td>
                <td rowspan="1" colspan="1">
                  <bold>94.50</bold>
                </td>
                <td rowspan="1" colspan="1">90.96</td>
                <td rowspan="1" colspan="1">89.33</td>
                <td rowspan="1" colspan="1">92.33</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Precision</td>
                <td rowspan="1" colspan="1">99.99</td>
                <td rowspan="1" colspan="1">99.89</td>
                <td rowspan="1" colspan="1">
                  <bold>100.00</bold>
                </td>
                <td rowspan="1" colspan="1">99.99</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Recall</td>
                <td rowspan="1" colspan="1">
                  <bold>94.38</bold>
                </td>
                <td rowspan="1" colspan="1">90.85</td>
                <td rowspan="1" colspan="1">89.08</td>
                <td rowspan="1" colspan="1">92.15</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Specificity</td>
                <td rowspan="1" colspan="1">99.73</td>
                <td rowspan="1" colspan="1">95.87</td>
                <td rowspan="1" colspan="1">
                  <bold>99.95</bold>
                </td>
                <td rowspan="1" colspan="1">
                  <bold>99.95</bold>
                </td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">F1-Score</td>
                <td rowspan="1" colspan="1">
                  <bold>97.10</bold>
                </td>
                <td rowspan="1" colspan="1">95.16</td>
                <td rowspan="1" colspan="1">94.23</td>
                <td rowspan="1" colspan="1">95.91</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">MCC</td>
                <td rowspan="1" colspan="1">
                  <bold>0.52</bold>
                </td>
                <td rowspan="1" colspan="1">0.41</td>
                <td rowspan="1" colspan="1">0.39</td>
                <td rowspan="1" colspan="1">0.45</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Peak RSS (GB)</td>
                <td rowspan="1" colspan="1">
                  <bold>0.099</bold>
                </td>
                <td rowspan="1" colspan="1">0.163</td>
                <td rowspan="1" colspan="1">0.272</td>
                <td rowspan="1" colspan="1">0.251</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Index Size (GB)</td>
                <td rowspan="1" colspan="1">
                  <bold>0.047</bold>
                </td>
                <td rowspan="1" colspan="1">0.153</td>
                <td rowspan="1" colspan="1">0.097</td>
                <td rowspan="1" colspan="1">0.090</td>
              </tr>
              <tr>
                <td rowspan="1" colspan="1">Throughput (reads per sec)</td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>5967</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">1102</td>
                <td align="center" rowspan="1" colspan="1">5632</td>
                <td align="center" rowspan="1" colspan="1">5306</td>
              </tr>
            </tbody>
          </table>
          <table-wrap-foot>
            <fn id="tblfn1">
              <p><italic toggle="yes">Note</italic>: Reads from a nanopore sequencing run are mapped to the eight organisms to generate ground truth. We use only the first 360 nucleotides for classification from those confidently mapped reads to mimic unblock decision-making after 0.8 s of sequencing the individual read. All reads are mapped against the seven bacterial reference sequences to filter out only the bacterial reads. At the same time, we want to keep as much <italic toggle="yes">S.cerevisiae</italic> reads, which corresponds to an enrichment of that organism in an enrichment/depletion experiment. Consistent with the simulated data, ReadBouncer can classify a higher percentage of bacterial reads while having slightly less precision and specificity than minimap2. Our approach also is the computationally most effective one, with the lowest memory footprint and highest classification throughput. Bold values represent the best metrics value achieved over all tools, e.g. ReadBouncer (k=13) shows highest accuracy, F1-Score, recall but also the smallest memory footprint (Peak RSS and index size).</p>
            </fn>
          </table-wrap-foot>
        </table-wrap>
        <p>Another important aspect is the amount of main memory a tool needs to hold the reference index needed for read classification. Using the seven bacterial reference genomes of the Zymo Mock Community as depletion target (reference index), ReadBouncer shows the smallest maximum memory consumption measured as Peak RSS. It only needs 0.099 GigaBytes (GB) of main memory, in contrast to 0.251 GB consumed by minimap2 with k-mer size 13. Furthermore, ReadBouncer has the smallest index file size (0.047 GB) of all three tools. In addition to the smallest memory footprint, ReadBouncer also achieves the highest classification throughput. We can classify 5967 reads per second with our approach compared to 5632 reads per second by minimap2 (k-mer size 15) and 1102 reads per second achieved by SPUMONI. These results show that ReadBouncer can correctly classify more reads and is computationally more efficient than other state-of-the-art tools used for nanopore adaptive sampling.</p>
      </sec>
    </sec>
    <sec>
      <title>3.2 Adaptive sampling evaluation</title>
      <p>In our live experiment, we assess our read classification based on IBFs in a targeted adaptive sampling setup. For this purpose, we downloaded a bulk Fast5 file of a human whole-genome sequencing experiment provided via the Github page of Readfish (<ext-link xlink:href="https://github.com/LooseLab/readfish" ext-link-type="uri">https://github.com/LooseLab/readfish</ext-link>). Such a bulk Fast5 file (<xref rid="btac223-B21" ref-type="bibr">Payne <italic toggle="yes">et al.</italic>, 2019</xref>) allows the playback of the whole sequencing run for testing if the ReadUntil functionality is working correctly. Oxford Nanopore’s MinKNOW software simulates an already finished sequencing run without the need for a physical sequencing device when performing a playback run. Compared to the original sequencing run, read signals are reported at the same time point after starting the run. Unblocking a read does not cause MinKNOW to finish sending signals for that read during a playback run. It just breaks the read when receiving an unblock message for the read and creates a new read identifier but continues to send signals of the same original read. Here, we compare ReadBouncer and Readfish using both real-time GPU base-calling with ONT’s Guppy basecaller and real-time CPU base-calling with DeepNano-blitz. While ReadBouncer integrates DeepNano, we had to use a special git branch of Readfish (<ext-link xlink:href="https://github.com/LooseLab/readfish/tree/caller_refactor" ext-link-type="uri">https://github.com/LooseLab/readfish/tree/caller_refactor</ext-link>) to facilitate CPU base calling. In all experiments, ReadBouncer and Readfish were run on a separate Ubuntu 18.04 Laptop with 16 GB RAM and Intel Core i7 while GPU live base calling and the playback were performed on an NVIDIA Jetson AGX Xavier. In addition, we compared the results with two MinKNOW adaptive sampling experiments, one using MinKNOW’s <italic toggle="yes">target</italic> and the other using MinKNOW’s <italic toggle="yes">deplete</italic> method. Both experiments were performed on the NVIDIA Jetson AGX Xavier, too.</p>
      <p>In our experiments, we do a playback of a complete human genome sequencing run with the goal to enrich for chromosomes 21 and 22 of the human genome and deplete all other human reads from that run. This setup not only mimics a targeted sequencing approach but also corresponds to the application of sequencing a clinical human blood sample where up to 99% of the reads are human reads that we would want to deplete in order to enrich the number of reads from a pathogenic microbe. We perform playback runs for 60 min on ONT’s MinKNOW control software version 4.3.3. To ensure that the vast majority of the sequenced reads are of human origin, we first perform a playback run without adaptive sampling. Reads were base called with Guppy 5.0.14 and mapped with minimap2 to the human Telomere-to-Telomere Consortium (‘T2T’) CHM13 v1.1 reference assembly (<xref rid="btac223-B18" ref-type="bibr">Nurk <italic toggle="yes">et al.</italic>, 2022</xref>). From the resulting reads passing the in-built quality filtering of MinKNOW, 99.66% could be mapped to the human reference genome. For the comparison of the tools in an adaptive sampling setting, we first adjust the <italic toggle="yes">break_reads_after_seconds</italic> parameter within MinKNOW to 0.4 s as recommended by the Readfish authors. Since MinKNOW sends data as chunks, this parameter sets the size of one chunk to a maximum of 180 nucleotides. Both tools, ReadBouncer and Readfish, can concatenate the data chunks and perform classification after the receipt of every chunk. For integrated CPU base calling with DeepNano-blitz we used a neural network size of 48 for both tools. For real-time GPU base calling on the NVIDIA Jetson AGX Xavier we used the fast base-calling mode of Guppy 5.0.14 for ReadBouncer and Readfish.</p>
      <p>For the evaluation of both tools, we repeat the same playback run for 60 min. In the experiment with CPU base calling, we ran ReadBouncer with default parameters (<inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">fragment</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">size</mml:mi><mml:mo>=</mml:mo><mml:mn>100</mml:mn><mml:mo>,</mml:mo><mml:mn>000</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">kmer</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">size</mml:mi><mml:mo>=</mml:mo><mml:mn>13</mml:mn></mml:mrow></mml:math></inline-formula>) using three base calling threads and three read classification threads, respectively. The same setting was applied to Readfish with three CPU base calling threads and minimap2 using three threads per default. Since Guppy ensures a higher raw read accuracy, we ran ReadBouncer with <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">fragment</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">size</mml:mi><mml:mo>=</mml:mo><mml:mn>200</mml:mn><mml:mo>,</mml:mo><mml:mn>000</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi mathvariant="italic">kmer</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">size</mml:mi><mml:mo>=</mml:mo><mml:mn>15</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">error</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">rate</mml:mi><mml:mo>=</mml:mo><mml:mn>0.05</mml:mn></mml:mrow></mml:math></inline-formula> in the GPU base calling experiment. In all experiments, we used chromosomes 21 and 22 as target filter and all other chromosomes as depletion filter in ReadBouncer. Our settings within the Readfish configuration file correspond to the example TOML file in the github repository (<ext-link xlink:href="https://github.com/LooseLab/readfish/blob/master/examples/human_chr_selection.toml" ext-link-type="uri">https://github.com/LooseLab/readfish/blob/master/examples/human_chr_selection.toml</ext-link>) and aim to target chromosomes 21 and 22 as well, while unblocking all reads that do not map to the targets. For MinKNOW <italic toggle="yes">target</italic> we used chromosomes 21 and 22 as reference and for MinKNOW <italic toggle="yes">deplete</italic> all other chromosomes as reference sequence. Before starting the adaptive sampling experiments, we had to build index files for all three tools. For Readfish and MinKNOW, we created minimap2 index files, which took 103 s on an Intel Core i7 with one thread and peak RSS of 11.68 GB. Building ReadBouncer index files took 478 s on the same system, but needed only 8.62 GB peak RSS. After finishing the playback run, the resulting Fast5 files were basecalled in high accuracy mode with Guppy 5.0.14. All reads in the resulting fastq files were mapped to the human genome reference and mapping statistics were calculated with Readfish’s <italic toggle="yes">summary</italic> script. Using a playback run allows a fair comparison of the different approaches since the same sequencing data come from MinKNOW during the same amount of time. Thus, we expect a similar number of on-target reads and on-target bases across all experiments. On the other hand, we expect different numbers of rejected reads while retaining similar number of bases for those reads due to the different lengths of rejected reads caused by different unblock time points. The reason is MinKNOW just splitting a sequenced read into two segments when receiving an unblock message for that read. Thus, the earlier we reject an off-target read, the shorter the read length and the more off-target reads are seen.</p>
      <p>The results of all six experiments can be seen in <xref rid="btac223-T2" ref-type="table">Table 2</xref>. Our first observation is that the results for our target chromosomes 21 and 22 are similar for all experiments but the MinKNOW <italic toggle="yes">deplete</italic> experiment. Here, the number of on-target reads is much higher while showing the smallest mean and median read lengths caused by a high number of false rejection decisions. These results suggest that MinKNOW <italic toggle="yes">deplete</italic> is not suitable for targeting single chromosomes of the human genome in an adaptive sampling experiment. On the other hand, MinKNOW <italic toggle="yes">target</italic> shows similar results for chromosomes 21 and 22 when compared to ReadBouncer and Readfish. However, the mean read length of 3629 bp measured for unblocked reads is much higher than those in the ReadBouncer and Readfish experiments, which shows that MinKNOW <italic toggle="yes">target</italic> spends too much time sequencing off-target reads. These experiments show that ReadBouncer and Readfish outperform the two MinKNOW adaptive sampling strategies.</p>
      <table-wrap position="float" id="btac223-T2">
        <label>Table 2.</label>
        <caption>
          <p>Comparison of ReadBouncer, Readfish and MinKNOW in a targeted sequencing experiment</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1"/>
              <th colspan="4" align="center" rowspan="1">ReadBouncer<hr/></th>
              <th colspan="4" align="center" rowspan="1">Readfish<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Basecaller</th>
              <th align="center" rowspan="1" colspan="1">contig</th>
              <th align="center" rowspan="1" colspan="1">Reads</th>
              <th align="center" rowspan="1" colspan="1">Bases</th>
              <th align="center" rowspan="1" colspan="1">Mean</th>
              <th align="center" rowspan="1" colspan="1">Median</th>
              <th align="center" rowspan="1" colspan="1">Reads</th>
              <th align="center" rowspan="1" colspan="1">Bases</th>
              <th align="center" rowspan="1" colspan="1">Mean</th>
              <th align="center" rowspan="1" colspan="1">Median</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">DeepNano</td>
              <td rowspan="1" colspan="1">chr21</td>
              <td rowspan="1" colspan="1">73</td>
              <td rowspan="1" colspan="1">2 208 211</td>
              <td rowspan="1" colspan="1">
                <bold>30 249</bold>
              </td>
              <td rowspan="1" colspan="1">9025</td>
              <td rowspan="1" colspan="1">73</td>
              <td rowspan="1" colspan="1">2 118 199</td>
              <td rowspan="1" colspan="1">29 016</td>
              <td rowspan="1" colspan="1">9285</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">chr22</td>
              <td rowspan="1" colspan="1">92</td>
              <td rowspan="1" colspan="1">1 179 449</td>
              <td rowspan="1" colspan="1">12 820</td>
              <td rowspan="1" colspan="1">6262</td>
              <td rowspan="1" colspan="1">91</td>
              <td rowspan="1" colspan="1">1 177 699</td>
              <td rowspan="1" colspan="1">12 942</td>
              <td rowspan="1" colspan="1">5449</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Others</td>
              <td rowspan="1" colspan="1">122 745</td>
              <td rowspan="1" colspan="1">136 441 510</td>
              <td rowspan="1" colspan="1">1112</td>
              <td rowspan="1" colspan="1">503</td>
              <td rowspan="1" colspan="1">92 527</td>
              <td rowspan="1" colspan="1">140 303 151</td>
              <td rowspan="1" colspan="1">1516</td>
              <td rowspan="1" colspan="1">1310</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Guppy</td>
              <td rowspan="1" colspan="1">chr21</td>
              <td rowspan="1" colspan="1">77</td>
              <td rowspan="1" colspan="1">2 189 976</td>
              <td rowspan="1" colspan="1">28 441</td>
              <td rowspan="1" colspan="1">
                <bold>9442</bold>
              </td>
              <td rowspan="1" colspan="1">71</td>
              <td rowspan="1" colspan="1">2 126 553</td>
              <td rowspan="1" colspan="1">29 951</td>
              <td rowspan="1" colspan="1">9262</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">chr22</td>
              <td rowspan="1" colspan="1">83</td>
              <td rowspan="1" colspan="1">1 210 472</td>
              <td rowspan="1" colspan="1">
                <bold>14 584</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>7663</bold>
              </td>
              <td rowspan="1" colspan="1">88</td>
              <td rowspan="1" colspan="1">1 178 629</td>
              <td rowspan="1" colspan="1">13 394</td>
              <td rowspan="1" colspan="1">6602</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Others</td>
              <td rowspan="1" colspan="1">154 684</td>
              <td rowspan="1" colspan="1">140 636 076</td>
              <td rowspan="1" colspan="1">907</td>
              <td rowspan="1" colspan="1">
                <bold>479</bold>
              </td>
              <td rowspan="1" colspan="1">140 267</td>
              <td rowspan="1" colspan="1">133 484 295</td>
              <td rowspan="1" colspan="1">952</td>
              <td rowspan="1" colspan="1">877</td>
            </tr>
            <tr>
              <td colspan="10" rowspan="1">
                <hr/>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td colspan="4" align="center" rowspan="1">MinKNOW <italic toggle="yes">target</italic></td>
              <td colspan="4" align="center" rowspan="1">MinKNOW <italic toggle="yes">deplete</italic></td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1"/>
              <td colspan="4" rowspan="1">
                <hr/>
              </td>
              <td colspan="4" rowspan="1">
                <hr/>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td align="center" rowspan="1" colspan="1">contig</td>
              <td align="center" rowspan="1" colspan="1">Reads</td>
              <td align="center" rowspan="1" colspan="1">Bases</td>
              <td align="center" rowspan="1" colspan="1">Mean</td>
              <td align="center" rowspan="1" colspan="1">Median</td>
              <td align="center" rowspan="1" colspan="1">Reads</td>
              <td align="center" rowspan="1" colspan="1">Bases</td>
              <td align="center" rowspan="1" colspan="1">Mean</td>
              <td align="center" rowspan="1" colspan="1">Median</td>
            </tr>
            <tr>
              <td colspan="10" rowspan="1">
                <hr/>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">chr21</td>
              <td rowspan="1" colspan="1">77</td>
              <td rowspan="1" colspan="1">2 099 268</td>
              <td rowspan="1" colspan="1">27 263</td>
              <td rowspan="1" colspan="1">9170</td>
              <td rowspan="1" colspan="1">1425</td>
              <td rowspan="1" colspan="1">2 285 420</td>
              <td rowspan="1" colspan="1">1604</td>
              <td rowspan="1" colspan="1">845</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">chr22</td>
              <td rowspan="1" colspan="1">105</td>
              <td rowspan="1" colspan="1">1 061 911</td>
              <td rowspan="1" colspan="1">10 113</td>
              <td rowspan="1" colspan="1">3368</td>
              <td rowspan="1" colspan="1">468</td>
              <td rowspan="1" colspan="1">1 219 518</td>
              <td rowspan="1" colspan="1">2606</td>
              <td rowspan="1" colspan="1">883</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Others</td>
              <td rowspan="1" colspan="1">38 656</td>
              <td rowspan="1" colspan="1">140 284 944</td>
              <td rowspan="1" colspan="1">3629</td>
              <td rowspan="1" colspan="1">520</td>
              <td rowspan="1" colspan="1">177 549</td>
              <td rowspan="1" colspan="1">132 949 878</td>
              <td rowspan="1" colspan="1">
                <bold>749</bold>
              </td>
              <td rowspan="1" colspan="1">769</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: Four 60 min playback runs of a whole human genome sequencing experiment were performed using either ReadBouncer or Readfish in combination with either DeepNano CPU base calling or Guppy GPU base calling. The same experiment was repeated with MinKNOW’s adaptive sampling functionality in <italic toggle="yes">target</italic> and <italic toggle="yes">deplete</italic> mode. The goal of all experiments was to target chromosomes 21 and 22 while rejecting all other human reads. For chromosomes 21 and 22, highest mean and median read lengths across all experiments are highlighted in bold. For rejected reads, lowest mean and median read lengths across all experiments are highlighted in bold. ReadBouncer and Readfish show consistently better results when using GPU base calling with ReadBouncer having shorter mean and median read lengths for non-target reads regardless of the used basecaller. ReadBouncer outperforms MinKNOW <italic toggle="yes">target</italic> by having longer read lengths for on-target reads and shorter read lengths for off-target reads caused by a better read classification. MinKNOW <italic toggle="yes">deplete</italic> has the worst results of all tools indicated by high numbers of on-target reads with short read lengths caused by lots of false unblock decisions for on-target reads.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>Comparing ReadBouncer with Readfish, when both tools use the same basecaller, ReadBouncer shows better results regarding median read lengths and the number of bases sequenced. We also see that the choice of the base calling tool has a significant impact on the outcome of the adaptive sampling experiment. Using Guppy GPU base calling for both tools, ReadBouncer and Readfish result in much shorter read lengths for non-target (unblocked) reads. Interestingly, we observe that unblocked reads from the ReadBouncer playback runs have shorter mean and median read lengths than those from the Readfish playback runs. This is also shown in the length distribution plots of unblocked reads for playback runs with Guppy base calling presented in <xref rid="btac223-F4" ref-type="fig">Figure 4</xref>.</p>
      <fig position="float" id="btac223-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Read length distributions of unblocked reads when using (<bold>a</bold>) ReadBouncer or (<bold>b</bold>) Readfish on a 60 min playback run of a whole human sequencing experiment with real-time Guppy GPU base calling. ReadBouncer makes faster rejection decisions than Readfish, which can be observed by shorter read lengths of unblocked nanopore reads</p>
        </caption>
        <graphic xlink:href="btac223f4" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>The idea of adaptive sampling is to selectively sequence individual DNA molecules on nanopore sequencing devices using in-silico methods. This study presents a new tool for adaptive sampling that improves read classification by combining IBFs with k-mer matching statistics. ReadBouncer shows a higher read classification sensitivity than other state-of-the-art classification tools for adaptive sampling while retaining a high specificity. Our tool also improves classification performance and memory usage compared to the other tools. We could observe shorter read lengths of non-target reads in different playback experiments when using ReadBouncer instead of Readfish. In a real experiment, this could mean that ReadBouncer investigates more DNA molecules in the same amount of sequencing time. We developed our tool as an easy-to-install software application with a graphical user interface on Linux and Windows operating systems. In addition, ReadBouncer supports fast CPU base-calling, providing even small sequencing facilities or in-field researchers that typically only have access to low-cost hardware the possibility to use the adaptive sampling feature of the MinION sequencer.</p>
    <p>The key benefit of our new tool is the improved read classification. We neither use signal nor sequence space mapping algorithms for read classification compared to other adaptive sampling tools. Instead, our IBF approach uses k-mer counting in Bloom Filters for sequence containment testing, resulting in smaller index files and fewer memory requirements. However, the improved sensitivity comes at the cost of decreased classification speed with increasing reference database size due to our approach of fragmenting the reference genome sequences and using one bin of the IBF per fragment. The fragmentation approach ensures a high classification specificity for nanopore reads with high error rates of approximately 10–15% as observed by the CPU basecaller DeepNano-blitz (<xref rid="btac223-B4" ref-type="bibr">Boža <italic toggle="yes">et al.</italic>, 2020</xref>). This error rate forces us to use small k-mer sizes such as 13, which entails the need for smaller fragment sizes down to 100 000 nucleotides to avoid too many FP matches. Using real-time GPU base-calling with single raw read accuracies of about 94% allows increasing the k-mer size to 15 and fragment size to 200 000, reducing the number of bins in the IBF by 50%. In the future, we expect to use even fewer fragments per genome and consequentially improve the classification speed for larger genomes as Oxford Nanopore is steadily improving its per-read accuracy. This could also enable the usage of our IBF approach for real-time metagenomics classification of nanopore reads or the construction of pan-genomics indexes that store all different haplotypes of a pathogen in one IBF, with one haplotype per bin. To further increase performance, combining ReadBouncer and minimap2 could be worthwhile, as the integration of different methods in related fields has demonstrated (<xref rid="btac223-B23" ref-type="bibr">Piro <italic toggle="yes">et al.</italic>, 2017</xref>).</p>
    <p>A second key feature of ReadBouncer is its support for fast and accurate real-time GPU base-calling with ONT’s Guppy and real-time CPU base-calling with DeepNano-blitz. This study showed that both approaches show reliable results for a whole human sequencing playback run with the application to target specific chromosomes while rejecting reads belonging to all other chromosomes. Since there are some performance drawbacks of MinKNOW when using a playback run, the measured read lengths of rejected reads can deviate to a real experiment. Other users (<ext-link xlink:href="https://github.com/sirselim/jetson_nanopore_sequencing" ext-link-type="uri">https://github.com/sirselim/jetson_nanopore_sequencing</ext-link>) reported much shorter unblocked read lengths on real experiments performed on NVIDIA Jetson AGX Xavier. To ensure reproducibility and fair comparison between tools and to reduce the influence of potential artifacts, we evaluated our tool here on a playback of a well-performed experimental run rather than during run-time of the sequencer. Since a playback run is data from a real sequencing experiment, we do not expect any bias from this comparison but can guarantee a fair comparison between tools. We also do not expect any negative impact on ReadBouncer’s classification approach’s improved sensitivity by using a playback run.</p>
    <p>We expect that ReadBouncer can also contribute to the field of pathogen detection in non-model organisms. Metagenomics sequencing of such samples easily consists of up to 99% host reads that can be depleted with adaptive sampling resulting in an in-silico enrichment of pathogenic reads as shown by other research groups (<xref rid="btac223-B13" ref-type="bibr">Marquet <italic toggle="yes">et al.</italic>, 2022</xref>; <xref rid="btac223-B14" ref-type="bibr">Martin <italic toggle="yes">et al.</italic>, 2022</xref>). Here, our CPU-based approach also makes access to adaptive sampling much easier for researchers studying wild living animals in the field. With Nanopores being successfully applied to peptide sequencing (<xref rid="btac223-B5" ref-type="bibr">Brinkerhoff <italic toggle="yes">et al.</italic>, 2021</xref>), we also see possible modifications of the approach to be useful for targeted protein sequencing.</p>
    <p>Another potential use case for adaptive sampling is the real-time detection of antibiotic resistance and virulence genes. In their recently published study, <xref rid="btac223-B30" ref-type="bibr">Zhou <italic toggle="yes">et al.</italic> (2021)</xref> showed that direct nanopore metagenomics sequencing of human blood samples could detect pathogens in real-time but fails to detect antibiotic resistance genes. They compared direct metagenomic sequencing approach to MinION sequencing of blood culture samples. Using blood cultures, they could deplete human reads to about 65% of all sequenced reads in the corresponding sample, which was sufficient to identify more than 80% of resistance genes after 2 hours of sequencing. We expect that the number of sequenced human host reads can be depleted at a similar rate by using adaptive sampling, which was already shown by Marquet <italic toggle="yes">et al.</italic> This could reduce costs and decrease the time to detect pathogens in human blood samples. In the future, a point-of-care test for antibiotic resistance genes in human patient samples that also avoids shipping the samples to a nearby laboratory could decrease antibiotic drugs’ usage and help restrict the development of antibiotic resistance that are a burden to many health care systems all over the world. Besides further sample preparation and sequencing technology improvements, we encourage scientists to set up proof-of-principle studies investigating the potential application of adaptive sampling for real-time AMR gene detection.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btac223_Supplementary_Data</label>
      <media xlink:href="btac223_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Vitor C. Piro and Tobias P. Loka (HPI) and Knut Reinert (FU Berlin) for valuable discussions and comments on the usage of IBFs and Martin Beer (FLI) for insights into Nanopore sequencing. They thank the Genome Sequencing Unit at Robert Koch Institute for sequencing of the ZymoBIOMICS Mock Community.</p>
    <sec>
      <title>Funding</title>
      <p>This work was supported by a grant from the BMBF/German Center for Infection Research [TI 06.904—FP2019 to B.Y.R.].</p>
      <p><italic toggle="yes">Conflict of Interest</italic>: J.-U.U. and B.Y.R. have filed a patent application on selective nanopore sequencing approaches.</p>
    </sec>
  </ack>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btac223-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ahmed</surname><given-names>O.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Pan-genomic matching statistics for targeted nanopore sequencing</article-title>. <source>iScience</source>, <volume>24</volume>, <fpage>102696</fpage>.<pub-id pub-id-type="pmid">34195571</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blanca</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2022</year>) <article-title>The statistics of k-mers from a sequence undergoing a simple mutation process without spurious matches</article-title>. <source>J. Comput. Biol</source>., <volume>29</volume>, <fpage>155</fpage>–<lpage>168</lpage>.<pub-id pub-id-type="pmid">35108101</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bloom</surname><given-names>B.H.</given-names></string-name></person-group> (<year>1970</year>) <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun. ACM</source>, <volume>13</volume>, <fpage>422</fpage>–<lpage>426</lpage>.</mixed-citation>
    </ref>
    <ref id="btac223-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Boža</surname><given-names>V.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Deepnano-blitz: a fast base caller for minion nanopore sequencers</article-title>. <source>Bioinformatics</source>, <volume>36</volume>, <fpage>4191</fpage>–<lpage>4192</lpage>.<pub-id pub-id-type="pmid">32374816</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Brinkerhoff</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Multiple rereads of single proteins at single–amino acid resolution using nanopores</article-title>. <source>Science</source>, <volume>374</volume>, <fpage>eabl4381</fpage>–<lpage>1513</lpage>.</mixed-citation>
    </ref>
    <ref id="btac223-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Broder</surname><given-names>A.Z.</given-names></string-name></person-group> (<year>1997</year>) On the resemblance and containment of documents. In: <italic toggle="yes">Proceedings. Compression and Complexity of SEQUENCES 1997 (Cat. No. 97TB100171)</italic>. IEEE Comput. Soc. Salerno, Italy, pp. <fpage>21</fpage>–<lpage>29</lpage></mixed-citation>
    </ref>
    <ref id="btac223-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dadi</surname><given-names>T.H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Dream-yara: an exact read mapper for very large databases with short update time</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i766</fpage>–<lpage>i772</lpage>.<pub-id pub-id-type="pmid">30423080</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koslicki</surname><given-names>D.</given-names></string-name>, <string-name><surname>Zabeti</surname><given-names>H.</given-names></string-name></person-group> (<year>2019</year>) <article-title>Improving minhash via the containment index with applications to metagenomic analysis</article-title>. <source>Appl. Math. Comput</source>., <volume>354</volume>, <fpage>206</fpage>–<lpage>215</lpage>.</mixed-citation>
    </ref>
    <ref id="btac223-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kovaka</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Targeted nanopore sequencing by real-time mapping of raw electrical signal with uncalled</article-title>. <source>Nat. Biotechnol</source>., <volume>39</volume>, <fpage>431</fpage>–<lpage>441</lpage>.<pub-id pub-id-type="pmid">33257863</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Leggett</surname><given-names>R.M.</given-names></string-name>, <string-name><surname>Clark</surname><given-names>M.D.</given-names></string-name></person-group> (<year>2017</year>) <article-title>A world of opportunities with nanopore sequencing</article-title>. <source>J. Exp. Bot</source>., <volume>68</volume>, <fpage>5419</fpage>–<lpage>5429</lpage>.<pub-id pub-id-type="pmid">28992056</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3094</fpage>–<lpage>3100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loose</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Real-time selective sequencing using nanopore technology</article-title>. <source>Nat. Methods</source>, <volume>13</volume>, <fpage>751</fpage>–<lpage>754</lpage>.<pub-id pub-id-type="pmid">27454285</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Marquet</surname><given-names>M.</given-names></string-name></person-group> et al. (2022). Evaluation of microbiome enrichment and host dna depletion in human vaginal samples using oxford nanopore’s adaptive sequencing. Scientific reports, 12, 1–10.</mixed-citation>
    </ref>
    <ref id="btac223-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Martin</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2022</year>) <article-title>Nanopore adaptive sampling: a tool for enrichment of low abundance species in metagenomic samples</article-title>. <source>Genome Biol</source>., <volume>23</volume>, <fpage>11</fpage>–<lpage>27</lpage>.<pub-id pub-id-type="pmid">35067223</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mikheyev</surname><given-names>A.S.</given-names></string-name>, <string-name><surname>Tin</surname><given-names>M.M.</given-names></string-name></person-group> (<year>2014</year>) <article-title>A first look at the oxford nanopore minion sequencer</article-title>. <source>Mol. Ecol. Resour</source>., <volume>14</volume>, <fpage>1097</fpage>–<lpage>1102</lpage>.<pub-id pub-id-type="pmid">25187008</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mongan</surname><given-names>A.E.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>Portable sequencer in the fight against infectious disease</article-title>. <source>J. Hum. Genet</source>., <volume>65</volume>, <fpage>35</fpage>–<lpage>40</lpage>.<pub-id pub-id-type="pmid">31582773</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nicholls</surname><given-names>S.M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Ultra-deep, long-read nanopore sequencing of mock microbial community standards</article-title>. <source>Gigascience</source>, <volume>8</volume>, <fpage>giz043</fpage>.<pub-id pub-id-type="pmid">31089679</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nurk</surname>,<given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2022</year>) <article-title>The complete sequence of a human genome</article-title>. <source><italic toggle="yes">Science </italic></source>, <volume>376</volume>, <fpage>44</fpage>–<lpage>53</lpage>. https://doi.org/<pub-id pub-id-type="doi">10.1126/science.abj6987</pub-id>.<pub-id pub-id-type="pmid">35357919</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ondov</surname><given-names>B.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Mash: fast genome and metagenome distance estimation using minhash</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>1</fpage>–<lpage>14</lpage>.<pub-id pub-id-type="pmid">26753840</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ono</surname><given-names>Y.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Pbsim2: a simulator for long-read sequencers with a novel generative model of quality scores</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>589</fpage>–<lpage>595</lpage>.<pub-id pub-id-type="pmid">32976553</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Payne</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Bulkvis: a graphical viewer for oxford nanopore bulk fast5 files</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>2193</fpage>–<lpage>2198</lpage>.<pub-id pub-id-type="pmid">30462145</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Payne</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Readfish enables targeted nanopore sequencing of gigabase-sized genomes</article-title>. <source>Nat. Biotechnol</source>., <volume>39</volume>, <fpage>442</fpage>–<lpage>450</lpage>.<pub-id pub-id-type="pmid">33257864</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Piro</surname><given-names>V.C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Metameta: integrating metagenome analysis tools to improve taxonomic profiling</article-title>. <source>Microbiome</source>, <volume>5</volume>, <fpage>1</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">28086968</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Piro</surname><given-names>V.C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020</year>) <article-title>ganon: precise metagenomics classification against large and up-to-date sets of reference sequences</article-title>. <source>Bioinformatics</source>, <volume>36</volume>, <fpage>i12</fpage>–<lpage>i20</lpage>.<pub-id pub-id-type="pmid">32657362</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Quick</surname><given-names>J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Real-time, portable genome sequencing for ebola surveillance</article-title>. <source>Nature</source>, <volume>530</volume>, <fpage>228</fpage>–<lpage>232</lpage>.<pub-id pub-id-type="pmid">26840485</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rang</surname><given-names>F.J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>From squiggle to basepair: computational approaches for improving nanopore sequencing read accuracy</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>1</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">29301551</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Runtuwene</surname><given-names>L.R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>On-site minion sequencing</article-title>. <source>Single Mol. Single Cell Sequencing</source>, <bold>1129</bold>, <fpage>143</fpage>–<lpage>150</lpage>.</mixed-citation>
    </ref>
    <ref id="btac223-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Sim</surname><given-names>J.</given-names></string-name>, <string-name><surname>Chapman</surname><given-names>B.</given-names></string-name></person-group> (<year>2019</year>) <article-title>In-field whole genome sequencing using the minion nanopore sequencer to detect the presence of high-prized military targets</article-title>. <source>Aust. J. Forensic Sci</source>., <volume>51</volume>, <fpage>S86</fpage>–<lpage>S90</lpage>.</mixed-citation>
    </ref>
    <ref id="btac223-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wick</surname><given-names>R.R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Performance of neural network basecalling tools for oxford nanopore sequencing</article-title>. <source>Genome Biol</source>., <volume>20</volume>, <fpage>1</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">30606230</pub-id></mixed-citation>
    </ref>
    <ref id="btac223-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Comprehensive pathogen identification, antibiotic resistance, and virulence genes prediction directly from simulated blood samples and positive blood cultures by nanopore metagenomic sequencing</article-title>. <source>Front. Genet</source>., <volume>12</volume>, <fpage>620009</fpage>.<pub-id pub-id-type="pmid">33841495</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
