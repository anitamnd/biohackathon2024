<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9940620</article-id>
    <article-id pub-id-type="pmid">36749013</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad074</article-id>
    <article-id pub-id-type="publisher-id">btad074</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Optimal gap-affine alignment in <italic toggle="yes">O</italic>(<italic toggle="yes">s</italic>) space</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7951-3914</contrib-id>
        <name>
          <surname>Marco-Sola</surname>
          <given-names>Santiago</given-names>
        </name>
        <aff><institution>Computer Sciences Department, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors i Sistemes Operatius, Universitat Autònoma de Barcelona</institution>, Barcelona 08193, <country country="ES">Spain</country></aff>
        <xref rid="btad074-cor1" ref-type="corresp"/>
        <!--santiagomsola@gmail.com-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8345-8356</contrib-id>
        <name>
          <surname>Eizenga</surname>
          <given-names>Jordan M</given-names>
        </name>
        <aff><institution>Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-9744-131X</contrib-id>
        <name>
          <surname>Guarracino</surname>
          <given-names>Andrea</given-names>
        </name>
        <aff><institution>Genomics Research Centre, Human Technopole</institution>, Milan 20157, <country country="IT">Italy</country></aff>
        <aff><institution>Department of Genetics, Genomics and Informatics, University of Tennessee Health Science Center</institution>, Memphis, TN 38163, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8863-3539</contrib-id>
        <name>
          <surname>Paten</surname>
          <given-names>Benedict</given-names>
        </name>
        <aff><institution>Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-3821-631X</contrib-id>
        <name>
          <surname>Garrison</surname>
          <given-names>Erik</given-names>
        </name>
        <aff><institution>Department of Genetics, Genomics and Informatics, University of Tennessee Health Science Center</institution>, Memphis, TN 38163, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9848-8758</contrib-id>
        <name>
          <surname>Moreto</surname>
          <given-names>Miquel</given-names>
        </name>
        <aff><institution>Computer Sciences Department, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors, Universitat Politècnica de Catalunya</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Martelli</surname>
          <given-names>Pier Luigi</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad074-cor1">To whom correspondence should be addressed. <email>santiagomsola@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-02-07">
      <day>07</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>07</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>2</issue>
    <elocation-id>btad074</elocation-id>
    <history>
      <date date-type="received">
        <day>17</day>
        <month>8</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>02</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>30</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>20</day>
        <month>2</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad074.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Pairwise sequence alignment remains a fundamental problem in computational biology and bioinformatics. Recent advances in genomics and sequencing technologies demand faster and scalable algorithms that can cope with the ever-increasing sequence lengths. Classical pairwise alignment algorithms based on dynamic programming are strongly limited by quadratic requirements in time and memory. The recently proposed wavefront alignment algorithm (WFA) introduced an efficient algorithm to perform exact gap-affine alignment in <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <italic toggle="yes">s</italic> is the optimal score and <italic toggle="yes">n</italic> is the sequence length. Notwithstanding these bounds, WFA’s <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory requirements become computationally impractical for genome-scale alignments, leading to a need for further improvement.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we present the bidirectional WFA algorithm, the first gap-affine algorithm capable of computing optimal alignments in <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory while retaining WFA’s time complexity of <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As a result, this work improves the lowest known memory bound <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to compute gap-affine alignments. In practice, our implementation never requires more than a few hundred MBs aligning noisy Oxford Nanopore Technologies reads up to 1 Mbp long while maintaining competitive execution times.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>All code is publicly available at <ext-link xlink:href="https://github.com/smarco/BiWFA-paper" ext-link-type="uri">https://github.com/smarco/BiWFA-paper</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p>Supplementary data are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000780</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Ministerio de Ciencia e Innovacion</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Pairwise sequence alignment provides a parsimonious transformation of one string into another. From this transformation, we can understand the relationship between pairs of sequences. Because similarities and differences between biosequences (DNA, RNA, protein) relate to variation in function and evolutionary history of living things, pairwise sequence alignment algorithms are a core part of many essential bioinformatics methods in read mapping (<xref rid="btad074-B13" ref-type="bibr">Li, 2013</xref>; <xref rid="btad074-B16" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2012</xref>), genome assembly (<xref rid="btad074-B12" ref-type="bibr">Koren <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btad074-B26" ref-type="bibr">Simpson <italic toggle="yes">et al.</italic>, 2009</xref>), variant calling (<xref rid="btad074-B8" ref-type="bibr">Garrison and Marth, 2012</xref>; <xref rid="btad074-B18" ref-type="bibr">McKenna <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btad074-B24" ref-type="bibr">Rodríguez-Martín <italic toggle="yes">et al.</italic>, 2017</xref>) and many others (<xref rid="btad074-B5" ref-type="bibr">Durbin <italic toggle="yes">et al.</italic>, 1998</xref>; <xref rid="btad074-B10" ref-type="bibr">Jones et al., 2004</xref>). Its importance has motivated the research and development of multiple solutions over the past 50 years.</p>
    <p>Classical approaches to derive alignments involve the application of <italic toggle="yes">dynamic programming</italic> (DP) techniques. These methods require computing a matrix whose dimensions correspond to the lengths of the query <italic toggle="yes">q</italic> and target <italic toggle="yes">t</italic> sequences. Using DP recurrence relations, these methods compute the optimal alignment score for progressively longer prefixes of <italic toggle="yes">q</italic> and <italic toggle="yes">t</italic>, which correspond to the cells of the DP matrix. Thus, an optimal alignment can then be read out by tracing the recurrence back through the matrix.</p>
    <p>Selecting a suitable alignment score function is essential to obtain biologically meaningful alignments, as it determines the characteristics of optimal alignments. In effect, the alignment score function encodes prior expectations about the probability of certain kinds of sequence differences. It has been observed that, in many contexts, insertions and deletions are non-uniformly distributed; they are infrequent but tend to be adjacent so that they form extended <italic toggle="yes">gaps</italic> with a long-tailed length distribution. This motivated the development of <italic toggle="yes">gap-affine</italic> models in which the penalty of starting a new gap is larger than that of extending a gap (<xref rid="btad074-B9" ref-type="bibr">Gotoh, 1982</xref>). Crucially, gap-affine penalties can be implemented efficiently using additional DP matrices.</p>
    <p>Problematically, the efficiency of classical gap-affine DP-based methods is constrained by their quadratic requirements in time and memory with respect to the lengths of the sequence pair. Consequently, multiple optimizations have been proposed over the years. Notable examples include bit-parallel techniques (<xref rid="btad074-B15" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>), data-layout transformations to exploit SIMD instructions (<xref rid="btad074-B7" ref-type="bibr">Farrar, 2007</xref>; <xref rid="btad074-B25" ref-type="bibr">Rognes and Seeberg, 2000</xref>; <xref rid="btad074-B31" ref-type="bibr">Wozniak, 1997</xref>), difference encoding of the DP matrix (<xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>), among other methods (<xref rid="btad074-B1" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic>, 1990</xref>; <xref rid="btad074-B11" ref-type="bibr">Kiełbasa <italic toggle="yes">et al.</italic>, 2011</xref>; <xref rid="btad074-B32" ref-type="bibr">Xia <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btad074-B34" ref-type="bibr">Zhao <italic toggle="yes">et al.</italic>, 2013</xref>). Nonetheless, all these exact methods retain the quadratic requirements of the original DP algorithm and therefore struggle to scale when aligning long sequences.</p>
    <p>In many cases, when two sequences are homologous, the majority of possible alignments are largely sub-optimal, having a substantially worse score than the optimal one. For this reason, heuristic methods are usually employed to find candidate alignment regions when the cost of exact algorithms becomes impractical. Most notable approaches use adaptive <italic toggle="yes">band</italic> methods (<xref rid="btad074-B29" ref-type="bibr">Suzuki and Kasahara, 2017</xref>) or pruning strategies [e.g. X-drop (<xref rid="btad074-B33" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2000</xref>) and Z-drop (<xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>)] to avoid the computation of alignments extremely unlikely to be optimal. These heuristic methods have been implemented within many widely used tools (<xref rid="btad074-B1" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic>, 1990</xref>; <xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>).</p>
    <p>Recently, we proposed the wavefront alignment algorithm (WFA) (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>) to compute the exact alignment between two sequences using gap-affine penalties. WFA reformulates the alignment problem to compute the longest-possible alignments of increasing score until the optimal alignment is found. Notably, WFA takes advantage of homologous regions between sequences to accelerate alignment’s computation. As a result, WFA computes optimal gap-affine alignments in <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory, where <italic toggle="yes">n</italic> is the sequence length and <italic toggle="yes">s</italic> the optimal alignment score. Being an exact algorithm, WFA provides the same guarantee for optimality as classical algorithms (<xref rid="btad074-B9" ref-type="bibr">Gotoh, 1982</xref>; <xref rid="btad074-B22" ref-type="bibr">Needleman and Wunsch, 1970</xref>; <xref rid="btad074-B27" ref-type="bibr">Smith and Waterman, 1981</xref>), but does away with the quadratic requirements in time.</p>
    <p>WFA unlocked the path for optimal alignment methods capable of scaling to long sequences. Nevertheless, the <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory requirements quickly become the limiting factor when aligning sufficiently long or noisy sequences (<xref rid="btad074-B6" ref-type="bibr">Eizenga and Paten, 2022</xref>). As it happens, WFA’s memory requirements can be impractical when aligning through large structural variations or highly divergent genome regions. Given that we use alignment to understand variation, these are some contexts in which optimal alignment could be most useful, but its memory requirements make it prohibitive.</p>
    <p>To address this problem, this article presents the first gap-affine alignment algorithm to compute the optimal alignment in <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory (excluding the storage of the input sequences). Our method, the bidirectional WFA algorithm (BiWFA), computes the WFA alignment of two sequences in the forward and reverse direction until they meet. Using two wavefronts of <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory, we demonstrate how to find the optimal breakpoint of the alignment at score <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and proceed recursively to solve the complete alignment in <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. To our knowledge, this work improves the lowest known memory bound to compute gap-affine alignments <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btad074-B21" ref-type="bibr">Myers and Miller, 1988</xref>) to <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, while retaining the time complexity of the original WFA <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, our experimental results demonstrate that the BiWFA delivers comparable, or even better, performance than the original WFA, outperforming other state-of-the-art tools while using a minimal amount of memory.</p>
    <p>The rest of the article is structured as follows. Section 2 presents the definitions, algorithms and formal proofs supporting BiWFA. Section 3 shows the experimental evaluation of our method, comparing it against other state-of-the-art tools and libraries. Lastly, Section 4 presents a discussion on the BiWFA method and summarizes the contributions and impact of this work.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Wavefront alignment algorithm</title>
      <p>Let the query <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the text <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be strings of length <italic toggle="yes">n</italic> and <italic toggle="yes">m</italic>, respectively. Likewise, let <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote a substring of any string <italic toggle="yes">v</italic> from the <italic toggle="yes">i</italic>th to the <italic toggle="yes">j</italic>th character. We will use <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the gap-affine penalties. A mismatch costs <italic toggle="yes">x</italic>, and a gap of length <italic toggle="yes">l</italic> costs <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mo>⋅</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula>. We assume that <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, and further that all of the score parameters are constants.</p>
      <p>Basically, WFA computes partial optimal alignments of increasing score until an alignment with score <italic toggle="yes">s</italic> reaches coordinate <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the DP matrix. In this way, the algorithm determines that <italic toggle="yes">s</italic> is the minimal alignment score. Moreover, it can derive the optimal alignment by tracing back the partial alignments that led to score <italic toggle="yes">s</italic> at <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Let <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denote the offset within diagonal <italic toggle="yes">k</italic> in the DP-matrix to the farthest-reaching (f.r.) cell that has score <italic toggle="yes">s</italic> and ends with a match, mismatch, insertion or deletion, respectively. In general, we denote by <italic toggle="yes">wavefront</italic> the tuple of offsets for a given score <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We refer to the four elements in this tuple as its <italic toggle="yes">components</italic>, and we associate a corresponding sentinel value to specify each component: <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref>, we proved that the f.r. points of <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> can be computed using previous wavefronts <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, using <xref rid="E1" ref-type="disp-formula">Equation 1</xref> where <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the length of longest common prefix between substrings <italic toggle="yes">v</italic> and <italic toggle="yes">w</italic>. The base case for this recursion is given by <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p><xref rid="E1" ref-type="disp-formula">Equation 1</xref> shows that the computation of a given wavefront depends only on the previous <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> wavefronts. We refer to <italic toggle="yes">p</italic> as the wavefront <italic toggle="yes">scope</italic> or, in other words, the maximum score increase between partial alignments. Moreover, note that <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> does not need to be explicitly stored as its values can be inferred using <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>In the worst case, WFA requires computing <italic toggle="yes">s</italic> wavefronts of increasing length, totalling <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>s</mml:mi></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> cells. Moreover, the <italic toggle="yes">LCP</italic> must be computed once for each cell. However, within a diagonal, the total number of offset increments cannot exceed the length of the sequences. Hence, WFA requires <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory in the worst case (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>). Since <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, the <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor of the execution time, due to the <italic toggle="yes">LCP</italic>, dominates over the <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor in the worst case. However, in practice, the time is often closer to <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This is because spurious matches between high-entropy sequences are short in expectation. Accordingly, the <italic toggle="yes">LCP</italic> computations often finish after performing only a few character comparisons, except along the optimal alignment in which <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> comparisons are required.</p>
    </sec>
    <sec>
      <title>2.2 Bidirectional wavefront alignment algorithm</title>
      <p>The core idea of the BiWFA algorithm is to perform WFA simultaneously in both directions on the strings: from start to end (i.e. forward) and from end to start (i.e. reverse). Each direction will only retain <italic toggle="yes">p</italic> wavefronts in memory. This is insufficient to perform a full traceback. However, when they ‘meet’ in the middle, we can infer a breakpoint in the alignment that divides the optimal score roughly in half. Then, we can apply the same procedure on the two sides of the breakpoint recursively. We will show that this results in only a constant-factor slowdown. This technique was previously employed to a similar end with the Myers <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>D</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> difference algorithm (<xref rid="btad074-B20" ref-type="bibr">Myers, 1986</xref>).</p>
      <p><xref rid="btad074-F1" ref-type="fig">Figure 1</xref> presents a graphical example of BiWFA computing a breakpoint in the optimal alignment between two sequences. The figure shows the DP cells computed by the forward and reverse wavefronts. Alignments in both directions progress until they overlap on cell <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with score <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula> corresponding to the optimal alignment (<inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <fig position="float" id="btad074-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Example of BiWFA aligning <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mi mathvariant="italic">TCTAGCG</mml:mi><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> against <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mi mathvariant="italic">TGGAAAG</mml:mi><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> under the penalties <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btad074f1" position="float"/>
      </fig>
      <p>First, let us define the WFA equations for the forward and reverse alignment directions. The recursions for the forward direction are equivalent to those of the standard WFA presented above (<xref rid="E1" ref-type="disp-formula">Equation 1</xref>). However, to highlight the distinction, we will denote them <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The recursions for the reverse direction are very similar (<xref rid="E2" ref-type="disp-formula">Equation 2</xref>), using <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> as the base case and <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the length of the longest common suffix of <italic toggle="yes">v</italic> and <italic toggle="yes">w</italic>. Note that the same argument used in <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref> applies to the reverse recursions to prove that they are f.r. in the reverse direction.
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi mathvariant="italic">LCS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>Algorithm 1 presents the BiWFA algorithm to compute a breakpoint in the optimal alignment at <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. Using forward and reverse wavefronts, the algorithm proceeds by alternatingly computing forward and reverse alignments (i.e. <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula>). To this end, BiWFA relies on the operators <italic toggle="yes">WF_NEXT()</italic> and <italic toggle="yes">WF_EXTEND()</italic> from the standard WFA [see <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref>] to compute successive wavefronts using <xref rid="E1" ref-type="disp-formula">Equaions 1</xref> and <xref rid="E2" ref-type="disp-formula">2</xref>. The process is halted after their offsets overlap to compute the position of a breakpoint in the optimal alignment. This algorithm iterates until it is guaranteed that the optimal breakpoint has been found. However, there are some technical details involving the detection of overlaps and the computation of the optimal breakpoint, which we cover in Sections 2.3 and 2.4.</p>
    </sec>
    <sec>
      <title>2.3 Finding a score-balanced breakpoint in the optimal alignment</title>
      <p>The first technical detail involved in finding an alignment breakpoint between the two directions is that it is often not possible to split an alignment into an equally scoring prefix and suffix. In general, two prefixes of the optimal alignment that differ by one character can have scores that differ by as much as <italic toggle="yes">p</italic>. Accordingly, we will demand a weaker notion of balance. If <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are the forward and reverse scores, respectively, we will aim to have <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>The second technical detail is that the optimal score is not always the sum of the two scores. This occurs because the forward iteration incurs the gap open penalty <italic toggle="yes">o</italic> at the beginning of gaps, but the reverse incurs it at the end of gaps (or rather, at the beginning in the reverse direction). Thus, if the two directions meet in a gap, then we have <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula> rather than <inline-formula id="IE67a"><mml:math id="IM67a" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the optimal alignment score.</p>
      <p>The final technical detail is that offsets of the two directions may not precisely meet. WFA proceeds by greedily taking matches in both directions. This makes it possible for the two directions to shoot past each other without actually meeting. It turns out that it is sufficient to detect that such an overshoot has occurred, as will be shown in Section 2.4.</p>
      <p>In Algorithm 2, we reconcile these three difficulties. Without loss of generality, we assume that a forward wavefront <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has been computed (Algorithm 1), and we want to detect overlaps against the previously computed reverse wavefronts <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. First, if <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> belongs to a score-balanced breakpoint (with <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>), it is sufficient to check for overlaps against <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the previous <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> reverse wavefronts. Second, for every diagonal <italic toggle="yes">k</italic> in wavefront <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, Algorithm 2 checks of overlaps in all wavefront components. This way, the algorithm keeps track of the overlap with the minimum score detected so far. Last, note that overlaps on <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:math></inline-formula> and <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:math></inline-formula> components account twice for the gap-open score <italic toggle="yes">o</italic>. Hence, the score from overlaps at indel components has to be decreased by <italic toggle="yes">o</italic>.</p>
      <p>
        <inline-graphic xlink:href="btad074ilf1.jpg"/>
      </p>
      <p>In practice, Algorithm 1 can avoid most calls to <italic toggle="yes">WF_OVERLAP()</italic>. An efficient implementation can keep track of the farthest reached antidiagonal by each wavefront. If the most advanced antidiagonal reached by the forward and reverse wavefronts do not overlap (<italic toggle="yes">ANTIDIAG()</italic> on Algorithm 1), it follows that no offsets from any diagonal can overlap, rendering the call to <italic toggle="yes">WF_OVERLAP()</italic> unnecessary.</p>
    </sec>
    <sec>
      <title>2.4 Correctness of the breakpoint detection</title>
      <p>The correctness of the Algorithm 1 stems from the following lemma.<statement id="mthst1"><label>Lemma 2.1.</label><p><italic toggle="yes">The optimal alignment score</italic> <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">if and only if there exist</italic> <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">and k such that</italic> <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and at least one of the following is true:</italic><list list-type="order"><list-item><p><inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item></list><italic toggle="yes">and further</italic>, <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">(resp.</italic> <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">) is included in the traceback of an alignment with score at most s if the first (resp. second, third) condition is true</italic><bold>.</bold></p><p><bold><italic toggle="yes">Proof.</italic></bold></p><p>See <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p><p><inline-graphic xlink:href="btad074ilf2.jpg"/></p><p>This lemma implies that the minimum value s for which the ‘only if’ condition holds is the optimal score. Moreover, if the first of the three conditions is found to hold for some values <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula>. Therefore, Algorithm 1 is guaranteed to find part of a minimum-scoring alignment based on the following features:
<list list-type="bullet"><list-item><p>Algorithm 2 checks a window of <italic toggle="yes">p</italic> score values on each iteration.</p></list-item><list-item><p>Algorithm 1 iterates through alternatingly increasing values of <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, detecting breakpoints with scores of at least <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> in each iteration.</p></list-item><list-item><p>After finding some <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that satisfy the overlap condition, Algorithm 1 continues for additional iterations until it is no longer possible to find a lower score.</p></list-item></list></p></statement></p>
    </sec>
    <sec>
      <title>2.5 Combining breakpoints into an alignment</title>
      <p>Algorithm 3 shows how to use BiWFA to recursively split alignments into smaller subproblems until the remaining alignment can be trivially solved.</p>
      <p>Note that a breakpoint computed by BiWFA can be found on the I or D components. Thus, those alignments that connect with this breakpoint have to start or end at the given component. This way, Algorithm 3 considers the starting and ending component of each alignment, and forces the underlying WFAs to use different initial conditions depending on the alignment starting at the <italic toggle="yes">M</italic> (<inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>), I (<inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) or <italic toggle="yes">D</italic> component (<inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>). A similar argument applies to the ending conditions of each alignment ending at the <italic toggle="yes">M</italic> (<inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>), <italic toggle="yes">I</italic> (<inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>) or <italic toggle="yes">D</italic> component (<inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>).</p>
    </sec>
    <sec>
      <title>2.6 BiWFA uses <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space and <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time</title>
      <p>The memory complexity of Algorithm 1 is relatively simple to characterize. The range of diagonal values <italic toggle="yes">k</italic> increases by at most two every time <italic toggle="yes">s</italic> is incremented, and each forward and reverse search only needs to store the last <italic toggle="yes">p</italic> wavefronts. Thus, the memory use is proportional to the optimal alignment score, <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, excluding the storage of the input sequences. Also, note that the output alignment only requires storing the position <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for the mismatches, insertions and deletions (matches can be inferred from the gaps). Concerning Algorithm 3, data structures are discarded before entering a recursive call. Therefore, the maximum memory use occurs in the outermost call, in which s is the optimal score of the full alignment.</p>
      <p>
        <inline-graphic xlink:href="btad074ilf3.jpg"/>
      </p>
      <p>The time complexity is more complicated to analyze. Our proof follows similar arguments as those from <xref rid="btad074-B20" ref-type="bibr">Myers (1986)</xref>.<statement id="mthst2"><label>Theorem 2.2.</label><p><italic toggle="yes">BiWFA’s time complexity is</italic> <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, being n and m the sequences’ length and s the optimal alignment score.</italic></p><p><italic toggle="yes">Proof.</italic></p><p>Let <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, and let <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be BiWFA’s execution time with score <italic toggle="yes">s</italic>. A call to BiWFA can result in two recursive calls. Let <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the combined length of the sequences in the two calls, and similarly let <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the two alignment scores. Following Lemma 2.1, we know that these variables obey the following inequalities:
<list list-type="bullet"><list-item><p><inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item></list></p><p>Because each direction of WFA executes in <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>), we can choose a constant <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> large enough that the following inequality holds for all <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>We can also choose a constant <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> large enough that for all <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula><disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></disp-formula></p><p>This follows because the recursion depth depends only on <italic toggle="yes">s</italic>, which we have given an upper bound. Therefore, this term includes a bounded number of calls that all have linear dependence on <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>.</p></statement></p>
      <p>Next, we argue that <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> by induction on <italic toggle="yes">s</italic>. The base cases for <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> follow trivially from the latter of the previous inequalities. Assume then that <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> and the induction hypothesis holds for <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Note that we then have <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, else either <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. Thus,
<disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>This proves the claim.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We implement the BiWFA algorithm described in this work in C. The code and the scripts required to reproduce the experimental results presented in this section are publicly available and can be found at <ext-link xlink:href="https://github.com/smarco/BiWFA-paper" ext-link-type="uri">https://github.com/smarco/BiWFA-paper</ext-link>. Moreover, the code has been integrated into the WFA2-lib alignment library (as ultralow memory mode) at <ext-link xlink:href="https://github.com/smarco/WFA2-lib" ext-link-type="uri">https://github.com/smarco/WFA2-lib</ext-link>.</p>
    <sec>
      <title>3.1 Experimental setup</title>
      <p>We evaluate the performance of our BiWFA implementation compared to the state-of-the-art and other high-performance sequence alignment libraries. We select the original WFA (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>) (wfa-high) and its new low-memory modes (wfa-med and wfa-low) implemented in WFA2-lib (<ext-link xlink:href="https://github.com/smarco/WFA2-lib" ext-link-type="uri">https://github.com/smarco/WFA2-lib</ext-link>). Also, we select the efficient wfalm (<xref rid="btad074-B6" ref-type="bibr">Eizenga and Paten, 2022</xref>) (wfalm) and its low-memory modes (wfalm-low and wfalm-rec). Moreover, we include the highly optimized KSW2-Z2 (ksw2_extz2_sse), from the KSW2 library (<xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>; <xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>), as the best representative of DP-based methods due to its exceptional performance and widely usage within bioinformatics tools. In addition, we include the Edlib (<xref rid="btad074-B28" ref-type="bibr">Šošić and Šikić, 2017</xref>) and BitPal (<xref rid="btad074-B15" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>) libraries, which implement bit-parallel alignment strategies for edit and non-unitary penalties (i.e. gap-linear), respectively. Although they solve a considerably easier problem (i.e. Edlib is restricted to edit-alignments and BitPal only computes the alignment score), and thus are not directly comparable, we included them in the evaluation to provide a performance upper bound.</p>
      <p>We considered including other popular methods like those implemented in the Parasail (<xref rid="btad074-B4" ref-type="bibr">Daily <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btad074-B3" ref-type="bibr">Daily, 2016</xref>; <xref rid="btad074-B7" ref-type="bibr">Farrar, 2007</xref>; <xref rid="btad074-B31" ref-type="bibr">Wozniak, 1997</xref>), SeqAn (<xref rid="btad074-B23" ref-type="bibr">Rahn <italic toggle="yes">et al.</italic>, 2018</xref>) and Gaba (<xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>) libraries. However, these libraries were not designed to align long and noisy sequences, and failed to complete the executions. Therefore these methods were discarded from the evaluation.</p>
      <p>All the presented methods have been configured to generate global alignments. These algorithms are grouped in two categories: ‘Gap-affine Exact’ for exact algorithms that use gap-affine penalties (i.e. BiWFA, WFA and its low-memory modes, wfalm and its low-memory modes and KSW2-Z2), and ‘Others’ for methods that use simpler penalty models or can only compute the alignment score (i.e. Edlib and BitPal).</p>
      <p>For the evaluation, we use simulated and real datasets. For the simulated datasets, we simulate several datasets of various sequence lengths (i.e. 100K, 500K, 1M and 2M bases) and different error rate (i.e. <italic toggle="yes">e </italic>=<italic toggle="yes"> </italic>10% and 20%) randomly generated. Regarding the evaluation with real datasets, we use a first set of sequences generated by the Human Pangenome Reference Consortium (<xref rid="btad074-B19" ref-type="bibr">Miga and Wang, 2021</xref>), consisting of long reads sequenced using Oxford Nanopore Technologies (ONT), PromethION platform, with an average error rate of 5–10%. The sequences are derived from the human cell line HG002, subset to chromosome 12 and restricted to those at least 10 kbp long, for a total number of 1312 sequence pairs of average length equal to 172<italic toggle="yes"> </italic>kbp (maximum ∼306<italic toggle="yes"> </italic>kbp). In addition, we use a second dataset comprising ONT MinION reads from <xref rid="btad074-B2" ref-type="bibr">Bowden <italic toggle="yes">et al.</italic> (2019)</xref>, with an average error rate of 5% and restricted to those at least 500<italic toggle="yes"> </italic>kbp long, for a total number of 48 sequence pairs of average length equal to 630<italic toggle="yes"> </italic>kbp (maximum ∼1<italic toggle="yes"> </italic>Mbp).</p>
      <p>All the executions are performed single-thread on a node running CentOS Linux (release 8.1.1911) equipped with an AMD EPYC 7742 CPU and 1 TB of DRAM (distributed in 16<italic toggle="yes"> </italic>dimms<italic toggle="yes"> </italic>×<italic toggle="yes"> </italic>64<italic toggle="yes"> </italic>GiB @3200<italic toggle="yes"> </italic>MHz).</p>
    </sec>
    <sec>
      <title>3.2 Evaluation on simulated data</title>
      <p><xref rid="btad074-T1" ref-type="table">Table 1</xref> shows the performance results (i.e. execution time and memory) for the different methods using simulated datasets. Overall, the results show that BiWFA is faster and uses less memory than all other methods in the ‘Gap-affine Exact’ category. In particular, BiWFA requires <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mn>32</mml:mn><mml:mo>−</mml:mo><mml:mn>1000</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory than KSW2-Z2, while being <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.4</mml:mn><mml:mo>−</mml:mo><mml:mn>4.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. Compared to original WFA-based methods (i.e. WFA-high and wfalm), BiWFA uses <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mn>9</mml:mn><mml:mo>−</mml:mo><mml:mn>9620</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory, being up to <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mn>4.4</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. Similarly, BiWFA outperforms the other memory-efficient WFA-based methods (i.e. WFA-med, WFA-low, wfalm-low and wfalm-rec), reducing memory requirements down to <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mn>438</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> while being <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.7</mml:mn><mml:mo>−</mml:mo><mml:mn>26.5</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. More importantly, most of the pairwise alignment methods evaluated fail to scale megabases-long sequences, requiring more memory than available in the node (i.e. 1TB). As opposed, BiWFA only requires a few hundred MBs of memory. Note that, computing the full alignment (BiWFA) requires a similar amount of memory as computing only the alignment score (BiWFA.score). Nonetheless, computing the alignment score is <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than computing the full alignment.</p>
      <table-wrap position="float" id="btad074-T1">
        <label>Table 1.</label>
        <caption>
          <p>Time and memory performance of pairwise alignment implementations on simulated data</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="8" rowspan="1">Time (s)<hr/></th>
              <th colspan="8" align="left" rowspan="1">Memory (MBs)<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">10<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" rowspan="1">100<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" rowspan="1">1<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" rowspan="1">2<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">10<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">100<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">1<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">2<italic toggle="yes"> </italic>Mbp<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">edlib</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.6</td>
              <td rowspan="1" colspan="1">2.5</td>
              <td rowspan="1" colspan="1">4.5</td>
              <td rowspan="1" colspan="1">17.9</td>
              <td rowspan="1" colspan="1">35.3</td>
              <td rowspan="1" colspan="1">35.4</td>
              <td rowspan="1" colspan="1">69.1</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">22</td>
              <td rowspan="1" colspan="1">23</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">bitpal</td>
              <td rowspan="1" colspan="1">1.3</td>
              <td rowspan="1" colspan="1">1.2</td>
              <td rowspan="1" colspan="1">12.3</td>
              <td rowspan="1" colspan="1">12.3</td>
              <td rowspan="1" colspan="1">123.8</td>
              <td rowspan="1" colspan="1">123.7</td>
              <td rowspan="1" colspan="1">248.0</td>
              <td rowspan="1" colspan="1">247.1</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">13</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ksw2-extz2</td>
              <td rowspan="1" colspan="1">9.8</td>
              <td rowspan="1" colspan="1">9.9</td>
              <td rowspan="1" colspan="1">96.7</td>
              <td rowspan="1" colspan="1">97.5</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">193</td>
              <td rowspan="1" colspan="1">196</td>
              <td rowspan="1" colspan="1">19 081</td>
              <td rowspan="1" colspan="1">19 083</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-high</td>
              <td rowspan="1" colspan="1">
                <bold>2.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5.7</bold>
              </td>
              <td rowspan="1" colspan="1">28.5</td>
              <td rowspan="1" colspan="1">84.1</td>
              <td rowspan="1" colspan="1">312.9</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">128</td>
              <td rowspan="1" colspan="1">313</td>
              <td rowspan="1" colspan="1">8981</td>
              <td rowspan="1" colspan="1">26 667</td>
              <td rowspan="1" colspan="1">932 199</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-med</td>
              <td rowspan="1" colspan="1">6.6</td>
              <td rowspan="1" colspan="1">20.2</td>
              <td rowspan="1" colspan="1">89.5</td>
              <td rowspan="1" colspan="1">272.8</td>
              <td rowspan="1" colspan="1">1922.1</td>
              <td rowspan="1" colspan="1">3690.1</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">35</td>
              <td rowspan="1" colspan="1">81</td>
              <td rowspan="1" colspan="1">830</td>
              <td rowspan="1" colspan="1">1620</td>
              <td rowspan="1" colspan="1">42 464</td>
              <td rowspan="1" colspan="1">24 874</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-low</td>
              <td rowspan="1" colspan="1">8.0</td>
              <td rowspan="1" colspan="1">24.1</td>
              <td rowspan="1" colspan="1">101.4</td>
              <td rowspan="1" colspan="1">301.1</td>
              <td rowspan="1" colspan="1">4394.9</td>
              <td rowspan="1" colspan="1">4857.0</td>
              <td rowspan="1" colspan="1">7710.2</td>
              <td rowspan="1" colspan="1">9813.1</td>
              <td rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">60</td>
              <td rowspan="1" colspan="1">554</td>
              <td rowspan="1" colspan="1">884</td>
              <td rowspan="1" colspan="1">25 321</td>
              <td rowspan="1" colspan="1">12 539</td>
              <td rowspan="1" colspan="1">52 551</td>
              <td rowspan="1" colspan="1">26 067</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm</td>
              <td rowspan="1" colspan="1">6.4</td>
              <td rowspan="1" colspan="1">19.2</td>
              <td rowspan="1" colspan="1">90.2</td>
              <td rowspan="1" colspan="1">268.7</td>
              <td rowspan="1" colspan="1">841.0</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">54</td>
              <td rowspan="1" colspan="1">148</td>
              <td rowspan="1" colspan="1">8968</td>
              <td rowspan="1" colspan="1">26 575</td>
              <td rowspan="1" colspan="1">898 770</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm-low</td>
              <td rowspan="1" colspan="1">10.1</td>
              <td rowspan="1" colspan="1">30.4</td>
              <td rowspan="1" colspan="1">164.1</td>
              <td rowspan="1" colspan="1">494.8</td>
              <td rowspan="1" colspan="1">1525.1</td>
              <td rowspan="1" colspan="1">4418.7</td>
              <td rowspan="1" colspan="1">2990.1</td>
              <td rowspan="1" colspan="1">8779.4</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">443</td>
              <td rowspan="1" colspan="1">823</td>
              <td rowspan="1" colspan="1">10 435</td>
              <td rowspan="1" colspan="1">30 817</td>
              <td rowspan="1" colspan="1">36 299</td>
              <td rowspan="1" colspan="1">69 312</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm-rec</td>
              <td rowspan="1" colspan="1">22.3</td>
              <td rowspan="1" colspan="1">70.7</td>
              <td rowspan="1" colspan="1">447.5</td>
              <td rowspan="1" colspan="1">1402.6</td>
              <td rowspan="1" colspan="1">5792.7</td>
              <td rowspan="1" colspan="1">17 752.9</td>
              <td rowspan="1" colspan="1">11 979.6</td>
              <td rowspan="1" colspan="1">37 747.7</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">43</td>
              <td rowspan="1" colspan="1">73</td>
              <td rowspan="1" colspan="1">497</td>
              <td rowspan="1" colspan="1">904</td>
              <td rowspan="1" colspan="1">1064</td>
              <td rowspan="1" colspan="1">1787</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BiWFA</td>
              <td rowspan="1" colspan="1">2.4</td>
              <td rowspan="1" colspan="1">6.9</td>
              <td rowspan="1" colspan="1">
                <bold>20.8</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>61.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>218.3</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>680.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>466.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1429.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>6</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>19</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>27</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>97</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>180</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>202</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>267</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BiWFA.score</td>
              <td rowspan="1" colspan="1">1.1</td>
              <td rowspan="1" colspan="1">3.1</td>
              <td rowspan="1" colspan="1">10.2</td>
              <td rowspan="1" colspan="1">30.2</td>
              <td rowspan="1" colspan="1">112.2</td>
              <td rowspan="1" colspan="1">355.8</td>
              <td rowspan="1" colspan="1">245.4</td>
              <td rowspan="1" colspan="1">750.2</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">186</td>
              <td rowspan="1" colspan="1">204</td>
              <td rowspan="1" colspan="1">256</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Execution time (in seconds) and memory (in MBs) required per 1M bases aligned, using different pairwise alignment implementations on simulated datasets. Executions that failed appear as ‘n/a’. Best performing implementation in the ‘Gap-affine Exact’ category is marked in bold. Although Edlib and BitPal are not directly comparable to the other implementations, we included them in the comparison as a reference. Similarly, we include executions of BiWFA limited to compute the alignment score as ‘BiWFA.score’.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>For completeness, we present a comprehensive experimental evaluation on a wider range of sequence lengths (i.e. 100 bp, 1 Kbp, 10 Kbp, 100 Kbp, 1 Mbp and 2 Mbp) and error rates (0.1%, 1%, 5%, 10%, 20% and 40%) on <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1 and S2</xref>). For short sequences (i.e. ≤1 Kbp), the results show that BiWFA delivers similar performance as the original WFA (<inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.25</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> slower) while reducing the memory requirements up to <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mn>60</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>. Our experiments indicate that BiWFA starts outperforming the original WFA when aligning sequences longer than ∼30 Kbp. Nevertheless, the exact performance breakpoint can vary depending on the error rate, implementation and processor specifics. Similarly, for smaller error rates (i.e. <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mo>≤</mml:mo></mml:math></inline-formula>1%), WFA-based methods largely outperform other approaches, being <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> orders of magnitude faster than other methods like KSW2-Z2, bitpal and edlib. In addition, for low error rates, memory-efficient WFA-based methods require a minimal amount of memory.</p>
    </sec>
    <sec>
      <title>3.3 Evaluation on real data</title>
      <p><xref rid="btad074-F2" ref-type="fig">Figure 2</xref> shows the performance results obtained for all the evaluated algorithms in terms of execution time and consumed memory. BiWFA uses many times less memory than other methods. In particular, when aligning ultra-long ONT sequences (<xref rid="btad074-F2" ref-type="fig">Fig. 2B</xref>), BiWFA requires between <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mn>68</mml:mn><mml:mo>−</mml:mo><mml:mn>93</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory compared to wfalm and WFA low-memory modes. Furthermore, BiWFA uses 3.5<inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mo>×</mml:mo></mml:math></inline-formula> less memory compared to the efficient recursive mode from wfalm (most memory-efficient gap-affine algorithm to date).</p>
      <fig position="float" id="btad074-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Experimental results from the execution of BiWFA and other state-of-the-art implementations aligning long sequences. Figure shows (<bold>A</bold>) memory consumption and (<bold>B</bold>) execution time per sequence aligned. A vertical line on each panel separates algorithms that use simpler penalty models or can only compute the alignment score (i.e. edlib and bitpal) from those that compute the full gap-affine alignment</p>
        </caption>
        <graphic xlink:href="btad074f2" position="float"/>
      </fig>
      <p>At the same time, BiWFA proves to be one of the fastest implementations aligning long sequences. Using ultra-long sequences, our method is <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mn>25.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than wfalm’s recursive mode. Moreover, BiWFA’s execution times are similar to those of BitPal (sometimes even faster, <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.1</mml:mn><mml:mo>−</mml:mo><mml:mn>1.28</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster on average) computing exact alignments (not just the score) under the gap-affine model.</p>
      <p>For completeness, <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S1</xref> shows experimental results limited to aligning sequences up to 10<italic toggle="yes"> </italic>Kbps. In this scenario, BiWFA demonstrates to be one of the fastest implementations, requiring less than 10<italic toggle="yes"> </italic>MB to execute.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>As long sequencing technologies improve and high-quality sequence assembly decreases in cost, we anticipate that the importance of pairwise alignment algorithm will continue to increase. To keep up with upcoming improvements in sequencing and genomics, pairwise alignment algorithms need to face crucial challenges in reducing execution time and memory consumption. In this work, we have presented the BiWFA, a gap-affine pairwise alignment algorithm that requires <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space, being the first algorithm to improve the long standing space lower bound of <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The BiWFA answers the pressing need for sequence alignment methods capable to scaling to genome-scale alignments and full pangenomes.</p>
    <p>Most notably, BiWFA execution times are very similar, or even better, than those of the original WFA (despite BiWFA requiring <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mn>2954</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mn>607</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory when aligning ultra-long MinION and PromethION sequences, respectively). This result can be better understood considering the memory inefficiencies that the original WFA experiences when using a large memory footprint. As the sequence’s length and error increases, the original WFA uses a substantially larger memory footprint, putting a significant pressure on the memory hierarchy of the processor. Due to the pervasive memory inefficiencies of modern processors executing memory intensive applications, the original WFA’s performance is severely deteriorated when aligning long sequence datasets (like those from Nanopore presented in the evaluation). In contrast, BiWFA relieves this memory pressure using a minimal memory footprint. As a result, BiWFA is able to balance out the additional work induced by BiWFA’s recursion, delivering a performance on-par with the original WFA.</p>
    <p>We have presented the BiWFA using gap-affine penalties. Nevertheless, these very same ideas can be translated directly into other distances like edit, linear gap or piecewise gap-affine. Moreover, it can be easily extended to semi-global alignment (a.k.a. ends-free, glocal, extension or overlapped alignment) by modifying the initial conditions and termination criterion. At the same time, the BiWFA retains the strengths of the original WFA: no restrictions on the sequences’ alphabet, preprocessing steps, nor prior estimation of the alignment error.</p>
    <p>Due to the simplicity of the WFA’s computational pattern, BiWFA’s core functions can be easily vectorized to fully exploit the capabilities of modern SIMD multicore processors. Our implementation, relies on the automatic vectorization capabilities of modern compilers. As a result, the BiWFA implementation can exploit the SIMD capabilities of any processor supported by modern compilers, without rewriting any part of the source code.</p>
    <p>Genomics and bioinformatics methods will continue to rely on sequence alignment as a core and critical component. BiWFA paves the way for the development of faster and more accurate tools that can scale with longer and noisy sequences using a minimal amount of memory. In this way, we expect BiWFA to enable efficient sequence alignment at genome-scale in years to come.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad074_Supplementary_Data</label>
      <media xlink:href="btad074_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Ragnar Groot Koerkamp and the anonymous reviewers for making useful suggestions and contributing to improving the manuscript.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This research was supported by the European Union Regional Development Fund within the framework of the ERDF Operational Program of Catalonia 2014-2020 with a grant of 50% of total cost eligible under the DRAC project [001-P-001723] and Lenovo-BSC Contract-Framework Contract (2022). It was also supported by the Ministerio de Ciencia e Innovacion MCIN AEI/10.13039/501100011033 and NextGenerationEU/PRTR under contracts PID2020-113614RB-C21, PID2019-107255GB-C21, and TED2021-132634A-I00, by the Generalitat de Catalunya GenCat-DIUiE (GRR) [contracts 2017-SGR-313, 2017-SGR-1328 and 2017-SGR-1414]. M.M. was partially supported by the Spanish Ministry of Economy, Industry and Competitiveness under Ramon y Cajal fellowship number RYC-2016-21104. S.M.-S. was supported by Juan de la Cierva fellowship grant IJC2020-045916-I funded by MCIN/AEI/10.13039/501100011033 and by ‘European Union NextGenerationEU/PRTR’. B.P. and J.M.E. were supported, in part, by the United States National Institutes of Health [award numbers: R01HG010485, U01HG010961, OT2OD026682, OT3HL142481 and U24HG011853]. E.G. was supported by NIH/NIDA U01DA047638 and NSF PPoSS Award #2118709. A.G. acknowledges Dr. Nicole Soranzo’s efforts to establish a pangenome research unit at the Human Technopole in Milan, Italy.</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad074-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>1990</year>) <article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biol</source>., <volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bowden</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Sequencing of human genomes with nanopore technology</article-title>. <source>Nat. Commun</source>., <volume>10</volume>, <fpage>1869</fpage>.<pub-id pub-id-type="pmid">31015479</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Parasail: SIMD C library for global, semi-global, and local pairwise sequence alignments</article-title>. <source>BMC Bioinf</source>., <volume>17</volume>, <fpage>1</fpage>–<lpage>11</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>A work stealing based approach for enabling scalable optimal sequence homology detection</article-title>. <source>J. Parallel Distributed Comput</source>., <volume>79</volume>, <fpage>132</fpage>–<lpage>142</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>1998</year>) <source>Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids</source>. <publisher-name>Cambridge University Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btad074-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Eizenga</surname><given-names>J.M.</given-names></string-name>, <string-name><surname>Paten</surname><given-names>B.</given-names></string-name></person-group> (<year>2022</year>) Improving the time and space complexity of the WFA algorithm and generalizing its scoring. <italic toggle="yes">bioRxiv</italic>.</mixed-citation>
    </ref>
    <ref id="btad074-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Farrar</surname><given-names>M.</given-names></string-name></person-group> (<year>2007</year>) <article-title>Striped Smith–Waterman speeds database searches six times over other SIMD implementations</article-title>. <source>Bioinformatics</source>, <volume>23</volume>, <fpage>156</fpage>–<lpage>161</lpage>.<pub-id pub-id-type="pmid">17110365</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Garrison</surname><given-names>E.</given-names></string-name>, <string-name><surname>Marth</surname><given-names>G.</given-names></string-name></person-group> (<year>2012</year>) Haplotype-based variant detection from short-read sequencing. <italic toggle="yes">arXiv preprint arXiv:1207.3907.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gotoh</surname><given-names>O.</given-names></string-name></person-group> (<year>1982</year>) <article-title>An improved algorithm for matching biological sequences</article-title>. <source>J. Mol. Biol</source>., <volume>162</volume>, <fpage>705</fpage>–<lpage>708</lpage>.<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Jones</surname><given-names>N.</given-names></string-name></person-group><etal>et al</etal> (<year>2004</year>) <source>An Introduction to Bioinformatics Algorithms</source>. <publisher-name>MIT Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btad074-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kiełbasa</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Adaptive seeds tame genomic sequence comparison</article-title>. <source>Genome Res</source>., <volume>21</volume>, <fpage>487</fpage>–<lpage>493</lpage>.<pub-id pub-id-type="pmid">21209072</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koren</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>CANU: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>722</fpage>–<lpage>736</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2013</year>) Aligning sequence reads, clone sequences and assembly contigs with bwa-mem. <italic toggle="yes">arXiv preprint arXiv:1303.3997.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3094</fpage>–<lpage>3100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loving</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3166</fpage>–<lpage>3173</lpage>.<pub-id pub-id-type="pmid">25075119</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>The gem mapper: fast, accurate and versatile alignment by filtration</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>1185</fpage>–<lpage>1188</lpage>.<pub-id pub-id-type="pmid">23103880</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Fast gap-affine pairwise alignment using the wavefront algorithm</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>456</fpage>–<lpage>463</lpage>.<pub-id pub-id-type="pmid">32915952</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McKenna</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2010</year>) <article-title>The genome analysis toolkit: a mapreduce framework for analyzing next-generation DNA sequencing data</article-title>. <source>Genome Res</source>., <volume>20</volume>, <fpage>1297</fpage>–<lpage>1303</lpage>.<pub-id pub-id-type="pmid">20644199</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Miga</surname><given-names>K. H.</given-names></string-name>, <string-name><surname>Wang</surname><given-names>T.</given-names></string-name></person-group> (<year>2021</year>) <article-title>The need for a human pangenome reference sequence</article-title>. <source>Annu. Rev. Genomics Hum. Genet</source>., <volume>22</volume>, <fpage>81</fpage>–<lpage>102</lpage>.<pub-id pub-id-type="pmid">33929893</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E. W.</given-names></string-name></person-group> (<year>1986</year>) <article-title>An <italic toggle="yes">O</italic>(<italic toggle="yes">ND</italic>) difference algorithm and its variations</article-title>. <source>Algorithmica</source>, <volume>1</volume>, <fpage>251</fpage>–<lpage>266</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E. W.</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W.</given-names></string-name></person-group> (<year>1988</year>) <article-title>Optimal alignments in linear space</article-title>. <source>Bioinformatics</source>, <volume>4</volume>, <fpage>11</fpage>–<lpage>17</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Needleman</surname><given-names>S. B.</given-names></string-name>, <string-name><surname>Wunsch</surname><given-names>C. D.</given-names></string-name></person-group> (<year>1970</year>) <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>. <source>J. Mol. Biol</source>., <volume>48</volume>, <fpage>443</fpage>–<lpage>453</lpage>.<pub-id pub-id-type="pmid">5420325</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rahn</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Generic accelerated sequence alignment in seqan using vectorization and multi-threading</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3437</fpage>–<lpage>3445</lpage>.<pub-id pub-id-type="pmid">29726911</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rodríguez-Martín</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>Chimpipe: accurate detection of fusion genes and transcription-induced chimeras from RNA-seq data</article-title>. <source>BMC Genomics</source>, <volume>18</volume>, <fpage>7</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">28049418</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T.</given-names></string-name>, <string-name><surname>Seeberg</surname><given-names>E.</given-names></string-name></person-group> (<year>2000</year>) <article-title>Six-fold speed-up of Smith–Waterman sequence database searches using parallel processing on common microprocessors</article-title>. <source>Bioinformatics</source>, <volume>16</volume>, <fpage>699</fpage>–<lpage>706</lpage>.<pub-id pub-id-type="pmid">11099256</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Simpson</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2009</year>) <article-title>ABYSS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Smith</surname><given-names>T. F.</given-names></string-name>, <string-name><surname>Waterman</surname><given-names>M. S.</given-names></string-name></person-group> (<year>1981</year>) <article-title>Comparison of biosequences</article-title>. <source>Adv. Appl. Math</source>., <volume>2</volume>, <fpage>482</fpage>–<lpage>489</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Šošić</surname><given-names>M.</given-names></string-name>, <string-name><surname>Šikić</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) <article-title>EDLIB: a C/C++ library for fast, exact sequence alignment using edit distance</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>1394</fpage>–<lpage>1395</lpage>.<pub-id pub-id-type="pmid">28453688</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) Acceleration of nucleotide semi-global alignment with adaptive banded dynamic programming. <italic toggle="yes">bioRxiv.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Introducing difference recurrence relations for faster semi-global alignment of long sequences</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>33</fpage>–<lpage>47</lpage>.<pub-id pub-id-type="pmid">29402212</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wozniak</surname><given-names>A.</given-names></string-name></person-group> (<year>1997</year>) <article-title>Using video-oriented instructions to speed up sequence comparison</article-title>. <source>Bioinformatics</source>, <volume>13</volume>, <fpage>145</fpage>–<lpage>150</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Xia</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>A review of parallel implementations for the Smith–Waterman algorithm</article-title>. In: <source>Interdisciplinary Sciences: Computational Life Sciences</source>, pp. <fpage>1</fpage>–<lpage>14</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2000</year>) <article-title>A greedy algorithm for aligning DNA sequences</article-title>. <source>J. Comput. Biol</source>., <volume>7</volume>, <fpage>203</fpage>–<lpage>214</lpage>.<pub-id pub-id-type="pmid">10890397</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhao</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2013</year>) <article-title>SSW library: an SIMD Smith–Waterman C/C++ library for use in genomic applications</article-title>. <source>PLoS ONE</source>, <volume>8</volume>, <fpage>e82138</fpage>.<pub-id pub-id-type="pmid">24324759</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9940620</article-id>
    <article-id pub-id-type="pmid">36749013</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad074</article-id>
    <article-id pub-id-type="publisher-id">btad074</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Optimal gap-affine alignment in <italic toggle="yes">O</italic>(<italic toggle="yes">s</italic>) space</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7951-3914</contrib-id>
        <name>
          <surname>Marco-Sola</surname>
          <given-names>Santiago</given-names>
        </name>
        <aff><institution>Computer Sciences Department, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors i Sistemes Operatius, Universitat Autònoma de Barcelona</institution>, Barcelona 08193, <country country="ES">Spain</country></aff>
        <xref rid="btad074-cor1" ref-type="corresp"/>
        <!--santiagomsola@gmail.com-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8345-8356</contrib-id>
        <name>
          <surname>Eizenga</surname>
          <given-names>Jordan M</given-names>
        </name>
        <aff><institution>Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-9744-131X</contrib-id>
        <name>
          <surname>Guarracino</surname>
          <given-names>Andrea</given-names>
        </name>
        <aff><institution>Genomics Research Centre, Human Technopole</institution>, Milan 20157, <country country="IT">Italy</country></aff>
        <aff><institution>Department of Genetics, Genomics and Informatics, University of Tennessee Health Science Center</institution>, Memphis, TN 38163, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8863-3539</contrib-id>
        <name>
          <surname>Paten</surname>
          <given-names>Benedict</given-names>
        </name>
        <aff><institution>Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-3821-631X</contrib-id>
        <name>
          <surname>Garrison</surname>
          <given-names>Erik</given-names>
        </name>
        <aff><institution>Department of Genetics, Genomics and Informatics, University of Tennessee Health Science Center</institution>, Memphis, TN 38163, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9848-8758</contrib-id>
        <name>
          <surname>Moreto</surname>
          <given-names>Miquel</given-names>
        </name>
        <aff><institution>Computer Sciences Department, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors, Universitat Politècnica de Catalunya</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Martelli</surname>
          <given-names>Pier Luigi</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad074-cor1">To whom correspondence should be addressed. <email>santiagomsola@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-02-07">
      <day>07</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>07</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>2</issue>
    <elocation-id>btad074</elocation-id>
    <history>
      <date date-type="received">
        <day>17</day>
        <month>8</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>02</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>30</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>20</day>
        <month>2</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad074.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Pairwise sequence alignment remains a fundamental problem in computational biology and bioinformatics. Recent advances in genomics and sequencing technologies demand faster and scalable algorithms that can cope with the ever-increasing sequence lengths. Classical pairwise alignment algorithms based on dynamic programming are strongly limited by quadratic requirements in time and memory. The recently proposed wavefront alignment algorithm (WFA) introduced an efficient algorithm to perform exact gap-affine alignment in <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <italic toggle="yes">s</italic> is the optimal score and <italic toggle="yes">n</italic> is the sequence length. Notwithstanding these bounds, WFA’s <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory requirements become computationally impractical for genome-scale alignments, leading to a need for further improvement.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we present the bidirectional WFA algorithm, the first gap-affine algorithm capable of computing optimal alignments in <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory while retaining WFA’s time complexity of <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As a result, this work improves the lowest known memory bound <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to compute gap-affine alignments. In practice, our implementation never requires more than a few hundred MBs aligning noisy Oxford Nanopore Technologies reads up to 1 Mbp long while maintaining competitive execution times.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>All code is publicly available at <ext-link xlink:href="https://github.com/smarco/BiWFA-paper" ext-link-type="uri">https://github.com/smarco/BiWFA-paper</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p>Supplementary data are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000780</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Ministerio de Ciencia e Innovacion</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Pairwise sequence alignment provides a parsimonious transformation of one string into another. From this transformation, we can understand the relationship between pairs of sequences. Because similarities and differences between biosequences (DNA, RNA, protein) relate to variation in function and evolutionary history of living things, pairwise sequence alignment algorithms are a core part of many essential bioinformatics methods in read mapping (<xref rid="btad074-B13" ref-type="bibr">Li, 2013</xref>; <xref rid="btad074-B16" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2012</xref>), genome assembly (<xref rid="btad074-B12" ref-type="bibr">Koren <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btad074-B26" ref-type="bibr">Simpson <italic toggle="yes">et al.</italic>, 2009</xref>), variant calling (<xref rid="btad074-B8" ref-type="bibr">Garrison and Marth, 2012</xref>; <xref rid="btad074-B18" ref-type="bibr">McKenna <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btad074-B24" ref-type="bibr">Rodríguez-Martín <italic toggle="yes">et al.</italic>, 2017</xref>) and many others (<xref rid="btad074-B5" ref-type="bibr">Durbin <italic toggle="yes">et al.</italic>, 1998</xref>; <xref rid="btad074-B10" ref-type="bibr">Jones et al., 2004</xref>). Its importance has motivated the research and development of multiple solutions over the past 50 years.</p>
    <p>Classical approaches to derive alignments involve the application of <italic toggle="yes">dynamic programming</italic> (DP) techniques. These methods require computing a matrix whose dimensions correspond to the lengths of the query <italic toggle="yes">q</italic> and target <italic toggle="yes">t</italic> sequences. Using DP recurrence relations, these methods compute the optimal alignment score for progressively longer prefixes of <italic toggle="yes">q</italic> and <italic toggle="yes">t</italic>, which correspond to the cells of the DP matrix. Thus, an optimal alignment can then be read out by tracing the recurrence back through the matrix.</p>
    <p>Selecting a suitable alignment score function is essential to obtain biologically meaningful alignments, as it determines the characteristics of optimal alignments. In effect, the alignment score function encodes prior expectations about the probability of certain kinds of sequence differences. It has been observed that, in many contexts, insertions and deletions are non-uniformly distributed; they are infrequent but tend to be adjacent so that they form extended <italic toggle="yes">gaps</italic> with a long-tailed length distribution. This motivated the development of <italic toggle="yes">gap-affine</italic> models in which the penalty of starting a new gap is larger than that of extending a gap (<xref rid="btad074-B9" ref-type="bibr">Gotoh, 1982</xref>). Crucially, gap-affine penalties can be implemented efficiently using additional DP matrices.</p>
    <p>Problematically, the efficiency of classical gap-affine DP-based methods is constrained by their quadratic requirements in time and memory with respect to the lengths of the sequence pair. Consequently, multiple optimizations have been proposed over the years. Notable examples include bit-parallel techniques (<xref rid="btad074-B15" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>), data-layout transformations to exploit SIMD instructions (<xref rid="btad074-B7" ref-type="bibr">Farrar, 2007</xref>; <xref rid="btad074-B25" ref-type="bibr">Rognes and Seeberg, 2000</xref>; <xref rid="btad074-B31" ref-type="bibr">Wozniak, 1997</xref>), difference encoding of the DP matrix (<xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>), among other methods (<xref rid="btad074-B1" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic>, 1990</xref>; <xref rid="btad074-B11" ref-type="bibr">Kiełbasa <italic toggle="yes">et al.</italic>, 2011</xref>; <xref rid="btad074-B32" ref-type="bibr">Xia <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btad074-B34" ref-type="bibr">Zhao <italic toggle="yes">et al.</italic>, 2013</xref>). Nonetheless, all these exact methods retain the quadratic requirements of the original DP algorithm and therefore struggle to scale when aligning long sequences.</p>
    <p>In many cases, when two sequences are homologous, the majority of possible alignments are largely sub-optimal, having a substantially worse score than the optimal one. For this reason, heuristic methods are usually employed to find candidate alignment regions when the cost of exact algorithms becomes impractical. Most notable approaches use adaptive <italic toggle="yes">band</italic> methods (<xref rid="btad074-B29" ref-type="bibr">Suzuki and Kasahara, 2017</xref>) or pruning strategies [e.g. X-drop (<xref rid="btad074-B33" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2000</xref>) and Z-drop (<xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>)] to avoid the computation of alignments extremely unlikely to be optimal. These heuristic methods have been implemented within many widely used tools (<xref rid="btad074-B1" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic>, 1990</xref>; <xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>).</p>
    <p>Recently, we proposed the wavefront alignment algorithm (WFA) (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>) to compute the exact alignment between two sequences using gap-affine penalties. WFA reformulates the alignment problem to compute the longest-possible alignments of increasing score until the optimal alignment is found. Notably, WFA takes advantage of homologous regions between sequences to accelerate alignment’s computation. As a result, WFA computes optimal gap-affine alignments in <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory, where <italic toggle="yes">n</italic> is the sequence length and <italic toggle="yes">s</italic> the optimal alignment score. Being an exact algorithm, WFA provides the same guarantee for optimality as classical algorithms (<xref rid="btad074-B9" ref-type="bibr">Gotoh, 1982</xref>; <xref rid="btad074-B22" ref-type="bibr">Needleman and Wunsch, 1970</xref>; <xref rid="btad074-B27" ref-type="bibr">Smith and Waterman, 1981</xref>), but does away with the quadratic requirements in time.</p>
    <p>WFA unlocked the path for optimal alignment methods capable of scaling to long sequences. Nevertheless, the <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory requirements quickly become the limiting factor when aligning sufficiently long or noisy sequences (<xref rid="btad074-B6" ref-type="bibr">Eizenga and Paten, 2022</xref>). As it happens, WFA’s memory requirements can be impractical when aligning through large structural variations or highly divergent genome regions. Given that we use alignment to understand variation, these are some contexts in which optimal alignment could be most useful, but its memory requirements make it prohibitive.</p>
    <p>To address this problem, this article presents the first gap-affine alignment algorithm to compute the optimal alignment in <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory (excluding the storage of the input sequences). Our method, the bidirectional WFA algorithm (BiWFA), computes the WFA alignment of two sequences in the forward and reverse direction until they meet. Using two wavefronts of <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory, we demonstrate how to find the optimal breakpoint of the alignment at score <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and proceed recursively to solve the complete alignment in <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. To our knowledge, this work improves the lowest known memory bound to compute gap-affine alignments <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btad074-B21" ref-type="bibr">Myers and Miller, 1988</xref>) to <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, while retaining the time complexity of the original WFA <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, our experimental results demonstrate that the BiWFA delivers comparable, or even better, performance than the original WFA, outperforming other state-of-the-art tools while using a minimal amount of memory.</p>
    <p>The rest of the article is structured as follows. Section 2 presents the definitions, algorithms and formal proofs supporting BiWFA. Section 3 shows the experimental evaluation of our method, comparing it against other state-of-the-art tools and libraries. Lastly, Section 4 presents a discussion on the BiWFA method and summarizes the contributions and impact of this work.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Wavefront alignment algorithm</title>
      <p>Let the query <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the text <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be strings of length <italic toggle="yes">n</italic> and <italic toggle="yes">m</italic>, respectively. Likewise, let <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote a substring of any string <italic toggle="yes">v</italic> from the <italic toggle="yes">i</italic>th to the <italic toggle="yes">j</italic>th character. We will use <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the gap-affine penalties. A mismatch costs <italic toggle="yes">x</italic>, and a gap of length <italic toggle="yes">l</italic> costs <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mo>⋅</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula>. We assume that <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, and further that all of the score parameters are constants.</p>
      <p>Basically, WFA computes partial optimal alignments of increasing score until an alignment with score <italic toggle="yes">s</italic> reaches coordinate <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the DP matrix. In this way, the algorithm determines that <italic toggle="yes">s</italic> is the minimal alignment score. Moreover, it can derive the optimal alignment by tracing back the partial alignments that led to score <italic toggle="yes">s</italic> at <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Let <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denote the offset within diagonal <italic toggle="yes">k</italic> in the DP-matrix to the farthest-reaching (f.r.) cell that has score <italic toggle="yes">s</italic> and ends with a match, mismatch, insertion or deletion, respectively. In general, we denote by <italic toggle="yes">wavefront</italic> the tuple of offsets for a given score <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We refer to the four elements in this tuple as its <italic toggle="yes">components</italic>, and we associate a corresponding sentinel value to specify each component: <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref>, we proved that the f.r. points of <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> can be computed using previous wavefronts <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, using <xref rid="E1" ref-type="disp-formula">Equation 1</xref> where <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the length of longest common prefix between substrings <italic toggle="yes">v</italic> and <italic toggle="yes">w</italic>. The base case for this recursion is given by <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p><xref rid="E1" ref-type="disp-formula">Equation 1</xref> shows that the computation of a given wavefront depends only on the previous <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> wavefronts. We refer to <italic toggle="yes">p</italic> as the wavefront <italic toggle="yes">scope</italic> or, in other words, the maximum score increase between partial alignments. Moreover, note that <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> does not need to be explicitly stored as its values can be inferred using <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>In the worst case, WFA requires computing <italic toggle="yes">s</italic> wavefronts of increasing length, totalling <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>s</mml:mi></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> cells. Moreover, the <italic toggle="yes">LCP</italic> must be computed once for each cell. However, within a diagonal, the total number of offset increments cannot exceed the length of the sequences. Hence, WFA requires <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory in the worst case (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>). Since <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, the <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor of the execution time, due to the <italic toggle="yes">LCP</italic>, dominates over the <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor in the worst case. However, in practice, the time is often closer to <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This is because spurious matches between high-entropy sequences are short in expectation. Accordingly, the <italic toggle="yes">LCP</italic> computations often finish after performing only a few character comparisons, except along the optimal alignment in which <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> comparisons are required.</p>
    </sec>
    <sec>
      <title>2.2 Bidirectional wavefront alignment algorithm</title>
      <p>The core idea of the BiWFA algorithm is to perform WFA simultaneously in both directions on the strings: from start to end (i.e. forward) and from end to start (i.e. reverse). Each direction will only retain <italic toggle="yes">p</italic> wavefronts in memory. This is insufficient to perform a full traceback. However, when they ‘meet’ in the middle, we can infer a breakpoint in the alignment that divides the optimal score roughly in half. Then, we can apply the same procedure on the two sides of the breakpoint recursively. We will show that this results in only a constant-factor slowdown. This technique was previously employed to a similar end with the Myers <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>D</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> difference algorithm (<xref rid="btad074-B20" ref-type="bibr">Myers, 1986</xref>).</p>
      <p><xref rid="btad074-F1" ref-type="fig">Figure 1</xref> presents a graphical example of BiWFA computing a breakpoint in the optimal alignment between two sequences. The figure shows the DP cells computed by the forward and reverse wavefronts. Alignments in both directions progress until they overlap on cell <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with score <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula> corresponding to the optimal alignment (<inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <fig position="float" id="btad074-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Example of BiWFA aligning <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mi mathvariant="italic">TCTAGCG</mml:mi><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> against <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mi mathvariant="italic">TGGAAAG</mml:mi><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> under the penalties <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btad074f1" position="float"/>
      </fig>
      <p>First, let us define the WFA equations for the forward and reverse alignment directions. The recursions for the forward direction are equivalent to those of the standard WFA presented above (<xref rid="E1" ref-type="disp-formula">Equation 1</xref>). However, to highlight the distinction, we will denote them <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The recursions for the reverse direction are very similar (<xref rid="E2" ref-type="disp-formula">Equation 2</xref>), using <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> as the base case and <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the length of the longest common suffix of <italic toggle="yes">v</italic> and <italic toggle="yes">w</italic>. Note that the same argument used in <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref> applies to the reverse recursions to prove that they are f.r. in the reverse direction.
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi mathvariant="italic">LCS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>Algorithm 1 presents the BiWFA algorithm to compute a breakpoint in the optimal alignment at <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. Using forward and reverse wavefronts, the algorithm proceeds by alternatingly computing forward and reverse alignments (i.e. <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula>). To this end, BiWFA relies on the operators <italic toggle="yes">WF_NEXT()</italic> and <italic toggle="yes">WF_EXTEND()</italic> from the standard WFA [see <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref>] to compute successive wavefronts using <xref rid="E1" ref-type="disp-formula">Equaions 1</xref> and <xref rid="E2" ref-type="disp-formula">2</xref>. The process is halted after their offsets overlap to compute the position of a breakpoint in the optimal alignment. This algorithm iterates until it is guaranteed that the optimal breakpoint has been found. However, there are some technical details involving the detection of overlaps and the computation of the optimal breakpoint, which we cover in Sections 2.3 and 2.4.</p>
    </sec>
    <sec>
      <title>2.3 Finding a score-balanced breakpoint in the optimal alignment</title>
      <p>The first technical detail involved in finding an alignment breakpoint between the two directions is that it is often not possible to split an alignment into an equally scoring prefix and suffix. In general, two prefixes of the optimal alignment that differ by one character can have scores that differ by as much as <italic toggle="yes">p</italic>. Accordingly, we will demand a weaker notion of balance. If <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are the forward and reverse scores, respectively, we will aim to have <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>The second technical detail is that the optimal score is not always the sum of the two scores. This occurs because the forward iteration incurs the gap open penalty <italic toggle="yes">o</italic> at the beginning of gaps, but the reverse incurs it at the end of gaps (or rather, at the beginning in the reverse direction). Thus, if the two directions meet in a gap, then we have <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula> rather than <inline-formula id="IE67a"><mml:math id="IM67a" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the optimal alignment score.</p>
      <p>The final technical detail is that offsets of the two directions may not precisely meet. WFA proceeds by greedily taking matches in both directions. This makes it possible for the two directions to shoot past each other without actually meeting. It turns out that it is sufficient to detect that such an overshoot has occurred, as will be shown in Section 2.4.</p>
      <p>In Algorithm 2, we reconcile these three difficulties. Without loss of generality, we assume that a forward wavefront <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has been computed (Algorithm 1), and we want to detect overlaps against the previously computed reverse wavefronts <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. First, if <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> belongs to a score-balanced breakpoint (with <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>), it is sufficient to check for overlaps against <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the previous <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> reverse wavefronts. Second, for every diagonal <italic toggle="yes">k</italic> in wavefront <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, Algorithm 2 checks of overlaps in all wavefront components. This way, the algorithm keeps track of the overlap with the minimum score detected so far. Last, note that overlaps on <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:math></inline-formula> and <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:math></inline-formula> components account twice for the gap-open score <italic toggle="yes">o</italic>. Hence, the score from overlaps at indel components has to be decreased by <italic toggle="yes">o</italic>.</p>
      <p>
        <inline-graphic xlink:href="btad074ilf1.jpg"/>
      </p>
      <p>In practice, Algorithm 1 can avoid most calls to <italic toggle="yes">WF_OVERLAP()</italic>. An efficient implementation can keep track of the farthest reached antidiagonal by each wavefront. If the most advanced antidiagonal reached by the forward and reverse wavefronts do not overlap (<italic toggle="yes">ANTIDIAG()</italic> on Algorithm 1), it follows that no offsets from any diagonal can overlap, rendering the call to <italic toggle="yes">WF_OVERLAP()</italic> unnecessary.</p>
    </sec>
    <sec>
      <title>2.4 Correctness of the breakpoint detection</title>
      <p>The correctness of the Algorithm 1 stems from the following lemma.<statement id="mthst1"><label>Lemma 2.1.</label><p><italic toggle="yes">The optimal alignment score</italic> <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">if and only if there exist</italic> <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">and k such that</italic> <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and at least one of the following is true:</italic><list list-type="order"><list-item><p><inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item></list><italic toggle="yes">and further</italic>, <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">(resp.</italic> <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">) is included in the traceback of an alignment with score at most s if the first (resp. second, third) condition is true</italic><bold>.</bold></p><p><bold><italic toggle="yes">Proof.</italic></bold></p><p>See <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p><p><inline-graphic xlink:href="btad074ilf2.jpg"/></p><p>This lemma implies that the minimum value s for which the ‘only if’ condition holds is the optimal score. Moreover, if the first of the three conditions is found to hold for some values <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula>. Therefore, Algorithm 1 is guaranteed to find part of a minimum-scoring alignment based on the following features:
<list list-type="bullet"><list-item><p>Algorithm 2 checks a window of <italic toggle="yes">p</italic> score values on each iteration.</p></list-item><list-item><p>Algorithm 1 iterates through alternatingly increasing values of <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, detecting breakpoints with scores of at least <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> in each iteration.</p></list-item><list-item><p>After finding some <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that satisfy the overlap condition, Algorithm 1 continues for additional iterations until it is no longer possible to find a lower score.</p></list-item></list></p></statement></p>
    </sec>
    <sec>
      <title>2.5 Combining breakpoints into an alignment</title>
      <p>Algorithm 3 shows how to use BiWFA to recursively split alignments into smaller subproblems until the remaining alignment can be trivially solved.</p>
      <p>Note that a breakpoint computed by BiWFA can be found on the I or D components. Thus, those alignments that connect with this breakpoint have to start or end at the given component. This way, Algorithm 3 considers the starting and ending component of each alignment, and forces the underlying WFAs to use different initial conditions depending on the alignment starting at the <italic toggle="yes">M</italic> (<inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>), I (<inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) or <italic toggle="yes">D</italic> component (<inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>). A similar argument applies to the ending conditions of each alignment ending at the <italic toggle="yes">M</italic> (<inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>), <italic toggle="yes">I</italic> (<inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>) or <italic toggle="yes">D</italic> component (<inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>).</p>
    </sec>
    <sec>
      <title>2.6 BiWFA uses <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space and <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time</title>
      <p>The memory complexity of Algorithm 1 is relatively simple to characterize. The range of diagonal values <italic toggle="yes">k</italic> increases by at most two every time <italic toggle="yes">s</italic> is incremented, and each forward and reverse search only needs to store the last <italic toggle="yes">p</italic> wavefronts. Thus, the memory use is proportional to the optimal alignment score, <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, excluding the storage of the input sequences. Also, note that the output alignment only requires storing the position <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for the mismatches, insertions and deletions (matches can be inferred from the gaps). Concerning Algorithm 3, data structures are discarded before entering a recursive call. Therefore, the maximum memory use occurs in the outermost call, in which s is the optimal score of the full alignment.</p>
      <p>
        <inline-graphic xlink:href="btad074ilf3.jpg"/>
      </p>
      <p>The time complexity is more complicated to analyze. Our proof follows similar arguments as those from <xref rid="btad074-B20" ref-type="bibr">Myers (1986)</xref>.<statement id="mthst2"><label>Theorem 2.2.</label><p><italic toggle="yes">BiWFA’s time complexity is</italic> <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, being n and m the sequences’ length and s the optimal alignment score.</italic></p><p><italic toggle="yes">Proof.</italic></p><p>Let <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, and let <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be BiWFA’s execution time with score <italic toggle="yes">s</italic>. A call to BiWFA can result in two recursive calls. Let <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the combined length of the sequences in the two calls, and similarly let <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the two alignment scores. Following Lemma 2.1, we know that these variables obey the following inequalities:
<list list-type="bullet"><list-item><p><inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item></list></p><p>Because each direction of WFA executes in <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>), we can choose a constant <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> large enough that the following inequality holds for all <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>We can also choose a constant <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> large enough that for all <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula><disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></disp-formula></p><p>This follows because the recursion depth depends only on <italic toggle="yes">s</italic>, which we have given an upper bound. Therefore, this term includes a bounded number of calls that all have linear dependence on <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>.</p></statement></p>
      <p>Next, we argue that <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> by induction on <italic toggle="yes">s</italic>. The base cases for <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> follow trivially from the latter of the previous inequalities. Assume then that <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> and the induction hypothesis holds for <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Note that we then have <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, else either <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. Thus,
<disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>This proves the claim.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We implement the BiWFA algorithm described in this work in C. The code and the scripts required to reproduce the experimental results presented in this section are publicly available and can be found at <ext-link xlink:href="https://github.com/smarco/BiWFA-paper" ext-link-type="uri">https://github.com/smarco/BiWFA-paper</ext-link>. Moreover, the code has been integrated into the WFA2-lib alignment library (as ultralow memory mode) at <ext-link xlink:href="https://github.com/smarco/WFA2-lib" ext-link-type="uri">https://github.com/smarco/WFA2-lib</ext-link>.</p>
    <sec>
      <title>3.1 Experimental setup</title>
      <p>We evaluate the performance of our BiWFA implementation compared to the state-of-the-art and other high-performance sequence alignment libraries. We select the original WFA (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>) (wfa-high) and its new low-memory modes (wfa-med and wfa-low) implemented in WFA2-lib (<ext-link xlink:href="https://github.com/smarco/WFA2-lib" ext-link-type="uri">https://github.com/smarco/WFA2-lib</ext-link>). Also, we select the efficient wfalm (<xref rid="btad074-B6" ref-type="bibr">Eizenga and Paten, 2022</xref>) (wfalm) and its low-memory modes (wfalm-low and wfalm-rec). Moreover, we include the highly optimized KSW2-Z2 (ksw2_extz2_sse), from the KSW2 library (<xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>; <xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>), as the best representative of DP-based methods due to its exceptional performance and widely usage within bioinformatics tools. In addition, we include the Edlib (<xref rid="btad074-B28" ref-type="bibr">Šošić and Šikić, 2017</xref>) and BitPal (<xref rid="btad074-B15" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>) libraries, which implement bit-parallel alignment strategies for edit and non-unitary penalties (i.e. gap-linear), respectively. Although they solve a considerably easier problem (i.e. Edlib is restricted to edit-alignments and BitPal only computes the alignment score), and thus are not directly comparable, we included them in the evaluation to provide a performance upper bound.</p>
      <p>We considered including other popular methods like those implemented in the Parasail (<xref rid="btad074-B4" ref-type="bibr">Daily <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btad074-B3" ref-type="bibr">Daily, 2016</xref>; <xref rid="btad074-B7" ref-type="bibr">Farrar, 2007</xref>; <xref rid="btad074-B31" ref-type="bibr">Wozniak, 1997</xref>), SeqAn (<xref rid="btad074-B23" ref-type="bibr">Rahn <italic toggle="yes">et al.</italic>, 2018</xref>) and Gaba (<xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>) libraries. However, these libraries were not designed to align long and noisy sequences, and failed to complete the executions. Therefore these methods were discarded from the evaluation.</p>
      <p>All the presented methods have been configured to generate global alignments. These algorithms are grouped in two categories: ‘Gap-affine Exact’ for exact algorithms that use gap-affine penalties (i.e. BiWFA, WFA and its low-memory modes, wfalm and its low-memory modes and KSW2-Z2), and ‘Others’ for methods that use simpler penalty models or can only compute the alignment score (i.e. Edlib and BitPal).</p>
      <p>For the evaluation, we use simulated and real datasets. For the simulated datasets, we simulate several datasets of various sequence lengths (i.e. 100K, 500K, 1M and 2M bases) and different error rate (i.e. <italic toggle="yes">e </italic>=<italic toggle="yes"> </italic>10% and 20%) randomly generated. Regarding the evaluation with real datasets, we use a first set of sequences generated by the Human Pangenome Reference Consortium (<xref rid="btad074-B19" ref-type="bibr">Miga and Wang, 2021</xref>), consisting of long reads sequenced using Oxford Nanopore Technologies (ONT), PromethION platform, with an average error rate of 5–10%. The sequences are derived from the human cell line HG002, subset to chromosome 12 and restricted to those at least 10 kbp long, for a total number of 1312 sequence pairs of average length equal to 172<italic toggle="yes"> </italic>kbp (maximum ∼306<italic toggle="yes"> </italic>kbp). In addition, we use a second dataset comprising ONT MinION reads from <xref rid="btad074-B2" ref-type="bibr">Bowden <italic toggle="yes">et al.</italic> (2019)</xref>, with an average error rate of 5% and restricted to those at least 500<italic toggle="yes"> </italic>kbp long, for a total number of 48 sequence pairs of average length equal to 630<italic toggle="yes"> </italic>kbp (maximum ∼1<italic toggle="yes"> </italic>Mbp).</p>
      <p>All the executions are performed single-thread on a node running CentOS Linux (release 8.1.1911) equipped with an AMD EPYC 7742 CPU and 1 TB of DRAM (distributed in 16<italic toggle="yes"> </italic>dimms<italic toggle="yes"> </italic>×<italic toggle="yes"> </italic>64<italic toggle="yes"> </italic>GiB @3200<italic toggle="yes"> </italic>MHz).</p>
    </sec>
    <sec>
      <title>3.2 Evaluation on simulated data</title>
      <p><xref rid="btad074-T1" ref-type="table">Table 1</xref> shows the performance results (i.e. execution time and memory) for the different methods using simulated datasets. Overall, the results show that BiWFA is faster and uses less memory than all other methods in the ‘Gap-affine Exact’ category. In particular, BiWFA requires <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mn>32</mml:mn><mml:mo>−</mml:mo><mml:mn>1000</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory than KSW2-Z2, while being <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.4</mml:mn><mml:mo>−</mml:mo><mml:mn>4.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. Compared to original WFA-based methods (i.e. WFA-high and wfalm), BiWFA uses <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mn>9</mml:mn><mml:mo>−</mml:mo><mml:mn>9620</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory, being up to <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mn>4.4</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. Similarly, BiWFA outperforms the other memory-efficient WFA-based methods (i.e. WFA-med, WFA-low, wfalm-low and wfalm-rec), reducing memory requirements down to <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mn>438</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> while being <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.7</mml:mn><mml:mo>−</mml:mo><mml:mn>26.5</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. More importantly, most of the pairwise alignment methods evaluated fail to scale megabases-long sequences, requiring more memory than available in the node (i.e. 1TB). As opposed, BiWFA only requires a few hundred MBs of memory. Note that, computing the full alignment (BiWFA) requires a similar amount of memory as computing only the alignment score (BiWFA.score). Nonetheless, computing the alignment score is <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than computing the full alignment.</p>
      <table-wrap position="float" id="btad074-T1">
        <label>Table 1.</label>
        <caption>
          <p>Time and memory performance of pairwise alignment implementations on simulated data</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="8" rowspan="1">Time (s)<hr/></th>
              <th colspan="8" align="left" rowspan="1">Memory (MBs)<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">10<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" rowspan="1">100<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" rowspan="1">1<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" rowspan="1">2<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">10<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">100<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">1<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">2<italic toggle="yes"> </italic>Mbp<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">edlib</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.6</td>
              <td rowspan="1" colspan="1">2.5</td>
              <td rowspan="1" colspan="1">4.5</td>
              <td rowspan="1" colspan="1">17.9</td>
              <td rowspan="1" colspan="1">35.3</td>
              <td rowspan="1" colspan="1">35.4</td>
              <td rowspan="1" colspan="1">69.1</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">22</td>
              <td rowspan="1" colspan="1">23</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">bitpal</td>
              <td rowspan="1" colspan="1">1.3</td>
              <td rowspan="1" colspan="1">1.2</td>
              <td rowspan="1" colspan="1">12.3</td>
              <td rowspan="1" colspan="1">12.3</td>
              <td rowspan="1" colspan="1">123.8</td>
              <td rowspan="1" colspan="1">123.7</td>
              <td rowspan="1" colspan="1">248.0</td>
              <td rowspan="1" colspan="1">247.1</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">13</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ksw2-extz2</td>
              <td rowspan="1" colspan="1">9.8</td>
              <td rowspan="1" colspan="1">9.9</td>
              <td rowspan="1" colspan="1">96.7</td>
              <td rowspan="1" colspan="1">97.5</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">193</td>
              <td rowspan="1" colspan="1">196</td>
              <td rowspan="1" colspan="1">19 081</td>
              <td rowspan="1" colspan="1">19 083</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-high</td>
              <td rowspan="1" colspan="1">
                <bold>2.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5.7</bold>
              </td>
              <td rowspan="1" colspan="1">28.5</td>
              <td rowspan="1" colspan="1">84.1</td>
              <td rowspan="1" colspan="1">312.9</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">128</td>
              <td rowspan="1" colspan="1">313</td>
              <td rowspan="1" colspan="1">8981</td>
              <td rowspan="1" colspan="1">26 667</td>
              <td rowspan="1" colspan="1">932 199</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-med</td>
              <td rowspan="1" colspan="1">6.6</td>
              <td rowspan="1" colspan="1">20.2</td>
              <td rowspan="1" colspan="1">89.5</td>
              <td rowspan="1" colspan="1">272.8</td>
              <td rowspan="1" colspan="1">1922.1</td>
              <td rowspan="1" colspan="1">3690.1</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">35</td>
              <td rowspan="1" colspan="1">81</td>
              <td rowspan="1" colspan="1">830</td>
              <td rowspan="1" colspan="1">1620</td>
              <td rowspan="1" colspan="1">42 464</td>
              <td rowspan="1" colspan="1">24 874</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-low</td>
              <td rowspan="1" colspan="1">8.0</td>
              <td rowspan="1" colspan="1">24.1</td>
              <td rowspan="1" colspan="1">101.4</td>
              <td rowspan="1" colspan="1">301.1</td>
              <td rowspan="1" colspan="1">4394.9</td>
              <td rowspan="1" colspan="1">4857.0</td>
              <td rowspan="1" colspan="1">7710.2</td>
              <td rowspan="1" colspan="1">9813.1</td>
              <td rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">60</td>
              <td rowspan="1" colspan="1">554</td>
              <td rowspan="1" colspan="1">884</td>
              <td rowspan="1" colspan="1">25 321</td>
              <td rowspan="1" colspan="1">12 539</td>
              <td rowspan="1" colspan="1">52 551</td>
              <td rowspan="1" colspan="1">26 067</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm</td>
              <td rowspan="1" colspan="1">6.4</td>
              <td rowspan="1" colspan="1">19.2</td>
              <td rowspan="1" colspan="1">90.2</td>
              <td rowspan="1" colspan="1">268.7</td>
              <td rowspan="1" colspan="1">841.0</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">54</td>
              <td rowspan="1" colspan="1">148</td>
              <td rowspan="1" colspan="1">8968</td>
              <td rowspan="1" colspan="1">26 575</td>
              <td rowspan="1" colspan="1">898 770</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm-low</td>
              <td rowspan="1" colspan="1">10.1</td>
              <td rowspan="1" colspan="1">30.4</td>
              <td rowspan="1" colspan="1">164.1</td>
              <td rowspan="1" colspan="1">494.8</td>
              <td rowspan="1" colspan="1">1525.1</td>
              <td rowspan="1" colspan="1">4418.7</td>
              <td rowspan="1" colspan="1">2990.1</td>
              <td rowspan="1" colspan="1">8779.4</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">443</td>
              <td rowspan="1" colspan="1">823</td>
              <td rowspan="1" colspan="1">10 435</td>
              <td rowspan="1" colspan="1">30 817</td>
              <td rowspan="1" colspan="1">36 299</td>
              <td rowspan="1" colspan="1">69 312</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm-rec</td>
              <td rowspan="1" colspan="1">22.3</td>
              <td rowspan="1" colspan="1">70.7</td>
              <td rowspan="1" colspan="1">447.5</td>
              <td rowspan="1" colspan="1">1402.6</td>
              <td rowspan="1" colspan="1">5792.7</td>
              <td rowspan="1" colspan="1">17 752.9</td>
              <td rowspan="1" colspan="1">11 979.6</td>
              <td rowspan="1" colspan="1">37 747.7</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">43</td>
              <td rowspan="1" colspan="1">73</td>
              <td rowspan="1" colspan="1">497</td>
              <td rowspan="1" colspan="1">904</td>
              <td rowspan="1" colspan="1">1064</td>
              <td rowspan="1" colspan="1">1787</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BiWFA</td>
              <td rowspan="1" colspan="1">2.4</td>
              <td rowspan="1" colspan="1">6.9</td>
              <td rowspan="1" colspan="1">
                <bold>20.8</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>61.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>218.3</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>680.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>466.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1429.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>6</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>19</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>27</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>97</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>180</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>202</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>267</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BiWFA.score</td>
              <td rowspan="1" colspan="1">1.1</td>
              <td rowspan="1" colspan="1">3.1</td>
              <td rowspan="1" colspan="1">10.2</td>
              <td rowspan="1" colspan="1">30.2</td>
              <td rowspan="1" colspan="1">112.2</td>
              <td rowspan="1" colspan="1">355.8</td>
              <td rowspan="1" colspan="1">245.4</td>
              <td rowspan="1" colspan="1">750.2</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">186</td>
              <td rowspan="1" colspan="1">204</td>
              <td rowspan="1" colspan="1">256</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Execution time (in seconds) and memory (in MBs) required per 1M bases aligned, using different pairwise alignment implementations on simulated datasets. Executions that failed appear as ‘n/a’. Best performing implementation in the ‘Gap-affine Exact’ category is marked in bold. Although Edlib and BitPal are not directly comparable to the other implementations, we included them in the comparison as a reference. Similarly, we include executions of BiWFA limited to compute the alignment score as ‘BiWFA.score’.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>For completeness, we present a comprehensive experimental evaluation on a wider range of sequence lengths (i.e. 100 bp, 1 Kbp, 10 Kbp, 100 Kbp, 1 Mbp and 2 Mbp) and error rates (0.1%, 1%, 5%, 10%, 20% and 40%) on <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1 and S2</xref>). For short sequences (i.e. ≤1 Kbp), the results show that BiWFA delivers similar performance as the original WFA (<inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.25</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> slower) while reducing the memory requirements up to <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mn>60</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>. Our experiments indicate that BiWFA starts outperforming the original WFA when aligning sequences longer than ∼30 Kbp. Nevertheless, the exact performance breakpoint can vary depending on the error rate, implementation and processor specifics. Similarly, for smaller error rates (i.e. <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mo>≤</mml:mo></mml:math></inline-formula>1%), WFA-based methods largely outperform other approaches, being <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> orders of magnitude faster than other methods like KSW2-Z2, bitpal and edlib. In addition, for low error rates, memory-efficient WFA-based methods require a minimal amount of memory.</p>
    </sec>
    <sec>
      <title>3.3 Evaluation on real data</title>
      <p><xref rid="btad074-F2" ref-type="fig">Figure 2</xref> shows the performance results obtained for all the evaluated algorithms in terms of execution time and consumed memory. BiWFA uses many times less memory than other methods. In particular, when aligning ultra-long ONT sequences (<xref rid="btad074-F2" ref-type="fig">Fig. 2B</xref>), BiWFA requires between <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mn>68</mml:mn><mml:mo>−</mml:mo><mml:mn>93</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory compared to wfalm and WFA low-memory modes. Furthermore, BiWFA uses 3.5<inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mo>×</mml:mo></mml:math></inline-formula> less memory compared to the efficient recursive mode from wfalm (most memory-efficient gap-affine algorithm to date).</p>
      <fig position="float" id="btad074-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Experimental results from the execution of BiWFA and other state-of-the-art implementations aligning long sequences. Figure shows (<bold>A</bold>) memory consumption and (<bold>B</bold>) execution time per sequence aligned. A vertical line on each panel separates algorithms that use simpler penalty models or can only compute the alignment score (i.e. edlib and bitpal) from those that compute the full gap-affine alignment</p>
        </caption>
        <graphic xlink:href="btad074f2" position="float"/>
      </fig>
      <p>At the same time, BiWFA proves to be one of the fastest implementations aligning long sequences. Using ultra-long sequences, our method is <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mn>25.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than wfalm’s recursive mode. Moreover, BiWFA’s execution times are similar to those of BitPal (sometimes even faster, <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.1</mml:mn><mml:mo>−</mml:mo><mml:mn>1.28</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster on average) computing exact alignments (not just the score) under the gap-affine model.</p>
      <p>For completeness, <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S1</xref> shows experimental results limited to aligning sequences up to 10<italic toggle="yes"> </italic>Kbps. In this scenario, BiWFA demonstrates to be one of the fastest implementations, requiring less than 10<italic toggle="yes"> </italic>MB to execute.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>As long sequencing technologies improve and high-quality sequence assembly decreases in cost, we anticipate that the importance of pairwise alignment algorithm will continue to increase. To keep up with upcoming improvements in sequencing and genomics, pairwise alignment algorithms need to face crucial challenges in reducing execution time and memory consumption. In this work, we have presented the BiWFA, a gap-affine pairwise alignment algorithm that requires <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space, being the first algorithm to improve the long standing space lower bound of <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The BiWFA answers the pressing need for sequence alignment methods capable to scaling to genome-scale alignments and full pangenomes.</p>
    <p>Most notably, BiWFA execution times are very similar, or even better, than those of the original WFA (despite BiWFA requiring <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mn>2954</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mn>607</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory when aligning ultra-long MinION and PromethION sequences, respectively). This result can be better understood considering the memory inefficiencies that the original WFA experiences when using a large memory footprint. As the sequence’s length and error increases, the original WFA uses a substantially larger memory footprint, putting a significant pressure on the memory hierarchy of the processor. Due to the pervasive memory inefficiencies of modern processors executing memory intensive applications, the original WFA’s performance is severely deteriorated when aligning long sequence datasets (like those from Nanopore presented in the evaluation). In contrast, BiWFA relieves this memory pressure using a minimal memory footprint. As a result, BiWFA is able to balance out the additional work induced by BiWFA’s recursion, delivering a performance on-par with the original WFA.</p>
    <p>We have presented the BiWFA using gap-affine penalties. Nevertheless, these very same ideas can be translated directly into other distances like edit, linear gap or piecewise gap-affine. Moreover, it can be easily extended to semi-global alignment (a.k.a. ends-free, glocal, extension or overlapped alignment) by modifying the initial conditions and termination criterion. At the same time, the BiWFA retains the strengths of the original WFA: no restrictions on the sequences’ alphabet, preprocessing steps, nor prior estimation of the alignment error.</p>
    <p>Due to the simplicity of the WFA’s computational pattern, BiWFA’s core functions can be easily vectorized to fully exploit the capabilities of modern SIMD multicore processors. Our implementation, relies on the automatic vectorization capabilities of modern compilers. As a result, the BiWFA implementation can exploit the SIMD capabilities of any processor supported by modern compilers, without rewriting any part of the source code.</p>
    <p>Genomics and bioinformatics methods will continue to rely on sequence alignment as a core and critical component. BiWFA paves the way for the development of faster and more accurate tools that can scale with longer and noisy sequences using a minimal amount of memory. In this way, we expect BiWFA to enable efficient sequence alignment at genome-scale in years to come.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad074_Supplementary_Data</label>
      <media xlink:href="btad074_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Ragnar Groot Koerkamp and the anonymous reviewers for making useful suggestions and contributing to improving the manuscript.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This research was supported by the European Union Regional Development Fund within the framework of the ERDF Operational Program of Catalonia 2014-2020 with a grant of 50% of total cost eligible under the DRAC project [001-P-001723] and Lenovo-BSC Contract-Framework Contract (2022). It was also supported by the Ministerio de Ciencia e Innovacion MCIN AEI/10.13039/501100011033 and NextGenerationEU/PRTR under contracts PID2020-113614RB-C21, PID2019-107255GB-C21, and TED2021-132634A-I00, by the Generalitat de Catalunya GenCat-DIUiE (GRR) [contracts 2017-SGR-313, 2017-SGR-1328 and 2017-SGR-1414]. M.M. was partially supported by the Spanish Ministry of Economy, Industry and Competitiveness under Ramon y Cajal fellowship number RYC-2016-21104. S.M.-S. was supported by Juan de la Cierva fellowship grant IJC2020-045916-I funded by MCIN/AEI/10.13039/501100011033 and by ‘European Union NextGenerationEU/PRTR’. B.P. and J.M.E. were supported, in part, by the United States National Institutes of Health [award numbers: R01HG010485, U01HG010961, OT2OD026682, OT3HL142481 and U24HG011853]. E.G. was supported by NIH/NIDA U01DA047638 and NSF PPoSS Award #2118709. A.G. acknowledges Dr. Nicole Soranzo’s efforts to establish a pangenome research unit at the Human Technopole in Milan, Italy.</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad074-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>1990</year>) <article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biol</source>., <volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bowden</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Sequencing of human genomes with nanopore technology</article-title>. <source>Nat. Commun</source>., <volume>10</volume>, <fpage>1869</fpage>.<pub-id pub-id-type="pmid">31015479</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Parasail: SIMD C library for global, semi-global, and local pairwise sequence alignments</article-title>. <source>BMC Bioinf</source>., <volume>17</volume>, <fpage>1</fpage>–<lpage>11</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>A work stealing based approach for enabling scalable optimal sequence homology detection</article-title>. <source>J. Parallel Distributed Comput</source>., <volume>79</volume>, <fpage>132</fpage>–<lpage>142</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>1998</year>) <source>Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids</source>. <publisher-name>Cambridge University Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btad074-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Eizenga</surname><given-names>J.M.</given-names></string-name>, <string-name><surname>Paten</surname><given-names>B.</given-names></string-name></person-group> (<year>2022</year>) Improving the time and space complexity of the WFA algorithm and generalizing its scoring. <italic toggle="yes">bioRxiv</italic>.</mixed-citation>
    </ref>
    <ref id="btad074-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Farrar</surname><given-names>M.</given-names></string-name></person-group> (<year>2007</year>) <article-title>Striped Smith–Waterman speeds database searches six times over other SIMD implementations</article-title>. <source>Bioinformatics</source>, <volume>23</volume>, <fpage>156</fpage>–<lpage>161</lpage>.<pub-id pub-id-type="pmid">17110365</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Garrison</surname><given-names>E.</given-names></string-name>, <string-name><surname>Marth</surname><given-names>G.</given-names></string-name></person-group> (<year>2012</year>) Haplotype-based variant detection from short-read sequencing. <italic toggle="yes">arXiv preprint arXiv:1207.3907.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gotoh</surname><given-names>O.</given-names></string-name></person-group> (<year>1982</year>) <article-title>An improved algorithm for matching biological sequences</article-title>. <source>J. Mol. Biol</source>., <volume>162</volume>, <fpage>705</fpage>–<lpage>708</lpage>.<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Jones</surname><given-names>N.</given-names></string-name></person-group><etal>et al</etal> (<year>2004</year>) <source>An Introduction to Bioinformatics Algorithms</source>. <publisher-name>MIT Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btad074-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kiełbasa</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Adaptive seeds tame genomic sequence comparison</article-title>. <source>Genome Res</source>., <volume>21</volume>, <fpage>487</fpage>–<lpage>493</lpage>.<pub-id pub-id-type="pmid">21209072</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koren</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>CANU: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>722</fpage>–<lpage>736</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2013</year>) Aligning sequence reads, clone sequences and assembly contigs with bwa-mem. <italic toggle="yes">arXiv preprint arXiv:1303.3997.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3094</fpage>–<lpage>3100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loving</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3166</fpage>–<lpage>3173</lpage>.<pub-id pub-id-type="pmid">25075119</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>The gem mapper: fast, accurate and versatile alignment by filtration</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>1185</fpage>–<lpage>1188</lpage>.<pub-id pub-id-type="pmid">23103880</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Fast gap-affine pairwise alignment using the wavefront algorithm</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>456</fpage>–<lpage>463</lpage>.<pub-id pub-id-type="pmid">32915952</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McKenna</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2010</year>) <article-title>The genome analysis toolkit: a mapreduce framework for analyzing next-generation DNA sequencing data</article-title>. <source>Genome Res</source>., <volume>20</volume>, <fpage>1297</fpage>–<lpage>1303</lpage>.<pub-id pub-id-type="pmid">20644199</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Miga</surname><given-names>K. H.</given-names></string-name>, <string-name><surname>Wang</surname><given-names>T.</given-names></string-name></person-group> (<year>2021</year>) <article-title>The need for a human pangenome reference sequence</article-title>. <source>Annu. Rev. Genomics Hum. Genet</source>., <volume>22</volume>, <fpage>81</fpage>–<lpage>102</lpage>.<pub-id pub-id-type="pmid">33929893</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E. W.</given-names></string-name></person-group> (<year>1986</year>) <article-title>An <italic toggle="yes">O</italic>(<italic toggle="yes">ND</italic>) difference algorithm and its variations</article-title>. <source>Algorithmica</source>, <volume>1</volume>, <fpage>251</fpage>–<lpage>266</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E. W.</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W.</given-names></string-name></person-group> (<year>1988</year>) <article-title>Optimal alignments in linear space</article-title>. <source>Bioinformatics</source>, <volume>4</volume>, <fpage>11</fpage>–<lpage>17</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Needleman</surname><given-names>S. B.</given-names></string-name>, <string-name><surname>Wunsch</surname><given-names>C. D.</given-names></string-name></person-group> (<year>1970</year>) <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>. <source>J. Mol. Biol</source>., <volume>48</volume>, <fpage>443</fpage>–<lpage>453</lpage>.<pub-id pub-id-type="pmid">5420325</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rahn</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Generic accelerated sequence alignment in seqan using vectorization and multi-threading</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3437</fpage>–<lpage>3445</lpage>.<pub-id pub-id-type="pmid">29726911</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rodríguez-Martín</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>Chimpipe: accurate detection of fusion genes and transcription-induced chimeras from RNA-seq data</article-title>. <source>BMC Genomics</source>, <volume>18</volume>, <fpage>7</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">28049418</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T.</given-names></string-name>, <string-name><surname>Seeberg</surname><given-names>E.</given-names></string-name></person-group> (<year>2000</year>) <article-title>Six-fold speed-up of Smith–Waterman sequence database searches using parallel processing on common microprocessors</article-title>. <source>Bioinformatics</source>, <volume>16</volume>, <fpage>699</fpage>–<lpage>706</lpage>.<pub-id pub-id-type="pmid">11099256</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Simpson</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2009</year>) <article-title>ABYSS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Smith</surname><given-names>T. F.</given-names></string-name>, <string-name><surname>Waterman</surname><given-names>M. S.</given-names></string-name></person-group> (<year>1981</year>) <article-title>Comparison of biosequences</article-title>. <source>Adv. Appl. Math</source>., <volume>2</volume>, <fpage>482</fpage>–<lpage>489</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Šošić</surname><given-names>M.</given-names></string-name>, <string-name><surname>Šikić</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) <article-title>EDLIB: a C/C++ library for fast, exact sequence alignment using edit distance</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>1394</fpage>–<lpage>1395</lpage>.<pub-id pub-id-type="pmid">28453688</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) Acceleration of nucleotide semi-global alignment with adaptive banded dynamic programming. <italic toggle="yes">bioRxiv.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Introducing difference recurrence relations for faster semi-global alignment of long sequences</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>33</fpage>–<lpage>47</lpage>.<pub-id pub-id-type="pmid">29402212</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wozniak</surname><given-names>A.</given-names></string-name></person-group> (<year>1997</year>) <article-title>Using video-oriented instructions to speed up sequence comparison</article-title>. <source>Bioinformatics</source>, <volume>13</volume>, <fpage>145</fpage>–<lpage>150</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Xia</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>A review of parallel implementations for the Smith–Waterman algorithm</article-title>. In: <source>Interdisciplinary Sciences: Computational Life Sciences</source>, pp. <fpage>1</fpage>–<lpage>14</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2000</year>) <article-title>A greedy algorithm for aligning DNA sequences</article-title>. <source>J. Comput. Biol</source>., <volume>7</volume>, <fpage>203</fpage>–<lpage>214</lpage>.<pub-id pub-id-type="pmid">10890397</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhao</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2013</year>) <article-title>SSW library: an SIMD Smith–Waterman C/C++ library for use in genomic applications</article-title>. <source>PLoS ONE</source>, <volume>8</volume>, <fpage>e82138</fpage>.<pub-id pub-id-type="pmid">24324759</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9940620</article-id>
    <article-id pub-id-type="pmid">36749013</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad074</article-id>
    <article-id pub-id-type="publisher-id">btad074</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Optimal gap-affine alignment in <italic toggle="yes">O</italic>(<italic toggle="yes">s</italic>) space</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-7951-3914</contrib-id>
        <name>
          <surname>Marco-Sola</surname>
          <given-names>Santiago</given-names>
        </name>
        <aff><institution>Computer Sciences Department, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors i Sistemes Operatius, Universitat Autònoma de Barcelona</institution>, Barcelona 08193, <country country="ES">Spain</country></aff>
        <xref rid="btad074-cor1" ref-type="corresp"/>
        <!--santiagomsola@gmail.com-->
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8345-8356</contrib-id>
        <name>
          <surname>Eizenga</surname>
          <given-names>Jordan M</given-names>
        </name>
        <aff><institution>Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-9744-131X</contrib-id>
        <name>
          <surname>Guarracino</surname>
          <given-names>Andrea</given-names>
        </name>
        <aff><institution>Genomics Research Centre, Human Technopole</institution>, Milan 20157, <country country="IT">Italy</country></aff>
        <aff><institution>Department of Genetics, Genomics and Informatics, University of Tennessee Health Science Center</institution>, Memphis, TN 38163, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0001-8863-3539</contrib-id>
        <name>
          <surname>Paten</surname>
          <given-names>Benedict</given-names>
        </name>
        <aff><institution>Genomics Institute, University of California Santa Cruz</institution>, Santa Cruz, CA 95064, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-3821-631X</contrib-id>
        <name>
          <surname>Garrison</surname>
          <given-names>Erik</given-names>
        </name>
        <aff><institution>Department of Genetics, Genomics and Informatics, University of Tennessee Health Science Center</institution>, Memphis, TN 38163, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-9848-8758</contrib-id>
        <name>
          <surname>Moreto</surname>
          <given-names>Miquel</given-names>
        </name>
        <aff><institution>Computer Sciences Department, Barcelona Supercomputing Center</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
        <aff><institution>Departament d’Arquitectura de Computadors, Universitat Politècnica de Catalunya</institution>, Barcelona 08034, <country country="ES">Spain</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Martelli</surname>
          <given-names>Pier Luigi</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad074-cor1">To whom correspondence should be addressed. <email>santiagomsola@gmail.com</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-02-07">
      <day>07</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>07</day>
      <month>2</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>2</issue>
    <elocation-id>btad074</elocation-id>
    <history>
      <date date-type="received">
        <day>17</day>
        <month>8</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>02</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>30</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>20</day>
        <month>2</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad074.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Pairwise sequence alignment remains a fundamental problem in computational biology and bioinformatics. Recent advances in genomics and sequencing technologies demand faster and scalable algorithms that can cope with the ever-increasing sequence lengths. Classical pairwise alignment algorithms based on dynamic programming are strongly limited by quadratic requirements in time and memory. The recently proposed wavefront alignment algorithm (WFA) introduced an efficient algorithm to perform exact gap-affine alignment in <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <italic toggle="yes">s</italic> is the optimal score and <italic toggle="yes">n</italic> is the sequence length. Notwithstanding these bounds, WFA’s <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory requirements become computationally impractical for genome-scale alignments, leading to a need for further improvement.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we present the bidirectional WFA algorithm, the first gap-affine algorithm capable of computing optimal alignments in <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory while retaining WFA’s time complexity of <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As a result, this work improves the lowest known memory bound <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to compute gap-affine alignments. In practice, our implementation never requires more than a few hundred MBs aligning noisy Oxford Nanopore Technologies reads up to 1 Mbp long while maintaining competitive execution times.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>All code is publicly available at <ext-link xlink:href="https://github.com/smarco/BiWFA-paper" ext-link-type="uri">https://github.com/smarco/BiWFA-paper</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p>Supplementary data are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>European Union</institution>
            <institution-id institution-id-type="DOI">10.13039/501100000780</institution-id>
          </institution-wrap>
        </funding-source>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Ministerio de Ciencia e Innovacion</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Pairwise sequence alignment provides a parsimonious transformation of one string into another. From this transformation, we can understand the relationship between pairs of sequences. Because similarities and differences between biosequences (DNA, RNA, protein) relate to variation in function and evolutionary history of living things, pairwise sequence alignment algorithms are a core part of many essential bioinformatics methods in read mapping (<xref rid="btad074-B13" ref-type="bibr">Li, 2013</xref>; <xref rid="btad074-B16" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2012</xref>), genome assembly (<xref rid="btad074-B12" ref-type="bibr">Koren <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btad074-B26" ref-type="bibr">Simpson <italic toggle="yes">et al.</italic>, 2009</xref>), variant calling (<xref rid="btad074-B8" ref-type="bibr">Garrison and Marth, 2012</xref>; <xref rid="btad074-B18" ref-type="bibr">McKenna <italic toggle="yes">et al.</italic>, 2010</xref>; <xref rid="btad074-B24" ref-type="bibr">Rodríguez-Martín <italic toggle="yes">et al.</italic>, 2017</xref>) and many others (<xref rid="btad074-B5" ref-type="bibr">Durbin <italic toggle="yes">et al.</italic>, 1998</xref>; <xref rid="btad074-B10" ref-type="bibr">Jones et al., 2004</xref>). Its importance has motivated the research and development of multiple solutions over the past 50 years.</p>
    <p>Classical approaches to derive alignments involve the application of <italic toggle="yes">dynamic programming</italic> (DP) techniques. These methods require computing a matrix whose dimensions correspond to the lengths of the query <italic toggle="yes">q</italic> and target <italic toggle="yes">t</italic> sequences. Using DP recurrence relations, these methods compute the optimal alignment score for progressively longer prefixes of <italic toggle="yes">q</italic> and <italic toggle="yes">t</italic>, which correspond to the cells of the DP matrix. Thus, an optimal alignment can then be read out by tracing the recurrence back through the matrix.</p>
    <p>Selecting a suitable alignment score function is essential to obtain biologically meaningful alignments, as it determines the characteristics of optimal alignments. In effect, the alignment score function encodes prior expectations about the probability of certain kinds of sequence differences. It has been observed that, in many contexts, insertions and deletions are non-uniformly distributed; they are infrequent but tend to be adjacent so that they form extended <italic toggle="yes">gaps</italic> with a long-tailed length distribution. This motivated the development of <italic toggle="yes">gap-affine</italic> models in which the penalty of starting a new gap is larger than that of extending a gap (<xref rid="btad074-B9" ref-type="bibr">Gotoh, 1982</xref>). Crucially, gap-affine penalties can be implemented efficiently using additional DP matrices.</p>
    <p>Problematically, the efficiency of classical gap-affine DP-based methods is constrained by their quadratic requirements in time and memory with respect to the lengths of the sequence pair. Consequently, multiple optimizations have been proposed over the years. Notable examples include bit-parallel techniques (<xref rid="btad074-B15" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>), data-layout transformations to exploit SIMD instructions (<xref rid="btad074-B7" ref-type="bibr">Farrar, 2007</xref>; <xref rid="btad074-B25" ref-type="bibr">Rognes and Seeberg, 2000</xref>; <xref rid="btad074-B31" ref-type="bibr">Wozniak, 1997</xref>), difference encoding of the DP matrix (<xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>), among other methods (<xref rid="btad074-B1" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic>, 1990</xref>; <xref rid="btad074-B11" ref-type="bibr">Kiełbasa <italic toggle="yes">et al.</italic>, 2011</xref>; <xref rid="btad074-B32" ref-type="bibr">Xia <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btad074-B34" ref-type="bibr">Zhao <italic toggle="yes">et al.</italic>, 2013</xref>). Nonetheless, all these exact methods retain the quadratic requirements of the original DP algorithm and therefore struggle to scale when aligning long sequences.</p>
    <p>In many cases, when two sequences are homologous, the majority of possible alignments are largely sub-optimal, having a substantially worse score than the optimal one. For this reason, heuristic methods are usually employed to find candidate alignment regions when the cost of exact algorithms becomes impractical. Most notable approaches use adaptive <italic toggle="yes">band</italic> methods (<xref rid="btad074-B29" ref-type="bibr">Suzuki and Kasahara, 2017</xref>) or pruning strategies [e.g. X-drop (<xref rid="btad074-B33" ref-type="bibr">Zhang <italic toggle="yes">et al.</italic>, 2000</xref>) and Z-drop (<xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>)] to avoid the computation of alignments extremely unlikely to be optimal. These heuristic methods have been implemented within many widely used tools (<xref rid="btad074-B1" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic>, 1990</xref>; <xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>).</p>
    <p>Recently, we proposed the wavefront alignment algorithm (WFA) (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>) to compute the exact alignment between two sequences using gap-affine penalties. WFA reformulates the alignment problem to compute the longest-possible alignments of increasing score until the optimal alignment is found. Notably, WFA takes advantage of homologous regions between sequences to accelerate alignment’s computation. As a result, WFA computes optimal gap-affine alignments in <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory, where <italic toggle="yes">n</italic> is the sequence length and <italic toggle="yes">s</italic> the optimal alignment score. Being an exact algorithm, WFA provides the same guarantee for optimality as classical algorithms (<xref rid="btad074-B9" ref-type="bibr">Gotoh, 1982</xref>; <xref rid="btad074-B22" ref-type="bibr">Needleman and Wunsch, 1970</xref>; <xref rid="btad074-B27" ref-type="bibr">Smith and Waterman, 1981</xref>), but does away with the quadratic requirements in time.</p>
    <p>WFA unlocked the path for optimal alignment methods capable of scaling to long sequences. Nevertheless, the <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory requirements quickly become the limiting factor when aligning sufficiently long or noisy sequences (<xref rid="btad074-B6" ref-type="bibr">Eizenga and Paten, 2022</xref>). As it happens, WFA’s memory requirements can be impractical when aligning through large structural variations or highly divergent genome regions. Given that we use alignment to understand variation, these are some contexts in which optimal alignment could be most useful, but its memory requirements make it prohibitive.</p>
    <p>To address this problem, this article presents the first gap-affine alignment algorithm to compute the optimal alignment in <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory (excluding the storage of the input sequences). Our method, the bidirectional WFA algorithm (BiWFA), computes the WFA alignment of two sequences in the forward and reverse direction until they meet. Using two wavefronts of <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory, we demonstrate how to find the optimal breakpoint of the alignment at score <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and proceed recursively to solve the complete alignment in <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. To our knowledge, this work improves the lowest known memory bound to compute gap-affine alignments <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btad074-B21" ref-type="bibr">Myers and Miller, 1988</xref>) to <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, while retaining the time complexity of the original WFA <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Furthermore, our experimental results demonstrate that the BiWFA delivers comparable, or even better, performance than the original WFA, outperforming other state-of-the-art tools while using a minimal amount of memory.</p>
    <p>The rest of the article is structured as follows. Section 2 presents the definitions, algorithms and formal proofs supporting BiWFA. Section 3 shows the experimental evaluation of our method, comparing it against other state-of-the-art tools and libraries. Lastly, Section 4 presents a discussion on the BiWFA method and summarizes the contributions and impact of this work.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Wavefront alignment algorithm</title>
      <p>Let the query <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the text <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be strings of length <italic toggle="yes">n</italic> and <italic toggle="yes">m</italic>, respectively. Likewise, let <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote a substring of any string <italic toggle="yes">v</italic> from the <italic toggle="yes">i</italic>th to the <italic toggle="yes">j</italic>th character. We will use <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the gap-affine penalties. A mismatch costs <italic toggle="yes">x</italic>, and a gap of length <italic toggle="yes">l</italic> costs <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mo>⋅</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula>. We assume that <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, and further that all of the score parameters are constants.</p>
      <p>Basically, WFA computes partial optimal alignments of increasing score until an alignment with score <italic toggle="yes">s</italic> reaches coordinate <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the DP matrix. In this way, the algorithm determines that <italic toggle="yes">s</italic> is the minimal alignment score. Moreover, it can derive the optimal alignment by tracing back the partial alignments that led to score <italic toggle="yes">s</italic> at <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>Let <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denote the offset within diagonal <italic toggle="yes">k</italic> in the DP-matrix to the farthest-reaching (f.r.) cell that has score <italic toggle="yes">s</italic> and ends with a match, mismatch, insertion or deletion, respectively. In general, we denote by <italic toggle="yes">wavefront</italic> the tuple of offsets for a given score <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We refer to the four elements in this tuple as its <italic toggle="yes">components</italic>, and we associate a corresponding sentinel value to specify each component: <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>M</mml:mi><mml:mo>,</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref>, we proved that the f.r. points of <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> can be computed using previous wavefronts <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">W</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, using <xref rid="E1" ref-type="disp-formula">Equation 1</xref> where <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the length of longest common prefix between substrings <italic toggle="yes">v</italic> and <italic toggle="yes">w</italic>. The base case for this recursion is given by <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p><xref rid="E1" ref-type="disp-formula">Equation 1</xref> shows that the computation of a given wavefront depends only on the previous <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>+</mml:mo><mml:mi>e</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> wavefronts. We refer to <italic toggle="yes">p</italic> as the wavefront <italic toggle="yes">scope</italic> or, in other words, the maximum score increase between partial alignments. Moreover, note that <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> does not need to be explicitly stored as its values can be inferred using <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>In the worst case, WFA requires computing <italic toggle="yes">s</italic> wavefronts of increasing length, totalling <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mi>s</mml:mi></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> cells. Moreover, the <italic toggle="yes">LCP</italic> must be computed once for each cell. However, within a diagonal, the total number of offset increments cannot exceed the length of the sequences. Hence, WFA requires <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> memory in the worst case (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>). Since <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mi>p</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, the <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor of the execution time, due to the <italic toggle="yes">LCP</italic>, dominates over the <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> factor in the worst case. However, in practice, the time is often closer to <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This is because spurious matches between high-entropy sequences are short in expectation. Accordingly, the <italic toggle="yes">LCP</italic> computations often finish after performing only a few character comparisons, except along the optimal alignment in which <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> comparisons are required.</p>
    </sec>
    <sec>
      <title>2.2 Bidirectional wavefront alignment algorithm</title>
      <p>The core idea of the BiWFA algorithm is to perform WFA simultaneously in both directions on the strings: from start to end (i.e. forward) and from end to start (i.e. reverse). Each direction will only retain <italic toggle="yes">p</italic> wavefronts in memory. This is insufficient to perform a full traceback. However, when they ‘meet’ in the middle, we can infer a breakpoint in the alignment that divides the optimal score roughly in half. Then, we can apply the same procedure on the two sides of the breakpoint recursively. We will show that this results in only a constant-factor slowdown. This technique was previously employed to a similar end with the Myers <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>D</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> difference algorithm (<xref rid="btad074-B20" ref-type="bibr">Myers, 1986</xref>).</p>
      <p><xref rid="btad074-F1" ref-type="fig">Figure 1</xref> presents a graphical example of BiWFA computing a breakpoint in the optimal alignment between two sequences. The figure shows the DP cells computed by the forward and reverse wavefronts. Alignments in both directions progress until they overlap on cell <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with score <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mn>8</mml:mn><mml:mo>+</mml:mo><mml:mn>8</mml:mn><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula> corresponding to the optimal alignment (<inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
      <fig position="float" id="btad074-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Example of BiWFA aligning <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mi mathvariant="italic">TCTAGCG</mml:mi><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> against <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mo>“</mml:mo><mml:mi mathvariant="italic">TGGAAAG</mml:mi><mml:mo>”</mml:mo></mml:mrow></mml:math></inline-formula> under the penalties <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btad074f1" position="float"/>
      </fig>
      <p>First, let us define the WFA equations for the forward and reverse alignment directions. The recursions for the forward direction are equivalent to those of the standard WFA presented above (<xref rid="E1" ref-type="disp-formula">Equation 1</xref>). However, to highlight the distinction, we will denote them <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The recursions for the reverse direction are very similar (<xref rid="E2" ref-type="disp-formula">Equation 2</xref>), using <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> as the base case and <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the length of the longest common suffix of <italic toggle="yes">v</italic> and <italic toggle="yes">w</italic>. Note that the same argument used in <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref> applies to the reverse recursions to prove that they are f.r. in the reverse direction.
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>e</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>min</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi mathvariant="italic">LCS</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">X</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>Algorithm 1 presents the BiWFA algorithm to compute a breakpoint in the optimal alignment at <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. Using forward and reverse wavefronts, the algorithm proceeds by alternatingly computing forward and reverse alignments (i.e. <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula>). To this end, BiWFA relies on the operators <italic toggle="yes">WF_NEXT()</italic> and <italic toggle="yes">WF_EXTEND()</italic> from the standard WFA [see <xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic> (2021)</xref>] to compute successive wavefronts using <xref rid="E1" ref-type="disp-formula">Equaions 1</xref> and <xref rid="E2" ref-type="disp-formula">2</xref>. The process is halted after their offsets overlap to compute the position of a breakpoint in the optimal alignment. This algorithm iterates until it is guaranteed that the optimal breakpoint has been found. However, there are some technical details involving the detection of overlaps and the computation of the optimal breakpoint, which we cover in Sections 2.3 and 2.4.</p>
    </sec>
    <sec>
      <title>2.3 Finding a score-balanced breakpoint in the optimal alignment</title>
      <p>The first technical detail involved in finding an alignment breakpoint between the two directions is that it is often not possible to split an alignment into an equally scoring prefix and suffix. In general, two prefixes of the optimal alignment that differ by one character can have scores that differ by as much as <italic toggle="yes">p</italic>. Accordingly, we will demand a weaker notion of balance. If <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are the forward and reverse scores, respectively, we will aim to have <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>The second technical detail is that the optimal score is not always the sum of the two scores. This occurs because the forward iteration incurs the gap open penalty <italic toggle="yes">o</italic> at the beginning of gaps, but the reverse incurs it at the end of gaps (or rather, at the beginning in the reverse direction). Thus, if the two directions meet in a gap, then we have <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula> rather than <inline-formula id="IE67a"><mml:math id="IM67a" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>o</mml:mi><mml:mi>p</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the optimal alignment score.</p>
      <p>The final technical detail is that offsets of the two directions may not precisely meet. WFA proceeds by greedily taking matches in both directions. This makes it possible for the two directions to shoot past each other without actually meeting. It turns out that it is sufficient to detect that such an overshoot has occurred, as will be shown in Section 2.4.</p>
      <p>In Algorithm 2, we reconcile these three difficulties. Without loss of generality, we assume that a forward wavefront <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> has been computed (Algorithm 1), and we want to detect overlaps against the previously computed reverse wavefronts <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. First, if <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> belongs to a score-balanced breakpoint (with <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>), it is sufficient to check for overlaps against <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and the previous <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> reverse wavefronts. Second, for every diagonal <italic toggle="yes">k</italic> in wavefront <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">W</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, Algorithm 2 checks of overlaps in all wavefront components. This way, the algorithm keeps track of the overlap with the minimum score detected so far. Last, note that overlaps on <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:math></inline-formula> and <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:math></inline-formula> components account twice for the gap-open score <italic toggle="yes">o</italic>. Hence, the score from overlaps at indel components has to be decreased by <italic toggle="yes">o</italic>.</p>
      <p>
        <inline-graphic xlink:href="btad074ilf1.jpg"/>
      </p>
      <p>In practice, Algorithm 1 can avoid most calls to <italic toggle="yes">WF_OVERLAP()</italic>. An efficient implementation can keep track of the farthest reached antidiagonal by each wavefront. If the most advanced antidiagonal reached by the forward and reverse wavefronts do not overlap (<italic toggle="yes">ANTIDIAG()</italic> on Algorithm 1), it follows that no offsets from any diagonal can overlap, rendering the call to <italic toggle="yes">WF_OVERLAP()</italic> unnecessary.</p>
    </sec>
    <sec>
      <title>2.4 Correctness of the breakpoint detection</title>
      <p>The correctness of the Algorithm 1 stems from the following lemma.<statement id="mthst1"><label>Lemma 2.1.</label><p><italic toggle="yes">The optimal alignment score</italic> <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">if and only if there exist</italic> <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">and k such that</italic> <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and at least one of the following is true:</italic><list list-type="order"><list-item><p><inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula><italic toggle="yes">and</italic> <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">→</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p></list-item></list><italic toggle="yes">and further</italic>, <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">(resp.</italic> <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">I</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="script" class="calligraphy">D</mml:mi><mml:mo stretchy="false">←</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic toggle="yes">) is included in the traceback of an alignment with score at most s if the first (resp. second, third) condition is true</italic><bold>.</bold></p><p><bold><italic toggle="yes">Proof.</italic></bold></p><p>See <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref>.</p><p><inline-graphic xlink:href="btad074ilf2.jpg"/></p><p>This lemma implies that the minimum value s for which the ‘only if’ condition holds is the optimal score. Moreover, if the first of the three conditions is found to hold for some values <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">opt</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:math></inline-formula>. Therefore, Algorithm 1 is guaranteed to find part of a minimum-scoring alignment based on the following features:
<list list-type="bullet"><list-item><p>Algorithm 2 checks a window of <italic toggle="yes">p</italic> score values on each iteration.</p></list-item><list-item><p>Algorithm 1 iterates through alternatingly increasing values of <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, detecting breakpoints with scores of at least <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mi>o</mml:mi><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> in each iteration.</p></list-item><list-item><p>After finding some <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that satisfy the overlap condition, Algorithm 1 continues for additional iterations until it is no longer possible to find a lower score.</p></list-item></list></p></statement></p>
    </sec>
    <sec>
      <title>2.5 Combining breakpoints into an alignment</title>
      <p>Algorithm 3 shows how to use BiWFA to recursively split alignments into smaller subproblems until the remaining alignment can be trivially solved.</p>
      <p>Note that a breakpoint computed by BiWFA can be found on the I or D components. Thus, those alignments that connect with this breakpoint have to start or end at the given component. This way, Algorithm 3 considers the starting and ending component of each alignment, and forces the underlying WFAs to use different initial conditions depending on the alignment starting at the <italic toggle="yes">M</italic> (<inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">X</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>), I (<inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) or <italic toggle="yes">D</italic> component (<inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>). A similar argument applies to the ending conditions of each alignment ending at the <italic toggle="yes">M</italic> (<inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>), <italic toggle="yes">I</italic> (<inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">I</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>) or <italic toggle="yes">D</italic> component (<inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script" class="calligraphy">D</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>).</p>
    </sec>
    <sec>
      <title>2.6 BiWFA uses <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space and <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time</title>
      <p>The memory complexity of Algorithm 1 is relatively simple to characterize. The range of diagonal values <italic toggle="yes">k</italic> increases by at most two every time <italic toggle="yes">s</italic> is incremented, and each forward and reverse search only needs to store the last <italic toggle="yes">p</italic> wavefronts. Thus, the memory use is proportional to the optimal alignment score, <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, excluding the storage of the input sequences. Also, note that the output alignment only requires storing the position <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for the mismatches, insertions and deletions (matches can be inferred from the gaps). Concerning Algorithm 3, data structures are discarded before entering a recursive call. Therefore, the maximum memory use occurs in the outermost call, in which s is the optimal score of the full alignment.</p>
      <p>
        <inline-graphic xlink:href="btad074ilf3.jpg"/>
      </p>
      <p>The time complexity is more complicated to analyze. Our proof follows similar arguments as those from <xref rid="btad074-B20" ref-type="bibr">Myers (1986)</xref>.<statement id="mthst2"><label>Theorem 2.2.</label><p><italic toggle="yes">BiWFA’s time complexity is</italic> <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic toggle="yes">, being n and m the sequences’ length and s the optimal alignment score.</italic></p><p><italic toggle="yes">Proof.</italic></p><p>Let <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, and let <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be BiWFA’s execution time with score <italic toggle="yes">s</italic>. A call to BiWFA can result in two recursive calls. Let <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the combined length of the sequences in the two calls, and similarly let <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> be the two alignment scores. Following Lemma 2.1, we know that these variables obey the following inequalities:
<list list-type="bullet"><list-item><p><inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item></list></p><p>Because each direction of WFA executes in <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>), we can choose a constant <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> large enough that the following inequality holds for all <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>We can also choose a constant <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> large enough that for all <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula><disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></disp-formula></p><p>This follows because the recursion depth depends only on <italic toggle="yes">s</italic>, which we have given an upper bound. Therefore, this term includes a bounded number of calls that all have linear dependence on <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>.</p></statement></p>
      <p>Next, we argue that <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> by induction on <italic toggle="yes">s</italic>. The base cases for <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> follow trivially from the latter of the previous inequalities. Assume then that <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>3</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> and the induction hypothesis holds for <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Note that we then have <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>≤</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, else either <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. Thus,
<disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>T</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>f</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>s</mml:mi><mml:mo>/</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>≤</mml:mo><mml:mn>3</mml:mn><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mi>s</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mi>ℓ</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>This proves the claim.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We implement the BiWFA algorithm described in this work in C. The code and the scripts required to reproduce the experimental results presented in this section are publicly available and can be found at <ext-link xlink:href="https://github.com/smarco/BiWFA-paper" ext-link-type="uri">https://github.com/smarco/BiWFA-paper</ext-link>. Moreover, the code has been integrated into the WFA2-lib alignment library (as ultralow memory mode) at <ext-link xlink:href="https://github.com/smarco/WFA2-lib" ext-link-type="uri">https://github.com/smarco/WFA2-lib</ext-link>.</p>
    <sec>
      <title>3.1 Experimental setup</title>
      <p>We evaluate the performance of our BiWFA implementation compared to the state-of-the-art and other high-performance sequence alignment libraries. We select the original WFA (<xref rid="btad074-B17" ref-type="bibr">Marco-Sola <italic toggle="yes">et al.</italic>, 2021</xref>) (wfa-high) and its new low-memory modes (wfa-med and wfa-low) implemented in WFA2-lib (<ext-link xlink:href="https://github.com/smarco/WFA2-lib" ext-link-type="uri">https://github.com/smarco/WFA2-lib</ext-link>). Also, we select the efficient wfalm (<xref rid="btad074-B6" ref-type="bibr">Eizenga and Paten, 2022</xref>) (wfalm) and its low-memory modes (wfalm-low and wfalm-rec). Moreover, we include the highly optimized KSW2-Z2 (ksw2_extz2_sse), from the KSW2 library (<xref rid="btad074-B14" ref-type="bibr">Li, 2018</xref>; <xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>), as the best representative of DP-based methods due to its exceptional performance and widely usage within bioinformatics tools. In addition, we include the Edlib (<xref rid="btad074-B28" ref-type="bibr">Šošić and Šikić, 2017</xref>) and BitPal (<xref rid="btad074-B15" ref-type="bibr">Loving <italic toggle="yes">et al.</italic>, 2014</xref>) libraries, which implement bit-parallel alignment strategies for edit and non-unitary penalties (i.e. gap-linear), respectively. Although they solve a considerably easier problem (i.e. Edlib is restricted to edit-alignments and BitPal only computes the alignment score), and thus are not directly comparable, we included them in the evaluation to provide a performance upper bound.</p>
      <p>We considered including other popular methods like those implemented in the Parasail (<xref rid="btad074-B4" ref-type="bibr">Daily <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btad074-B3" ref-type="bibr">Daily, 2016</xref>; <xref rid="btad074-B7" ref-type="bibr">Farrar, 2007</xref>; <xref rid="btad074-B31" ref-type="bibr">Wozniak, 1997</xref>), SeqAn (<xref rid="btad074-B23" ref-type="bibr">Rahn <italic toggle="yes">et al.</italic>, 2018</xref>) and Gaba (<xref rid="btad074-B30" ref-type="bibr">Suzuki and Kasahara, 2018</xref>) libraries. However, these libraries were not designed to align long and noisy sequences, and failed to complete the executions. Therefore these methods were discarded from the evaluation.</p>
      <p>All the presented methods have been configured to generate global alignments. These algorithms are grouped in two categories: ‘Gap-affine Exact’ for exact algorithms that use gap-affine penalties (i.e. BiWFA, WFA and its low-memory modes, wfalm and its low-memory modes and KSW2-Z2), and ‘Others’ for methods that use simpler penalty models or can only compute the alignment score (i.e. Edlib and BitPal).</p>
      <p>For the evaluation, we use simulated and real datasets. For the simulated datasets, we simulate several datasets of various sequence lengths (i.e. 100K, 500K, 1M and 2M bases) and different error rate (i.e. <italic toggle="yes">e </italic>=<italic toggle="yes"> </italic>10% and 20%) randomly generated. Regarding the evaluation with real datasets, we use a first set of sequences generated by the Human Pangenome Reference Consortium (<xref rid="btad074-B19" ref-type="bibr">Miga and Wang, 2021</xref>), consisting of long reads sequenced using Oxford Nanopore Technologies (ONT), PromethION platform, with an average error rate of 5–10%. The sequences are derived from the human cell line HG002, subset to chromosome 12 and restricted to those at least 10 kbp long, for a total number of 1312 sequence pairs of average length equal to 172<italic toggle="yes"> </italic>kbp (maximum ∼306<italic toggle="yes"> </italic>kbp). In addition, we use a second dataset comprising ONT MinION reads from <xref rid="btad074-B2" ref-type="bibr">Bowden <italic toggle="yes">et al.</italic> (2019)</xref>, with an average error rate of 5% and restricted to those at least 500<italic toggle="yes"> </italic>kbp long, for a total number of 48 sequence pairs of average length equal to 630<italic toggle="yes"> </italic>kbp (maximum ∼1<italic toggle="yes"> </italic>Mbp).</p>
      <p>All the executions are performed single-thread on a node running CentOS Linux (release 8.1.1911) equipped with an AMD EPYC 7742 CPU and 1 TB of DRAM (distributed in 16<italic toggle="yes"> </italic>dimms<italic toggle="yes"> </italic>×<italic toggle="yes"> </italic>64<italic toggle="yes"> </italic>GiB @3200<italic toggle="yes"> </italic>MHz).</p>
    </sec>
    <sec>
      <title>3.2 Evaluation on simulated data</title>
      <p><xref rid="btad074-T1" ref-type="table">Table 1</xref> shows the performance results (i.e. execution time and memory) for the different methods using simulated datasets. Overall, the results show that BiWFA is faster and uses less memory than all other methods in the ‘Gap-affine Exact’ category. In particular, BiWFA requires <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mn>32</mml:mn><mml:mo>−</mml:mo><mml:mn>1000</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory than KSW2-Z2, while being <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.4</mml:mn><mml:mo>−</mml:mo><mml:mn>4.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. Compared to original WFA-based methods (i.e. WFA-high and wfalm), BiWFA uses <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mn>9</mml:mn><mml:mo>−</mml:mo><mml:mn>9620</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory, being up to <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mn>4.4</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. Similarly, BiWFA outperforms the other memory-efficient WFA-based methods (i.e. WFA-med, WFA-low, wfalm-low and wfalm-rec), reducing memory requirements down to <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mrow><mml:mn>438</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> while being <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mn>2.7</mml:mn><mml:mo>−</mml:mo><mml:mn>26.5</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster. More importantly, most of the pairwise alignment methods evaluated fail to scale megabases-long sequences, requiring more memory than available in the node (i.e. 1TB). As opposed, BiWFA only requires a few hundred MBs of memory. Note that, computing the full alignment (BiWFA) requires a similar amount of memory as computing only the alignment score (BiWFA.score). Nonetheless, computing the alignment score is <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than computing the full alignment.</p>
      <table-wrap position="float" id="btad074-T1">
        <label>Table 1.</label>
        <caption>
          <p>Time and memory performance of pairwise alignment implementations on simulated data</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="8" rowspan="1">Time (s)<hr/></th>
              <th colspan="8" align="left" rowspan="1">Memory (MBs)<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th colspan="2" rowspan="1">10<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" rowspan="1">100<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" rowspan="1">1<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" rowspan="1">2<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">10<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">100<italic toggle="yes"> </italic>Kbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">1<italic toggle="yes"> </italic>Mbp<hr/></th>
              <th colspan="2" align="left" rowspan="1">2<italic toggle="yes"> </italic>Mbp<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1"/>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
              <th rowspan="1" colspan="1">10%</th>
              <th rowspan="1" colspan="1">20%</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">edlib</td>
              <td rowspan="1" colspan="1">0.4</td>
              <td rowspan="1" colspan="1">0.6</td>
              <td rowspan="1" colspan="1">2.5</td>
              <td rowspan="1" colspan="1">4.5</td>
              <td rowspan="1" colspan="1">17.9</td>
              <td rowspan="1" colspan="1">35.3</td>
              <td rowspan="1" colspan="1">35.4</td>
              <td rowspan="1" colspan="1">69.1</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">22</td>
              <td rowspan="1" colspan="1">23</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">bitpal</td>
              <td rowspan="1" colspan="1">1.3</td>
              <td rowspan="1" colspan="1">1.2</td>
              <td rowspan="1" colspan="1">12.3</td>
              <td rowspan="1" colspan="1">12.3</td>
              <td rowspan="1" colspan="1">123.8</td>
              <td rowspan="1" colspan="1">123.7</td>
              <td rowspan="1" colspan="1">248.0</td>
              <td rowspan="1" colspan="1">247.1</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">13</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">ksw2-extz2</td>
              <td rowspan="1" colspan="1">9.8</td>
              <td rowspan="1" colspan="1">9.9</td>
              <td rowspan="1" colspan="1">96.7</td>
              <td rowspan="1" colspan="1">97.5</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">193</td>
              <td rowspan="1" colspan="1">196</td>
              <td rowspan="1" colspan="1">19 081</td>
              <td rowspan="1" colspan="1">19 083</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-high</td>
              <td rowspan="1" colspan="1">
                <bold>2.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5.7</bold>
              </td>
              <td rowspan="1" colspan="1">28.5</td>
              <td rowspan="1" colspan="1">84.1</td>
              <td rowspan="1" colspan="1">312.9</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">128</td>
              <td rowspan="1" colspan="1">313</td>
              <td rowspan="1" colspan="1">8981</td>
              <td rowspan="1" colspan="1">26 667</td>
              <td rowspan="1" colspan="1">932 199</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-med</td>
              <td rowspan="1" colspan="1">6.6</td>
              <td rowspan="1" colspan="1">20.2</td>
              <td rowspan="1" colspan="1">89.5</td>
              <td rowspan="1" colspan="1">272.8</td>
              <td rowspan="1" colspan="1">1922.1</td>
              <td rowspan="1" colspan="1">3690.1</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">35</td>
              <td rowspan="1" colspan="1">81</td>
              <td rowspan="1" colspan="1">830</td>
              <td rowspan="1" colspan="1">1620</td>
              <td rowspan="1" colspan="1">42 464</td>
              <td rowspan="1" colspan="1">24 874</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">WFA-low</td>
              <td rowspan="1" colspan="1">8.0</td>
              <td rowspan="1" colspan="1">24.1</td>
              <td rowspan="1" colspan="1">101.4</td>
              <td rowspan="1" colspan="1">301.1</td>
              <td rowspan="1" colspan="1">4394.9</td>
              <td rowspan="1" colspan="1">4857.0</td>
              <td rowspan="1" colspan="1">7710.2</td>
              <td rowspan="1" colspan="1">9813.1</td>
              <td rowspan="1" colspan="1">25</td>
              <td rowspan="1" colspan="1">60</td>
              <td rowspan="1" colspan="1">554</td>
              <td rowspan="1" colspan="1">884</td>
              <td rowspan="1" colspan="1">25 321</td>
              <td rowspan="1" colspan="1">12 539</td>
              <td rowspan="1" colspan="1">52 551</td>
              <td rowspan="1" colspan="1">26 067</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm</td>
              <td rowspan="1" colspan="1">6.4</td>
              <td rowspan="1" colspan="1">19.2</td>
              <td rowspan="1" colspan="1">90.2</td>
              <td rowspan="1" colspan="1">268.7</td>
              <td rowspan="1" colspan="1">841.0</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">54</td>
              <td rowspan="1" colspan="1">148</td>
              <td rowspan="1" colspan="1">8968</td>
              <td rowspan="1" colspan="1">26 575</td>
              <td rowspan="1" colspan="1">898 770</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
              <td rowspan="1" colspan="1">n/a</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm-low</td>
              <td rowspan="1" colspan="1">10.1</td>
              <td rowspan="1" colspan="1">30.4</td>
              <td rowspan="1" colspan="1">164.1</td>
              <td rowspan="1" colspan="1">494.8</td>
              <td rowspan="1" colspan="1">1525.1</td>
              <td rowspan="1" colspan="1">4418.7</td>
              <td rowspan="1" colspan="1">2990.1</td>
              <td rowspan="1" colspan="1">8779.4</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">443</td>
              <td rowspan="1" colspan="1">823</td>
              <td rowspan="1" colspan="1">10 435</td>
              <td rowspan="1" colspan="1">30 817</td>
              <td rowspan="1" colspan="1">36 299</td>
              <td rowspan="1" colspan="1">69 312</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">wfalm-rec</td>
              <td rowspan="1" colspan="1">22.3</td>
              <td rowspan="1" colspan="1">70.7</td>
              <td rowspan="1" colspan="1">447.5</td>
              <td rowspan="1" colspan="1">1402.6</td>
              <td rowspan="1" colspan="1">5792.7</td>
              <td rowspan="1" colspan="1">17 752.9</td>
              <td rowspan="1" colspan="1">11 979.6</td>
              <td rowspan="1" colspan="1">37 747.7</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">43</td>
              <td rowspan="1" colspan="1">73</td>
              <td rowspan="1" colspan="1">497</td>
              <td rowspan="1" colspan="1">904</td>
              <td rowspan="1" colspan="1">1064</td>
              <td rowspan="1" colspan="1">1787</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BiWFA</td>
              <td rowspan="1" colspan="1">2.4</td>
              <td rowspan="1" colspan="1">6.9</td>
              <td rowspan="1" colspan="1">
                <bold>20.8</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>61.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>218.3</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>680.4</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>466.9</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1429.0</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>6</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>5</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>19</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>27</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>97</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>180</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>202</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>267</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">BiWFA.score</td>
              <td rowspan="1" colspan="1">1.1</td>
              <td rowspan="1" colspan="1">3.1</td>
              <td rowspan="1" colspan="1">10.2</td>
              <td rowspan="1" colspan="1">30.2</td>
              <td rowspan="1" colspan="1">112.2</td>
              <td rowspan="1" colspan="1">355.8</td>
              <td rowspan="1" colspan="1">245.4</td>
              <td rowspan="1" colspan="1">750.2</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">97</td>
              <td rowspan="1" colspan="1">186</td>
              <td rowspan="1" colspan="1">204</td>
              <td rowspan="1" colspan="1">256</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: Execution time (in seconds) and memory (in MBs) required per 1M bases aligned, using different pairwise alignment implementations on simulated datasets. Executions that failed appear as ‘n/a’. Best performing implementation in the ‘Gap-affine Exact’ category is marked in bold. Although Edlib and BitPal are not directly comparable to the other implementations, we included them in the comparison as a reference. Similarly, we include executions of BiWFA limited to compute the alignment score as ‘BiWFA.score’.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>For completeness, we present a comprehensive experimental evaluation on a wider range of sequence lengths (i.e. 100 bp, 1 Kbp, 10 Kbp, 100 Kbp, 1 Mbp and 2 Mbp) and error rates (0.1%, 1%, 5%, 10%, 20% and 40%) on <xref rid="sup1" ref-type="supplementary-material">Supplementary Material</xref> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1 and S2</xref>). For short sequences (i.e. ≤1 Kbp), the results show that BiWFA delivers similar performance as the original WFA (<inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.25</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> slower) while reducing the memory requirements up to <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mn>60</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>. Our experiments indicate that BiWFA starts outperforming the original WFA when aligning sequences longer than ∼30 Kbp. Nevertheless, the exact performance breakpoint can vary depending on the error rate, implementation and processor specifics. Similarly, for smaller error rates (i.e. <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mo>≤</mml:mo></mml:math></inline-formula>1%), WFA-based methods largely outperform other approaches, being <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> orders of magnitude faster than other methods like KSW2-Z2, bitpal and edlib. In addition, for low error rates, memory-efficient WFA-based methods require a minimal amount of memory.</p>
    </sec>
    <sec>
      <title>3.3 Evaluation on real data</title>
      <p><xref rid="btad074-F2" ref-type="fig">Figure 2</xref> shows the performance results obtained for all the evaluated algorithms in terms of execution time and consumed memory. BiWFA uses many times less memory than other methods. In particular, when aligning ultra-long ONT sequences (<xref rid="btad074-F2" ref-type="fig">Fig. 2B</xref>), BiWFA requires between <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mn>68</mml:mn><mml:mo>−</mml:mo><mml:mn>93</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory compared to wfalm and WFA low-memory modes. Furthermore, BiWFA uses 3.5<inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mo>×</mml:mo></mml:math></inline-formula> less memory compared to the efficient recursive mode from wfalm (most memory-efficient gap-affine algorithm to date).</p>
      <fig position="float" id="btad074-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Experimental results from the execution of BiWFA and other state-of-the-art implementations aligning long sequences. Figure shows (<bold>A</bold>) memory consumption and (<bold>B</bold>) execution time per sequence aligned. A vertical line on each panel separates algorithms that use simpler penalty models or can only compute the alignment score (i.e. edlib and bitpal) from those that compute the full gap-affine alignment</p>
        </caption>
        <graphic xlink:href="btad074f2" position="float"/>
      </fig>
      <p>At the same time, BiWFA proves to be one of the fastest implementations aligning long sequences. Using ultra-long sequences, our method is <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mn>25.7</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster than wfalm’s recursive mode. Moreover, BiWFA’s execution times are similar to those of BitPal (sometimes even faster, <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mn>1.1</mml:mn><mml:mo>−</mml:mo><mml:mn>1.28</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> faster on average) computing exact alignments (not just the score) under the gap-affine model.</p>
      <p>For completeness, <xref rid="sup1" ref-type="supplementary-material">Supplementary Figure S1</xref> shows experimental results limited to aligning sequences up to 10<italic toggle="yes"> </italic>Kbps. In this scenario, BiWFA demonstrates to be one of the fastest implementations, requiring less than 10<italic toggle="yes"> </italic>MB to execute.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>As long sequencing technologies improve and high-quality sequence assembly decreases in cost, we anticipate that the importance of pairwise alignment algorithm will continue to increase. To keep up with upcoming improvements in sequencing and genomics, pairwise alignment algorithms need to face crucial challenges in reducing execution time and memory consumption. In this work, we have presented the BiWFA, a gap-affine pairwise alignment algorithm that requires <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space, being the first algorithm to improve the long standing space lower bound of <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The BiWFA answers the pressing need for sequence alignment methods capable to scaling to genome-scale alignments and full pangenomes.</p>
    <p>Most notably, BiWFA execution times are very similar, or even better, than those of the original WFA (despite BiWFA requiring <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mn>2954</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mn>607</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula> less memory when aligning ultra-long MinION and PromethION sequences, respectively). This result can be better understood considering the memory inefficiencies that the original WFA experiences when using a large memory footprint. As the sequence’s length and error increases, the original WFA uses a substantially larger memory footprint, putting a significant pressure on the memory hierarchy of the processor. Due to the pervasive memory inefficiencies of modern processors executing memory intensive applications, the original WFA’s performance is severely deteriorated when aligning long sequence datasets (like those from Nanopore presented in the evaluation). In contrast, BiWFA relieves this memory pressure using a minimal memory footprint. As a result, BiWFA is able to balance out the additional work induced by BiWFA’s recursion, delivering a performance on-par with the original WFA.</p>
    <p>We have presented the BiWFA using gap-affine penalties. Nevertheless, these very same ideas can be translated directly into other distances like edit, linear gap or piecewise gap-affine. Moreover, it can be easily extended to semi-global alignment (a.k.a. ends-free, glocal, extension or overlapped alignment) by modifying the initial conditions and termination criterion. At the same time, the BiWFA retains the strengths of the original WFA: no restrictions on the sequences’ alphabet, preprocessing steps, nor prior estimation of the alignment error.</p>
    <p>Due to the simplicity of the WFA’s computational pattern, BiWFA’s core functions can be easily vectorized to fully exploit the capabilities of modern SIMD multicore processors. Our implementation, relies on the automatic vectorization capabilities of modern compilers. As a result, the BiWFA implementation can exploit the SIMD capabilities of any processor supported by modern compilers, without rewriting any part of the source code.</p>
    <p>Genomics and bioinformatics methods will continue to rely on sequence alignment as a core and critical component. BiWFA paves the way for the development of faster and more accurate tools that can scale with longer and noisy sequences using a minimal amount of memory. In this way, we expect BiWFA to enable efficient sequence alignment at genome-scale in years to come.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad074_Supplementary_Data</label>
      <media xlink:href="btad074_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors thank Ragnar Groot Koerkamp and the anonymous reviewers for making useful suggestions and contributing to improving the manuscript.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This research was supported by the European Union Regional Development Fund within the framework of the ERDF Operational Program of Catalonia 2014-2020 with a grant of 50% of total cost eligible under the DRAC project [001-P-001723] and Lenovo-BSC Contract-Framework Contract (2022). It was also supported by the Ministerio de Ciencia e Innovacion MCIN AEI/10.13039/501100011033 and NextGenerationEU/PRTR under contracts PID2020-113614RB-C21, PID2019-107255GB-C21, and TED2021-132634A-I00, by the Generalitat de Catalunya GenCat-DIUiE (GRR) [contracts 2017-SGR-313, 2017-SGR-1328 and 2017-SGR-1414]. M.M. was partially supported by the Spanish Ministry of Economy, Industry and Competitiveness under Ramon y Cajal fellowship number RYC-2016-21104. S.M.-S. was supported by Juan de la Cierva fellowship grant IJC2020-045916-I funded by MCIN/AEI/10.13039/501100011033 and by ‘European Union NextGenerationEU/PRTR’. B.P. and J.M.E. were supported, in part, by the United States National Institutes of Health [award numbers: R01HG010485, U01HG010961, OT2OD026682, OT3HL142481 and U24HG011853]. E.G. was supported by NIH/NIDA U01DA047638 and NSF PPoSS Award #2118709. A.G. acknowledges Dr. Nicole Soranzo’s efforts to establish a pangenome research unit at the Human Technopole in Milan, Italy.</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad074-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>1990</year>) <article-title>Basic local alignment search tool</article-title>. <source>J. Mol. Biol</source>., <volume>215</volume>, <fpage>403</fpage>–<lpage>410</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bowden</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Sequencing of human genomes with nanopore technology</article-title>. <source>Nat. Commun</source>., <volume>10</volume>, <fpage>1869</fpage>.<pub-id pub-id-type="pmid">31015479</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group> (<year>2016</year>) <article-title>Parasail: SIMD C library for global, semi-global, and local pairwise sequence alignments</article-title>. <source>BMC Bioinf</source>., <volume>17</volume>, <fpage>1</fpage>–<lpage>11</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Daily</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>A work stealing based approach for enabling scalable optimal sequence homology detection</article-title>. <source>J. Parallel Distributed Comput</source>., <volume>79</volume>, <fpage>132</fpage>–<lpage>142</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>1998</year>) <source>Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids</source>. <publisher-name>Cambridge University Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btad074-B6">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Eizenga</surname><given-names>J.M.</given-names></string-name>, <string-name><surname>Paten</surname><given-names>B.</given-names></string-name></person-group> (<year>2022</year>) Improving the time and space complexity of the WFA algorithm and generalizing its scoring. <italic toggle="yes">bioRxiv</italic>.</mixed-citation>
    </ref>
    <ref id="btad074-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Farrar</surname><given-names>M.</given-names></string-name></person-group> (<year>2007</year>) <article-title>Striped Smith–Waterman speeds database searches six times over other SIMD implementations</article-title>. <source>Bioinformatics</source>, <volume>23</volume>, <fpage>156</fpage>–<lpage>161</lpage>.<pub-id pub-id-type="pmid">17110365</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B8">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Garrison</surname><given-names>E.</given-names></string-name>, <string-name><surname>Marth</surname><given-names>G.</given-names></string-name></person-group> (<year>2012</year>) Haplotype-based variant detection from short-read sequencing. <italic toggle="yes">arXiv preprint arXiv:1207.3907.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Gotoh</surname><given-names>O.</given-names></string-name></person-group> (<year>1982</year>) <article-title>An improved algorithm for matching biological sequences</article-title>. <source>J. Mol. Biol</source>., <volume>162</volume>, <fpage>705</fpage>–<lpage>708</lpage>.<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B10">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Jones</surname><given-names>N.</given-names></string-name></person-group><etal>et al</etal> (<year>2004</year>) <source>An Introduction to Bioinformatics Algorithms</source>. <publisher-name>MIT Press</publisher-name>, <publisher-loc>Cambridge</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btad074-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kiełbasa</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>Adaptive seeds tame genomic sequence comparison</article-title>. <source>Genome Res</source>., <volume>21</volume>, <fpage>487</fpage>–<lpage>493</lpage>.<pub-id pub-id-type="pmid">21209072</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koren</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>CANU: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>722</fpage>–<lpage>736</lpage>.<pub-id pub-id-type="pmid">28298431</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B13">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2013</year>) Aligning sequence reads, clone sequences and assembly contigs with bwa-mem. <italic toggle="yes">arXiv preprint arXiv:1303.3997.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3094</fpage>–<lpage>3100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Loving</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2014</year>) <article-title>BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</article-title>. <source>Bioinformatics</source>, <volume>30</volume>, <fpage>3166</fpage>–<lpage>3173</lpage>.<pub-id pub-id-type="pmid">25075119</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2012</year>) <article-title>The gem mapper: fast, accurate and versatile alignment by filtration</article-title>. <source>Nat. Methods</source>, <volume>9</volume>, <fpage>1185</fpage>–<lpage>1188</lpage>.<pub-id pub-id-type="pmid">23103880</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marco-Sola</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Fast gap-affine pairwise alignment using the wavefront algorithm</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>456</fpage>–<lpage>463</lpage>.<pub-id pub-id-type="pmid">32915952</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>McKenna</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2010</year>) <article-title>The genome analysis toolkit: a mapreduce framework for analyzing next-generation DNA sequencing data</article-title>. <source>Genome Res</source>., <volume>20</volume>, <fpage>1297</fpage>–<lpage>1303</lpage>.<pub-id pub-id-type="pmid">20644199</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Miga</surname><given-names>K. H.</given-names></string-name>, <string-name><surname>Wang</surname><given-names>T.</given-names></string-name></person-group> (<year>2021</year>) <article-title>The need for a human pangenome reference sequence</article-title>. <source>Annu. Rev. Genomics Hum. Genet</source>., <volume>22</volume>, <fpage>81</fpage>–<lpage>102</lpage>.<pub-id pub-id-type="pmid">33929893</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E. W.</given-names></string-name></person-group> (<year>1986</year>) <article-title>An <italic toggle="yes">O</italic>(<italic toggle="yes">ND</italic>) difference algorithm and its variations</article-title>. <source>Algorithmica</source>, <volume>1</volume>, <fpage>251</fpage>–<lpage>266</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>E. W.</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W.</given-names></string-name></person-group> (<year>1988</year>) <article-title>Optimal alignments in linear space</article-title>. <source>Bioinformatics</source>, <volume>4</volume>, <fpage>11</fpage>–<lpage>17</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Needleman</surname><given-names>S. B.</given-names></string-name>, <string-name><surname>Wunsch</surname><given-names>C. D.</given-names></string-name></person-group> (<year>1970</year>) <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>. <source>J. Mol. Biol</source>., <volume>48</volume>, <fpage>443</fpage>–<lpage>453</lpage>.<pub-id pub-id-type="pmid">5420325</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rahn</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Generic accelerated sequence alignment in seqan using vectorization and multi-threading</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3437</fpage>–<lpage>3445</lpage>.<pub-id pub-id-type="pmid">29726911</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rodríguez-Martín</surname><given-names>B.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>Chimpipe: accurate detection of fusion genes and transcription-induced chimeras from RNA-seq data</article-title>. <source>BMC Genomics</source>, <volume>18</volume>, <fpage>7</fpage>–<lpage>17</lpage>.<pub-id pub-id-type="pmid">28049418</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rognes</surname><given-names>T.</given-names></string-name>, <string-name><surname>Seeberg</surname><given-names>E.</given-names></string-name></person-group> (<year>2000</year>) <article-title>Six-fold speed-up of Smith–Waterman sequence database searches using parallel processing on common microprocessors</article-title>. <source>Bioinformatics</source>, <volume>16</volume>, <fpage>699</fpage>–<lpage>706</lpage>.<pub-id pub-id-type="pmid">11099256</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Simpson</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2009</year>) <article-title>ABYSS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>., <volume>19</volume>, <fpage>1117</fpage>–<lpage>1123</lpage>.<pub-id pub-id-type="pmid">19251739</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Smith</surname><given-names>T. F.</given-names></string-name>, <string-name><surname>Waterman</surname><given-names>M. S.</given-names></string-name></person-group> (<year>1981</year>) <article-title>Comparison of biosequences</article-title>. <source>Adv. Appl. Math</source>., <volume>2</volume>, <fpage>482</fpage>–<lpage>489</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Šošić</surname><given-names>M.</given-names></string-name>, <string-name><surname>Šikić</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) <article-title>EDLIB: a C/C++ library for fast, exact sequence alignment using edit distance</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>1394</fpage>–<lpage>1395</lpage>.<pub-id pub-id-type="pmid">28453688</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B29">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2017</year>) Acceleration of nucleotide semi-global alignment with adaptive banded dynamic programming. <italic toggle="yes">bioRxiv.</italic></mixed-citation>
    </ref>
    <ref id="btad074-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Suzuki</surname><given-names>H.</given-names></string-name>, <string-name><surname>Kasahara</surname><given-names>M.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Introducing difference recurrence relations for faster semi-global alignment of long sequences</article-title>. <source>BMC Bioinformatics</source>, <volume>19</volume>, <fpage>33</fpage>–<lpage>47</lpage>.<pub-id pub-id-type="pmid">29402212</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wozniak</surname><given-names>A.</given-names></string-name></person-group> (<year>1997</year>) <article-title>Using video-oriented instructions to speed up sequence comparison</article-title>. <source>Bioinformatics</source>, <volume>13</volume>, <fpage>145</fpage>–<lpage>150</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Xia</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>A review of parallel implementations for the Smith–Waterman algorithm</article-title>. In: <source>Interdisciplinary Sciences: Computational Life Sciences</source>, pp. <fpage>1</fpage>–<lpage>14</lpage>.</mixed-citation>
    </ref>
    <ref id="btad074-B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhang</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2000</year>) <article-title>A greedy algorithm for aligning DNA sequences</article-title>. <source>J. Comput. Biol</source>., <volume>7</volume>, <fpage>203</fpage>–<lpage>214</lpage>.<pub-id pub-id-type="pmid">10890397</pub-id></mixed-citation>
    </ref>
    <ref id="btad074-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhao</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2013</year>) <article-title>SSW library: an SIMD Smith–Waterman C/C++ library for use in genomic applications</article-title>. <source>PLoS ONE</source>, <volume>8</volume>, <fpage>e82138</fpage>.<pub-id pub-id-type="pmid">24324759</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
