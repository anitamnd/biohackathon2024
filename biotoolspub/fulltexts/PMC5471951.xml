<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5471951</article-id>
    <article-id pub-id-type="publisher-id">1658</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-017-1658-0</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A greedy alignment-free distance estimator for phylogenetic inference</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Thankachan</surname>
          <given-names>Sharma V.</given-names>
        </name>
        <address>
          <email>sharma.thankachan@ucf.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chockalingam</surname>
          <given-names>Sriram P.</given-names>
        </name>
        <address>
          <email>sriram.pc@iitb.ac.in</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Yongchao</given-names>
        </name>
        <address>
          <email>yliu860@gatech.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Krishnan</surname>
          <given-names>Ambujam</given-names>
        </name>
        <address>
          <email>krishnambujam@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff4">4</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Aluru</surname>
          <given-names>Srinivas</given-names>
        </name>
        <address>
          <email>aluru@cc.gatech.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2159 2859</institution-id><institution-id institution-id-type="GRID">grid.170430.1</institution-id><institution>Department of Computer Science, </institution><institution>University of Central Florida, </institution></institution-wrap>Orlando, 32816 FL USA </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2097 4943</institution-id><institution-id institution-id-type="GRID">grid.213917.f</institution-id><institution>Institute for Data Engineering and Science, </institution><institution>Georgia Institute of Technology, </institution></institution-wrap>Atlanta, 30332 GA USA </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2097 4943</institution-id><institution-id institution-id-type="GRID">grid.213917.f</institution-id><institution>School of Computational Science and Engineering, </institution><institution>Georgia Institute of Technology, </institution></institution-wrap>Atlanta, 30332 GA USA </aff>
      <aff id="Aff4"><label>4</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 0662 7451</institution-id><institution-id institution-id-type="GRID">grid.64337.35</institution-id><institution>School of Electrical Engineering and Computer Science, </institution><institution>Louisiana State University, </institution></institution-wrap>Baton Rouge, 70703 LA USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>7</day>
      <month>6</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>7</day>
      <month>6</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2017</year>
    </pub-date>
    <volume>18</volume>
    <issue>Suppl 8</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. The Supplement Editors declare that they have no competing interests.</issue-sponsor>
    <elocation-id>238</elocation-id>
    <permissions>
      <copyright-statement>© The Author(s) 2017</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Alignment-free sequence comparison approaches have been garnering increasing interest in various data- and compute-intensive applications such as phylogenetic inference for large-scale sequences. While <italic>k</italic>-mer based methods are predominantly used in real applications, the average common substring (ACS) approach is emerging as one of the prominent alignment-free approaches. This ACS approach has been further generalized by some recent work, either greedily or exactly, by allowing a bounded number of mismatches in the common substrings.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We present ALFRED-G, a greedy alignment-free distance estimator for phylogenetic tree reconstruction based on the concept of the generalized ACS approach. In this algorithm, we have investigated a new heuristic to efficiently compute the lengths of common strings with mismatches allowed, and have further applied this heuristic to phylogeny reconstruction. Performance evaluation using real sequence datasets shows that our heuristic is able to reconstruct comparable, or even more accurate, phylogenetic tree topologies than the kmacs heuristic algorithm at highly competitive speed.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>ALFRED-G is an alignment-free heuristic for evolutionary distance estimation between two biological sequences. This algorithm is implemented in C++ and has been incorporated into our open-source ALFRED software package (<ext-link ext-link-type="uri" xlink:href="http://alurulab.cc.gatech.edu/phylo">http://alurulab.cc.gatech.edu/phylo</ext-link>).</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Alignment-free methods</kwd>
      <kwd>Sequence comparison</kwd>
      <kwd>Phylogeny reconstruction</kwd>
    </kwd-group>
    <conference xlink:href="http://www.iccabs.org/2015/">
      <conf-name>Fifth IEEE International Conference on Computational Advances in Bio and Medical Sciences (ICCABS 2015)</conf-name>
      <conf-loc>Miami, FL, USA</conf-loc>
      <conf-date>15-17 October 2015</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2017</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Accurate estimation of the evolutionary distance between two sequences is fundamental and critical to phylogenetic analysis aiming to reconstruct the correct evolutionary history and estimate the time of divergence between species. One popular approach to evolutionary distance estimation relies on sequence alignment. Typically, the pipeline for alignment-based phylogenetic inference generally works by three steps. Firstly, we perform all-to-all pairwise sequence alignment to gain a pairwise distance matrix for the input sequences. The evolutionary distance between two sequences in the matrix is typically inferred from an optimal alignment, e.g. equal to one minus percent identity in the optimal alignment. Secondly, we construct a guide tree from the pairwise distance matrix and then conduct progressive alignment of multiple sequences following the order determined by the guide tree. Finally, we infer a phylogenetic tree from the resulting multiple alignments using a tree inference program which can be distance-, parsimony-, bayesian, or likelihood-based. Nevertheless, it needs to be stressed that we could also choose to construct a phylogenetic tree directly from the pairwise distance matrix computed in the first step, using some distance-based tree construction algorithm such as unweighted pair group method with arithmetic mean (UPGMA) [<xref ref-type="bibr" rid="CR1">1</xref>] or neighbor-joining (NJ) [<xref ref-type="bibr" rid="CR2">2</xref>].</p>
    <p>Although they may have high accuracy, alignment-based approaches involve high computational cost, thus resulting in slow speed. This is because pairwise alignment using dynamic programming has a quadratic complexity with respect to sequence length. This is even more challenging when constructing the phylogenetic tree for a large number of sequences, especially long sequences (e.g. eukaryotic genomes). In this case, some research efforts have been devoted to accelerating the tree construction using high performance computing architectures [<xref ref-type="bibr" rid="CR3">3</xref>–<xref ref-type="bibr" rid="CR6">6</xref>]. In addition to acceleration, as an alternative to alignment-based approaches, alignment-free approaches emerge and become popular, mainly owing to their speed superiority. For instance, given a collection of <italic>d</italic> sequences of average length <italic>n</italic>, the time complexity for pairwise distance matrix computation can be as high as <italic>O</italic>(<italic>d</italic>
<sup>2</sup>
<italic>n</italic>
<sup>2</sup>) when using pairwise alignment. In contrast, by using alignment-free exact <italic>k</italic>-mer (a <italic>k</italic>-mer is a string of <italic>k</italic> characters) counting, the whole computation can be done in <italic>O</italic>(<italic>d</italic>
<sup>2</sup>
<italic>n</italic>) time, significantly reducing the run-time by a factor of <italic>n</italic>. Moreover, alignment-free approaches are capable of overcoming some difficulties, which challenge alignment-based approaches, such as genetic recombination and shuffling during the evolution process.</p>
    <p>A variety of alignment-free approaches have been proposed, most of which are based on the concept of sequence seeding that extracts fixed- or variable- length substrings from a given sequence. Based on fixed-length seeding, there are two kinds of alignment-free approaches: exact <italic>k</italic>-mer counting [<xref ref-type="bibr" rid="CR7">7</xref>] and spaced <italic>k</italic>-mer counting [<xref ref-type="bibr" rid="CR8">8</xref>]. For the exact <italic>k</italic>-mer counting approach, it builds a <italic>k</italic>-mer frequency (or occurrence) vector for each sequence and computes the pairwise distance using some distance measure based on the frequency vectors. Example distance measures include Euclidean distance [<xref ref-type="bibr" rid="CR9">9</xref>], Kullback-Lebler divergence [<xref ref-type="bibr" rid="CR10">10</xref>] and the one proposed by Edgar [<xref ref-type="bibr" rid="CR11">11</xref>]. The Edgar’s distance measure models the similarity between two sequences as the fraction of exact <italic>k</italic>-mers shared by them, and then computes the pairwise distance by subtracting the similarity value from one. This distance measure has been shown to be highly related to genetic distance and has been used in other applications like metagenomic sequence classification [<xref ref-type="bibr" rid="CR12">12</xref>]. For the spaced <italic>k</italic>-mer counting approach, it allows character mismatches between <italic>k</italic>-mers at some predefined positions and usually employs multiple pattern templates in order to improve accuracy.</p>
    <p>Based on variable-length seeding, there are three kinds of approaches: the average common substring (ACS) method [<xref ref-type="bibr" rid="CR13">13</xref>], the <italic>k</italic>-mismatch ACS (k-ACS) method [<xref ref-type="bibr" rid="CR14">14</xref>, <xref ref-type="bibr" rid="CR15">15</xref>] and the mutation distances (<italic>K</italic>
<sub><italic>r</italic></sub>) [<xref ref-type="bibr" rid="CR16">16</xref>]. The distance based on these methods can be computed using suffix trees/arrays. Given two sequences, the ACS method first calculates the length of the longest substring that starts at each position <italic>i</italic> in one sequence and matches some substring of the other sequence. Subsequently, it averages and normalizes all of the lengths computed to represent the similarity of the two sequences. Finally, the resulting similarity value is used to compute the pairwise distance. The time complexity of the ACS method is directly proportional to the sum of lengths of the two sequences.</p>
    <p>In contrast, the k-ACS method computes the pairwise distance by finding substring pairs with upto <italic>k</italic> mismatches, given two sequences. Specifically, instead of determining the longest common substrings, the k-ACS method aims to find the longest substring starting at each position in one sequence and matching some substring in the other sequence with upto <italic>k</italic> mismatches. The mutation distances is closely related to ACS, where the difference is only in the conversion from the similarity value to a pairwise distance.</p>
    <p>Unlike the ACS method, the solutions to the k-ACS method involves high computational cost. For example, an algorithm given by Leimeister and Morgenstern [<xref ref-type="bibr" rid="CR14">14</xref>] takes <italic>O</italic>(<italic>k</italic>
<italic>n</italic>
<sup>2</sup>) time in the worst case, which is certainty not a suitable replacement of alignment based methods. However, they proposed a faster algorithm, namely kmacs, that computes an approximation to k-ACS based distance. Another algorithm by Apostolico et al. runs in <italic>O</italic>(<italic>n</italic>
<sup>2</sup>/ log<italic>n</italic>) time [<xref ref-type="bibr" rid="CR17">17</xref>]. This raises an open question, whether the exact k-ACS based distance can be computed in strictly sub-quadratic time. Initial attempts were focused on the special case of <italic>k</italic>=1 [<xref ref-type="bibr" rid="CR18">18</xref>, <xref ref-type="bibr" rid="CR19">19</xref>]. Later, Aluru et al. [<xref ref-type="bibr" rid="CR15">15</xref>, <xref ref-type="bibr" rid="CR20">20</xref>] positively answered this question by presenting an algorithm with a worst case run time of <italic>O</italic>(<italic>n</italic> log<italic>k</italic>
<italic>n</italic>) for any constant <italic>k</italic>. The algorithm is much more complicated than the original ACS method and even the k-ACS approximation by [<xref ref-type="bibr" rid="CR14">14</xref>]. Moreover the practical variant of this algorithm can get quite slow for even moderately large values of <italic>k</italic> due to its exponential dependency on <italic>k</italic> [<xref ref-type="bibr" rid="CR21">21</xref>]. However, this algorithm has its merit as the first sub-quadratic time algorithm for exact k-ACS computation for any positive integer <italic>k</italic>. A recently proposed algorithm by Pizzi is based on filtering approaches [<xref ref-type="bibr" rid="CR22">22</xref>]. In summary, on one hand, we have a fast approximation algorithm [<xref ref-type="bibr" rid="CR14">14</xref>] and on the other hand, we have an exact (theoretical) algorithm [<xref ref-type="bibr" rid="CR15">15</xref>], that might work well for small values of <italic>k</italic> in practice. Inspired by both algorithms, we introduce a new <bold>g</bold>reedy heuristic for <bold>al</bold>ignment-<bold>fre</bold>e <bold>d</bold>istance estimation, named ALFRED-G. The heuristic is implemented in C++ and has been incorporated into our open-source ALFRED software package (<ext-link ext-link-type="uri" xlink:href="http://alurulab.cc.gatech.edu/phylo">http://alurulab.cc.gatech.edu/phylo</ext-link>).</p>
    <p>We use X and Y to denote the two sequences to be compared. The length of sequence X is denoted by |X|, its <italic>i</italic>th character by X[<italic>i</italic>], and the substring that starts at position <italic>i</italic> and ends at position <italic>j</italic> by X[<italic>i</italic>…<italic>j</italic>]. For brevity, we use X
<sub><italic>i</italic></sub> to denote the suffix of X starting at <italic>i</italic>. The total length of X and Y is denoted by <italic>n</italic>. A key data structure in our algorithm is the generalized suffix tree (<italic>GST</italic>). The <italic>GST</italic> of X and Y is a compact trie of all suffixes of X and Y. It consists of <italic>n</italic> leaves and at most <italic>n</italic>−1 internal nodes. Corresponding to each leaf, there is a unique suffix of X or Y. The edges are labeled with a sequence of characters. The <italic>string-depth</italic> of a node <italic>u</italic> is the length of the string obtained by concatenating the edge labels on the path from the root of <italic>GST</italic> to <italic>u</italic>. The space and the construction time of <italic>GST</italic> are <italic>O</italic>(<italic>n</italic>) [<xref ref-type="bibr" rid="CR23">23</xref>]. For any (<italic>i</italic>,<italic>j</italic>) pair, |<italic>LCP</italic>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)|, the length of the longest common prefix of X
<sub><italic>i</italic></sub> and Y
<sub><italic>j</italic></sub> is same as the string-depth of the lowest common ancestor node of the leaves corresponding to X
<sub><italic>i</italic></sub> and Y
<sub><italic>j</italic></sub>. Using <italic>GST</italic>, we can compute it in constant time. Also, we can compute |<italic>LCP</italic>
<sub><italic>k</italic></sub>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)|, the length of the longest common prefix of X
<sub><italic>i</italic></sub> and Y
<sub><italic>j</italic></sub> with first <italic>k</italic> mismatches ignored, in <italic>O</italic>(<italic>k</italic>) time as follows. Let <italic>z</italic>=|<italic>LCP</italic>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)|, then for any <italic>k</italic>≥1, 
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \left|\mathsf{LCP}_{k}\left(\mathsf{X}_{i}, \mathsf{Y}_{j}\right)\right| = z+1+\left|\mathsf{LCP}_{k-1}\left(\mathsf{X}_{i+z+1}, \mathsf{Y}_{j+z+1}\right)\right|  $$ \end{document}</tex-math><mml:math id="M2"><mml:mfenced close="|" open="|" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">LCP</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mfenced close="|" open="|" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">LCP</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>z</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:math><graphic xlink:href="12859_2017_1658_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>
</p>
    <sec id="Sec2">
      <title>Problem definition</title>
      <p>The <italic>k</italic>-mismatch average common substring of X w.r.t. Y, denoted by <italic>ACS</italic>
<sub><italic>k</italic></sub>(X,Y) is defined as the average of the length of the prefix of a suffix of X, that appears as a substring of Y within hamming distance <italic>k</italic>. Specifically, let <italic>λ</italic>
<sub><italic>k</italic></sub>(<italic>i</italic>)= max<italic>j</italic>|<italic>LCP</italic>
<sub><italic>k</italic></sub>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)|, then 
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \mathsf{ACS}_{k}(\mathsf{X}, \mathsf{Y}) = \frac{1}{|\mathsf{X}|}\sum_{i=1}^{|\mathsf{X}|}\lambda_{k}(i)  $$ \end{document}</tex-math><mml:math id="M4"><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">ACS</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo></mml:math><graphic xlink:href="12859_2017_1658_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>The distance <italic>Dist</italic>
<sub><italic>k</italic></sub>(X,Y), based on <italic>ACS</italic>
<sub><italic>k</italic></sub> is given below [<xref ref-type="bibr" rid="CR13">13</xref>, <xref ref-type="bibr" rid="CR14">14</xref>]. 
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $${} \begin{array}{ll} \mathsf{Dist}_{k}(\mathsf{X},\mathsf{Y}) &amp;= \frac{1}{2} \left(\frac{\log |\mathsf{Y}|} {\mathsf{ACS}_{k}(\mathsf{X},\mathsf{Y})}+\frac{\log |\mathsf{X}|}{\mathsf{ACS}_{k}(\mathsf{Y},\mathsf{X})}\right) -\left(\frac{\log |\mathsf{X}|}{|\mathsf{X}|}+\frac{\log |\mathsf{Y}|}{|\mathsf{Y}|}\right)\\ \end{array}  $$ \end{document}</tex-math><mml:math id="M6"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Dist</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mfrac><mml:mrow><mml:mo>log</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">ACS</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo>log</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">ACS</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>−</mml:mo><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:mfrac><mml:mrow><mml:mo>log</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo>log</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">Y</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr/></mml:mtable></mml:math><graphic xlink:href="12859_2017_1658_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>
</p>
    </sec>
  </sec>
  <sec id="Sec3">
    <title>Methods</title>
    <sec id="Sec4">
      <title>Approximating <italic>ACS</italic><sub><italic>k</italic></sub>(·,·)</title>
      <p>It is observed that <italic>ACS</italic>
<sub><italic>k</italic></sub>(·,·) can be easily computed in <italic>O</italic>(<italic>n</italic>
<sup>2</sup>
<italic>k</italic>) time via |X|×|Y| number of |<italic>LCP</italic>
<sub><italic>k</italic></sub>(·,·)| queries, which is clearly not affordable. The first attempt to circumvent this issue was made by Leimeister and Morgenstern [<xref ref-type="bibr" rid="CR14">14</xref>], who presented a heuristic method, named kmacs, that quickly computes an approximation to <italic>ACS</italic>
<sub><italic>k</italic></sub>(X,Y). The key idea is to replace <italic>λ</italic>
<sub><italic>k</italic></sub>(<italic>i</italic>) with <italic>λ</italic>
<italic>k</italic>′(<italic>i</italic>) in the equation for <italic>ACS</italic>
<sub><italic>k</italic></sub>, where <italic>α</italic>
<sub><italic>i</italic></sub>=<italic>a</italic>
<italic>r</italic>
<italic>g</italic> max<italic>j</italic>|<italic>LCP</italic>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)| and <inline-formula id="IEq1"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\lambda _{k}'(i) =|\mathsf {LCP}_{k}(\mathsf {X}_{i},\mathsf {Y}_{\alpha _{i}})|\phantom {\dot {i}\!}$\end{document}</tex-math><mml:math id="M8"><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">LCP</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>|</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq1.gif"/></alternatives></inline-formula>. Using <italic>GST</italic>, we can compute <italic>α</italic>
<sub><italic>i</italic></sub> for all values of <italic>i</italic> in <italic>O</italic>(<italic>n</italic>) time. Therefore, <italic>λ</italic>
<italic>k</italic>′(<italic>i</italic>) for all values of <italic>i</italic> and the corresponding distance can be easily obtained in <italic>O</italic>(<italic>n</italic>
<italic>k</italic>) time. Note that the ratio of <italic>λ</italic>
<sub><italic>k</italic></sub>(<italic>i</italic>) to <italic>λ</italic>
<italic>k</italic>′(<italic>i</italic>) can be as high as <italic>Θ</italic>(<italic>n</italic>). Nonetheless, it has been shown that for most practical cases, the average of the latter can serve as a good approximation to the average of the former.</p>
    </sec>
    <sec id="Sec5">
      <title>Our approach</title>
      <p>The idea is to follow a simple adaptation of Aluru et al.’s exact algorithm [<xref ref-type="bibr" rid="CR15">15</xref>] for 1-mismatch case and then use the heuristic approach by Leimeister and Morgenstern [<xref ref-type="bibr" rid="CR14">14</xref>] to extend the result to <italic>k</italic>-mismatch. Specifically, our approximation to <italic>ACS</italic>
<sub><italic>k</italic></sub> is obtained by replacing <italic>λ</italic>
<sub><italic>k</italic></sub>(<italic>i</italic>) in the equation for <italic>ACS</italic>
<sub><italic>k</italic></sub> by <italic>λ</italic>
<italic>k</italic>″(<italic>i</italic>), where <italic>β</italic>
<sub><italic>i</italic></sub>=<italic>a</italic>
<italic>r</italic>
<italic>g</italic> max<italic>j</italic>|<italic>LCP</italic>
<sub>1</sub>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)| and <inline-formula id="IEq2"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\lambda _{k}''(i) =|\mathsf {LCP}_{k}(\mathsf {X}_{i},\mathsf {Y}_{\beta _{i}})|\phantom {\dot {i}\!}$\end{document}</tex-math><mml:math id="M10"><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>″</mml:mo></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">LCP</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>|</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq2.gif"/></alternatives></inline-formula>. To compute <italic>β</italic>
<sub><italic>i</italic></sub> for <italic>i</italic>=1,2,…,|X|, we first construct <italic>GST</italic> and an array <italic>A</italic>[1,|X|]. Then for each internal node <italic>u</italic> in <italic>GST</italic>, process the set <inline-formula id="IEq3"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}(u)$\end{document}</tex-math><mml:math id="M12"><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq3.gif"/></alternatives></inline-formula> of suffixes corresponding to the leaves in the subtree of <italic>u</italic>. Let <italic>h</italic> be the <italic>string-depth</italic> of <italic>u</italic>. Then (<italic>h</italic>+1) is the first position, in which the prefixes of two suffixes in <inline-formula id="IEq4"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}(u)$\end{document}</tex-math><mml:math id="M14"><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq4.gif"/></alternatives></inline-formula> can differ. We sort all suffixes in <inline-formula id="IEq5"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {S}(u)$\end{document}</tex-math><mml:math id="M16"><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq5.gif"/></alternatives></inline-formula> by treating the (<italic>h</italic>+1)th character all suffixes to be identical, or equivalently first (<italic>h</italic>+1) characters to be the same. To do so, we follow the steps below: 
<list list-type="bullet"><list-item><p>Map each <inline-formula id="IEq6"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathsf {X}_{i} \in \mathcal {S}(u)$\end{document}</tex-math><mml:math id="M18"><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq6.gif"/></alternatives></inline-formula> to a pair (X
<sub><italic>i</italic></sub>,<italic>k</italic>
<italic>e</italic>
<italic>y</italic>), where <italic>key</italic> is the lexicographic rank of the suffix X
<sub><italic>i</italic>+<italic>h</italic>+1</sub> among all suffixes of X and Y. In other words, <italic>key</italic> is the lexicographic rank of the suffix obtained by deleting the first (<italic>h</italic>+1) characters of X
<sub><italic>i</italic></sub>. Using <italic>GST</italic>, we can compute <italic>key</italic> in constant time.</p></list-item><list-item><p>Likewise, map each <inline-formula id="IEq7"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathsf {Y}_{j} \in \mathcal {S}(u)$\end{document}</tex-math><mml:math id="M20"><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq7.gif"/></alternatives></inline-formula> to a pair (Y
<sub><italic>j</italic></sub>,<italic>k</italic>
<italic>e</italic>
<italic>y</italic>), where <italic>key</italic> is the lexicographic rank of Y
<sub><italic>j</italic>+<italic>h</italic>+1</sub> among all suffixes of X and Y.</p></list-item><list-item><p>Sort all pairs in the ascending order of <italic>key</italic>.</p></list-item><list-item><p>For each pair (X
<sub><italic>i</italic></sub>,·), find the closest pairs, say (Y
<sub><italic>a</italic></sub>,·) and (Y
<sub><italic>b</italic></sub>,·), towards the left and right side (if they exist) that are created from a suffix of Y, and update <italic>A</italic>[<italic>i</italic>]←<italic>a</italic>
<italic>r</italic>
<italic>g</italic> max<italic>j</italic>∈{<italic>a</italic>,<italic>b</italic>,<italic>A</italic>[<italic>i</italic>]}|<italic>LCP</italic>
<sub>1</sub>(X
<sub><italic>i</italic></sub>,Y
<sub><italic>j</italic></sub>)|.</p></list-item></list>
</p>
      <p>After processing all internal nodes as described above, compute the following and report it as our approximation to <italic>ACS</italic>
<sub><italic>k</italic></sub>(X,Y) 
<disp-formula id="Equa"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\frac{1}{|\mathsf{X}|} \sum_{i=1}^{|\mathsf{X}|} \lambda^{\prime\prime}_{k}(i) = \frac{1}{|\mathsf{X}|} \sum_{i=1}^{|\mathsf{X}|} \left|\mathsf{LCP}_{k}\left(\mathsf{X}_{i},\mathsf{Y}_{\beta_{i}}\right)\right| $$ \end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:munderover><mml:msubsup><mml:mrow><mml:mi>λ</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>′′</mml:mi></mml:mrow></mml:msubsup><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">X</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:munderover><mml:mfenced close="|" open="|" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">LCP</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="(" separators=""><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">X</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math><graphic xlink:href="12859_2017_1658_Article_Equa.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>It can be easily verified that <italic>A</italic>[<italic>i</italic>] will be correctly updated to <italic>β</italic>
<sub><italic>i</italic></sub> while processing the lowest common ancestor node of the leaves corresponding to X
<sub><italic>i</italic></sub> and <inline-formula id="IEq8"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathsf {Y}_{\beta _{i}}$\end{document}</tex-math><mml:math id="M24"><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">Y</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>β</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq8.gif"/></alternatives></inline-formula>. The overall run time is <inline-formula id="IEq9"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$nk+\sum _{u} |\mathcal {S}(u)|\log |\mathcal {S}(u)|=O(nk+nH\log n)$\end{document}</tex-math><mml:math id="M26"><mml:mtext mathvariant="italic">nk</mml:mtext><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>u</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mo>log</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">S</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">nk</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">nH</mml:mtext><mml:mo>log</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2017_1658_Article_IEq9.gif"/></alternatives></inline-formula>, where <italic>H</italic> is the height of <italic>GST</italic> and its expected value is <italic>O</italic>(log<italic>n</italic>) [<xref ref-type="bibr" rid="CR24">24</xref>].</p>
    </sec>
    <sec id="Sec6">
      <title>Implementation</title>
      <p>ALFRED-G is implemented in C++ and is incorporated in our open-source ALFRED software package (<ext-link ext-link-type="uri" xlink:href="http://alurulab.cc.gatech.edu/phylo">http://alurulab.cc.gatech.edu/phylo</ext-link>). This algorithm takes a collection of sequences as input and computes an approximation to <italic>ACS</italic>
<sub><italic>k</italic></sub>(·,·) for all pairs of sequences. For this, we have used the open-source libdivsufsort library [<xref ref-type="bibr" rid="CR25">25</xref>] to construct the suffix array (SA) and have used the implementations in the SDSL library [<xref ref-type="bibr" rid="CR26">26</xref>] to build the corresponding LCP table (using the Kasai algorithm [<xref ref-type="bibr" rid="CR27">27</xref>]) and the range minimum query (RMQ) table (using the Bender-Farach’s algorithm [<xref ref-type="bibr" rid="CR28">28</xref>]). (Note that the operations on a suffix tree can be simulated using the corresponding SA, inverse SA, LCP array and RMQ table). The SDSL library has support for using bit compression techniques to reduce the size of the tables and arrays in exchange for slower query time. However, we don’t compress these data structures, and instead we have used 32-bit integers for indices as well as prefix lengths.</p>
    </sec>
  </sec>
  <sec id="Sec7">
    <title>Results and discussion</title>
    <sec id="Sec8">
      <title>Benchmark datasets</title>
      <p>We have assessed the performance of ALFRED-G for the reconstruction of phylogenetic trees by using three sequence datasets, which contain prokaryotic DNA sequences, eukaryotic DNA sequences, and protein sequences, respectively. The prokaryotic sequence dataset consists of 27 Primate mitochondrial genomes, which was previously studied by [<xref ref-type="bibr" rid="CR16">16</xref>] in order to assess the performance of alignment-free approaches for phylogenetic tree reconstruction. In the study, a reference tree was constructed based on a multiple alignment of the sequences.</p>
      <p>The eukaryotic sequence dataset is constructed by Newton et al. [<xref ref-type="bibr" rid="CR29">29</xref>] from 32 Roseobacter genomes, by extracting 70 universal single-copy genes for the 32 genomes with each gene being completely sequenced in all genomes and having no ambiguous start/stop sites. The 70 genes for each genome are, subsequently, concatenated and aligned with ClustalW in Geneious 4.0 (available from <ext-link ext-link-type="uri" xlink:href="http://www.geneious.com">http://www.geneious.com</ext-link>) using <italic>Escherichia coli</italic> K12 substrain MG1655 as the outgroup. The multiple sequence alignment file is available at <ext-link ext-link-type="uri" xlink:href="http://alurulab.cc.gatech.edu/phylo">http://alurulab.cc.gatech.edu/phylo</ext-link>, from which the raw sequences corresponding to the 32 Roseobacter genomes are extracted and then used in our study. In our study, we have used the phylogenetic tree presented in Newton et al. [<xref ref-type="bibr" rid="CR29">29</xref>] as the reference tree.</p>
      <p>The protein sequence dataset is taken from BAliBASE (v3.0) [<xref ref-type="bibr" rid="CR30">30</xref>], which is popular benchmark dataset for multiple sequence alignment. We have used 218 sets of protein sequences in BAliBASE, and constructed the reference trees from the corresponding reference alignments using the <italic>proml</italic> program available in PHYLIP [<xref ref-type="bibr" rid="CR31">31</xref>], which implements the Maxmimum Likelihood method. For each of the parameter selected for our experiments, we report the average RF-distance of the 218 trees constructed from this set.</p>
    </sec>
    <sec id="Sec9">
      <title>Phylogenetic tree construction and comparison</title>
      <p>Given a set of <italic>d</italic> sequences, we first compute the distance between any sequence pair and then construct a pairwise distance matrix of size <italic>d</italic>×<italic>d</italic>. Subsequently, the neighbor-joining (NJ) algorithm [<xref ref-type="bibr" rid="CR2">2</xref>] is applied on the pairwise distance matrix to reconstruct the phylogenetic tree, where the neighbor program in PHYLIP is used. Finally, the topology of the tree is compared with the reference tree using the Robinson-Foulds (RF) distance metric, where the treedist program in PHYLIP is used to compute the RF distance between two trees. Note that the lower the RF distance is, the better the tree topology matches. In particular, if the RF distance equals zero, it means exact topology match between the two trees.</p>
      <p>All experiments are preformed in an Apple Macbook Pro (Mid-2012 model) running Mac OS 10.10.4 (OS X Yosemite). The machine features a 2.9 GHz dual-core Intel Core i7-3667U processor with 4MB L3 cache and 8GB RAM.</p>
    </sec>
    <sec id="Sec10">
      <title>Performance comparison</title>
      <p>As our method is closely related to kmacs, we compared the performance of ALFRED-G with kmacs in terms of speed and accuracy (based on RF-distance) for different values of <italic>k</italic>, ranging from 0 to 9. Note that for <italic>k</italic>=0, both kmacs and ALFRED-G are the same as the ACS method.</p>
      <p>Figure <xref rid="Fig1" ref-type="fig">1</xref> shows the results for the prokaryotic dataset. It can be observed that for all values of <italic>k</italic>, ALFRED-G provides either the same or better accuracy (in terms of RF distance). Interestingly, for <italic>k</italic>=4 and 5, the phylogenetic tree created based on ALFRED-G coincides exactly with the reference tree (see Fig. <xref rid="Fig2" ref-type="fig">2</xref>). We notice that the only other alignment-free method, that was able to recreate this exact reference tree is the recently proposed spaced-seed method [<xref ref-type="bibr" rid="CR8">8</xref>] (but needs careful parameter turning).
<fig id="Fig1"><label>Fig. 1</label><caption><p>RF distance and run-time plots for the prokaryotic dataset</p></caption><graphic xlink:href="12859_2017_1658_Fig1_HTML" id="MO1"/></fig>
<fig id="Fig2"><label>Fig. 2</label><caption><p>Tree generated by ALFRED-G for the prokaryotic dataset with <italic>k</italic>=4</p></caption><graphic xlink:href="12859_2017_1658_Fig2_HTML" id="MO2"/></fig>
</p>
      <p>Figure <xref rid="Fig3" ref-type="fig">3</xref> shows the results for the eukaryotic dataset. Likewise, our RF distance is never worse than that obtained by kmacs. In particular, when setting <italic>k</italic>=6,7 and 8, our RF distance is lower, indicating better performance. Figure <xref rid="Fig4" ref-type="fig">4</xref> shows the topological comparison between the tree generated by our approach and the reference tree, which is generated by the Dendroscope software [<xref ref-type="bibr" rid="CR32">32</xref>].
<fig id="Fig3"><label>Fig. 3</label><caption><p>RF distance and run-time plots for the eukaryotic dataset</p></caption><graphic xlink:href="12859_2017_1658_Fig3_HTML" id="MO3"/></fig>
<fig id="Fig4"><label>Fig. 4</label><caption><p>Reference tree and the tree generated by ALFRED-G for the eukaryotic dataset with <italic>k</italic>=7 (RF distance = 8)</p></caption><graphic xlink:href="12859_2017_1658_Fig4_HTML" id="MO4"/></fig>
</p>
      <p>Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the results for the protein dataset. Here both ALFRED-G and kmacs gave almost the same RF score for each value of <italic>k</italic>. As expected, ALFRED-G is slower than kmacs (by a factor of 2 to 4), however the difference in run-time is independent of <italic>k</italic>.
<fig id="Fig5"><label>Fig. 5</label><caption><p>RF distance and run-time plots for the BAliBASE protein dataset</p></caption><graphic xlink:href="12859_2017_1658_Fig5_HTML" id="MO5"/></fig>
</p>
      <p>In the earlier work by Leimeister and Morgenstern [<xref ref-type="bibr" rid="CR14">14</xref>], it has been show that kmacs and spaced-seed [<xref ref-type="bibr" rid="CR8">8</xref>] are superior to other alignment-free methods, when applied to the aforementioned three datasets. Our experiments show that ALFRED-G is comparable and often more accurate than kmacs, albeit involving higher computational cost. It needs to be mentioned that the comparison with spaced-seed is not as straightforward as with kmacs, because spaced-seed has different input parameters and requires tedious pattern templates tuning. Nevertheless, we have carefully evaluated spaced-seed based on the suggestions from [<xref ref-type="bibr" rid="CR8">8</xref>]. Our evaluation shows that spaced-seed is able to recover the entire reference tree (i.e. RF distance = 0) for the prokaryotic dataset, in just 4 seconds. However, for the rest, the performance of spaced-seed is roughly comparable to both ours and kmacs.</p>
    </sec>
  </sec>
  <sec id="Sec11" sec-type="conclusion">
    <title>Conclusions</title>
    <p>In this paper, we have introduced a greedy alignment-free approach to estimating the evolutionary distance between two sequences. The core of the heuristic is to identify a 1-mismatch longest substring in sequence Y that appears as a prefix of any given suffix in sequence X, and vice versa. This heuristic has been further applied to reconstruct the phylogenetic tree, given a collection of sequences that are believed to be close enough and have some evolutionary relationship between them. The performance of our heuristic has been evaluated using three real datasets: one prokaryotic dataset, one eukaryotic dataset and one protein dataset, in terms of tree-topology RF score and speed. Our experimental results show that our heuristic can exactly reconstruct the same phylogenetic tree topology with the reference tree for the prokaryotic dataset, whereas kmacs cannot. On the remaining two datasets, our heuristic also demonstrates comparable or even better performance than kmacs. As for speed, our heuristic is slightly slower than kmacs.</p>
    <p>Although our heuristic has been shown effective for phylogenetic inference, there are still some limitations that could be improved in the future. Firstly, our heuristic assumes an evolution model having only mismatches, not involving insertions or deletions, for simplicity. This model may not exactly fit the real evolutionary process given a collection of sequences. Nevertheless, our performance evaluation has shown that even though there are some insertions or deletions between sequences (observed from multiple sequence alignment), their evolutionary distances can still be estimated with reasonable accuracy using our heuristic. However, it should be noted that the existence of insertions or deletions may cause our heuristic to underestimate the similarity values, i.e. <italic>ACS</italic>
<sub><italic>k</italic></sub>(·,·), between sequences, thus overestimating their distances, i.e. <italic>Dist</italic>
<sub><italic>k</italic></sub>(X,Y).</p>
    <p>Secondly, our heuristic assumes that the homologous regions between two sequences are on the same strand. Actually, this is not always the case. Given a homologous region, the substring in sequence X may have an opposite strand to the corresponding homology in sequence Y. In this case, directly applying our heuristic to such sequences may overestimate the distance, since these homologies with opposite strands are not counted in the computation of similarity values. In some sense, we would expect that the estimation accuracy of alignment-free approaches could be further improved by incorporating support for strand differences in homologies.</p>
    <p>Thirdly, our heuristic has only used Eq. (<xref rid="Equ3" ref-type="">3</xref>) to estimate the distance from the similarity values computed from Eq. (<xref rid="Equ2" ref-type="">2</xref>). Actually, we usually need to tune distance equations for different similarity computation approaches and even for similarity values in different ranges. For example, Edgar [<xref ref-type="bibr" rid="CR11">11</xref>] used percent identity <italic>D</italic> (0≤<italic>D</italic>≤1) between two sequences as a similarity measure, but proposed to use two different distance computations depending on the value of <italic>D</italic>. In this case, Edgar computed the distance as − ln(1−<italic>D</italic>−<italic>D</italic>
<sup>2</sup>/5) if <italic>D</italic>&gt;0.25, and retrieved the distance value from a pre-computed lookup table, otherwise. Hence, it may be beneficial to design some new distance computation equations that better match our approach. Finally, considering the generality and fast speed of our heuristic, we would expect that related research in bioinformatics and computational biology could benefit from our algorithm.</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>From Fifth IEEE International Conference on Computational Advances in Bio and Medical Sciences(ICCABS 2015) Miami, FL, USA.15-17 October 2015</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>This research is supported in part by the U.S. National Science Foundation grant IIS-1416259. We thank the reviewers of this article and its preliminary version [<xref ref-type="bibr" rid="CR33">33</xref>]. We also thank the authors of [<xref ref-type="bibr" rid="CR29">29</xref>] for sharing the multiple sequence alignment file for the 32 Roseobacter genomes.</p>
    <sec id="d29e2570">
      <title>Funding</title>
      <p>The funding for publication of the article was by the U.S. National Science Foundation grant IIS-1416259.</p>
    </sec>
    <sec id="d29e2575">
      <title>Availability of data and material</title>
      <p>Both dataset and code are available at <ext-link ext-link-type="uri" xlink:href="http://alurulab.cc.gatech.edu/phylo">http://alurulab.cc.gatech.edu/phylo</ext-link>.</p>
    </sec>
    <sec id="d29e2585">
      <title>Authors’ contributions</title>
      <p>ST conceived the algorithm and wrote the initial manuscript; SC implemented the code and performed some experiments; YL wrote the manuscript; AK performed the experiments; SA conceptualized the study. All authors have read and approved the final manuscript.</p>
    </sec>
    <sec id="d29e2590">
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec id="d29e2595">
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e2600">
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec id="d29e2605">
      <title>About this supplement</title>
      <p>This article has been published as part of BMC Bioinformatics Volume 18 Supplement 8, 2017: Selected articles from the Fifth IEEE International Conference on Computational Advances in Bio and Medical Sciences (ICCABS 2015): Bioinformatics. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-18-supplement-8">https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-18-supplement-8</ext-link>.</p>
    </sec>
    <sec id="d29e2615">
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sokal</surname>
            <given-names>RR</given-names>
          </name>
        </person-group>
        <article-title>A statistical method for evaluating systematic relationships</article-title>
        <source>Univ Kans Sci Bull</source>
        <year>1958</year>
        <volume>38</volume>
        <fpage>1409</fpage>
        <lpage>38</lpage>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Saitou</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Nei</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees</article-title>
        <source>Mol Biol Evol</source>
        <year>1987</year>
        <volume>4</volume>
        <issue>4</issue>
        <fpage>406</fpage>
        <lpage>25</lpage>
        <?supplied-pmid 3447015?>
        <pub-id pub-id-type="pmid">3447015</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">Stewart CA, Hart D, Berry DK, Olsen GJ, Wernert EA, Fischer W. Parallel implementation and performance of fastdnaml-a program for maximum likelihood phylogenetic inference. In: Supercomputing, ACM/IEEE 2001 Conference. IEEE: 2001. p. 32–2.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <mixed-citation publication-type="other">Ott M, Zola J, Stamatakis A, Aluru S. Large-scale maximum likelihood-based phylogenetic analysis on the ibm bluegene/l. In: Proceedings of the 2007 ACM/IEEE Conference on Supercomputing. ACM: 2007. p. 4.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <mixed-citation publication-type="other">Liu Y, Schmidt B, Maskell DL. Parallel reconstruction of neighbor-joining trees for large multiple sequence alignments using cuda. In: Parallel &amp; Distributed Processing, 2009. IPDPS 2009. IEEE International Symposium On. IEEE: 2009. p. 1–8.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhou</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Stones</surname>
            <given-names>DS</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Mrbayes on a graphics processing unit</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <issue>9</issue>
        <fpage>1255</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btr140</pub-id>
        <?supplied-pmid 21414986?>
        <pub-id pub-id-type="pmid">21414986</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vinga</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Almeida</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Alignment-free sequence comparison-a review</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>4</issue>
        <fpage>513</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg005</pub-id>
        <?supplied-pmid 12611807?>
        <pub-id pub-id-type="pmid">12611807</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <mixed-citation publication-type="other">Leimeister CA, Boden M, Horwege S, Lindner S, Morgenstern B. Fast alignment-free sequence comparison using spaced-word frequencies. Bioinformatics. 2014; 30(14):1991. doi:<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btu177">http://dx.doi.org/10.1093/bioinformatics/btu177</ext-link>,<ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btu177">http://dx.doi.org/10.1093/bioinformatics/btu177</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Blaisdell</surname>
            <given-names>BE</given-names>
          </name>
        </person-group>
        <article-title>Effectiveness of measures requiring and not requiring prior sequence alignment for estimating the dissimilarity of natural sequences</article-title>
        <source>J Mol Evol</source>
        <year>1989</year>
        <volume>29</volume>
        <issue>6</issue>
        <fpage>526</fpage>
        <lpage>37</lpage>
        <pub-id pub-id-type="doi">10.1007/BF02602924</pub-id>
        <?supplied-pmid 2515299?>
        <pub-id pub-id-type="pmid">2515299</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Hsieh</surname>
            <given-names>YC</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>LA</given-names>
          </name>
        </person-group>
        <article-title>Statistical measures of dna sequence dissimilarity under markov chain models of base composition</article-title>
        <source>Biometrics</source>
        <year>2001</year>
        <volume>57</volume>
        <issue>2</issue>
        <fpage>441</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1111/j.0006-341X.2001.00441.x</pub-id>
        <?supplied-pmid 11414568?>
        <pub-id pub-id-type="pmid">11414568</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Edgar</surname>
            <given-names>RC</given-names>
          </name>
        </person-group>
        <article-title>Muscle: a multiple sequence alignment method with reduced time and space complexity</article-title>
        <source>BMC Bioinforma</source>
        <year>2004</year>
        <volume>5</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-5-113</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sun</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Cai</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Farrell</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>McKendree</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Farmerie</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Esprit: estimating species richness using large collections of 16s rrna pyrosequences</article-title>
        <source>Nucleic Acids Res</source>
        <year>2009</year>
        <volume>37</volume>
        <issue>10</issue>
        <fpage>76</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkp285</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ulitsky</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Burstein</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tuller</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Chor</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>The average common substring approach to phylogenomic reconstruction</article-title>
        <source>J Comput Biol</source>
        <year>2006</year>
        <volume>13</volume>
        <issue>2</issue>
        <fpage>336</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2006.13.336</pub-id>
        <?supplied-pmid 16597244?>
        <pub-id pub-id-type="pmid">16597244</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leimeister</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Morgenstern</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>kmacs: the k-mismatch average common substring approach to alignment-free sequence comparison</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <issue>14</issue>
        <fpage>2000</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu331</pub-id>
        <?supplied-pmid 24828656?>
        <pub-id pub-id-type="pmid">24828656</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Aluru S, Apostolico A, Thankachan SV. Efficient alignment free sequence comparison with bounded mismatches. In: International Conference on Research in Computational Molecular Biology. Springer: 2015. p. 1–12.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Haubold</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Pfaffelhuber</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Domazet-Loso</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Wiehe</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Estimating mutation distances from unaligned genomes</article-title>
        <source>J Comput Biol</source>
        <year>2009</year>
        <volume>16</volume>
        <issue>10</issue>
        <fpage>1487</fpage>
        <lpage>500</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0106</pub-id>
        <?supplied-pmid 19803738?>
        <pub-id pub-id-type="pmid">19803738</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Apostolico</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Guerra</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Landau</surname>
            <given-names>GM</given-names>
          </name>
          <name>
            <surname>Pizzi</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Sequence similarity measures based on bounded hamming distance</article-title>
        <source>Theor Comput Sci</source>
        <year>2016</year>
        <volume>638</volume>
        <fpage>76</fpage>
        <lpage>90</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tcs.2016.01.023</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flouri</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Giaquinta</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Kobert</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Longest common substrings with k mismatches</article-title>
        <source>Inf Process Lett</source>
        <year>2015</year>
        <volume>115</volume>
        <issue>6</issue>
        <fpage>643</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ipl.2015.03.006</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <mixed-citation publication-type="other">Manzini G. Longest common prefix with mismatches. In: International Symposium on String Processing and Information Retrieval. Springer: 2015. p. 299–310.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thankachan</surname>
            <given-names>SV</given-names>
          </name>
          <name>
            <surname>Apostolico</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Aluru</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>A provably efficient algorithm for the k-mismatch average common substring problem</article-title>
        <source>J Comput Biol</source>
        <year>2016</year>
        <volume>23</volume>
        <issue>6</issue>
        <fpage>472</fpage>
        <lpage>82</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2015.0235</pub-id>
        <?supplied-pmid 27058840?>
        <pub-id pub-id-type="pmid">27058840</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thankachan</surname>
            <given-names>SV</given-names>
          </name>
          <name>
            <surname>Chockalingam</surname>
            <given-names>SP</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Apostolico</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Aluru</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Alfred: a practical method for alignment-free distance computation</article-title>
        <source>J Comput Biol</source>
        <year>2016</year>
        <volume>23</volume>
        <issue>6</issue>
        <fpage>452</fpage>
        <lpage>60</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2015.0217</pub-id>
        <?supplied-pmid 27138275?>
        <pub-id pub-id-type="pmid">27138275</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pizzi</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Missmax: alignment-free sequence comparison with mismatches through filtering and heuristics</article-title>
        <source>Algorithm Mol Biol</source>
        <year>2016</year>
        <volume>11</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/s13015-016-0072-x</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Weiner P. Linear pattern matching algorithms. In: Switching and Automata Theory, 1973. SWAT’08. IEEE Conference Record of 14th Annual Symposium On. IEEE: 1973. p. 1–11.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Devroye</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Szpankowski</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Rais</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>A note on the height of suffix trees</article-title>
        <source>SIAM J Comput</source>
        <year>1992</year>
        <volume>21</volume>
        <issue>1</issue>
        <fpage>48</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1137/0221005</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <mixed-citation publication-type="other">Mori Y. Libdivsufsort: a lightweight suffix array construction library. 2003.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <mixed-citation publication-type="other">Gog S, Beller T, Moffat A, Petri M. From theory to practice: Plug and play with succinct data structures. In: International Symposium on Experimental Algorithms. Springer: 2014. p. 326–37.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <mixed-citation publication-type="other">Kasai T, Lee G, Arimura H, Arikawa S, Park K. Linear-time longest-common-prefix computation in suffix arrays and its applications. In: Annual Symposium on Combinatorial Pattern Matching. Springer: 2001. p. 181–92.</mixed-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <mixed-citation publication-type="other">Bender MA, Farach-Colton M. The lca problem revisited. In: Latin American Symposium on Theoretical Informatics. Springer: 2000. p. 88–94.</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Newton</surname>
            <given-names>RJ</given-names>
          </name>
          <name>
            <surname>Griffin</surname>
            <given-names>LE</given-names>
          </name>
          <name>
            <surname>Bowles</surname>
            <given-names>KM</given-names>
          </name>
          <name>
            <surname>Meile</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Gifford</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Givens</surname>
            <given-names>CE</given-names>
          </name>
          <name>
            <surname>Howard</surname>
            <given-names>EC</given-names>
          </name>
          <name>
            <surname>King</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Oakley</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Reisch</surname>
            <given-names>CR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Genome characteristics of a generalist marine bacterial lineage</article-title>
        <source>ISME J</source>
        <year>2010</year>
        <volume>4</volume>
        <issue>6</issue>
        <fpage>784</fpage>
        <lpage>98</lpage>
        <pub-id pub-id-type="doi">10.1038/ismej.2009.150</pub-id>
        <?supplied-pmid 20072162?>
        <pub-id pub-id-type="pmid">20072162</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Koehl</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Ripp</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Poch</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>Balibase 3.0: latest developments of the multiple sequence alignment benchmark</article-title>
        <source>Proteins Struct Funct Bioinforma</source>
        <year>2005</year>
        <volume>61</volume>
        <issue>1</issue>
        <fpage>127</fpage>
        <lpage>36</lpage>
        <pub-id pub-id-type="doi">10.1002/prot.20527</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <mixed-citation publication-type="other">Felsenstein J. {<italic>PHYLIP</italic>}: phylogenetic inference package, version 3.5 c. 1993.</mixed-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huson</surname>
            <given-names>DH</given-names>
          </name>
          <name>
            <surname>Richter</surname>
            <given-names>DC</given-names>
          </name>
          <name>
            <surname>Rausch</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Dezulian</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Franz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rupp</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Dendroscope: an interactive viewer for large phylogenetic trees</article-title>
        <source>BMC Bioinforma</source>
        <year>2007</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>1</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-460</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33</label>
      <mixed-citation publication-type="other">Thankachan SV, Chockalingam SP, Liu Y, Krishnan A, Aluru S. A greedy alignment-free distance estimator for phylogenetic inference. In: International Conference on Computational Advances in Bio and Medical Sciences (ICCABS). IEEE: 2015. p. 1–1.</mixed-citation>
    </ref>
  </ref-list>
</back>
