<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4058937</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu264</article-id>
    <article-id pub-id-type="publisher-id">btu264</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb 2014 Proceedings Papers Committee</subject>
        <subj-group subj-group-type="heading">
          <subject>Original Papers</subject>
          <subj-group subj-group-type="heading">
            <subject>Protein Structure and Function</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>An efficient parallel algorithm for accelerating computational protein design</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Zhou</surname>
          <given-names>Yichao</given-names>
        </name>
        <xref ref-type="aff" rid="btu264-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xu</surname>
          <given-names>Wei</given-names>
        </name>
        <xref ref-type="aff" rid="btu264-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Donald</surname>
          <given-names>Bruce R.</given-names>
        </name>
        <xref ref-type="aff" rid="btu264-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btu264-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Zeng</surname>
          <given-names>Jianyang</given-names>
        </name>
        <xref ref-type="aff" rid="btu264-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btu264-COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="btu264-AFF1"><sup>1</sup>Institute for Theoretical Computer Science (ITCS), Institute for Interdisciplinary Information Sciences, Tsinghua University, Beijing 100084, P. R. China, <sup>2</sup>Department of Computer Science, Duke University, Durham, NC 27708, USA and <sup>3</sup>Department of Biochemistry, Duke University Medical Center, Durham, NC 27708, USA</aff>
    <author-notes>
      <corresp id="btu264-COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>12</issue>
    <fpage>i255</fpage>
    <lpage>i263</lpage>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">http://creativecommons.org/licenses/by-nc/3.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Structure-based computational protein design (SCPR) is an important topic in protein engineering. Under the assumption of a rigid backbone and a finite set of discrete conformations of side-chains, various methods have been proposed to address this problem. A popular method is to combine the dead-end elimination (DEE) and A* tree search algorithms, which provably finds the global minimum energy conformation (GMEC) solution.</p>
      <p><bold>Results:</bold> In this article, we improve the efficiency of computing A* heuristic functions for protein design and propose a variant of A* algorithm in which the search process can be performed on a single GPU in a massively parallel fashion. In addition, we make some efforts to address the memory exceeding problem in A* search. As a result, our enhancements can achieve a significant speedup of the A*-based protein design algorithm by four orders of magnitude on large-scale test data through pre-computation and parallelization, while still maintaining an acceptable memory overhead. We also show that our parallel A* search algorithm could be successfully combined with iMinDEE, a state-of-the-art DEE criterion, for rotamer pruning to further improve SCPR with the consideration of continuous side-chain flexibility.</p>
      <p><bold>Availability:</bold> Our software is available and distributed open-source under the GNU Lesser General License Version 2.1 (GNU, February 1999). The source code can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.cs.duke.edu/donaldlab/osprey.php">http://www.cs.duke.edu/donaldlab/osprey.php</ext-link> or <ext-link ext-link-type="uri" xlink:href="http://iiis.tsinghua.edu.cn/~compbio/software.html">http://iiis.tsinghua.edu.cn/∼compbio/software.html</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>zengjy321@tsinghua.edu.cn</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>Structure-based computational protein design (SCPR) provides a promising tool in a wide range of protein engineering applications, such as drug design (<xref rid="btu264-B12" ref-type="bibr">Gorczynski <italic>et al.</italic>, 2007</xref>), enzyme synthesis (<xref rid="btu264-B3" ref-type="bibr">Chen <italic>et al.</italic>, 2009</xref>), drug resistance prediction (<xref rid="btu264-B7" ref-type="bibr">Frey <italic>et al.</italic>, 2010</xref>) and design of protein–protein interactions (<xref rid="btu264-B25" ref-type="bibr">Roberts <italic>et al.</italic>, 2012</xref>). The basic idea of SCPR is to find a new amino acid sequence based on a known structure, such that the total energy of the resulting molecular complex is minimized. In general, it is difficult to model an ideal protein design framework with the consideration of full backbone and side-chain flexibility, since there are usually a huge number of conformations that need to be sampled even for a small protein. Therefore, in practice assumptions are often made to reduce the complexity of the protein design problem. In most of protein design models (<xref rid="btu264-B25" ref-type="bibr">Roberts <italic>et al.</italic>, 2012</xref>), the backbone structure is assumed as a rigid body, and only side-chains are allowed to rotate among a finite set of discrete conformations, called the <italic>rotamer library</italic>.</p>
    <p>Under the rigid backbone assumption, the goal of SCPR is to search over all possible combinations of side-chain rotamer conformations of different allowed amino acids, trying to find the global minimum energy conformation (aka GMEC). Unfortunately, this problem has been proven NP-hard (<xref rid="btu264-B2" ref-type="bibr">Chazelle <italic>et al.</italic>, 2004</xref>; <xref rid="btu264-B23" ref-type="bibr">Pierce and Winfree, 2002</xref>). Thus, a number of heuristic methods, such as Monte Carlo and genetic algorithms, have been proposed to find the approximate solutions to this problem (<xref rid="btu264-B16" ref-type="bibr">Kuhlman and Baker, 2000</xref>; <xref rid="btu264-B20" ref-type="bibr">Marvin and Hellinga, 2001</xref>; <xref rid="btu264-B30" ref-type="bibr">Shah <italic>et al.</italic>, 2004</xref>; <xref rid="btu264-B32" ref-type="bibr">Street and Mayo, 1999</xref>). A recent study also suggests that we can split the entire task into small pieces so that a large-scale protein design problem can be solved in parallel (<xref rid="btu264-B24" ref-type="bibr">Pitman <italic>et al.</italic>, 2014</xref>). However, these approaches cannot provide any provable guarantee of finding the global optimal solution (i.e., GMEC) as they may get trapped in a local optimum. In contrast, provable algorithms, such as tree decomposition (<xref rid="btu264-B33" ref-type="bibr">Xu and Berger, 2006</xref>), integer linear programming with a branch-and-bound technique (<xref rid="btu264-B1" ref-type="bibr">Althaus <italic>et al.</italic>, 2002</xref>; <xref rid="btu264-B14" ref-type="bibr">Kingsford <italic>et al.</italic>, 2005</xref>), dead-end elimination (DEE; <xref rid="btu264-B5" ref-type="bibr">Desmet <italic>et al.</italic>, 1992</xref>) and A* search (<xref rid="btu264-B6" ref-type="bibr">Donald, 2011</xref>; <xref rid="btu264-B17" ref-type="bibr">Leach <italic>et al.</italic>, 1998</xref>; <xref rid="btu264-B19" ref-type="bibr">Lippow and Tidor, 2007</xref>) assure that GMEC will be outputted as a final solution. In particular, the combination of DEE and A* search is popular in computational protein design (<xref rid="btu264-B6" ref-type="bibr">Donald, 2011</xref>; <xref rid="btu264-B19" ref-type="bibr">Lippow and Tidor, 2007</xref>). In this design strategy, DEE is first applied to prune a large number of unfavorable rotamers that are provably not part of the optimal solution. Next, the A* algorithm is used to search over all possible combinations of the remaining rotamers and compute the GMEC solution.</p>
    <p>A number of DEE criteria have been proposed to improve the rotamer pruning and reduce the complexity of the rotamer conformation search space (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>; <xref rid="btu264-B11" ref-type="bibr">Georgiev <italic>et al.</italic>, 2008</xref>, <xref rid="btu264-B10" ref-type="bibr">2006</xref>). Although DEE can prune most rotamer conformations in the problem space, the A* algorithm still runs in exponential time in the worst case. In the DEE and A*-based framework, A* is generally one of the most time-consuming parts, especially for large-scale protein design problems. Thus it is vital to propose a faster algorithm to alleviate this bottleneck and therefore accelerate the protein design process.</p>
    <p>In this article, we develop an efficient parallel A* tree search algorithm to accelerate computational protein design. By optimizing and parallelizing the computation of heuristic functions and the underlying data structure (i.e., the priority queue) for A* search, our algorithm significantly speeds up the A* search process. Our approach fully exploits the capacity of parallelism on a Graphics Processing Unit (GPU) to support the A* search for protein design. Tests on a benchmark dataset of 74 proteins show that our new algorithm runs up to 20 000 times faster than the original A*-based protein design algorithm, while still maintaining an acceptable amount of memory overhead. Thus, our parallel A* search algorithm can provide a practically useful tool for computational protein design.</p>
  </sec>
  <sec>
    <title>2 METHODS</title>
    <sec id="SEC2.1">
      <title>2.1 General-purpose computing on GPUs</title>
      <p>General-purpose computing on graphics processing units (aka GPGPU), is a method to use a GPU together with a CPU to accelerate traditional computation. The main difference between CPU and GPU computational frameworks lies in the mechanisms they use to process calculation tasks. A CPU usually contains several highly optimized cores for sequential instruction execution, while a GPU typically contains thousands of simpler but efficient cores which are able to process different tasks in parallel. As an example, a high-end GPU, AMD Radeon 7970 Tahiti XT, has 2048 processing elements, while a powerful CPU such as Intel Xeon E7-8870 only contains 10 cores. Because of this characteristic, we must modify our algorithms originally designed for a CPU to take advantage of a large amount of parallelism to bring the full power of a GPU into play.</p>
      <p>A GPU typically has a better performance in floating-point operation than a same-price CPU. For example, an NVIDIA GeForce GTX 580M has 952.3 <italic>theoretical</italic> GFLOPS (giga floating-point operation per second), while the <italic>theoretical</italic> GFLOPS of Intel Core i7-3960 is only 158.4, according to the specification released by Intel (<xref rid="btu264-B13" ref-type="bibr">Intel Corporation, 2011</xref>) and NVIDIA (<xref rid="btu264-B22" ref-type="bibr">NVIDIA Corporation, 2013</xref>), respectively. In our protein design problem, the main bottleneck is the floating-point operations for the heuristic function evaluation. Therefore, GPU acceleration is an appropriate tool to address such a problem.</p>
      <p>A GPU has its own memory system. Thus it can provide a larger memory bandwidth than that of a CPU, which means GPU cores can retrieve and write data from/to the global memory faster than a CPU. This is especially suitable for those algorithms that are limited by the global memory bandwidth. However, before and after the computation, data need to be transferred between the memory of CPU and GPU through a relatively slow PCI-E bus. Thus, in general, we prefer a smaller ratio between the amount of time used to transfer input/output and the amount of time spent on computation. The A* search algorithm is suitable for such a computation framework, as the amount of floating-point computation makes the data transfer overhead negligible.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 An A* search algorithm for protein design</title>
      <p>In this section, we will first give some background about using A* algorithm to solve the protein design problem. In Section 2.2.1, we will provide a new approach to improve the computation of heuristic function in A* search. After that, Sections 2.3 and 2.4 will present a two-level parallelized A* algorithm that is suitable for a modern GPU. Finally, Section 2.5 will provide an extended A* algorithm that runs in bounded memory.</p>
      <p>Under the assumption of a rigid backbone and discrete side-chain rotamers, SCPR can be generally formulated as an optimization problem, in which we aim to find an amino acid or rotamer sequence that minimizes the following objective function using 1- and 2-body energies:
<disp-formula id="btu264-M1"><label>(1)</label><graphic xlink:href="btu264m1.jpg" position="float"/></disp-formula>
where <italic>A</italic> is the set of discrete side-chain rotamer conformations (typically called the <italic>rotamer library</italic>), <italic>E</italic><sub>0</sub> is the backbone or template energy, <italic>E</italic><sub>1</sub>(<italic>i<sub>r</sub></italic>) is the self energy of rotamer <italic>r</italic> for residue <italic>i</italic> (including intra-residue and rotamer-to-backbone energies), and <italic>E</italic><sub>2</sub>(<italic>i<sub>r</sub></italic>,<italic>j<sub>s</sub></italic>) is the pairwise interaction energy between rotamer <italic>i<sub>r</sub></italic> and <italic>j<sub>s</sub></italic>. The global optimal solution, i.e., GMEC, minimizes the above energy function in <xref ref-type="disp-formula" rid="btu264-M1">Equation (1)</xref>.</p>
      <p>The combination of DEE and A* search algorithm has been popularly used in computational protein design (<xref rid="btu264-B6" ref-type="bibr">Donald, 2011</xref>; <xref rid="btu264-B9" ref-type="bibr">Gainza <italic>et al.</italic>, 2013</xref>; <xref rid="btu264-B11" ref-type="bibr">Georgiev <italic>et al.</italic>, 2008</xref>; <xref rid="btu264-B17" ref-type="bibr">Leach <italic>et al.</italic>, 1998</xref>; <xref rid="btu264-B18" ref-type="bibr">Lilien <italic>et al.</italic>, 2005</xref>; <xref rid="btu264-B19" ref-type="bibr">Lippow and Tidor, 2007</xref>;). In this protein design strategy, the DEE algorithm is first applied to prune a number of rotamers that are provably not part of the optimal solution that minimizes the energy function in <xref ref-type="disp-formula" rid="btu264-M1">Equation (1)</xref>. Next, an A* tree search algorithm is used to search over all possible combinations of the remaining rotamers and find the global optimal solution (i.e., GMEC). Traditional implementations of the A* search algorithm for protein design take a priority queue to decide the order of visiting nodes in the tree search. In this priority queue, elements are sorted by the following heuristic function as the evaluation measure for each expanding rotamer:
<disp-formula id="btu264-M2"><label>(2)</label><mml:math id="n2"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>g</italic>(<italic>x</italic>) represents the actual cost from the starting node (i.e., the root of the A* search tree) to the current node <italic>x</italic>, and <italic>h</italic>(<italic>x</italic>) represents the estimated cost from the current node <italic>x</italic> to its destination (i.e., a leaf node in the A* search tree).</p>
      <p>Each time, we extract a node with the smallest heuristic function value from the priority queue, expand it and then push the new expanded nodes back into the priority queue. We repeat this process until a target node (which is one of the leaf nodes with the minimum heuristic function value in the search tree) is found. Algorithm 1 describes a single-thread version of the traditional A* search procedure.</p>
      <p>
        <boxed-text id="btu264-BOX1" position="float">
          <caption>
            <title><bold>Algorithm 1</bold> A single-thread version of the traditional A* search</title>
          </caption>
          <p>1: <bold>procedure</bold> A-S<sc>tar</sc>(<italic>s</italic>, <italic>T</italic>)   ▹ <italic>s</italic> is the starting node and <italic>T</italic> is</p>
          <p>2: Let <italic>Q</italic> be a priority queue   ▹ the set of target nodes</p>
          <p>3: <inline-formula><mml:math id="n3"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>←</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>4: P<sc>ush</sc>(<italic>Q</italic>, <italic>s</italic>)</p>
          <p>5: <bold>while</bold>
<italic>Q</italic> is not empty <bold>do</bold></p>
          <p>6:  <inline-formula><mml:math id="n4"><mml:mrow><mml:mi>q</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula>P<sc>op</sc>(<italic>Q</italic>)</p>
          <p>7:  <bold>if</bold>
<inline-formula><mml:math id="n5"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p>
          <p>8:   <bold>return</bold> the path found</p>
          <p>9:  <bold>end if</bold></p>
          <p>10:  Let <italic>R</italic> be the set of expanded nodes from <italic>q</italic></p>
          <p>11:  Calculate <italic>f</italic>(<italic>x</italic>) for all nodes in <italic>R</italic></p>
          <p>12:  Push all the elements from <italic>R</italic> into <italic>Q</italic></p>
          <p>13: <bold>end while</bold></p>
          <p>14: <bold>end procedure</bold></p>
        </boxed-text>
      </p>
      <sec id="SEC2.2.1">
        <title>2.2.1 Improved computation of heuristic functions</title>
        <p>In the A* search algorithm for solving the protein design problem, the actual cost from the starting node to current node <italic>x</italic> in the search tree is defined by
<disp-formula id="btu264-M3"><label>(3)</label><graphic xlink:href="btu264m3.jpg" position="float"/></disp-formula>
where <italic>D</italic>(<italic>x</italic>) is the set of residues in which rotamers have been already determined so far, <italic>E</italic><sub>0</sub> is the backbone energy, <italic>E</italic><sub>1</sub>(<italic>i<sub>r</sub></italic>) is the self energy of rotamer <italic>i<sub>r</sub></italic> (including both intra-residue and rotamer-to-backbone energies), and <italic>E</italic><sub>2</sub>(<italic>i<sub>r</sub></italic>,<italic>j<sub>s</sub></italic>) is the pairwise interaction energy between rotamers <italic>i<sub>r</sub></italic> and <italic>j<sub>s</sub></italic>.</p>
        <p>The estimated cost from current node <italic>x</italic> to the destination node is defined by
<disp-formula id="btu264-M4"><label>(4)</label><mml:math id="n7"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mover><mml:mi>r</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mover></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>j</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mover><mml:mi>u</mml:mi><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mover></mml:mrow></mml:mstyle><mml:msub><mml:mi>E</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>U</italic>(<italic>x</italic>) represents the set of residues, in which rotamers have not been determined at current node <italic>x</italic>.</p>
        <p>A brute-force method of calculating heuristic function <italic>f</italic>(<italic>x</italic>) = <italic>g</italic>(<italic>x</italic>) + <italic>h</italic>(<italic>x</italic>) takes <italic>O</italic>(<italic>n</italic><sup>2</sup><italic>m</italic><sup>2</sup>) floating-point operations, where <italic>n</italic> is the length of protein sequence and <italic>m</italic> is the maximum possible number of rotamers per residue. Thus, it takes <italic>O</italic>(<italic>n</italic><sup>2</sup><italic>m</italic><sup>2</sup><italic>t</italic>) floating-point operations to compute heuristic functions for all nodes in the whole A* search tree using this brute-force method, where <italic>t</italic> is the total number of expanded nodes in the search tree. However, our analysis of <xref ref-type="disp-formula" rid="btu264-M4">Equation (4)</xref> reveals that we do not need to spend <italic>O</italic>(<italic>nm</italic>) time in repeatedly calculating <inline-formula><mml:math id="n8"><mml:mrow><mml:mstyle displaystyle="true"><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>⁡</mml:mo></mml:mrow></mml:mstyle><mml:msub><mml:mi>E</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>i</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>k</mml:mi><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> each time when we evaluate the heuristic function. Since we search the conformation space residue by residue, there are only <italic>n</italic> possibilities for <italic>U</italic>(<italic>x</italic>). Therefore, we can use a two-dimension table <italic>T</italic>[<italic>U</italic>(<italic>x</italic>),<italic>i<sub>r</sub></italic>] to pre-compute all these possible values. This pre-computation process takes <italic>O</italic>(<italic>n</italic><sup>2</sup><italic>m</italic>) memory and <italic>O</italic>(<italic>n</italic><sup>3</sup><italic>m</italic><sup>2</sup>) floating-point operations, but reduces time complexity of calculating <italic>f</italic>(<italic>x</italic>) down to <italic>O</italic>(<italic>n</italic><sup>2</sup><italic>m</italic>) when expanding a new node. Again suppose that the total number of expanded nodes in the final A* search tree is <italic>t</italic>. Then we bring down the overall time complexity from <italic>O</italic>(<italic>n</italic><sup>2</sup><italic>m</italic><sup>2</sup><italic>t</italic>) to <italic>O</italic>(<italic>n</italic><sup>3</sup><italic>m</italic><sup>2 </sup>+ <italic>n</italic><sup>2</sup><italic>mt</italic>), which greatly improves the practical efficiency of the algorithm because in general <italic>t</italic> ≫ <italic>n</italic>.</p>
        <p>We have also applied some technique to improve the computation of the <italic>g</italic>(<italic>x</italic>) function, which reduces its computational complexity from <italic>O</italic>(<italic>n</italic><sup>2</sup>) to <italic>O</italic>(<italic>n</italic>). More details of the improved computation of <italic>g</italic>(<italic>x</italic>) can be found in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">Supplementary Material Section S1</ext-link>.</p>
      </sec>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Parallelized computation of heuristic functions</title>
      <p>The most time-consuming part of the A* tree search algorithm for protein design lies in the following two aspects: (i) Calculation of heuristic functions; (ii) Priority queue operations for expanding new nodes. To alleviate these two bottlenecks, we propose a new algorithm with two levels of parallelism to accelerate protein design. In this section, we will describe the first level of parallelism, that is, parallelized calculation of heuristic functions in A* search.</p>
      <p>Although time complexity of calculating a heuristic function has been improved from <italic>O</italic>(<italic>n</italic><sup>2</sup><italic>m</italic><sup>2</sup><italic>t</italic>) to <italic>O</italic>(<italic>n</italic><sup>3</sup><italic>m</italic><sup>2 </sup>+ <italic>n</italic><sup>2</sup><italic>mt</italic>) in Section 2.2.1, the computation of heuristic functions for new expanded nodes in A* search can be further sped up by exploiting the inherent parallelism capacity of a GPU. This step is quite straightforward, based on the observation that calculation of heuristic function <italic>f</italic>(<italic>x</italic>) for each expanded node is simply a series of independent arithmetic operations that can be directly parallelized. The flow chart of the first level parallelism can be found in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">Figure S1</ext-link> in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">Supplementary Material Section S2</ext-link>.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Parallelized A* search for protein design</title>
      <p>Although the method described in Section 2.3 can parallelize the A* search algorithm, the scale of the parallelism is still limited. In our protein design problem, the degree of parallelism in the computation of heuristic function is equal to the maximum number of rotamers per residue, which is normally in the order of 10 after pruning unfavorable rotamers using the combinations of different DEE criteria. Although this may be good enough for a single-machine CPU implementation, a GPU implementation definitely needs a larger degree of parallelism as we mentioned in Section 2.1.</p>
      <p>Another problem is that the priority queue operations, including P<sc>ush-back</sc> and P<sc>op</sc>, take <inline-formula><mml:math id="n9"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, where <italic>N</italic> stands for the total number of elements in the priority queue and usually is a large number. After computing the heuristic functions of newly expanded nodes, we need to push all of them back into a single priority queue. This part has not been parallelized and thus only exploits a small proportion of the parallel capacity of a GPU. Therefore, further improvement is needed.</p>
      <p>A naïve idea is to pop a number of minimum elements from a single priority queue and then compute their heuristic function values. However, this method is still unable to parallelize the priority queue operations. Existing parallel priority queues (<xref rid="btu264-B26" ref-type="bibr">Rönngren and Ayani, 1997</xref>), such as pipelined binary heap (<xref rid="btu264-B21" ref-type="bibr">Moon <italic>et al.</italic>, 2000</xref>), do not fit the GPU model well, mainly due to the high overhead of synchronization and branch divergence.</p>
      <p>To address the aforementioned problems, we propose a new and parallel version of the A* search algorithm to fully exploit the power of parallelism in a GPU for accelerating protein design. This algorithm is mainly based on the observation that we do not need to extract the <italic>k</italic> lowest-energy conformations with the smallest <italic>f</italic>(<italic>x</italic>) values in gap-free sorted order. In fact, we only need to assure that the element with the smallest heuristic function value is extracted, and do not have to restrict others.</p>
      <p>In our algorithm, we allocate hundreds of priority queues, and then let each thread operate on its own priority queue. Suppose we allocate <italic>k</italic> priority queues in total. The basic idea of our algorithm includes the following key steps:
<list list-type="order"><list-item><p>Launch <italic>k</italic> threads to pop <italic>k</italic> minimum elements from <italic>k</italic> priority queues in parallel;</p></list-item><list-item><p>For each thread, expand new nodes for the extracted element;</p></list-item><list-item><p>Launch enough threads to perform parallelized computation of heuristic functions, using the procedure described in Section 2.3; and</p></list-item><list-item><p>Launch <italic>k</italic> threads to push all expanded nodes back into <italic>k</italic> priority queues.</p></list-item></list>
</p>
      <p>The pseudocode of our algorithm, GA*, can be found in Algorithm 2. More details of this parallel algorithm are illustrated in <xref ref-type="fig" rid="btu264-F1">Figure 1</xref>. The parallelism employed in our algorithm can directly address all the previously mentioned computational bottlenecks in A* search and thus greatly speed up the computational protein design process. In addition, our new algorithm introduces small overhead. It only requires a constant number of global synchronization points per round without much communication overhead.
<fig id="btu264-F1" position="float"><label>Fig. 1.</label><caption><p>Flow chart of our GA* search algorithm for accelerating protein design. Symbols <italic>r<sub>i</sub></italic> represent all parallel expanded rotamers, and <italic>p</italic> is the total number of expanded nodes. A shaded and rounded square represents a global state, which can be regarded as a global synchronization point. The directional black edges mean that the procedure needs to be done between two synchronization points. The dashed arrows and the double bold arrows represent the data flow among different states and the priority queues, respectively. A group of similar arrows means that the operations are performed in parallel</p></caption><graphic xlink:href="btu264f1"/></fig></p>
      <p>Note that this pseudocode is just for computing the GMEC solution. Our algorithm can be easily extended to output all solutions within a specific energetic cutoff from the GMEC solution in gap-free sorted order, using the same strategy as in OSPREY (<xref rid="btu264-B3" ref-type="bibr">Chen <italic>et al.</italic>, 2009</xref>; <xref rid="btu264-B9" ref-type="bibr">Gainza <italic>et al.</italic>, 2013</xref>).</p>
      <p>
        <boxed-text id="btu264-BOX2" position="float">
          <caption>
            <title><bold>Algorithm 2</bold> GA*: a GPU parallel A* algorithm for protein design</title>
          </caption>
          <p>1: <bold>procedure</bold> GA*(<italic>k</italic>, <italic>s</italic>, <italic>T</italic>)   ▹ <italic>k</italic> is the number of allocated</p>
          <p>2: <bold>for</bold>
<inline-formula><mml:math id="n10"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <italic>k</italic>
<underline>in parallel</underline>
<bold>do</bold>   ▹ priority queues, <italic>s</italic> is the</p>
          <p>3:  Let <italic>Q<sub>i</sub></italic> be a priority queue   ▹ starting node, and <italic>T</italic> is</p>
          <p>4:  <inline-formula><mml:math id="n11"><mml:mrow><mml:msub><mml:mi>Q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula>   ▹ the set of all target nodes,</p>
          <p>5: <bold>end for</bold></p>
          <p>6: P<sc>ush</sc>(<italic>Q</italic><sub>1</sub>, <italic>s</italic>)</p>
          <p>7: <inline-formula><mml:math id="n12"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:mtext>nil</mml:mtext></mml:mrow></mml:math></inline-formula>   ▹ <italic>t</italic> stores the best solution hitherto</p>
          <p>8: <bold>while</bold>
<inline-formula><mml:math id="n13"><mml:mrow><mml:mo>∃</mml:mo><mml:msub><mml:mi>Q</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that is not empty <bold>do</bold></p>
          <p>9:  <inline-formula><mml:math id="n14"><mml:mrow><mml:mi>R</mml:mi><mml:mo>←</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>10:  <bold>for</bold>
<italic>i</italic> be the index where <italic>Q<sub>i</sub></italic> is not empty <underline>in parallel</underline>
<bold>do</bold></p>
          <p>11:   <inline-formula><mml:math id="n15"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> P<sc>op</sc>(<italic>Q<sub>i</sub></italic>)</p>
          <p>12:   <bold>if</bold>
<inline-formula><mml:math id="n16"><mml:mrow><mml:msub><mml:mi>q</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p>
          <p>13:    <bold>if</bold>
<inline-formula><mml:math id="n17"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mtext>nil</mml:mtext></mml:mrow></mml:math></inline-formula>
<bold>or</bold>
<italic>f</italic>(<italic>p<sub>i</sub></italic>) &lt; <italic>f</italic>(<italic>t</italic>) <bold>then</bold></p>
          <p>14:     <inline-formula><mml:math id="n18"><mml:mrow><mml:mi>t</mml:mi><mml:mo>←</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></p>
          <p>15:    <bold>end if</bold></p>
          <p>16:    <bold>continue</bold></p>
          <p>17:   <bold>end if</bold></p>
          <p>18:   Let <italic>R′</italic> be the nodes expanded from <italic>q<sub>i</sub></italic>.</p>
          <p>19:   <inline-formula><mml:math id="n19"><mml:mrow><mml:mi>R</mml:mi><mml:mo>←</mml:mo><mml:mi>R</mml:mi><mml:mo>∪</mml:mo><mml:mi>R</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>20:  <bold>end for</bold></p>
          <p>21:  <bold>if</bold>
<inline-formula><mml:math id="n20"><mml:mrow><mml:mi>t</mml:mi><mml:mo>≠</mml:mo><mml:mtext>nil</mml:mtext></mml:mrow></mml:math></inline-formula>
<bold>and</bold>
<inline-formula><mml:math id="n21"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>⁡</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p>
          <p>22:   <bold>return</bold>
<italic>t</italic></p>
          <p>23:  <bold>end if</bold></p>
          <p>24:  Reorder the nodes in <italic>R</italic> ▹ See Section 2.6</p>
          <p>25:  Calculate <italic>f</italic>(<italic>x</italic>) for all nodes in <italic>R</italic>
<underline>in maximum parallel</underline></p>
          <p>26:  <bold>for</bold>
<inline-formula><mml:math id="n22"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <italic>k</italic>
<underline>in parallel</underline>
<bold>do</bold></p>
          <p>27:   Pick |<italic>R</italic>|/<italic>k</italic> nodes from <italic>R</italic> with different parents</p>
          <p>28:   Push them into <italic>Q<sub>i</sub></italic></p>
          <p>29:  <bold>end for</bold></p>
          <p>30: <bold>end while</bold></p>
          <p>31: <bold>end procedure</bold></p>
        </boxed-text>
      </p>
      <p>Note that the nodes to be expanded are not necessarily the most optimal nodes. For example, suppose we have two priority queues, and the 1st, 2nd, 3rd most optimal nodes are in the first priority queue while the 4th one is in the second queue. In this situation, our algorithm will pop out the 1st and 4th most optimal nodes, which is not an ideal situation. This is the price of the parallelism of the priority queue. We try to alleviate this problem by separating the nodes with the same parent nodes, which may have similar heuristic function values, to different queues.</p>
      <p>Because the parallelism of the priority queue changes the work flow of the overall A* algorithm, it is necessary to provide a proof to show that GA* is able to compute a global optimal solution. Here, our proof is derived mainly for the protein design problem, in which the underlying search graph is a tree.
<statement><title>L<sc>emma</sc> 2.1</title><p><italic>Let h<sub>r</sub>(x) represent the real cost from x to an optimum target node. If the defined heuristic function satisfies h(x) ≤ h<sub>r</sub>(x) for each node x and the search graph is a tree, for any optimal target </italic><inline-formula><mml:math id="n23"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula><italic>, there exists a node t′ in the priority queues {Q<sub>i</sub>} such that f(t′) ≤ f(t) in Algorithm 2 before each</italic> P<sc>op</sc>
<italic>operation is executed.</italic></p></statement>
<statement><title>P<sc>roof</sc></title><p>Let <italic>d</italic>(<italic>x</italic>,<italic>y</italic>) = <italic>g</italic>(<italic>y</italic>)– <italic>g</italic>(<italic>x</italic>) denote the real cost from node <italic>x</italic> to node <italic>y</italic>, where <italic>x</italic> must be on the path from the starting node <italic>s</italic> to <italic>y</italic>. For all node <italic>t′</italic> that is on the path from <italic>s</italic> to <italic>t</italic>, we have
<disp-formula><mml:math id="n24"><mml:mtable><mml:mtr><mml:mtd><mml:maligngroup/><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mtext>
</mml:mtext><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mo>≤</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>h</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mtext>
</mml:mtext><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mspace width=".9em"/><mml:mspace width=".3em"/><mml:mspace width=".9em"/><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mspace width=".9em"/><mml:mtext>
</mml:mtext><mml:mo>=</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:mtext>
</mml:mtext><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
</p></statement>
</p>
      <p>Thus, it is sufficient to prove that there exists a node <italic>t′</italic> in the priority queues along the path from <italic>s</italic> to <italic>t</italic>. At the beginning, the starting node <italic>s</italic> satisfies such a condition. At any time, if line 11 in Algorithm 2 pops node <italic>t′</italic>, line 18 will generate another node that is also on the path from <italic>s</italic> to <italic>t</italic>, which is then pushed back into the queues. Thus, such a node always exists.□
<statement><title>T<sc>heorem</sc> 2.2</title><p>Let h<sub>r</sub>(x) represent the real cost from x to an optimum target node. If the defined heuristic function satisfies h(x) ≤ h<sub>r</sub>(x) for every node x and the search graph is a tree, the first solution returned by GA* must be the optimal solution.</p></statement>
<statement><title>P<sc>roof</sc></title><p>We prove this theorem by contradiction. There exists two possible situations that may violate our conclusion:
<list list-type="order"><list-item><p>The algorithm never terminates; and</p></list-item><list-item><p>When the algorithm terminates, it returns a solution that is not optimal.</p></list-item></list>
</p></statement>
</p>
      <p>For (1), it is impossible because the search space is a finite tree and our algorithm will never visit any node twice.</p>
      <p>For (2), assume that our algorithm returns a node <italic>t</italic><sub>1</sub>, while the optimal solution is node <italic>t</italic><sub>2</sub>. Thus, we have <italic>f</italic>(<italic>t</italic><sub>1</sub>) &gt; <italic>f</italic>(<italic>t</italic><sub>2</sub>). However, according to Lemma 2.1, we have a node <italic>t′</italic> in the queues {<italic>Q<sub>i</sub></italic>} that satisfies <italic>f</italic>(<italic>t′</italic>) ≤ <italic>f</italic>(<italic>t</italic><sub>2</sub>) &lt; <italic>f</italic>(<italic>t</italic><sub>1</sub>), which violates the condition in line 21 of Algorithm 2.□</p>
      <p>Theorem 2.2 states that GA* guarantees to find the global optimal solution. However, GA* does not retain all the properties that the original version of A* search has. The optimality property (<xref rid="btu264-B4" ref-type="bibr">Dechter and Pearl, 1985</xref>), which guarantees that A* will expand fewer nodes than any other algorithm using the same heuristic function, is lost in GA*. The reason is that in GA*, it is possible to expand a node whose <italic>f</italic>(<italic>x</italic>) value is larger than the best solution due to the parallelism. However, as we will see in the Results section, the fraction of extra expanded nodes compared to the original A* algorithm is within an acceptable range.</p>
    </sec>
    <sec id="SEC2.5">
      <title>2.5 Memory-bounded A* search for protein design</title>
      <p>Although our parallel algorithm GA* can speed up the traditional A* algorithm by several orders of magnitude, the scale of the protein design problem that it can solve is still limited. For example, we may support at most 20 mutable residues if all types of amino acids are allowed in each residue. The bottleneck mainly lies in the limited memory available for each machine. In the worst case, A* produces an exponential number of expanded nodes in the search tree. Once the algorithm runs out of memory to store new expanded nodes, it cannot continue. Several efforts have been made to solve this problem. In particular, variants of the A* algorithm such as iterative deepening depth-first search (IDA*) (<xref rid="btu264-B15" ref-type="bibr">Korf, 1985</xref>) and simplified memory-bounded A* (SMA*) (<xref rid="btu264-B27" ref-type="bibr">Russell, 1992</xref>) have been proposed to address such an issue. IDA* uses a depth-first-search strategy to reduce the usage of memory, which is difficult to parallelize on a GPU. On the other hand, we found that SMA* could be well implemented on a GPU. We call this new algorithm GSMA*.</p>
      <p>SMA* is almost identical to a normal A* algorithm, with the only exception that if a new expanded node does not fit in memory, we simply throw away the least promising node in the queue, which has the worst <italic>f</italic>(<italic>x</italic>) value. Using this method, SMA* can still assure to generate the optimal solution when the memory is large enough for the original A* algorithm, while it may miss the optimal solution if the size of the priority queue exceeds the memory limit. In this case, although our algorithm cannot guarantee to find the GMEC solution, we can still know whether the solution returned by SMA* is a GMEC solution. This can be done by tracking the lowest <italic>f</italic>(<italic>x</italic>) value among all nodes that we have thrown away. If the energy of the returned solution is below this value, we know that SMA* finds the GMEC solution. Otherwise, we can report that the energy of the GMEC solution must lie in the interval between this value and energy of the solution found by SMA*.</p>
      <p>For GSMA*, when we run out of the memory, we first do a global scan operation (<xref rid="btu264-B29" ref-type="bibr">Sengupta <italic>et al.</italic>, 2007</xref>) to pick those nodes which are the leaves of the current searching tree, while freeing the memory occupied by the internal nodes that have already been expanded. Then a global sorting operation is performed over all the remaining nodes according to their <italic>f</italic>(<italic>x</italic>) values. Finally, we keep a user-specified percentage of nodes with the lowest <italic>f</italic>(<italic>x</italic>) values and then reconstruct the priority queues evenly, in which nodes are stratified by their heuristic function values.</p>
    </sec>
    <sec id="SEC2.6">
      <title>2.6 Implementation details</title>
      <p>Our new parallel A* search algorithm is implemented based on the current open-source protein design package OSPREY (<xref rid="btu264-B3" ref-type="bibr">Chen <italic>et al.</italic>, 2009</xref>; <xref rid="btu264-B9" ref-type="bibr">Gainza <italic>et al.</italic>, 2013</xref>). The CPU code is written in C and the GPU code is written in CUDA. As the OSPREY library is implemented in Java, we use Java Native Interface (JNI) to communicate with the native C program.</p>
      <p>At the beginning, our program copies the configuration and necessary information such as energy matrix and the original sequence from CPU memory to the global memory of a GPU. Then it allocates memory space for the nodes generated by GA* and a user-specified number of binary heaps. Each element in a binary heap stores a floating-point value of <italic>f</italic>(<italic>x</italic>) and a pointer to its corresponding node <italic>x</italic>.</p>
      <p>After initializing the GPU data structure, the GPU circulates among the four states as shown in <xref ref-type="fig" rid="btu264-F2">Figure 2</xref> until a valid solution is found. Compared to <xref ref-type="fig" rid="btu264-F1">Figure 1</xref>, we add a new R<sc>adix</sc>-S<sc>orting</sc> state.
<fig id="btu264-F2" position="float"><label>Fig. 2.</label><caption><p>Diagram of the GPU states</p></caption><graphic xlink:href="btu264f2"/></fig></p>
      <p>In the E<sc>xtraction</sc> phase, GA* launches a user-specified number of threads, each of which operates on its own priority queue and performs the D<sc>elete</sc>-M<sc>inimum</sc> operation to extract the node with the minimum <italic>f</italic>(<italic>x</italic>) value. Each priority queue is a vanilla binary heap. In addition, GA* checks whether the extracted node of the current thread is the optimal target node. Also, the expanding operation is done in this phase, which generates the children of the extracted nodes and then puts them into a global buffer.</p>
      <p>The second phase is R<sc>adix</sc>-S<sc>orting</sc>, which corresponds to line 24 in Algorithm 2. In this phase, the expanded nodes are sorted by their current depth, that is, the number of decided rotamers, before entering the E<sc>valuation</sc> phase. The major motivation for this phase is that the range of the loop during the calculation of <italic>f</italic>(<italic>x</italic>) heavily depends on the depth of the corresponding node in the search tree. Thus, after sorting, all the threads in a single SIMD unit of a GPU will tend to have the same length of the loop during the evaluation phase, which thus can reduce the branch divergence overhead and improve the efficiency of the parallelized computation of heuristic functions. There are several efficient sorting algorithms available for GPUs, such as (<xref rid="btu264-B28" ref-type="bibr">Satish <italic>et al.</italic>, 2009</xref>; <xref rid="btu264-B31" ref-type="bibr">Sintorn and Assarsson, 2008</xref>). As the number of elements to be sorted is not that large, we choose a classical and simple method, the GPU radix-sorting (<xref rid="btu264-B29" ref-type="bibr">Sengupta <italic>et al.</italic>, 2007</xref>), to perform this task.</p>
      <p>In the E<sc>valuation</sc> phase, GA* launches the same number of threads as the number of expanded nodes to calculate the heuristic function of each node in order to exploit the full floating-point operation capacity of a GPU. Our tests show that a GPU would spend more than 80% time in this phase. Thus parallelizing the calculation of heuristic functions in this phase can significantly reduce the running time of A* search for protein design. Section 2.3 explains more details about parallelizing computation of heuristic functions in this phase.</p>
      <p>In the final P<sc>ushing-</sc>B<sc>ack</sc> phase, GA* pushes all the expanded nodes with their heuristic function values back into the priority queues, using the classical <sc>insert</sc> procedure of a binary heap. In addition, GA* pushes the different expanded nodes into priority queues so that the sizes of these queues are balanced and the new expanded nodes with the same parents, which may have similar heuristic function values, are stored in different queues.</p>
    </sec>
  </sec>
  <sec>
    <title>3 RESULTS</title>
    <sec id="SEC3.1">
      <title>3.1 Parallel protein design</title>
      <p>In order to evaluate the performance of our new parallel A* algorithm, we performed several protein design experiments. The Results section is divided into two parts. In the first subsection, we will compare the running time and memory usage of our new algorithm GA* against the original A* algorithm for protein design. In the second subsection, we will evaluate the effectiveness of the combination of our parallel design algorithm GA* and the memory-bounded strategy (i.e., SMA*), by testing whether our algorithm is able to get a GMEC solution and calculating the proportion of recovered residues in <italic>native sequences recovery</italic>.</p>
      <p>In addition to the original A* search algorithm in OSPREY (<xref rid="btu264-B9" ref-type="bibr">Gainza <italic>et al.</italic>, 2013</xref>) and our parallel design algorithm GA*, we also implemented a single-thread version of the A* search algorithm on a CPU in C programming language using the new strategy of computing heuristic functions, as we have described in Section 2.2.1. There are two reasons for us to include this program in this benchmark. First, it measures improvement by using this new strategy to compute heuristic functions. Second, it is unfair to perform a direct comparison between algorithms implemented in Java and native machine code on a GPU, because the Java Virtual Machine and the garbage collection system may introduce a considerable amount of overhead.</p>
      <p>We used 74 protein core redesigns provided by (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>) as the test data. We used the same parameters as those in (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>), including the set of allowed amino acids and the number of mutable residues. We used iMinDEE (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>) as the DEE strategy to prune those rotamers that are provably not in the part of the global optimal solution. The iMinDEE algorithm can give a more accurate result on rotamer pruning, but results in a much larger conformation space for the downstream A* algorithm to search over to find the GMEC solution. Strictly speaking, we are not trying to find the GMEC solution in A* when using iMinDEE. We are trying to find the lowest-energy bound conformation for iMinDEE. But from the point view of an A* algorithm, it treats that job as same as finding the GMEC solution. So we will not distinguish these terminologies in the Results section. In this part of the experiment, memory-bounded operations were not performed. Because GA* is a provable algorithm (see Theorem 2.2 in Section 2.4), it can still guarantee to find the optimal solution. For correctness, we also verified that our results are completely identical to those of original OSPREY.</p>
      <p>The CPU and GPU we used in this benchmark test were an Intel Xeon<sup>TM</sup>E5-1620 3.6 GHz with 16 GB memory and an NVIDIA Tesla K20c GPU with 4.8 GB global memory and 2496 CUDA cores, respectively. The main point of this test is to measure the speed and the memory consumption of our algorithm, the results of which can be found in <xref ref-type="table" rid="btu264-T1">Tables 1</xref> and <xref ref-type="table" rid="btu264-T2">2</xref>, respectively. We ran the full experiment over all 74 protein structures, but we only show the list of the 10 slowest cases here as the others were finished too quickly even for the original A* algorithm implemented in OSPREY after rotamer pruning using iMinDEE. The results of all tests can be found in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">Tables S1</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">S2</ext-link> in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu264/-/DC1">Supplementary Material Section S3</ext-link>.
<table-wrap id="btu264-T1" position="float"><label>Table 1.</label><caption><p>The comparison results about time efficiency of our parallel against original versions of A* search for protein design</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">PDB</th><th rowspan="1" colspan="1">Space<xref ref-type="table-fn" rid="btu264-TF1"><sup>a</sup></xref></th><th rowspan="1" colspan="1">OSPREY<xref ref-type="table-fn" rid="btu264-TF1"><sup>b</sup></xref></th><th rowspan="1" colspan="1">A*1<xref ref-type="table-fn" rid="btu264-TF1"><sup>c</sup></xref></th><th rowspan="1" colspan="1">GA*768<xref ref-type="table-fn" rid="btu264-TF1"><sup>d</sup></xref></th><th rowspan="1" colspan="1">GA*4992<xref ref-type="table-fn" rid="btu264-TF1"><sup>d</sup></xref></th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1"><monospace>2QCP</monospace></td><td rowspan="1" colspan="1">2·10<sup>17</sup></td><td rowspan="1" colspan="1">21 551 916</td><td rowspan="1" colspan="1">51 091</td><td rowspan="1" colspan="1">3075</td><td rowspan="1" colspan="1">1146</td></tr><tr><td rowspan="1" colspan="1"><monospace>1XMK</monospace></td><td rowspan="1" colspan="1">2·10<sup>14</sup></td><td rowspan="1" colspan="1">247 585</td><td rowspan="1" colspan="1">2990</td><td rowspan="1" colspan="1">296</td><td rowspan="1" colspan="1">121</td></tr><tr><td rowspan="1" colspan="1"><monospace>1X6I</monospace></td><td rowspan="1" colspan="1">7·10<sup>13</sup></td><td rowspan="1" colspan="1">96 990</td><td rowspan="1" colspan="1">1406</td><td rowspan="1" colspan="1">138</td><td rowspan="1" colspan="1">73</td></tr><tr><td rowspan="1" colspan="1"><monospace>1UCS</monospace></td><td rowspan="1" colspan="1">6·10<sup>12</sup></td><td rowspan="1" colspan="1">88 135</td><td rowspan="1" colspan="1">1771</td><td rowspan="1" colspan="1">182</td><td rowspan="1" colspan="1">79</td></tr><tr><td rowspan="1" colspan="1"><monospace>1CC8</monospace></td><td rowspan="1" colspan="1">3·10<sup>14</sup></td><td rowspan="1" colspan="1">77 614</td><td rowspan="1" colspan="1">1078</td><td rowspan="1" colspan="1">99</td><td rowspan="1" colspan="1">53</td></tr><tr><td rowspan="1" colspan="1"><monospace>2CS7</monospace></td><td rowspan="1" colspan="1">8·10<sup>12</sup></td><td rowspan="1" colspan="1">64 187</td><td rowspan="1" colspan="1">1154</td><td rowspan="1" colspan="1">149</td><td rowspan="1" colspan="1">57</td></tr><tr><td rowspan="1" colspan="1"><monospace>2BWF</monospace></td><td rowspan="1" colspan="1">9·10<sup>13</sup></td><td rowspan="1" colspan="1">18 457</td><td rowspan="1" colspan="1">307</td><td rowspan="1" colspan="1">33</td><td rowspan="1" colspan="1">24</td></tr><tr><td rowspan="1" colspan="1"><monospace>1I27</monospace></td><td rowspan="1" colspan="1">7·10<sup>11</sup></td><td rowspan="1" colspan="1">8151</td><td rowspan="1" colspan="1">88</td><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1">16</td></tr><tr><td rowspan="1" colspan="1"><monospace>1T8K</monospace></td><td rowspan="1" colspan="1">2·10<sup>13</sup></td><td rowspan="1" colspan="1">6806</td><td rowspan="1" colspan="1">89</td><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1">15</td></tr><tr><td rowspan="1" colspan="1"><monospace>1R6J</monospace></td><td rowspan="1" colspan="1">2·10<sup>14</sup></td><td rowspan="1" colspan="1">6018</td><td rowspan="1" colspan="1">107</td><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1">21</td></tr></tbody></table><table-wrap-foot><fn id="btu264-TF1"><p><italic>Notes</italic>: Time was measured in <italic>millisecond</italic>. The results were sorted by the running time needed by OSPREY and only the 10 largest cases are listed here. <sup>a</sup>The second column, labeled with ‘Space’, reports the size of conformation search space after the rotamer pruning using iMinDEE. <sup>b</sup>The third column, labeled with ‘OSPREY’, reports the running time of the original A* algorithm in OSPREY implemented in Java. <sup>c</sup>The fourth column, labeled with ‘A*1’, reports the running time of our new implementation of a single-thread A* algorithm written in C programming language running on a CPU, which adopted the improved computation of heuristic functions, as described in Section 2.2.1. <sup>d</sup>The fifth and sixth columns, labeled with ‘GA*768’ and ‘GA*4992’, respectively, report the running time of two fully parallelized A* algorithms running on a GPU, whose numbers of parallel priority queues are 768 and 4992, respectively.</p></fn></table-wrap-foot></table-wrap>
<table-wrap id="btu264-T2" position="float"><label>Table 2.</label><caption><p>The comparison results about memory consumption of our parallel against original versions of A* search for protein design</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">PDB</th><th rowspan="1" colspan="1">Space</th><th rowspan="1" colspan="1">A*1</th><th rowspan="1" colspan="1">GA*768</th><th rowspan="1" colspan="1">GA*4992</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1"><monospace>2QCP</monospace></td><td rowspan="1" colspan="1">2·10<sup>17</sup></td><td rowspan="1" colspan="1">31 589 690</td><td rowspan="1" colspan="1">32 825 074</td><td rowspan="1" colspan="1">35 517 854</td></tr><tr><td rowspan="1" colspan="1"><monospace>1XMK</monospace></td><td rowspan="1" colspan="1">2·10<sup>14</sup></td><td rowspan="1" colspan="1">2 910 324</td><td rowspan="1" colspan="1">3 325 654</td><td rowspan="1" colspan="1">4 419 100</td></tr><tr><td rowspan="1" colspan="1"><monospace>1X6I</monospace></td><td rowspan="1" colspan="1">7·10<sup>13</sup></td><td rowspan="1" colspan="1">1 919 055</td><td rowspan="1" colspan="1">2 282 986</td><td rowspan="1" colspan="1">3 486 684</td></tr><tr><td rowspan="1" colspan="1"><monospace>1UCS</monospace></td><td rowspan="1" colspan="1">6·10<sup>12</sup></td><td rowspan="1" colspan="1">1 713 636</td><td rowspan="1" colspan="1">2 196 315</td><td rowspan="1" colspan="1">2 960 752</td></tr><tr><td rowspan="1" colspan="1"><monospace>1CC8</monospace></td><td rowspan="1" colspan="1">3·10<sup>14</sup></td><td rowspan="1" colspan="1">966 196</td><td rowspan="1" colspan="1">1 255 899</td><td rowspan="1" colspan="1">1 893 701</td></tr><tr><td rowspan="1" colspan="1"><monospace>2CS7</monospace></td><td rowspan="1" colspan="1">8·10<sup>12</sup></td><td rowspan="1" colspan="1">1 378 633</td><td rowspan="1" colspan="1">1 686 558</td><td rowspan="1" colspan="1">2 354 910</td></tr><tr><td rowspan="1" colspan="1"><monospace>2BWF</monospace></td><td rowspan="1" colspan="1">9·10<sup>13</sup></td><td rowspan="1" colspan="1">325 634</td><td rowspan="1" colspan="1">529 810</td><td rowspan="1" colspan="1">981 302</td></tr><tr><td rowspan="1" colspan="1"><monospace>1I27</monospace></td><td rowspan="1" colspan="1">7·10<sup>11</sup></td><td rowspan="1" colspan="1">121 920</td><td rowspan="1" colspan="1">260 825</td><td rowspan="1" colspan="1">737 328</td></tr><tr><td rowspan="1" colspan="1"><monospace>1T8K</monospace></td><td rowspan="1" colspan="1">2·10<sup>13</sup></td><td rowspan="1" colspan="1">129 767</td><td rowspan="1" colspan="1">211 003</td><td rowspan="1" colspan="1">618 794</td></tr><tr><td rowspan="1" colspan="1"><monospace>1R6J</monospace></td><td rowspan="1" colspan="1">2·10<sup>14</sup></td><td rowspan="1" colspan="1">117 053</td><td rowspan="1" colspan="1">244 399</td><td rowspan="1" colspan="1">837 359</td></tr></tbody></table><table-wrap-foot><fn><p><italic>Note</italic>: Each column has the same meaning as that in <xref ref-type="table" rid="btu264-T1">Table 1</xref> except that the numbers in last three columns represent the numbers of expanded nodes in different programs.</p></fn></table-wrap-foot></table-wrap></p>
      <p>In our GA* algorithm, the number of parallel priority queues, as described in Section 2.4, is a parameter that we can tune for the maximum performance. By increasing the number of priority queues, we can increase the degree of parallelism and further exploit the capability of the GPU hardware. On the other hand, when more parallel priority queues are used, the number of extra expanded nodes in the tree search compared to the original A* algorithm will also increase, which will cause both computation and memory overhead. In our computational experiments, we tested two choices of this parameter. One is 768, designed for the balance between time and space consumption. The other is 4992, targeting at maximizing the protein design speed.</p>
      <p>From <xref ref-type="table" rid="btu264-T1">Table 1</xref>, we found that our parallel A* algorithm GA* can speed up the original A*-based protein design algorithm by several orders of magnitude. For the largest protein design problem related to <monospace>2QCP</monospace>, the original A*-based protein design algorithm took ∼6 h, while GA*4992 (i.e., GA* algorithm that used 4992 parallel priority queues) was able to finish the search in 1.2 s. Such improvement is striking. In addition, as summarized in <xref ref-type="table" rid="btu264-T2">Table 2</xref>, the larger the conformation search space is, the more impact GA* will have. This is because for large problems, GA* is able to better exploit its parallelism, amortizing the overhead to a negligible level.</p>
      <p>Furthermore, the test results on the memory consumption of GA* (<xref ref-type="table" rid="btu264-T2">Table 2</xref>) were also promising. Although for small-scale protein design problems, memory consumption of GA*4992 was several times higher than that of a single-thread version, the discrepancy in memory consumption became more and more negligible when the conformation space scaled up. For the largest design problem related to <monospace>2QCP</monospace>, GA*4992 only generated 1.12 times more nodes than the single-thread algorithm. Therefore, such small growth of memory requirement was acceptable compared to the large improvement on time efficiency achieved by our algorithm.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Parallel protein design with bounded memory</title>
      <p>Memory limitation is always a problem when we are conducting large-scale protein design. Although GSMA* can solve this problem, it does not guarantee to generate a GMEC solution anymore. Therefore, it is necessary to evaluate the quality of its solutions when the memory resource is not sufficient. Researches have shown that the sequences of native proteins tend to optimize their core structures for stability (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>; <xref rid="btu264-B16" ref-type="bibr">Kuhlman and Baker, 2000</xref>). Therefore we included the <italic>native sequence recovery</italic> experiments, in which we removed the types of some amino acids from the core of the wild-type proteins and recorded the percentage of correctly recovered residues by the design algorithm as an indicator of its quality besides other direct critera.</p>
      <p>We randomly picked six PDBs from the protein sequence recovery dataset provided in (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>) to evaluate performance of our parallel GA* with limited memory (i.e., GSMA*). Unlike Section 3.1 in which we did not change any parameters on the original test dataset, this time we increased the number of mutable residues so that the total number of new nodes expanded by GA* just fitted the physical memory limit of the GPU without throwing any of them away, which had ∼3 × 10<sup>7</sup> nodes. We did this because we need to have a set of optimal solutions as a reference for comparison, and we hoped that all the test data had the similar memory consumption so that their performance was comparable. The method for choosing the set of allowed amino acids and the positions of extra mutable residues was as same as that in (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>).</p>
      <p>The number of parallel priority queues in this experiment was fixed to 768. We ran our experiments four times per test data. Each time we imposed a different restriction on the number of nodes that GSMA* was allowed to expand, which was 3 × 10<sup>4</sup>, 3 × 10<sup>5</sup>, 3 × 10<sup>6</sup> and 3 × 10<sup>7</sup>, respectively. These restrictions can be approximately considered as using 1000th, 1%, 10% and 100% of memory needed by GA*. Each time the system ran out of memory, 50% of the nodes with larger <italic>f</italic>(<italic>x</italic>) values were thrown away.</p>
      <p>We use four metrics to evaluate the quality of our algorithm. The first one is the availability of the GMEC solution. The second one is whether GSMA* is able to determine that the first solution it found is the GMEC solution. We have described this method in Section 2.5. The other two metrics are based on the first 50 solutions returned by A* rather than the GMEC solution. The third metric, correctness, measures the percentage of the top 50 solutions calculated with memory restriction that were also presented in the top 50 solutions calculated without such restriction. The fourth metric, recovery rate, reports the average percentage of amino acids in the top 50 solutions that are identical to those in the wild-type protein. <xref ref-type="table" rid="btu264-T3">Table 3</xref> shows the results.
<table-wrap id="btu264-T3" position="float"><label>Table 3.</label><caption><p>Performance of GSMA* with 768 parallel priority queues on 6 test datasets</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">PDB</th><th rowspan="1" colspan="1"><monospace>1OAI</monospace></th><th rowspan="1" colspan="1"><monospace>1U2H</monospace></th><th rowspan="1" colspan="1"><monospace>1ZZK</monospace></th><th rowspan="1" colspan="1"><monospace>2CS7</monospace></th><th rowspan="1" colspan="1"><monospace>2DSX</monospace></th><th rowspan="1" colspan="1"><monospace>3D3B</monospace></th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">No. of mutable residues</td><td rowspan="1" colspan="1">16</td><td rowspan="1" colspan="1">18</td><td rowspan="1" colspan="1">14</td><td rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1">15</td><td rowspan="1" colspan="1">15</td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">Conformation space</td><td rowspan="1" colspan="1">2·10<sup>22</sup></td><td rowspan="1" colspan="1">2·10<sup>20</sup></td><td rowspan="1" colspan="1">2·10<sup>15</sup></td><td rowspan="1" colspan="1">2·10<sup>23</sup></td><td rowspan="1" colspan="1">3·10<sup>20</sup></td><td rowspan="1" colspan="1">6·18<sup>18</sup></td></tr><tr><td rowspan="1" colspan="1"/><td rowspan="1" colspan="1">GA*768 search space<xref ref-type="table-fn" rid="btu264-TF2"><sup>a</sup></xref></td><td rowspan="1" colspan="1">4·10<sup>7</sup></td><td rowspan="1" colspan="1">8·10<sup>6</sup></td><td rowspan="1" colspan="1">8·10<sup>6</sup></td><td rowspan="1" colspan="1">4·10<sup>7</sup></td><td rowspan="1" colspan="1">4·10<sup>7</sup></td><td rowspan="1" colspan="1">3·10<sup>7</sup></td></tr><tr><td rowspan="5" colspan="1">3 × 10<sup>4</sup> nodes limit</td><td rowspan="1" colspan="1">Scan count<xref ref-type="table-fn" rid="btu264-TF2"><sup>b</sup></xref></td><td rowspan="1" colspan="1">252</td><td rowspan="1" colspan="1">104</td><td rowspan="1" colspan="1">99</td><td rowspan="1" colspan="1">202</td><td rowspan="1" colspan="1">182</td><td rowspan="1" colspan="1">109</td></tr><tr><td rowspan="1" colspan="1">GMEC gotten</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">NO</td></tr><tr><td rowspan="1" colspan="1">GMEC assured</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td></tr><tr><td rowspan="1" colspan="1">Correctness</td><td rowspan="1" colspan="1">4%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">20%</td><td rowspan="1" colspan="1">12%</td><td rowspan="1" colspan="1">32%</td><td rowspan="1" colspan="1">6%</td></tr><tr><td rowspan="1" colspan="1">Recovery ratio</td><td rowspan="1" colspan="1">62%</td><td rowspan="1" colspan="1">75%</td><td rowspan="1" colspan="1">85%</td><td rowspan="1" colspan="1">48%</td><td rowspan="1" colspan="1">46%</td><td rowspan="1" colspan="1">48%</td></tr><tr><td rowspan="5" colspan="1">3 × 10<sup>5</sup> nodes limit</td><td rowspan="1" colspan="1">Scan count<xref ref-type="table-fn" rid="btu264-TF2"><sup>b</sup></xref></td><td rowspan="1" colspan="1">139</td><td rowspan="1" colspan="1">43</td><td rowspan="1" colspan="1">36</td><td rowspan="1" colspan="1">103</td><td rowspan="1" colspan="1">97</td><td rowspan="1" colspan="1">55</td></tr><tr><td rowspan="1" colspan="1">GMEC gotten</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td></tr><tr><td rowspan="1" colspan="1">GMEC assured</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td><td rowspan="1" colspan="1">NO</td></tr><tr><td rowspan="1" colspan="1">Correctness</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">44%</td></tr><tr><td rowspan="1" colspan="1">Recovery ratio</td><td rowspan="1" colspan="1">74%</td><td rowspan="1" colspan="1">75%</td><td rowspan="1" colspan="1">87%</td><td rowspan="1" colspan="1">46%</td><td rowspan="1" colspan="1">48%</td><td rowspan="1" colspan="1">54%</td></tr><tr><td rowspan="5" colspan="1">3 × 10<sup>6</sup> nodes limit</td><td rowspan="1" colspan="1">Scan count<xref ref-type="table-fn" rid="btu264-TF2"><sup>b</sup></xref></td><td rowspan="1" colspan="1">22</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">3</td><td rowspan="1" colspan="1">24</td><td rowspan="1" colspan="1">22</td><td rowspan="1" colspan="1">18</td></tr><tr><td rowspan="1" colspan="1">GMEC gotten</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td></tr><tr><td rowspan="1" colspan="1">GMEC assured</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td></tr><tr><td rowspan="1" colspan="1">Correctness</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td></tr><tr><td rowspan="1" colspan="1">Recovery ratio</td><td rowspan="1" colspan="1">74%</td><td rowspan="1" colspan="1">75%</td><td rowspan="1" colspan="1">87%</td><td rowspan="1" colspan="1">46%</td><td rowspan="1" colspan="1">48%</td><td rowspan="1" colspan="1">53%</td></tr><tr><td rowspan="5" colspan="1">3 × 10<sup>7</sup> nodes limit</td><td rowspan="1" colspan="1">Scan count<xref ref-type="table-fn" rid="btu264-TF2"><sup>b</sup></xref></td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">0</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">GMEC gotten</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td></tr><tr><td rowspan="1" colspan="1">GMEC assured</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td><td rowspan="1" colspan="1">YES</td></tr><tr><td rowspan="1" colspan="1">Correctness</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td><td rowspan="1" colspan="1">100%</td></tr><tr><td rowspan="1" colspan="1">Recovery ratio</td><td rowspan="1" colspan="1">74%</td><td rowspan="1" colspan="1">75%</td><td rowspan="1" colspan="1">87%</td><td rowspan="1" colspan="1">46%</td><td rowspan="1" colspan="1">48%</td><td rowspan="1" colspan="1">53%</td></tr></tbody></table><table-wrap-foot><fn id="btu264-TF2"><p><italic>Note</italic>: The meaning of each row is explained either in the text or here. <sup>a</sup>The row labeled with ‘GA*768 search space’ represents the number of nodes expanded by GA*768 for calculating the best 50 solutions. <sup>b</sup>The rows labeled with ‘Scan Count’ represent the number of times that the system ran out of memory, in which a series of operations described in Section 2.5 were executed.</p></fn></table-wrap-foot></table-wrap></p>
      <p>The numbers reported in the row of GA*768 search space indicate that the numbers of new nodes expanded by parallel A* search did not exceed the memory limit of GPU so that the results computed without memory restriction can be used as references for evaluating their tests with memory restriction. We found that the native sequence recovery ratios of last three structures were a little low, even when no node was thrown away. Apart from that, the results look encouraging. The GMEC solution can be guaranteed by GSMA*768 on all our test data even if we only used ∼10% of memory required by GA*768. When we restricted the memory to 1%, GSMA*768 can still keep all GMEC solutions, though it cannot theoretically guarantee to find the GMEC solution in some cases.</p>
      <p>In the test with the restriction of 0.1% memory, the algorithm achieved relatively poor performance. In this case, the algorithm was only allow to keep 30 000 nodes in memory, which is unfriendly to parallel A*, as discussed in Section 3.1. When the absolute size of allowed memory is too small, it is more probable for GSMA* to throw away an important node at the beginning of the tree expansion. In practice, we will always use all available memory to perform the protein design task. So this setting was only for the evaluation purpose.</p>
    </sec>
  </sec>
  <sec>
    <title>4 CONCLUSION AND FUTURE WORK</title>
    <p>Computational protein design is a challenging problem in the computation biology field. In this article, we have developed an innovative method to improve the A* algorithm for computational protein design, which significantly reduces running time of the original protein design algorithm by up to four orders of magnitude while maintaining low memory overhead. Another advantage of our algorithm is that we do not change the interface of the original protein design framework in OSPREY (<xref rid="btu264-B9" ref-type="bibr">Gainza <italic>et al.</italic>, 2013</xref>). We have shown that it could be successfully integrated with iMinDEE (<xref rid="btu264-B8" ref-type="bibr">Gainza <italic>et al.</italic>, 2012</xref>) to further improve SCPR with the consideration of continuous side-chain flexibility.</p>
    <p>Memory limitation becomes a more important problem in protein design after A* is sped up. Thus, we introduce memory-bounded parallel A*, a variant of A* algorithm that only uses limited memory. In the Results section, we have shown that in practice, the memory-bounded parallel A* algorithm is able to <italic>guarantee</italic> the GMEC solution with only one-tenth of memory consumption that the original algorithm requires.</p>
    <p>Currently GA* is only implemented on the Tesla GPU card. It would be interesting to know whether it can achieve similar performance on a more affordable GPU card such as NVIDIA GeForce GTX series. In addition, although currently GA* is only runnable on a single GPU platform, it should be easy to port it to other parallel computational platforms due to the parallel characteristic of our algorithm. If we can utilize the existing large clusters of CPUs and GPUs to run GA*, in which more memory and computation resource is available, we will be able to solve a larger protein design problem than ever before.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We thank Mr Kyle Roberts and Mr Pablo Gainza for helping us set up the iMinDEE code and providing us the benchmark dataset and scripts for testing. We thank Mr Kyle Roberts and Mr Mark Hallen for their helpful comments on the draft of this article. We particularly thank Mr Kyle Roberts for his in-depth comments on the property of memory-bounded A*. We thank the anonymous reviewers for their helpful comments.</p>
    <p><italic>Funding</italic>: This work is supported in part by the <funding-source>National Basic Research Program of China</funding-source> (grant <award-id>2011CBA00300</award-id>, <award-id>2011CBA00301</award-id>) and the <funding-source>National Natural Science Foundation of China</funding-source> (grant <award-id>61033001</award-id>, <award-id>61361136003</award-id>). This work is supported by a grant to B.R.D. from the <funding-source>National Institutes of Health</funding-source> (<award-id>R01 GM-78031</award-id>).</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="btu264-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Althaus</surname>
            <given-names>E</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A combinatorial approach to protein docking with flexible side chains</article-title>
        <source>J. Comput. Biol.</source>
        <year>2002</year>
        <volume>9</volume>
        <fpage>597</fpage>
        <lpage>612</lpage>
        <pub-id pub-id-type="pmid">12323095</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chazelle</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A semidefinite programming approach to side chain positioning with new rounding strategies</article-title>
        <source>INFORMS J. Comput.</source>
        <year>2004</year>
        <volume>16</volume>
        <fpage>380</fpage>
        <lpage>392</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>C-Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Computational structure-based redesign of enzyme activity</article-title>
        <source>Proc. Natl Acad. Sci.</source>
        <year>2009</year>
        <volume>106</volume>
        <fpage>3764</fpage>
        <lpage>3769</lpage>
        <pub-id pub-id-type="pmid">19228942</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dechter</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Pearl</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Generalized best-first search strategies and the optimality of A*</article-title>
        <source>J. ACM (JACM)</source>
        <year>1985</year>
        <volume>32</volume>
        <fpage>505</fpage>
        <lpage>536</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Desmet</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The dead-end elimination theorem and its use in protein side-chain positioning</article-title>
        <source>Nature</source>
        <year>1992</year>
        <volume>356</volume>
        <fpage>539</fpage>
        <lpage>542</lpage>
        <pub-id pub-id-type="pmid">21488406</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B6">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Donald</surname>
            <given-names>BR</given-names>
          </name>
        </person-group>
        <source>Algorithms in Structural Molecular Biology</source>
        <year>2011</year>
        <publisher-loc>Cambridge, MA, USA</publisher-loc>
        <publisher-name>The MIT Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu264-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Frey</surname>
            <given-names>KM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Predicting resistance mutations using protein design algorithms</article-title>
        <source>Proc. Natl Acad. Sci.</source>
        <year>2010</year>
        <volume>107</volume>
        <fpage>13707</fpage>
        <lpage>13712</lpage>
        <pub-id pub-id-type="pmid">20643959</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gainza</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Protein design using continuous rotamers</article-title>
        <source>PLoS Comput. Biol.</source>
        <year>2012</year>
        <volume>8</volume>
        <fpage>e1002335</fpage>
        <pub-id pub-id-type="pmid">22279426</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gainza</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>OSPREY: protein design with ensembles, flexibility, and provable algorithms</article-title>
        <source>Method. Enzymol.</source>
        <year>2013</year>
        <volume>523</volume>
        <fpage>87</fpage>
      </element-citation>
    </ref>
    <ref id="btu264-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Georgiev</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Improved pruning algorithms and divide-and-conquer strategies for dead-end elimination, with application to protein design</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <fpage>e174</fpage>
        <lpage>e183</lpage>
        <pub-id pub-id-type="pmid">16873469</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Georgiev</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The minimized dead-end elimination criterion and its application to protein redesign in a hybrid scoring and search algorithm for computing partition functions over molecule ensembles</article-title>
        <source>J. Comput. Chem.</source>
        <year>2008</year>
        <volume>29</volume>
        <fpage>1527</fpage>
        <lpage>1542</lpage>
        <pub-id pub-id-type="pmid">18293294</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gorczynski</surname>
            <given-names>MJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Allosteric inhibition of the protein-protein interaction between the leukemia-associated proteins Runx1 and CBFβ</article-title>
        <source>Chem. Biol.</source>
        <year>2007</year>
        <volume>14</volume>
        <fpage>1186</fpage>
        <lpage>1197</lpage>
        <pub-id pub-id-type="pmid">17961830</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B13">
      <element-citation publication-type="book">
        <collab>Intel Corporation</collab>
        <source>Intel Microprocessor Export Compliance Metrics</source>
        <year>2011</year>
      </element-citation>
    </ref>
    <ref id="btu264-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kingsford</surname>
            <given-names>CL</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Solving and analyzing side-chain positioning problems using linear and integer programming</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <fpage>1028</fpage>
        <lpage>1039</lpage>
        <pub-id pub-id-type="pmid">15546935</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Korf</surname>
            <given-names>RE</given-names>
          </name>
        </person-group>
        <article-title>Depth-first iterative-deepening: an optimal admissible tree search</article-title>
        <source>Artif. Int.</source>
        <year>1985</year>
        <volume>27</volume>
        <fpage>97</fpage>
        <lpage>109</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kuhlman</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Baker</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Native protein sequences are close to optimal for their structures</article-title>
        <source>Proc. Natl Acad. Sci.</source>
        <year>2000</year>
        <volume>97</volume>
        <fpage>10383</fpage>
        <lpage>10388</lpage>
        <pub-id pub-id-type="pmid">10984534</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leach</surname>
            <given-names>AR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Exploring the conformational space of protein side chains using dead-end elimination and the A* algorithm</article-title>
        <source>Proteins Struct. Funct. Genet.</source>
        <year>1998</year>
        <volume>33</volume>
        <fpage>227</fpage>
        <lpage>239</lpage>
        <pub-id pub-id-type="pmid">9779790</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lilien</surname>
            <given-names>RH</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A novel ensemble-based scoring and search algorithm for protein redesign and its application to modify the substrate specificity of the gramicidin synthetase a phenylalanine adenylation enzyme</article-title>
        <source>J. Comput. Biol.</source>
        <year>2005</year>
        <volume>12</volume>
        <fpage>740</fpage>
        <lpage>761</lpage>
        <pub-id pub-id-type="pmid">16108714</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lippow</surname>
            <given-names>SM</given-names>
          </name>
          <name>
            <surname>Tidor</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Progress in computational protein design</article-title>
        <source>Curr. Opin. Biotechnol.</source>
        <year>2007</year>
        <volume>18</volume>
        <fpage>305</fpage>
        <lpage>311</lpage>
        <pub-id pub-id-type="pmid">17644370</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marvin</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Hellinga</surname>
            <given-names>HW</given-names>
          </name>
        </person-group>
        <article-title>Conversion of a maltose receptor into a zinc biosensor by computational design</article-title>
        <source>Proc. Natl Acad. Sci.</source>
        <year>2001</year>
        <volume>98</volume>
        <fpage>4955</fpage>
        <lpage>4960</lpage>
        <pub-id pub-id-type="pmid">11320244</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Moon</surname>
            <given-names>S-W</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Scalable hardware priority queue architectures for high-speed packet switches</article-title>
        <source>IEEE Trans. Comput.</source>
        <year>2000</year>
        <volume>49</volume>
        <fpage>1215</fpage>
        <lpage>1227</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B22">
      <element-citation publication-type="book">
        <collab>NVIDIA Corporation</collab>
        <source>NVIDIA Tesla Technical Specifications</source>
        <year>2013</year>
      </element-citation>
    </ref>
    <ref id="btu264-B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pierce</surname>
            <given-names>NA</given-names>
          </name>
          <name>
            <surname>Winfree</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Protein design is NP-hard</article-title>
        <source>Protein Eng.</source>
        <year>2002</year>
        <volume>15</volume>
        <fpage>779</fpage>
        <lpage>782</lpage>
        <pub-id pub-id-type="pmid">12468711</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pitman</surname>
            <given-names>DJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Improving computational efficiency and tractability of protein design using a piecemeal approach. A strategy for parallel and distributed protein design</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>1138</fpage>
        <lpage>1145</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B25">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>KE</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Computational design of a PDZ domain peptide inhibitor that rescues CFTR activity</article-title>
        <source>PLoS Comput. Biol.</source>
        <year>2012</year>
        <volume>8</volume>
        <fpage>e1002477</fpage>
        <pub-id pub-id-type="pmid">22532795</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rönngren</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Ayani</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>A comparative study of parallel and sequential priority queue algorithms</article-title>
        <source>ACM T. Model. Comput. S. (TOMACS)</source>
        <year>1997</year>
        <volume>7</volume>
        <fpage>157</fpage>
        <lpage>209</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B27">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Russell</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Efficient memory-bounded search methods</article-title>
        <source>Proceedings of the 10th European Conference on Artificial intelligence</source>
        <year>1992</year>
      </element-citation>
    </ref>
    <ref id="btu264-B28">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Satish</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Designing efficient sorting algorithms for manycore GPUs</article-title>
        <source>IEEE International Parallel &amp; Distributed Processing Symposium, 2009. IPDPS 2009</source>
        <year>2009</year>
        <fpage>1</fpage>
        <lpage>10</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B29">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Sengupta</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Fellner</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Spencer</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Scan primitives for GPU computing</article-title>
        <source>Proceedings of the 22nd ACM SIGGRAPH/EUROGRAPHICS symposium on Graphics hardware</source>
        <year>2007</year>
        <publisher-loc>Aire-la-Ville, Switzerland, Switzerland</publisher-loc>
        <publisher-name>Eurographics Association</publisher-name>
        <fpage>97</fpage>
        <lpage>106</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B30">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shah</surname>
            <given-names>PS</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Preprocessing of rotamers for protein design calculations</article-title>
        <source>J. Comput. Chem.</source>
        <year>2004</year>
        <volume>25</volume>
        <fpage>1797</fpage>
        <lpage>1800</lpage>
        <pub-id pub-id-type="pmid">15362137</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B31">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sintorn</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Assarsson</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>Fast parallel GPU-sorting using a hybrid algorithm</article-title>
        <source>J. Parallel Distr. Com.</source>
        <year>2008</year>
        <volume>68</volume>
        <fpage>1381</fpage>
        <lpage>1388</lpage>
      </element-citation>
    </ref>
    <ref id="btu264-B32">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Street</surname>
            <given-names>AG</given-names>
          </name>
          <name>
            <surname>Mayo</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Computational protein design</article-title>
        <source>Structure</source>
        <year>1999</year>
        <volume>7</volume>
        <fpage>R105</fpage>
        <lpage>R109</lpage>
        <pub-id pub-id-type="pmid">10378265</pub-id>
      </element-citation>
    </ref>
    <ref id="btu264-B33">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Xu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Berger</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate algorithms for protein side-chain packing</article-title>
        <source>J. ACM (JACM)</source>
        <year>2006</year>
        <volume>53</volume>
        <fpage>533</fpage>
        <lpage>557</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
