<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Algorithms Mol Biol</journal-id>
    <journal-title>Algorithms for molecular biology : AMB</journal-title>
    <issn pub-type="epub">1748-7188</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2147010</article-id>
    <article-id pub-id-type="publisher-id">1748-7188-2-10</article-id>
    <article-id pub-id-type="pmid">17877802</article-id>
    <article-id pub-id-type="doi">10.1186/1748-7188-2-10</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A basic analysis toolkit for biological sequences</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Giancarlo</surname>
          <given-names>Raffaele</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>raffaele@math.unipa.it</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Siragusa</surname>
          <given-names>Alessandro</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>alessandro.siragusa@gmail.com</email>
      </contrib>
      <contrib id="A3" contrib-type="author">
        <name>
          <surname>Siragusa</surname>
          <given-names>Enrico</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>enricos@imap.cc</email>
      </contrib>
      <contrib id="A4" contrib-type="author">
        <name>
          <surname>Utro</surname>
          <given-names>Filippo</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>filippo.utro@gmail.com</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Dipartimento di Matematica Applicazioni, Università di Palermo, Italy</aff>
    <pub-date pub-type="collection">
      <year>2007</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>18</day>
      <month>9</month>
      <year>2007</year>
    </pub-date>
    <volume>2</volume>
    <fpage>10</fpage>
    <lpage>10</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.almob.org/content/2/1/10"/>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>5</month>
        <year>2007</year>
      </date>
      <date date-type="accepted">
        <day>18</day>
        <month>9</month>
        <year>2007</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2007 Giancarlo et al; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2007</copyright-year>
      <copyright-holder>Giancarlo et al; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Giancarlo
               Raffaele
               
               raffaele@math.unipa.it
            </dc:author><dc:title>
            A basic analysis toolkit for biological sequences
         </dc:title><dc:date>2007</dc:date><dcterms:bibliographicCitation>Algorithms for Molecular Biology 2(1): 10-. (2007)</dcterms:bibliographicCitation><dc:identifier type="sici">1748-7188(2007)2:1&#x0003c;10&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1748-7188</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <p>This paper presents a software library, nicknamed BATS, for some basic sequence analysis tasks. Namely, local alignments, via approximate string matching, and global alignments, via longest common subsequence and alignments with affine and concave gap cost functions. Moreover, it also supports filtering operations to select strings from a set and establish their statistical significance, via z-score computation. None of the algorithms is new, but although they are generally regarded as fundamental for sequence analysis, they have not been implemented in a single and consistent software package, as we do here. Therefore, our main contribution is to fill this gap between algorithmic theory and practice by providing an extensible and easy to use software library that includes algorithms for the mentioned string matching and alignment problems. The library consists of C/C++ library functions as well as Perl library functions. It can be interfaced with Bioperl and can also be used as a stand-alone system with a GUI. The software is available at <ext-link ext-link-type="uri" xlink:href="http://www.math.unipa.it/~raffaele/BATS/"/> under the GNU GPL.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Computational analysis of biological sequences has became an extremely rich field of modern science and a highly interdisciplinary area, where statistical and algorithmic methods play a key role [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>]. In particular, sequence alignment tools have been at the hearth of this field for nearly 50 years and it is commonly accepted that the initial investigation of the mathematical notion of alignment and distance is one of the major contributions of S. Ulam to sequence analysis in molecular biology [<xref ref-type="bibr" rid="B3">3</xref>]. Moreover, alignment techniques have a wealth of applications in other domains, as pointed out for the first time in [<xref ref-type="bibr" rid="B4">4</xref>].</p>
    <p>Here we concentrate on alignment problems involving only two sequences. In general, they can be divided in two areas: local and global alignments [<xref ref-type="bibr" rid="B1">1</xref>]. Local alignment methods try to find regions of high similarity between two strings, e.g. BLAST [<xref ref-type="bibr" rid="B5">5</xref>], as opposed to global alignment methods that assess an overall structural similarity between the two strings, e.g. the Gotoh alignment algorithm [<xref ref-type="bibr" rid="B6">6</xref>]. However, at the algorithmic level, both classes often share the same ideas and techniques, being in most cases all based on dynamic programming algorithms and related speed-ups [<xref ref-type="bibr" rid="B7">7</xref>]. More in detail, we have implementations for (see also Fig. <xref ref-type="fig" rid="F1">1</xref> for the corresponding function in the GUI):</p>
    <fig position="float" id="F1">
      <label>Figure 1</label>
      <caption>
        <p><bold>a snapshot of the GUI</bold>. An overview of the GUI of BATS. The top bar has a specific button for each of the algorithms and functions implemented. Then, each function has its own parameter selection interface. The Edit Distance function interface is shown here.</p>
      </caption>
      <graphic xlink:href="1748-7188-2-10-1"/>
    </fig>
    <p>(a) Approximate string matching with <italic>k </italic>mismatches. That is, given a pattern and text string and an integer <italic>k</italic>, we are interested in finding all occurrences of the pattern in the text with at most <italic>k </italic>mismatching characters per occurrence. We provide an implementation of an algorithm given in [<xref ref-type="bibr" rid="B8">8</xref>]. It is a simplification of the first efficient algorithm obtained for this problem, due to Landau and Vishkin [<xref ref-type="bibr" rid="B9">9</xref>]. The asymptotically fastest known algorithm to date is due to Amir, Lewenstein and Porat [<xref ref-type="bibr" rid="B10">10</xref>]. Formalization of the problem, as well as description of the algorithm and library functions, both in C/C++ and Perl, is given in section 2.</p>
    <p>(b) Approximate string matching with <italic>k </italic>differences. That is, given a pattern and text string and an integer <italic>k</italic>, we are interested in finding all occurrences of the pattern in the text with at most <italic>k </italic>differences where, for each occurrence a "difference" is a character to be inserted, deleted or substituted in the pattern. We provide an implementation of the algorithm by Landau and Vishkin [<xref ref-type="bibr" rid="B11">11</xref>], although the asymptotically most efficient one, to date, has been recently obtained by Cole and Hariharan [<xref ref-type="bibr" rid="B12">12</xref>]. Formalization of the problem, as well as description of the algorithm and library functions, both in C/C++ and Perl, is given in section 3.</p>
    <p>(c) The longest common subsequence from fragments, a generalization of the well known longest common subsequence problem [<xref ref-type="bibr" rid="B1">1</xref>], considered by Baker and Giancarlo [<xref ref-type="bibr" rid="B13">13</xref>]. Formalization of the problem, as well as description of the algorithm and library functions, both in C/C++ and Perl, is given in section 4.</p>
    <p>(d) Edit distance with concave and affine gap penalties. It is the well known generalization of the edit distance between two strings introduced by M.S. Waterman [<xref ref-type="bibr" rid="B14">14</xref>], i.e., with the use of concave gap costs. We provide an implementation of the algorithm obtained by Galil and Giancarlo [<xref ref-type="bibr" rid="B15">15</xref>] (<bold>GG </bold>algorithm for short). An analogous algorithm was obtained independently by Miller and Myers [<xref ref-type="bibr" rid="B16">16</xref>]. We also point out that the asymptotically most efficient algorithm, to date, is still the one given by Klawe and Kleitman [<xref ref-type="bibr" rid="B17">17</xref>], although it seems to be mainly of theoretic interest. It is also worth mentioning that the <bold>GG </bold>algorithm naturally specializes to deal with affine gap costs. Formalization of the problem, as well as description of the algorithm and library functions, both in C/C++ and Perl, is given in section 5.</p>
    <p>(e) Filtering, statistical significance computation and organism model generation. The first two functions allow to select a subset of strings from a given set and to assess its statistical significance via z-score computation [<xref ref-type="bibr" rid="B18">18</xref>]. The third function is required in order to give to the first two, a probabilistic model of the input data. While the filtering techniques are quite standard, the implementation of the z-score computation is a specialization of a non-trivial implementation by Sinha and Tompa, used for motif discovery [<xref ref-type="bibr" rid="B19">19</xref>]. Our code, as the one by Sinha and Tompa, works only for DNA sequences. The function allowing for the generation of a user-specified model organism gives, in a suitable format, all probabilistic information needed by the z-score function. Description of this part of the system, as well as presentation of the corresponding library functions, both in C/C++ and Perl, is given in section 6.</p>
    <p>As it is self-evident from the description just given, this software library is not intended as a generic programming environment, like Leda for combinatorial and geometric computing [<xref ref-type="bibr" rid="B20">20</xref>]. An initial attempt, in that direction, for string algorithms is described in [<xref ref-type="bibr" rid="B21">21</xref>]. The software presented here is more tailored at specific alignment problems. We also point out that most of the algorithms implemented in BATS are based on suffix trees [<xref ref-type="bibr" rid="B22">22</xref>]. Here we use the algorithm by Ukkonen [<xref ref-type="bibr" rid="B23">23</xref>] in the Strmat library [<xref ref-type="bibr" rid="B24">24</xref>]. It is not particularly memory-efficient (17 bytes/character) and that may be problematic for genome-wide applications of the corresponding algorithms. We finally point out that the entire library can be used as a stand-alone system with a GUI and it can be interfaced with Bioperl. A detailed user manual, together with installation procedures, file formats etc., is given at the supplementary web site [<xref ref-type="bibr" rid="B25">25</xref>].</p>
  </sec>
  <sec>
    <title>2 Approximate string matching with <italic>k </italic>mismatches</title>
    <p>Given a text string <italic>text </italic>= <italic>t</italic>[1, <italic>n</italic>], a pattern string <italic>pattern </italic>= <italic>p</italic>[1, <italic>m</italic>] and an integer <italic>k</italic>, <italic>k </italic>≤ <italic>m </italic>≤ <italic>n</italic>, we are interested in finding all occurrences of the pattern in the text with at most <italic>k </italic>mismatches, i.e. with at most <italic>k </italic>locations in which the pattern and a text substring have different symbols.</p>
    <p>Let <italic>Prefix</italic>(<italic>i</italic>, <italic>j</italic>) be a function that returns the length of the longest common prefix between <italic>p</italic>[<italic>i</italic>, <italic>m</italic>] and <italic>t</italic>[<italic>j</italic>, <italic>n</italic>]. It can be computed in <italic>O</italic>(1) time, after the following preprocessing step: (A) build the suffix tree <italic>T </italic>[<xref ref-type="bibr" rid="B22">22</xref>] of the strings <italic>p</italic>[1, <italic>m</italic>]$<italic>t</italic>[1, <italic>n</italic>], where $ is a delimiter not appearing anywhere else in the two strings; (B) preprocess <italic>T </italic>so that Lowest Common Ancestor (LCA for short) queries can be answered in constant time [<xref ref-type="bibr" rid="B26">26</xref>]. The preprocessing step takes <italic>O</italic>(<italic>n </italic>+ <italic>m</italic>) time and it is well known that the computation of <italic>Prefix</italic>(<italic>i</italic>, <italic>j</italic>) reduces to the computation of one LCA query on the leaves of <italic>T </italic>[<xref ref-type="bibr" rid="B8">8</xref>].</p>
    <p>Once that the preprocessing step is completed, we can find the first (leftmost) mismatch between <italic>p</italic>[1, <italic>m</italic>] and <italic>t</italic>[<italic>j</italic>, <italic>j </italic>+ <italic>m </italic>- 1] in <italic>O</italic>(1) time by use of <italic>Prefix</italic>(1, <italic>j</italic>). If we keep track of where this mismatch occurs, say</p>
    <p>1: Algorithm <bold>SM</bold></p>
    <p>2: <bold>for </bold><italic>j </italic>= 1 <bold>to </bold><italic>n </italic><bold>do</bold></p>
    <p>3:    <italic>pt </italic>← <italic>j</italic>; <italic>v </italic>← 1; <italic>num_mismatch </italic>← 0;</p>
    <p>4:    **<italic>t</italic>[<italic>j</italic>, <italic>j </italic>+ <italic>m </italic>- 1] is aligned with <italic>p</italic>[1, <italic>m</italic>] and no mismatch has been found**</p>
    <p>5:    <bold>while </bold><italic>v </italic>≤ <italic>m </italic>- 1 <bold>and </bold><italic>num_mismatch </italic>≤ <italic>k </italic><bold>do</bold></p>
    <p>6:</p>
    <p>7:       **find leftmost mismatch between <italic>t</italic>[<italic>pt</italic>, <italic>pt </italic>+ <italic>m </italic>- 1] and <italic>p</italic>[<italic>v</italic>, <italic>m</italic>]**</p>
    <p>8:       ℓ ← <italic>Prefix</italic>(<italic>v</italic>, <italic>pt</italic>)</p>
    <p>9:       <bold>if </bold><italic>v </italic>+ ℓ ≤ <italic>m </italic><bold>then</bold></p>
    <p>10:          <italic>num_mismatch </italic>← <italic>num_mismatch </italic>+ 1</p>
    <p>11:       <bold>end if</bold></p>
    <p>12:       <italic>pt </italic>← <italic>pt </italic>+ ℓ + 1; <italic>v </italic>← <italic>v </italic>+ ℓ + 1;</p>
    <p>13:    <bold>end while</bold></p>
    <p>14:    <bold>if </bold><italic>num_mismatch </italic>≤ <italic>k </italic><bold>then</bold></p>
    <p>15:       <bold>found match</bold></p>
    <p>16:    <bold>end if</bold></p>
    <p>17: <bold>end for</bold></p>
    <p>at position <italic>l </italic>of <italic>pattern</italic>, we can locate the second mismatch, in <italic>O</italic>(1) time, by finding the leftmost mismatch between <italic>p</italic>[<italic>l </italic>+ 1, <italic>m</italic>] and <italic>t</italic>[<italic>j </italic>+ <italic>l </italic>- 1, <italic>j </italic>+ <italic>m </italic>- 1]. In general, the <italic>q</italic>-th mismatch between <italic>p</italic>[1, <italic>m</italic>] and <italic>t</italic>[<italic>j</italic>, <italic>j </italic>+ <italic>m </italic>- 1] can be found in <italic>O</italic>(1) time by knowing the location of the (<italic>q </italic>- 1)-th mismatch. Algorithm <bold>SM </bold>gives the needed pseudo-code. We have:</p>
    <p><bold>Theorem 2.1 </bold>[<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>]<italic>Given a pattern p and a text t of length m and n respectively, Algorithm </italic><bold>SM </bold><italic>finds all occurrences of p in t with at most k mismatches in O</italic>(<italic>m </italic>+ <italic>n </italic>+ <italic>nk</italic>) <italic>time, including the preprocessing step</italic>.</p>
    <sec>
      <title>2.1 The C/C++ library functions</title>
      <p>The function below returns all occurrences, with at most <italic>k </italic>mismatches, of a pattern within a text.</p>
      <p>Synopsis</p>
      <p>#include "k_mismatch.h"</p>
      <p>OCCURRENCES</p>
      <p><bold><underline>k_mismatch</underline></bold>(<underline>char</underline><italic><underline>*text</underline></italic>, <underline>char</underline><italic><underline>*pattern</underline></italic>, <underline>int </underline><italic><underline>k</underline></italic>);</p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic><underline>text</underline></italic>: points to a text string;</p>
      <p>• <italic><underline>pattern</underline></italic>: points to a pattern string;</p>
      <p>• <italic><underline>k</underline></italic>: is an integer giving the maximum number of allowed mismatches.</p>
      <p><bold>Return Values</bold>: <bold><underline>k_mismatch</underline></bold> returns a pointer to <underline>OCCURRENCES_STRUCT</underline>, defined as:</p>
      <p>typedef struct <underline>occurrences</underline></p>
      <p>{</p>
      <p>   <underline>int</underline><italic><underline> start</underline></italic>, <italic><underline>end</underline></italic>;</p>
      <p>   <underline>int</underline><italic><underline> errors</underline></italic>;</p>
      <p>   <underline>char</underline><italic><underline>*text</underline></italic>;</p>
      <p>   <underline>char</underline><italic><underline>*pattern</underline></italic>;</p>
      <p>struct <underline>occurrences</underline><italic><underline>*next</underline></italic>;</p>
      <p>} <underline>OCCURRENCES_STRUCT</underline>, <italic><underline>*OCCURRENCES</underline></italic>;</p>
      <p>where:</p>
      <p>• <italic><underline>start</underline></italic>: is the start position of this occurrence in the text string;</p>
      <p>• <italic><underline>end</underline></italic>: is the end position of this occurrence in the text string;</p>
      <p>• <italic><underline>errors</underline></italic>: the number of mismatches of this occurrence;</p>
      <p>• <italic><underline>text</underline></italic>: is a pointer to the aligned substring corresponding to the occurrence found;</p>
      <p>• <italic><underline>pattern</underline></italic>: is a pointer to the aligned pattern string.</p>
    </sec>
    <sec>
      <title>2.2 The PERL library functions</title>
      <p>The function below returns all occurrences, with at most <italic>k </italic>mismatches, of a pattern within a text.</p>
      <p>Synopsis</p>
      <p>use BSAT::K_Mismatch;</p>
      <p>K_Mismatch <italic>Text Pattern K</italic></p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic>Text</italic>: is a scalar containing the text string;</p>
      <p>• <italic>Pattern</italic>: is a scalar containing the pattern string;</p>
      <p>• <italic>K</italic>: is a scalar giving the maximum number of allowed mismatches.</p>
      <p><bold>Return values: </bold>The function returns an array of occurrences. Each occurrence consists of a hash:</p>
      <p>my %occurrence = (</p>
      <p>   errors =&gt; 0,</p>
      <p>   start =&gt; 0,</p>
      <p>   end =&gt; 0,</p>
      <p>   text =&gt; "",</p>
      <p>   pattern =&gt; "");</p>
      <p>where the above fields are as in the <underline>OCCURRENCES_STRUCT</underline> defined earlier.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Approximate string matching with <italic>k </italic>differences</title>
    <p>In this section we consider a more general problem of approximate string matching by extending the set of allowed differences between strings. Letting <italic>text</italic>, <italic>pattern </italic>and <italic>k </italic>be as in section 2, we are interested in finding all occurrences of <italic>pattern </italic>in <italic>text </italic>with at most <italic>k </italic>differences. The allowed differences are:</p>
    <p>(a) A symbol of the pattern corresponds to a different symbol of the text, i.e., a mismatch.</p>
    <p>(b) A symbol of the pattern corresponds to no symbol in the text.</p>
    <p>(c) A symbol of the text corresponds to no symbol in the pattern.</p>
    <p>Let <italic>A </italic>be an (<italic>m </italic>+ 1) × (<italic>n </italic>+ 1) dynamic programming matrix and consider the following recurrence:</p>
    <p>
      <disp-formula id="bmcM1"><italic>A</italic>[0, <italic>j</italic>] = 0, 0 ≤ <italic>j </italic>&lt;<italic>n</italic>.</disp-formula>
    </p>
    <p>
      <disp-formula id="bmcM2"><italic>A</italic>[<italic>i</italic>, 0] = <italic>i</italic>, 0 ≤ <italic>i </italic>&lt;<italic>m</italic>.</disp-formula>
    </p>
    <p>
      <disp-formula id="bmcM3"><italic>A</italic>[<italic>i</italic>, <italic>j</italic>] = <italic>min</italic>(<italic>A</italic>[<italic>i </italic>- 1, <italic>j</italic>] + 1, <italic>A</italic>[<italic>i</italic>, <italic>j </italic>- 1] + 1, <italic>if p</italic>[<italic>i</italic>] = <italic>t</italic>[<italic>j</italic>] <italic>then A</italic>[<italic>i </italic>- 1, <italic>j </italic>- 1] <italic>else A</italic>[<italic>i </italic>- 1, <italic>j </italic>- 1] + 1).</disp-formula>
    </p>
    <p>Matrix <italic>A </italic>can be computed row by row, or column by column, in <italic>O</italic>(<italic>nm</italic>) time. Moreover, it can be easily shown that <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] is the minimal edit distance between <italic>p</italic>[1, <italic>i</italic>] and a substring of <italic>text </italic>ending at position <italic>j</italic>. Thus, it follows that there is an occurrence of the pattern in the text ending at position <italic>j </italic>of the text if and only if <italic>A</italic>[<italic>m</italic>, <italic>j</italic>] ≤ <italic>k</italic>. The computation of <italic>A </italic>can be substantially sped-up by observing that, for any <italic>i </italic>and <italic>j</italic>, either <italic>A</italic>[<italic>i </italic>+ 1, <italic>j </italic>+ 1] = <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] or <italic>A</italic>[<italic>i </italic>+ 1, <italic>j </italic>+ 1] = <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] + 1. That is, the elements along any diagonal of <italic>A </italic>form a non-decreasing sequence of integers. Thus, the computation of <italic>A </italic>can be performed by finding, for all diagonals, the rows in which <italic>A</italic>[<italic>i </italic>+ 1, <italic>j </italic>+ 1] = <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] + 1 ≤ <italic>k</italic>. Such an observation was exploited by Ukkonen [<xref ref-type="bibr" rid="B27">27</xref>] in order to obtain a space efficient algorithm for the computation of the edit distance between two strings. Landau and Vishkin [<xref ref-type="bibr" rid="B11">11</xref>] cleverly extended the method by Ukkonen to obtain an efficient algorithm that handles the more general problem of string matching with <italic>k </italic>differences. We present their algorithm here, although the asymptotically most efficient one, to date, has been recently obtained by Cole and Hariharan [<xref ref-type="bibr" rid="B12">12</xref>].</p>
    <p>Let <italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>denote the largest row <italic>i </italic>such that <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] = <italic>e </italic>and <italic>j </italic>- <italic>i </italic>= <italic>d</italic>. The definition of <italic>L</italic><sub><italic>d</italic>, <italic>e </italic></sub>implies that <italic>e </italic>is the minimal number of differences between <italic>p</italic>[1, <italic>L</italic><sub><italic>d</italic>,<italic>e</italic></sub>] and the substrings of the text ending at <italic>t</italic>[<italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>+ <italic>d</italic>], with <italic>p</italic>[<italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>+ 1] ≠ <italic>t</italic>[<italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>+ <italic>d </italic>+ 1]. In order to solve the <italic>k </italic>differences problem, we need to compute the values of <italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>that satisfy <italic>e </italic>≤ <italic>k</italic>. Assuming that <italic>L</italic><sub><italic>d</italic>+1,<italic>e</italic>-1</sub>, <italic>L</italic><sub><italic>d</italic>-1,<italic>e</italic>-1 </sub>and <italic>L</italic><sub><italic>d</italic>,<italic>e</italic>-1 </sub>have been correctly computed, <italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>is computed as follows. Let <italic>row </italic>= <italic>max</italic>(<italic>L</italic><sub><italic>d</italic>+1,<italic>e</italic>-1 </sub>+ 1, <italic>L</italic><sub><italic>d</italic>-1,<italic>e</italic>-1</sub>, <italic>L</italic><sub><italic>d</italic>,<italic>e</italic>-1 </sub>+ 1) and let ℓ be the largest integer such that <italic>p</italic>[<italic>row </italic>+ 1, <italic>row </italic>+ ℓ] = <italic>t</italic>[<italic>d </italic>+ <italic>row </italic>+ 1, <italic>d </italic>+ <italic>row </italic>+ ℓ]. Then, <italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>= <italic>row </italic>+ ℓ. The proof of correctness of such a computation is a simple exercise, left to the reader. Moreover, if one makes use of the preprocessing algorithms presented in section 2, <italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>can be computed in <italic>O</italic>(1) time as follows:</p>
    <p><italic>L</italic><sub><italic>d</italic>,<italic>e </italic></sub>= <italic>row </italic>+ <italic>Prefix</italic>(<italic>row </italic>+ 1, <italic>row </italic>+ <italic>d </italic>+ 1). Algorithm <bold>SD </bold>gives the needed pseudo-code. We have:</p>
    <p><bold>Theorem 3.1 </bold>[<xref ref-type="bibr" rid="B11">11</xref>]<italic>Given a pattern p and a text t, of length m and n, respectively, Algorithm </italic><bold>SD </bold><italic>finds all occurrences of p in t with at most k differences in O</italic>(<italic>m </italic>+ <italic>n </italic>+ <italic>nk</italic>) <italic>time, including the preprocessing step</italic>.</p>
    <sec>
      <title>3.1 The C/C++ library functions</title>
      <p>The function below returns all occurrences of a pattern within a text with at most k differences.</p>
      <p>Synopsis</p>
      <p>#include " k_difference.h"</p>
      <p>OCCURRENCES</p>
      <p><bold><underline>k_difference</underline></bold> (<underline>char</underline><italic><underline>*text</underline></italic>, <underline>char</underline><italic><underline>*pattern</underline></italic>, <underline>int</underline><italic><underline>k</underline></italic>);</p>
      <p><bold>Arguments</bold>: As in function <bold><underline>k_mismatch</underline></bold></p>
      <p><bold>Return Values</bold>: As in function <bold><underline>k_mismatch</underline></bold></p>
      <p>1: Algorithm <bold>SD</bold></p>
      <p>2: **Initial Conditions Start Here**</p>
      <p>3: <bold>for </bold><italic>d </italic>:= 0 <bold>to </bold><italic>n </italic><bold>do</bold></p>
      <p>4:    <italic>L</italic>[<italic>d</italic>, -1] ← -1</p>
      <p>5: <bold>end for</bold></p>
      <p>6: <bold>for </bold><italic>d </italic>:= -(<italic>k </italic>+ 1) <bold>to </bold>-1 <bold>do</bold></p>
      <p>7:    <italic>L</italic>[<italic>d</italic>, |<italic>d</italic>| - 1] ← |<italic>d</italic>| - 1</p>
      <p>8:    <italic>L</italic>[<italic>d</italic>, |<italic>d</italic>| - 2] ← |<italic>d</italic>| - 2</p>
      <p>9: <bold>end for</bold></p>
      <p>10: <bold>for </bold><italic>e </italic>:= -1 <bold>to </bold><italic>k </italic><bold>do</bold></p>
      <p>11:    <italic>L</italic>[<italic>n </italic>+ 1, <italic>e</italic>] ← -1</p>
      <p>12: <bold>end for</bold></p>
      <p>13: **Initial Conditions End Here**</p>
      <p>14: <bold>for </bold><italic>e </italic>:= 0 <bold>to </bold><italic>k </italic><bold>do</bold></p>
      <p>15:    <bold>for </bold><italic>d </italic>:= -<italic>e </italic><bold>to </bold><italic>n </italic><bold>do</bold></p>
      <p>16:       <italic>row </italic>← max(<italic>L</italic>[<italic>d</italic>, <italic>e </italic>- 1] + 1, <italic>L</italic>[<italic>d </italic>- 1, <italic>e </italic>- 1], <italic>L</italic>[<italic>d </italic>+ 1, <italic>e </italic>- 1] + 1</p>
      <p>17:       <italic>row </italic>← min(<italic>row</italic>, <italic>m</italic>)</p>
      <p>18:       <bold>if </bold><italic>row </italic>&lt;<italic>m </italic><bold>and </bold><italic>row </italic>+ <italic>d </italic>&lt;<italic>n </italic><bold>then</bold></p>
      <p>19:          <italic>row </italic>← <italic>row </italic>+ <italic>Prefix</italic>(<italic>row </italic>+ 1, <italic>row </italic>+ <italic>d </italic>+ 1)</p>
      <p>20:       <bold>end if</bold></p>
      <p>21:       <italic>L</italic>[<italic>d</italic>, <italic>e</italic>] ← <italic>row</italic></p>
      <p>22:       <bold>if </bold><italic>L</italic>[<italic>d</italic>, <italic>e</italic>] = <italic>m </italic><bold>and </bold><italic>d </italic>+ <italic>m </italic>≤ <italic>n </italic><bold>then</bold></p>
      <p>23:          **Occurrence Found**</p>
      <p>24:       <bold>end if</bold></p>
      <p>25:    <bold>end for</bold></p>
      <p>26: <bold>end for</bold></p>
    </sec>
    <sec>
      <title>3.2 The PERL library functions</title>
      <p>The function below returns all occurrences of a pattern within a text with at most k differences.</p>
      <p>Synopsis</p>
      <p>use BSAT::K_Difference;</p>
      <p>K_Difference <italic>Text Pattern K</italic></p>
      <p><bold>Arguments</bold>: As in function <bold><underline>K_Mismatch</underline></bold></p>
      <p><bold>Return values: </bold>As in function <bold><underline>K_Mismatch</underline></bold></p>
    </sec>
  </sec>
  <sec>
    <title>4 Longest common subsequence from fragments</title>
    <p>In this section we consider the problem of identifying a longest common subsequence (LCS for short) of two strings <italic>X </italic>and <italic>Y</italic>, using a set <italic>M </italic>of matching fragments. That is, strings of a given length that appear in both <italic>X </italic>and <italic>Y</italic>. We start by reviewing some basic notions about LCS computation and relate them to approximate string matching, discussed in sections 2 and 3. Then, we outline the algorithm presented in [<xref ref-type="bibr" rid="B13">13</xref>].</p>
    <sec>
      <title>4.1 LCS from fragments and edit graphs</title>
      <p>It is well known that finding the LCS of <italic>X </italic>and <italic>Y </italic>is equivalent to finding the Levenshtein edit distance between the two strings [<xref ref-type="bibr" rid="B4">4</xref>], where the "edit operations" are insertion and deletion of a single character. Those edit operations naturally correspond to the differences of type (b) and (c) introduced in section 3 for approximate string matching. Although there is analogy between approximate string matching and LCS computation, the former can be regarded as a local alignment method as opposed to the latter, that is a global alignment method [<xref ref-type="bibr" rid="B1">1</xref>]. Following Myers [<xref ref-type="bibr" rid="B28">28</xref>], we phrase the LCS problem as the computation of a shortest path in the edit graph for <italic>X </italic>and <italic>Y</italic>, defined as follows. It is a directed grid graph (see Fig. <xref ref-type="fig" rid="F2">2</xref>) with vertices (<italic>i</italic>, <italic>j</italic>), where 0 ≤ <italic>i </italic>≤ <italic>n </italic>and 0 ≤ <italic>j </italic>≤ <italic>m</italic>, |<italic>X</italic>| = <italic>n </italic>and |<italic>Y</italic>| = <italic>m</italic>. We refer to the vertices also as <italic>points</italic>. There is a vertical edge from each non-bottom point to its neighbor below. There is a horizontal edge from each non-rightmost point to its right neighbor. Finally, if <italic>X</italic>[<italic>i</italic>] = <italic>Y</italic>[<italic>j</italic>], there is a diagonal edge from (<italic>i </italic>- 1, <italic>j </italic>- 1) to (<italic>i</italic>, <italic>j</italic>). Assume that each non-diagonal edge has weight 1 and the remaining edges weight 0. Then, the Levenshtein edit distance is given by the minimum cost of any path from (0, 0) to (<italic>n</italic>, <italic>m</italic>). We assume the reader to be familiar with the notion of edit script corresponding to the min-cost path and how to recover an LCS from an edit script [<xref ref-type="bibr" rid="B28">28</xref>-<xref ref-type="bibr" rid="B30">30</xref>]. Our LCS from Fragments problem also corresponds naturally to an edit graph. The vertices and the horizontal and vertical edges are as before, but the diagonal edges correspond to a given set of fragments. Each fragment, formally described as a triple (<italic>i</italic>, <italic>j</italic>, <italic>k</italic>), represents a sequence of diagonal edges from (<italic>i </italic>- <italic>j </italic>- 1) (the <italic>start </italic>point) to (<italic>i </italic>+ <italic>k </italic>- 1, <italic>j </italic>+ <italic>k </italic>- 1) (the <italic>end </italic>point). For a fragment <italic>f</italic>, the start and end points of <italic>f </italic>are denoted by <italic>start</italic>(<italic>f</italic>) and <italic>end</italic>(<italic>f</italic>), respectively. In the example of Figure <xref ref-type="fig" rid="F3">3</xref>, the fragments are the sequences of at least 2 diagonal edges of Fig. <xref ref-type="fig" rid="F2">2</xref>. The LCS from Fragments problem is equivalent to finding a minimum-cost path in the edit graph from (0, 0) to (<italic>n</italic>, <italic>m</italic>), where each diagonal edge has weight 0 and each non-diagonal edge has weight 1. The problem has an obvious dynamic programming solution since the graph naturally corresponds to an <italic>nxm </italic>dynamic programming matrix. However, it also falls into the more efficient algorithmic paradigm of Sparse Dynamic Programming [<xref ref-type="bibr" rid="B31">31</xref>,<xref ref-type="bibr" rid="B32">32</xref>], as discussed in [<xref ref-type="bibr" rid="B13">13</xref>] and outlined next.</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p><bold>an edit graph</bold>. An edit graph for the strings <italic>X </italic>= <italic>CDABAC </italic>and <italic>Y </italic>= <italic>ABCABBA</italic>. It naturally corresponds to a <bold>DP </bold>matrix. The bold path from (0, 0) to (6, 7) gives an edit script from which we can recover the LCS between <italic>X </italic>and <italic>Y</italic>.</p>
        </caption>
        <graphic xlink:href="1748-7188-2-10-2"/>
      </fig>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>an edit graph with fragments</bold>. An LCS from Fragments edit graph for the same strings as in Figure 2, where the fragments are the sequences of at least two diagonal edges of Figure 2. The bold path from (0, 0) to (6, 7) corresponds to a minimum-cost path under the Levenshtein edit distance.</p>
        </caption>
        <graphic xlink:href="1748-7188-2-10-3"/>
      </fig>
      <p>For a point <italic>p</italic>, define <italic>x</italic>(<italic>p</italic>) and <italic>y</italic>(<italic>p</italic>) to be the <italic>x</italic>- and <italic>y</italic>- coordinates of <italic>p</italic>, respectively. We also refer to <italic>x</italic>(<italic>p</italic>) as the <italic>row </italic>of <italic>p </italic>and <italic>y</italic>(<italic>p</italic>) as the <italic>column </italic>of <italic>p</italic>. Define the diagonal number of <italic>f </italic>to be <italic>d</italic>(<italic>f</italic>) = <italic>y</italic>(<italic>start</italic>(<italic>f</italic>)) - <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)).</p>
      <p>We say a fragment <italic>f' </italic>is <italic>left of start</italic>(<italic>f</italic>) if some point of <italic>f' </italic>besides <italic>start</italic>(<italic>f'</italic>) is to the left of <italic>start</italic>(<italic>f</italic>) on a horizontal line through <italic>start</italic>(<italic>f</italic>), or <italic>start</italic>(<italic>f</italic>) lies on <italic>f' </italic>and <italic>x</italic>(<italic>start</italic>(<italic>f'</italic>)) &lt;<italic>x</italic>(<italic>start</italic>(<italic>f</italic>)). (In the latter case, <italic>f </italic>and <italic>f' </italic>are in the same diagonal and overlap.) A fragment <italic>f' </italic>is <italic>above start</italic>(<italic>f</italic>) if some point of <italic>f' </italic>besides <italic>start</italic>(<italic>f'</italic>) is strictly above <italic>start</italic>(<italic>f</italic>) on a vertical line through <italic>start</italic>(<italic>f</italic>).</p>
      <p>Define <italic>visl</italic>(<italic>f</italic>) to be the first fragment to the left of <italic>start</italic>(<italic>f</italic>) if such exists, and undefined otherwise. Define <italic>visa</italic>(<italic>f</italic>) to be the first fragment above <italic>start</italic>(<italic>f</italic>) if such exists, and undefined otherwise.</p>
      <p>We say that fragment <italic>f </italic>precedes fragment <italic>f' </italic>if <italic>x</italic>(<italic>end</italic>(<italic>f</italic>)) &lt;<italic>x</italic>(<italic>start</italic>(<italic>f'</italic>)) and <italic>y</italic>(<italic>end</italic>(<italic>f</italic>)) &lt;<italic>y</italic>(<italic>start</italic>(<italic>f'</italic>)), i.e. if the end point of <italic>f </italic>is strictly inside the rectangle with opposite corners (0, 0) and <italic>start</italic>(<italic>f'</italic>).</p>
      <p>Suppose that fragment <italic>f </italic>precedes fragment <italic>f'</italic>. The shortest path from <italic>end</italic>(<italic>f</italic>) to <italic>start</italic>(<italic>f'</italic>) with no diagonal edges has cost <italic>x</italic>(<italic>start</italic>(<italic>f'</italic>)) - <italic>x</italic>(<italic>end</italic>(<italic>f</italic>)) + <italic>y</italic>(<italic>start</italic>(<italic>f'</italic>)) - <italic>y</italic>(<italic>end</italic>(<italic>f</italic>)), and the minimum cost of any path from (0, 0) to <italic>start</italic>(<italic>f'</italic>) through <italic>f </italic>is that value plus <italic>mincost</italic><sub>0</sub>(<italic>f</italic>). It will be helpful to separate out the part of this cost that depends on <italic>f </italic>by the definition <italic>Z</italic>(<italic>f</italic>) = <italic>mincost</italic><sub>0</sub>(<italic>f</italic>) - <italic>x</italic>(<italic>end</italic>(<italic>f</italic>)) - <italic>y</italic>(<italic>end</italic>(<italic>f</italic>)). Note that <italic>Z</italic>(<italic>f</italic>) ≤ 0 since <italic>mincost</italic><sub>0</sub>(<italic>f</italic>) ≤ <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)) + <italic>y</italic>(<italic>start</italic>(<italic>f</italic>)). The following lemma states that we can compute LCS from fragments by considering only end-points of some fragments rather than all points in the dynamic programming matrix. Moreover, it also gives the appropriate recurrence relations that we need to compute.</p>
      <p><bold>Lemma 4.1 </bold>[<xref ref-type="bibr" rid="B13">13</xref>]<italic>For any fragment f and any point p on f, mincost</italic><sub>0</sub>(<italic>p</italic>) = <italic>mincost</italic><sub>0</sub>(<italic>start</italic>(<italic>f</italic>)).</p>
      <p><italic>Moreover, mincost</italic><sub>0</sub>(<italic>f</italic>) <italic>is the minimum of x</italic>(<italic>start</italic>(<italic>f</italic>)) + <italic>y</italic>(<italic>start</italic>(<italic>f</italic>)) <italic>and any of c<sub>p</sub>, c<sub>l</sub>, and c<sub>a </sub>that are defined according to the following:</italic></p>
      <p><italic>1. If at least one fragment precedes f, c</italic><sub><italic>p </italic></sub>= <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)) + <italic>y</italic>(<italic>start</italic>(<italic>f</italic>)) + min{<italic>Z</italic>(<italic>f'</italic>): <italic>f' </italic><italic>precedes f</italic>}.</p>
      <p><italic>2. If visl</italic>(<italic>f</italic>) <italic>is defined, c</italic><sub><italic>l </italic></sub>= <italic>mincost</italic><sub>0</sub>(<italic>visl</italic>(<italic>f</italic>))+<italic>d</italic>(<italic>f</italic>) - <italic>d</italic>(<italic>visl</italic>(<italic>f</italic>));</p>
      <p><italic>3. If visa</italic>(<italic>f</italic>) <italic>is defined, c</italic><sub><italic>a </italic></sub>= <italic>mincost</italic><sub>0</sub>(<italic>visa</italic>(<italic>f</italic>)) + <italic>d</italic>(<italic>visa</italic>(<italic>f</italic>)) - <italic>d</italic>(<italic>f</italic>);</p>
    </sec>
    <sec>
      <title>4.2 Outline of the algorithm</title>
      <p>Based on Lemma 4.1, we now present the main steps of the algorithm in [<xref ref-type="bibr" rid="B13">13</xref>] computing the required optimal path, given a list <italic>M </italic>of fragments (represented as triples of integers). It uses a sweepline approach where successive rows are processed, and within rows, points are processed from left to right. Lexicographic sorting of (<italic>x</italic>, <italic>y</italic>)-values is needed. The algorithm consists of two main phases, one in which it computes visibility information, i.e., <italic>visl</italic>(<italic>f</italic>) and <italic>visa</italic>(<italic>f</italic>) for each fragment <italic>f</italic>, and the other in which it computes Recurrences (1)–(3) in Lemma 4.1.</p>
      <p>Not all the rows and columns need contain a start point or end point, and we generally wish to skip empty rows and columns for efficiency. For any <italic>x </italic>(<italic>y</italic>, resp.), let <italic>C</italic>(<italic>x</italic>) (<italic>R</italic>(<italic>y</italic>), resp.) be the <italic>i </italic>for which <italic>x </italic>is in the <italic>i</italic>-th non-empty column (row, resp.). These values can be calculated in the same time bounds as the lexicographic sorting. From now on, we assume that the algorithm processes only nonempty rows and columns.</p>
      <p>For the lexicographic sorting and both phases, we assume the existence of a data structure of type <italic>D </italic>that stores integers <italic>j </italic>in some range [0, <italic>u</italic>] and supports the following operations: (1) insert, (2) delete, (3) member, (4) min, (5) successor: given <italic>j</italic>, the next larger value than <italic>j </italic>in <italic>D</italic>, (6) max: given <italic>j</italic>, find the max value less than <italic>j </italic>in <italic>D</italic>. In our toolkit, <italic>D </italic>is implemented via balanced trees [<xref ref-type="bibr" rid="B33">33</xref>]. Therefore, if <italic>d </italic>elements are stored in it, each operation takes <italic>O</italic>(log <italic>d</italic>) time. More complex schemes are proposed and analyzed in [<xref ref-type="bibr" rid="B13">13</xref>], yielding better asymptotic performance. With the mentioned data structures, lexicographic sorting of (<italic>x</italic>, <italic>y</italic>)-values can be done in <italic>O</italic>(<italic>d </italic>log <italic>d</italic>) time. In our case <italic>u </italic>≤ <italic>n </italic>+ <italic>m </italic>and <italic>d </italic>≤ |<italic>M</italic>|.</p>
      <p>• <bold>Visibility Computation</bold>. We now briefly outline how to compute <italic>visl</italic>(<italic>f</italic>) and <italic>visa</italic>(<italic>f</italic>) for each fragment <italic>f </italic>via a sweepline algorithm. We describe the computation of <italic>visl</italic>(<italic>f</italic>); that for <italic>visa</italic>(<italic>f</italic>) is similar. For <italic>visl</italic>(<italic>f</italic>), the sweepline algorithm sweeps along successive rows. Assume that we have reached row <italic>i</italic>. We keep all fragments crossing row <italic>i </italic>sorted by diagonal number in a data structure <italic>V</italic>. For each fragment <italic>f </italic>such that <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)) = <italic>i</italic>, we record the fragment <italic>f' </italic>to the left of <italic>start</italic>(<italic>f</italic>) in the sorted list of fragments; in this case, <italic>visl</italic>(<italic>f</italic>) = <italic>f'</italic>. Then, for each fragment <italic>f </italic>with <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)) = <italic>i</italic>, we insert <italic>f </italic>into <italic>V</italic>. Finally, we remove fragments <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1748-7188-2-10-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacuWGMbGzgaqcaaaa@2E11@</mml:annotation></mml:semantics></mml:math></inline-formula> such that <italic>y</italic>(<italic>end</italic>(<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1748-7188-2-10-i1" overflow="scroll"><mml:semantics definitionURL="" encoding=""><mml:mover accent="true"><mml:mi>f</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacuWGMbGzgaqcaaaa@2E11@</mml:annotation></mml:semantics></mml:math></inline-formula>)) = <italic>i</italic>. If the data structure <italic>V </italic>is implemented as a balanced search tree, the total time for this computation is <italic>O</italic>(<italic>M </italic>log <italic>M</italic>).</p>
      <p>• <bold>The Main Algorithm</bold>. Again, we use a sweepline approach of processing successive rows. It follows the same paradigm as the Hunt-Szymanski LCS algorithm [<xref ref-type="bibr" rid="B34">34</xref>] and the computation of the <italic>RNA </italic>secondary structure (with linear cost functions) [<xref ref-type="bibr" rid="B31">31</xref>].</p>
      <p>We use another data structure <italic>B </italic>of type <italic>D</italic>, but this time <italic>B </italic>stores column numbers (and a fragment associated with each one). The values stored in <italic>B </italic>will represent the columns at which the minimum value of <italic>Z</italic>(<italic>f</italic>) decreases compared to any columns to the left, i.e. the columns containing an end point of a fragment <italic>f </italic>for which <italic>Z</italic>(<italic>f</italic>) is smaller than <italic>Z</italic>(<italic>f'</italic>) for any <italic>f' </italic>whose end point has already been processed and which is in a column to the left. Notice that, once we fix a row, <italic>D </italic>gives a partition of that row in terms of columns. Within a row, first process any start points in the row from left to right. For each start point of a fragment, compute <italic>mincost</italic><sub>0 </sub>using Lemma 4.1. Note that when the start point of a fragment <italic>f </italic>is computed, <italic>mincost</italic><sub>0 </sub>has already been computed for each fragment that precedes <italic>f </italic>and each fragment that is <italic>visa</italic>(<italic>f</italic>) or <italic>visl</italic>(<italic>f</italic>). To find the minimum value of <italic>Z</italic>(<italic>f'</italic>) over all predecessors <italic>f' </italic>of <italic>f</italic>, the data structure <italic>B </italic>is used. The minimum relevant value for <italic>Z</italic>(<italic>f'</italic>) is obtained from <italic>B </italic>by using the max operation to find the max <italic>j </italic>&lt;<italic>y</italic>(<italic>start</italic>(<italic>f</italic>)) in <italic>B</italic>; the fragment <italic>f' </italic>associated with that <italic>j </italic>is one for which <italic>Z</italic>(<italic>f'</italic>) is the minimum (based on endpoints processed so far) over all columns to the left of the column containing <italic>start</italic>(<italic>f</italic>), and in fact this value of <italic>Z</italic>(<italic>f'</italic>) is the</p>
      <p>1: Algorithm <bold>FLCS</bold></p>
      <p>2: For each fragment <italic>f</italic>, compute <italic>visl</italic>(<italic>f</italic>) and <italic>visa</italic>(<italic>f</italic>)</p>
      <p>3: <bold>for </bold><italic>i </italic>= <italic>R</italic>(0) to <italic>R</italic>(<italic>n</italic>) <bold>do</bold></p>
      <p>4:    <bold>for </bold>each fragment <italic>f </italic>s.t. <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)) = <italic>i </italic><bold>do</bold></p>
      <p>5:       <italic>f' </italic>← max on <italic>B </italic>with key <italic>y</italic>(<italic>start</italic>(<italic>f</italic>))</p>
      <p>6:       <bold>if </bold><italic>f' </italic>is defined <bold>then</bold></p>
      <p>7:          compute <italic>cp</italic></p>
      <p>8:       <bold>end if</bold></p>
      <p>9:       <bold>if </bold><italic>visl</italic>(<italic>f</italic>) is defined <bold>then</bold></p>
      <p>10:          compute <italic>cl</italic></p>
      <p>11:       <bold>end if</bold></p>
      <p>12:       <bold>if </bold><italic>visa</italic>(<italic>f</italic>) is defined <bold>then</bold></p>
      <p>13:          compute <italic>ca</italic></p>
      <p>14:       <bold>end if</bold></p>
      <p>15:       compute <italic>mincost</italic>(<italic>f</italic>)</p>
      <p>16:    <bold>end for</bold></p>
      <p>17:    <bold>for </bold>each fragment <italic>f </italic>s.t. <italic>x</italic>(<italic>start</italic>(<italic>f</italic>)) = <italic>i </italic><bold>do</bold></p>
      <p>18:       <italic>f' </italic>← max on <italic>B </italic>with key <italic>y</italic>(<italic>end</italic>(<italic>f</italic>)) + 1</p>
      <p>19:       <bold>if </bold><italic>f' </italic>is not defined <bold>or </bold><italic>Z</italic>(<italic>f</italic>) &lt;<italic>Z</italic>(<italic>f'</italic>) <bold>then</bold></p>
      <p>20:          INSERT <italic>f </italic>into <italic>B </italic>with key <italic>y</italic>(<italic>end</italic>(<italic>f</italic>))</p>
      <p>21:       <bold>end if</bold></p>
      <p>22:       <bold>for </bold>each fragment <italic>f' </italic>:= SUCCESSOR(<italic>f</italic>) in <italic>B </italic>such that <italic>Z</italic>(<italic>f'</italic>) ≤ <italic>Z</italic>(<italic>f</italic>) <bold>do</bold></p>
      <p>23:          DELETE(<italic>f'</italic>) from <italic>B</italic></p>
      <p>24:       <bold>end for</bold></p>
      <p>25:    <bold>end for</bold></p>
      <p>26: <bold>end for</bold></p>
      <p>minimum value over all predecessors of <italic>f</italic>.</p>
      <p>After any start points for a row have been processed, process the end points. When an end point of a fragment <italic>f </italic>is processed, <italic>B </italic>is updated as necessary if <italic>Z</italic>(<italic>f</italic>) represents a new minimum value at the column <italic>y</italic>(<italic>end</italic>(<italic>f</italic>)); successor and deletion operations may be needed to find and remove any values that have been superseded by the new minimum value. Algorithm <bold>FLCS </bold>gives the pseudo-code of the method just outlined, with the visibility computation omitted for conciseness. In conclusion, we have:</p>
      <p><bold>Theorem 4.2 </bold>[<xref ref-type="bibr" rid="B13">13</xref>]<italic>Suppose X </italic>[1 : <italic>n</italic>] <italic>and Y </italic>[1 : <italic>m</italic>] <italic>are strings, and a set M of fragments relating substrings of X and Y is given. One can compute the LCS from Fragments in O</italic>(|<italic>M</italic>|log|<italic>M</italic>|) <italic>time and O</italic>(|<italic>M</italic>|) <italic>space using standard balanced search tree schemes</italic>.</p>
    </sec>
    <sec>
      <title>4.3 The C/C++ library functions</title>
      <p>The function below computes the longest common subsequence from fragments and returns the corresponding alignment.</p>
      <p>Synopsis</p>
      <p>#include "flcs.h"</p>
      <p>ALIGNMENTS</p>
      <p><bold><underline>flcs</underline></bold> (<underline>char</underline><italic><underline>*X</underline></italic>, <underline>char</underline><italic><underline>*Y</underline></italic>, <underline>FRAGSET</underline><italic><underline>M</underline></italic>);</p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic><underline>X</underline></italic>: points to a string;</p>
      <p>• <italic><underline>Y</underline></italic>: points to a string;</p>
      <p>• <italic><underline>M</underline></italic>: point to a <underline>FRAGSET_STRUCT</underline>, that represents a set of fragments.</p>
      <p><bold>Return Values</bold>: A pointer to <underline>ALIGNMENTS_STRUCT</underline>, which is defined as:</p>
      <p>typedef struct <underline>alignments</underline></p>
      <p>{</p>
      <p>   <underline>double </underline><italic><underline>distance</underline></italic>;</p>
      <p>   <underline>char</underline><italic><underline>*X</underline></italic>;</p>
      <p>   <underline>char</underline><italic><underline>*Y</underline></italic>;</p>
      <p>struct <underline>alignments</underline><italic><underline>*next</underline></italic>;</p>
      <p>} <underline>ALIGNMENTS_STRUCT</underline>, <italic><underline>*ALIGNMENTS</underline></italic>;</p>
      <p>where:</p>
      <p>• <italic><underline>distance</underline></italic>: is the Levenshtein Distance between strings <italic><underline>X</underline></italic>and <italic><underline>Y</underline></italic>, computed using only fragments;</p>
      <p>• <italic><underline>X</underline></italic>: is a pointer to the aligned string <italic><underline>X</underline></italic>, i.e., the string with appropriate spacers inserted;</p>
      <p>• <italic><underline>Y</underline></italic>: is a pointer to the aligned string <italic><underline>Y</underline></italic>with appropriate spacers inserted.</p>
      <p>One can create a set of fragments from all the matching <italic>k</italic>-tuples between <italic><underline>X</underline></italic>and <italic><underline>Y</underline></italic>, using the function:</p>
      <p>FRAGSET</p>
      <p><bold><underline>fragset_create_ktuples </underline></bold>(<underline>char</underline><italic><underline>*X</underline></italic>, <underline>char</underline><italic><underline>*Y</underline></italic>, <underline>int</underline><italic><underline>k</underline></italic>);</p>
      <p>where:</p>
      <p>• <italic><underline>X</underline></italic>: points to string;</p>
      <p>• <italic><underline>Y</underline></italic>: points to a string;</p>
      <p>• <italic><underline>k</underline></italic>: is the fragment length.</p>
      <p>Auxiliary functions destroying, creating or incrementally updating a set of fragments are the following:</p>
      <p>void</p>
      <p><bold><underline>fragset_destroy</underline></bold>(<underline>FRAGSET</underline><italic><underline> fragset</underline></italic>);</p>
      <p>FRAGSET</p>
      <p><bold><underline>fragset_create</underline></bold>(<underline>int</underline><italic><underline>*max_cardinality</underline></italic>);</p>
      <p>int</p>
      <p><bold><underline>fragset_frag_add</underline></bold>(<underline>FRAGSET </underline><italic><underline>fragset</underline></italic>, <underline>int </underline><italic><underline>i</underline></italic>, <underline>int</underline><italic><underline> j</underline></italic>, <underline>int</underline><italic><underline> length</underline></italic>);</p>
      <p>where</p>
      <p>• <italic><underline>fragset</underline></italic>:points to FRAGSET_STRUCT;</p>
      <p>• <italic><underline>i</underline></italic>: fragment starting position in the first string <italic><underline>X</underline></italic>;</p>
      <p>• <italic><underline>j</underline></italic>: fragment starting position in the second string <italic><underline>Y</underline></italic>;</p>
      <p>• <italic><underline>length</underline></italic>: fragment length.</p>
    </sec>
    <sec>
      <title>4.4 The PERL library functions</title>
      <p>The function FLCS computes the longest common subsequence from fragments. It returns the corresponding alignment.</p>
      <p>Synopsis</p>
      <p>use BSAT::FLCS;</p>
      <p>FLCS <italic>X Y Frags</italic></p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic>X</italic>: is a scalar containing string X.</p>
      <p>• <italic>Y</italic>: is a scalar containing string Y.</p>
      <p>• <italic>Frags</italic>: is a hash reference (see below).</p>
      <p><bold>Return values: </bold>FLCS returns a hash corresponding to the alignment between X and Y:</p>
      <p>my %alignment = (</p>
      <p>   distance =&gt; 0,</p>
      <p>   X =&gt; "",</p>
      <p>   Y =&gt; "");</p>
      <p>where:</p>
      <p>• distance: is a scalar containing the Levenshtein Distance between strings <italic><underline>X</underline></italic>and <italic><underline>Y</underline></italic>, computed using only fragments;</p>
      <p>• X: is a scalar containing the alignment string X;</p>
      <p>• Y: is a scalar containing the alignment string Y.</p>
      <p>The hash reference Frags is defined as:</p>
      <p>my %Frags = (</p>
      <p>   K =&gt; 0,</p>
      <p>   Set =&gt; ());</p>
      <p>where:</p>
      <p>• K: is a scalar giving the fragment length;</p>
      <p>• Set: is an array of three elements (<italic>i</italic>, <italic>j</italic>, <italic>length</italic>) specifying a fragment.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Edit distance with gaps</title>
    <sec>
      <title>5.1 The dynamic programming recurrences</title>
      <p>We refer to the edit operations of substitution of one symbol for another (point mutation), deletion of a single symbol, and insertion of a single symbol as <italic>basic operations</italic>. They are related in a natural way to the differences introduced in section 3. Let a <italic>gap </italic>be a consecutive set of deleted symbols in one string or inserted symbols in the other string. With the basic set of operations, the cost of a gap is the sum of the costs of the individual insertions or deletions which compose it. Therefore, a gap is considered as a sequence of homogeneous elementary events (insertion or deletion) rather than as an elementary event itself. But, both theoretic and experimental considerations [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B14">14</xref>,<xref ref-type="bibr" rid="B35">35</xref>], suggest that the cost <italic>w</italic>(<italic>i</italic>, <italic>j</italic>) of a generic gap <italic>X</italic>[<italic>i</italic>, <italic>j</italic>] must be of the form</p>
      <p>
        <disp-formula id="bmcM4"><italic>w</italic>(<italic>i</italic>, <italic>j</italic>) = <italic>f</italic><sup>1</sup>(<italic>X</italic>[<italic>i</italic>]) + <italic>f</italic><sup>2</sup>(<italic>X</italic>[<italic>j</italic>]) + <italic>g</italic>(<italic>j </italic>- <italic>i</italic>)</disp-formula>
      </p>
      <p>where <italic>f</italic><sup>1 </sup>and <italic>f</italic><sup>2 </sup>are the costs of breaking the string at the endpoints of the gap and <italic>g </italic>is a function that increases with the gap length.</p>
      <p>In molecular biology, the most likely choices for <italic>g </italic>are affine or concave functions of the gap lengths, e.g., <italic>g</italic>(ℓ) = <italic>c</italic><sub>1 </sub>+ <italic>c</italic><sub>2</sub>ℓ or <italic>g</italic>(ℓ) = <italic>c</italic><sub>1 </sub>+ <italic>c</italic><sub>2 </sub>log ℓ, where <italic>c</italic><sub>1 </sub>and <italic>c</italic><sub>2 </sub>are constants. With such a choice of <italic>g</italic>, the cost of a long gap is less than or equal to the sums of the costs of any partition of the gap into smaller gaps. That is, each gap is treated as a unit. Such constraint on <italic>g </italic>induces a constraint on the function <italic>w</italic>. Indeed, <italic>w </italic>must satisfy the following inequality, known as <italic>concave Monge condition </italic>[<xref ref-type="bibr" rid="B7">7</xref>]:</p>
      <p>
        <disp-formula id="bmcM5"><italic>w</italic>(<italic>a</italic>, <italic>c</italic>) + <italic>w</italic>(<italic>b</italic>, <italic>d</italic>) ≥ <italic>w</italic>(<italic>b</italic>, <italic>c</italic>) + <italic>w</italic>(<italic>a</italic>, <italic>d</italic>) for all <italic>a </italic>&lt;<italic>b </italic>and <italic>c </italic>&lt;<italic>d</italic>.</disp-formula>
      </p>
      <p>an extremely useful inequality that yields speed-ups in Dynamic Programming [<xref ref-type="bibr" rid="B7">7</xref>].</p>
      <p>The gap sequence alignment problem can be solved by computing the following dynamic programming equation (<italic>w' </italic>is a cost function analogous to <italic>w</italic>):</p>
      <p>
        <disp-formula id="bmcM6"><italic>D</italic>[<italic>i</italic>, <italic>j</italic>] = min{<italic>D</italic>[<italic>i </italic>- 1, <italic>j </italic>- 1] + <italic>sub</italic>(<italic>X</italic>[<italic>i</italic>], <italic>Y</italic>[<italic>j</italic>]), <italic>E</italic>[<italic>i</italic>, <italic>j</italic>], <italic>F</italic>[<italic>i</italic>, <italic>j</italic>]}</disp-formula>
      </p>
      <p>where</p>
      <p>
        <disp-formula id="bmcM7">
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3" name="1748-7188-2-10-i2" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>E</mml:mi>
                <mml:mrow>
                  <mml:mo>[</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mo>]</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:munder>
                  <mml:mrow>
                    <mml:mi>min</mml:mi>
                    <mml:mo>⁡</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>0</mml:mn>
                    <mml:mo>≤</mml:mo>
                    <mml:mi>k</mml:mi>
                    <mml:mo>≤</mml:mo>
                    <mml:mi>j</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mi>D</mml:mi>
                    <mml:mrow>
                      <mml:mo>[</mml:mo>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>k</mml:mi>
                      </mml:mrow>
                      <mml:mo>]</mml:mo>
                    </mml:mrow>
                    <mml:mo>+</mml:mo>
                    <mml:mi>w</mml:mi>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mi>k</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGfbqrdaWadaqaaiabdMgaPjabcYcaSiabdQgaQbGaay5waiaaw2faaiabg2da9maaxababaGagiyBa0MaeiyAaKMaeiOBa4galeaacqaIWaamcqGHKjYOcqWGRbWAcqGHKjYOcqWGQbGAcqGHsislcqaIXaqmaeqaaOWaaiWabeaacqWGebardaWadaqaaiabdMgaPjabcYcaSiabdUgaRbGaay5waiaaw2faaiabgUcaRiabdEha3naabmaabaGaem4AaSMaeiilaWIaemOAaOgacaGLOaGaayzkaaaacaGL7bGaayzFaaGaeiilaWcaaa@52D2@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>
        <disp-formula id="bmcM8">
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4" name="1748-7188-2-10-i3" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mi>F</mml:mi>
                <mml:mrow>
                  <mml:mo>[</mml:mo>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mo>]</mml:mo>
                </mml:mrow>
                <mml:mo>=</mml:mo>
                <mml:munder>
                  <mml:mrow>
                    <mml:mi>min</mml:mi>
                    <mml:mo>⁡</mml:mo>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mn>0</mml:mn>
                    <mml:mo>≤</mml:mo>
                    <mml:mi>l</mml:mi>
                    <mml:mo>≤</mml:mo>
                    <mml:mi>i</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:mn>1</mml:mn>
                  </mml:mrow>
                </mml:munder>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mrow>
                    <mml:mi>D</mml:mi>
                    <mml:mrow>
                      <mml:mo>[</mml:mo>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                      <mml:mo>]</mml:mo>
                    </mml:mrow>
                    <mml:mo>+</mml:mo>
                    <mml:msup>
                      <mml:mi>w</mml:mi>
                      <mml:mo>′</mml:mo>
                    </mml:msup>
                    <mml:mrow>
                      <mml:mo>(</mml:mo>
                      <mml:mrow>
                        <mml:mi>l</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>i</mml:mi>
                      </mml:mrow>
                      <mml:mo>)</mml:mo>
                    </mml:mrow>
                  </mml:mrow>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
                <mml:mo>,</mml:mo>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWGgbGrdaWadaqaaiabdMgaPjabcYcaSiabdQgaQbGaay5waiaaw2faaiabg2da9maaxababaGagiyBa0MaeiyAaKMaeiOBa4galeaacqaIWaamcqGHKjYOcqWGSbaBcqGHKjYOcqWGPbqAcqGHsislcqaIXaqmaeqaaOWaaiWabeaacqWGebardaWadaqaaiabdMgaPjabcYcaSiabdQgaQbGaay5waiaaw2faaiabgUcaRiqbdEha3zaafaWaaeWaaeaacqWGSbaBcqGGSaalcqWGPbqAaiaawIcacaGLPaaaaiaawUhacaGL9baacqGGSaalaaa@52DE@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p><italic>sub </italic>is a symbol substitution cost matrix and the initial conditions of recurrence (6) are <italic>D</italic>[<italic>i</italic>, 0] = <italic>w'</italic>(0, <italic>i</italic>), 1 ≤ <italic>i </italic>≤ <italic>m </italic>and <italic>D</italic>[0, <italic>j</italic>] = <italic>w</italic>(0, <italic>j</italic>), 1 ≤ <italic>j </italic>≤ <italic>n</italic>.</p>
      <p>We observe that the computation of recurrence (6) consists of <italic>n </italic>+ <italic>m </italic>interleaved subproblems that have the following general form: Compute</p>
      <p>
        <disp-formula id="bmcM9">
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5" name="1748-7188-2-10-i4" overflow="scroll">
            <mml:semantics definitionURL="" encoding="">
              <mml:mrow>
                <mml:mtable>
                  <mml:mtr>
                    <mml:mtd>
                      <mml:mrow>
                        <mml:mi>E</mml:mi>
                        <mml:mrow>
                          <mml:mo>[</mml:mo>
                          <mml:mi>j</mml:mi>
                          <mml:mo>]</mml:mo>
                        </mml:mrow>
                        <mml:mo>=</mml:mo>
                        <mml:munder>
                          <mml:mrow>
                            <mml:mi>min</mml:mi>
                            <mml:mo>⁡</mml:mo>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>0</mml:mn>
                            <mml:mo>≤</mml:mo>
                            <mml:mi>k</mml:mi>
                            <mml:mo>≤</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:munder>
                        <mml:mrow>
                          <mml:mo>{</mml:mo>
                          <mml:mrow>
                            <mml:mi>D</mml:mi>
                            <mml:mrow>
                              <mml:mo>[</mml:mo>
                              <mml:mi>k</mml:mi>
                              <mml:mo>]</mml:mo>
                            </mml:mrow>
                            <mml:mo>+</mml:mo>
                            <mml:mi>w</mml:mi>
                            <mml:mrow>
                              <mml:mo>(</mml:mo>
                              <mml:mrow>
                                <mml:mi>k</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>j</mml:mi>
                              </mml:mrow>
                              <mml:mo>)</mml:mo>
                            </mml:mrow>
                          </mml:mrow>
                          <mml:mo>}</mml:mo>
                        </mml:mrow>
                        <mml:mo>,</mml:mo>
                      </mml:mrow>
                    </mml:mtd>
                    <mml:mtd>
                      <mml:mrow>
                        <mml:mi>j</mml:mi>
                        <mml:mo>=</mml:mo>
                        <mml:mn>1</mml:mn>
                        <mml:mo>,</mml:mo>
                        <mml:mo>⋯</mml:mo>
                        <mml:mo>,</mml:mo>
                        <mml:mi>n</mml:mi>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
                <mml:mo>,</mml:mo>
              </mml:mrow>
              <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaafaqabeqacaaabaGaemyrau0aamWaaeaacqWGQbGAaiaawUfacaGLDbaacqGH9aqpdaWfqaqaaiGbc2gaTjabcMgaPjabc6gaUbWcbaGaeGimaaJaeyizImQaem4AaSMaeyizImQaemOAaOMaeyOeI0IaeGymaedabeaakmaacmqabaGaemiraq0aamWaaeaacqWGRbWAaiaawUfacaGLDbaacqGHRaWkcqWG3bWDdaqadaqaaiabdUgaRjabcYcaSiabdQgaQbGaayjkaiaawMcaaaGaay5Eaiaaw2haaiabcYcaSaqaaiabdQgaQjabg2da9iabigdaXiabcYcaSiabl+UimjabcYcaSiabd6gaUbaacqGGSaalaaa@57AF@</mml:annotation>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p><italic>D</italic>[0] is given and for every <italic>k </italic>= 1,..., <italic>n</italic>, <italic>D </italic>[<italic>k</italic>] is easily computed from <italic>E</italic>[<italic>k</italic>]. We now concentrate on a general algorithm computing (9).</p>
    </sec>
    <sec>
      <title>5.2 The GG algorithm</title>
      <p>From now on, unless otherwise specified, we assume that <italic>w </italic>satisfies the concave Monge condition (5). An important notion related to concave Monge condition is concave total monotonicity of an <italic>s </italic>× <italic>p </italic>matrix <italic>A</italic>. <italic>A </italic>is <italic>concave totally monotone </italic>if and only if</p>
      <p>
        <disp-formula id="bmcM10"><italic>A</italic>[<italic>a</italic>, <italic>c</italic>] ≤ <italic>A</italic>[<italic>b</italic>, <italic>c</italic>] ⇒ <italic>A</italic>[<italic>a</italic>, <italic>d</italic>] ≤ <italic>A</italic>[<italic>b</italic>, <italic>d</italic>].</disp-formula>
      </p>
      <p>for all <italic>a </italic>&lt;<italic>b </italic>and <italic>c </italic>&lt;<italic>d</italic>.</p>
      <p>It is easy to check that if <italic>w </italic>is seen as a two-dimensional matrix, the concave Monge condition implies concave total monotonicity of <italic>w</italic>. Notice that the converse is not true. Total monotonicity and Monge condition of a matrix <italic>A </italic>are relevant to the design of algorithms because of the following observations. Let <italic>r</italic><sub><italic>j </italic></sub>denote the row index such that <italic>A</italic>[<italic>r</italic><sub><italic>j</italic></sub>, <italic>j</italic>] is the minimum value in column <italic>j</italic>. Concave total monotonicity implies that the minimum row indices are nonincreasing, i.e., <italic>r</italic><sub>1 </sub>≥ <italic>r</italic><sub>2 </sub>≥ ... ≥ <italic>r</italic><sub><italic>m</italic></sub>. We say that an element <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] is <italic>dead </italic>if <italic>i </italic>≠ = <italic>r</italic><sub><italic>j </italic></sub>(i.e., <italic>A</italic>[<italic>i</italic>, <italic>j</italic>] is not the minimum of column <italic>j</italic>). A submatrix of <italic>A </italic>is dead if all of its elements are dead.</p>
      <p>Let <italic>B</italic>[<italic>i</italic>, <italic>j</italic>] = <italic>D</italic>[<italic>i</italic>] + <italic>w</italic>(<italic>i</italic>, <italic>j</italic>), for 0 ≤ <italic>i </italic>≤ <italic>j </italic>≤ <italic>n</italic>. We say that <italic>B</italic>[<italic>i</italic>, <italic>j</italic>] is <italic>available </italic>if <italic>D</italic>[<italic>i</italic>] is known and therefore <italic>B</italic>[<italic>i</italic>, <italic>j</italic>] can be computed in constant time. That is, <italic>B</italic>[<italic>i</italic>, <italic>j</italic>] is available only when the column minima for columns 1, 2,..., <italic>i </italic>have been found. We say that <italic>B </italic>is <italic>on-line</italic>, since its entries become available as the computation proceeds.</p>
      <p>The computation of recurrence (9) reduces to the identification of the column minima in an on-line upper triangular matrix <italic>B</italic>. One can easily show that when <italic>w </italic>satisfies the concave Monge condition, <italic>B </italic>is totally monotone. We make use of this fact to obtain an efficient algorithm.</p>
      <p>The algorithm outlined here finds column minima one at a time and processes available entries so that it keeps only possible candidates for future column minima. In the concave case, we use a stack to maintain the candidates. The algorithm can be sketched as follows (proof of correctness can be found in [<xref ref-type="bibr" rid="B15">15</xref>])</p>
      <p>For each <italic>j</italic>, 2 ≤ <italic>j </italic>≤ <italic>n</italic>, we find the minimum at column <italic>j </italic>as follows. Assume that (<italic>i</italic><sub>1</sub>, <italic>h</italic><sub>1</sub>),..., (<italic>i</italic><sub><italic>k</italic></sub>, <italic>h</italic><sub><italic>k</italic></sub>) are on the stack ((<italic>i</italic><sub>1</sub>, <italic>h</italic><sub>1</sub>) is at the top of the stack). Initially, (0, <italic>n</italic>) is on the stack. The invariant on the stack elements is that in submatrix <italic>B</italic>[0 : <italic>j </italic>- 2, <italic>j </italic>: <italic>n</italic>] row <italic>i</italic><sub><italic>r</italic></sub>, for 1 ≤ <italic>r </italic>≤ <italic>k</italic>, is the best (gives the minimum) in the column interval [<italic>h</italic><sub><italic>r</italic>-1 </sub>+ 1, <italic>h</italic><sub><italic>r</italic></sub>] (assumingh <italic>h</italic><sub>0 </sub>+ 1 = <italic>j</italic>). By the concave total monotonicity of <italic>B</italic>, <italic>i</italic><sub>1</sub>,..., <italic>i</italic><sub><italic>k </italic></sub>are nonincreasing. Thus the minimum at column <italic>j </italic>is the minimum of <italic>B</italic>[<italic>i</italic><sub>1</sub>, <italic>j</italic>] and <italic>B</italic>[<italic>j </italic>- 1, <italic>j</italic>].</p>
      <p>Now we update the stack with row <italic>j </italic>- 1 as follows.</p>
      <p>(<bold>GG1) </bold>If <italic>B</italic>[<italic>i</italic><sub>1</sub>, <italic>j</italic>] ≤ <italic>B</italic>[<italic>j </italic>- 1, <italic>j</italic>], row <italic>j </italic>- 1 is dead by concave total monotonicity. If <italic>h</italic><sub>1 </sub>= <italic>j</italic>, we pop the top element because it will not be useful.</p>
      <p>(<bold>GG2) </bold>If <italic>B</italic>[<italic>i</italic><sub>1</sub>, <italic>j</italic>] &gt; <italic>B</italic>[<italic>j </italic>- 1, <italic>j</italic>], we compare row <italic>j </italic>- 1 with row <italic>i</italic><sub><italic>r </italic></sub>at <italic>h</italic><sub><italic>r </italic></sub>(i.e., <italic>B</italic>[<italic>i</italic><sub><italic>r</italic></sub>, <italic>h</italic><sub><italic>r</italic></sub>] vs. <italic>B</italic>[<italic>j </italic>- 1, <italic>h</italic><sub><italic>r</italic></sub>]), for <italic>r </italic>= 1, 2,..., until row <italic>i</italic><sub><italic>r </italic></sub>is better than row <italic>j </italic>- 1 at <italic>h</italic><sub><italic>r</italic></sub>. If row <italic>j </italic>- 1 is better than row <italic>i</italic><sub><italic>r </italic></sub>at <italic>h</italic><sub><italic>r</italic></sub>, row <italic>i</italic><sub><italic>r </italic></sub>cannot give the minimum for any column because row <italic>j </italic>- 1 is better than row <italic>i</italic><sub><italic>r </italic></sub>for column <italic>l </italic>≤ <italic>h</italic><sub><italic>r </italic></sub>and row <italic>i</italic><sub><italic>r</italic>+1 </sub>is better than row <italic>i</italic><sub><italic>r </italic></sub>for column <italic>l </italic>&gt; <italic>h</italic><sub><italic>r</italic></sub>. We pop the element (<italic>i</italic><sub><italic>r</italic></sub>, <italic>h</italic><sub><italic>r</italic></sub>) from the stack and continue to compare row <italic>j </italic>- 1 with row <italic>i</italic><sub><italic>r</italic>+1</sub>. If row <italic>i</italic><sub><italic>r </italic></sub>is better than row <italic>j </italic>- 1 at <italic>h</italic><sub><italic>r</italic></sub>, we need to find the border of the two rows <italic>j </italic>- 1 and <italic>i</italic><sub><italic>r</italic></sub>, which is the largest <italic>h </italic>&lt;<italic>h</italic><sub><italic>r </italic></sub>such that row <italic>j </italic>- 1 is better than row <italic>i</italic><sub><italic>r </italic></sub>for column <italic>l </italic>≤ <italic>h</italic>; i.e., finding the zero <italic>z </italic>of <italic>f</italic>(<italic>x</italic>) = <italic>B</italic>[<italic>j </italic>- 1, <italic>x</italic>] - <italic>B</italic>[<italic>i</italic><sub><italic>r</italic></sub>, <italic>x</italic>] = <italic>w</italic>(<italic>j </italic>- 1, <italic>x</italic>) - <italic>w</italic>(<italic>i</italic><sub><italic>r</italic></sub>, <italic>x</italic>) + (<italic>D</italic>[<italic>j </italic>- 1] - <italic>D</italic>[<italic>i</italic><sub><italic>r</italic></sub>]), then <italic>h </italic>= ⌊<italic>z</italic>⌋. If <italic>h </italic>≥ <italic>j </italic>+1, we push (<italic>j </italic>- 1, <italic>h</italic>) into the stack.</p>
      <p>In the pseudo-code of Algorithm <bold>GG</bold>, let <italic>I</italic>(<italic>top</italic>) and <italic>H</italic>(<italic>top</italic>) denote (<italic>i</italic><sub>1</sub>, <italic>h</italic><sub>1</sub>). Moreover, let <italic>CLOSEST</italic>(<italic>j </italic>- 1, <italic>I</italic>(<italic>top</italic>)) be a function that returns the zero of <italic>f</italic>(<italic>x</italic>) (defined in step <bold>GG2</bold>) closest to <italic>j </italic>- 1. Notice that, using the monotonicity conditions on <italic>w</italic>, <italic>CLOSEST</italic>(<italic>j </italic>- 1, <italic>I</italic>(<italic>top</italic>)) can be computed in <italic>O</italic>(log <italic>n</italic>) time. Moreover, we say that <italic>f </italic>satisfies the <italic>closest zero property </italic>if such a zero can be computed in constant time. We also notice that when <italic>w </italic>is a linear function, <italic>f </italic>obviously satisfies the closet zero property. Moreover, for linear functions, lines 9–20 of Algorithm <bold>GG </bold>become useless since only one element can be on the stack: the winner (the minimum) of the comparison on line 5 of the algorithm. We have:</p>
      <p><bold>Theorem 5.1 </bold><italic>Recurrence (9) can be computed in O</italic>(<italic>n </italic>log <italic>n</italic>) <italic>time when w satisfies the concave Monge conditions. The time reduces to O</italic>(<italic>n</italic>) <italic>when the closet zero property is satisfied or w is linear. Therefore, given two strings X and Y, their edit distance with gaps can be computed in time O</italic>(<italic>nm </italic>log max(<italic>n</italic>, <italic>m</italic>)) <italic>time, when both w and w' satisfy the concave Monge conditions and O</italic>(<italic>nm</italic>) <italic>time when both functions satisfy the closest zero property or are affine gap costs</italic>.</p>
      <p>Two remarks are in order regarding the implementation of the <bold>GG </bold>algorithm provided here:</p>
      <p>1: Algorithm <bold>GG</bold></p>
      <p>2: <bold>push </bold>(0, <italic>n</italic>) on <italic>S</italic></p>
      <p>3: <bold>for </bold><italic>j </italic>:= 2 <bold>to </bold><italic>n </italic><bold>do</bold></p>
      <p>4:    ℓ ← <italic>I</italic>(<italic>top</italic>)</p>
      <p>5:    <bold>if </bold><italic>B</italic>[<italic>j </italic>- 1, <italic>j</italic>] ≥ <italic>B</italic>[ℓ, <italic>j</italic>] <bold>then</bold></p>
      <p>6:       min is <italic>B</italic>[ℓ, <italic>j</italic>]</p>
      <p>7:    <bold>else</bold></p>
      <p>8:       min is <italic>B</italic>[<italic>j </italic>- 1, <italic>j</italic>]</p>
      <p>9:       <bold>while </bold><italic>S </italic>≠ ∅ <bold>and </bold><italic>B</italic>[<italic>j </italic>- 1, <italic>j</italic>] ≤ <italic>B</italic>[<italic>I</italic>(<italic>top</italic>); <italic>H</italic>(<italic>top</italic>)] <bold>do</bold></p>
      <p>10:          <bold>pop</bold></p>
      <p>11:       <bold>end while</bold></p>
      <p>12:       <bold>if </bold><italic>S </italic>= ∅ <bold>then</bold></p>
      <p>13:          <bold>push </bold>(<italic>j </italic>- 1, <italic>n</italic>)</p>
      <p>14:       <bold>else</bold></p>
      <p>15:          <italic>h </italic>← <italic>CLOSEST</italic>(<italic>j </italic>- 1, <italic>I</italic>(<italic>top</italic>))</p>
      <p>16:          <bold>push </bold>(<italic>j </italic>- 1, <italic>h</italic>)</p>
      <p>17:       <bold>end if</bold></p>
      <p>18:    <bold>end if</bold></p>
      <p>19:    <bold>if </bold><italic>H</italic>(<italic>top</italic>) = <italic>j </italic><bold>then</bold></p>
      <p>20:       <bold>pop</bold></p>
      <p>21:    <bold>end if</bold></p>
      <p>22: <bold>end for</bold></p>
      <p>(a) It takes in input a character substitution matrix. Such a matrix could be one of the well known PAM [<xref ref-type="bibr" rid="B36">36</xref>] or BLOSUM [<xref ref-type="bibr" rid="B37">37</xref>,<xref ref-type="bibr" rid="B38">38</xref>] matrices. However, those matrices have been designed for maximization problems, while we have stated our alignment problem as a minimization problem. Therefore, in order to use those matrices, we need to change the sign of each entry, i.e., take its dual.</p>
      <p>(b) It takes in input two default gap cost functions, one affine and the other concave: <italic>g</italic>(ℓ) = <italic>c</italic><sub>1 </sub>+ <italic>c</italic><sub>2</sub>ℓ and <italic>g</italic>(ℓ) = <italic>c</italic><sub>1 </sub>+ <italic>c</italic><sub>2 </sub>log ℓ, where <italic>c</italic><sub>1 </sub>and <italic>c</italic><sub>2 </sub>are constants. In this case, the closet zero property holds and the program uses this condition to avoid the binary search. However, the user can also specify a concave cost function by simply providing a pointer to the excutable computing it. In this case, the binary search is used.</p>
    </sec>
    <sec>
      <title>5.3 The C/C++ library functions</title>
      <p>The function below computes the edit distance between two strings, using convex or affine gap costs. It returns the corresponding alignment.</p>
      <p>Synopsis</p>
      <p>#include "edit_distance_gaps.h"</p>
      <p>ALIGNMENTS</p>
      <p><bold><underline>edit_distance_gaps</underline></bold>(<underline>char</underline><italic><underline>*X</underline></italic>, <underline>char</underline><italic><underline>*Y</underline></italic>, <underline>WEIGHT</underline><italic><underline> Xw</underline></italic>, <underline>WEIGHT </underline><italic><underline>Yw</underline></italic>,, <underline>MATRIX</underline><italic><underline> substitution</underline></italic>);</p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic><underline>X</underline></italic>: points to a string;</p>
      <p>• <italic><underline>Y</underline></italic>: points to a string;</p>
      <p>• <italic><underline>Xw</underline></italic>: is a pointer to a <underline>WEIGHT_STRUCT</underline>;</p>
      <p>• <italic><underline>Yw</underline></italic>: is a pointer to a <underline>WEIGHT_STRUCT</underline>;</p>
      <p>• <italic><underline>substitution</underline></italic>: is a pointer to <underline>MATRIX_STRUCT</underline>, a data structure (detailed below) defining an upper triangular substitution cost matrix.</p>
      <p><underline>WEIGHT_STRUCT</underline> defines a generic cost function for gaps, as follows:</p>
      <p>typedef struct <underline>weight</underline></p>
      <p>{</p>
      <p>   <underline>int</underline><italic><underline> type</underline></italic>;</p>
      <p><underline>double</underline><italic><underline> Wa</underline></italic>, <italic><underline>Wg</underline></italic>, <italic><underline>base</underline></italic>;</p>
      <p><underline>double</underline> (<italic><underline>*w</underline></italic>)(<underline>int </underline><italic><underline>l</underline></italic>, <underline>int</underline><italic><underline> k</underline></italic>);</p>
      <p>} <underline>WEIGHT_STRUCT</underline>, <italic><underline>*WEIGHT</underline></italic>;</p>
      <p>The <italic><underline>type</underline></italic> is a mendatory field that takes two values:F_AFFINE and F_CONCAVE. In both cases, the total of gap opening and closing costs, i.e., <italic><underline>Wg</underline></italic>, and the gap extension cost, i.e., <italic><underline>Wa</underline></italic>, need also be specified. Then, the affine function is <italic>W</italic><sub><italic>a </italic></sub>+ <italic>W</italic><sub><italic>g</italic></sub>ℓ, for a gap of length ℓ. For the concave cost function, we can use the default <italic>W</italic><sub><italic>a </italic></sub>+ <italic>W</italic><sub><italic>g</italic></sub><italic>log</italic><sub><italic>base</italic></sub>(ℓ), where the <underline>base</underline> of the logarithm must also be specified. One can also use a user-defined concave cost function <italic>w </italic>by specifying a pointer to a function defined as:</p>
      <p>double</p>
      <p><bold><underline>weight_function</underline></bold>(<underline>int </underline><italic><underline>l</underline></italic>, <underline>int</underline><italic><underline> k</underline></italic>);</p>
      <p><underline>MATRIX_STRUCT</underline> defines a generic cost substitution matrix, as follows:</p>
      <p>typedef struct <underline>matrix</underline></p>
      <p>{</p>
      <p>   <underline>char</underline><italic><underline>*alphabet</underline></italic>;</p>
      <p>   <underline>int</underline><italic><underline> size</underline></italic></p>
      <p>   <underline>double</underline><italic><underline>**matrix</underline></italic></p>
      <p>} <underline>MATRIX_STRUCT</underline>, <italic><underline>*MATRIX</underline></italic>;</p>
      <p>where <italic><underline>alphabet</underline></italic> is a pointer to the alphabet array (case insensitive) of cardinality <italic><underline>size</underline></italic>. The last field <italic><underline>matrix</underline></italic>is a pointer an upper triangular symbol substitution cost matrix. In case one wants to use the default matrix, i.e., match values 0 and mismatch 1, it suffices to set filed <italic>size </italic>equal to zero.</p>
      <p><bold>Return Values</bold>: A pointer to <underline>ALIGNMENTS_STRUCT</underline>, which is defined as in section 4.3, except that <italic><underline>distance</underline></italic> now refers to the edit distance with gaps.</p>
    </sec>
    <sec>
      <title>5.4 The Perl library functions</title>
      <p>The <bold>Edit_Distance_Gap </bold>computes the edit distance with gaps between two strings.</p>
      <p>Synopsis</p>
      <p>use BSAT::Edit_Distance_Gaps;</p>
      <p>Edit_Distance_Gaps <italic>X Y Xw Yw Substitution</italic></p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic>X</italic>: is a scalar containing string X;</p>
      <p>• <italic>Y</italic>: is a scalar containing string Y;</p>
      <p>• <italic>Xw</italic>: is a hash reference defined below;</p>
      <p>• <italic>Yw</italic>: is a hash reference defined below;</p>
      <p>• <italic>Yw</italic>: is a list reference containing the</p>
      <p>• <italic>Substitution</italic>: is a list reference containing an upper triangular symbol substitution cost matrix. If undefined, the default values are used, as in section 5.3;</p>
      <p>• <italic>Alphabet</italic>: is a list reference containing the characters of alphabet (case insensitive). If undefined, the default values are used, as in section 5.3.</p>
      <p>Xw is defined as (Yw is analogous):</p>
      <p>my %Xw = (</p>
      <p>   <italic>Type </italic>=&gt; "",</p>
      <p>   <italic>Wa </italic>=&gt; 0,</p>
      <p>   <italic>Wg </italic>=&gt; 0,</p>
      <p>   <italic>Base </italic>=&gt; 0,</p>
      <p>   <italic>w </italic>=&gt; \&amp;<italic>custom_fuction</italic>);</p>
      <p>where the fields are as in the specification of the cost function in section 5.3.</p>
      <p><bold>Return values</bold>: <bold>Edit_Distance_Gaps </bold>returns an hash corresponding to the computed alignment and it is defined as in section 4.4, except the distance is now the value of the edit distance with gaps:</p>
      <p>my %alignment = (</p>
      <p>   distance =&gt; 0,</p>
      <p>   X =&gt; "",</p>
      <p>   Y =&gt; "");</p>
    </sec>
  </sec>
  <sec>
    <title>6 Filtering, statistical scores and model organism generation</title>
    <p>In this section we outline the filtering and statistical functions present in the system, starting with the filter. Let <italic>O</italic><sub>1</sub>,...,<italic>O</italic><sub><italic>s </italic></sub>be the output of algorithm <bold>SM </bold>on the pattern strings <italic>p</italic><sub>1</sub>,...,<italic>p</italic><sub>s </sub>and text strings <italic>t</italic><sub>1</sub>,...,<italic>t</italic><sub><italic>s</italic></sub>, respectively. We assume that the algorithm has been used with the same value of <italic>k </italic>in all <italic>s </italic>instances. The procedure takes in input the sets <italic>O</italic><sub><italic>i </italic></sub>and <italic>t</italic><sub><italic>i</italic></sub>, 1 ≤ <italic>i </italic>≤ <italic>s</italic>, and a threshold parameter <italic>th</italic>. It returns a set <italic>W </italic>consisting of all strings in <italic>O</italic><sub><italic>i </italic></sub>that appear in at least <italic>th </italic>of the text strings. Since each <italic>O</italic><sub><italic>i </italic></sub>consists of the occurrences of a pattern <italic>p</italic><sub><italic>i </italic></sub>in <italic>t</italic><sub><italic>i</italic></sub>, with mismatches, <italic>W </italic>corresponds to a set of strings representing common occurrences of all patterns in the text strings, i.e., it is a consensus set. The algorithmic details yielding an efficient implementation of the filtering operation are straightforward and therefore omitted.</p>
    <p>We now turn to the z-score. The assessment of the statistical significance of the occurrences of a set of strings <italic>W </italic>in a set of text strings <italic>t</italic><sub>1</sub>,...,<italic>t</italic><sub><italic>s </italic></sub>is a well established procedure for analysis of biological sequences, in particular via z-score functions [<xref ref-type="bibr" rid="B18">18</xref>]. Intuitively, the value of the z-score for a set of strings <italic>W </italic>gives an indication of how relevant are the occurrences of the strings in <italic>W </italic>in the text strings <italic>t</italic><sub>1</sub>,...,<italic>t</italic><sub><italic>s</italic></sub>, with respect to "a random event" as characterized by a background model. We limit ourselves to give formal definitions and for the case in which <italic>W </italic>contains only one string and <italic>s </italic>= 1. For the generalization to the case in which <italic>W </italic>contains more than one string and the rather involved algorithmic details, the reader is referred to [<xref ref-type="bibr" rid="B19">19</xref>].</p>
    <p>Let <italic>p </italic>be a string and let <italic>X </italic>be a set of random strings, generated according to some " background probabilistic model", usually a Markov Source. Let <italic>X</italic><sub><italic>p </italic></sub>be the random variable indicating the number of occurrences of <italic>p </italic>in <italic>X </italic>and let <italic>E</italic>(<italic>X</italic><sub><italic>p</italic></sub>) and <italic>σ</italic>(<italic>X</italic><sub><italic>p</italic></sub>) be the mean and standard deviation, respectively. Then, the <italic>z-score </italic>associated with <italic>p </italic>is</p>
    <p>
      <disp-formula id="bmcM11">
        <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6" name="1748-7188-2-10-i5" overflow="scroll">
          <mml:semantics definitionURL="" encoding="">
            <mml:mrow>
              <mml:msub>
                <mml:mi>z</mml:mi>
                <mml:mi>p</mml:mi>
              </mml:msub>
              <mml:mo>=</mml:mo>
              <mml:mfrac>
                <mml:mrow>
                  <mml:msub>
                    <mml:mi>N</mml:mi>
                    <mml:mi>p</mml:mi>
                  </mml:msub>
                  <mml:mo>−</mml:mo>
                  <mml:mi>E</mml:mi>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>X</mml:mi>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
                <mml:mrow>
                  <mml:mi>σ</mml:mi>
                  <mml:mrow>
                    <mml:mo>(</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mi>X</mml:mi>
                        <mml:mi>p</mml:mi>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo>)</mml:mo>
                  </mml:mrow>
                </mml:mrow>
              </mml:mfrac>
            </mml:mrow>
            <mml:annotation encoding="MathType-MTEF">
 MathType@MTEF@5@5@+=feaafiart1ev1aaatCvAUfKttLearuWrP9MDH5MBPbIqV92AaeXatLxBI9gBaebbnrfifHhDYfgasaacH8akY=wiFfYdH8Gipec8Eeeu0xXdbba9frFj0=OqFfea0dXdd9vqai=hGuQ8kuc9pgc9s8qqaq=dirpe0xb9q8qiLsFr0=vr0=vr0dc8meaabaqaciaacaGaaeqabaqabeGadaaakeaacqWG6bGEdaWgaaWcbaGaemiCaahabeaakiabg2da9maalaaabaGaemOta40aaSbaaSqaaiabdchaWbqabaGccqGHsislcqWGfbqrdaqadaqaaiabdIfaynaaBaaaleaacqWGWbaCaeqaaaGccaGLOaGaayzkaaaabaacciGae83Wdm3aaeWaaeaacqWGybawdaWgaaWcbaGaemiCaahabeaaaOGaayjkaiaawMcaaaaaaaa@402E@</mml:annotation>
          </mml:semantics>
        </mml:math>
      </disp-formula>
    </p>
    <p>where <italic>N</italic><sub><italic>p </italic></sub>is the number of occurrences of <italic>p </italic>in the strings in <italic>X</italic>. Notice that <italic>z</italic><sub><italic>p </italic></sub>gives the number of standard deviations by which the observed value <italic>N</italic><sub><italic>p </italic></sub>exceeds its expected value. It is normalized so that it has mean zero and standard deviation one, so that it can be used to compare the z-score of different strings.</p>
    <p>The module that computes the z-score in our system takes in input the set <italic>W </italic>output by the filtering function, the text strings <italic>t</italic><sub>1</sub>,...,<italic>t</italic><sub><italic>s </italic></sub>and a model, i.e., a table encoding a Markov source of order 3, together with additional information needed for the computation of the variance (see Appendix A in [<xref ref-type="bibr" rid="B39">39</xref>]). The software computing the z-score is a specialization of the software of Sinha and Tompa for the computation of the z-score in YMF, that is designed to work for motifs (a concise and general encoding of a set of strings). As in their case, the code is designed to work only for DNA sequences. Therefore, care must be taken in computing the number of occurrences of a string <italic>p </italic>in a string <italic>t</italic>. In fact, one must count occurrences on both DNA strands. That is done by including, for each string in the input set <italic>W</italic>, its reverse complement.</p>
    <p>Two model organisms are available, Human and Yeast, as they are given by the YMF software distribution of Sinha and Tompa [<xref ref-type="bibr" rid="B39">39</xref>]. Moreover, via the function that generates a model organism, the user can specify a new model for her/his sequences. Details on input formats for the model are given in the User Guide.</p>
    <sec>
      <title>6.1 The C/C++ library functions</title>
      <p>The function below computes the z-score value of a set of patterns (all of the same length) with respect to a set of sequences (all of the same length). It works for DNA only.</p>
      <p>Synopsis</p>
      <p>#include "z_score.h"</p>
      <p>double</p>
      <p><bold><underline>z score </underline></bold>(<underline>char</underline><italic><underline>**patterns</underline></italic>, <underline>char</underline><italic><underline>**texts</underline></italic>, <underline>char</underline><italic><underline>*organismpath</underline></italic>);</p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic><underline>patterns</underline></italic>: is a column vector, each item points to a pattern string. The last item point to NULL;</p>
      <p>• <italic><underline>texts</underline></italic>: is a column vector, each item points to a text string. The last item point to NULL;</p>
      <p>• <italic><underline>organismpath</underline></italic>: it is the path to the file containing all probabilistic information for an organism.</p>
      <p>Return Values</p>
      <p>Upon successful completion <bold><underline>z_score</underline></bold>return a double value, corresponding to z-score.</p>
      <p>The function below generates a Markov model of order 3, from a set of strings. It works for DNA only.</p>
      <p>Synopsis</p>
      <p>#include " model_generatation.h"</p>
      <p>int</p>
      <p><bold><underline>model_generatation </underline></bold>(<underline>char</underline><italic><underline>**strings</underline></italic>, <underline>char</underline><italic><underline>*path</underline></italic>, <underline>char</underline><italic><underline>*organism</underline></italic>);</p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic><underline>strings</underline></italic>: is a column vector, each item points to a string. The last item point to NULL;</p>
      <p>• <underline>path</underline>: is a output path;</p>
      <p>• <underline>organism</underline>: is the organism name;</p>
      <p>Return Values</p>
      <p><bold><underline>model_generation</underline></bold> returns zero if the computation is completed successfully and 1 otherwise.</p>
    </sec>
    <sec>
      <title>6.2 The Perl library functions</title>
      <p>The function below performs a filtering operation on a set of sequences.</p>
      <p>use BATS::Filter;</p>
      <p>Filter <italic>files hits score Hitsthreshold Filesthreshold</italic></p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic>files</italic>: is an array of strings containing the filenames.</p>
      <p>• <italic>hits</italic>: is a hash reference containing number of hits for each occurrence per file.</p>
      <p>• <italic>score</italic>: is a hash reference containing number of errors for each occurrence.</p>
      <p>• <italic>Filesthreshold</italic>: is a scalar containing the minimum number of hits on which occurrences need to be present.</p>
      <p>• <italic>Filesthreshold</italic>: is a scalar containing the minimum percentage of files on which occurrences need to be present.</p>
      <p><bold>Return values </bold>Filter returns an array containing indices of hits that satisfy the threshold.</p>
      <p>The function below computes the z-score value of a set of patterns (all of the same length) with respect to a set of sequences (all of the same length). It works for DNA only.</p>
      <p>Synopsis</p>
      <p>use BATS::Z_Score;</p>
      <p>Z_Score <italic>patters texts organismpath</italic></p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic>patterns</italic>: is an array of strings containing the set of patterns;</p>
      <p>• <italic>sequences</italic>: is an array of strings containing the text strings;</p>
      <p>• <italic>organismpath</italic>: it is the path to the file containing all probabilistic information for an organism.</p>
      <p>Return values:</p>
      <p>Z_Score returns a scalar containing the z-score value of the pattern set.</p>
      <p>The function below generates a Markov model of order 3, from a set of strings. It works for DNA only.</p>
      <p>Synopsis</p>
      <p>use BATS::Model_Generation;</p>
      <p>Model_Generatation <italic>strings path organism</italic></p>
      <p><bold>Arguments</bold>:</p>
      <p>• <italic>strings</italic>: is an array of strings;</p>
      <p>• <italic>path</italic>: is a scalar containing the string of the output path;</p>
      <p>• <italic>organism</italic>: points to the string containing the name of the organism;</p>
      <p><bold>Return values: </bold>Model_Generation returns a scalar containing 0 if the computation is completed successfully and 1 otherwise.</p>
    </sec>
  </sec>
  <sec>
    <title>7 Conclusion</title>
    <p>We have presented a software library for some basic global and local sequence alignment tasks. Moreover, procedures to assess the statistical significance of the occurrence of a set of DNA pattern strings in a set of DNA text strings has also been provided. Although none of the presented algorithms is new, this the first software library that provides their implementation in one consistent and ready to use package.</p>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>The authors are deeply endebted to S. Sinha and M. Tompa for allowing to modify their software in order to be included in BATS. RG is partially supported by the Italian MIUR FIRB project " Bioinformatica per la Genomica e la Proteomica" and by MIUR FIRB Italy-Israel project " Pattern Matching and Discovery in Discrete Structures, with applications to Bioinformatics".</p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <source>Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology</source>
        <year>1997</year>
        <publisher-name>Cambridge University Press</publisher-name>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Waterman</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <source>Introduction to Computational Biology Maps, Sequences and Genomes</source>
        <year>1995</year>
        <publisher-name>Chapman Hall</publisher-name>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Goad</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Cooper N</surname>
          </name>
        </person-group>
        <article-title>Sequence analysis- contributions by Ulam to molecular genetics</article-title>
        <source>From Cardinals to Chaos Reflections on the life and legacy of Stanislaw Ulam</source>
        <year>1989</year>
        <publisher-name>Cambridge University Press</publisher-name>
        <fpage>288</fpage>
        <lpage>291</lpage>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kruskal</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sankoff</surname>
            <given-names>D</given-names>
          </name>
          <collab>Eds</collab>
        </person-group>
        <source>Time Wraps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison</source>
        <year>1983</year>
        <publisher-name>Addison-Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altshul</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Basic Local Alignment Search Tool</article-title>
        <source>J of Molecular Bioilogy</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An Improved Algorithm for Matching of Biological Sequences</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>705</fpage>
        <lpage>708</lpage>
        <pub-id pub-id-type="pmid">7166760</pub-id>
        <pub-id pub-id-type="doi">10.1016/0022-2836(82)90398-9</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Apostolico A, Galil Z</surname>
          </name>
        </person-group>
        <article-title>Dynamic Programming: Special Cases</article-title>
        <source>Pattern Matching Algorithms</source>
        <year>1997</year>
        <publisher-name>Oxford University Press</publisher-name>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Galil</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Data Structures and Algorithms for Approximate String Matching</article-title>
        <source>J of Complexity</source>
        <year>1988</year>
        <volume>4</volume>
        <fpage>32</fpage>
        <lpage>72</lpage>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Landau</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Vishkin</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>Efficient String Matching with k Mismatches</article-title>
        <source>Theoretical Computer Science</source>
        <year>1986</year>
        <volume>43</volume>
        <fpage>239</fpage>
        <lpage>249</lpage>
        <pub-id pub-id-type="doi">10.1016/0304-3975(86)90178-7</pub-id>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Amir</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Lewenstein</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Porat</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Faster algorithms for string matching with k mismatches</article-title>
        <source>J of Algorithms</source>
        <year>2004</year>
        <volume>50</volume>
        <fpage>257</fpage>
        <lpage>275</lpage>
        <pub-id pub-id-type="doi">10.1016/S0196-6774(03)00097-X</pub-id>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Landau</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Vishkin</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>Introducing Efficient Parallelism into Approximate String Matching and a New Serial Algorithm</article-title>
        <source>Proc 18th Symposium on Theory of Computing, ACM</source>
        <year>1986</year>
        <fpage>220</fpage>
        <lpage>230</lpage>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cole</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Hariharan</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Approximate String Matching: A Simpler Faster Algorithm</article-title>
        <source>SIAM J Comput</source>
        <year>2002</year>
        <volume>31</volume>
        <fpage>1761</fpage>
        <lpage>1782</lpage>
        <pub-id pub-id-type="doi">10.1137/S0097539700370527</pub-id>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Baker</surname>
            <given-names>BS</given-names>
          </name>
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Sparse Dynamic Programming for Longest Common Subsequence from Fragments</article-title>
        <source>J Algorithms</source>
        <year>2002</year>
        <volume>42</volume>
        <fpage>231</fpage>
        <lpage>254</lpage>
        <pub-id pub-id-type="doi">10.1006/jagm.2002.1214</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Waterman</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Efficient Sequence Alignment Algorithms</article-title>
        <source>Journal of Theoretical Biology</source>
        <year>1984</year>
        <volume>108</volume>
        <fpage>333</fpage>
        <lpage>337</lpage>
        <pub-id pub-id-type="pmid">6748696</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Galil</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Speeding Up Dynamic Programming with Applications to Molecular Biology</article-title>
        <source>Theor Comput Sci</source>
        <year>1989</year>
        <volume>64</volume>
        <fpage>107</fpage>
        <lpage>118</lpage>
        <pub-id pub-id-type="doi">10.1016/0304-3975(89)90101-1</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>Sequence Comparison with Concave Weighting Functions</article-title>
        <source>Bull Math Biol</source>
        <year>1988</year>
        <volume>50</volume>
        <fpage>97</fpage>
        <lpage>120</lpage>
        <pub-id pub-id-type="pmid">3207952</pub-id>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Klawe</surname>
            <given-names>MM</given-names>
          </name>
          <name>
            <surname>Kleitman</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>An Almost Linear Algorithm for Generalized Matrix Searching</article-title>
        <source>SIAM J on Desc Math</source>
        <year>1990</year>
        <volume>3</volume>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leung</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Marsh</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Speed</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Over- and underrepresentation of short DNA words in herpesvirus genomes</article-title>
        <source>J Comput Biol</source>
        <year>1996</year>
        <volume>3</volume>
        <fpage>345</fpage>
        <lpage>360</lpage>
        <pub-id pub-id-type="pmid">8891954</pub-id>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Sinha</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tompa</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A Statistical Method for Finding Transcription Factors Binding Sites</article-title>
        <source>8-th ISMB Conference, AAAI</source>
        <year>2000</year>
        <fpage>344</fpage>
        <lpage>354</lpage>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Mehlhorn</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Näher</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <source>The LEDA Platform of Combinatorial and Geometric Computing</source>
        <year>1999</year>
        <publisher-name>Cambridge, UK: Cambridge University Press</publisher-name>
      </citation>
    </ref>
    <ref id="B21">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Czumaj</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Gasieniec</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Traeff</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>The Archtecture of a Software Library for String Processing</article-title>
        <source>Workshop on Algorithm Engineering</source>
        <year>1997</year>
        <publisher-name>University of Venice</publisher-name>
        <fpage>166</fpage>
        <lpage>176</lpage>
      </citation>
    </ref>
    <ref id="B22">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McCreight</surname>
            <given-names>EM</given-names>
          </name>
        </person-group>
        <article-title>A space-economical suffix tree construction algorithm</article-title>
        <source>Journal of the ACM</source>
        <year>1976</year>
        <volume>23</volume>
        <fpage>262</fpage>
        <lpage>272</lpage>
        <pub-id pub-id-type="doi">10.1145/321941.321946</pub-id>
      </citation>
    </ref>
    <ref id="B23">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>On-Line Construction of Suffix Trees</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>14</volume>
      </citation>
    </ref>
    <ref id="B24">
      <citation citation-type="other">
        <article-title>Strmat</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.cs.ucdavis.edu/~gusfield/strmat.html"/>
      </citation>
    </ref>
    <ref id="B25">
      <citation citation-type="other">
        <article-title>BATS Supplementary Material Web Page</article-title>
        <ext-link ext-link-type="uri" xlink:href="http://www.math.unipa.it/~raffaele/BATS"/>
      </citation>
    </ref>
    <ref id="B26">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schieber</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Vishkin</surname>
            <given-names>U</given-names>
          </name>
        </person-group>
        <article-title>On Finding Lowest Common Ancestors: Simplification and Parallelization</article-title>
        <source>Siam J on Computing</source>
        <year>1988</year>
        <volume>17</volume>
        <fpage>1253</fpage>
        <lpage>1262</lpage>
        <pub-id pub-id-type="doi">10.1137/0217079</pub-id>
      </citation>
    </ref>
    <ref id="B27">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Algorithms for Approximate String Matching</article-title>
        <source>Information and Control</source>
        <year>1985</year>
        <volume>64</volume>
        <fpage>100</fpage>
        <lpage>118</lpage>
        <pub-id pub-id-type="doi">10.1016/S0019-9958(85)80046-2</pub-id>
      </citation>
    </ref>
    <ref id="B28">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
        </person-group>
        <article-title>An O(ND) Difference Algorithm and Its Variations</article-title>
        <source>Algorithmica</source>
        <year>1986</year>
        <volume>1</volume>
        <fpage>251</fpage>
        <lpage>266</lpage>
        <pub-id pub-id-type="doi">10.1007/BF01840446</pub-id>
      </citation>
    </ref>
    <ref id="B29">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Apostolico</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Rozenberg G, Salomaa A</surname>
          </name>
        </person-group>
        <article-title>String Editing and Longest Common Subsequence</article-title>
        <source>Handbook of Formal Languages</source>
        <year>1997</year>
        <volume>2</volume>
        <publisher-name>Berlin: Springer Verlag</publisher-name>
        <fpage>361</fpage>
        <lpage>398</lpage>
      </citation>
    </ref>
    <ref id="B30">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hirschberg</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Apostolico A, Galil Z</surname>
          </name>
        </person-group>
        <article-title>Serial Computations of Levenshtein Distances</article-title>
        <source>Pattern Matching Algorithms</source>
        <year>1997</year>
        <publisher-name>Oxford: Oxford University Press</publisher-name>
        <fpage>123</fpage>
        <lpage>142</lpage>
      </citation>
    </ref>
    <ref id="B31">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eppstein</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Galil</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Italiano</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Sparse Dynamic Programming I: Linear Cost Functions</article-title>
        <source>J of ACM</source>
        <year>1992</year>
        <volume>39</volume>
        <fpage>519</fpage>
        <lpage>545</lpage>
        <pub-id pub-id-type="doi">10.1145/146637.146650</pub-id>
      </citation>
    </ref>
    <ref id="B32">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Eppstein</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Galil</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Giancarlo</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Italiano</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Sparse Dynamic Programming II: Convex and Concave Cost Functions</article-title>
        <source>J of ACM</source>
        <year>1992</year>
        <volume>39</volume>
        <fpage>546</fpage>
        <lpage>567</lpage>
        <pub-id pub-id-type="doi">10.1145/146637.146656</pub-id>
      </citation>
    </ref>
    <ref id="B33">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Aho</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hopcroft</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ullman</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <source>Data Structures and Algorithms</source>
        <year>1983</year>
        <publisher-name>Reading, MA.: Addison-Wesley</publisher-name>
      </citation>
    </ref>
    <ref id="B34">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hunt</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Szymanski</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>A Fast Algorithm for Computing Longest Common Subsequences</article-title>
        <source>Comm of the ACM</source>
        <year>1977</year>
        <volume>20</volume>
        <fpage>350</fpage>
        <lpage>353</lpage>
        <pub-id pub-id-type="doi">10.1145/359581.359603</pub-id>
      </citation>
    </ref>
    <ref id="B35">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fitch</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>Optimal Sequence Alignment</article-title>
        <source>National Academy of Sciences USA</source>
        <year>1983</year>
        <volume>80</volume>
        <fpage>1382</fpage>
        <lpage>1385</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.80.5.1382</pub-id>
      </citation>
    </ref>
    <ref id="B36">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Dayhoff</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Schwartz</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Orcutt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Dayhoff M</surname>
          </name>
        </person-group>
        <article-title>A model of evolutionary change in proteins</article-title>
        <source>Atlas of Protein Sequence and Structure</source>
        <year>1978</year>
        <fpage>345</fpage>
        <lpage>352</lpage>
      </citation>
    </ref>
    <ref id="B37">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Henikoff</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Henikoff</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Amino acid substitution matrices from protein blocks</article-title>
        <source>Proc Nat Acad of Sci USA</source>
        <year>1992</year>
        <volume>89</volume>
        <fpage>10915</fpage>
        <lpage>10919</lpage>
        <pub-id pub-id-type="pmid">1438297</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.89.22.10915</pub-id>
      </citation>
    </ref>
    <ref id="B38">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Henikoff</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Henikoff</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Performance evaluation of amino acid substitution matrices</article-title>
        <source>Proteins: Structure, function and genetics</source>
        <year>1993</year>
        <volume>17</volume>
        <fpage>49</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1002/prot.340170108</pub-id>
      </citation>
    </ref>
    <ref id="B39">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sinha</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Tompa</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>YMF: A Program for Discovery of Novel Transcription Factor Binding Sites by Statistical Overrepresentation</article-title>
        <source>Nucleic Acids Research</source>
        <year>2003</year>
        <volume>31</volume>
        <fpage>3586</fpage>
        <lpage>3588</lpage>
        <pub-id pub-id-type="pmid">12824371</pub-id>
        <pub-id pub-id-type="doi">10.1093/nar/gkg618</pub-id>
      </citation>
    </ref>
  </ref-list>
</back>
