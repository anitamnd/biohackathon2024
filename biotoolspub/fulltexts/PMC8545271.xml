<?all-math-mml yes?>
<?use-mml?>
<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD with MathML3 v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1-mathml3.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName nihms2pmcx2.xsl?>
<?ConverterInfo.Version 1?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<?properties manuscript?>
<?origin nihpa?>
<?iso-abbr SoftwareX?>
<?submitter-system nihms?>
<?submitter-canonical-name Elsevier?>
<?submitter-canonical-id ELSEVIERAM?>
<?submitter-userid 8068823?>
<?submitter-authority myNCBI?>
<?submitter-login elsevieram?>
<?submitter-name Elsevier Author Support?>
<?domain nihpa?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-journal-id">101660267</journal-id>
    <journal-id journal-id-type="pubmed-jr-id">43949</journal-id>
    <journal-id journal-id-type="nlm-ta">SoftwareX</journal-id>
    <journal-id journal-id-type="iso-abbrev">SoftwareX</journal-id>
    <journal-title-group>
      <journal-title>SoftwareX</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2352-7110</issn>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8545271</article-id>
    <article-id pub-id-type="pmid">34703873</article-id>
    <article-id pub-id-type="doi">10.1016/j.softx.2021.100676</article-id>
    <article-id pub-id-type="manuscript">nihpa1708640</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CycFlowDec: A Python module for decomposing flow networks using simple cycles</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Bernardi</surname>
          <given-names>Austen</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Swanson</surname>
          <given-names>Jessica M.J.</given-names>
        </name>
        <xref rid="CR1" ref-type="corresp">*</xref>
      </contrib>
      <aff id="A1">Department of Chemistry, University of Utah, 1400 E, Salt Lake City, UT, 84112, United States of America</aff>
    </contrib-group>
    <author-notes>
      <corresp id="CR1"><label>*</label>Corresponding author. <email>j.swanson@utah.edu</email> (Jessica M.J. Swanson).</corresp>
    </author-notes>
    <pub-date pub-type="nihms-submitted">
      <day>8</day>
      <month>10</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>2</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <month>6</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>25</day>
      <month>10</month>
      <year>2021</year>
    </pub-date>
    <volume>14</volume>
    <elocation-id>100676</elocation-id>
    <permissions>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbyncndlicense">https://creativecommons.org/licenses/by-nc-nd/4.0/</ali:license_ref>
        <license-p>This is an open access article under the CC BY-NC-ND license (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by-nc-nd/4.0/">http://creativecommons.org/licenses/by-nc-nd/4.0/</ext-link>).</license-p>
      </license>
    </permissions>
    <abstract id="ABS1">
      <p id="P1">New algorithms for determining the expected flow through simple cycles in a closed network are presented. Current network analysis software do not implement algorithms for expected cyclic flow decomposition, despite its potential value. Decomposing networks into expected cycle flows provides a quantitative characterization of network cycles that can be further analyzed for sensitivity and correlative behavior. An efficient, general algorithm has been coded into CycFlowDec, an open source Python module available at <ext-link ext-link-type="uri" xlink:href="https://github.com/austenb28/CycFlowDec">https://github.com/austenb28/CycFlowDec</ext-link>.</p>
    </abstract>
    <kwd-group>
      <kwd>CycFlowDec</kwd>
      <kwd>Cyclic flow decomposition</kwd>
      <kwd>Network analysis</kwd>
      <kwd>Kinetic networks</kwd>
      <kwd>Kinetic modeling</kwd>
    </kwd-group>
  </article-meta>
</front>
<body>
  <table-wrap id="T3" position="anchor" orientation="portrait">
    <caption>
      <p id="P2">Code metadata</p>
    </caption>
    <table frame="hsides" rules="none">
      <colgroup span="1">
        <col align="left" valign="middle" span="1"/>
        <col align="left" valign="middle" span="1"/>
      </colgroup>
      <tbody>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Current code version</td>
          <td align="left" valign="top" rowspan="1" colspan="1">v1</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Permanent link to code/repository used for this code version</td>
          <td align="left" valign="top" rowspan="1" colspan="1">
            <ext-link ext-link-type="uri" xlink:href="https://github.com/ElsevierSoftwareX/SOFTX-D-20-00084">https://github.com/ElsevierSoftwareX/SOFTX-D-20-00084</ext-link>
          </td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Code Ocean compute capsule</td>
          <td align="left" valign="top" rowspan="1" colspan="1">N/A</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Legal Code License</td>
          <td align="left" valign="top" rowspan="1" colspan="1">GPL 3.0</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Code versioning system used</td>
          <td align="left" valign="top" rowspan="1" colspan="1">Git</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Software code languages, tools, and services used</td>
          <td align="left" valign="top" rowspan="1" colspan="1">Python 3</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Compilation requirements, operating environments &amp; dependencies</td>
          <td align="left" valign="top" rowspan="1" colspan="1">Python 3, NumPy</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">If available Link to developer documentation/manual</td>
          <td align="left" valign="top" rowspan="1" colspan="1">
            <ext-link ext-link-type="uri" xlink:href="https://github.com/austenb28/CycFlowDec">https:/github.com/austenb28/CycFlowDec</ext-link>
          </td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">Support email for questions</td>
          <td align="left" valign="top" rowspan="1" colspan="1">
            <email>a.bernardi@utah.edu</email>
          </td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <sec id="S1">
    <label>1.</label>
    <title>Motivation and significance</title>
    <p id="P3">Network analysis is a practice that reaches all areas of science, from biology [<xref rid="R1" ref-type="bibr">1</xref>], to computer science [<xref rid="R2" ref-type="bibr">2</xref>], to traffic flow [<xref rid="R3" ref-type="bibr">3</xref>]. For some analyses, a central objective is to characterize the expected flow of certain cycles within a network [<xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R4" ref-type="bibr">4</xref>,<xref rid="R5" ref-type="bibr">5</xref>]. However, quantifying the relative probabilities of pathways through a complex network is generally non-trivial. Many graph theoretic algorithms have been developed to characterize network flow [<xref rid="R6" ref-type="bibr">6</xref>–<xref rid="R9" ref-type="bibr">9</xref>], and the software implementing these algorithms have gained popularity [<xref rid="R10" ref-type="bibr">10</xref>–<xref rid="R15" ref-type="bibr">15</xref>]. These methods generally quantify the maximum flow or minimum cost paths. However, there has been limited progress on the determination of the expected flow decomposition of complex networks. Previous studies concerning expected cycle flows have been largely theoretical [<xref rid="R16" ref-type="bibr">16</xref>,<xref rid="R17" ref-type="bibr">17</xref>], and have focused on developing mathematical descriptions of related system attributes, such as entropy production rates [<xref rid="R18" ref-type="bibr">18</xref>], or specific network types, such as quantum Markov semigroups [<xref rid="R19" ref-type="bibr">19</xref>].</p>
    <p id="P4">The primary motivator of this work involves the analysis of relevant ion transport pathways in a kinetic Markov state model of a Cl<sup>−</sup>/H<sup>+</sup> antiporter, [<xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R20" ref-type="bibr">20</xref>,<xref rid="R21" ref-type="bibr">21</xref>] for which decomposing the network into expected simple cyclic flows is essential. These cycles can be further studied to determine their sensitivities to specific transitions, revealing sub-ensemble properties and opening new avenues for mechanistic insight. Aside from this specific application, the Python module CycFlowDec, described in this work, has been designed to decompose a given flow network into expected simple cycle flows. Any chemical reaction network can be analyzed using CycFlowDec to quantitatively determine the expected flow of relevant reaction cycles. This feature is particularly valuable for analyzing networks in the fields of catalysis, such as the study of enzymatic networks or heterogeneous catalysis. Precise knowledge of expected cycle flows in reactive networks provides a quantitative metric for the importance of the underlying mechanisms that dictate the functionality of the reactive network. In an analogous fashion, CycFlowDec can be applied to the analysis of any application involving flow networks. For example, one could use CycFlowDec to determine the expected cycle flows in a communications network [<xref rid="R22" ref-type="bibr">22</xref>], a traffic network [<xref rid="R23" ref-type="bibr">23</xref>], a migration network [<xref rid="R24" ref-type="bibr">24</xref>], or a monetary network [<xref rid="R25" ref-type="bibr">25</xref>].</p>
  </sec>
  <sec id="S2">
    <label>2.</label>
    <title>Theoretical background</title>
    <p id="P5">New algorithms for decomposing a closed flow network into simple cycles are presented herein. Note that a simple cycle is a cycle that contains at most one instance of any node. Thus, an expected simple cycle flow decomposition assigns the expected flows to all simple cycles in a network such that the original flow network is recovered when the cycle flows are summed together. The mathematical framework of the algorithms presented in this work is based on the work developed in Ref. [<xref rid="R26" ref-type="bibr">26</xref>] and expanded on in chapter 3 of Ref. [<xref rid="R27" ref-type="bibr">27</xref>]. This section presents an overview of this previously developed framework, while the appendices describe the newly developed algorithms. The most efficient, general algorithm has been implemented in the CycFlowDec Python module, available at <ext-link ext-link-type="uri" xlink:href="https://github.com/austenb28/CycFlowDec">https://github.com/austenb28/CycFlowDec</ext-link> with examples and additional documentation. While the presented algorithms are designed to decompose closed flow networks into simple cycle flows, the framework can be straightforwardly extended to open networks via transformation of the open network to an effective closed network. This is accomplished by including an additional virtual node, which connects the network sinks to the sources.</p>
    <p id="P6">Four algorithms are sequentially outlined in <xref rid="APP1" ref-type="app">Appendix A</xref>, ending with the fastest algorithm, which is incorporated in CycFlowDec. We begin with a brief overview of the underlying theory [<xref rid="R26" ref-type="bibr">26</xref>,<xref rid="R27" ref-type="bibr">27</xref>]. Consider the three-node flow network <inline-formula><mml:math display="inline" id="M1"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> in <xref rid="F1" ref-type="fig">Fig. 1</xref>. Let a representative cyclic walk <italic>W</italic> on <inline-formula><mml:math display="inline" id="M2"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> be
<disp-formula id="FD1"><mml:math display="block" id="M3"><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>A</mml:mi><mml:mo>}</mml:mo><mml:mo>.</mml:mo></mml:math></disp-formula>
Walk <italic>W</italic> can be decomposed into simple cycles with the following procedure: [<xref rid="R27" ref-type="bibr">27</xref>]
<list list-type="order" id="L1"><list-item><p id="P7">Start at the first node of <italic>W</italic>. Mark it as visited.</p></list-item><list-item><p id="P8">Walk to the next node.</p></list-item><list-item><p id="P9">If the current node was already marked as visited, extract all nodes from its previous visitation up to the preceding node. Log the cycle composed by the extracted nodes. Mark the extracted nodes as unvisited except the current node. Otherwise, mark the current node as visited.</p></list-item><list-item><p id="P10">Repeat 2 and 3 until the end of the walk.</p></list-item></list></p>
    <p id="P11">Note that a simple cycle is a cycle that contains no more than one instance of any node. <xref rid="T1" ref-type="table">Table 1</xref> illustrates the decomposition of <italic>W</italic> using the described procedure. A cycle that cycles through <italic>q</italic> nodes <italic>n</italic><sub>1</sub>, <italic>n</italic><sub>2</sub>, . . ., <italic>n<sub>q</sub></italic>, . . . is denoted by (<italic>n</italic><sub>1</sub>, <italic>n</italic><sub>2</sub>, . . ., <italic>n<sub>q</sub></italic>). Extracting cycles with this procedure has several benefits. If the procedure is performed on a network <inline-formula><mml:math display="inline" id="M4"><mml:mrow><mml:mtext mathvariant="double-struck">N</mml:mtext></mml:mrow></mml:math></inline-formula> using a random walk generated via Markovian transition probabilities, we can define the divergent limit [<xref rid="R27" ref-type="bibr">27</xref>]
<disp-formula id="FD2"><label>(1)</label><mml:math display="block" id="M5"><mml:mrow><mml:munder><mml:mrow><mml:mi>lim</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mi>w</mml:mi><mml:mi>c</mml:mi><mml:mi>N</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mspace width="1.0em"/><mml:mo>∀</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℂ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>N</italic> is the length of the walk, C is the set of all simple cycles on <inline-formula><mml:math display="inline" id="M6"><mml:mrow><mml:mtext mathvariant="double-struck">N</mml:mtext></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math display="inline" id="M7"><mml:mrow><mml:msubsup><mml:mi>w</mml:mi><mml:mi>c</mml:mi><mml:mi>N</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> is the number of extracted cycles <italic>c</italic> on a walk of length <italic>N</italic>. <xref rid="FD2" ref-type="disp-formula">Eq. (1)</xref> represents the primary basis of all algorithms described in this work. The expected probability <italic>p<sub>c</sub></italic> of a cycle is given by [<xref rid="R27" ref-type="bibr">27</xref>]
<disp-formula id="FD3"><label>(2)</label><mml:math display="block" id="M8"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℂ</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>∀</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℂ</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    <p id="P12">Importantly, <italic>p<sub>c</sub></italic> is finite and takes on the same value irrespective of the starting node of the walk. The expected flow of a cycle <italic>c</italic>, given as <italic>f<sub>c</sub></italic>, may be calculated as
<disp-formula id="FD4"><label>(3)</label><mml:math display="block" id="M9"><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℂ</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>n</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:msub><mml:mi>w</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">E</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mi>e</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mspace width="1.0em"/><mml:mo>∀</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>ℂ</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math display="inline" id="M10"><mml:mrow><mml:mtext mathvariant="double-struck">E</mml:mtext></mml:mrow></mml:math></inline-formula> is the set of all edges on <inline-formula><mml:math display="inline" id="M11"><mml:mrow><mml:mtext mathvariant="double-struck">N</mml:mtext></mml:mrow></mml:math></inline-formula>, <italic>e<sub>j</sub></italic> is the flow of edge <italic>j</italic>, and <italic>n<sub>k</sub></italic> is the number of edges in cycle <italic>k</italic>. Combining <xref rid="FD3" ref-type="disp-formula">Eqs. (2)</xref> and <xref rid="FD4" ref-type="disp-formula">(3)</xref> shows that <italic>f<sub>c</sub></italic> is also finite and takes on the same value irrespective of the starting node of the walk. <xref rid="FD4" ref-type="disp-formula">Eq. (3)</xref> is the equation used in CycFlowDec to calculate cycle flows.</p>
  </sec>
  <sec id="S3">
    <label>3.</label>
    <title>Software description</title>
    <p id="P13">CycFlowDec is an open source Python module that enables the expected simple cycle flow decomposition of closed networks. Flow decomposition is accomplished using the percolating with burn-in and minimum contribution tolerance described in <xref rid="S15" ref-type="sec">Appendix A.4</xref>, enabling rapid and efficient performance on complex networks.</p>
    <sec id="S4">
      <label>3.1.</label>
      <title>Software architecture</title>
      <p id="P14">CycFlowDec is fully contained in a single, compact Python 3 script, requiring NumPy as its only external library. The object oriented structure uses a CycFlowDec main class, employing various methods for decomposition and analysis. An auxiliary Walk class is also used that enables efficient tracking of the percolating walks in the algorithm. A diagram of the architecture of CycFlowDec is provided in <xref rid="F2" ref-type="fig">Fig. 2</xref>. Detailed descriptions of the classes and methods along with examples are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/austenb28/CycFlowDec">https://github.com/austenb28/CycFlowDec</ext-link>.</p>
    </sec>
  </sec>
  <sec id="S5">
    <label>4.</label>
    <title>Illustrative examples</title>
    <sec id="S6">
      <label>4.1.</label>
      <title>Algorithm performances</title>
      <p id="P15">In order to assess the performance of the cyclic flow decomposition algorithms described in <xref rid="APP1" ref-type="app">Appendix A</xref>, the mean relative error (MRE) was calculated between edges of the reconstructed flow network from cycles and the original flow network. That is,
<disp-formula id="FD5"><label>(4)</label><mml:math display="block" id="M12"><mml:mrow><mml:mtext>MRE</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">E</mml:mi></mml:mrow></mml:munder><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℂ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mi>f</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>N<sub>E</sub></italic> is the number of edges in <inline-formula><mml:math display="inline" id="M13"><mml:mrow><mml:mtext mathvariant="double-struck">N</mml:mtext></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math display="inline" id="M14"><mml:mrow><mml:mtext mathvariant="double-struck">C</mml:mtext></mml:mrow></mml:math></inline-formula><sub><italic>j</italic></sub> is the set of simple cycles containing edge <italic>j</italic>. <xref rid="F3" ref-type="fig">Fig. 3</xref> shows the MRE vs. steps for the first three described algorithms for <inline-formula><mml:math display="inline" id="M15"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, the three-node network specified in <xref rid="F1" ref-type="fig">Fig. 1</xref>. The percolating with burn-in uses <italic>burn</italic> = <italic>N</italic> − 2, where <italic>N</italic> is the total number of steps. Optimizing the selection of <italic>burn</italic> is discussed in <xref rid="APP2" ref-type="app">Appendix B</xref>. The <inline-formula><mml:math display="inline" id="M16"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> network is small enough to use a minimum contribution tolerance of zero. The percolating with burn-in algorithm is significantly faster than the stochastic and percolating algorithms, exhibiting geometric instead of algebraic convergence. CycFlowDec employs the percolating with burn-in and minimum contribution tolerance algorithm, permitting rapid cyclic flow decomposition of closed networks.</p>
      <p id="P16">The <inline-formula><mml:math display="inline" id="M17"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> cyclic flow decomposition for the previously described algorithms is reported in <xref rid="T2" ref-type="table">Table 2</xref>. All three algorithms appear to be converging to the same decomposition, consistent with the fact that they are based on the same fundamental theory. Consistent with the final datapoints in <xref rid="F3" ref-type="fig">Fig. 3</xref>, the stochastically determined cycle flows agree with the higher accuracy algorithms by at least one digit, while the percolating cycle flows agree with the percolating with burn-in by at least four digits.</p>
    </sec>
    <sec id="S7">
      <label>4.2.</label>
      <title>Additional networks</title>
      <p id="P17">Since <inline-formula><mml:math display="inline" id="M18"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> is a small network, a seven-node network <inline-formula><mml:math display="inline" id="M19"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and a 64-node network <inline-formula><mml:math display="inline" id="M20"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> were also used to validate CycFlowDec. Networks <inline-formula><mml:math display="inline" id="M21"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math display="inline" id="M22"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> are depicted in <xref rid="F4" ref-type="fig">Figs. 4</xref> and <xref rid="F5" ref-type="fig">5</xref>, respectively. Network <inline-formula><mml:math display="inline" id="M23"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> represents a Markov state model of the Cl<sup>−</sup>/H<sup>+</sup> antiporter [<xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R20" ref-type="bibr">20</xref>,<xref rid="R21" ref-type="bibr">21</xref>] that largely motivated this work.</p>
      <p id="P18">The MRE convergence of the networks is shown in <xref rid="F6" ref-type="fig">Fig. 6</xref>. Intuitively, <inline-formula><mml:math display="inline" id="M24"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> requires substantially more steps to converge than the other networks; however, <inline-formula><mml:math display="inline" id="M25"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> actually converges faster than <inline-formula><mml:math display="inline" id="M26"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>. This implies that there is another factor affecting convergence besides the number of nodes and edges in the network. It is likely that this third factor is related to the relative flow balance of the network: networks with edge flows of similar magnitudes equilibrate percolation faster than networks with edge flows of highly variant magnitudes. Network <inline-formula><mml:math display="inline" id="M27"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> has edge flows that differ by a factor of 10, while the <inline-formula><mml:math display="inline" id="M28"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> edge flows are all <italic>O</italic>(1). Network <inline-formula><mml:math display="inline" id="M29"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> has edge flows that differ by over 10<sup>3</sup>. The algorithmic convergence rate is likely a complex function of the number of nodes and edges as well as the flow balance in the network, and warrants further investigation.</p>
    </sec>
  </sec>
  <sec id="S8">
    <label>5.</label>
    <title>Impact</title>
    <p id="P19">CycFlowDec decomposes closed flow networks into expected simple cycle flows. To the best of our knowledge, no other network analysis tools have been designed to accomplish this task. This tool has a broad potential use given the potentially important role of cyclic flow in closed flow networks in any scientific field involving flow networks, such as chemical reaction networks, communication networks, and more [<xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R4" ref-type="bibr">4</xref>,<xref rid="R5" ref-type="bibr">5</xref>,<xref rid="R22" ref-type="bibr">22</xref>–<xref rid="R25" ref-type="bibr">25</xref>]. Determining the expected cycle flows in a flow network yields a direct metric for importance of the underlying cycles that constitute network function. This information is especially valuable for quantitatively determining fundamental mechanisms that dictate functional behavior in the network. The example network <inline-formula><mml:math display="inline" id="M30"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> represents an enzymatic ion transport network of a Cl<sup>−</sup>/H<sup>+</sup> antiporter, which can be directly analyzed with CycFlowDec [<xref rid="R1" ref-type="bibr">1</xref>,<xref rid="R20" ref-type="bibr">20</xref>,<xref rid="R21" ref-type="bibr">21</xref>]. Future work will expand on this analysis, including the assessment of cycle sensitivity to specific transitions, and applicability to obtain mechanistic insight in the complex biological system.</p>
    <p id="P20">CycFlowDec is an open source Python module published under the GNU General Public License. This transparency ensures straightforward access to all interested parties and allows further modification of CycFlowDec. Additionally, the lightweight design and simple Python interface enables direct incorporation into general research projects and programs. The simple Python module format is well suited for CycFlowDec due to its wide potential range of applicability for network analysis.</p>
    <p id="P21">CycFlowDec was designed for the decomposition of close flow networks into simple cycle flows, but it can also be applied to the analysis of open networks with no internal modification. This can be accomplished by defining an effective closed flow network for the open network, where the source nodes are connected to the sink nodes via an intermediate virtual node. Using CycFlowDec to decompose the effective closed network will result in simple cycle flows, some of which include the virtual node. The simple cycles that include the virtual node represent transient path flows, where the transient path is given by removing the virtual node. This additional application of CycFlowDec to open flow networks further increases the range of applicability. For example, CycFlowDec has only been applied to steady state networks involving the Cl<sup>−</sup>/H<sup>+</sup> antiporter represented by <inline-formula><mml:math display="inline" id="M31"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, whereas the intermediate, transient state networks could be analyzed using the previously mentioned open network analysis.</p>
  </sec>
  <sec id="S9">
    <label>6.</label>
    <title>Conclusions</title>
    <p id="P22">A novel, efficient algorithm for determining the cyclic flow decomposition of closed networks is presented. The algorithm is incorporated in the open source Python module CycFlowDec. While CycFlowDec was designed for closed networks, it is applicable to open networks by defining an analogous effective closed network where a source and sink flows are sent to a virtual node. CycFlowDec enables more comprehensive analyses of cyclic flow networks, which are present in many fields of science.</p>
  </sec>
</body>
<back>
  <ack id="S10">
    <title>Acknowledgments</title>
    <p id="P23">The authors are grateful to Dr. Heather Mayes, Dr. Sangun Lee, Dr. Zhi Yue, and Dr. Vadhana Varadarajan for their motivating research, and to Andrew Ralph for his assistance in testing. The authors also thank Dr. Dionisios Vlachos and Dr. Udit Gupta for insightful discussions. This work was funded, in part, by a collaborative development award from the CHEETAH Center at the University of Utah, United States of America (NIH P50 AI150464). The support and resources of the Center for High Performance Computing at the University of Utah are also gratefully acknowledged.</p>
  </ack>
  <fn-group>
    <fn fn-type="COI-statement" id="FN1">
      <p id="P37">Declaration of competing interest</p>
      <p id="P38">The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.</p>
    </fn>
  </fn-group>
  <app-group>
    <app id="APP1">
      <label>Appendix A.</label>
      <title>Algorithms</title>
      <p id="P24">The CycFlowDec Python module implements a single efficient, general algorithm based on established Markovian circulation theory [<xref rid="R26" ref-type="bibr">26</xref>,<xref rid="R27" ref-type="bibr">27</xref>]. The algorithm is a product of three sequential modifications on simpler algorithms that are described first.</p>
      <sec id="S12">
        <label>A.1.</label>
        <title>Stochastic algorithm</title>
        <p id="P25">The first algorithm described is directly obtained from the underlying theory. The pseudocode is provided in <xref rid="T4" ref-type="table">algorithm 1</xref>. The left stochastic matrix <bold>M</bold> is calculated using
<disp-formula id="FD6"><label>(A.1)</label><mml:math display="block" id="M32"><mml:mrow><mml:mi mathvariant="bold">M</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>e</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo>∀</mml:mo><mml:mi>l</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ℝ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:munder><mml:msub><mml:mi>e</mml:mi><mml:mi>l</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mspace width="1.0em"/><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">V</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math display="inline" id="M33"><mml:mrow><mml:mtext mathvariant="double-struck">V</mml:mtext></mml:mrow></mml:math></inline-formula> is the set of all nodes on <inline-formula><mml:math display="inline" id="M34"><mml:mrow><mml:mtext mathvariant="double-struck">N</mml:mtext></mml:mrow></mml:math></inline-formula>, <italic>e<sub>j,k</sub></italic> the edge flow from node <italic>j</italic> to node <italic>k</italic>, and <inline-formula><mml:math display="inline" id="M35"><mml:mrow><mml:mtext mathvariant="double-struck">E</mml:mtext></mml:mrow></mml:math></inline-formula><sub><italic>j</italic></sub> is the set of all edges emanating from node <italic>j</italic>. For <inline-formula><mml:math display="inline" id="M36"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> in <xref rid="F1" ref-type="fig">Fig. 1</xref>,
<disp-formula id="FD7"><mml:math display="block" id="M37"><mml:mrow><mml:mi mathvariant="bold">M</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mn>38</mml:mn><mml:mo>/</mml:mo><mml:mn>43</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>6</mml:mn><mml:mo>/</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>40</mml:mn><mml:mo>/</mml:mo><mml:mn>44</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mn>3</mml:mn><mml:mo>/</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mn>4</mml:mn><mml:mo>/</mml:mo><mml:mn>44</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>5</mml:mn><mml:mo>/</mml:mo><mml:mn>43</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
<xref rid="FD6" ref-type="disp-formula">Eq. (A.1)</xref> is used to calculate <bold>M</bold> for all algorithms in this work. The stack data structure is appropriate for storing walks, since cycles are always extracted from the end of the walk. <bold>Roll</bold>(0, 1) rolls a random uniform real number between zero and one that is used to stochastically select the next node in the walk with <bold>M</bold>. The stack method pop_cycle(<italic>k</italic>) extracts and returns the encountered cycle starting from node <italic>k</italic> according to the previously defined procedure. The resulting cycle counts <italic>w<sub>c</sub></italic> keyed by cycle <italic>c</italic> are stored in the hash table <bold>C</bold>, which can be used to calculate cycle flows with <xref rid="FD4" ref-type="disp-formula">Eq. (3)</xref>.</p>
        <table-wrap id="T4" position="anchor" orientation="portrait">
          <label>Algorithm 1:</label>
          <caption>
            <p id="P26">Stochastic cyclic flow decomposition.</p>
          </caption>
          <table frame="hsides" rules="none">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Generate</bold> the stochastic matrix <bold>M</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Initialize</bold> an empty stack <bold>S</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Initialize</bold> an empty hash table <bold>C</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Put</bold> a starting node on <bold>S</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>for</bold><italic>j</italic> 1 <bold>to</bold>
<italic>N</italic>
<bold>do</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <italic>r</italic>
<bold>Roll</bold>(0, 1)</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>for</bold>
<italic>k</italic>
<bold>in</bold> rows(<bold>M</bold>) <bold>do</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>if M</bold>[k,<bold>S[end]</bold>] ≤ <italic>r</italic>
<bold>then</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>break</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>end if</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>end for</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>if</bold>
<italic>k</italic>
<bold>in S then</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <italic>c</italic> = <bold>S</bold>.pop_cycle(<italic>k</italic>)</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>C</bold>[<italic>c</italic>] += 1</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>else</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>S</bold>.push(<italic>k</italic>)</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>end if</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec id="S13">
        <label>A.2.</label>
        <title>Percolating algorithm</title>
        <p id="P27">The percolating algorithm extends the stochastic algorithm in the limit of infinite walks emanating from the starting node. In this sense, infinite walks deterministically percolate the network from the starting node, and cycles are extracted and counted as they are encountered. The pseudocode is provided in <xref rid="T5" ref-type="table">algorithm 2</xref>, for the case that the variables <italic>burn</italic> and <italic>tol</italic> (defined in <xref rid="S14" ref-type="sec">Appendices A.3</xref> and <xref rid="S15" ref-type="sec">A.4</xref>, respectively) are initialized to zero. Instead of explicitly counting the number of occurrences of the simple cycles, the fractional contribution of each cycle with respect to all walks is used for <italic>w<sub>c</sub></italic>. For example, if 3% of walks go through cycle <italic>c</italic> at a given iteration, then w<italic><sub>c</sub></italic> is incremented by 0.03. The two hash tables <bold>H</bold><sub>1</sub> and <bold>H</bold><sub>1</sub> keyed by walk stacks are used to alternate the percolation steps and progress the walks. The percolating algorithm takes advantage of the ability to consolidate walks with the same stacks after cycle extraction, allowing the tracking of infinite percolating walks without combinatorial explosion. Similar to the stochastic algorithm, the resulting cycle contributions <italic>w<sub>c</sub></italic> are stored in hash table <bold>C</bold>, and can be used to calculate cycle flows with <xref rid="FD4" ref-type="disp-formula">Eq. (3)</xref>. Both algorithms subsequently described result in <bold>C</bold> in the same fashion.</p>
      </sec>
      <sec id="S14">
        <label>A.3.</label>
        <title>Percolating with burn-in algorithm</title>
        <p id="P28">The percolating algorithm is subject to initialization bias at earlier iterations, since it takes time for the walks to fully percolate and equilibrate. A straightforward idea to mitigate this issue is to refrain from counting cycles for some number <italic>burn</italic> of initial iterations. This inclusion of a burn-in with the percolating algorithm is shown in <xref rid="T5" ref-type="table">algorithm 2</xref>, for the case that the variable <italic>tol</italic> is initialized to zero.</p>
      </sec>
      <sec id="S15">
        <label>A.4.</label>
        <title>Percolating with burn-in and minimum contribution tolerance</title>
        <p id="P29">For highly connected, large networks, the percolating algorithm will suffer from combinatorial explosion, since the convergence rate decreases linearly with the number of feasible simple cycles. At the cost of maximum achievable accuracy, this issue can be mitigated by only percolating new walk stacks that contribute to the total number of walks above a fractional tolerance <italic>tol</italic>. This modification is shown in <xref rid="T5" ref-type="table">algorithm 2</xref>. Walks that contribute below <italic>tol</italic> but do not result in new walk stacks are still percolated, since they do not increase the total number of walk stacks. Contributions that are not percolated are folded back into the originating walk.</p>
        <table-wrap id="T5" position="anchor" orientation="portrait">
          <label>Algorithm 2:</label>
          <caption>
            <p id="P30">Percolating cyclic flow decomposition with burn-in and minimum contribution tolerance algorithm.</p>
          </caption>
          <table frame="hsides" rules="none">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Generate</bold> the stochastic matrix <bold>M</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Initialize</bold> an empty hash table <bold>H</bold><sub>−1</sub></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Initialize</bold> an empty hash table <bold>H</bold><sub>1</sub></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Initialize</bold> an empty hash table <bold>C</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>Initialize</bold> a stack <bold>S</bold> containing a starting node</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>H</bold><sub>−1</sub>[<bold>S</bold>] = 1</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><italic>b</italic> = 1</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"><bold>for</bold><italic>j</italic> = 1 <bold>to</bold>
<italic>N</italic>
<bold>do</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>for S in H</bold><sub>−<italic>b</italic></sub>.keys() <bold>do</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>H</bold><sub><italic>b</italic></sub>
<bold>S</bold> = 0</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>end for</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>for S in H</bold><sub>−<italic>b</italic></sub>.keys() <bold>do</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <italic>r</italic> = 0</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>for</bold>
<italic>k</italic>
<bold>in</bold> rows(<bold>M</bold>) <bold>do</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <italic>f</italic> = <bold>H</bold><sub>−<italic>b</italic></sub>[<bold>S</bold>] ∗ <bold>M</bold>[<italic>k</italic>, <bold>S</bold>[<bold>end</bold>]]</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>Q = S</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>if H</bold><sub>−<italic>b</italic></sub>
<bold>S</bold> &gt; <italic>tol</italic>
<bold>or</bold>
<italic>k</italic>
<bold>in S then</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <bold>if</bold>
<italic>j</italic> &gt; <italic>burn</italic>
<bold>and</bold>
<italic>k</italic>
<bold>in S then</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">     <italic>c</italic> = <bold>Q</bold>.pop_cycle(<italic>k</italic>)</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">     <bold>C</bold>[<italic>c</italic>] += <italic>f</italic></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <bold>else</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">     <bold>Q</bold>.push(<italic>k</italic>)</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <bold>end if</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <bold>if Q in H</bold><sub><italic>b</italic></sub>.keys() <bold>then</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">     <bold>H</bold><sub><italic>b</italic></sub>[<bold>Q</bold>] += <italic>f</italic></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <bold>else</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">     <bold>H</bold><sub><italic>b</italic></sub>[<bold>Q</bold>] = <italic>f</italic></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <bold>end if</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>else</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">    <italic>r += f</italic></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>end if</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>end for</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>if S in H</bold><sub><italic>b</italic></sub>.keys() <bold>then</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>H</bold><sub><italic>b</italic></sub>[<bold>S</bold>] += <italic>r</italic></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>else</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">   <bold>H</bold><sub><italic>b</italic></sub>[<bold>S</bold>] = <italic>r</italic></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">  <bold>end if</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <bold>end for</bold></td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1"> <italic>b</italic> *= −1</td>
              </tr>
              <tr>
                <td align="left" valign="top" rowspan="1" colspan="1">
                  <bold>end for</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
    </app>
    <app id="APP2">
      <label>Appendix B.</label>
      <title>Burn-in selection</title>
      <fig id="F7" orientation="portrait" position="anchor">
        <label>Fig. B.7.</label>
        <caption>
          <p id="P31">Semi-log plots of MRE vs. burn-in steps for <inline-formula><mml:math display="inline" id="M38"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math display="inline" id="M39"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math display="inline" id="M40"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>. Total steps were fixed at 150, 50, and 3000 for the three, seven, and 64-node networks, respectively.</p>
        </caption>
        <graphic xlink:href="nihms-1708640-f0007"/>
      </fig>
      <fig id="F8" orientation="portrait" position="anchor">
        <label>Fig. B.8.</label>
        <caption>
          <p id="P32">Semi-log plot of MRE vs. burn-in steps for a network analogous to <inline-formula><mml:math display="inline" id="M41"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math display="inline" id="M42"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>A</mml:mi><mml:mi>B</mml:mi></mml:mrow><mml:mo stretchy="true">⇀</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow><mml:mo stretchy="true">⇀</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>C</mml:mi><mml:mi>A</mml:mi></mml:mrow><mml:mo stretchy="true">⇀</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mn>40</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math display="inline" id="M43"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>A</mml:mi><mml:mi>C</mml:mi></mml:mrow><mml:mo stretchy="true">⇀</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>C</mml:mi><mml:mi>B</mml:mi></mml:mrow><mml:mo stretchy="true">⇀</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>B</mml:mi><mml:mi>A</mml:mi></mml:mrow><mml:mo stretchy="true">⇀</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Total steps were fixed at 500.</p>
        </caption>
        <graphic xlink:href="nihms-1708640-f0008"/>
      </fig>
      <p id="P33">The burn-in is a critical component of algorithm efficiency, as demonstrated in <xref rid="F3" ref-type="fig">Fig. 3</xref>. To investigate the effects of burn-in selection, different burn-ins were tested for the same total steps for all three validation networks, shown in <xref rid="F7" ref-type="fig">Fig. B.7</xref>. An interesting pattern arises from this data: all three networks show dual behavior for even and odd burn-in steps. Upon further testing, the behavior is actually dependent on whether the number of cycle logging steps <italic>log = N − burn</italic> is even or odd. Specifically, even <italic>log</italic> steps exhibit generally decreasing, lower MRE, while odd <italic>log</italic> steps exhibit higher MRE with an upturn for <italic>log</italic> near zero. Network <inline-formula><mml:math display="inline" id="M44"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> shows the least difference between even and odd <italic>log</italic> steps, probably since it contains the most balanced edge flows. A burn-in of <italic>N</italic> − 2 is slightly higher than <italic>N</italic> − 4 for <inline-formula><mml:math display="inline" id="M45"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, probably due to <inline-formula><mml:math display="inline" id="M46"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> requiring a non-zero minimum contribution tolerance to accelerate its computation.</p>
      <p id="P34">As it so happens, <inline-formula><mml:math display="inline" id="M47"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math display="inline" id="M48"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math display="inline" id="M49"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> all have dominant flow cycles of length two. In order to test whether the burn-in behavior was sensitive to this, a network with the same structure as <inline-formula><mml:math display="inline" id="M50"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> but with a dominant flow cycle of length three was tested. The result is shown in <xref rid="F8" ref-type="fig">Fig. B.8</xref>. The burn-in behavior appears sensitive to the dominant flow cycle length, as ternary burn-in behavior is observed with the length three cycle dominant network. For complex networks where computational efficiency is a limiting factor, the burn-in behavior should be tested, as no simple, general choice of burn-in is apparent without prior knowledge of cycle flows.</p>
    </app>
    <app id="APP3">
      <label>Appendix C.</label>
      <title>Minimum contribution tolerance selection</title>
      <fig id="F9" orientation="portrait" position="anchor">
        <label>Fig. C.9.</label>
        <caption>
          <p id="P35">Semi-log plot of MRE vs. steps for different minimum contribution tolerances for <inline-formula><mml:math display="inline" id="M51"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>. Edge flows below 0.1 are omitted from the MRE calculation.</p>
        </caption>
        <graphic xlink:href="nihms-1708640-f0009"/>
      </fig>
      <p id="P36">For <inline-formula><mml:math display="inline" id="M52"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, a minimum contribution tolerance <italic>tol</italic> is required to permit tractable computation times. The behavior of the cyclic flow network convergence of <inline-formula><mml:math display="inline" id="M53"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> with respect to <italic>tol</italic> is shown in <xref rid="F9" ref-type="fig">Fig. C.9</xref>. For all values of <italic>tol</italic>, the MRE decrease exponentially until a certain step number is reached, and then levels out. This behavior is consistent with the concept that incorporating a minimum contribution tolerance decreases the maximum achievable accuracy of cyclic flow decomposition. Lower MRE is obtainable using lower tolerances, at the cost of increasing computational expense.</p>
    </app>
  </app-group>
  <ref-list>
    <title>References</title>
    <ref id="R1">
      <label>[1]</label>
      <mixed-citation publication-type="journal"><name><surname>Mayes</surname><given-names>HB</given-names></name>, <name><surname>Lee</surname><given-names>S</given-names></name>, <name><surname>White</surname><given-names>AD</given-names></name>, <name><surname>Voth</surname><given-names>GA</given-names></name>, <name><surname>Swanson</surname><given-names>JM</given-names></name>. <article-title>Multiscale kinetic modeling reveals an ensemble of Cl–/H+ exchange pathways in ClC-ec1 antiporter</article-title>. <source>J Am Chem Soc</source><year>2018</year>;<volume>140</volume>(<issue>5</issue>):<fpage>1793</fpage>–<lpage>804</lpage>.<pub-id pub-id-type="pmid">29332400</pub-id></mixed-citation>
    </ref>
    <ref id="R2">
      <label>[2]</label>
      <mixed-citation publication-type="journal"><name><surname>Rawat</surname><given-names>W</given-names></name>, <name><surname>Wang</surname><given-names>Z</given-names></name>. <article-title>Deep convolutional neural networks for image classification: A comprehensive review</article-title>. <source>Neural Comput</source><year>2017</year>;<volume>29</volume>(<issue>9</issue>):<fpage>2352</fpage>–<lpage>449</lpage>.<pub-id pub-id-type="pmid">28599112</pub-id></mixed-citation>
    </ref>
    <ref id="R3">
      <label>[3]</label>
      <mixed-citation publication-type="journal"><name><surname>Yan</surname><given-names>Y</given-names></name>, <name><surname>Zhang</surname><given-names>S</given-names></name>, <name><surname>Tang</surname><given-names>J</given-names></name>, <name><surname>Wang</surname><given-names>X</given-names></name>. <article-title>Understanding characteristics in multivariate traffic flow time series from complex network structure</article-title>. <source>Physica A</source><year>2017</year>;<volume>477</volume>:<fpage>149</fpage>–<lpage>60</lpage>.</mixed-citation>
    </ref>
    <ref id="R4">
      <label>[4]</label>
      <mixed-citation publication-type="journal"><name><surname>Manik</surname><given-names>D</given-names></name>, <name><surname>Timme</surname><given-names>M</given-names></name>, <name><surname>Witthaut</surname><given-names>D</given-names></name>. <article-title>Cycle flows and multistability in oscillatory networks</article-title>. <source>Chaos</source><year>2017</year>;<volume>27</volume>(<issue>8</issue>):<fpage>083123</fpage>.<pub-id pub-id-type="pmid">28863499</pub-id></mixed-citation>
    </ref>
    <ref id="R5">
      <label>[5]</label>
      <mixed-citation publication-type="journal"><name><surname>Wang</surname><given-names>G</given-names></name>, <name><surname>Du</surname><given-names>C</given-names></name>, <name><surname>Chen</surname><given-names>H</given-names></name>, <name><surname>Simha</surname><given-names>R</given-names></name>, <name><surname>Rong</surname><given-names>Y</given-names></name>, <name><surname>Xiao</surname><given-names>Y</given-names></name>, <name><surname>Zeng</surname><given-names>C</given-names></name>. <article-title>Process-based network decomposition reveals backbone motif structure</article-title>. <source>Proc Natl Acad Sci</source><year>2010</year>;<volume>107</volume>(<issue>23</issue>):<fpage>10478</fpage>–<lpage>83</lpage>.<pub-id pub-id-type="pmid">20498084</pub-id></mixed-citation>
    </ref>
    <ref id="R6">
      <label>[6]</label>
      <mixed-citation publication-type="journal"><name><surname>Dantzig</surname><given-names>G</given-names></name>, <name><surname>Fulkerson</surname><given-names>DR</given-names></name>. <article-title>On the max flow min cut theorem of networks</article-title>. <source>Linear Inequal Relat Syst</source><year>2003</year>;<volume>38</volume>:<fpage>225</fpage>–<lpage>31</lpage>.</mixed-citation>
    </ref>
    <ref id="R7">
      <label>[7]</label>
      <mixed-citation publication-type="journal"><name><surname>Froncek</surname><given-names>D</given-names></name>. <article-title>Cyclic decompositions of complete graphs into spanning trees</article-title>. <source>Discuss Math Graph Theory</source><year>2004</year>;<volume>24</volume>(<issue>2</issue>):<fpage>345</fpage>–<lpage>53</lpage>.</mixed-citation>
    </ref>
    <ref id="R8">
      <label>[8]</label>
      <mixed-citation publication-type="journal"><name><surname>Rosa</surname><given-names>A</given-names></name>. <article-title>On cyclic decompositions of the complete graph into (4m 2)-gons</article-title>. <source>Mat-fyz Časopis</source><year>1966</year>;<volume>16</volume>(<issue>4</issue>):<fpage>349</fpage>–<lpage>52</lpage>.</mixed-citation>
    </ref>
    <ref id="R9">
      <label>[9]</label>
      <mixed-citation publication-type="journal"><name><surname>Woodhouse</surname><given-names>FG</given-names></name>, <name><surname>Forrow</surname><given-names>A</given-names></name>, <name><surname>Fawcett</surname><given-names>JB</given-names></name>, <name><surname>Dunkel</surname><given-names>J</given-names></name>. <article-title>Stochastic cycle selection in active flow networks</article-title>. <source>Proc Natl Acad Sci</source><year>2016</year>;<volume>113</volume>(<issue>29</issue>):<fpage>8200</fpage>–<lpage>5</lpage>.<pub-id pub-id-type="pmid">27382186</pub-id></mixed-citation>
    </ref>
    <ref id="R10">
      <label>[10]</label>
      <mixed-citation publication-type="journal"><name><surname>Csardi</surname><given-names>G</given-names></name>, <name><surname>Nepusz</surname><given-names>T</given-names></name>, <etal/><article-title>The igraph software package for complex network research</article-title>. <source>Int J Complex Syst</source><year>2006</year>;<volume>1695</volume>(<issue>5</issue>):<fpage>1</fpage>–<lpage>9</lpage>.</mixed-citation>
    </ref>
    <ref id="R11">
      <label>[11]</label>
      <mixed-citation publication-type="journal"><name><surname>Langfelder</surname><given-names>P</given-names></name>, <name><surname>Horvath</surname><given-names>S</given-names></name>. <article-title>WGCNA: An R package for weighted correlation network analysis</article-title>. <source>BMC Bioinformatics</source><year>2008</year>;<volume>9</volume>(<issue>1</issue>):<fpage>559</fpage>.<pub-id pub-id-type="pmid">19114008</pub-id></mixed-citation>
    </ref>
    <ref id="R12">
      <label>[12]</label>
      <mixed-citation publication-type="journal"><name><surname>Handcock</surname><given-names>MS</given-names></name>, <name><surname>Hunter</surname><given-names>DR</given-names></name>, <name><surname>Butts</surname><given-names>CT</given-names></name>, <name><surname>Goodreau</surname><given-names>SM</given-names></name>, <name><surname>Morris</surname><given-names>M</given-names></name>. <article-title>Statnet: Software tools for the representation, visualization, analysis and simulation of network data</article-title>. <source>J Stat Softw</source><year>2008</year>;<volume>24</volume>(<issue>1</issue>):<fpage>1548</fpage>.</mixed-citation>
    </ref>
    <ref id="R13">
      <label>[13]</label>
      <mixed-citation publication-type="book"><name><surname>De Nooy</surname><given-names>W</given-names></name>, <name><surname>Mrvar</surname><given-names>A</given-names></name>, <name><surname>Batagelj</surname><given-names>V</given-names></name>. <source>Exploratory social network analysis with pajek: Revised and expanded edition for updated software</source>, vol. 46. <publisher-name>Cambridge University Press</publisher-name>; <year>2018</year>.</mixed-citation>
    </ref>
    <ref id="R14">
      <label>[14]</label>
      <mixed-citation publication-type="journal"><name><surname>Thomas</surname><given-names>S</given-names></name>, <name><surname>Bonchev</surname><given-names>D</given-names></name>. <article-title>A survey of current software for network analysis in molecular biology</article-title>. <source>Hum Genom</source><year>2010</year>;<volume>4</volume>(<issue>5</issue>):<fpage>353</fpage>.</mixed-citation>
    </ref>
    <ref id="R15">
      <label>[15]</label>
      <mixed-citation publication-type="journal"><name><surname>Hoops</surname><given-names>S</given-names></name>, <name><surname>Sahle</surname><given-names>S</given-names></name>, <name><surname>Gauges</surname><given-names>R</given-names></name>, <name><surname>Lee</surname><given-names>C</given-names></name>, <name><surname>Pahle</surname><given-names>J</given-names></name>, <name><surname>Simus</surname><given-names>N</given-names></name>, <name><surname>Singhal</surname><given-names>M</given-names></name>, <name><surname>Xu</surname><given-names>L</given-names></name>, <name><surname>Mendes</surname><given-names>P</given-names></name>, <name><surname>Kummer</surname><given-names>U</given-names></name>. <article-title>COPASI—a complex pathway simulator</article-title>. <source>Bioinformatics</source><year>2006</year>;<volume>22</volume>(<issue>24</issue>):<fpage>3067</fpage>–<lpage>74</lpage>.<pub-id pub-id-type="pmid">17032683</pub-id></mixed-citation>
    </ref>
    <ref id="R16">
      <label>[16]</label>
      <mixed-citation publication-type="journal"><name><surname>Banisch</surname><given-names>R</given-names></name>, <name><surname>Conrad</surname><given-names>ND</given-names></name>. <article-title>Cycle-flow–based module detection in directed recurrence networks</article-title>. <source>Europhys Lett</source><year>2015</year>;<volume>108</volume>(<issue>6</issue>):<fpage>68008</fpage>.</mixed-citation>
    </ref>
    <ref id="R17">
      <label>[17]</label>
      <mixed-citation publication-type="journal"><name><surname>Banisch</surname><given-names>R</given-names></name>, <name><surname>Conrad</surname><given-names>N</given-names></name>, <name><surname>Schütte</surname><given-names>C</given-names></name>. <article-title>Reactive flows and unproductive cycles for random walks on complex networks</article-title>. <source>Eur Phys J Spec Top</source><year>2015</year>;<volume>224</volume>(<issue>12</issue>):<fpage>2369</fpage>–<lpage>87</lpage>.</mixed-citation>
    </ref>
    <ref id="R18">
      <label>[18]</label>
      <mixed-citation publication-type="journal"><name><surname>Jia</surname><given-names>C</given-names></name>, <name><surname>Jiang</surname><given-names>D-Q</given-names></name>, <name><surname>Qian</surname><given-names>M-P</given-names></name>, <etal/><article-title>Cycle symmetries and circulation fluctuations for discrete-time and continuous-time Markov chains</article-title>. <source>Ann Appl Probab</source><year>2016</year>;<volume>26</volume>(<issue>4</issue>):<fpage>2454</fpage>–<lpage>93</lpage>.</mixed-citation>
    </ref>
    <ref id="R19">
      <label>[19]</label>
      <mixed-citation publication-type="journal"><name><surname>Fagnola</surname><given-names>F</given-names></name>, <name><surname>Umanita</surname><given-names>V</given-names></name>. <article-title>Generic quantum Markov semigroups, cycle decomposition and deviation from equilibrium</article-title>. <source>Infin. Dimens. Anal. Quantum Probab. Relat. Top</source><year>2012</year>;<volume>15</volume>(<issue>03</issue>):<fpage>1250016</fpage>.</mixed-citation>
    </ref>
    <ref id="R20">
      <label>[20]</label>
      <mixed-citation publication-type="journal"><name><surname>Lee</surname><given-names>S</given-names></name>, <name><surname>Swanson</surname><given-names>JM</given-names></name>, <name><surname>Voth</surname><given-names>GA</given-names></name>. <article-title>Multiscale simulations reveal key aspects of the proton transport mechanism in the ClC-ec1 antiporter</article-title>. <source>Biophys J</source><year>2016</year>;<volume>110</volume>(<issue>6</issue>):<fpage>1334</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">27028643</pub-id></mixed-citation>
    </ref>
    <ref id="R21">
      <label>[21]</label>
      <mixed-citation publication-type="journal"><name><surname>Lee</surname><given-names>S</given-names></name>, <name><surname>Mayes</surname><given-names>HB</given-names></name>, <name><surname>Swanson</surname><given-names>JM</given-names></name>, <name><surname>Voth</surname><given-names>GA</given-names></name>. <article-title>The origin of coupled chloride and proton transport in a Cl–/H+ antiporter</article-title>. <source>J Am Chem Soc</source><year>2016</year>;<volume>138</volume>(<issue>45</issue>):<fpage>14923</fpage>–<lpage>30</lpage>.<pub-id pub-id-type="pmid">27783900</pub-id></mixed-citation>
    </ref>
    <ref id="R22">
      <label>[22]</label>
      <mixed-citation publication-type="journal"><name><surname>Hagen</surname><given-names>L</given-names></name>, <name><surname>Keller</surname><given-names>T</given-names></name>, <name><surname>Neely</surname><given-names>S</given-names></name>, <name><surname>DePaula</surname><given-names>N</given-names></name>, <name><surname>Robert-Cooperman</surname><given-names>C</given-names></name>. <article-title>Crisis communications in the age of social media: A network analysis of Zika-related tweets</article-title>. <source>Soc Sci Comput Rev</source><year>2018</year>;<volume>36</volume>(<issue>5</issue>):<fpage>523</fpage>–<lpage>41</lpage>.</mixed-citation>
    </ref>
    <ref id="R23">
      <label>[23]</label>
      <mixed-citation publication-type="journal"><name><surname>Ding</surname><given-names>R</given-names></name>, <name><surname>Ujang</surname><given-names>N</given-names></name>, <name><surname>bin Hamid</surname><given-names>H</given-names></name>, <name><surname>Abd Manan</surname><given-names>MS</given-names></name>, <name><surname>He</surname><given-names>Y</given-names></name>, <name><surname>Li</surname><given-names>R</given-names></name>, <name><surname>Wu</surname><given-names>J</given-names></name>. <article-title>Detecting the urban traffic network structure dynamics through the growth and analysis of multi-layer networks</article-title>. <source>Physica A</source><year>2018</year>;<volume>503</volume>:<fpage>800</fpage>–<lpage>17</lpage>.</mixed-citation>
    </ref>
    <ref id="R24">
      <label>[24]</label>
      <mixed-citation publication-type="journal"><name><surname>Myers</surname><given-names>OM</given-names></name>, <name><surname>Reyier</surname><given-names>E</given-names></name>, <name><surname>Ahr</surname><given-names>B</given-names></name>, <name><surname>Cook</surname><given-names>GS</given-names></name>. <article-title>Striped mullet migration patterns in the Indian River Lagoon: A network analysis approach to spatial fisheries management</article-title>. <source>Mar. Coast. Fish</source><year>2020</year>;<volume>12</volume>(<issue>6</issue>):<fpage>423</fpage>–<lpage>40</lpage>.</mixed-citation>
    </ref>
    <ref id="R25">
      <label>[25]</label>
      <mixed-citation publication-type="journal"><name><surname>Iosifidis</surname><given-names>G</given-names></name>, <name><surname>Charette</surname><given-names>Y</given-names></name>, <name><surname>Airoldi</surname><given-names>EM</given-names></name>, <name><surname>Littera</surname><given-names>G</given-names></name>, <name><surname>Tassiulas</surname><given-names>L</given-names></name>, <name><surname>Christakis</surname><given-names>NA</given-names></name>. <article-title>Cyclic motifs in the Sardex monetary network</article-title>. <source>Nat Hum Behav</source><year>2018</year>;<volume>2</volume>(<issue>11</issue>):<fpage>822</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">31558815</pub-id></mixed-citation>
    </ref>
    <ref id="R26">
      <label>[26]</label>
      <mixed-citation publication-type="journal"><name><surname>Minping</surname><given-names>Q</given-names></name>, <name><surname>Min</surname><given-names>Q</given-names></name>. <article-title>Circulation for recurrent Markov chains</article-title>. <source>Z. Wahrscheinlichkeitstheor. Verwandte Geb</source><year>1982</year>;<volume>59</volume>(<issue>2</issue>):<fpage>203</fpage>–<lpage>10</lpage>.</mixed-citation>
    </ref>
    <ref id="R27">
      <label>[27]</label>
      <mixed-citation publication-type="book"><name><surname>Kalpazidou</surname><given-names>SL</given-names></name>. <source>Cycle representations of Markov processes</source>, vol. 28. <publisher-name>Springer Science &amp; Business Media</publisher-name>; <year>2007</year>.</mixed-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="F1" orientation="portrait" position="float">
    <label>Fig. 1.</label>
    <caption>
      <p id="P39">The three-node flow network <inline-formula><mml:math display="inline" id="M54"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    </caption>
    <graphic xlink:href="nihms-1708640-f0001"/>
  </fig>
  <fig id="F2" orientation="portrait" position="float">
    <label>Fig. 2.</label>
    <caption>
      <p id="P40">CycFlowDec architecture diagram. Classes and methods intended for general users are in green.</p>
    </caption>
    <graphic xlink:href="nihms-1708640-f0002"/>
  </fig>
  <fig id="F3" orientation="portrait" position="float">
    <label>Fig. 3.</label>
    <caption>
      <p id="P41">Log–log plot of MRE vs. algorithm steps for the stochastic, percolating, and percolating with burn-in algorithms for <inline-formula><mml:math display="inline" id="M55"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>. Stochastic and percolating have trendlines of the form <italic>y</italic> = <italic>ax</italic><sup>−<italic>b</italic></sup>, and percolating with burn-in uses <italic>y</italic> = <italic>ae</italic><sup>−<italic>bx</italic></sup>.</p>
    </caption>
    <graphic xlink:href="nihms-1708640-f0003"/>
  </fig>
  <fig id="F4" orientation="portrait" position="float">
    <label>Fig. 4.</label>
    <caption>
      <p id="P42">The seven-node flow network <inline-formula><mml:math display="inline" id="M56"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
    </caption>
    <graphic xlink:href="nihms-1708640-f0004"/>
  </fig>
  <fig id="F5" orientation="portrait" position="float">
    <label>Fig. 5.</label>
    <caption>
      <p id="P43">The 64-node flow network <inline-formula><mml:math display="inline" id="M57"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>. Generated with igraph [<xref rid="R10" ref-type="bibr">10</xref>] using the large graph layout algorithm. Edges represent bidirectional flows.</p>
    </caption>
    <graphic xlink:href="nihms-1708640-f0005"/>
  </fig>
  <fig id="F6" orientation="portrait" position="float">
    <label>Fig. 6.</label>
    <caption>
      <p id="P44">Log–log plot of MRE vs. steps for <inline-formula><mml:math display="inline" id="M58"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math display="inline" id="M59"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math display="inline" id="M60"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> using the percolating algorithm with burn-in. Trendlines are of the form <italic>y = ae</italic><sup>−<italic>bx</italic></sup>. Burn-in and minimum contribution tolerance for <inline-formula><mml:math display="inline" id="M61"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math display="inline" id="M62"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> were <italic>N</italic> − 2 and zero, respectively. Network <inline-formula><mml:math display="inline" id="M63"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> used <italic>N</italic> − 4 and 10<sup>−7</sup>. Starting nodes were <italic>A</italic>, <italic>G</italic>, and 51 for <inline-formula><mml:math display="inline" id="M64"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math display="inline" id="M65"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>7</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math display="inline" id="M66"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>64</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula>, respectively.</p>
    </caption>
    <graphic xlink:href="nihms-1708640-f0006"/>
  </fig>
  <table-wrap id="T1" position="float" orientation="portrait">
    <label>Table 1</label>
    <caption>
      <p id="P45">Walk-based simple cycle extraction example. The current node on <italic>W</italic> is in bold.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <colgroup span="1">
        <col align="left" valign="middle" span="1"/>
        <col align="left" valign="middle" span="1"/>
        <col align="left" valign="middle" span="1"/>
      </colgroup>
      <thead>
        <tr>
          <th align="left" valign="top" rowspan="1" colspan="1">
            <italic>W</italic>
          </th>
          <th align="left" valign="top" rowspan="1" colspan="1">Visited</th>
          <th align="left" valign="top" rowspan="1" colspan="1">Extracted cycle</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic><bold>A</bold>, B, A, C, B, A, B, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{A}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, <bold>B</bold>, A, C, B, A, B, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic><bold>A</bold>, C, B, A, B, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A, B</italic>)</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, <bold>C</bold>, B, A, B, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, C</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, C, <bold>B</bold>, A, B, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, C, B</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic><bold>A</bold>, B, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A, C, B</italic>)</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, <bold>B</bold>, C, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B, <bold>C</bold>, B, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B, C</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, <bold>B</bold>, C, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>B, C</italic>)</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B, <bold>C</bold>, A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A, B, C</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1"/>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic><bold>A</bold></italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">{<italic>A</italic>}</td>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A, B, C</italic>)</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
  <table-wrap id="T2" position="float" orientation="portrait">
    <label>Table 2</label>
    <caption>
      <p id="P46">Cycle flows of <inline-formula><mml:math display="inline" id="M67"><mml:mrow><mml:msup><mml:mtext mathvariant="double-struck">N</mml:mtext><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> by algorithm. <italic>N</italic> = 2 × 10<sup>5</sup> for stochastic and percolating, while <italic>N</italic> = 300 for percolating with burn-in.</p>
    </caption>
    <table frame="hsides" rules="groups">
      <colgroup span="1">
        <col align="left" valign="middle" span="1"/>
        <col align="left" valign="middle" span="1"/>
        <col align="left" valign="middle" span="1"/>
        <col align="left" valign="middle" span="1"/>
      </colgroup>
      <thead>
        <tr>
          <th align="left" valign="top" rowspan="1" colspan="1">Cycle</th>
          <th align="center" valign="top" rowspan="1" colspan="1">Stochastic</th>
          <th align="center" valign="top" rowspan="1" colspan="1">Percolating</th>
          <th align="center" valign="top" rowspan="1" colspan="1">Percolating, <italic>burn</italic> = <italic>N</italic> − 2</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A</italic>, <italic>B</italic>)</td>
          <td align="right" valign="top" rowspan="1" colspan="1">36.90029</td>
          <td align="right" valign="top" rowspan="1" colspan="1">36.77424</td>
          <td align="right" valign="top" rowspan="1" colspan="1">36.77419</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A</italic>, <italic>C</italic>)</td>
          <td align="right" valign="top" rowspan="1" colspan="1">2.74282</td>
          <td align="right" valign="top" rowspan="1" colspan="1">2.77420</td>
          <td align="right" valign="top" rowspan="1" colspan="1">2.77419</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>B</italic>, <italic>C</italic>)</td>
          <td align="right" valign="top" rowspan="1" colspan="1">1.78229</td>
          <td align="right" valign="top" rowspan="1" colspan="1">1.77418</td>
          <td align="right" valign="top" rowspan="1" colspan="1">1.77419</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A</italic>, <italic>B</italic>, <italic>C</italic>)</td>
          <td align="right" valign="top" rowspan="1" colspan="1">3.18206</td>
          <td align="right" valign="top" rowspan="1" colspan="1">3.22579</td>
          <td align="right" valign="top" rowspan="1" colspan="1">3.22581</td>
        </tr>
        <tr>
          <td align="left" valign="top" rowspan="1" colspan="1">(<italic>A</italic>, <italic>C</italic>, <italic>B</italic>)</td>
          <td align="right" valign="top" rowspan="1" colspan="1">1.20101</td>
          <td align="right" valign="top" rowspan="1" colspan="1">1.22580</td>
          <td align="right" valign="top" rowspan="1" colspan="1">1.22581</td>
        </tr>
      </tbody>
    </table>
  </table-wrap>
</floats-group>
