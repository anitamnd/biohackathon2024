<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4058917</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu289</article-id>
    <article-id pub-id-type="publisher-id">btu289</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb 2014 Proceedings Papers Committee</subject>
        <subj-group subj-group-type="heading">
          <subject>Original Papers</subject>
          <subj-group subj-group-type="heading">
            <subject>Evolution and Comparative Genomics</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Pareto-optimal phylogenetic tree reconciliation</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Libeskind-Hadas</surname>
          <given-names>Ran</given-names>
        </name>
        <xref ref-type="aff" rid="btu289-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wu</surname>
          <given-names>Yi-Chieh</given-names>
        </name>
        <xref ref-type="aff" rid="btu289-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bansal</surname>
          <given-names>Mukul S.</given-names>
        </name>
        <xref ref-type="aff" rid="btu289-AFF1">
          <sup>3</sup>
        </xref>
        <xref ref-type="corresp" rid="btu289-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kellis</surname>
          <given-names>Manolis</given-names>
        </name>
        <xref ref-type="aff" rid="btu289-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btu289-AFF1">
          <sup>4</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="btu289-AFF1"><sup>1</sup>Department of Computer Science, Harvey Mudd College, Claremont, CA 91711, <sup>2</sup>Department of Electrical Engineering and Computer Science, MIT, Cambridge, MA 02139, <sup>3</sup>Department of Computer Science and Engineering, University of Connecticut, Storrs, CT 06269 and <sup>4</sup>Broad Institute, Cambridge, MA 02142, USA</aff>
    <author-notes>
      <corresp id="btu289-COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>12</issue>
    <fpage>i87</fpage>
    <lpage>i95</lpage>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by/3.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Phylogenetic tree reconciliation is a widely used method for reconstructing the evolutionary histories of gene families and species, hosts and parasites and other dependent pairs of entities. Reconciliation is typically performed using maximum parsimony, in which each evolutionary event type is assigned a cost and the objective is to find a reconciliation of minimum total cost. It is generally understood that reconciliations are sensitive to event costs, but little is understood about the relationship between event costs and solutions. Moreover, choosing appropriate event costs is a notoriously difficult problem.</p>
      <p><bold>Results:</bold> We address this problem by giving an efficient algorithm for computing Pareto-optimal sets of reconciliations, thus providing the first systematic method for understanding the relationship between event costs and reconciliations. This, in turn, results in new techniques for computing event support values and, for cophylogenetic analyses, performing robust statistical tests. We provide new software tools and demonstrate their use on a number of datasets from evolutionary genomic and cophylogenetic studies.</p>
      <p><bold>Availability and implementation:</bold> Our Python tools are freely available at <ext-link ext-link-type="uri" xlink:href="www.cs.hmc.edu/~hadas/xscape">www.cs.hmc.edu/∼hadas/xscape</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>mukul@engr.uconn.edu</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>Phylogenetic tree reconciliation is a fundamental technique for studying the evolution of pairs of entities such as gene families and species, parasites and hosts and species and geographical regions. Recent algorithmic advances in tree reconciliation have led to seminal biological discoveries. Among these are the finding that &gt;26% of extant gene families arose during the Archaean period between 3.33 and 2.85 billion years ago (<xref rid="btu289-B8" ref-type="bibr">David and Alm, 2011</xref>), a study showing that interactions of species and their ecological niches are strongly conserved across the entire tree of life (<xref rid="btu289-B10" ref-type="bibr">Gómez <italic>et al.</italic>, 2010</xref>), and new insights into the relationship between pathogenic RNA viruses and their hosts (<xref rid="btu289-B14" ref-type="bibr">Jackson and Charleston, 2004</xref>).</p>
    <p>The reconciliation problem takes as input two trees and the associations between their leaves and seeks a mapping of one tree onto the other such that incongruence between the two trees is accounted for by a set of evolutionary events. In the context of gene family evolution, the two trees are the <italic>gene tree</italic> and the <italic>species tree</italic>, and in the well-studied Duplication-Transfer-Loss model (DTL), the events are speciation, duplication, transfer and loss. Unlike the simpler Duplication-Loss (DL) reconciliation model (<xref rid="btu289-B11" ref-type="bibr">Goodman <italic>et al.</italic>, 1979</xref>: <xref rid="btu289-B19" ref-type="bibr">Page, 1994</xref>), DTL accounts for transfer events and is thus broadly applicable across the tree of life. In the context of parasites and their hosts, the corresponding events are co-speciation, independent speciation, host switch and loss, respectively. In the context of species and area cladograms, these four events correspond to vicariance, sympatric speciation, dispersal and loss, respectively (<xref rid="btu289-B17" ref-type="bibr">Morrone, 2009</xref>). Henceforth, we refer to this set of events as the DTL model and use the DTL event names.</p>
    <p>DTL-reconciliation is generally performed in a maximum parsimony framework in which each event type has an associated user-defined cost and the objective is to find a reconciliation of minimum total cost. Probabilistic approaches for DTL reconciliation, which do not require event cost assignments, also exist (<xref rid="btu289-B24" ref-type="bibr">Szollosi <italic>et al.</italic>, 2012</xref>; <xref rid="btu289-B25" ref-type="bibr">Tofigh, 2009</xref>), but these require estimates of other parameters, such as species divergence times, and are prohibitively slow for trees with more than a few leaves. If the species trees are fully dated, then maximum parsimony reconciliations can be found in polynomial time (<xref rid="btu289-B9" ref-type="bibr">Doyon <italic>et al.</italic>, 2010</xref>; <xref rid="btu289-B16" ref-type="bibr">Libeskind-Hadas and Charleston, 2009</xref>). However, accurately dating the internal nodes of a phylogenetic tree is generally difficult (<xref rid="btu289-B20" ref-type="bibr">Rutschmann, 2006</xref>). In the absence of dates, reconciliations may be time-inconsistent in the sense that they can induce contradictory constraints on the relative order of the internal nodes. The problem of finding optimal time-consistent DTL-reconciliations in undated trees is known to be NP-hard (<xref rid="btu289-B13" ref-type="bibr">Hallett <italic>et al.</italic>, 2004</xref>; <xref rid="btu289-B18" ref-type="bibr">Ovadia <italic>et al.</italic>, 2011</xref>). Therefore, a common approach, and the one followed in this article, is to relax the time-consistency requirement (<xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic>, 2012</xref>, <xref rid="btu289-B3" ref-type="bibr">2013</xref>; <xref rid="btu289-B6" ref-type="bibr">Chen <italic>et al.</italic>, 2012</xref>; <xref rid="btu289-B8" ref-type="bibr">David and Alm, 2011</xref>; <xref rid="btu289-B26" ref-type="bibr">Tofigh <italic>et al.</italic>, 2011</xref>), which permits an optimal (although not necessarily time-consistent) solution to be found in <italic>O</italic>(<italic>mn</italic>) time (<xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic>, 2012</xref>), where <italic>m</italic> and <italic>n</italic> denote the number of nodes in the gene (parasite) and species (host) trees, respectively. Experimental evidence suggests that the solutions found using this approach are generally time-consistent (<xref rid="btu289-B1" ref-type="bibr">Addario-Berry <italic>et al.</italic>, 2003</xref>); but see also <xref rid="btu289-B23" ref-type="bibr">Stolzer <italic>et al.</italic> (2012)</xref>.</p>
    <p>Maximum parsimony reconciliations depend on the event costs. In the DTL model, speciations are considered ‘null events’ and are therefore typically assigned a cost of 0 while duplications, transfers and losses are assigned positive costs. <xref ref-type="fig" rid="btu289-F1">Figure 1</xref>a shows a species (host) tree in black and a gene (parasite) tree in gray along with associations between their leaves. If duplication, transfer and loss each cost 1, then the reconciliation in <xref ref-type="fig" rid="btu289-F1">Figure 1</xref>b is optimal, comprises one speciation and one transfer and has total cost 1. However, if duplication and loss cost 1 and transfer costs 5, then the maximum parsimony reconciliation in <xref ref-type="fig" rid="btu289-F1">Figure 1</xref>c is optimal, comprises one speciation, one duplication and three losses and has total cost 4. Even small differences in event costs can induce different solutions when the trees are larger. For example, we have found that in many datasets, the default costs used in TreeMap (<xref rid="btu289-B5" ref-type="bibr">Charleston, 1998</xref>) and Jane (<xref rid="btu289-B7" ref-type="bibr">Conow <italic>et al.</italic>, 2010</xref>) give rise to different reconciliations than those using the default costs in AnGST (<xref rid="btu289-B8" ref-type="bibr">David and Alm, 2011</xref>) and RANGER-DTL (<xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic>, 2012</xref>).
<fig id="btu289-F1" position="float"><label>Fig. 1.</label><caption><p>(<bold>a</bold>) A species (host) tree in black and a gene (parasite) tree in gray with the leaf associations shown in dotted lines. (<bold>b</bold> and <bold>c</bold>) Two different reconciliations with events labeled by type</p></caption><graphic xlink:href="btu289f1"/></fig></p>
    <p>Despite great advances in the efficiency and accuracy of DTL-reconciliation, little is understood about the relationship between event costs and the resulting maximum parsimony reconciliations. A systematic way to handle the difficulty in determining appropriate event costs is to optimize for event counts rather than total numerical cost. We define an <italic>event count vector</italic> for a reconciliation to be a triple <inline-formula><mml:math id="n1"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, denoting the number of duplications, transfers and losses, respectively. These vectors do not explicitly count the number of speciation events because the number of speciations is implicit (it is <inline-formula><mml:math id="n2"><mml:mrow><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mi>δ</mml:mi><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>).</p>
    <p>An event count vector <inline-formula><mml:math id="n3"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is <italic>strictly better</italic> than an event count vector <inline-formula><mml:math id="n4"><mml:mrow><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> if each entry of <italic>v</italic> is less than or equal to the corresponding entry in <italic>v<sup>′</sup></italic> and at least one entry of <italic>v</italic> is less than its corresponding entry in <italic>v<sup>′</sup></italic>. A reconciliation is <italic>Pareto-optimal</italic> if there is no reconciliation with a strictly better event count vector. We use the term Pareto-optimal for both reconciliations and their corresponding event count vectors.</p>
    <p>Given the set of all Pareto-optimal event count vectors, we can partition the space of possible event cost assignments into equivalence classes, or ‘regions’, such that any two event cost assignments within the same region lead to the same optimal reconciliations. These regions provide insights into the relationships between event costs and maximum parsimony reconciliations and have numerous applications, including new definitions and algorithms for computing event consensus support.</p>
    <sec>
      <title>Previous work</title>
      <p>TreeMap (<xref rid="btu289-B5" ref-type="bibr">Charleston, 1998</xref>) was the first to address the problem of uncertain event costs by enumerating Pareto-optimal solutions. However, TreeMap’s underlying algorithm has worst-case exponential time and thus can only be used with small trees. <xref rid="btu289-B25" ref-type="bibr">Tofigh (2009)</xref> later considered the problem of computing all Pareto-optimal solutions for the DTL-reconciliation problem but without accounting for losses; this simplifies the algorithmic problem but affects the accuracy of the reconciliation. Losses play a fundamental role in the ability to distinguish between duplications and transfers, and in mapping the nodes of the gene tree to the nodes of the species tree, and thus should be explicitly considered during reconciliation (<xref rid="btu289-B23" ref-type="bibr">Stolzer <italic>et al.</italic>, 2012</xref>).</p>
      <p>Thus, despite earlier work on Pareto-optimal reconciliations, there currently exist no algorithms or tools for computing or exploring the space of all Pareto-optimal DTL reconciliations.</p>
    </sec>
    <sec>
      <title>Our contributions</title>
      <p>In this article, we give efficient algorithms that compute all Pareto-optimal DTL reconciliations and completely characterize the relationship between event costs and maximum parsimony reconciliations. Specifically,
<list list-type="bullet"><list-item><p>We give an algorithm for computing the Pareto-optimal event count vectors by extending the dynamic programming approaches that we and others have developed for the case of fixed event costs. Our algorithm has worst-case running time <inline-formula><mml:math id="n5"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>5</mml:mn></mml:msup><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <italic>m</italic> and <italic>n</italic> denote the number of leaves in the gene (parasite) tree and species (host) tree, respectively. The algorithm also counts the number of distinct reconciliations associated with each event count vector. In addition, we give a <inline-formula><mml:math id="n6"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time algorithm that uses the Pareto-optimal event count vectors to partition the event cost space into equivalence classes, or regions, such that event costs in a region give rise to the same set of maximum parsimony reconciliations.</p></list-item><list-item><p>We present three applications of this algorithm and provide downloadable software tools for each one.
<list list-type="simple"><list-item><label>–</label><p>The first tool, <italic>costscape</italic>, computes the Pareto-optimal event count vectors and provides a visualization of the corresponding regions.</p></list-item><list-item><label>–</label><p>The second tool, <italic>eventscape</italic>, identifies the individual events that are common to the reconciliations in each region and uses this information to identify events that are strongly supported across the event cost space.</p></list-item><list-item><label>–</label><p>The <italic>sigscape</italic> tool permits new, more robust statistical significance tests in cophylogenetic analyses.</p></list-item></list>
</p></list-item><list-item><p>We apply these tools to a number of datasets to demonstrate their utility. These results show that a small number of appropriately selected event costs can be used to capture a large fraction of maximum parsimony reconciliations; that a significant fraction of speciation events occur in every reconciliation across a wide range of event costs; and that duplications, transfers and losses are more sensitive to the choice of event costs.</p></list-item></list>
</p>
    </sec>
  </sec>
  <sec id="SEC2">
    <title>2 DEFINITIONS AND PRELIMINARIES</title>
    <p>We follow the basic definitions and notation from <xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic> (2012)</xref>. Given a tree <italic>T</italic>, we denote its node, edge and leaf sets by <inline-formula><mml:math id="n7"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n8"><mml:mrow><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. If <italic>T</italic> is rooted, the root node of <italic>T</italic> is denoted by <inline-formula><mml:math id="n9"><mml:mrow><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, the parent of a node <inline-formula><mml:math id="n10"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by <inline-formula><mml:math id="n11"><mml:mrow><mml:mi>p</mml:mi><mml:msub><mml:mi>a</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, its set of children by <inline-formula><mml:math id="n12"><mml:mrow><mml:mi>C</mml:mi><mml:msub><mml:mi>h</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the (maximal) subtree of <italic>T</italic> rooted at <italic>v</italic> by <italic>T</italic>(<italic>v</italic>). The set of <italic>internal nodes</italic> of <italic>T</italic>, denoted <italic>I</italic>(<italic>T</italic>), is defined to be <inline-formula><mml:math id="n13"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">∖</mml:mi><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We define <inline-formula><mml:math id="n14"><mml:mrow><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to be the partial order on <italic>V</italic>(<italic>T</italic>) where <inline-formula><mml:math id="n15"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> if <italic>y</italic> is a node on the path between <inline-formula><mml:math id="n16"><mml:mrow><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>x</italic>. The partial order <inline-formula><mml:math id="n17"><mml:mrow><mml:msub><mml:mo>≥</mml:mo><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is defined analogously, i.e. <inline-formula><mml:math id="n18"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mo>≥</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> if <italic>x</italic> is a node on the path between <inline-formula><mml:math id="n19"><mml:mrow><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>y</italic>. We say that <italic>y</italic> is an <italic>ancestor</italic> of <italic>x</italic>, or that <italic>x</italic> is a <italic>descendant</italic> of <italic>y</italic>, if <inline-formula><mml:math id="n20"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> (note that, under this definition, every node is a descendant as well as ancestor of itself). We say that <italic>x</italic> and <italic>y</italic> are <italic>incomparable</italic> if neither <inline-formula><mml:math id="n21"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> nor <inline-formula><mml:math id="n22"><mml:mrow><mml:mi>y</mml:mi><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>x</mml:mi></mml:mrow></mml:math></inline-formula>. Given a non-empty subset <inline-formula><mml:math id="n23"><mml:mrow><mml:mi>L</mml:mi><mml:mo>⊆</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we denote by <inline-formula><mml:math id="n24"><mml:mrow><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mi>a</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the last common ancestor (LCA) of all the leaves in <italic>L</italic> in tree <italic>T</italic>, that is, <inline-formula><mml:math id="n25"><mml:mrow><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:msub><mml:mi>a</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the unique smallest upper bound of <italic>L</italic> under <inline-formula><mml:math id="n26"><mml:mrow><mml:msub><mml:mo>≤</mml:mo><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Given <inline-formula><mml:math id="n27"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>x</mml:mi><mml:msub><mml:mo>→</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> denotes the unique path from <italic>x</italic> to <italic>y</italic> in <italic>T</italic>. We denote by <inline-formula><mml:math id="n28"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the number of edges on the path <inline-formula><mml:math id="n29"><mml:mrow><mml:mi>x</mml:mi><mml:msub><mml:mo>→</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula>; note that if <italic>x</italic> = <italic>y</italic> then <inline-formula><mml:math id="n30"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Throughout this work, the <italic>term</italic> tree refers to a rooted binary tree.</p>
    <p>We assume that the two input trees are denoted by <italic>T</italic> and <italic>S</italic>, and the goal is to map tree <italic>T</italic> to tree <italic>S</italic>. Thus, in gene-tree/species-tree reconciliation, <italic>T</italic> denotes the gene tree and <italic>S</italic> the species tree; in coevolutionary studies, <italic>T</italic> denotes the parasite tree and <italic>S</italic> the host tree; and in biogeographical studies, <italic>T</italic> denotes the species tree and <italic>S</italic> the area cladogram. Each leaf of tree <italic>T</italic> is labeled with the leaf-label from <italic>S</italic> with which it is associated. This labeling defines a <italic>leaf-mapping</italic>
<inline-formula><mml:math id="n31"><mml:mrow><mml:msub><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that maps a leaf node <inline-formula><mml:math id="n32"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to the unique leaf node <inline-formula><mml:math id="n33"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which has the same label as <italic>t</italic>. Note that <italic>T</italic> may have more than one leaf associated with the same leaf of <italic>S</italic>. Throughout this work we will implicitly assume that the species tree contains all the species represented in the gene tree.</p>
    <sec id="SEC2.1">
      <title>2.1 Reconciliation and DTL scenarios</title>
      <p>Next, we define what constitutes a valid DTL reconciliation; specifically, we define a Duplication-Transfer-Loss scenario (DTL-scenario) (<xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic>, 2012</xref>; <xref rid="btu289-B26" ref-type="bibr">Tofigh <italic>et al.</italic>, 2011</xref>) for <italic>T</italic> and <italic>S</italic> that characterizes the mappings of <italic>T</italic> into <italic>S</italic> that constitute a biologically valid reconciliation. Essentially, DTL-scenarios (i) map each node of <italic>T</italic> to a unique node in <italic>S</italic> in a consistent way that respects the immediate temporal constraints implied by the topology of <italic>S</italic>, and (ii) designate each node of <italic>T</italic> as representing either a speciation, duplication or transfer event.
<statement><title>D<sc>efinition</sc> 2.1 (DTL-scenario)</title><p><italic>A DTL-scenario for T and S is a seven-tuple</italic><inline-formula><mml:math id="n34"><mml:mrow><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic>, where</italic><inline-formula><mml:math id="n35"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>:</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>represents the leaf-mapping from T to</italic><inline-formula><mml:math id="n36"><mml:mrow><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>maps each node of T to a node of S, the sets</italic><inline-formula><mml:math id="n37"><mml:mrow><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula><italic>and Θ partition I(T) into speciation (or co-speciation), duplication and transfer nodes</italic><italic>, respectively, Ξ is a subset of edges of T that represent transfer edges and</italic><inline-formula><mml:math id="n38"><mml:mrow><mml:mi>τ</mml:mi><mml:mo>:</mml:mo><mml:mo>Θ</mml:mo><mml:mo>→</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>specifies the recipient for each transfer event, subject to the following constraints:</italic><list list-type="order"><list-item><p><italic>If</italic><inline-formula><mml:math id="n39"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>, then</italic><inline-formula><mml:math id="n40"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></list-item><list-item><p><italic>If</italic><inline-formula><mml:math id="n41"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and t′ and t″ denote the children of t, then,</italic><list list-type="alpha-lower"><list-item><p><inline-formula><mml:math id="n42"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>≮</mml:mo></mml:menclose><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n43"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:menclose notation="updiagonalstrike"><mml:mo>≮</mml:mo></mml:menclose><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>,</italic></p></list-item><list-item><p><italic>At least one of </italic><inline-formula><mml:math id="n44"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n45"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>is a descendant of </italic><inline-formula><mml:math id="n46"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></list-item></list></p></list-item><list-item><p><italic>Given any edge </italic><inline-formula><mml:math id="n47"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>Ξ</mml:mo></mml:mrow></mml:math></inline-formula><italic>if and only if </italic><inline-formula><mml:math id="n48"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n49"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>are incomparable.</italic></p></list-item><list-item><p><italic>If </italic><inline-formula><mml:math id="n50"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n51"><mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n52"><mml:mrow><mml:mi>t</mml:mi><mml:mo>″</mml:mo></mml:mrow></mml:math></inline-formula><italic>denote the children of t, then,</italic><list list-type="alpha-lower"><list-item><p><inline-formula><mml:math id="n53"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>Σ</mml:mi></mml:mrow></mml:math></inline-formula><italic>only if </italic><inline-formula><mml:math id="n54"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n55"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n56"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>are incomparable,</italic></p></list-item><list-item><p><inline-formula><mml:math id="n57"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula><italic>only if </italic><inline-formula><mml:math id="n58"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>≥</mml:mo><mml:mi>S</mml:mi></mml:msub><mml:mspace width=".3em"/><mml:mi>l</mml:mi><mml:mi>c</mml:mi><mml:mi>a</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>,</italic></p></list-item><list-item><p><inline-formula><mml:math id="n59"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>Θ</mml:mo></mml:mrow></mml:math></inline-formula><italic>if and only if either </italic><inline-formula><mml:math id="n60"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>Ξ</mml:mo></mml:mrow></mml:math></inline-formula><italic>or </italic><inline-formula><mml:math id="n61"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>Ξ</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></list-item><list-item><p><italic>If </italic><inline-formula><mml:math id="n62"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>Θ</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n63"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>Ξ</mml:mo></mml:mrow></mml:math></inline-formula><italic>, then </italic><inline-formula><mml:math id="n64"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n65"><mml:mrow><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>must be incomparable, and </italic><inline-formula><mml:math id="n66"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>must be a descendant of </italic><inline-formula><mml:math id="n67"><mml:mrow><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></list-item></list></p></list-item></list></p></statement>
</p>
      <p>Constraint 1 above ensures that the mapping <inline-formula><mml:math id="n68"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:math></inline-formula> is consistent with the leaf-mapping <inline-formula><mml:math id="n69"><mml:mi mathvariant="script" class="calligraphy">L</mml:mi></mml:math></inline-formula>. Constraint 2a imposes on <inline-formula><mml:math id="n70"><mml:mi mathvariant="script" class="calligraphy">M</mml:mi></mml:math></inline-formula> the temporal constraints implied by <italic>S</italic>. Constraint 2b implies that any internal node in <italic>G</italic> may represent at most one transfer event. Constraint 3 determines the edges of <italic>T</italic> that are transfer edges. Constraints 4a, 4b and 4c state the conditions under which an internal node of <italic>T</italic> may represent a speciation, duplication and transfer, respectively. Constraint 4d specifies which species may be designated as the recipient species for any given transfer event.</p>
      <p>DTL-scenarios correspond naturally to reconciliations, and it is straightforward to infer the reconciliation of <italic>T</italic> and <italic>S</italic> implied by any DTL-scenario.</p>
      <p>Given a DTL-scenario, one can directly count the minimum number of gene losses (<xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic>, 2012</xref>) in the corresponding reconciliation as follows.
<statement><title>D<sc>efinition</sc> 2.2 (Losses)</title><p><italic>Given a DTL-scenario </italic><inline-formula><mml:math id="n71"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic>for T and S, let </italic><inline-formula><mml:math id="n72"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>and </italic><inline-formula><mml:math id="n73"><mml:mrow><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>. The number of losses </italic><inline-formula><mml:math id="n74"><mml:mrow><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>α</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>at node t is defined to be</italic><list list-type="bullet"><list-item><p><inline-formula><mml:math id="n75"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>, if <inline-formula><mml:math id="n76"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>Σ</mml:mi></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p><inline-formula><mml:math id="n77"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, if <inline-formula><mml:math id="n78"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p><inline-formula><mml:math id="n79"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, if <inline-formula><mml:math id="n80"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo>Ξ</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item></list></p></statement>
</p>
      <p><italic>The total number of losses in the reconciliation corresponding to the DTL-scenario α is defined to be</italic><inline-formula><inline-graphic xlink:href="btu289i1.jpg"/></inline-formula>.</p>
      <p>We assume that speciations have zero cost, and let <inline-formula><mml:math id="n82"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>C<sub>L</sub></italic> denote the assigned positive costs for duplication, transfer and loss events, respectively. Then the cost of reconciling <italic>T</italic> and <italic>S</italic> according to a DTL-scenario α is defined as follows:
<statement><title>D<sc>efinition</sc> 2.3 (Reconciliation cost of a DTL-scenario)</title><p><italic>Given a DTL-scenario </italic><inline-formula><mml:math id="n83"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic>for T and S, the reconciliation cost associated with α is given by </italic><inline-formula><mml:math id="n84"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>Δ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>·</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>Θ</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
</p>
      <p>The traditional goal of DTL-reconciliation is to find a most parsimonious reconciliation, i.e. a DTL-scenario for <italic>G</italic> and <italic>S</italic> with minimum reconciliation cost. However, in this work, we assume that the exact cost assignments, <inline-formula><mml:math id="n85"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>C<sub>L</sub></italic>, are unknown; therefore, we focus on the inferred event counts rather than the reconciliation cost itself.
<statement><title>D<sc>efinition</sc> 2.4 (Event count vector)</title><p><italic>Given a DTL-scenario </italic><inline-formula><mml:math id="n86"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic>for T and S, the event count vector associated with α, denoted </italic><inline-formula><mml:math id="n87"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>, is defined to be </italic><inline-formula><mml:math id="n88"><mml:mrow><mml:mo>〈</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>Δ</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>Θ</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>α</mml:mi></mml:msub><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
</p>
      <p>Given two DTL-scenarios <inline-formula><mml:math id="n89"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n90"><mml:mrow><mml:mi>α</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>′</mml:mo><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> for <italic>T</italic> and <italic>S</italic>, the event count vector <inline-formula><mml:math id="n91"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is said to be <italic>strictly better</italic> than <inline-formula><mml:math id="n92"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>α</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> if each entry of <inline-formula><mml:math id="n93"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is less than or equal to the corresponding entry in <inline-formula><mml:math id="n94"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>α</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and at least one entry of <inline-formula><mml:math id="n95"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is less than its corresponding entry in <inline-formula><mml:math id="n96"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>α</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>.
<statement><title>D<sc>efinition</sc> 2.5 (Pareto-optimal event count vector)</title><p><italic>Given a DTL-scenario </italic><inline-formula><mml:math id="n97"><mml:mrow><mml:mi>α</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo>,</mml:mo><mml:mi>Σ</mml:mi><mml:mo>,</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mo>Ξ</mml:mo><mml:mo>,</mml:mo><mml:mi>τ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula><italic>for T and S, the event count vector </italic><inline-formula><mml:math id="n98"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>is said to be Pareto-optimal if there does not exist any other DTL-scenario </italic><inline-formula><mml:math id="n99"><mml:mrow><mml:mi>α</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula><italic>for T and S whose event count vector </italic><inline-formula><mml:math id="n100"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mrow><mml:mi>α</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>is strictly better than </italic><inline-formula><mml:math id="n101"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>α</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
</p>
      <p>Given trees <italic>T</italic> and <italic>S</italic> and leaf-mapping <inline-formula><mml:math id="n102"><mml:mrow><mml:msub><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, our goal is to find all Pareto-optimal event count vectors for the two trees. Note that, if an event count vector <inline-formula><mml:math id="n103"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> is Pareto-optimal, then there exists some assignment of values for <inline-formula><mml:math id="n104"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> and <italic>C<sub>L</sub></italic> for which a most parsimonious reconciliation invokes exactly δ duplications, θ transfers and ℓ losses. Thus, the set of all Pareto-optimal event count vectors provides a relationship between event cost assignments and most parsimonious reconciliations.
<statement><title>P<sc>roblem</sc> 1 (Pareto-optimal vectors)</title><p><italic>The Pareto-optimal vectors (PV) problem is to find the set of all Pareto-optimal event count vectors for trees T and S and their leaf-mapping </italic><inline-formula><mml:math id="n106"><mml:mrow><mml:msub><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
</p>
      <p>The set of Pareto-optimal vectors obtained by solving the PV problem can then be used to partition the space of possible event cost assignments into ‘equivalent’ regions.
<statement><title>P<sc>roblem</sc> 2 (Equivalent Region Partition)</title><p><italic>Given </italic><inline-formula><mml:math id="n107"><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mrow><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula><italic>and the set of all Pareto-optimal event count vectors for the two trees, the equivalent region partition (ERP) problem is to partition the space of possible event cost assignments into disjoint regions such that any two event cost assignments within the same region yield the same set of maximum parsimony reconciliations.</italic></p></statement>
</p>
      <p>In the next section, we first show how to efficiently solve both the PV and ERP problems. In the subsequent sections, we use these algorithmic results as the basis of new software tools and then demonstrate the utility of these tools on several biological datasets.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 ALGORITHMS</title>
    <p>Our algorithm for the PV problem is based on an extension of the dynamic programming framework for computing most parsimonious DTL reconciliations with known event costs, e.g. (<xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic>, 2012</xref>). <xref rid="btu289-B25" ref-type="bibr">Tofigh (2009)</xref> was the first to adapt the dynamic programming algorithm to compute Pareto-optimal event count vectors. However, that result did not count losses, which significantly simplifies the dynamic programming algorithm and also bounds the number of Pareto-optimal event count vectors to just <italic>O</italic>(<italic>m</italic>), resulting in an <inline-formula><mml:math id="n108"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time algorithm, where <inline-formula><mml:math id="n109"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n110"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>. In developing an efficient algorithm for the PV problem, we not only show how to efficiently account for losses in the dynamic programming algorithm [using ideas from <xref rid="btu289-B2" ref-type="bibr">Bansal <italic>et al.</italic> (2012)</xref>] but also show how to efficiently maintain the resulting larger set of Pareto-optimal event count vectors.</p>
    <sec id="SEC3.1">
      <title>3.1 Solving the PV problem</title>
      <p>Given any <inline-formula><mml:math id="n111"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n112"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, let <inline-formula><mml:math id="n113"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> denote the set of Pareto-optimal event count vectors for reconciling <italic>T</italic>(<italic>t</italic>) with <italic>S</italic> such that <italic>t</italic> maps to <italic>s</italic> and <inline-formula><mml:math id="n114"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>Σ</mml:mi></mml:mrow></mml:math></inline-formula>. The terms <inline-formula><mml:math id="n115"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n116"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are defined similarly for <inline-formula><mml:math id="n117"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>Δ</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n118"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mo>Θ</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. Given any <inline-formula><mml:math id="n119"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n120"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we define <inline-formula><mml:math id="n121"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be the set of Pareto-optimal event count vectors for reconciling <italic>T</italic>(<italic>t</italic>) with <italic>S</italic> such that <italic>t</italic> maps to <italic>s</italic>. Our algorithm performs a nested post-order traversal of <italic>T</italic> and <italic>S</italic> to compute <inline-formula><mml:math id="n122"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each <italic>t</italic> and <italic>s</italic>.</p>
      <p>Given two sets <italic>A</italic> and <italic>B</italic> of Pareto-optimal event count vectors, we define <inline-formula><mml:math id="n123"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊕</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> to be the set obtained by taking the union of the event count vectors in <italic>A</italic> and <italic>B</italic> and then selecting the subset of event count vectors that are Pareto-optimal. Similarly, <inline-formula><mml:math id="n124"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊗</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> is defined to be the set obtained by first computing the Cartesian product of <italic>A</italic> and <italic>B</italic>, then converting each resulting ordered pair into a single event count vector by adding the two vectors of the ordered pair, and finally taking only the subset of Pareto-optimal event count vectors. These operations will be used when merging the Pareto-optimal event count vectors from smaller subproblems to compute the Pareto-optimal event count vectors for larger subproblems. The dynamic programming table for <inline-formula><mml:math id="n125"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is initialized and computed as shown below:
<disp-formula><mml:math id="n126"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo>〈</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>〉</mml:mo><mml:mtext>  if</mml:mtext><mml:mspace width=".3em"/><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width=".3em"/><mml:mtext>and</mml:mtext><mml:mspace width=".3em"/><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>〈</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>〉</mml:mo><mml:mtext> </mml:mtext><mml:mspace width=".3em"/><mml:mtext>if</mml:mtext><mml:mspace width=".3em"/><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width=".3em"/><mml:mtext>and</mml:mtext><mml:mspace width=".3em"/><mml:mi>s</mml:mi><mml:mo>≠</mml:mo><mml:mi mathvariant="script" class="calligraphy">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mtext> </mml:mtext><mml:mspace width=".3em"/><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
</p>
      <p>Given an event count vector, <inline-formula><mml:math id="n127"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, we use the notation <inline-formula><mml:math id="n128"><mml:mrow><mml:mi>v</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, for <inline-formula><mml:math id="n129"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℤ</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, to denote the event count vector where the count for duplications is incremented by <italic>i</italic>, i.e. <inline-formula><mml:math id="n130"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>+</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. The vectors <inline-formula><mml:math id="n131"><mml:mrow><mml:mi>v</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n132"><mml:mrow><mml:mi>v</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are defined analogously for transfers and losses, respectively. We extend this notation to a set of event count vectors, <italic>A</italic>, as follows: <inline-formula><mml:math id="n133"><mml:mrow><mml:mi>A</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> represents the set <inline-formula><mml:math id="n134"><mml:mrow><mml:mo>{</mml:mo><mml:mi>v</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>A</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The sets <inline-formula><mml:math id="n135"><mml:mrow><mml:mi>A</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n136"><mml:mrow><mml:mi>A</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are defined analogously. We define
<list list-type="simple"><list-item><p><inline-formula><mml:math id="n137"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mstyle displaystyle="true"><mml:mo>⊕</mml:mo></mml:mstyle><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>,</p></list-item><list-item><p><inline-formula><mml:math id="n138"><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mstyle displaystyle="true"><mml:mo>⊕</mml:mo></mml:mstyle><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mspace width=".3em"/><mml:mtext>incomparable to</mml:mtext><mml:mspace width=".3em"/><mml:mi>s</mml:mi></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and</p></list-item><list-item><p><inline-formula><mml:math id="n139"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mstyle displaystyle="true"><mml:mo>⊕</mml:mo></mml:mstyle><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item></list>
</p>
      <p>Our algorithm computes <inline-formula><mml:math id="n140"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n141"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each <inline-formula><mml:math id="n142"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n143"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by performing a nested post-order traversal of <italic>T</italic> and <italic>S</italic>. The values <inline-formula><mml:math id="n144"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n145"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> help to reuse previously computed information to efficiently compute the values <inline-formula><mml:math id="n146"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n147"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> at each step. The exact formulas for computing the values of <inline-formula><mml:math id="n148"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n149"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using previously computed values are given in steps 17, 18 and 19 of the algorithm below. The nested post-order traversal ensures that when computing <inline-formula><mml:math id="n150"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n151"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> at nodes <inline-formula><mml:math id="n152"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>G</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n153"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>, all the required <inline-formula><mml:math id="n154"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n155"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> values have already been computed.</p>
      <p>Note that once all the <inline-formula><mml:math id="n156"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mo>·</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> sets have been computed, the set of Pareto-optimal event count vectors for the reconciliation of <italic>T</italic> and <italic>S</italic> is simply <inline-formula><mml:math id="n157"><mml:mrow><mml:munder><mml:mstyle displaystyle="true"><mml:mo>⊕</mml:mo></mml:mstyle><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The algorithm is as follows:</p>
      <boxed-text id="btu289-BOX1" position="float">
        <p>
          <bold>Algorithm</bold>
          <inline-formula>
            <mml:math id="n158">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mi>a</mml:mi>
                <mml:mi>r</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mi>t</mml:mi>
                <mml:mi>o</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mi>R</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mi>c</mml:mi>
                <mml:mi>o</mml:mi>
                <mml:mi>n</mml:mi>
                <mml:mi>c</mml:mi>
                <mml:mi>i</mml:mi>
                <mml:mi>l</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>T</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>S</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi mathvariant="script" class="calligraphy">L</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:math>
          </inline-formula>
        </p>
        <p>1: <bold>for</bold> each <inline-formula><mml:math id="n159"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n160"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p>
        <p>2: Initialize <inline-formula><mml:math id="n161"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="n162"><mml:mrow><mml:mi>ou</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to ∅.</p>
        <p>3: <bold>for</bold> each <inline-formula><mml:math id="n164"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p>
        <p>4:  <inline-formula><mml:math id="n165"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>〈</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>〉</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, and, for each <inline-formula><mml:math id="n166"><mml:mrow><mml:mi>s</mml:mi><mml:msub><mml:mo>≥</mml:mo><mml:mi>S</mml:mi></mml:msub><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="n167"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>〈</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>〉</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n168"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>〈</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>〉</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>5: <bold>for</bold> each <inline-formula><mml:math id="n169"><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in post-order <bold>do</bold></p>
        <p>6:  <bold>for</bold> each <inline-formula><mml:math id="n170"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in post-order <bold>do</bold></p>
        <p>7:   Let <inline-formula><mml:math id="n171"><mml:mrow><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:msub><mml:mi>h</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>8:   <bold>if</bold>
<inline-formula><mml:math id="n172"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mi>e</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p>
        <p>9:    <inline-formula><mml:math id="n173"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>〈</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>,</mml:mo><mml:mi>∞</mml:mi><mml:mo>〉</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>10:    <inline-formula><mml:math id="n174"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>11:    <inline-formula><mml:math id="n175"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>          <inline-formula><mml:math id="n176"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>12:    <inline-formula><mml:math id="n177"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>13:    <inline-formula><mml:math id="n178"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>14:    <inline-formula><mml:math id="n179"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>15:  <bold>else</bold></p>
        <p>16:    Let <inline-formula><mml:math id="n180"><mml:mrow><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:msub><mml:mi>h</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>17:    <inline-formula><mml:math id="n181"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>          <inline-formula><mml:math id="n182"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>18:    <inline-formula><mml:math id="n183"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo/><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Δ</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>19:    If <inline-formula><mml:math id="n184"><mml:mrow><mml:mi>s</mml:mi><mml:mo>≠</mml:mo><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math id="n185"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>         <inline-formula><mml:math id="n186"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>″</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊗</mml:mo><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>Θ</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>20:    <inline-formula><mml:math id="n187"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>Σ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>21:    <inline-formula><mml:math id="n188"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>         <inline-formula><mml:math id="n189"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>22:    <inline-formula><mml:math id="n190"><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>23:  <bold>for</bold> each <inline-formula><mml:math id="n191"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in pre-order <bold>do</bold></p>
        <p>24:    Let <inline-formula><mml:math id="n192"><mml:mrow><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mi>C</mml:mi><mml:msub><mml:mi>h</mml:mi><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>25:    <inline-formula><mml:math id="n193"><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and</p>
        <p>     <inline-formula><mml:math id="n194"><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊕</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>A</mml:mi><mml:mi>l</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>26: Return <inline-formula><mml:math id="n195"><mml:mrow><mml:munder><mml:mstyle displaystyle="true"><mml:mo>⊕</mml:mo></mml:mstyle><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </boxed-text>
      <p>To complete our description of the above algorithm, we must also show how to efficiently perform the operations <inline-formula><mml:math id="n196"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊕</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n197"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊗</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>, for any two sets <italic>A</italic> and <italic>B</italic> of Pareto-optimal event count vectors. Operation <inline-formula><mml:math id="n198"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊕</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> can be performed in <inline-formula><mml:math id="n199"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time using a straightforward algorithm (Lemma 3.2 below). Computing <inline-formula><mml:math id="n200"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊗</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> efficiently is more involved. From Lemma 3.1 (below), each Pareto-optimal set has size <inline-formula><mml:math id="n201"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, computing their Cartesian product takes time <inline-formula><mml:math id="n202"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Finding the subset of Pareto-optimal vectors by pairwise comparisons would thus take <inline-formula><mml:math id="n203"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>8</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. We now show how <inline-formula><mml:math id="n204"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊗</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> can be computed in <inline-formula><mml:math id="n205"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time.</p>
      <boxed-text id="btu289-BOX2" position="float">
        <p>
          <bold>Procedure</bold>
          <inline-formula>
            <mml:math id="n206">
              <mml:mrow>
                <mml:mi>P</mml:mi>
                <mml:mi>e</mml:mi>
                <mml:mi>r</mml:mi>
                <mml:mi>f</mml:mi>
                <mml:mi>o</mml:mi>
                <mml:mi>r</mml:mi>
                <mml:mi>m</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mo>⊗</mml:mo>
                <mml:mo stretchy="false">(</mml:mo>
                <mml:mi>A</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>B</mml:mi>
                <mml:mo stretchy="false">)</mml:mo>
              </mml:mrow>
            </mml:math>
          </inline-formula>
        </p>
        <p>1: Create an empty ordered list <italic>Z</italic> that will be used to store event count vectors in lexicographically sorted order.</p>
        <p>2: <bold>for</bold> each <inline-formula><mml:math id="n207"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p>
        <p>3:  <bold>for</bold> each <inline-formula><mml:math id="n208"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>do</bold></p>
        <p>4:   Compute the vector <inline-formula><mml:math id="n209"><mml:mrow><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:math></inline-formula>. Let this new vector be denoted as <inline-formula><mml:math id="n210"><mml:mrow><mml:mi>c</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>5:   Insert <italic>c</italic> into <italic>Z</italic> (maintaining lexicographic order).</p>
        <p>6:   Consider the element <italic>d</italic> immediately before <italic>c</italic> in the list <italic>Z</italic>.</p>
        <p>7:   <bold>if</bold>
<italic>d</italic> exists and is of the form <inline-formula><mml:math id="n211"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>−</mml:mo><mml:mi>x</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="n212"><mml:mrow><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>    <bold>then</bold></p>
        <p>8:    Delete <italic>c</italic> from <italic>Z</italic>.</p>
        <p>9:   <bold>else</bold></p>
        <p>10:    Consider the element <italic>e</italic> immediately after <italic>c</italic> in the list <italic>Z</italic>.</p>
        <p>11:    <bold>if</bold>
<italic>e</italic> exists and is of the form <inline-formula><mml:math id="n213"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>+</mml:mo><mml:mi>x</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="n214"><mml:mrow><mml:mi>x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>     <bold>then</bold></p>
        <p>12:     Delete <italic>e</italic> from <italic>Z</italic>.</p>
        <p>13: Delete from <italic>Z</italic> all vectors that are not Pareto-optimal.</p>
        <p>14: Return <italic>Z</italic>.</p>
      </boxed-text>
      <p>We now analyze our algorithm and prove its correctness. Recall that <italic>m</italic> and <italic>n</italic> denote the number of leaves in <italic>T</italic> and <italic>S</italic>, respectively.
<statement><title>L<sc>emma</sc> 3.1</title><p><italic>The cardinality of any set of Pareto-optimal event count vectors can be no greater than </italic><inline-formula><mml:math id="n215"><mml:mrow><mml:mo>Θ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
<statement><title>P<sc>roof</sc></title><p>Consider any event count vector <inline-formula><mml:math id="n216"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. Let <italic>A</italic> be any set of Pareto-optimal event count vectors. Suppose <italic>A</italic> contains more than one vector with identical values for δ and θ but different values for <italic>ℓ</italic>. Clearly, only one of these vectors can be Pareto-optimal (the one with the lowest value for <italic>ℓ</italic>). Thus, for any pair of fixed values for δ and θ, <italic>A</italic> may contain at most one vector with that assignment of values for δ and θ. Because the values of δ and θ are both bounded by <italic>m</italic> − 1, the number of internal nodes in <italic>T</italic>, the lemma follows.</p></statement>
<statement><title>L<sc>emma</sc> 3.2</title><p><italic>Given any two sets, A and B, of Pareto-optimal event count vectors, the set </italic><inline-formula><mml:math id="n217"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊕</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula><italic>can be computed in </italic><inline-formula><mml:math id="n218"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>time.</italic></p></statement>
<statement><title>P<sc>roof</sc></title><p>Let <inline-formula><mml:math id="n219"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mo>⊕</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula>. Because both <italic>A</italic> and <italic>B</italic> have <inline-formula><mml:math id="n220"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> elements, so does <italic>C</italic>. Thus, trimming down set <italic>C</italic> to just the Pareto-optimal vectors requires at most <inline-formula><mml:math id="n221"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. </p></statement>
<statement><title>L<sc>emma</sc> 3.3</title><p><italic>Given any two sets, A and B, of Pareto-optimal event count vectors, the set </italic><inline-formula><mml:math id="n222"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊗</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula><italic>can be computed in </italic><inline-formula><mml:math id="n223"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>time.</italic></p></statement>
<statement><title>P<sc>roof</sc></title><p>Consider Procedure <inline-formula><mml:math id="n224"><mml:mrow><mml:mi>P</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mo>⊗</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We first prove its correctness and then analyze its time complexity.</p><p><italic>Correctness:</italic> Consider the set <inline-formula><mml:math id="n225"><mml:mrow><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>A</mml:mi><mml:mspace width=".3em"/><mml:mtext>and</mml:mtext><mml:mspace width=".1em"/><mml:msub><mml:mi>v</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>B</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The procedure constructs each element of <italic>C</italic>, one at a time, and adds it to the ordered set <italic>Z</italic>. The only elements ever deleted from set <italic>Z</italic> in Steps 8 and 12 are those that are not Pareto-optimal. Finally, Step 13 removes any remaining elements that are not Pateto-optimal from <italic>Z</italic>. The procedure thus computes the value of <inline-formula><mml:math id="n226"><mml:mrow><mml:mi>A</mml:mi><mml:mo>⊗</mml:mo><mml:mi>B</mml:mi></mml:mrow></mml:math></inline-formula> correctly.</p></statement>
</p>
      <p><italic>Complexity:</italic> Because both <italic>A</italic> and <italic>B</italic> contain at most <inline-formula><mml:math id="n227"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> vectors (Lemma 3.1), Steps 4 through 12 are each executed <inline-formula><mml:math id="n228"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> times. By using a self-balancing binary search tree to represent <italic>Z</italic>, each of these steps can be executed in <inline-formula><mml:math id="n229"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, yielding a total time complexity of <inline-formula><mml:math id="n230"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for Steps 1 through 12. Because the time complexity of Step 13 is <inline-formula><mml:math id="n231"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi>Z</mml:mi><mml:msup><mml:mo stretchy="false">|</mml:mo><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it now suffices to show that the size of <italic>Z</italic> never exceeds <italic>m</italic><sup>2</sup> at any time. Consider Steps 8 and 12. These steps ensure that for any fixed value of δ, and θ, there is at most one vector in <italic>Z</italic> of the form <inline-formula><mml:math id="n232"><mml:mrow><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, the size of <italic>Z</italic> can not exceed <inline-formula><mml:math id="n233"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> at any time.</p>
      <p>Based on the pseudo-code for Algorithm <italic>Pareto-Reconcile</italic>, and on the previous three lemmas, the next two theorems follow easily. For brevity, their proofs appear in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary Section S1</ext-link>.
<statement><title>T<sc>heorem</sc> 3.1</title><p>Algorithm Pareto-Reconcile correctly solves the PV problem.</p></statement>
<statement><title>T<sc>heorem</sc> 3.2</title><p><italic>The total time complexity of Algorithm Pareto-Reconcile is </italic><inline-formula><mml:math id="n234"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>5</mml:mn></mml:msup><mml:mi>n</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>. In addition, the algorithm can be implemented so that its total space complexity is </italic><inline-formula><mml:math id="n235"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Equivalent region partition</title>
      <p>In this section, we describe how the set of Pareto-optimal event count vectors can be used to efficiently partition the space of event costs into a finite number of equivalence classes, or ‘regions’, such that all event costs in a given region induce the same set of maximum parsimony reconciliations. These regions provide insights into the relationship between the event costs and the resulting solutions and are used in several of the software tools described in the next section.</p>
      <p>Recall that we assume that speciation is a ‘null’ event with cost 0 and all other events have positive costs. Because the costs are unit-less, duplication cost is normalized to 1 and the costs of transfer and loss are non-negative values relative to the unit cost of duplication. For a given event count vector <inline-formula><mml:math id="n236"><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mo>〈</mml:mo><mml:mi>δ</mml:mi><mml:mo>,</mml:mo><mml:mi>θ</mml:mi><mml:mo>,</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>〉</mml:mo></mml:mrow></mml:math></inline-formula> and positive real transfer and loss costs <inline-formula><mml:math id="n237"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n238"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, respectively, the cost of that solution, denoted <inline-formula><mml:math id="n239"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is <inline-formula><mml:math id="n240"><mml:mrow><mml:mi>δ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>·</mml:mo><mml:mi>θ</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo>·</mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>Let <italic>A</italic> denote the Pareto-optimal set of event count vectors for a given pair of trees and leaf mapping. These vectors induce a partition of the event cost space into <italic>regions</italic> where the region <italic>R</italic>(<italic>v</italic>) associated with event count vector <inline-formula><mml:math id="n241"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula> is the set of points <inline-formula><mml:math id="n242"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="n243"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>A</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p>From this definition, it follows that for every combination of transfer and loss costs in a given region, every maximum parsimony solution using those costs will have the event count vector associated with that region. While there can be many distinct reconciliations in a given region, all event costs in that region will admit the same set of maximum parsimony reconciliations.
<statement><title>T<sc>heorem</sc> 3.3</title><p><italic>Given a set of Pareto-optimal event count vectors, the corresponding regions can be found in time </italic><inline-formula><mml:math id="n244"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic>.</italic></p></statement>
<statement><title>P<sc>roof</sc></title><p>Let <italic>A</italic> denote the set of Pareto-optimal event count vectors. By Lemma 3.1, <inline-formula><mml:math id="n245"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The region <italic>R</italic>(<italic>v</italic>) corresponding to <inline-formula><mml:math id="n246"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>A</mml:mi></mml:mrow></mml:math></inline-formula> comprises all points <inline-formula><mml:math id="n247"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>θ</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msup><mml:mo>×</mml:mo><mml:msup><mml:mi>ℝ</mml:mi><mml:mo>+</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="n248"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>A</mml:mi><mml:mo>−</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>. Each inequality of the form <inline-formula><mml:math id="n249"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi mathvariant="script" class="calligraphy">C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> induces a half-space and <italic>R</italic>(<italic>v</italic>) is the intersection of those half-spaces. The intersection of <italic>N</italic> half-spaces can be found in time <inline-formula><mml:math id="n250"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>N</mml:mi><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btu289-B4" ref-type="bibr">Berg <italic>et al.</italic>, 2008</xref>) and thus each region can be found in time <inline-formula><mml:math id="n251"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, all <inline-formula><mml:math id="n252"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> regions can be found in time <inline-formula><mml:math id="n253"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>m</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p></statement>
</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Counting solutions and enumerating events</title>
      <p>Our algorithm for the PV problem can be easily adapted to count the number of maximum parsimony reconciliations for each Pareto-optimal event count vector and to record the events in those reconciliations. To count the number of distinct reconciliations, we keep track of the number of solutions associated with each event count vector in each subproblem <inline-formula><mml:math id="n254"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Those values are easily updated based on the number of solutions from the subproblems from which <inline-formula><mml:math id="n255"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is constructed (<xref rid="btu289-B3" ref-type="bibr">Bansal <italic>et al.</italic>, 2013</xref>). The additional bookkeeping does not increase the asymptotic running time of the algorithm.</p>
      <p>In addition, the dynamic program can be augmented to keep track of the set of events occurring in the reconciliations associated with a Pareto-optimal event count vector. While the number of reconciliations can grow exponentially with the <italic>m</italic> and <italic>n</italic>, the total number of distinct events is bounded by <inline-formula><mml:math id="n256"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> because each of the <italic>O</italic>(<italic>m</italic>) nodes of <italic>T</italic> can be mapped to at most <italic>O</italic>(<italic>n</italic>) nodes in <italic>S</italic> and, for transfer events, there are <italic>O</italic>(<italic>n</italic>) possible destinations for the ‘landing site’. For each subproblem <inline-formula><mml:math id="n257"><mml:mrow><mml:mi>P</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> we can, therefore, maintain a set of associated events such as the union or intersection of all events that occur in that subproblem. This increases the asymptotic running time by a factor that depends only on the time complexity of the particular set theoretic operation. For example, we use set intersection in the <italic>eventscape</italic> tool described in the next section, which contributes a multiplicative factor of <inline-formula><mml:math id="n258"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mi>log</mml:mi><mml:mo>⁡</mml:mo><mml:mi>m</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using self-balancing binary search trees.</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 APPLICATIONS AND SOFTWARE</title>
    <p>In this section, we demonstrate three programs that use the algorithmic results in the previous section to provide new insights into maximum parsimony reconciliation. Each of these tools solves the PV and ERP problems and uses those solutions in different ways. We note that while our algorithms can compute all Pareto-optimal regions, these tools take a user-specified a range of costs for transfer and loss events, relative to the normalized unit cost of duplication, and restrict the Pareto-optimal event count vectors and corresponding regions to that <italic>event cost space</italic>. (We note that the choice of fixing the duplication cost to 1 and normalizing the remaining costs with respect to duplication is arbitrary).</p>
    <p>The first tool, <italic>costscape</italic>, computes the Pareto-optimal event count vectors and their corresponding regions as well as a ‘Count’ of the number of distinct maximum parsimony reconciliations in each region. These results are displayed graphically to provide a systematic overview of the relationship between event costs and the structure of the maximum parsimony solution space. For example, <xref ref-type="fig" rid="btu289-F2">Figure 2</xref>a and b show the results of using costscape on the canonical gopher-louse (<xref rid="btu289-B12" ref-type="bibr">Hafner and Nadler, 1988</xref>) and indigobird-finch (<xref rid="btu289-B22" ref-type="bibr">Sorenson <italic>et al.</italic>, 2004</xref>) datasets for transfer and loss costs ranging from 0.1 to 5, relative to the unit cost of duplication.
<fig id="btu289-F2" position="float"><label>Fig. 2.</label><caption><p>Pareto-regions for the (<bold>a</bold>) gopher-louse and (<bold>b</bold>) indigobird-finch datasets. Colors are arbitrary and are used to match regions with the event counts in the legend. The displayed event counts comprise the number of speciations in addition to the number of duplications, transfers and losses. In addition, the ‘Count’ field indicates the number of distinct reconciliations in each region. While most regions are polygons, regions may also be points or lines, such as in the first region in the legend in (a). (<bold>c</bold>) Results of a permutation test on the gopher-louse dataset using 1000 random trials. For (c) only, green indicates significance at the 0.01 level, yellow represents significance between 0.01 and 0.05 and red indicates lack of significance at the 0.05 level. Brightness of green, yellow and red indicates differences in <italic>P</italic>-values, with brighter shades indicating smaller <italic>P</italic>-values. All plots use transfer and loss costs ranging from 0.1 to 5. Plus sign marks the default event costs for Jane/TreeMap (<inline-formula><mml:math id="n259"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>) and multiplication sign the default event costs for AnGST/RANGER-DTL (<inline-formula><mml:math id="n260"><mml:mrow><mml:msub><mml:mi>C</mml:mi><mml:mi>Δ</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mo>Θ</mml:mo></mml:msub><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>C</mml:mi><mml:mi>L</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>). In (a), the two sets of default costs are in the same region, whereas in (b) and in almost all but the smallest datasets, the two sets of default costs are in different regions</p></caption><graphic xlink:href="btu289f2"/></fig></p>
    <p>The second tool, <italic>eventscape</italic>, augments the dynamic programming algorithm to compute the set of events that are common to <italic>every</italic> reconciliation in a region. Eventscape then collects all of these events over all regions and partitions that set into the set of events that are found in exactly one region, exactly two regions and so forth up to the total number of regions. Each event includes a gene (parasite) node, its association with a species (host) node and the type of event. In the case of transfers, the landing site of the event is also specified. One important application of eventscape is in identifying events that are highly supported by merit of occurring in a large fraction of the regions or the cost space. The next section explores this application on a large collection of datasets.</p>
    <p>The third tool, <italic>sigscape</italic> is designed for cophylogenetic analyses where permutation tests are performed to test the null hypothesis that the host and parasite trees are similar owing to chance. Shades of each color indicate variations in <italic>P</italic>-values, with brighter shades indicating smaller <italic>P</italic>-values. For example, for the gopher-louse dataset using transfer and loss costs ranging from 0.1 to 5 and using 1000 permutations, sigscape found <inline-formula><mml:math id="n261"><mml:mrow><mml:mn>97.6</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> of the event cost space to have significance at the 0.01 level, <inline-formula><mml:math id="n262"><mml:mrow><mml:mn>1.5</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> to have significance between 0.01 and 0.05, and <inline-formula><mml:math id="n263"><mml:mrow><mml:mn>0.9</mml:mn><mml:mi>%</mml:mi></mml:mrow></mml:math></inline-formula> below the 0.05 level (<xref ref-type="fig" rid="btu289-F2">Fig. 2</xref>c). More details about sigscape are provided in <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary Section S2</ext-link>.</p>
    <p>These tools, collectively called <italic>xscape</italic>, are written in Python and are freely available at <ext-link ext-link-type="uri" xlink:href="www.cs.hmc.edu/~hadas/xscape">www.cs.hmc.edu/∼hadas/xscape</ext-link>. As noted earlier, the underlying algorithms do not guarantee time-consistent solutions because finding such solutions is NP-hard (<xref rid="btu289-B18" ref-type="bibr">Ovadia <italic>et al.</italic>, 2011</xref>). However, if the species trees are fully dated, then our algorithms can be modified (resulting in slower polynomial-time algorithms) to guarantee time-consistency (<xref rid="btu289-B7" ref-type="bibr">Conow <italic>et al.</italic>, 2010</xref>).</p>
  </sec>
  <sec>
    <title>5 RESULTS</title>
    <p>In this section, we demonstrate the utility of our algorithms and tools on a diverse collection of datasets. Currently, reconciliation analyses infer evolutionary events by choosing a set of event costs (often the default costs in the software, although most tools recommend experimenting with different costs) and constructing reconciliations based on these costs. Because event costs are not easily estimated and the choice of costs affects the reconciliations, we seek here to understand the impact of event costs on the resulting reconciliations.</p>
    <p>We first analyzed a biological dataset consisting of predominantly prokaryotic species sampled broadly from across the tree of life (<xref rid="btu289-B8" ref-type="bibr">David and Alm, 2011</xref>). This consisted of 4860 gene trees (with at least two extant genes) over 100 species, but, for efficiency, we restricted our analyses to a subset of 3433 gene families from 20 randomly sampled species and evaluated event counts and their corresponding event cost regions for transfer and loss costs ranging from 0.5 to 2 (with respect to the unit cost of duplication). The results presented here exclude 34 (&lt;1.0%) gene families for which <italic>eventscape</italic> used more than the allocated 5 GB of RAM in our experimental setup.</p>
    <p>Using the <italic>costscape</italic> tool, we observed that 85.8% (2917) of the gene families induce at least two regions, 37.5% (1274) have at least five regions and that the number of regions grows as a function of tree size (<xref ref-type="fig" rid="btu289-F3">Fig. 3</xref>a). Thus, the common practice of selecting a single cost setting or a small fixed number of cost settings [e.g., <xref rid="btu289-B23" ref-type="bibr">Stolzer <italic>et al.</italic> (2012)</xref> considered three settings, and <xref rid="btu289-B3" ref-type="bibr">Bansal <italic>et al.</italic> (2013)</xref> considered five] can result in missing potentially important parts of the solution space. Additionally, many regions have zero area (e.g. lines or points), meaning that the associated reconciliations are unlikely to be discovered by an ad hoc choice of event costs: for this dataset, 54.1% (1839) of the gene families have at least one region with zero area, and for 19.7% (669) of the gene families, more than half of the regions have zero area.
<fig id="btu289-F3" position="float"><label>Fig. 3.</label><caption><p>The <italic>costscape</italic> summary on the tree of life dataset. For each gene family, we computed (<bold>a</bold>) the number <italic>y</italic> of Pareto-optimal regions (all regions, black white circles; positive area regions, red plus sign; zero area regions, blue multiplication sign) and the number <italic>x</italic> of extant genes, and (<bold>b</bold>) the fraction <italic>y</italic> of the event cost space covered by the largest <italic>x</italic> regions</p></caption><graphic xlink:href="btu289f3"/></fig></p>
    <p>We also found that a systematic choice of event costs (e.g. using <italic>costscape</italic>) can cover a substantial portion of the solution space. For example, for all gene families studied here, an appropriately selected subset of five or fewer regions covers the majority (&gt;50%) of the event cost space (<xref ref-type="fig" rid="btu289-F3">Fig. 3</xref>b), and coverage of the event cost space appears to follow a power law distribution (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary Fig. S1</ext-link>). Although these results seem to suggest that a small set of event costs (and their associated regions) is representative of the entire event cost space, we note that coverage of event cost space is a biased measure, as some large regions may include cost ratios that are biologically unrealistic while other regions containing biologically plausible ratios might cover a small fraction of the event cost space. Regions of zero area, for example, are generally abundant and may contain a biologically relevant solution. While these results provide some preliminary understanding of the relationship of event costs and the space of maximum parsimony reconciliations, further research is needed to understand the properties of this space and, ultimately, to determine appropriate event costs.</p>
    <p>Next, we focus on the identification of well-supported events across the event cost space. Given a user-specified event cost space, that is, a range of costs on transfer and loss (with respect to the unit cost of duplication), we used the <italic>eventscape</italic> tool to infer the Pareto-optimal regions and the sets of events that are common to <inline-formula><mml:math id="n264"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> regions, where <italic>k</italic> is the total number of regions in the event cost space. We define an event to have <italic>consensus support s</italic>, <inline-formula><mml:math id="n265"><mml:mrow><mml:mn>0</mml:mn><mml:mo>≤</mml:mo><mml:mi>s</mml:mi><mml:mo>≤</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> (with respect to the event cost space), if the event is found in <italic>every reconciliation</italic> in at least a fraction <italic>s</italic> (inclusive) of the regions. Note that this is one of many possible measures of event support, and our algorithms can be used to define and compute other measures.</p>
    <p>Using this definition, we investigated the fraction of events supported at various support thresholds (<xref ref-type="fig" rid="btu289-F4">Fig. 4</xref>a). Almost universally, speciations are the best supported type of event, with ∼33.2% of speciations supported under strict consensus (that is, found in all regions). Manual inspection revealed that speciations found near the root of the tree were often conserved across multiple regions. However, when analyzing gene family evolution, we are typically interested in the inferred duplications, transfers and losses (collectively, the DTL events), and we found that few of these have high support. For example, only 2.1% of duplications, 15.1% of transfers and 2.1% of losses have at least 80% support (though the percentage of events with at least 50% support is substantially higher, with 56.8% of duplications, 41.4% of transfers and 34.9% of losses supported at that level). Interestingly, we observed a ‘jump’ in the number of supported events around a support threshold of 50%. Also, in general, for most support thresholds, duplications are the most supported type of event (after speciation), followed by transfers, then losses; however, for low support thresholds, the three types of DTL events show roughly equal support. These results have important implications for existing analyses that rely on DTL reconciliation and suggest that many inferred events are highly specific to the user-defined event costs.
<fig id="btu289-F4" position="float"><label>Fig. 4.</label><caption><p>Event support for the tree of life dataset as measured by (<bold>a</bold>) fraction of regions or (<bold>b</bold>) fraction of event cost space covered. Coordinate (<italic>x</italic>, <italic>y</italic>) indicates that fraction <italic>y</italic> of events are found in at least fraction <italic>x</italic> of regions (or event cost space), with the plot being left-continuous (such that the highest <italic>y</italic> for each <italic>x</italic> should be read). Over all gene families, 16 795 speciations, 8375 duplications, 41 247 transfers and 13 761 losses are inferred</p></caption><graphic xlink:href="btu289f4"/></fig></p>
    <p>In this study, we have investigated a specific range of event costs (transfer and loss ranging from 0.5 to 2 relative to the unit cost of duplication). The number of regions, and thus the level of consensus support, depends on this range. Moreover, our analyses permitted cost combinations in which duplications are more expensive or less expensive than transfers and losses. Adding constraints on these cost relationships could alter the levels of support. We also note that manual inspection revealed that loss events, and to a lesser extent transfers, are often ‘fungible’ in the sense that they can be moved from one location to another without changing the total cost of the solution, and thus any individual loss or transfer event is not likely to be strongly supported. By looking at the event cost space and supported events, our tools allow the elucidation of the complex interplay between event cost assignments and event support under various ranges and constraints of event costs.</p>
    <p>For completeness, we also determined event support as measured by fraction of the event cost space (rather than fraction of the number of regions) covered (<xref ref-type="fig" rid="btu289-F4">Fig. 4</xref>b), yielding similar results. The main difference between these two measures is that event support increases gradually with increasing region coverage but tends to ‘jump’ with increasing event cost space coverage; this confirms our finding that the event cost space is dominated by a few large regions. Otherwise, duplications also show a clear demarcation from no support to high support at ∼66.7% coverage.</p>
    <p>To demonstrate the applicability of our tools on cophylogenetic datasets, we performed similar analyses on five host–parasite datasets and found results consistent with those above (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary Section S3</ext-link>, <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary Fig. S2</ext-link>).</p>
    <p>Finally, the average runtimes for our tools is on the order of seconds (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu289/-/DC1">Supplementary Table S1</ext-link>). To demonstrate scalability, we also ran <italic>costscape</italic> on the full 100-taxa tree of life dataset (also using transfer and loss costs ranging from 0.5 to 2) and found that the median runtime remains &lt;1 min.</p>
  </sec>
  <sec>
    <title>6 CONCLUSIONS</title>
    <p>In this work, we have described new algorithms and tools for understanding the relationship between event costs and maximum parsimony reconciliations. In particular, we have given algorithms for computing the set of Pareto-optimal event count vectors and partitioning the event cost space into equivalence classes, or regions, induced by these vectors. We have demonstrated these algorithms in three software tools that (i) compute and visualize the regions that partition the event cost space, (ii) list the sets of events shared by reconciliations within and between regions and (iii) determine the statistical significance of reconciliation costs over the cost space.</p>
    <p>An alternative approach to computing Pareto-optimal event count vectors would be to uniformly sample event costs and, for each sample, use existing algorithms to compute the maximum parsimony reconciliation and corresponding event counts. However, it is not known how to determine the appropriate sampling density to capture all event count vectors. Additionally, sampling fails to find regions that comprise points and lines, which we have shown to comprise a large fraction of the total number of solutions. Finally, our approach allows us to determine all Pareto-optimal event count vectors, whereas a sampling approach would necessarily capture only a subset of the event cost space.</p>
    <p>Using the tools based on our algorithms, we have conducted experiments on a broad array of datasets. These results show that the space of maximum parsimony solutions is complex and sensitive to the event costs, and thus, choosing ad hoc event costs may result in misrepresenting evolutionary histories. At the same time, we cannot discount ad hoc procedures for finding event costs [for example, through comparison to event inferences on a biological dataset, as in <xref rid="btu289-B8" ref-type="bibr">David and Alm (2011)</xref>]. In particular, such approaches may elucidate the boundaries for biologically reasonable event cost assignments, which could then be used as input into our tools for more systematic analysis.</p>
    <p>In addition, by defining notions of consensus support based on the number of regions that share an event, we found that while many speciation events have high consensus support, most other events do not. Thus, inferring events based on non-systematically selected event costs is likely to provide only a piece of a complex picture, and our tools motivate further investigation into the robustness of analyses based on DTL reconciliation.</p>
    <p>There are numerous interesting directions for future work. In particular, this work affords opportunities to explore many variants of event consensus support. For example, our work uses the most specific definition of an event in computing support: for a speciation, duplication or transfer to be supported across different reconciliations, a gene (parasite) tree node must map to the same species (host) tree node and to the same event, and transfers must also yield the same transfer edge. Similarly, for two losses to be supported across different reconciliations, they must be found along the same branch of both the gene tree and species tree. In some cases, analyses only require the species mapping (<xref rid="btu289-B8" ref-type="bibr">David and Alm, 2011</xref>) or event mapping (<xref rid="btu289-B15" ref-type="bibr">Koonin, 2005</xref>), and thus the support values must be considered for these relaxed definitions of events. Our algorithms can be modified accordingly.</p>
    <p>In addition to identifying highly supported events, it is desirable to find highly supported whole reconciliations. In the spirit of promising recent work on this problem for fixed event costs (<xref rid="btu289-B21" ref-type="bibr">Scornavacca <italic>et al.</italic>, 2013</xref>), one promising research direction is to identify and succinctly represent whole reconciliations that are robust across the space of event costs.</p>
    <p>In summary, this work provides techniques and tools that are immediately useful in the phylogenomic, cophylogenetic and biogeography analyses and offers avenues for further research that leverages the Pareto-optimal reconciliation methods developed here</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>The authors thank the anonymous referees for their invaluable comments.</p>
    <p><italic>Funding</italic>: This work was supported by the <funding-source>R. Michael Shanahan Endowment</funding-source> to R.L-H., startup funds from the <funding-source>University of Connecticut</funding-source> to M.S.B. and <funding-source>National Science Foundation</funding-source> CAREER award <award-id>0644282</award-id> to M.K.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu289-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Addario-Berry</surname>
            <given-names>L</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Towards identifying lateral gene transfer events</article-title>
        <source>Pac. Symp. Biocomput.</source>
        <year>2003</year>
        <volume>8</volume>
        <fpage>279</fpage>
        <lpage>290</lpage>
        <pub-id pub-id-type="pmid">12603035</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bansal</surname>
            <given-names>MS</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>283</fpage>
        <lpage>291</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bansal</surname>
            <given-names>MS</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reconciliation revisited: Handling multiple optima when reconciling with duplication, transfer, and loss</article-title>
        <source>J. Comput. Biol.</source>
        <year>2013</year>
        <volume>20</volume>
        <fpage>738</fpage>
        <lpage>754</lpage>
        <pub-id pub-id-type="pmid">24033262</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B4">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Berg</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <source>Computational Geometry: Algorithms and Applications</source>
        <year>2008</year>
        <edition>3rd edn</edition>
        <publisher-loc>Santa Clara, CA</publisher-loc>
        <publisher-name>Springer-Verlag TELOS</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu289-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Charleston</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Jungles: a new solution to the host-parasite phylogeny reconciliation problem</article-title>
        <source>Math. Biosci.</source>
        <year>1998</year>
        <volume>149</volume>
        <fpage>191</fpage>
        <lpage>223</lpage>
        <pub-id pub-id-type="pmid">9621683</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>ZZ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Simultaneous identification of duplications, losses, and lateral gene transfers</article-title>
        <source>IEEE/ACM Trans. Comput. Biol. Bioinform.</source>
        <year>2012</year>
        <volume>9</volume>
        <fpage>1515</fpage>
        <lpage>1528</lpage>
        <pub-id pub-id-type="pmid">22641711</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Conow</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Jane: a new tool for the cophylogeny reconstruction problem</article-title>
        <source>Algorithm Mol. Biol.</source>
        <year>2010</year>
        <volume>5</volume>
        <fpage>16</fpage>
      </element-citation>
    </ref>
    <ref id="btu289-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>David</surname>
            <given-names>LA</given-names>
          </name>
          <name>
            <surname>Alm</surname>
            <given-names>EJ</given-names>
          </name>
        </person-group>
        <article-title>Rapid evolutionary innovation during an archaean genetic expansion</article-title>
        <source>Nature</source>
        <year>2011</year>
        <volume>469</volume>
        <fpage>93</fpage>
        <lpage>96</lpage>
        <pub-id pub-id-type="pmid">21170026</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B9">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Doyon</surname>
            <given-names>JP</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Tannier</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>An efficient algorithm for gene/species trees parsimonious reconciliation with losses, duplications and transfers</article-title>
        <source>RECOMB-CG, volume 6398 of Lecture Notes in Computer Science</source>
        <year>2010</year>
        <publisher-loc>Berlin Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>93</fpage>
        <lpage>108</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gómez</surname>
            <given-names>JM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ecological interactions are evolutionarily conserved across the entire tree of life</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>465</volume>
        <fpage>918</fpage>
        <lpage>921</lpage>
        <pub-id pub-id-type="pmid">20520609</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Goodman</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fitting the gene lineage into its species lineage. a parsimony strategy illustrated by cladograms constructed from globin sequences</article-title>
        <source>Syst. Zool.</source>
        <year>1979</year>
        <volume>28</volume>
        <fpage>132</fpage>
        <lpage>163</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hafner</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Nadler</surname>
            <given-names>SA</given-names>
          </name>
        </person-group>
        <article-title>Phylogenetic trees support the coevolution of parasites and their hosts</article-title>
        <source>Nature</source>
        <year>1988</year>
        <volume>332</volume>
        <fpage>258</fpage>
        <lpage>259</lpage>
        <pub-id pub-id-type="pmid">3347269</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B13">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Hallett</surname>
            <given-names>MT</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Bourne</surname>
            <given-names>PE</given-names>
          </name>
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Simultaneous identification of duplications and lateral transfers</article-title>
        <source>RECOMB</source>
        <year>2004</year>
        <publisher-loc>New York, NY, USA</publisher-loc>
        <publisher-name>ACM</publisher-name>
        <fpage>347</fpage>
        <lpage>356</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jackson</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Charleston</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A cophylogenetic perspective of RNA-virus evolution</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2004</year>
        <volume>21</volume>
        <fpage>45</fpage>
        <lpage>57</lpage>
        <pub-id pub-id-type="pmid">12949128</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Koonin</surname>
            <given-names>EV</given-names>
          </name>
        </person-group>
        <article-title>Orthologs, paralogs, and evolutionary genomics</article-title>
        <source>Annu. Rev. Genet.</source>
        <year>2005</year>
        <volume>39</volume>
        <fpage>309</fpage>
        <lpage>338</lpage>
        <pub-id pub-id-type="pmid">16285863</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Libeskind-Hadas</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Charleston</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>On the computational complexity of the reticulate cophylogeny reconstruction problem</article-title>
        <source>J. Comput. Biol.</source>
        <year>2009</year>
        <volume>16</volume>
        <fpage>105</fpage>
        <lpage>117</lpage>
        <pub-id pub-id-type="pmid">19119995</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B17">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Morrone</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <source>Evolutionary Biogeography: An Integrative Approach with Case Studies</source>
        <year>2009</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>Columbia University Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="btu289-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ovadia</surname>
            <given-names>Y</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The cophylogeny reconstruction problem is NP-complete</article-title>
        <source>J. Comput. Biol.</source>
        <year>2011</year>
        <volume>18</volume>
        <fpage>59</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="pmid">20715926</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Page</surname>
            <given-names>RDM</given-names>
          </name>
        </person-group>
        <article-title>Maps between trees and cladistic analysis of historical associations among genes, organisms, and areas</article-title>
        <source>Syst. Biol.</source>
        <year>1994</year>
        <volume>43</volume>
        <fpage>58</fpage>
        <lpage>77</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rutschmann</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Molecular dating of phylogenetic trees: a brief review of current methods that estimate divergence times</article-title>
        <source>Divers. Distrib.</source>
        <year>2006</year>
        <volume>12</volume>
        <fpage>35</fpage>
        <lpage>48</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Scornavacca</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Representing a set of reconciliations in a compact way</article-title>
        <source>J. Bioinform. Comput. Biol.</source>
        <year>2013</year>
        <volume>11</volume>
        <fpage>1250025</fpage>
        <pub-id pub-id-type="pmid">23600816</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sorenson</surname>
            <given-names>MD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Clade-limited colonization in brood parasitic finches (vidua spp.)</article-title>
        <source>Syst. Biol.</source>
        <year>2004</year>
        <volume>53</volume>
        <fpage>140</fpage>
        <lpage>153</lpage>
        <pub-id pub-id-type="pmid">14965909</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stolzer</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Inferring duplications, losses, transfers and incomplete lineage sorting with nonbinary species trees</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>409</fpage>
        <lpage>415</lpage>
      </element-citation>
    </ref>
    <ref id="btu289-B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Szollosi</surname>
            <given-names>GJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Phylogenetic modeling of lateral gene transfer reconstructs the pattern and relative timing of speciations</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2012</year>
        <volume>109</volume>
        <fpage>17513</fpage>
        <lpage>17518</lpage>
        <pub-id pub-id-type="pmid">23043116</pub-id>
      </element-citation>
    </ref>
    <ref id="btu289-B25">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Tofigh</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Using trees to capture reticulate evolution: lateral gene transfers and cancer progression</article-title>
        <year>2009</year>
        <comment>PhD Thesis, KTH Royal Institute of Technology</comment>
      </element-citation>
    </ref>
    <ref id="btu289-B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tofigh</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Simultaneous identification of duplications and lateral gene transfers</article-title>
        <source>IEEE/ACM Trans. Comput. Biol. Bioinform.</source>
        <year>2011</year>
        <volume>8</volume>
        <fpage>517</fpage>
        <lpage>535</lpage>
        <pub-id pub-id-type="pmid">21233529</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
