<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612807</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz312</article-id>
    <article-id pub-id-type="publisher-id">btz312</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Population Genomics and Molecular Evolution</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Summarizing the solution space in tumor phylogeny inference by multiple consensus trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Aguse</surname>
          <given-names>Nuraini</given-names>
        </name>
        <xref ref-type="author-notes" rid="btz312-FM2"/>
        <xref ref-type="aff" rid="btz312-aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Qi</surname>
          <given-names>Yuanyuan</given-names>
        </name>
        <xref ref-type="author-notes" rid="btz312-FM2"/>
        <xref ref-type="aff" rid="btz312-aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>El-Kebir</surname>
          <given-names>Mohammed</given-names>
        </name>
        <xref ref-type="corresp" rid="btz312-cor1"/>
        <!--<email>melkebir@illinois.edu</email>-->
        <xref ref-type="aff" rid="btz312-aff1"/>
      </contrib>
    </contrib-group>
    <aff id="btz312-aff1">Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, USA</aff>
    <author-notes>
      <corresp id="btz312-cor1">To whom correspondence should be addressed. <email>melkebir@illinois.edu</email></corresp>
      <fn id="btz312-FM2">
        <p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i408</fpage>
    <lpage>i416</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz312.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Cancer phylogenies are key to studying tumorigenesis and have clinical implications. Due to the heterogeneous nature of cancer and limitations in current sequencing technology, current cancer phylogeny inference methods identify a large solution space of plausible phylogenies. To facilitate further downstream analyses, methods that accurately summarize such a set <inline-formula id="IE1"><mml:math id="IM1"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of cancer phylogenies are imperative. However, current summary methods are limited to a single consensus tree or graph and may miss important topological features that are present in different subsets of candidate trees.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We introduce the <sc>Multiple Consensus Tree</sc> (MCT) problem to simultaneously cluster <inline-formula id="IE2"><mml:math id="IM2"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and infer a consensus tree for each cluster. We show that MCT is NP-hard, and present an exact algorithm based on mixed integer linear programming (MILP). In addition, we introduce a heuristic algorithm that efficiently identifies high-quality consensus trees, recovering all optimal solutions identified by the MILP in simulated data at a fraction of the time. We demonstrate the applicability of our methods on both simulated and real data, showing that our approach selects the number of clusters depending on the complexity of the solution space <inline-formula id="IE3"><mml:math id="IM3"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><ext-link ext-link-type="uri" xlink:href="https://github.com/elkebir-group/MCT">https://github.com/elkebir-group/MCT</ext-link>.</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">UIUC Center for Computational Biotechnology and Genomic Medicine</named-content>
        </funding-source>
        <award-id>CSN 1624790</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">National Science Foundation</named-content>
          <named-content content-type="funder-identifier">10.13039/100000001</named-content>
        </funding-source>
        <award-id>1850502</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Cancer results from an evolutionary process, during which somatic mutations accumulate in a population of cells (<xref rid="btz312-B23" ref-type="bibr">Nowell, 1976</xref>), resulting in the formation of multiple tumor clones with distinct sets of mutations (<xref ref-type="fig" rid="btz312-F1">Fig. 1a</xref>). A <italic>phylogenetic tree</italic>, or phylogeny, is a model that represents this process. Mathematically, a phylogenetic tree for a tumor is a rooted tree <italic>T</italic>, whose leaves correspond to extant cells and whose internal vertices correspond to ancestral cells. The root of <italic>T</italic> is a normal cell, containing no somatic mutations. In classic phylogenetics, we aim to infer <italic>T</italic> given the leaf set <italic>L</italic>(<italic>T</italic>) under an appropriate evolutionary model. However, due to extensive uncertainty in single-cell DNA sequencing data (<xref rid="btz312-B22" ref-type="bibr">Navin, 2014</xref>) and the presence of mixed cellular populations in bulk DNA sequencing data (<xref rid="btz312-B7" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2015</xref>), we do not observe the leaves of <italic>T</italic>. Rather, our data consist of individually-sequenced cells that may contain errors that must be corrected, or cell populations that have been sequenced in bulk, resulting in mutation frequencies. As a consequence of this ambiguity, tumor phylogeny inference methods for both data types typically infer multiple phylogenetic trees <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with <italic>distinct</italic> topologies and <italic>distinct</italic> leaf sets that represent alternative evolutionary histories (<xref ref-type="fig" rid="btz312-F1">Fig. 1b</xref>).
</p>
    <fig id="btz312-F1" orientation="portrait" position="float">
      <label>Fig. 1.</label>
      <caption>
        <p>(<bold>a</bold>) Tumors are heterogeneous, composed of multiple clones with different sets of somatic mutations. This heterogeneity is the result of an evolutionary process, as modeled by a phylogenetic tree. Under the commonly used infinite sites model of evolution, where each mutation is acquired once and never lost, a phylogenetic tree may be equivalently represented by a mutation tree. (<bold>b</bold>) Due to ambiguities in bulk and single-cell sequencing data of tumors, current methods infer a large solution space of plausible mutation trees <inline-formula id="IE5"><mml:math id="IM5"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. For further downstream analyses of tumorigenesis, this solution space needs to be summarized. (<bold>c</bold>) Current summary methods either construct the parent-child graph <italic>G<sub>T</sub></italic> or identify a single consensus tree <italic>R</italic>, failing to adequately summarize solution spaces comprised of clusters of trees with distinct topological features. (<bold>d</bold>) Here, we introduce the <sc>Multiple Consensus Tree</sc> problem to simultaneously cluster mutation trees and construct a consensus tree of each cluster</p>
      </caption>
      <graphic xlink:href="btz312f1"/>
    </fig>
    <p>The majority of current methods in cancer phylogenetics make the <italic>infinite sites assumption</italic>, which states that a mutation is gained only once and never subsequently lost (<xref rid="btz312-B2" ref-type="bibr">Dang <italic>et al.</italic>, 2017</xref>; <xref rid="btz312-B3" ref-type="bibr">Deshwar <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B5" ref-type="bibr">Donmez <italic>et al.</italic>, 2016</xref>; <xref rid="btz312-B7" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2015</xref>, <xref rid="btz312-B8" ref-type="bibr">2016</xref>; <xref rid="btz312-B13" ref-type="bibr">Jahn <italic>et al.</italic>, 2016</xref>; <xref rid="btz312-B15" ref-type="bibr">Jiang <italic>et al.</italic>, 2016</xref>; <xref rid="btz312-B16" ref-type="bibr">Jiao <italic>et al.</italic>, 2014</xref>; <xref rid="btz312-B20" ref-type="bibr">Malikic <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B24" ref-type="bibr">Popic <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B25" ref-type="bibr">Ross and Markowetz, 2016</xref>; <xref rid="btz312-B29" ref-type="bibr">Strino <italic>et al.</italic>, 2013</xref>; <xref rid="btz312-B34" ref-type="bibr">Yuan <italic>et al.</italic>, 2015</xref>). Under this assumption, we may represent a phylogenetic tree <italic>T</italic> by a <italic>mutation tree</italic><inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btz312-B8" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2016</xref>; <xref rid="btz312-B13" ref-type="bibr">Jahn <italic>et al.</italic>, 2016</xref>). More specifically, we contract unlabeled edges of <italic>T</italic> to obtain <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>, whose vertices we label by the mutations that were introduced on the incoming edges (<xref ref-type="fig" rid="btz312-F1">Fig. 1a</xref>). Tumor phylogenies that adhere to the infinite sites assumption have been used to identify mutations that drive cancer progression (<xref rid="btz312-B14" ref-type="bibr">Jamal-Hanjani <italic>et al.</italic>, 2017</xref>; <xref rid="btz312-B21" ref-type="bibr">McGranahan <italic>et al.</italic>, 2015</xref>), assess the interplay between the immune system and the clonal architecture of a tumor (<xref rid="btz312-B19" ref-type="bibr">Łuksza <italic>et al.</italic>, 2017</xref>; <xref rid="btz312-B36" ref-type="bibr">Zhang <italic>et al.</italic>, 2018</xref>) and identify common evolutionary patterns in tumorigenesis and metastasis (<xref rid="btz312-B30" ref-type="bibr">Turajlic <italic>et al.</italic>, 2018a</xref>, <xref rid="btz312-B31" ref-type="bibr">b</xref>). These downstream analyses critically rely on the accuracy of the input phylogenetic tree. Thus, methods to accurately summarize the solution space <inline-formula id="IE8"><mml:math id="IM8"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> are essential, so as to remove inference errors and identify common dependencies between mutations in the input trees.</p>
    <p>A common approach employed in several studies (<xref rid="btz312-B3" ref-type="bibr">Deshwar <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B7" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B16" ref-type="bibr">Jiao <italic>et al.</italic>, 2014</xref>) summarizes the solution space <inline-formula id="IE9"><mml:math id="IM9"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by constructing the <italic>parent-child graph</italic><inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, which is a directed, edge-weighted graph that represents the union of all trees in <inline-formula id="IE11"><mml:math id="IM11"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. That is, each edge (<italic>u</italic>, <italic>v</italic>) of this graph corresponds to an edge in a tree <italic>T</italic> in the solution space <inline-formula id="IE12"><mml:math id="IM12"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and is weighted by the number of occurrences in <inline-formula id="IE13"><mml:math id="IM13"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> (<xref ref-type="fig" rid="btz312-F1">Fig. 1c</xref>). A key deficiency of the parent-child graph is that it does not accurately represent <italic>topological features</italic> of the solution space, i.e. patterns of co-occurrence and mutual exclusivity among edges in individual trees in the solution space. Moreover, downstream analyses require a single phylogenetic tree as input and are unable to operate directly on the parent-child graph.</p>
    <p>To overcome the latter limitation, <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref> introduced the <sc>Single Consensus Tree</sc> problem, which aims at constructing a <italic>consensus tree</italic> that best represents the solution space <inline-formula id="IE14"><mml:math id="IM14"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. To quantify similarity or distance between two trees, one needs a distance function. Recently, <xref rid="btz312-B17" ref-type="bibr">Karpov <italic>et al.</italic> (2018)</xref> introduced a tree edit distance measure that can be efficiently computed using dynamic programming. Using a distance function that directly measures edge similarity, <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref> seek a consensus tree with minimum total distance to the trees in <inline-formula id="IE15"><mml:math id="IM15"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. The main drawback to summarizing <inline-formula id="IE16"><mml:math id="IM16"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by a single tree is that important topological features may be missed, which is especially the case when <inline-formula id="IE17"><mml:math id="IM17"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> contains multiple clusters of distinctive trees. We note that there is a large body of work for consensus tree problems in classic phylogenetics (cf. <xref rid="btz312-B32" ref-type="bibr">Warnow, 2017</xref>). These methods are often based on bipartitions of a fixed leaf set. However, as mentioned above, the leaf set is typically unknown <italic>a priori</italic> in cancer phylogenetics due to the nature of the input data, preventing the direct application of consensus tree methods that rely on fixed leaf sets.</p>
    <p>In this paper, we introduce the <sc>Multiple Consensus Tree</sc> (MCT) problem of simultaneously grouping trees <inline-formula id="IE18"><mml:math id="IM18"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> into <italic>k</italic> clusters and reconstructing a consensus tree for each cluster with minimum total distance. The MCT approach better summarizes solution spaces <inline-formula id="IE19"><mml:math id="IM19"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> with distinct topological features, overcoming limitations of current approaches (<xref ref-type="fig" rid="btz312-F1">Fig. 1d</xref>). We prove that MCT is NP-hard, and give an exact approach based on mixed integer linear programming (MILP) that is able to efficiently solve small instances to optimality. In addition, we introduce a heuristic based on coordinate ascent that scales to large input instances. We benchmark our methods on simulated data, showing that the heuristic approach yields solution of quality comparable to that of the MILP approach at only a fraction of the time. We demonstrate the applicability of the MCT problem on recent lung cancer data. Our methods enable one to draw informed conclusions in downstream phylogenetic analyses of tumors.</p>
  </sec>
  <sec>
    <title>2 Problem statement</title>
    <p>The key object in this paper is a mutation tree, which is a defined as follows.</p>
    <p>
      <statement id="mthst1">
        <label>Definition 1</label>
        <p>A <italic>mutation tree T</italic> is a rooted tree whose <italic>m</italic> nodes are uniquely labeled by mutations <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
    </p>
    <p>We obtain a mutation tree <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> from a phylogenetic tree <inline-formula id="IE22"><mml:math id="IM22"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that satisfies the infinite sites assumption by first contracting its unlabeled edges, and then labeling the resulting vertices by the mutations present on their incoming edges (<xref ref-type="fig" rid="btz312-F1">Fig. 1a</xref>). To summarize a set <inline-formula id="IE23"><mml:math id="IM23"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of mutation trees (<xref ref-type="fig" rid="btz312-F1">Fig. 1b</xref>), we consider the following distance function, which was shown to be a distance metric by <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref>.</p>
    <p>
      <statement id="mthst2">
        <label>Definition 2</label>
        <p>Let <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be two rooted trees on the same vertex set <italic>V</italic>. The <italic>parent-child distance</italic><inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the number of edges unique to either tree, i.e.
<disp-formula id="E1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>∖</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo>∖</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
Mathematically, the parent-child distance <inline-formula id="IE27"><mml:math id="IM27"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of two rooted trees <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the size of the symmetric difference between <italic>E</italic> and <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mi>E</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. This distance has been used extensively in the tumor phylogeny inference literature to compare inferred trees to simulated trees (<xref rid="btz312-B7" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B20" ref-type="bibr">Malikic <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B24" ref-type="bibr">Popic <italic>et al.</italic>, 2015</xref>). <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref> used the parent-child distance to define a consensus tree for a set input trees <inline-formula id="IE31"><mml:math id="IM31"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> as follows.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst3">
        <label>Definition 3</label>
        <p>A <italic>consensus tree</italic> for rooted trees <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with the same vertex set <italic>V</italic> is a rooted tree <italic>R</italic> with vertex set <italic>V</italic>.</p>
        <p>Subsequently, <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref> introduced the <sc>Single Consensus Tree</sc> problem, which given a set <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of input trees seeks a consensus tree <italic>R</italic> with minimum total distance <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst4">
        <label>Problem 1</label>
        <p>(<sc>Single Consensus Tree</sc> (SCT)) Given distinct rooted trees <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with the same vertex set, find a consensus tree <italic>R</italic> such that <inline-formula id="IE36"><mml:math id="IM36"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is minimum.</p>
        <p>To better account for extensive ambiguity in the topology of solution trees, we introduce the <sc>Multiple Consensus Tree</sc> problem, which generalizes the <sc>Single Consensus Tree</sc> to <italic>k</italic> clusters.</p>
      </statement>
    </p>
    <p>
      <statement id="mthst5">
        <label>Problem 2</label>
        <p>(<sc>Multiple Consensus Tree</sc> (MCT)) Given distinct rooted trees <inline-formula id="IE37"><mml:math id="IM37"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and integer <inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, find a clustering <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and consensus trees <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> such that (i) no cluster <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is empty, i.e. <italic>σ</italic> is surjective, and (ii) <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is minimum.</p>
      </statement>
    </p>
  </sec>
  <sec>
    <title>3 Combinatorial structure and complexity</title>
    <p>Section 3.1 characterizes the solution space of the MCT problem. Section 3.2 shows that this problem is NP-hard. Proofs are in the supplement due to space constraints.</p>
    <sec>
      <title>3.1 Combinatorial characterization of optimal solutions</title>
      <p>To characterize the space of solutions to the MCT, we start by reviewing results for the SCT problem (<xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic>, 2018</xref>). Given input trees <inline-formula id="IE43"><mml:math id="IM43"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>, <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref> defined the parent-child graph <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as follows.</p>
      <p>
        <statement id="mthst6">
          <label>Definition 4</label>
          <p>(<xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref>) The <italic>parent-child graph</italic><inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of a set <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of trees is a weighted directed graph <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with the same vertex set <italic>V</italic> as each input tree, an edge <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:math></inline-formula> if and only if there exists an input tree <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and weight <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> equal to the number of input trees with edge (<italic>u</italic>, <italic>v</italic>), i.e.
<disp-formula id="E2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
          <p>Subsequently, the authors showed that solutions to an SCT instance <inline-formula id="IE52"><mml:math id="IM52"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> are maximum weight spanning arborescences in the parent-child graph <inline-formula id="IE53"><mml:math id="IM53"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We note that maximum weight spanning arborescences and branchings (with multiple root vertices) have frequent applications in computational biology (e.g. <xref rid="btz312-B4" ref-type="bibr">Desper <italic>et al.</italic>, 1999</xref>).</p>
        </statement>
      </p>
      <p>
        <statement id="mthst7">
          <label>Theorem 1</label>
          <p>(<xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic>, 2018</xref>) Given input trees <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, there exists a consensus tree <italic>R</italic> with minimum distance <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that is a maximum weight spanning arborescence in the parent-child graph <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
          <p>We have the following two lemmas that follow from the above theorem.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst8">
          <label>Lemma 1</label>
          <p>There exists an optimal consensus tree <italic>R</italic> to SCT instance <inline-formula id="IE57"><mml:math id="IM57"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> where each edge (<italic>u</italic>, <italic>v</italic>) of <italic>R</italic> occurs in an input tree.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst9">
          <label>Lemma 2</label>
          <p>There exists an optimal consensus tree <italic>R</italic> to SCT instance <inline-formula id="IE58"><mml:math id="IM58"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> where if an edge (<italic>u</italic>, <italic>v</italic>) is present in all trees <inline-formula id="IE59"><mml:math id="IM59"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> then (<italic>u</italic>, <italic>v</italic>) is an edge of the consensus tree <italic>R</italic>.</p>
          <p>Let <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> be the size of the vertex set <italic>V</italic> of a set <inline-formula id="IE61"><mml:math id="IM61"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of input trees. We prove the following relationship between the weight <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of any spanning arborescence <italic>R</italic> in <inline-formula id="IE63"><mml:math id="IM63"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and its distance <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to input trees <inline-formula id="IE65"><mml:math id="IM65"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst10">
          <label>Lemma 3</label>
          <p>The total distance <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munder><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of any spanning arborescence <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>R</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of parent-child graph <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to input trees <inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> equals <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
          <p>We have the following important proposition.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst11">
          <label>Proposition 1</label>
          <p>Given a clustering <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, the MCT problem decomposes into <italic>k</italic> independent SCT problems.</p>
          <p>From the above proposition and Theorem 1, we obtain the following corollaries that are generalizations of Lemmas 1, 2 and 3.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst12">
          <p><bold>Corollary 1</bold> There exists an optimal solution <inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to MCT instance <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where each edge of each consensus tree <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></inline-formula> occurs in an input tree in the set <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of trees assigned to cluster <italic>s</italic>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst13">
          <p><bold>Corollary 2</bold> There exists an optimal solution <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to MCT instance <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where if an edge (<italic>u</italic>, <italic>v</italic>) is present in all trees <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> assigned to cluster <italic>s</italic> then (<italic>u</italic>, <italic>v</italic>) is an edge of the consensus tree <italic>R<sub>s</sub></italic>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst14">
          <p><bold>Corollary 3</bold> There exists an optimal solution <inline-formula id="IE79"><mml:math id="IM79"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to MCT instance <inline-formula id="IE80"><mml:math id="IM80"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with total distance
<disp-formula id="E3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <inline-formula id="IE81"><mml:math id="IM81"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the weight of a maximum weight spanning arborescence <italic>R<sub>s</sub></italic> of the parent-child graph <inline-formula id="IE82"><mml:math id="IM82"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> obtained from <inline-formula id="IE83"><mml:math id="IM83"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
          <p>As the number of <italic>k</italic> of clusters increases the minimum total distance will decrease, as shown by the following proposition.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst15">
          <label>Proposition 2</label>
          <p>The minimum total distance of an MCT instance <inline-formula id="IE84"><mml:math id="IM84"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is monotonically decreasing with increasing number <italic>k</italic> of clusters.</p>
        </statement>
      </p>
    </sec>
    <sec>
      <title>3.2 Complexity</title>
      <p>Theorem 2 Multiple Consensus Tree (MCT) is NP-hard.</p>
      <p>We give a polynomial-time reduction from the Clique problem, a known NP-complete problem (<xref rid="btz312-B11" ref-type="bibr">Garey and Johnson, 1979</xref>).</p>
      <p>
        <statement id="mthst16">
          <label>Problem 3</label>
          <p>(<sc>Clique</sc>) Given an undirected, simple graph <italic>H</italic> with vertex set <italic>V</italic>(<italic>H</italic>), edge set <italic>E</italic>(<italic>H</italic>) and a positive integer <inline-formula id="IE85"><mml:math id="IM85"><mml:mrow><mml:mi>c</mml:mi><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, decide whether <italic>G</italic> contains a clique of size <italic>c</italic>.</p>
        </statement>
      </p>
      <p>To reduce a <sc>Clique</sc> instance (<italic>H</italic>, <italic>c</italic>) to an MCT instance <inline-formula id="IE86"><mml:math id="IM86"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we introduce the notation <inline-formula id="IE87"><mml:math id="IM87"><mml:mrow><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to indicate the subset of edges that are incident to <italic>v</italic>, i.e. <inline-formula id="IE88"><mml:math id="IM88"><mml:mrow><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>v</mml:mi><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>or</mml:mtext><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mi>v</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For each vertex <italic>v<sub>i</sub></italic> of <italic>H</italic>, we construct a tree <inline-formula id="IE89"><mml:math id="IM89"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The vertex set <italic>U</italic> of <italic>T<sub>i</sub></italic> is defined as <inline-formula id="IE90"><mml:math id="IM90"><mml:mrow><mml:mo>{</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mo>⊥</mml:mo><mml:mo>}</mml:mo><mml:mo>∪</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and the edge set <italic>A<sub>i</sub></italic> contains directed edges <inline-formula id="IE91"><mml:math id="IM91"><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mo>⊥</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>⊥</mml:mo><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE92"><mml:math id="IM92"><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∖</mml:mo><mml:mo>δ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. We set <inline-formula id="IE93"><mml:math id="IM93"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Since all the input trees <inline-formula id="IE94"><mml:math id="IM94"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> are on the same vertex set <italic>U</italic> and <inline-formula id="IE95"><mml:math id="IM95"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, it holds that <inline-formula id="IE96"><mml:math id="IM96"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is an instance of MCT problem. Clearly, this construction can be performed in time polynomial in <italic>n</italic> and <italic>m</italic>. <xref ref-type="fig" rid="btz312-F2">Figure 2</xref> shows an example of reduction.
</p>
      <fig id="btz312-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>An example reduction from the <sc>Clique</sc> problem to MCT. (<bold>a</bold>) An undirected graph <italic>H</italic> with <inline-formula id="IE97"><mml:math id="IM97"><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> edges and <inline-formula id="IE98"><mml:math id="IM98"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> vertices, containing a clique of size 3. (<bold>b–e</bold>) The <italic>n </italic>=<italic> </italic>4 input trees <inline-formula id="IE99"><mml:math id="IM99"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to the MCT problem obtained from <italic>H</italic>. The problem instance of determining whether <italic>H</italic> contains a clique of size <italic>c </italic>=<italic> </italic>3 reduces to the MCT instance <inline-formula id="IE100"><mml:math id="IM100"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula id="IE101"><mml:math id="IM101"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>c</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. An optimal clustering <italic>σ</italic> for <inline-formula id="IE102"><mml:math id="IM102"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> yields <inline-formula id="IE103"><mml:math id="IM103"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE104"><mml:math id="IM104"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. (<bold>f</bold>) The parent-child graph <inline-formula id="IE105"><mml:math id="IM105"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, with the optimal consensus tree <italic>R</italic><sub>1</sub> for input trees <inline-formula id="IE106"><mml:math id="IM106"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> indicated in red. The parent-child graph of <inline-formula id="IE107"><mml:math id="IM107"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> is identical to <italic>T</italic><sub>4</sub> with edge weights <inline-formula id="IE108"><mml:math id="IM108"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for each edge (<italic>u</italic>, <italic>v</italic>) such that the corresponding optimal consensus tree <italic>R</italic><sub>2</sub> equals <italic>T</italic><sub>4</sub>. As such, the total distance equals <inline-formula id="IE109"><mml:math id="IM109"><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="true">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>c</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo stretchy="true">]</mml:mo><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula>. By Lemma 6, <italic>H</italic> contains a clique of size <italic>c </italic>=<italic> </italic>3</p>
        </caption>
        <graphic xlink:href="btz312f2"/>
      </fig>
      <p>Defining the <italic>cost</italic> as the total distance <inline-formula id="IE110"><mml:math id="IM110"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we have the following two lemmas that provide lower bounds on the cost of any feasible solution <inline-formula id="IE111"><mml:math id="IM111"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE112"><mml:math id="IM112"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> obtained from a <sc>Clique</sc> instance (<italic>H</italic>, <italic>c</italic>).</p>
      <p>
        <statement id="mthst17">
          <label>Lemma 4</label>
          <p>The cost of a clustering <inline-formula id="IE113"><mml:math id="IM113"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that partitions <inline-formula id="IE114"><mml:math id="IM114"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> into parts of sizes <inline-formula id="IE115"><mml:math id="IM115"><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is at least <inline-formula id="IE116"><mml:math id="IM116"><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="true">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:msubsup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:math></inline-formula>. This bound is tight if and only if the input trees <inline-formula id="IE117"><mml:math id="IM117"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> assigned to each cluster <italic>s</italic> encode a clique in the undirected graph <italic>H</italic>.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst18">
          <label>Lemma 5</label>
          <p>The cost of any clustering <inline-formula id="IE118"><mml:math id="IM118"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE119"><mml:math id="IM119"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is at least <inline-formula id="IE120"><mml:math id="IM120"><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="true">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>c</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:math></inline-formula>. This bound is tight if and only if <italic>σ</italic> contains <italic>k</italic> – 1 singleton clusters and one cluster with <italic>c</italic> trees that encode the vertices of a clique in the undirected graph <italic>H</italic>.</p>
          <p>Finally, we use the above two lemmas to prove the following lemma, from which the theorem follows.</p>
        </statement>
      </p>
      <p>
        <statement id="mthst19">
          <label>Lemma 6</label>
          <p>There is a clique of size <italic>c</italic> in the undirected graph <italic>H</italic> if and only if the corresponding MCT instance <inline-formula id="IE121"><mml:math id="IM121"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has an optimal solution with cost <inline-formula id="IE122"><mml:math id="IM122"><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="true">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>c</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        </statement>
      </p>
    </sec>
  </sec>
  <sec>
    <title>4 Material and methods</title>
    <p>This section introduces three algorithms for <sc>Multiple Consensus Tree</sc> that exploit the combinatorial structure identified in the previous section. Section 4.4 describes a procedure for selecting the number <italic>k</italic> of clusters, balancing the decrease in distance and the additional complexity with increasing <italic>k</italic>.</p>
    <sec>
      <title>4.1 Brute force algorithm</title>
      <p>By Proposition 1, each MCT instance <inline-formula id="IE123"><mml:math id="IM123"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> decomposes into <italic>k</italic> SCT instances when given the clustering <italic>σ</italic>. Thus, one can identify optimal solutions <inline-formula id="IE124"><mml:math id="IM124"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE125"><mml:math id="IM125"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> by exhaustively generating all clusterings <italic>σ</italic>, retaining clusterings that have minimum total distance. The number of clusterings is given by the Stirling number of the second kind (<xref rid="btz312-B18" ref-type="bibr">Knuth, 1997</xref>), which is bounded by <italic>k<sup>n</sup></italic>. Given <italic>σ</italic>, we must solve <italic>k</italic> maximum weight spanning arborescence problems on sets <inline-formula id="IE126"><mml:math id="IM126"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of trees. <xref rid="btz312-B10" ref-type="bibr">Gabow <italic>et al.</italic> (1986)</xref> give an algorithm that identifies a maximum (minimum) weight spanning <italic>r</italic>-arborescence rooted at a given vertex <italic>r</italic> of a weighted directed graph <inline-formula id="IE127"><mml:math id="IM127"><mml:mrow><mml:mi>G</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE128"><mml:math id="IM128"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. For simplicity, we bound the number <inline-formula id="IE129"><mml:math id="IM129"><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> of edges in each parent-child graph <inline-formula id="IE130"><mml:math id="IM130"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> by <inline-formula id="IE131"><mml:math id="IM131"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. As such, the complexity of identifying an optimal consensus tree of a set of trees is <inline-formula id="IE132"><mml:math id="IM132"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>m</mml:mi><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. It follows that the time of identifying the optimal set of consensus trees is bounded by <inline-formula id="IE133"><mml:math id="IM133"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> Therefore the complexity of the brute force algorithm is <inline-formula id="IE134"><mml:math id="IM134"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:mo>·</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>4.2 Mixed integer linear program</title>
      <p>We introduce a mixed integer linear program (MILP) that models the feasible solution space of an MCT instance <inline-formula id="IE135"><mml:math id="IM135"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. To do so, we model (i) the surjective clustering function <inline-formula id="IE136"><mml:math id="IM136"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, (ii) the consensus trees <inline-formula id="IE137"><mml:math id="IM137"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> as spanning arborescences, (iii) the weight <inline-formula id="IE138"><mml:math id="IM138"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of each consensus tree <italic>R<sub>s</sub></italic> and (iv) additional cuts to improve performance. Let <italic>m</italic> be the number of vertices in the shared vertex set of input trees <inline-formula id="IE139"><mml:math id="IM139"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>.</p>
      <sec>
        <title>4.2.1 Clustering</title>
        <p>We introduce binary variables <inline-formula id="IE140"><mml:math id="IM140"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>×</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> to model clustering <inline-formula id="IE141"><mml:math id="IM141"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. More specifically, we require <inline-formula id="IE142"><mml:math id="IM142"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE143"><mml:math id="IM143"><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE144"><mml:math id="IM144"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if <inline-formula id="IE145"><mml:math id="IM145"><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> for each cluster <italic>s</italic> and input tree <italic>i</italic>. To that end, we introduce the following constraints.
<disp-formula id="E4"><label>(4)</label><mml:math id="M4"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E5"><label>(5)</label><mml:math id="M5"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>In addition, we require <italic>σ</italic> to be surjective. That is, each cluster <italic>s</italic> contains at least one tree, which we model as follows.
<disp-formula id="E6"><label>(6)</label><mml:math id="M6"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec>
        <title>4.2.2 Consensus trees</title>
        <p>By Proposition 1, the MCT problem decomposes into <italic>k</italic> instances of the SCT problem. By Theorem 1, we know that each SCT instance is a maximum weight spanning arborescence problem with unknown root. Consider the subproblem of a cluster <inline-formula id="IE146"><mml:math id="IM146"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. To model the edges of the consensus tree <italic>R<sub>s</sub></italic>, we introduce variables <inline-formula id="IE147"><mml:math id="IM147"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for each ordered pair <inline-formula id="IE148"><mml:math id="IM148"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of vertices such that <inline-formula id="IE149"><mml:math id="IM149"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if consensus tree <italic>R<sub>s</sub></italic> contains the edge (<italic>p</italic>, <italic>q</italic>) and <inline-formula id="IE150"><mml:math id="IM150"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. We require that <italic>R<sub>s</sub></italic> is a spanning arborescence of the vertex set <inline-formula id="IE151"><mml:math id="IM151"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, i.e. <italic>R<sub>s</sub></italic> contains a single vertex <italic>p</italic> that does not have a parent. To indicate the root vertex, we introduce variables <inline-formula id="IE152"><mml:math id="IM152"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for each vertex <italic>p</italic> such that <inline-formula id="IE153"><mml:math id="IM153"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if <italic>p</italic> is the root of <italic>R<sub>s</sub></italic> and <inline-formula id="IE154"><mml:math id="IM154"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. We have the following constraints that model a single root vertex and the presence of a unique parent of each non-root vertex.
<disp-formula id="E7"><label>(7)</label><mml:math id="M7"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E8"><label>(8)</label><mml:math id="M8"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E9"><label>(9)</label><mml:math id="M9"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E10"><label>(10)</label><mml:math id="M10"><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>For each order pair <inline-formula id="IE155"><mml:math id="IM155"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE156"><mml:math id="IM156"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if there exists an input tree <inline-formula id="IE157"><mml:math id="IM157"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> containing the edge (<italic>p</italic>, <italic>q</italic>) and <inline-formula id="IE158"><mml:math id="IM158"><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. By Corollary 1, we have that each edge (<italic>p</italic>, <italic>q</italic>) of <italic>R<sub>s</sub></italic> must occur in at least one input tree <inline-formula id="IE159"><mml:math id="IM159"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula>. As such, we have the following constraint:
<disp-formula id="E11"><label>(11)</label><mml:math id="M11"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>Next, we need to model connectivity, i.e. from the root vertex <italic>p</italic> of <italic>R<sub>s</sub></italic> every other vertex <inline-formula id="IE160"><mml:math id="IM160"><mml:mrow><mml:mi>q</mml:mi><mml:mo>≠</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> must be reachable. In other words, we need to prevent that <italic>R<sub>s</sub></italic> has cycles. For a subset <inline-formula id="IE161"><mml:math id="IM161"><mml:mrow><mml:mi>U</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> of vertices, let <inline-formula id="IE162"><mml:math id="IM162"><mml:mrow><mml:msup><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the subset of directed edges (<italic>p</italic>, <italic>q</italic>) occurring in the input trees <inline-formula id="IE163"><mml:math id="IM163"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> where <inline-formula id="IE164"><mml:math id="IM164"><mml:mrow><mml:mi>p</mml:mi><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:mi>U</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE165"><mml:math id="IM165"><mml:mrow><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:math></inline-formula>. More formally, <inline-formula id="IE166"><mml:math id="IM166"><mml:mrow><mml:msup><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>|</mml:mo><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>∖</mml:mo><mml:mi>U</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For any cut set <inline-formula id="IE167"><mml:math id="IM167"><mml:mrow><mml:mi>U</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, it must hold that <italic>U</italic> contains either the root vertex or there must be at least one incoming edge to <italic>U</italic>. This is captured by the following constraint.
<disp-formula id="E12"><label>(12)</label><mml:math id="M12"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mo>δ</mml:mo></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>U</mml:mi><mml:mo>⊆</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>The spanning arborescence polytope defined by constraints (7)–(12) has integral vertices (<xref rid="btz312-B27" ref-type="bibr">Schrijver, 2003</xref>). In other words, we do not require variables <bold>y</bold> and <bold>z</bold> to be binary.</p>
      </sec>
      <sec>
        <title>4.2.3 Parent-child distance</title>
        <p>For each ordered pair <inline-formula id="IE168"><mml:math id="IM168"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE169"><mml:math id="IM169"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> if input tree <italic>T<sub>i</sub></italic> contains the edge (<italic>p</italic>, <italic>q</italic>) and <inline-formula id="IE170"><mml:math id="IM170"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> otherwise. To model the distance <inline-formula id="IE171"><mml:math id="IM171"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of input tree <inline-formula id="IE172"><mml:math id="IM172"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> to its corresponding consensus tree <inline-formula id="IE173"><mml:math id="IM173"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we introduce the variable <inline-formula id="IE174"><mml:math id="IM174"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> which indicates that trees <italic>T<sub>i</sub></italic> and <italic>R<sub>s</sub></italic> contain the edge (<italic>p</italic>, <italic>q</italic>) and <italic>T<sub>i</sub></italic> is assigned to cluster <italic>s</italic>. In other words, <inline-formula id="IE175"><mml:math id="IM175"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the product of <inline-formula id="IE176"><mml:math id="IM176"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE177"><mml:math id="IM177"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. We thus have
<disp-formula id="E13"><label>(13)</label><mml:math id="M13"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>Using Corollary 3, we obtain the following objective function.
<disp-formula id="E14"><label>(14)</label><mml:math id="M14"><mml:mrow><mml:mi>min</mml:mi><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>k</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>q</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>We model <inline-formula id="IE178"><mml:math id="IM178"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>·</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> using the following constraints, which force <inline-formula id="IE179"><mml:math id="IM179"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to 0 if one of <inline-formula id="IE180"><mml:math id="IM180"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is 0.
<disp-formula id="E15"><label>(15)</label><mml:math id="M15"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E16"><label>(16)</label><mml:math id="M16"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E17"><label>(17)</label><mml:math id="M17"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E18"><label>(18)</label><mml:math id="M18"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>By integrality of <bold>x</bold> and <bold>y</bold>, we do not require <bold>w</bold> to be binary variables. Moreover, by the direction of the objective function, we do not need to force <inline-formula id="IE181"><mml:math id="IM181"><mml:mrow><mml:msub><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> to 1 if <inline-formula id="IE182"><mml:math id="IM182"><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      </sec>
      <sec>
        <title>4.2.4 Additional cuts</title>
        <p>To improve performance of the ILP, we use Corollary 1 to require that <italic>R<sub>s</sub></italic> contains the edge (<italic>p</italic>, <italic>q</italic>) only if there exists a tree <inline-formula id="IE183"><mml:math id="IM183"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> containing the edge (<italic>p</italic>, <italic>q</italic>). To that end, we introduce the following constraint.
<disp-formula id="E19"><label>(19)</label><mml:math id="M19"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>By Corollary 2, if all input trees <inline-formula id="IE184"><mml:math id="IM184"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> contain the edge (<italic>p</italic>, <italic>q</italic>) then there exists an optimal solution in which consensus tree <italic>R<sub>s</sub></italic> contains (<italic>p</italic>, <italic>q</italic>) as well. This is captured by the following constraint.
<disp-formula id="E20"><label>(20)</label><mml:math id="M20"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
        <p>Finally, we introduce the following symmetry breaking constraints that impose an ordering on <italic>σ</italic> such that <inline-formula id="IE185"><mml:math id="IM185"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>≥</mml:mo><mml:mo>…</mml:mo><mml:mo>≥</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>.
<disp-formula id="E21"><label>(21)</label><mml:math id="M21"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p>
      </sec>
      <sec>
        <title>4.2.5 Cut separation</title>
        <p>The number of constraints (12) grows exponentially in <italic>m</italic>. Therefore, we do not include these constraints in our formulation. Following a standard approach (<xref rid="btz312-B33" ref-type="bibr">Wolsey, 1998</xref>), we separate these constraints during the branch-and-bound procedure by identifying a minimum cut in a directed graph. Excluding constraints (12), our formulation has <inline-formula id="IE186"><mml:math id="IM186"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">nk</mml:mi><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> variables and constraints. <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S1</xref> contains the full MILP.</p>
        <p>
          <boxed-text id="btz312-BOX1" position="float" orientation="portrait">
            <label>Algorithm 1:</label>
            <caption>
              <p><sc>CoordinateAscent</sc>(<inline-formula id="IE187"><mml:math id="IM187"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>, <italic>k</italic>)</p>
            </caption>
            <p><bold>Input</bold>: Trees <inline-formula id="IE188"><mml:math id="IM188"><mml:mrow><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and number <italic>k </italic>&gt;<italic> </italic>0 of clusters</p>
            <p><bold>Output</bold>: Consensus trees <inline-formula id="IE189"><mml:math id="IM189"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and clustering <italic>σ</italic> 1 <inline-formula id="IE190"><mml:math id="IM190"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> random clustering</p>
            <p>2 <inline-formula id="E22"><mml:math id="IM191"><mml:mrow><mml:mi>L</mml:mi><mml:mo>,</mml:mo><mml:mo>Δ</mml:mo><mml:mo>←</mml:mo><mml:mo>∞</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>3 <bold>while</bold><italic>Δ &gt; 0</italic><bold>do</bold></p>
            <p>4 <bold>for</bold><inline-formula id="IE191"><mml:math id="IM192"><mml:mrow><mml:mi>s</mml:mi><mml:mo>←</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula><bold><italic>to</italic></bold><italic>k</italic><bold>do</bold></p>
            <p>5 <bold>   </bold>Let <inline-formula id="IE192"><mml:math id="IM193"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> be the parent-child graph of input trees <inline-formula id="IE193"><mml:math id="IM194"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with edge weights <inline-formula id="IE194"><mml:math id="IM195"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>:</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></inline-formula></p>
            <p>6 <bold>   </bold>Compute max weight spanning arborescence <italic>R<sub>s</sub></italic> of <inline-formula id="IE195"><mml:math id="IM196"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>7 <bold> for</bold><inline-formula id="IE196"><mml:math id="IM197"><mml:mrow><mml:mi>i</mml:mi><mml:mo>←</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula><bold><italic>to</italic></bold><italic>n</italic><bold>do</bold></p>
            <p>8 <bold>   </bold>σ(<italic>i</italic>)←argmin<sub><italic>s</italic></sub><sub>ϵ[</sub><sub><italic>k</italic></sub><sub>]</sub><italic>d</italic>(<italic>T<sub>i</sub></italic>,<italic>R<sub>s</sub></italic>)</p>
            <p>9  <inline-formula id="E23"><mml:math id="IM198"><mml:mi>L</mml:mi><mml:mo>′</mml:mo><mml:mo>←</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula></p>
            <p>10  <inline-formula id="E123"><mml:math id="IM199"><mml:mo>Δ</mml:mo><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mo>′</mml:mo><mml:mo>−</mml:mo><mml:mi>L</mml:mi></mml:math></inline-formula></p>
            <p>11  <inline-formula id="E223"><mml:math id="IM200"><mml:mi>L</mml:mi><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mo>′</mml:mo></mml:math></inline-formula></p>
            <p>12  <bold>return</bold><italic>(</italic><inline-formula id="IE197"><mml:math id="IM201"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula>, <italic>σ)</italic></p>
          </boxed-text>
        </p>
      </sec>
    </sec>
    <sec>
      <title>4.3 Coordinate ascent heuristic</title>
      <p>We use coordinate ascent to solve the <sc>Multiple Consensus Tree</sc> heuristically. The idea is to identify consensus trees and clusterings alternatingly, starting from a random clustering <italic>σ</italic>. Then, for each cluster <inline-formula id="IE198"><mml:math id="IM202"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, we construct the parent-child graph <inline-formula id="IE199"><mml:math id="IM203"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> from the set <inline-formula id="IE200"><mml:math id="IM204"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of input trees in cluster <italic>s</italic>. From <inline-formula id="IE201"><mml:math id="IM205"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, we obtain the consensus tree <italic>R<sub>s</sub></italic> by computing the maximum weight spanning arborescence of the graph. Finally, we update the clustering <italic>σ</italic> by reassigning each <inline-formula id="IE202"><mml:math id="IM206"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> to a cluster <inline-formula id="IE203"><mml:math id="IM207"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE204"><mml:math id="IM208"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is minimized. These steps are repeated until convergence is achieved (Algorithm 1). To avoid getting stuck in local optima, we allow the user to specify the number of restarts, initializing each restart with a new randomly-generated clustering. Alternatively, we allow the user to specify a time limit, restarting the algorithm until the running time exceeds the time limit.</p>
    </sec>
    <sec>
      <title>4.4 Model selection for the number <italic>k</italic> of clusters</title>
      <p>Given input trees <inline-formula id="IE205"><mml:math id="IM209"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> with <italic>m</italic> vertices, the number <italic>k</italic> of clusters ranges from 1 to <italic>n</italic>. To decide which number <italic>k</italic> of clusters to use, we apply the Bayesian Information Criterion (BIC). Note that this criterion requires a likelihood of the data given the model. In our case, the model corresponds to a solution <inline-formula id="IE206"><mml:math id="IM210"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to MCT instance <inline-formula id="IE207"><mml:math id="IM211"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. We need to define a likelihood function that is proportional to the probability <inline-formula id="IE208"><mml:math id="IM212"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of generating the data <inline-formula id="IE209"><mml:math id="IM213"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> given solution <inline-formula id="IE210"><mml:math id="IM214"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. To do so, we define the <italic>normalized distance</italic><inline-formula id="IE211"><mml:math id="IM215"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> between two trees <italic>T</italic> and <inline-formula id="IE212"><mml:math id="IM216"><mml:mrow><mml:mi>T</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E24"><label>(22)</label><mml:math id="M22"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Therefore, the <italic>mean normalized distance</italic><inline-formula id="IE213"><mml:math id="IM217"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of a set <inline-formula id="IE214"><mml:math id="IM218"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of <italic>n</italic> trees and a solution <inline-formula id="IE215"><mml:math id="IM219"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> equals
<disp-formula id="E25"><label>(23)</label><mml:math id="M23"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We assume that the probability <inline-formula id="IE216"><mml:math id="IM220"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of generating a tree <italic>T</italic> in <inline-formula id="IE217"><mml:math id="IM221"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by a model <inline-formula id="IE218"><mml:math id="IM222"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is proportional to the <italic>mean normalized similarity</italic><inline-formula id="IE219"><mml:math id="IM223"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> defined as
<disp-formula id="E26"><label>(24)</label><mml:math id="M24"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Note that as <italic>k</italic> increases, the sum of the distances of the optimal solutions to a set <inline-formula id="IE220"><mml:math id="IM224"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of trees is strictly decreasing by Proposition 2. Therefore, as <italic>k</italic> increases, the likelihood <inline-formula id="IE221"><mml:math id="IM225"><mml:mrow><mml:mi>h</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of optimal solutions <inline-formula id="IE222"><mml:math id="IM226"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is increasing. Assuming independence in generating each input tree, the probability <inline-formula id="IE223"><mml:math id="IM227"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the model generating a set <inline-formula id="IE224"><mml:math id="IM228"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of <italic>n</italic> trees is <inline-formula id="IE225"><mml:math id="IM229"><mml:mrow><mml:mi>Pr</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo>|</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>, which is proportional to <inline-formula id="IE226"><mml:math id="IM230"><mml:mrow><mml:mi>h</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
      <p>However, as <italic>k</italic> increases, the complexity of the model, i.e. the number of parameters in solution <inline-formula id="IE227"><mml:math id="IM231"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is also increasing. Using Proposition 1, optimal consensus trees <inline-formula id="IE228"><mml:math id="IM232"><mml:mi mathvariant="script">R</mml:mi></mml:math></inline-formula> are determined by the clustering <italic>σ</italic>. The clustering <italic>σ</italic> contains <italic>k</italic> clusters, amounting to the following Bayesian Information Criterion (BIC).
<disp-formula id="E27"><label>(25)</label><mml:math id="M25"><mml:mrow><mml:mfrac><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mi>ln</mml:mi><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo> </mml:mo><mml:mi>ln</mml:mi><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>h</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E28"><label>(26)</label><mml:math id="M26"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mo> </mml:mo><mml:mi>ln</mml:mi><mml:mo> </mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo> </mml:mo><mml:mi>ln</mml:mi><mml:mo> </mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mo>σ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>The factor of 1/2 ensures that the two terms are of similar scale. The task is now to choose <italic>k</italic> such that the above equation is minimized.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Results</title>
    <p>We implemented the three algorithms (BF, MILP and CA) in C++ using the LEMON graph library (<ext-link ext-link-type="uri" xlink:href="http://lemon.cs.elte.hu">http://lemon.cs.elte.hu</ext-link>). We implemented MILP using CPLEX v12.8 (<ext-link ext-link-type="uri" xlink:href="https://www.ibm.com/analytics/cplex-optimizer">https://www.ibm.com/analytics/cplex-optimizer</ext-link>). In this section, we illustrate the application of our methods to simulated and real data. Specifically, Section 5.1 provides results of our algorithms on simulated data, whereas Section 5.2 applies our methods to recent lung cancer data (<xref rid="btz312-B14" ref-type="bibr">Jamal-Hanjani <italic>et al.</italic>, 2017</xref>).</p>
    <sec>
      <title>5.1 Simulations</title>
      <p>To evaluate our methods, we simulate bulk DNA sequencing data of tumors using a previously published tumor simulator (<xref rid="btz312-B9" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2018</xref>). We generate a total of 45 instances, composed of either five or ten bulk samples per instance and <inline-formula id="IE229"><mml:math id="IM233"><mml:mrow><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>9</mml:mn><mml:mo>,</mml:mo><mml:mn>11</mml:mn><mml:mo>,</mml:mo><mml:mn>13</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> mutation clusters (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>). Subsequently, we run the SPRUCE algorithm (<xref rid="btz312-B7" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2015</xref>) to enumerate the set <inline-formula id="IE230"><mml:math id="IM234"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> of mutation trees for each instance. The mean number of trees is 47 (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S1</xref>). We group the 45 simulated instances by the number of mutation trees into three classes, resulting in 16 ‘small’ instances with 6-10 trees, 15 ‘medium’ instances with 11–39 trees and 14 ‘large’ instances with 40-352 trees (<xref ref-type="fig" rid="btz312-F3">Fig. 3a</xref>).
</p>
      <fig id="btz312-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Coordinate ascent (CA) algorithm computes consensus trees with similar mean distance as the MILP algorithm in only a fraction of the time. (<bold>a</bold>) Number of trees for each class of simulated instances. (<bold>b</bold>) Mean normalized distance for solutions for each method. (<bold>c</bold>) Running time in seconds for each method (logarithmic scale)</p>
        </caption>
        <graphic xlink:href="btz312f3"/>
      </fig>
      <p>For each class of instances (small, medium or large) and number <inline-formula id="IE231"><mml:math id="IM235"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>5</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of clusters, we run the mixed integer linear program (MILP) and the brute force algorithm (BF) restricted to a running time of 1 h. In addition, we run the coordinate ascent (CA) algorithm in two modes: (i) using a time limit of 1 h, and (ii) restricted to 100 restarts. We run each algorithm in single-threaded mode on a computer with two Intel Xeon CPUs at 2.6 GHz (32 cores) and 512 GB of RAM.</p>
      <p><xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref> shows the number of instances solved to optimality by MILP and BF. We find that MILP outperforms the BF algorithm, solving 65% of instances to optimality versus 45.6% for BF. All small instances were solved to optimality by MILP, whereas BF failed to solved two small instances with <italic>k </italic>=<italic> </italic>5 clusters within the time limit. In particular, performance of BF decreases with increasing number <italic>k</italic> of clusters and number <italic>n</italic> of input trees, reflecting the exponential increase in the number <italic>k<sup>n</sup></italic> of enumerated clusterings with increasing number <italic>n</italic> of trees. Similarly, MILP performance decreases with increasing <italic>n</italic> and <italic>k</italic> (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S1</xref>). The instances that were solved to optimality by MILP include all instances solved to optimality by BF. For these reasons, we exclude BF from further analyses and focus on MILP and CA.</p>
      <p>To investigate the behavior of CA versus the MILP algorithm, we compute the mean normalized distance <inline-formula id="IE232"><mml:math id="IM236"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each simulated instance <inline-formula id="IE233"><mml:math id="IM237"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and output <inline-formula id="IE234"><mml:math id="IM238"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. This distance is defined in Section 4.4. We find that CA using only 100 restarts identifies solutions with similar mean normalized distance as CA and MILP using a time limit of 1 h (<xref ref-type="fig" rid="btz312-F3">Fig. 3b</xref>). These 100 restarts were completed in seconds (<xref ref-type="fig" rid="btz312-F3">Fig. 3c</xref>). Thus, CA with a small number of restarts computes high-quality consensus trees at only a fraction of the time required by MILP. Moreover, the CA algorithm with 100 restarts recovers all optimal solutions computed by MILP (<xref ref-type="supplementary-material" rid="sup1">Supplementary Table S2</xref>).</p>
      <p>Finally, we consider one simulated instance to illustrate the advantages of the <sc>Multiple Consensus Tree</sc> over previous approaches, and to illustrate the model selection step for choosing the number <italic>k</italic> of clusters. The instance we consider has <italic>n </italic>=<italic> </italic>9 trees and <italic>m </italic>=<italic> </italic>9 mutation clusters (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S2</xref>). Thus, the maximum number <italic>k</italic> of clusters equals <italic>n </italic>=<italic> </italic>9. We use CA with 100 restarts to compute consensus trees <inline-formula id="IE235"><mml:math id="IM239"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and clusterings <inline-formula id="IE236"><mml:math id="IM240"><mml:mrow><mml:mo>σ</mml:mo><mml:mo>:</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>→</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for each number <inline-formula id="IE237"><mml:math id="IM241"><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>9</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of clusters. In line with Proposition 2, <xref ref-type="fig" rid="btz312-F4">Figure 4a</xref> shows that the mean normalized distance <inline-formula id="IE238"><mml:math id="IM242"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> decreases with increasing number <italic>k</italic> of clusters. In particular, <inline-formula id="IE239"><mml:math id="IM243"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> for <italic>k </italic>=<italic> </italic>9 clusters, each containing a single input tree.
</p>
      <fig id="btz312-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Adequate representation of the solution space <inline-formula id="IE240"><mml:math id="IM244"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> requires <italic>k </italic>=<italic> </italic>2 consensus trees. This simulated instance contains <inline-formula id="IE241"><mml:math id="IM245"><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:math></inline-formula> input trees. (<bold>a</bold>) Top plot shows the mean normalized distance inferred by the coordinate ascent algorithm as a function of the number <italic>k</italic> of clusters. Bottom plot shows the number of trees per cluster. Using the BIC criterion, we summarize <inline-formula id="IE242"><mml:math id="IM246"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> with <italic>k</italic> = 2 clusters. (<bold>b</bold>) Parent-child graphs <inline-formula id="IE243"><mml:math id="IM247"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and consensus trees <italic>R</italic><sub>1</sub>, <italic>R</italic><sub>2</sub> (colored edges) of computed clustering. (<bold>c</bold>) Parent-child graph <inline-formula id="IE244"><mml:math id="IM248"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (bottom) and corresponding consensus tree <italic>R</italic> (top) do not adequately represent the topological features in input trees <inline-formula id="IE245"><mml:math id="IM249"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. That is, edge (<italic>b</italic>, <italic>e</italic>) does not co-occur with edges (<italic>b</italic>, <italic>d</italic>) or (<italic>b</italic>, <italic>g</italic>) in <inline-formula id="IE246"><mml:math id="IM250"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>, which cannot be concluded from <inline-formula id="IE247"><mml:math id="IM251"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Moreover, consensus tree <italic>R</italic> does not contain the edge (<italic>b</italic>, <italic>e</italic>), which occurs in 4 out of 9 input trees. Hence, <italic>R</italic> is an incomplete summary of <inline-formula id="IE248"><mml:math id="IM252"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula></p>
        </caption>
        <graphic xlink:href="btz312f4"/>
      </fig>
      <p>Applying the Bayesian Information Criterion (BIC), we select the solution with <italic>k </italic>=<italic> </italic>2 clusters (<xref ref-type="fig" rid="btz312-F4">Fig. 4a</xref>). The two resulting consensus trees <italic>R</italic><sub>1</sub> and <italic>R</italic><sub>2</sub> contain <inline-formula id="IE249"><mml:math id="IM253"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE250"><mml:math id="IM254"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> input trees, respectively (<xref ref-type="fig" rid="btz312-F4">Fig. 4a</xref>). <xref ref-type="fig" rid="btz312-F4">Figure 4b and c</xref> show the parent-child graphs <inline-formula id="IE251"><mml:math id="IM255"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE252"><mml:math id="IM256"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, with colored edges indicating the two corresponding consensus trees. In these figures, we see that the two consensus trees <italic>R</italic><sub>1</sub> and <italic>R</italic><sub>2</sub> differ in vertices <italic>d</italic>, <italic>e</italic> and <italic>g</italic>. Input trees <inline-formula id="IE253"><mml:math id="IM257"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> include the edge (<italic>b</italic>, <italic>e</italic>) whereas input trees <inline-formula id="IE254"><mml:math id="IM258"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> include the edge (<italic>a</italic>, <italic>e</italic>). In addition, trees in <inline-formula id="IE255"><mml:math id="IM259"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> include a branch composed of edges (<italic>e</italic>, <italic>g</italic>) and (<italic>g</italic>, <italic>d</italic>), whereas trees <inline-formula id="IE256"><mml:math id="IM260"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> contain <italic>d</italic> and <italic>g</italic> as siblings of parent <italic>b</italic>. Importantly, these topological features are not apparent when summarizing <inline-formula id="IE257"><mml:math id="IM261"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by the parent-child graph <inline-formula id="IE258"><mml:math id="IM262"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> or by constructing a single consensus tree from <inline-formula id="IE259"><mml:math id="IM263"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. That is, the parent-child graph <inline-formula id="IE260"><mml:math id="IM264"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> does not show patterns of co-occurrence and mutual exclusivity among edges. For instance, edge (<italic>b</italic>, <italic>e</italic>) does not co-occur with edges (<italic>b</italic>, <italic>d</italic>) or (<italic>b</italic>, <italic>g</italic>) in <inline-formula id="IE261"><mml:math id="IM265"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>, which cannot be concluded from <inline-formula id="IE262"><mml:math id="IM266"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (<xref ref-type="fig" rid="btz312-F4">Fig. 4c</xref>). Furthermore, the unique optimal consensus tree <italic>R</italic> obtained from <inline-formula id="IE263"><mml:math id="IM267"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> does not contain the edge (<italic>b</italic>, <italic>e</italic>) (<xref ref-type="fig" rid="btz312-F4">Fig. 4c</xref>), which occurs in 4 out of 9 input trees (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S2</xref>). Hence, <italic>R</italic> is an incomplete summary of <inline-formula id="IE264"><mml:math id="IM268"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>. Only by summarizing <inline-formula id="IE265"><mml:math id="IM269"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> using multiple consensus trees do these topological features become apparent. <xref ref-type="supplementary-material" rid="sup1">Supplementary Figure S3</xref> shows the distribution of the identified number <italic>k</italic> of clusters for each class of instances, showing that the number <italic>k</italic> of clusters selected by BIC increases with the number <italic>n</italic> of trees.</p>
    </sec>
    <sec>
      <title>5.2 Real data</title>
      <p>We consider a lung cancer cohort of 100 patients (<xref rid="btz312-B14" ref-type="bibr">Jamal-Hanjani <italic>et al.</italic>, 2017</xref>), composed of tumors that have undergone multi-region bulk DNA sequencing. <xref rid="btz312-B14" ref-type="bibr">Jamal-Hanjani <italic>et al.</italic> (2017)</xref> used PyClone (<xref rid="btz312-B26" ref-type="bibr">Roth <italic>et al.</italic>, 2014</xref>) to cluster mutations with similar cancer cell fractions and ran CITUP (<xref rid="btz312-B20" ref-type="bibr">Malikic <italic>et al.</italic>, 2015</xref>) to compute solution spaces <inline-formula id="IE266"><mml:math id="IM270"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> for each tumor, identifying multiple trees for 25 patients. We focus our analysis on patients CRUK0013 and CRUK0037, the only two patients with more than four reported trees. <xref rid="btz312-B14" ref-type="bibr">Jamal-Hanjani <italic>et al.</italic> (2017)</xref> identified 8 trees for patient CRUK0013 (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S4</xref>) and 17 trees for patient CRUK0037 (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S5</xref>). To summarize these trees, we run CA coupled with the model selection procedure for the number <italic>k</italic> of clusters.</p>
      <p>First, we consider patient CRUK0013, which has <italic>m </italic>=<italic> </italic>9 vertices/mutation clusters. <xref ref-type="fig" rid="btz312-F5">Figure 5a</xref> shows the relationship between the number <italic>k</italic> of clusters and the mean normalized distance <inline-formula id="IE267"><mml:math id="IM271"><mml:mrow><mml:mover accent="true"><mml:mi>d</mml:mi><mml:mo>¯</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script">T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo>,</mml:mo><mml:mo>σ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> computed by the CA method. The decrease in distance from <italic>k </italic>=<italic> </italic>1 to <italic>k </italic>=<italic> </italic>2 is modest. Consequently, the BIC prefers the <italic>k </italic>=<italic> </italic>1 solution. Inspection of the parent-child graph <inline-formula id="IE268"><mml:math id="IM272"><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and consensus tree <italic>R</italic> reveals that the consensus tree <italic>R</italic> covers 55 out 64 edges in <inline-formula id="IE269"><mml:math id="IM273"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>, where the 9 uncovered edges are incoming to <italic>v</italic><sub>8</sub> and <italic>v</italic><sub>9</sub>. In particular, there are no patterns of co-occurrence or mutual exclusivity among the edges leading to <italic>v</italic><sub>8</sub> and <italic>v</italic><sub>9</sub> in individual trees in <inline-formula id="IE270"><mml:math id="IM274"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> (<xref ref-type="fig" rid="btz312-F5">Fig. 5c</xref>), justifying the choice for <italic>k </italic>=<italic> </italic>1 cluster. This example, in addition to our simulated data results (<xref ref-type="supplementary-material" rid="sup1">Supplementary Fig. S3</xref>), show that our method does not overfit the input data when there are no clear topological features in the solution space.
</p>
      <fig id="btz312-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>Lung cancer patient CRUK0013 with <italic>n </italic>=<italic> </italic>8 trees is accurately summarized by a single consensus tree. (<bold>a</bold>) The mean normalized distance inferred by the coordinate ascent algorithm as a function of the number <italic>k</italic> of clusters, and the BIC. (<bold>b</bold>) The parent-child graph and consensus tree. (<bold>c</bold>) The number of input trees supporting each possible combination of topological features</p>
        </caption>
        <graphic xlink:href="btz312f5"/>
      </fig>
      <p>By contrast, for patient CRUK0037, with <italic>m </italic>=<italic> </italic>10 vertices (mutations clusters) and <italic>n </italic>=<italic> </italic>17 trees, our method infers <italic>k </italic>=<italic> </italic>2 clusters (<xref ref-type="fig" rid="btz312-F6">Fig. 6a</xref>). Inspection of the <italic>n </italic>=<italic> </italic>17 input trees reveals that there is variation in the placement of five vertices, as shown by the parent-child graph (<xref ref-type="fig" rid="btz312-F6">Fig. 6b</xref>). We focus our attention on vertices <italic>v</italic><sub>5</sub>, <italic>v</italic><sub>7</sub> and <italic>v</italic><sub>10</sub>, each with two possible parents. <xref ref-type="fig" rid="btz312-F6">Figure 6c</xref> shows the contingency table of all combinations of these three clusters, enabling us to observe that <inline-formula id="IE271"><mml:math id="IM275"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>7</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE272"><mml:math id="IM276"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are mutually exclusive. This pattern of mutual exclusivity is not apparent in the parent-child graph obtained from all trees (<xref ref-type="fig" rid="btz312-F6">Fig. 6b</xref>). Furthermore, the placement of the three mutation clusters in the <italic>k </italic>=<italic> </italic>1 consensus tree obtained from this graph is supported by only 2 out of 17 input trees. Thus, with <italic>k </italic>=<italic> </italic>1, neither the parent-child graph nor the consensus tree provide an adequate summary of the solution space of this patient.
</p>
      <fig id="btz312-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>Lung cancer patient CRUK0037 with <italic>n </italic>=<italic> </italic>17 trees is accurately summarized by <italic>k </italic>=<italic> </italic>2 consensus trees. (<bold>a</bold>) The mean normalized distance inferred by the coordinate ascent algorithm as a function of the number <italic>k</italic> of clusters, and the BIC. (<bold>b</bold>) The parent-graph and the consensus tree for <italic>k </italic>=<italic> </italic>1. (<bold>c</bold>) The number of input trees supporting each possible combination of topological features. (<bold>d, e</bold>) The two parent-child graphs and consensus trees for <italic>k </italic>=<italic> </italic>2. (<bold>f, g</bold>) The number of input trees in each cluster supporting each possible combination of topological features.</p>
        </caption>
        <graphic xlink:href="btz312f6"/>
      </fig>
      <p>Our method partitions the input trees into <italic>k </italic>=<italic> </italic>2 clusters: one cluster with seven input trees (<xref ref-type="fig" rid="btz312-F6">Fig. 6d</xref>) and the other cluster with the remaining ten trees (<xref ref-type="fig" rid="btz312-F6">Fig. 6e</xref>). This partition identifies patterns of co-occurrence and mutual exclusivity that are unique to each cluster. All seven trees in the first cluster contain the edge <inline-formula id="IE273"><mml:math id="IM277"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, whereas the remaining ten trees in the second cluster contain the edge <inline-formula id="IE274"><mml:math id="IM278"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>7</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. On the other hand, the trees in the first cluster exhibit mutual exclusivity between <inline-formula id="IE275"><mml:math id="IM279"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE276"><mml:math id="IM280"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>7</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>, whereas these two edges are present in 7/10 trees in the second cluster. Similarly, edges <inline-formula id="IE277"><mml:math id="IM281"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE278"><mml:math id="IM282"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>8</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>5</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> are mutually exclusivity in all ten trees in the second cluster, whereas these two edges are present in 5/7 trees in the first cluster. Thus, our method partitions the solution space of 17 trees into two clusters with distinct topological features. In addition, our method infers a consensus tree for each of the two clusters. The placement of <italic>v</italic><sub>5</sub>, <italic>v</italic><sub>7</sub> and <italic>v</italic><sub>10</sub> in the consensus tree of the first cluster is supported by 3/7 trees assigned to this cluster, being the dominant topological feature among these seven trees (<xref ref-type="fig" rid="btz312-F6">Fig. 6f</xref>). Similarly, the consensus tree of the second cluster highlights the most representative placement of these three vertices (supported by 5/10 trees, see <xref ref-type="fig" rid="btz312-F6">Fig. 6g</xref>).</p>
      <p>The first consensus tree contains the branch <inline-formula id="IE279"><mml:math id="IM283"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, whereas the second consensus tree contains the branch <inline-formula id="IE280"><mml:math id="IM284"><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>4</mml:mn></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. Vertex <italic>v</italic><sub>10</sub> contains the driver mutation HOOK3, whose placement may alter conclusions in downstream analyses, including those that assess tumor fitness to immunotherapy (<xref rid="btz312-B19" ref-type="bibr">Łuksza <italic>et al.</italic>, 2017</xref>) or identify repeated evolutionary trajectories among driver mutations (<xref rid="btz312-B31" ref-type="bibr">Turajlic <italic>et al.</italic>, 2018b</xref>). To avoid incorrect conclusions both consensus trees must be considered in these analyses. Our method facilitates such more robust downstream analyses, by simultaneously clustering input trees according to shared topological features, identifying the right number of clusters depending on the degree of differences among solution trees.</p>
    </sec>
  </sec>
  <sec>
    <title>6 Discussion</title>
    <p>We introduced the <sc>Multiple Consensus Tree</sc> (MCT) problem that enables one to accurately summarize a solution set <inline-formula id="IE281"><mml:math id="IM285"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> composed of tumor phylogenies with distinct topological features using multiple consensus trees, overcoming limitations of current approaches. Current approaches that summarize <inline-formula id="IE282"><mml:math id="IM286"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by constructing a graph that is the union of all edges in <inline-formula id="IE283"><mml:math id="IM287"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> fail to account for mutual exclusivity or co-occurence of edges in individual trees (<xref rid="btz312-B3" ref-type="bibr">Deshwar <italic>et al.</italic>, 2015</xref>; <xref rid="btz312-B8" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2016</xref>; <xref rid="btz312-B16" ref-type="bibr">Jiao <italic>et al.</italic>, 2014</xref>). In a similar vein, summarizing <inline-formula id="IE284"><mml:math id="IM288"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> by constructing a single consensus tree as described by <xref rid="btz312-B12" ref-type="bibr">Govek <italic>et al.</italic> (2018)</xref> may fail to represent topological features that are specific to a subset of trees in <inline-formula id="IE285"><mml:math id="IM289"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula>.</p>
    <p>Mathematically, MCT is a generalization of the <sc>Single Consensus Tree</sc> to <italic>k</italic> consensus trees. That is, given input trees <inline-formula id="IE286"><mml:math id="IM290"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and integer <italic>k </italic>&gt;<italic> </italic>0, we aim to simultaneously partition <inline-formula id="IE287"><mml:math id="IM291"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> into <italic>k</italic> disjoint, non-empty clusters and reconstruct a consensus tree for each cluster with minimum total distance. We proved that MCT is NP-hard. In addition, we presented two exact approaches based on mixed integer linear programming (MILP) and exhaustive enumeration. Using simulated data, we showed that the MILP efficiently solves small instances to optimality. In addition, we introduced a heuristic based on coordinate ascent that scales to large input instances. By benchmarking our methods on simulated data, we showed that the heuristic approach recovered all optimal solutions identified by the MILP at only a fraction of the time. We demonstrated the applicability of the MCT problem on lung cancer data, illustrating that our model selection step selects the right number <italic>k</italic> of clusters depending on the degree of differences among solution trees.</p>
    <p>There are a couple of avenues for future research. First, we used the parent-child distance in this manuscript. One could consider alternative distance functions, such as the tree distance function recently introduced by <xref rid="btz312-B17" ref-type="bibr">Karpov <italic>et al.</italic> (2018)</xref>. Second, the complexity of the MCT given fixed number <italic>k</italic> of clusters remains open. As we have seen in our analysis of real and simulated data, it is often the case that <inline-formula id="IE288"><mml:math id="IM292"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≪</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. Thus, an algorithm that is fixed parameter tractable in <italic>k</italic> would have immediate practical applications. Third, there may be multiple optimal solutions to MCT. More specifically, for a fixed clustering there might be multiple optimal consensus trees, and there might be multiple clusterings with the same total distance. Similarly to the original problem, it will be an interesting direction to identify common patterns and differences among such optimal solutions. Fourth, the mutation trees <inline-formula id="IE289"><mml:math id="IM293"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> considered in this manuscript adhere to the infinite sites assumption. Recent works in cancer phylogenetics have considered other evolutionary models, such as the infinite alleles model (<xref rid="btz312-B8" ref-type="bibr">El-Kebir <italic>et al.</italic>, 2016</xref>), the Dollo parsimony model (<xref rid="btz312-B1" ref-type="bibr">Bonizzoni <italic>et al.</italic>, 2017</xref>; <xref rid="btz312-B6" ref-type="bibr">El-Kebir, 2018</xref>) or the finite sites model (<xref rid="btz312-B35" ref-type="bibr">Zafar <italic>et al.</italic>, 2017</xref>). It will be an interesting question to adapt the methodology and problem to trees that employ these alternative models of evolution. Finally, a characterization of the distribution of trees in the solution space <inline-formula id="IE290"><mml:math id="IM294"><mml:mi mathvariant="script">T</mml:mi></mml:math></inline-formula> and their topological features under an error model of single-cell or bulk DNA sequencing has not been attempted yet. Akin to the work by <xref rid="btz312-B28" ref-type="bibr">Steel and Penny (1993)</xref> in classic phylogenetics, such work would provide much needed theoretical guidance on the larger issue of non-uniqueness of solutions in cancer phylogenetics.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by UIUC Center for Computational Biotechnology and Genomic Medicine (grant: CSN 1624790) and the National Science Foundation (grant: 1850502).</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz312_Supplementary_Data</label>
      <media xlink:href="btz312_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz312-B1">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Bonizzoni</surname><given-names>P.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) Beyond perfect phylogeny: multisample phylogeny reconstruction via ilp. In <italic>Proceedings of the 8<sup>th</sup> ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics</italic>, ACM-BCB ’17. ACM, New York, NY, USA, pp. 1–10.</mixed-citation>
    </ref>
    <ref id="btz312-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dang</surname><given-names>H.X.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) ClonEvol: clonal ordering and visualization in cancer sequencing. <italic>Ann. Oncol.</italic>, <volume>28</volume>, <fpage>3076</fpage>–<lpage>3082</lpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Deshwar</surname><given-names>A.G.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>PhyloWGS: reconstructing subclonal composition and evolution from whole-genome sequencing of tumors</article-title>. <source>Genome Biol</source>., <volume>16</volume>, <fpage>35.</fpage><pub-id pub-id-type="pmid">25786235</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Desper</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>1999</year>) 
<article-title>Inferring tree models for oncogenesis from comparative genome hybridization data</article-title>. <source>JCB</source>, <volume>6</volume>, <fpage>37</fpage>–<lpage>51</lpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Donmez</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) <chapter-title>Clonality inference from single tumor samples using low coverage sequence data</chapter-title> In: Singh,M. (Ed.), <source>Research in Computational Molecular Biology</source>, Vol. 9649. 
<publisher-name>Springer International Publishing</publisher-name>, Cham, pp. <fpage>83</fpage>–<lpage>94</lpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>El-Kebir</surname><given-names>M.</given-names></name></person-group> (<year>2018</year>) 
<article-title>SPhyR: tumor phylogeny estimation from single-cell sequencing data under loss and error</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i671</fpage>–<lpage>i679</lpage>.<pub-id pub-id-type="pmid">30423070</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>El-Kebir</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Reconstruction of clonal trees and tumor composition from multi-sample sequencing data</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>i62</fpage>–<lpage>i70</lpage>.<pub-id pub-id-type="pmid">26072510</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>El-Kebir</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Inferring the mutational history of a tumor using multi-state perfect phylogeny mixtures</article-title>. <source>Cell Syst</source>., <volume>3</volume>, <fpage>43</fpage>–<lpage>53</lpage>.<pub-id pub-id-type="pmid">27467246</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>El-Kebir</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Inferring parsimonious migration histories for metastatic cancers</article-title>. <source>Nat. Genet</source>., <volume>50</volume>, <fpage>718</fpage>–<lpage>726</lpage>.<pub-id pub-id-type="pmid">29700472</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gabow</surname><given-names>H.N.</given-names></name></person-group><etal>et al</etal> (<year>1986</year>) 
<article-title>Efficient algorithms for finding minimum spanning trees in undirected and directed graphs</article-title>. <source>Combinatorica</source>, <volume>6</volume>, <fpage>109</fpage>–<lpage>122</lpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Garey</surname><given-names>M.R.</given-names></name>, <name name-style="western"><surname>Johnson</surname><given-names>D.S.</given-names></name></person-group> (<year>1979</year>) <source>Computers and Intractability: A Guide to the Theory of NP-Completeness</source>. 
<publisher-name>W. H. Freeman &amp; Co</publisher-name>, 
<publisher-loc>New York, NY, USA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz312-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Govek</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>A consensus approach to infer tumor evolutionary histories</article-title>. In: <italic>Proceedings of the 2018 ACM International Conference on Bioinformatics, Computational Biology, and Health Informatics (BCB '18)</italic>. ACM, New York, NY, pp. 63–72. </mixed-citation>
    </ref>
    <ref id="btz312-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jahn</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Tree inference for single-cell data</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>86.</fpage><pub-id pub-id-type="pmid">27149953</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jamal-Hanjani</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Tracking the evolution of non–small-cell lung cancer</article-title>. <source>N. Engl. J. Med</source>., <volume>376</volume>, <fpage>2109</fpage>–<lpage>2121</lpage>.<pub-id pub-id-type="pmid">28445112</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jiang</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Assessing intratumor heterogeneity and tracking longitudinal and spatial clonal evolutionary history by next-generation sequencing</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>113</volume>, <fpage>E5528</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">27573852</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Jiao</surname><given-names>W.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Inferring clonal evolution of tumors from single nucleotide somatic mutations</article-title>. <source>BMC Bioinformatics</source>, <volume>15</volume>, <fpage>35.</fpage><pub-id pub-id-type="pmid">24484323</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B17">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Karpov</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) A multi-labeled tree edit distance for comparing “Clonal Trees” of tumor progression. In Parida, L. and Ukkonen, E. (eds.) <italic>18th International Workshop on Algorithms in Bioinformatics (WABI 2018)</italic>, volume 113 of <italic>Leibniz International Proceedings in Informatics (LIPIcs)</italic>, Dagstuhl, Germany. Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik, pp. <fpage>22:1</fpage>–<lpage>22:19</lpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B18">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Knuth</surname><given-names>D.E.</given-names></name></person-group> (<year>1997</year>) <source>The Art of Computer Programming, Volume 1 (3rd Ed.): Fundamental Algorithms.</source><publisher-name>Addison Wesley Longman Publishing Co., Inc</publisher-name>, 
<publisher-loc>Redwood City, CA, USA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz312-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Łuksza</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>A neoantigen fitness model predicts tumour response to checkpoint blockade immunotherapy</article-title>. <source>Nature</source>, <volume>551</volume>, <fpage>517.</fpage><pub-id pub-id-type="pmid">29132144</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Malikic</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Clonality inference in multiple tumor samples using phylogeny</article-title>. <source>Bioinformatics</source>, <volume>31</volume>, <fpage>1349</fpage>–<lpage>1356</lpage>.<pub-id pub-id-type="pmid">25568283</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>McGranahan</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Clonal status of actionable driver events and the timing of mutational processes in cancer evolution</article-title>. <source>Sci. Transl. Med</source>., <volume>7</volume>, <fpage>283ra54</fpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Navin</surname><given-names>N.E.</given-names></name></person-group> (<year>2014</year>) 
<article-title>Cancer genomics: one cell at a time</article-title>. <source>Genome Biol</source>., <volume>15</volume>, <fpage>452.</fpage><pub-id pub-id-type="pmid">25222669</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nowell</surname><given-names>P.C.</given-names></name></person-group> (<year>1976</year>) 
<article-title>The clonal evolution of tumor cell populations</article-title>. <source>Science</source>, <volume>194</volume>, <fpage>23</fpage>–<lpage>28</lpage>.<pub-id pub-id-type="pmid">959840</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Popic</surname><given-names>V.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Fast and scalable inference of multi-sample cancer lineages</article-title>. <source>Genome Biol</source>., <volume>16</volume>, <fpage>91.</fpage><pub-id pub-id-type="pmid">25944252</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ross</surname><given-names>E.M.</given-names></name>, <name name-style="western"><surname>Markowetz</surname><given-names>F.</given-names></name></person-group> (<year>2016</year>) 
<article-title>OncoNEM: inferring tumor evolution from single-cell sequencing data</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>69.</fpage><pub-id pub-id-type="pmid">27083415</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Roth</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>PyClone: statistical inference of clonal population structure in cancer</article-title>. <source>Nat. Methods</source>, <volume>11</volume>, <fpage>396</fpage>–<lpage>398</lpage>.<pub-id pub-id-type="pmid">24633410</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B27">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Schrijver</surname><given-names>A.</given-names></name></person-group> (<year>2003</year>) <source>Combinatorial Optimization – Polyhedra and Efficiency</source>. 
<publisher-name>Springer</publisher-name>, New York.</mixed-citation>
    </ref>
    <ref id="btz312-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Steel</surname><given-names>M.A.</given-names></name>, <name name-style="western"><surname>Penny</surname><given-names>D.</given-names></name></person-group> (<year>1993</year>) 
<article-title>Distributions of tree comparison metrics—some new results</article-title>. <source>Syst. Biol</source>., <volume>42</volume>, <fpage>126</fpage>–<lpage>141</lpage>.</mixed-citation>
    </ref>
    <ref id="btz312-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Strino</surname><given-names>F.</given-names></name></person-group><etal>et al</etal> (<year>2013</year>) 
<article-title>TrAp: a tree approach for fingerprinting subclonal tumor composition</article-title>. <source>Nucleic Acids Res</source>., <volume>41</volume>, <fpage>e165</fpage>.<pub-id pub-id-type="pmid">23892400</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B30">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Turajlic</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2018a</year>) Deterministic evolutionary trajectories influence primary tumor growth: TRACERx renal. <italic>Cell.</italic> doi: 10.1016/j.cell.2018.03.043.</mixed-citation>
    </ref>
    <ref id="btz312-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Turajlic</surname><given-names>S.</given-names></name></person-group><etal>et al</etal> (<year>2018b</year>) 
<article-title>Tracking cancer evolution reveals constrained routes to metastases: TRACERx renal</article-title>. <source>Cell</source>. doi: 10.1016/j.cell.2018.03.057.</mixed-citation>
    </ref>
    <ref id="btz312-B32">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Warnow</surname><given-names>T.</given-names></name></person-group> (<year>2017</year>) <source>Computational Phylogenetics: An Introduction to Designing Methods for Phylogeny Estimation</source>, <edition>1</edition>st edn. 
<publisher-name>Cambridge University Press</publisher-name>, 
<publisher-loc>New York, NY, USA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="btz312-B33">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Wolsey</surname><given-names>L.</given-names></name></person-group> (<year>1998</year>) <source>Integer Programming. Wiley Series in Discrete Mathematics and Optimization</source>. 
<publisher-name>Wiley</publisher-name>, New York.</mixed-citation>
    </ref>
    <ref id="btz312-B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yuan</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>BitPhylogeny: a probabilistic framework for reconstructing intra-tumor phylogenies</article-title>. <source>Genome Biol</source>., <volume>16</volume>, <fpage>1</fpage>.<pub-id pub-id-type="pmid">25583448</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zafar</surname><given-names>H.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>SiFit: inferring tumor trees from single-cell sequencing data under finite-sites models</article-title>. <source>Genome Biol</source>., <volume>18</volume>, <fpage>178</fpage>.<pub-id pub-id-type="pmid">28927434</pub-id></mixed-citation>
    </ref>
    <ref id="btz312-B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>A.W.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Interfaces of malignant and immunologic clonal dynamics in ovarian cancer</article-title>. <source>Cell</source>, <volume>173</volume>, <fpage>1755</fpage>–<lpage>1769.e22</lpage>.<pub-id pub-id-type="pmid">29754820</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
