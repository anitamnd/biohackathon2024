<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>BMC Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6302440</article-id>
    <article-id pub-id-type="pmid">30577736</article-id>
    <article-id pub-id-type="publisher-id">2508</article-id>
    <article-id pub-id-type="doi">10.1186/s12859-018-2508-4</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methodology</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CANDLE/Supervisor: a workflow framework for machine learning applied to cancer research</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Wozniak</surname>
          <given-names>Justin M.</given-names>
        </name>
        <address>
          <email>woz@anl.gov</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Jain</surname>
          <given-names>Rajeev</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Balaprakash</surname>
          <given-names>Prasanna</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ozik</surname>
          <given-names>Jonathan</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Collier</surname>
          <given-names>Nicholson T.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bauer</surname>
          <given-names>John</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xia</surname>
          <given-names>Fangfang</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brettin</surname>
          <given-names>Thomas</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stevens</surname>
          <given-names>Rick</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mohd-Yusof</surname>
          <given-names>Jamaludin</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Cardona</surname>
          <given-names>Cristina Garcia</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Essen</surname>
          <given-names>Brian Van</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Baughman</surname>
          <given-names>Matthew</given-names>
        </name>
        <xref ref-type="aff" rid="Aff4">4</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 1939 4845</institution-id><institution-id institution-id-type="GRID">grid.187073.a</institution-id><institution>Argonne National Laboratory, </institution></institution-wrap>Argonne, IL USA </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0004 0428 3079</institution-id><institution-id institution-id-type="GRID">grid.148313.c</institution-id><institution>Los Alamos National Laboratory, </institution></institution-wrap>Los Alamos, NM USA </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2160 9702</institution-id><institution-id institution-id-type="GRID">grid.250008.f</institution-id><institution>Lawrence Livermore National Laboratory, </institution></institution-wrap>Livermore, CA USA </aff>
      <aff id="Aff4"><label>4</label>Minerva, San Francisco, CA USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>21</day>
      <month>12</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>21</day>
      <month>12</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <volume>19</volume>
    <issue>Suppl 18</issue>
    <issue-sponsor>Publication of this supplement has not been supported by sponsorship. Information about the source of funding for publication charges can be found in the individual articles. The articles have undergone the journal's standard peer review process for supplements. ES is the Frederick National Laboratory for Cancer Research co-program lead for the Joint Design of Advanced Computing Solutions for Cancer (JDACS4C) program. Several of the papers presented in the workshop and included in the supplement are the result of work supported by the JDACS4C program and, as such, ES is listed as a co-author on one of the articles in the supplement but was not involved in its review. SC declares no competing interests.</issue-sponsor>
    <elocation-id>491</elocation-id>
    <permissions>
      <copyright-statement>© The Author(s) 2018</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Current multi-petaflop supercomputers are powerful systems, but present challenges when faced with problems requiring large machine learning workflows. Complex algorithms running at system scale, often with different patterns that require disparate software packages and complex data flows cause difficulties in assembling and managing large experiments on these machines.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>This paper presents a workflow system that makes progress on scaling machine learning ensembles, specifically in this first release, ensembles of deep neural networks that address problems in cancer research across the atomistic, molecular and population scales. The initial release of the application framework that we call CANDLE/Supervisor addresses the problem of hyper-parameter exploration of deep neural networks.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Initial results demonstrating CANDLE on DOE systems at ORNL, ANL and NERSC (Titan, Theta and Cori, respectively) demonstrate both scaling and multi-platform execution.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Sample</kwd>
      <kwd>Article</kwd>
      <kwd>Author</kwd>
    </kwd-group>
    <conference xlink:href="http://www.scworkshops.net/cancer2017/index.html">
      <conf-name>Computational Approaches for Cancer at SC17</conf-name>
      <conf-loc>Denver, CO, USA</conf-loc>
      <conf-date>17 November 2017</conf-date>
    </conference>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2018</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Cancer is an extremely complex disease, which disrupts basic biological processes at a fundamental level, leading to renegade cells threatening the health of the individual. Fortunately, with major technological advances in molecular sequencing, molecular and cellular imaging, and high-throughput screening techniques, it is now possible to probe the complexity of the disease at an unparalleled level, which provides a window into the behavior of the disease at unprecedented time and spatial scales. The application of these technologies has produced massive datasets that can be analyzed with automated machine learning (ML) techniques.</p>
    <p>Simultaneously, the development of post-petascale and near-exascale computers is ongoing. Top tier computers in the U.S. include ALCF Theta, OLCF Titan, and NERSC Cori. These systems feature extremely large node counts (thousands to tens of thousands), and are equipped with nodes of many integrated cores or accelerator technologies, such as GPUs. These systems also have large hierarchical memory and I/O resources. Thus, they are capable of performing machine learning workloads that would be extremely time-consuming to run elsewhere (on open science infrastructure).</p>
    <p>This work offers an early attempt to apply these top-tier systems to three problems in cancer research. We focus here on the problem of hyperparameter optimization, which tries to find high performing configurations for neural networks. The design parameters broadly include the number of layers, neurons per layer, activation function, and so on. The quality of the network is essentially its accuracy; a loss function <italic>F</italic> is determined such that its value is a measure of the error in the trained network behavior when applied to a validation set. The hyperparameter optimization problem is to minimze <italic>F</italic>(<italic>p</italic>), for all parameter sets <italic>p</italic> in the valid parameter space <italic>P</italic>, however, <italic>P</italic> is large and <italic>F</italic> is expensive. <italic>P</italic> is the cross product of all valid network settings, some of which may be categorical, some integer, some continuous. Evaluating <italic>F</italic> involves training the network on a training data set and applying it to the validation set.</p>
    <p>This problem is an excellent but challenging candidate for workflow technologies, because it involves running a large number of independent tasks, each of which communicates only with the optimization algorithm. Each task is capable of utilizing all the compute resources on the node, as the available 3rd-party ML implementations are multi-threaded or deployable on a GPU. The tasks run for minutes, hours, or longer. Workflow systems would be challenged, however, by the scale and complexity of the large-scale resources that we desire to apply to the problem. Also, we desire to apply complex 3rd-party algorithms written in Python or R to control this workflow by driving an optimization loop. Similarly, because the ML algorithms are written in C/C++ with complex Python-based interfaces, there is a software interfacing challenge. Additionally, we must collect data on <italic>F</italic> during the run, as well as various other data for profiling or validation.</p>
    <p>Success in the application of ML to cancer research will enable and greatly accelerate the capabilities needed to realize the promise envisioned for the ‘Cancer Moonshot’ [<xref ref-type="bibr" rid="CR1">1</xref>] and establish a new paradigm for cancer research for years to come by making effective use of the ever-growing volumes and diversity of cancer related data to build predictive models, provide better understanding of the disease and, ultimately, provide guidance and support decisions on anticipated effective treatments for individual patients.</p>
    <p><bold>Contributions</bold> This paper offers the following: 1) A description of several machine learning-based workflows relevant to cancer. 2) An architecture for coordinating and storing workflow processes and data products. 3) Performance results from running these workflows on large-scale systems.</p>
    <p>The remainder of this paper is organized as follows. In the remainder of this section, we describe the aspects of machine learning relevant to this work. In “<xref rid="Sec5" ref-type="sec">Methods</xref>” section, we describe the architecture of the CANDLE/Supervisor software system, and the three workflows currently supported by CANDLE/Supervisor, and the practicalities and portability issues. In “<xref rid="Sec11" ref-type="sec">Results</xref>” section, we describe performance results from these systems. In “<xref rid="Sec16" ref-type="sec">Discussion</xref>” section, we describe future work, and we conclude in “<xref rid="Sec17" ref-type="sec">Conclusions</xref>” section.</p>
    <sec id="Sec2">
      <title>The CANDLE project</title>
      <p>Machine learning (ML) has the capability to transform many scientific problems. In response to the growing power of ML techniques and the increasing available computing power at large scale computing facilities, the U.S. Department of Energy Exascale Computing Project (ECP) launched the <bold>Cancer Distributed Learning Environment (CANDLE)</bold>. CANDLE is developing a suite of software to support scalable deep learning on DOE supercomputing resources. While the CANDLE project is explicitly aimed at supporting deep learning in the three cancer pilot projects in the near-term, its longer-term goal is to support a wide variety of deep learning applications across DOE science domains.</p>
    </sec>
    <sec id="Sec3">
      <title>Frameworks for machine learning</title>
      <p>Deep learning frameworks are under active development by diverse research communities in both industry (Google, Facebook, Microsoft, etc.) and academia (Berkeley, Oxford, Toronto, etc.). These include Caffe [<xref ref-type="bibr" rid="CR2">2</xref>], Keras [<xref ref-type="bibr" rid="CR3">3</xref>], Theano [<xref ref-type="bibr" rid="CR4">4</xref>], Torch [<xref ref-type="bibr" rid="CR5">5</xref>], Poseidon [<xref ref-type="bibr" rid="CR6">6</xref>], Neon [<xref ref-type="bibr" rid="CR7">7</xref>], TensorFlow [<xref ref-type="bibr" rid="CR8">8</xref>], CNTK [<xref ref-type="bibr" rid="CR9">9</xref>], and the Livermore Big Artificial Neural Net (LBANN) [<xref ref-type="bibr" rid="CR10">10</xref>]. Each of these frameworks differ with respect to the machine learning tasks they target, their ease of use, data pre-processing, and target problems. Most frameworks were architected for a single node implementation and a few distributed memory multi-node implementations have recently emerged; but these implementations are primarily targeted at smaller core counts and for commodity cluster environments. Moreover, these implementations rely on avoiding communication by storing data on local disks. Implementations targeting high-performance computing systems will need novel techniques to fully exploit the system interconnect bandwidth and topologies, as well as the deep memory hierarchies.</p>
    </sec>
    <sec id="Sec4">
      <title>Hyperparameter search</title>
      <p>The simplest, though most costly, methods for hyperparameter optimization include exhaustive space search (the brute force method), simple gradient descent, multiple gradient descent, and random search. Though these search algorithms can be tuned to execute quickly (random search) or to find the optimal solution (exhaustive search), the marginal optimization with respect to utilized resources is not efficient for problems with <italic>O</italic>(10<sup>9</sup>) or greater reasonable discrete parameter combinations. There are two primary drawbacks to utilizing an <italic>a priori</italic> user-specified set of discrete hyperparameters for reducing loss: 1) it requires the user to make assumptions concerning topological efficiencies and efficacies and 2) it is limited to a small, finite set of models (i.e., it is forcing a complex algorithm into constrained bounds). By including effective reductions possible using gradient descent, we may gain one or two orders of magnitude of search space, however, this is still well below the <italic>O</italic>(10<sup>21</sup>) complexity that is possible in the current CANDLE workflows.</p>
      <p>Currently, several frameworks and libraries exist to accelerate model exploration. As described in “<xref rid="Sec5" ref-type="sec">Methods</xref>” section, we use the EMEWS [<xref ref-type="bibr" rid="CR11">11</xref>] framework to directly incorporate parameter exploration methods for efficient exploration of order &gt;10<sup>9</sup> spaces. This framework uses the Argonne-developed Swift/T [<xref ref-type="bibr" rid="CR12">12</xref>, <xref ref-type="bibr" rid="CR13">13</xref>] language to distribute the model exploration workload efficiently across a multi-node system.</p>
      <p>HyperTune [<xref ref-type="bibr" rid="CR14">14</xref>] uses Bayesian optimization to refine given network hyperparameters. This implementation of Bayesian optimization excels as it does not require calculation of many multidimensional derivatives. The algorithm can be thought of as finding direction from a random sample – a set of hyperparameters is chosen, then another, and if the second is a better set than the first, the algorithms aims in that direction. This method excels as it is extensible and can find reasonable solutions with much less compute time than evolutionary algorithms but it can also “bounce around,” not settling on a given set of values or displacing itself past a promising minima.</p>
      <p>Another alternative is the popular Python library, SciKit-Learn [<xref ref-type="bibr" rid="CR15">15</xref>]. This is a multipurpose machine learning library for Python (easily integrated with Keras) and can be used for hyperparameter search. HyperOpt [<xref ref-type="bibr" rid="CR16">16</xref>] is a hyperparameter search framework that is designed to perform searches using distributed hardware. HyperOpt has a SciKit-Learn variant [<xref ref-type="bibr" rid="CR17">17</xref>].</p>
      <p>Another approach is evolutionary algorithms. One of the most prominent and robust implementation of genetic algorithms for hyperparameter search is the NeuroEvolution of Augmenting Topologies (NEAT) algorithm [<xref ref-type="bibr" rid="CR18">18</xref>]. The NEAT method begins by spawning a genome and then producing a population based on that genome. Using a selection function, the algorithm then usually removes the least fit (those with the highest error rate or loss) members of the population, then uses crossover between members of the remaining subpopulation to produce the next generation. It does this on two levels, both within each node (neuron) and with the topology of the network. Using this genetic-style algorithm, one is often able to find a robustly effective solution. There are, however, some drawbacks of the NEAT algorithm (or, at least, its specific “NEAT-python” [<xref ref-type="bibr" rid="CR19">19</xref>] implementation). The primary factor that would most limit us in our application is NEAT‘s alteration of intra-node weights and parameters. While this can definitely prove beneficial by reducing loss at the “starting point” of training, it also serves as a topology specific feature that somewhat precludes comparison of pure topological strengths and weaknesses. The other limiting factor is the overhead required to generate the network from scratch.</p>
      <p>Another system for evolutionary algorithms for hyperparameter tuning is Optunity [<xref ref-type="bibr" rid="CR20">20</xref>], a DEAP-dependent [<xref ref-type="bibr" rid="CR21">21</xref>] hyperparameter tuning engine. DEAP (Distributed Evolutionary Algorithms in Python) is a Python framework that implements different, generalized evolutionary algorithms. Optunity acts as an interface between DEAP and the network to be optimized, allowing for easy deployment of these various algorithms for the purpose of hyperparameter optimization. Optunity is an excellent implementation of evolutionary algorithms for the purpose of hyperparameter tuning, however, it was last updated nearly one year ago (2016).</p>
      <p>mlrMBO [<xref ref-type="bibr" rid="CR22">22</xref>] is a R package for model-based approaches developed for tackling expensive black-box optimization by approximating the given objective function through a surrogate regression model. It is designed for optimization problems with mixed continuous, categorical and conditional parameters. mlrMBO follows Bayesian optimization [<xref ref-type="bibr" rid="CR23">23</xref>] approach which proceeds as follows. In the initialization phase, <italic>n</italic><sub><italic>s</italic></sub> configurations are sampled at random, evaluated, and a surrogate model <italic>M</italic> is fitted with the input-output pairs. In the iterative phase, at each iteration, <italic>n</italic><sub><italic>b</italic></sub> promising input configurations are sampled using the model <italic>M</italic>. These configurations are obtained using infill criterion that guides the optimization and tries to trade-off exploitation and exploration. The infill criterion selects configurations that either have a good expected objective value (exploitation) or high potential to improve the quality of the model <italic>M</italic> (exploration). The algorithm terminates when user-defined maximum number of evaluations and/or wall-clock time is exhausted.</p>
      <p>In this work, we focused on mlrMBO as it was shown to obtain state-of-the-art performance on a wide range of test problems, where it was benchmarked against other approaches such as DiceOptim, rBayesianOptimization, SPOT, SMAC, Spearmint, and Hyperopt. Crucial to the effectiveness of mlrMBO is the choice of the algorithm used to fit <italic>M</italic> and the infill criterion. Given the mixed integer parameters in the hyperparameter search, we used random forest [<xref ref-type="bibr" rid="CR24">24</xref>] because it can handle such parameters directly, without the need to encode the categorical parameters as numeric. For the infill criterion, we used the qLCB [<xref ref-type="bibr" rid="CR25">25</xref>], which proposes multiple points with varying degrees of exploration and exploitation.</p>
    </sec>
  </sec>
  <sec id="Sec5">
    <title>Methods</title>
    <p>Emerging multi-petaflop supercomputers are powerful platforms for ensembles of neural networks that can address many problems in cancer research, but it is difficult to assemble and manage large studies on these machine, which have tens of thousands of compute nodes. Typical workflow approaches would face challenges due to system scale, system complexity, management of complex workflow patterns, integration with disparate software packages, and data acquisition. CANDLE/Supervisor addresses the problem of hyperparameter optimization for cancer-based problems, and solves the common workflow challenges outlined above.</p>
    <p>To support the search patterns described in “<xref rid="Sec1" ref-type="sec">Background</xref>” section, we developed the CANDLE/Supervisor architecture diagrammed in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. The overall goal is to solve the hyperparameter optimization problem to minimize <italic>F</italic>(<italic>p</italic>), where <italic>F</italic> is the performance of the neural network parameterized by <italic>p</italic>∈<italic>P</italic>, where <italic>P</italic> is the space of valid parameters.
<fig id="Fig1"><label>Fig. 1</label><caption><p>CANDLE/Supervisor overall architecture</p></caption><graphic xlink:href="12859_2018_2508_Fig1_HTML" id="MO1"/></fig></p>
    <p>The optimization is controlled by an <bold>Algorithm</bold> 1 O selected by the user. The Algorithm can be selected from those previously integrated into CANDLE, or new ones can be added. These can be nearly any conceivable model exploration (ME) algorithm that can be integrated with the <bold>EMEWS</bold> 3 O software framework. EMEWS [<xref ref-type="bibr" rid="CR11">11</xref>] enables the user to plug in ME algorithms into a workflow for arbitrary model exploration; optimization is a key use case. The ME algorithm can be expressed in Python or R. This is implemented in a reusable way by connecting the parameter generating ME algorithm and output registration methods to interprocess communication mechanisms that allow these values to be exchanged with Swift/T. EMEWS currently provides this high-level queue-like interface in two implementations: EQ/Py and EQ/R (EMEWS Queues for Python and R). The Algorithm is run on a thread on one of the processors in the system. It is controlled by a Swift/T script 2 O provided by EMEWS, that obtains parameter tuples to sample and distributes them for evaluation.</p>
    <p>The Swift/T [<xref ref-type="bibr" rid="CR12">12</xref>, <xref ref-type="bibr" rid="CR13">13</xref>] workflow system is used to manage the overall workflow. It integrates with the various HPC schedulers “<xref rid="Sec10" ref-type="sec">Computing systems</xref>” section to bring up an allocation. A Swift/T run deploys one or more load balancers and many worker processes distributed across compute nodes in a configurable manner. Normally, Swift/T evaluates a workflow script and distributes the resulting work units for execution across the nodes of a computer system over MPI. Swift/T can launch jobs in a variety of ways, including in-memory Python functions in a bundled Python interpreter, shell commands, or even MPI-based parallel tasks. However, in this use case, workflow control is delegated to the Algorithm via the EMEWS framework, which provides the Swift/T script.</p>
    <p>During an optimization iteration, the Algorithm produces a list of parameter tuples 4 O that are encoded as arguments to a Python-based <bold>Wrapper</bold> script 5 O. These wrapper scripts are the interfaces to the various CANDLE Pilot applications. The parameters are encoded in JavaScript Object Notation (JSON) format which can be easily converted by the Python <bold>Wrapper</bold> script into a Python dictionary, from which a CANDLE Pilot application can retrieve the parameter values. These scripts are run concurrently across the available nodes of the Swift/T allocation, typically one per node. Thus, the <bold>ML</bold> has access to all the resources on the node. The ML is the underlying learning engine; we have tested with Theano and TensorFlow. The <bold>Pilots</bold> are Python programs that implement the application-level logic of the cancer problem in question. They use the <bold>Keras</bold> interface to interact with the ML and are coded to enable the hyperparameters to be inferred from a suitable default model file, or to be overwritten from the command line. It is this construction that allows the parameter tuples to be easily ingested by the respective Pilots, and use a standardized interface developed as part of the project.</p>
    <p>The result of a Wrapper execution is a performance measure on the parameter tuple <italic>p</italic>, typically the validation loss. Other metrics could be used, including training time or some combination thereof. These are fed back to the Algorithm by EMEWS to produce additional parameters to sample. The results are also written to a Solr-based <bold>Metadata Store</bold> 7 O, which contains information about the Wrapper execution. The Metadata Store accesses are triggered by Keras callback functions, which allow Wrapper code to be invoked by Keras at regular intervals. Thus, a progress history is available for each learning trial run, as well as for the overall optimization workflow. Good models can also be selected and written to a <bold>Model Store</bold>.</p>
    <sec id="Sec6">
      <title>Workflows</title>
      <p>In this section, we describe how the framework described in “<xref rid="Sec5" ref-type="sec">Methods</xref>” section is applied to the three pilot cancer problems. CANDLE is investigating three promising pilot applications of ML technology to cancer research:</p>
      <p><bold>P:RAS – The RAS pathway problem.</bold> The RAS/RAF pathway is a series of chemical events that is implicated in 30% of cancers. The goal of this pilot is to understand the molecular basis of key protein interactions in this pathway.</p>
      <p><bold>P:DRUG – The drug response problem.</bold> The goal of this pilot is to develop predictive models for drug response that can be used to optimize pre-clinical drug screening and drive precision medicine based treatments for cancer patients.</p>
      <p><bold>P:TREAT – The treatment strategy problem.</bold> The goal of this pilot is to automate the analysis and extraction of information from millions of cancer patient records to determine optimal cancer treatment strategies across a range of patient lifestyles, environmental exposures, cancer types and healthcare systems.</p>
      <p>While each of these three challenges are at different scales (i.e., molecular, cellular and population) and have specific scientific teams collaborating on the data acquisition, data analysis, model formulation, and scientific runs of simulations, they also share several common threads. They are all linked by common sets of cancer types that will appear at all three scales, all have to address significant data management and data analysis problems, and all need to integrate simulation, data analysis and machine learning to make progress. We have focused on the machine learning aspect of the three problems and, in particular, we are focused on building a single, scalable deep neural network computing environment to support them.</p>
    </sec>
    <sec id="Sec7">
      <title>P:RAS – The RAS pathway problem</title>
      <p>For this Pilot the goal is to develop a predictive capability for modeling the behavior of proteins on membranes and to apply that capability to RAS and effector proteins along the primary RAS signaling pathways. We expect that as a result of this capability we will accelerate the identification and development of effective therapeutics targeting cancers driven by RAS mutations, including the three deadliest cancers occurring today: pancreatic, lung and colon. By exploiting a mixture of atomistic and coarse-grained resolutions we anticipate modeling for the first time a relevant size (<italic>O</italic>(10<sup>10</sup>) atoms) and time-scale (<italic>O</italic>(10<sup>9</sup>) timesteps) to allow investigation of targetable binding sites along the RAS signaling cascade. Unfortunately, the combinatorial number of possible binding interactions along the cascade renders a human-guided exploration of the state-space unlikely to uncover a site suitable for therapeutic intervention. What is required is a formalism for defining and following a path of simulations that will lead us to a targetable site.</p>
      <p>The starting point for our deep learning is the output of these extremely large-scale molecular dynamics calculations. We aim to use unsupervised learning to uncover features from these simulations that can be used to describe the state-space of protein movement and binding in a higher level model. These higher level models can then be used to explore (far more efficiently) the possible dynamics of RAS interactions, delivering many millions of hypothetical trajectories which can be scored according to likelihood. By investigating (through direct numerical simulation) the most likely of these trajectories, we “close the loop” — essentially testing our hypothesis and then learning from the results. Any new information is used to refine the definitions of likelihood and affect future hypothesis. This combination of machine learning and molecular dynamics to develop and test hypotheses of protein binding will dramatically enhance our understanding of RAS signaling pathways (potentially leading to a cure) and demonstrates a new and powerful way to use high performance computing as tool for scientific discovery.</p>
      <p><bold>Pilot application.</bold> The P:RAS pilot is a two-stage set of stacked autoencoders that learn both molecular- and frame- level features for the coarse-grained molecular dynamics simulation of a lipid membrane. The first part of the neural network is a multi-stage stacked, convolutional autoencoder with a local receptive field sized to observe individual molecules, which produces molecular-level features. The second part of the neural network is a multi-stage, stacked fully connected autoencoder that processes the output of the molecular autoencoder to create a compressed representation of the entire simulation frame. For preliminary network optimizations, we have explored the following hyperparameters: 1) number of convolutional layers and features in the molecular autoencoder, 2) number of fully-connected layers and size of each layer, and 3) size of stochastic gradient descent mini-batch.</p>
    </sec>
    <sec id="Sec8">
      <title>P:DRUG – The drug response problem</title>
      <p>Our ultimate goal is to fully exploit exascale computing to develop the predictive models necessary to guide the choice of drug treatment for a tumor based on that patient’s molecular biomarkers and knowledge of drug responses in other cases. The development of CANDLE will bring deep learning to bear on this problem at an unprecedented scale, and we believe will produce models uniquely capable of making precision medicine a reality. Deep learning has the potential to generate models that take into account a vastly increased diversity of input features than other types of machine learning [<xref ref-type="bibr" rid="CR26">26</xref>]. Today machine learning is typically used to estimate drug response and patient outcome from one type of molecular data such as gene expression; however it has been demonstrated that models that incorporate more than one type of molecular information can be more accurate [<xref ref-type="bibr" rid="CR27">27</xref>]. Our goal in this problem is to develop a scalable deep learning framework that will support the utilization of many types of information as input to models. Ideally, we will integrate into our models information about drug molecular structures, drug interactions, drug combinations and drug molecular targets with information about the patient’s genetics, including their baseline genotype as well as the specific genetics and other molecular and cellular properties of their tumor, including gene mutations, gene expression patterns, proteome, transcriptome including small and non-coding RNAs, metabolomics, prior treatments, co-morbidities and environmental exposure.</p>
      <p>Our current working data contains drug and drug-like molecular screening data from over 300,000 compounds that have been tested on at least 60 cell lines giving us <italic>O</italic>(10<sup>7</sup>) training cases. For each tumor derived cell line, we have molecular characterization data that includes many types of microarrays each with ∼10<sup>5</sup> data points; we have genetic variation data for these sample that consist of 10<sup>7</sup> single nucleotide polymorphisms (SNPs); variety of proteomics, metabolomics, and transcription datasets including over 50,000 types of small and non-coding RNAs. For the compounds involved in screening, we can compute molecular characterization data (e.g., drug descriptors and molecular fingerprints) that when taken together are <italic>O</italic>(10<sup>6</sup>) features per molecule. Thus, our initial deep learning formulation of the drug response problem has an input data volume of between 10<sup>14</sup>−10<sup>15</sup> measurements or approximately 1PB. The ten-year problem target is at least an order of magnitude larger than this. To our knowledge, this would be one of the largest deep learning problems in biomedical science. One of the largest training sets in the DNN community is a 15TB image recognition dataset [<xref ref-type="bibr" rid="CR28">28</xref>]. Our ten-year goal is to expand this capability by at least an order of magnitude (10PB input data), requiring between 100TB and 1PB of high-speed memory for a single network instantiation and with a target training epoch runtime of hours.</p>
      <p><bold>Pilot application.</bold> The P:DRUG is a binary classification task on 1400 RNA-seq based gene expression profiles from the NCI Genomic Data Commons (GDC). 700 of these samples are from tumor tissues and the other 700 are their matched normals. There are 60,483 features for each sample that are fed into a neural network with a default configuration of two dense layers on top of two convolution layers. The following hyperparameters are explored to optimize our network architecture: 1) learning rate, 2) batch size, 3) number of epochs, 4) dropout, 5) activation function, 6) loss measure, 7) optimizer, 8) the number of convolution layers and the number of neurons in each convolution layer, and 9) the number of dense layers and the number of neurons in each dense layer.</p>
    </sec>
    <sec id="Sec9">
      <title>P:TREAT – The treatment strategy problem</title>
      <p>Our goal is to exploit exascale computing to develop the predictive models necessary for population-wide cancer surveillance that extends beyond the clinical trial setting. The treatment strategy problem tackles the critical issue of clinical translation to determine to what extent scientific advances, such as those made within the RAS pathway and drug response problems, translate successfully in the real world. The treatment strategy problem requires integration of heterogeneous datasets as well as deep analytic techniques to understand the interrelationships among genetic, lifestyle and environmental factors in patient-specific cancer etiology and cancer outcomes.</p>
      <p>To achieve our overarching goal, we will first leverage the CANDLE environment to deploy deep learning for automated extraction of clinical variables about patient-level cancer management trapped in unstructured text data from daily clinical practice. These variables capture important information about the patient’s cancer staging, administered therapies, disease progression (i.e., recurrence, metastasis), and outcome. Such information is critical to understand the impact of cancer treatment strategies and policies in the broad population as part of the national cancer surveillance program. Current practice relies on manual information extraction, an approach that is neither scalable nor comprehensive for a variety of reasons; the number of people living with cancer increases (roughly 15,000,000 people live with cancer in the US [<xref ref-type="bibr" rid="CR29">29</xref>], new diagnostic and therapeutic biomarkers are continuously introduced, and new therapeutic options enter the clinical arena. Traditional natural language processing (NLP) algorithms have been developed to automate this process. The NLP algorithms rely on carefully crafted keyword-based rules for information extraction. With the well-known variation in clinical expression and the size of the controlled medical vocabularies containing more than 100,000 medical terms and expressions (describing diseases, conditions, symptoms, and medical semantics that are typically present in unstructured clinical text), hand-engineered rule extraction is neither scalable nor effective for large-scale clinical deployment. Deep learning has the potential to address these challenges and capture both semantic and syntactic information in clinical text without having explicit knowledge of the clinical language. However, the deep learning tools that can handle the specific requirements of this third challenge (input space (<italic>O</italic>(10<sup>6</sup>) patients) × feature space (<italic>O</italic>(10<sup>5</sup>) medical terms and expressions) × output space (<italic>O</italic>(10<sup>5</sup>) medical biomarkers and clinical endpoints throughout a cancer patient’s medical care trajectory) do not currently exist. We will develop those tools, focusing specifically on semi-supervised learning since it is impractical to collect millions of expert-annotated clinical reports. A semi-supervised algorithmic framework is best suited to this challenge, balancing carefully the number of labeled data (&gt;10,000 clinical reports) and unlabeled data (&gt;2,000,000 clinical reports) to be made available to us by NCI. We will explore convolutional, deep-belief, and deep-stacking networks. In addition, we will implement a multi-task deep learning framework that can be used for joint classification/information extraction tasks.</p>
      <p><bold>Pilot application.</bold> For the P:TREAT Pilot, which involves training a multi-task deep neural network (MT-DNN), we used the following hyperparameters to optimize our network architecture: 1) learning rate, 2) batch size, 3) number of epochs, 4) dropout, 5) activation function, 6) loss measure, 7) optimizer, 8) number of folds, 9) the number of neurons in the shared layer, and 10) the number of neurons in the task-specific layer. For the MT-DNN, we chose three classification tasks, namely i) primary site, ii) tumor laterality, and iii) histological grade. For each of the parameters outlined above, we run a parameter sweep on our MT-DNN to iteratively optimize the average accuracy per training task. The end of the hyperparameter sweep results in a MT-DNN that is optimally performant on the three classification tasks.</p>
    </sec>
    <sec id="Sec10">
      <title>Computing systems</title>
      <p>The three workflows described previously “<xref rid="Sec6" ref-type="sec">Workflows</xref>” section were run on ALCF Theta, OLCF Titan, and NERSC Cori. These systems vary greatly in their hardware and software systems. The following is an overview of their system parameters: 
<list list-type="bullet"><list-item><p><bold>ALCF</bold><bold><italic>Theta</italic></bold><bold> at Argonne National Laboratory</bold><list list-type="bullet"><list-item><p>3624 nodes with item 64-core Intel Xeon Phi item 16 GB MCDRAM, 192 GB of DDR4 RAM</p></list-item><list-item><p>Python 2.7.13, Keras 2.0.2, TensorFlow 1.2.0</p></list-item><list-item><p>Scheduler: Cobalt</p></list-item></list></p></list-item><list-item><p><bold>OLCF</bold><bold><italic>Titan</italic></bold><bold> at Oak Ridge National Laboratory</bold><list list-type="bullet"><list-item><p>18,688 nodes with item 16-core AMD CPU item NVIDIA Kepler K20X GPUs item 32 GB RAM</p></list-item><list-item><p>Python 3.6, Keras 2.0.3, TensorFlow 1.0.1</p></list-item><list-item><p>Scheduler: PBS</p></list-item></list></p></list-item><list-item><p><bold>NERSC</bold><bold><italic>Cori</italic></bold><bold> at Lawrence Berkeley National Laboratory</bold><list list-type="bullet"><list-item><p>2388 nodes with item Intel Xeon Haswell CPUs item 128 GB RAM</p></list-item><list-item><p>9688 nodes with item Intel Xeon Phi item 16 GB MCDRAM, 96 GB DDR</p></list-item><list-item><p>Python 2.7.12, Keras 2.0.0, TensorFlow 1.2.0</p></list-item><list-item><p>Scheduler: SLURM</p></list-item></list></p></list-item></list></p>
      <p>As tabulated above, it is clear that these systems vary significantly in their hardware capabilities and installed software systems. This does not include differences in compiler versions, software module management, and storage system policies or capabilities.</p>
      <p>We use Swift/T to abstract the scheduler and compute layout settings. The launch parameters for Swift/T allow the user to specify the scheduler type, processor count, workers per node, and other common settings in a uniform way across systems.</p>
      <p>We use our Wrapper script abstraction “<xref rid="Sec5" ref-type="sec">Methods</xref>” section to abstract the Python configuration and ML library settings. The wrapper script is invoked in one of two ways, either by a short piece of Python code, the text of which is embedded in the Swift/T script and executed directly by the Swift/T runtime embedded Python interpreter, or by a bash script that is executed via a Swift/T app function [<xref ref-type="bibr" rid="CR12">12</xref>]. App functions are Swift/T language functions that are implemented as command-line programs, in this case a shell script that calls the Python interpreter passing it the wrapper script as an argument. In both cases, the Swift/T script receives the hyperparameters from the model exploration algorithm and passes them to the wrapper script either via a string template in the embedded Python code or as a command line argument to the bash script.</p>
      <p>The workflows were run on Cori using embedded Python invocation and on Theta and Titan using the app invocation of the bash script. Depending on the software stack available on the resource, the app function invocation avoids potential conflicts between Swift‘s embedded Python interpreter and the Python used by the deep learning frameworks by setting the PATH, PYTHONPATH, and other environment variables appropriately for the system in question.</p>
    </sec>
  </sec>
  <sec id="Sec11" sec-type="results">
    <title>Results</title>
    <p>In this section, we measure the performance of the CANDLE/Supervisor system for the cancer pilot workloads. We measure quantities relevant to the performance of a workflow system, namely, system utilization, task start-up latency, and task rate scaling.</p>
    <sec id="Sec12">
      <title>System utilization analysis</title>
      <p>In our first test, we measure system utilization on NERSC Cori. This test measures the fraction of the system available to the ML libraries, everything else is treated as overhead. In this test, we used the P:DRUG pilot workflow. The plots that follow illustrate the capability of our hyperparameter optimization infrastructure. Two search approaches, random and model-based searches, were scaled up to 360 nodes.</p>
      <p>To perform the CANDLE hyperparameter optimization, we installed the CANDLE/Supervisor environment with EMEWS configured to use mlrMBO as the optimization algorithm. We used the ML package that provides a deep learning environment for Python 2.7, including Keras, TensorFlow, Theano, etc., provided by the NERSC administrators.</p>
      <p>On Cori, we ran P:RAS and P:TREAT benchmarks on 360 nodes. For P:RAS, we ran two different hyperparameter search strategies: random search and model-based-search, both with a budget of 1800 parameter configurations. In the former, 1800 configurations were generated at random and evaluated by the workflow infrastructure. In the latter, 360 configurations are generated at random and the model-based-search generates 360 configurations at each iteration and evaluated. The results are shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. Our framework scales well to the total number of nodes in the system; there is negligible ramp-up time.
<fig id="Fig2"><label>Fig. 2</label><caption><p>System utilization for hyperparameter optimization on Cori</p></caption><graphic xlink:href="12859_2018_2508_Fig2_HTML" id="MO2"/></fig></p>
      <p>While the performance results show that random search has better resource utilization over model based search, this is due to the fact that model searches cannot proceed to the next sampling iteration until it finishes evaluating all configurations from the previous iteration. In a more realistic run, the models would run longer (10 or more hours), reducing the impact of the gaps between iterations. Additionally, we plan to overlap runs between iterations as described in “<xref rid="Sec16" ref-type="sec">Discussion</xref>” section.</p>
    </sec>
    <sec id="Sec13">
      <title>Scaling one iteration</title>
      <p>In this experiment we run the P:DRUG benchmark with mlrMBO for one iteration at various scales on Titan to determine scalability. For each node count <italic>N</italic>, we recorded the start time and stop time, and plot the number of models running on the system at each point in time. The result is shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref>.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Load profile for increasing workflow scale</p></caption><graphic xlink:href="12859_2018_2508_Fig3_HTML" id="MO3"/></fig></p>
      <p>As shown in the plot, increasing the number of nodes in the run increases the work done. While there is a considerable impact from task time variability, all tasks exit before they are forced to timeout, which would happen at the 90 minute mark. This shows that the CANDLE/Supervisor system is capable of delivering large-scale computational resources to hyperparameter search workflows.</p>
    </sec>
    <sec id="Sec14">
      <title>Task start-up latency</title>
      <p>Our underlying Supervisor workflow engine is capable of quickly distributing tasks to workers, but the workers must load the necessary optimization and ML libraries before executing. The plot in Fig. <xref rid="Fig4" ref-type="fig">4</xref> illustrates this. For increasing workloads (up to 62 nodes, one model per node) on Cori, we profiled the load time for the R packages and Python packages. The total load time is about 50 sec at 62 nodes. We use the in-memory Python and R interpreters available in Swift/T to load these modules, meaning that they are only loaded once per node per workflow, and not for each task.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Software load time for Python and R modules on Cori</p></caption><graphic xlink:href="12859_2018_2508_Fig4_HTML" id="MO4"/></fig></p>
      <p>As shown in the plot, loading the software (not even the training data!) takes almost a minute, even at the modest scale shown. Thus, the ability to keep the modules loaded in the Python and R interpreters from task to task, a unique Swift/T ability, is critical for these workflows.</p>
    </sec>
    <sec id="Sec15">
      <title>Task rate scaling</title>
      <p>In this measurement, we seek to summarize the scaling properties of our system by measuring models completed per unit time. In this case, we ran the P:DRUG workflow on Titan at various scale and simply measuring the number of models completed per hour. This result is shown in Fig. <xref rid="Fig5" ref-type="fig">5</xref>.
<fig id="Fig5"><label>Fig. 5</label><caption><p>Scalability: models completed per hour on Titan</p></caption><graphic xlink:href="12859_2018_2508_Fig5_HTML" id="MO5"/></fig></p>
      <p>As shown in the plot, the models per hour rate increases linearly up to 1024 nodes, reaching a maximum measured rate of 1060 models/hour. This delivers over 4 petaflops to the deep learning engines used in the workflow (1024 NVIDIA K20X @ 3.95 TF = 4.045 PF, single precision).</p>
    </sec>
  </sec>
  <sec id="Sec16" sec-type="discussion">
    <title>Discussion</title>
    <p>This paper demonstrates the basic features of a scalable workflow framework for machine learning applied to problems in cancer research, but there are many additional features yet to investigate and develop.</p>
    <p>First, we plan to address the cyclical nature of our workflows and resolve the gap problem shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. We will modify the optimizers to be “streaming optimizers”, which will be capable of producing more sample points as soon as sample results are available, instead of one iteration at a time. This may take significant modification to existing optimizer codes, but the potential gain in utilization will be worth the effort.</p>
    <p>Second, we plan to support larger data-parallel machine learning models in our workflows. Swift/T already has support for parallel MPI jobs, etc. [<xref ref-type="bibr" rid="CR12">12</xref>] Our workflows will be able to use this feature to dynamically select the resource levels to apply to each model execution.</p>
    <p>Third, we are applying our experience using these optimizers to develop new optimizers for hyperparameter optimization. These optimizers will be compatible with the CANDLE/Supervisor framework and we will easily be able to measure their quality against existing techniques on large-scale problems.</p>
  </sec>
  <sec id="Sec17" sec-type="conclusion">
    <title>Conclusions</title>
    <p>Applying machine learning to cancer research is a promising approach in many aspects, including the benchmark problems used here, the RAS pathway, drug response, and treatment strategies. A significant challenge in this area is selecting and parameterizing the neural network models and software packages to be applied to these problems. In this paper, we described the relevant workflows in some detail. We then offered our solution by presenting CANDLE/Supervisor, a framework for rapidly testing hyperparameter optimization techniques for machine learning models, and showed how it is applied to several cancer benchmarks.</p>
    <p>The CANDLE/Supervisor framework offers multiple features to support machine learning in cancer research. First, is has a pluggable architecture, allowing users to easily substitute the optimizer or ML problem. Second, it is efficient, allowing use of large-scale resources, as described in “<xref rid="Sec11" ref-type="sec">Results</xref>” section. Third, it is portable, and allows researchers to benefit from the abundant computational concurrency available on many leadership-class systems. The software has also been tested on clusters and individual workstations. It is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/ECP-CANDLE">https://github.com/ECP-CANDLE</ext-link>.</p>
    <p>As the project progresses, the design of the Pilots will evolve, either by modification of the default model paremeters (within a certain class of ML networks) or via construction of new networks, which may in turn necessitate modifications at the Supervisor level. We intend to periodically release updated Pilots, synchronized with appropriate updates at all levels of the CANDLE/Supervisor.</p>
    <p>Cancer research is an important topic with significant societal impact. CANDLE/Supervisor allows research teams to leverage the most powerful high-performance computer systems in this problem space.</p>
  </sec>
</body>
<back>
  <ack>
    <sec id="d29e1020">
      <title>Funding</title>
      <p>This material is based upon work supported by the U.S. Department of Energy, Office of Science, under contract number DE-AC02-06CH11357. This research was supported by the Exascale Computing Project (17-SC-20-SC), a collaborative effort of the U.S. Department of Energy Office of Science and the National Nuclear Security Administration. This research used resources of the Argonne Leadership Computing Facility, which is a DOE Office of Science User Facility. This research used resources of the Argonne Leadership Computing Facility, which is a DOE Office of Science User Facility supported under Contract DE-AC02-06CH11357. This research used resources of the Oak Ridge Leadership Computing Facility at the Oak Ridge National Laboratory, which is supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC05-00OR22725. This research used resources of the National Energy Research Scientific Computing Center, a DOE Office of Science User Facility supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC02-05CH11231. This material is based upon work supported by the NIH (R01GM115839). Publication costs were funded by the CANDLE project under the Exascale Computing Project, a U.S. Department of Energy program.</p>
    </sec>
    <sec id="d29e1025">
      <title>Availability of data and materials</title>
      <p>All software is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/ECP-CANDLE">https://github.com/ECP-CANDLE</ext-link>.</p>
    </sec>
    <sec id="d29e1035">
      <title>About this supplement</title>
      <p>This article has been published as part of <italic>BMC Bioinformatics Volume 19 Supplement 18, 2018: Selected Articles from the Computational Approaches for Cancer at SC17 workshop</italic>. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-19-supplement-18">https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-19-supplement-18</ext-link>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>JW led the production of the manuscript and performed the experimental runs presented here. JW, JO, and NC architected the overall CANDLE/Supervisor system. PB led the use of mlrMBO. FX, JMY, CGC, and BVE developed and integrated CANDLE Benchmarks. RJ, JB, and MB performed supporting research and experimentation. TB and RS developed the CANDLE environment concept and supervised the effort. All authors read and approved the final version of this manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec>
      <title>Ethics approval and consent to participate</title>
      <p>Not applicable.</p>
    </sec>
    <sec>
      <title>Consent for publication</title>
      <p>Not applicable.</p>
    </sec>
    <sec>
      <title>Competing interests</title>
      <p>The authors declare that they have no competing interests.</p>
    </sec>
    <sec>
      <title>Publisher’s Note</title>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <mixed-citation publication-type="other">Biden J. Report on the Cancer Moonshot. 2016. <ext-link ext-link-type="uri" xlink:href="https://medium.com/cancer-moonshot/my-report-to-the-president-3c64b0dae863">https://medium.com/cancer-moonshot/my-report-to-the-president-3c64b0dae863</ext-link>. Accessed 1 Nov 2017.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <mixed-citation publication-type="other">Jia Y, Shelhamer E, Donahue J, Karayev S, Long J, Girshick R, Guadarrama S, Darrell T. Caffe: Convolutional architecture for fast feature embedding. arXiv preprint arXiv:1408.5093. 2014.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">Chollet F, et al.Keras. GitHub. 2015. <ext-link ext-link-type="uri" xlink:href="https://github.com/keras-team/keras">https://github.com/keras-team/keras</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <mixed-citation publication-type="other">Theano Development Team. Theano: A Python framework for fast computation of mathematical expressions. arXiv e-prints. abs/1605.02688. 2016.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <mixed-citation publication-type="other">Collobert R, Kavukcuoglu K, Farabet C. Torch7: A matlab-like environment for machine learning. In: BigLearn, NIPS Workshop.2011. <ext-link ext-link-type="uri" xlink:href="https://groups.google.com/forum/#!topic/torch7/BDsodrhHE10">https://groups.google.com/forum/#!topic/torch7/BDsodrhHE10</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <mixed-citation publication-type="other">Zhang H, Zheng Z, Xu S, Dai W, Ho Q, Liang X, Hu Z, Wei J, Xie P, Xing EP. Poseidon: An efficient communication architecture for distributed deep learning on GPU clusters. CoRR abs/1706.03292. 2017.</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <mixed-citation publication-type="other">Systems N. Neon. 2017. <ext-link ext-link-type="uri" xlink:href="https://github.com/NervanaSystems/neon">https://github.com/NervanaSystems/neon</ext-link>. Accessed 14 Sept 2017.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <mixed-citation publication-type="other">Abadi M, Agarwal A, Barham P, Brevdo E, Chen Z, Citro C, Corrado GS, Davis A, Dean J, Devin M, Ghemawat S, Goodfellow I, Harp A, Irving G, Isard M, Jia Y, Jozefowicz R, Kaiser L, Kudlur M, Levenberg J, Mané D, Monga R, Moore S, Murray D, Olah C, Schuster M, Shlens J, Steiner B, Sutskever I, Talwar K, Tucker P, Vanhoucke V, Vasudevan V, Viégas F, Vinyals O, Warden P, Wattenberg M, Wicke M, Yu Y, Zheng X. TensorFlow: Large-Scale Machine Learning on Heterogeneous Systems. 2015. Software available from tensorflow.org. <ext-link ext-link-type="uri" xlink:href="https://www.tensorflow.org/">https://www.tensorflow.org/</ext-link>. Accessed 1 Nov 2017.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Seide</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Agarwal</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Cntk: Microsoft’s open-source deep-learning toolkit</article-title>
        <source>Proceedings of the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. KDD ’16</source>
        <year>2016</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <mixed-citation publication-type="other">Van Essen B, Kim H, Pearce R, Boakye K, Chen B. Lbann: Livermore big artificial neural network hpc toolkit. In: Proceedings of the Workshop on Machine Learning in High-Performance Computing Environments. MLHPC ’15. New York: ACM: 2015. p. 5–156. <pub-id pub-id-type="doi">10.1145/2834892.2834897</pub-id>.</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <mixed-citation publication-type="other">Ozik J, Collier N, Wozniak JM, Spagnuolo C. From desktop to large-scale model exploration with Swift/T. In: Proc. Winter Simulation Conference. WinterSim: 2016. p. 206–20.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <mixed-citation publication-type="other">Wozniak JM, Armstrong TG, Wilde M, Katz DS, Lusk E, Foster IT. Swift/T: Scalable data flow programming for distributed-memory task-parallel applications. In: Proc. CCGrid. CCGrid: 2013. p. 95–102.</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <mixed-citation publication-type="other">Armstrong TG, Wozniak JM, Wilde M, Foster IT. Compiler techniques for massively scalable implicit task parallelism. In: Proc. SC. SC: 2014. p. 299–310.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <mixed-citation publication-type="other">Kaul P, Golovin D, Kochanski G. Hyperparameter tuning in Cloud Machine Learning Engine using Bayesian Optimization. 2017. <ext-link ext-link-type="uri" xlink:href="https://cloud.google.com/blog/big-data/2017/08/hyperparameter-tuning-in-cloud-machine-learning-engine-using-bayesian-optimization">https://cloud.google.com/blog/big-data/2017/08/hyperparameter-tuning-in-cloud-machine-learning-engine-using-bayesian-optimization</ext-link>. Accessed 1 Nov 2017.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pedregosa</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Varoquaux</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Gramfort</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Michel</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Thirion</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Grisel</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Blondel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Prettenhofer</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Weiss</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Dubourg</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Vanderplas</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Passos</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cournapeau</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Brucher</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Perrot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Duchesnay</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Scikit-learn: Machine learning in Python</article-title>
        <source>J Mach Learn Res</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>2825</fpage>
        <lpage>30</lpage>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <mixed-citation publication-type="other">Bergstra J, Yamins D, Cox DD. Making a science of model search: Hyperparameter optimization in hundreds of dimensions for vision architectures. In: Proc. of the 30th International Conference on Machine Learning, Volume 28. ICML: 2013. p. 115–23.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bergstra</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Komer</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Eliasmith</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Yamins</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Cox</surname>
            <given-names>DD</given-names>
          </name>
        </person-group>
        <article-title>Hyperopt: a python library for model selection and hyperparameter optimization</article-title>
        <source>Comput Sci Discov</source>
        <year>2015</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>014008</fpage>
        <pub-id pub-id-type="doi">10.1088/1749-4699/8/1/014008</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stanley</surname>
            <given-names>KO</given-names>
          </name>
          <name>
            <surname>Miikkulainen</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Evolving neural networks through augmenting topologies</article-title>
        <source>Evol Comput</source>
        <year>2002</year>
        <volume>10</volume>
        <issue>2</issue>
        <fpage>99</fpage>
        <lpage>127</lpage>
        <pub-id pub-id-type="doi">10.1162/106365602320169811</pub-id>
        <pub-id pub-id-type="pmid">12180173</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <mixed-citation publication-type="other">CodeReclaimers. NEAT-Python. GitHub. 2017. <ext-link ext-link-type="uri" xlink:href="https://github.com/CodeReclaimers/neat-python">https://github.com/CodeReclaimers/neat-python</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <mixed-citation publication-type="other">Claesen M, Simm J, Popovic D, Moreau Y, Moor BD. Easy hyperparameter search using optunity. CoRR abs/1412.1114. 2014.</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fortin</surname>
            <given-names>F-A</given-names>
          </name>
          <name>
            <surname>De Rainville</surname>
            <given-names>F-M</given-names>
          </name>
          <name>
            <surname>Gardner</surname>
            <given-names>M-A</given-names>
          </name>
          <name>
            <surname>Parizeau</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Gagné</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>DEAP: Evolutionary algorithms made easy</article-title>
        <source>J Mach Learn Res</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>2171</fpage>
        <lpage>5</lpage>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <mixed-citation publication-type="other">Bischl B, Richter J, Bossek J, Horn D, Thomas J, Lang M. mlrmbo: A modular framework for model-based optimization of expensive black-box functions. arXiv preprint arXiv:1703.03373. 2017.</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Bergstra JS, Bardenet R, Bengio Y, Kégl B. Algorithms for hyper-parameter optimization. In: Advances in Neural Information Processing Systems. NIPS: 2011. p. 2546–54.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Breiman</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Random forests</article-title>
        <source>Mach Learn</source>
        <year>2001</year>
        <volume>45</volume>
        <issue>1</issue>
        <fpage>5</fpage>
        <lpage>32</lpage>
        <pub-id pub-id-type="doi">10.1023/A:1010933404324</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <mixed-citation publication-type="other">Hutter F, Hoos H, Leyton-Brown K. Parallel algorithm configuration. Learn Intell Optim. 2012;:55–70.</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <mixed-citation publication-type="other">LeCun Y, Bengio Y, Hinton G. Deep learning. Nature. 2015; 521:436–44. <pub-id pub-id-type="doi">10.1038/nature14539</pub-id>.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Costello</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Heiser</surname>
            <given-names>LM</given-names>
          </name>
          <name>
            <surname>Georgii</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Gönen</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Menden</surname>
            <given-names>MP</given-names>
          </name>
          <name>
            <surname>Wang</surname>
            <given-names>NJ</given-names>
          </name>
          <name>
            <surname>Bansal</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ammad-ud-din</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hintsanen</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Khan</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Mpindi</surname>
            <given-names>J-P</given-names>
          </name>
          <name>
            <surname>Kallioniemi</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Honkela</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Aittokallio</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Wennerberg</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Community</surname>
            <given-names>ND</given-names>
          </name>
          <name>
            <surname>Collins</surname>
            <given-names>JJ</given-names>
          </name>
          <name>
            <surname>Gallahan</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Singer</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Saez-Rodriguez</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kaski</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gray</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>Stolovitzky</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>A community effort to assess and improve drug sensitivity prediction algorithms</article-title>
        <source>Nat Biotechnol</source>
        <year>2014</year>
        <volume>32</volume>
        <issue>12</issue>
        <fpage>1202</fpage>
        <lpage>12</lpage>
        <pub-id pub-id-type="doi">10.1038/nbt.2877</pub-id>
        <pub-id pub-id-type="pmid">24880487</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <mixed-citation publication-type="other">Thomee B, Shamma DA, Friedland G, Elizalde B, Ni K, Poland D, Borth D, Li L. The new data and new challenges in multimedia research. CoRR abs/1503.01817. 2015.</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <mixed-citation publication-type="other">American Cancer Society. 2016.</mixed-citation>
    </ref>
  </ref-list>
</back>
