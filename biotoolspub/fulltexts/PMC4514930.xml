<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4514930</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btv185</article-id>
    <article-id pub-id-type="publisher-id">btv185</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SPARSE: quadratic time simultaneous alignment and folding of RNAs without sequence-based heuristics</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Will</surname>
          <given-names>Sebastian</given-names>
        </name>
        <xref ref-type="aff" rid="btv185-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btv185-AFF2">
          <sup>2</sup>
        </xref>
        <xref ref-type="author-notes" rid="btv185-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Otto</surname>
          <given-names>Christina</given-names>
        </name>
        <xref ref-type="aff" rid="btv185-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="author-notes" rid="btv185-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Miladi</surname>
          <given-names>Milad</given-names>
        </name>
        <xref ref-type="aff" rid="btv185-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="author-notes" rid="btv185-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Möhl</surname>
          <given-names>Mathias</given-names>
        </name>
        <xref ref-type="aff" rid="btv185-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Backofen</surname>
          <given-names>Rolf</given-names>
        </name>
        <xref ref-type="aff" rid="btv185-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btv185-AFF3">
          <sup>3</sup>
        </xref>
        <xref ref-type="aff" rid="btv185-AFF4">
          <sup>4</sup>
        </xref>
        <xref ref-type="aff" rid="btv185-AFF5">
          <sup>5</sup>
        </xref>
        <xref ref-type="corresp" rid="btv185-COR1">*</xref>
      </contrib>
      <aff id="btv185-AFF1"><sup>1</sup>Bioinformatics, Department of Computer Science, University of Freiburg, Freiburg, Germany,</aff>
      <aff id="btv185-AFF2"><sup>2</sup>Bioinformatics, Department of Computer Science, University of Leipzig, Leipzig, Germany,</aff>
      <aff id="btv185-AFF3"><sup>3</sup>Centre for Biological Systems Analysis (ZBSA), University of Freiburg, Freiburg, Germany,</aff>
      <aff id="btv185-AFF4"><sup>4</sup>Centre for Non-coding RNA in Technology and Health, University of Copenhagen, Copenhagen, Denmark and</aff>
      <aff id="btv185-AFF5"><sup>5</sup>Centre for Biological Signalling Studies (BIOSS), University of Freiburg, Freiburg, Germany</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btv185-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="btv185-FN1">
        <p><sup>†</sup>The authors wish it to be known that, in their opinion, the first three authors should be regarded as Joint First Authors.</p>
      </fn>
      <fn id="btv185-FN2">
        <p>Associate Editor: John Hancock</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>01</day>
      <month>8</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>02</day>
      <month>4</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>02</day>
      <month>4</month>
      <year>2015</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>31</volume>
    <issue>15</issue>
    <fpage>2489</fpage>
    <lpage>2496</lpage>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>11</month>
        <year>2014</year>
      </date>
      <date date-type="rev-recd">
        <day>9</day>
        <month>3</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>25</day>
        <month>3</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2015. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2015</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by-nc/4.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> RNA-Seq experiments have revealed a multitude of novel ncRNAs. The gold standard for their analysis based on simultaneous alignment and folding suffers from extreme time complexity of <inline-formula><mml:math id="MM1"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>6</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Subsequently, numerous faster ‘Sankoff-style’ approaches have been suggested. Commonly, the performance of such methods relies on sequence-based heuristics that restrict the search space to optimal or near-optimal sequence alignments; however, the accuracy of sequence-based methods breaks down for RNAs with sequence identities below 60%. Alignment approaches like LocARNA that do not require sequence-based heuristics, have been limited to high complexity (<inline-formula><mml:math id="MM2"><mml:mo>≥</mml:mo></mml:math></inline-formula> quartic time).</p>
      <p><bold>Results:</bold> Breaking this barrier, we introduce the novel Sankoff-style algorithm ‘sparsified prediction and alignment of RNAs based on their structure ensembles (SPARSE)’, which runs in <italic>quadratic time</italic> without sequence-based heuristics. To achieve this low complexity, on par with sequence alignment algorithms, SPARSE features strong sparsification based on structural properties of the RNA ensembles. Following PMcomp, SPARSE gains further speed-up from lightweight energy computation. Although all existing lightweight Sankoff-style methods restrict Sankoff’s original model by disallowing loop deletions and insertions, SPARSE transfers the Sankoff algorithm to the lightweight energy model completely for the first time. Compared with LocARNA, SPARSE achieves similar alignment and better folding quality in significantly less time (speedup: 3.7). At similar run-time, it aligns low sequence identity instances substantially more accurate than RAF, which uses sequence-based heuristics.</p>
      <p><bold>Availability and implementation:</bold> SPARSE is freely available at <ext-link ext-link-type="uri" xlink:href="http://www.bioinf.uni-freiburg.de/Software/SPARSE">http://www.bioinf.uni-freiburg.de/Software/SPARSE</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>backofen@informatik.uni-freiburg.de</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btv185/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The majority of transcripts are non-coding RNAs (ncRNAs), which unlike mRNAs do not code for proteins. ncRNAs are associated with a large range of important cellular functions; furthermore, there is increasing evidence of pervasive transcription (e.g. <xref rid="btv185-B14" ref-type="bibr">Jacquier, 2009</xref>; <xref rid="btv185-B3" ref-type="bibr">Clark <italic>et al.</italic>, 2011</xref>). Particularly, up to 450 000 ncRNAs have been predicted in the human genome alone (<xref rid="btv185-B20" ref-type="bibr">Rederstorff <italic>et al.</italic>, 2010</xref>).</p>
    <p>Analyzing the huge amount of RNA sequences poses major challenges for bioinformatics; particularly, since the sequence of related ncRNAs is often conserved only weakly, while the RNAs can still share a strongly conserved consensus structure. Therefore, taking sequence and structure similarity into account is indispensable for ncRNA analysis (<xref rid="btv185-B27" ref-type="bibr">Will <italic>et al.</italic>, 2007</xref>; <xref rid="btv185-B25" ref-type="bibr">Torarinsson <italic>et al.</italic>, 2007</xref>; <xref rid="btv185-B23" ref-type="bibr">Shi <italic>et al.</italic>, 2009</xref>; <xref rid="btv185-B26" ref-type="bibr">Tseng <italic>et al.</italic>, 2009</xref>; <xref rid="btv185-B21" ref-type="bibr">Saito <italic>et al.</italic>, 2011</xref>; <xref rid="btv185-B19" ref-type="bibr">Parker <italic>et al.</italic>, 2011</xref>). However, accurate methods for this purpose have extreme computational costs.</p>
    <p>The gold standard for RNA alignment has been introduced by <xref rid="btv185-B22" ref-type="bibr">Sankoff (1985)</xref>. Because structure prediction and alignment of RNAs depend on each other, Sankoff’s approach solves the alignment and folding problem simultaneously. For two RNA sequences, it finds two energetically favorable structures of the same shape together with a good alignment that reflects the similarity of the structures. For this purpose, Sankoff composes its objective function from a sequence alignment score and the free energies of the two structures. Because of the extreme <inline-formula><mml:math id="MM3"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>6</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time complexity of this algorithm, numerous Sankoff-like strategies have been developed aiming to speed up Sankoff’s task, while preserving accuracy as much as possible.</p>
    <p>A major class of such methods utilizes information from sequence-based alignment to reduce the search space for the computationally much more expensive alignment and folding algorithm. This idea was introduced in <xref rid="btv185-B13" ref-type="bibr">Holmes (2005)</xref>, and later refined by <xref rid="btv185-B6" ref-type="bibr">Dowell and Eddy (2006)</xref> and <xref rid="btv185-B10" ref-type="bibr">Harmanci <italic>et al.</italic> (2007)</xref>. The latter restricts the alignment space to an envelope around the base matches, whose sequence alignment probabilities exceed a fixed cutoff. Generally, such approaches have to cope with the well-known fact that sequence alignment fails for sequence identities below 60% (<xref rid="btv185-B7" ref-type="bibr">Gardner <italic>et al.</italic>, 2005</xref>). Consequently, sequence alignments can provide hints at the optimal structure-based alignment, but are potentially far-off. Moreover, even with such improvements Sankoff-like methods remain too expensive for large analysis tasks like clustering putative ncRNAs in large datasets, e.g. the entire human transcriptome or even meta-genomics data.</p>
    <p>PMcomp (<xref rid="btv185-B12" ref-type="bibr">Hofacker <italic>et al.</italic>, 2004</xref>) suggested a fundamentally different route to faster RNA alignment. It introduced a new Sankoff-like scoring model that enables lightweight computation. For this purpose, it employs a base pair-based energy model instead of the original loop-based energy model. Furthermore, PMcomp simplifies Sankoff’s model by predicting only a single consensus structure. Tools like LocARNA (<xref rid="btv185-B27" ref-type="bibr">Will <italic>et al.</italic>, 2007</xref>), FoldAlignM (<xref rid="btv185-B25" ref-type="bibr">Torarinsson <italic>et al.</italic>, 2007</xref>) and LocARNA-P (<xref rid="btv185-B28" ref-type="bibr">Will <italic>et al.</italic>, 2012</xref>) build on the PMcomp model, but additionally sparsify the folding spaces of both RNAs, resulting in <inline-formula><mml:math id="MM4"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time complexity. CARNA (<xref rid="btv185-B24" ref-type="bibr">Sorescu <italic>et al.</italic>, 2012</xref>) extends the PMcomp model to pseudoknot structures. RAF (<xref rid="btv185-B5" ref-type="bibr">Do <italic>et al.</italic>, 2008</xref>) combined the ideas of <xref rid="btv185-B10" ref-type="bibr">Harmanci <italic>et al.</italic> (2007)</xref> and <xref rid="btv185-B12" ref-type="bibr">Hofacker <italic>et al.</italic> (2004)</xref>, resulting in a lightweight Sankoff-variant with sequence-based speed up.</p>
    <sec>
      <title>1.1 Contributions</title>
      <p>In this work, we introduce the novel lightweight Sankoff-style approach SPARSE (sparsified prediction and alignment of RNAs based on their structure ensembles) with quadratic time complexity. Achieving the same complexity as sequence alignment with SPARSE is a breakthrough for RNA analysis, because this profound performance gain works without sequence-based heuristics. On the contrary, it is purely based on information from the RNAs’ structural ensembles. Consequently, the technique is applicable without compromising the alignment quality in the low sequence identity zone.</p>
      <p>Going beyond LocARNA, which sparsifies based on base pair probabilities, SPARSE additionally sparsifies based on conditional probabilities of bases and base pairs within loops (<xref rid="btv185-B18" ref-type="bibr">Otto <italic>et al.</italic>, 2014</xref>). The latter results in a quadratic time improvement over LocARNA, which already improved by a quadratic factor over Sankoff’s algorithm; this results in the quadratic time complexity of SPARSE, a <italic>quartic speedup</italic> over the original Sankoff algorithm.</p>
      <p>Concretely, SPARSE sparsifies the novel Sankoff-style algorithm prediction and alignment of RNAs based on their structure ensembles (PARSE), which—like PMcomp—supports lightweight computation. Going beyond PMcomp, it predicts two potentially different structures for the two RNA sequences, supporting insertions and deletions of loops. The dependencies between these structures and the alignment are exactly the same as in the original problem formulation of Sankoff. Thus, the increased flexibility of PARSE over the PMcomp-like previous RNA alignment approaches is an important contribution by itself. We show that the novel problem can be efficiently solved by dynamic programming. Moreover, we present a model and algorithm for affine gap costs that distinguishes insertions and deletions of single bases and entire loops.</p>
      <p>Based on SPARSE, we furthermore develop a fast <italic>multiple</italic> RNA alignment approach. In our benchmarks, compared with LocARNA, the much faster SPARSE computes alignments of similar quality with improved folding quality. Compared with RAF (<xref rid="btv185-B5" ref-type="bibr">Do <italic>et al.</italic>, 2008</xref>), SPARSE is similarly fast (speedup over LocARNA of 4.2 versus 3.7) and has the same time complexity, but provides superior alignment quality in the hard case of low sequence identity.</p>
    </sec>
  </sec>
  <sec>
    <title>2 Methods</title>
    <p><xref ref-type="fig" rid="btv185-F1">Figure 1</xref> illustrates the subsequent fundamental preliminaries.
<fig id="btv185-F1" position="float"><label>Fig. 1.</label><caption><p>Example <italic>alignment</italic>
<inline-formula><mml:math id="MM5"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula> of two <italic>RNA sequences A</italic> and <italic>B</italic> together with (<italic>non-crossing</italic>) <italic>structures</italic>
<inline-formula><mml:math id="MM6"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM7"><mml:mrow><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>4</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>5</mml:mn></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. We highlight the positions in the <italic>loop closed by a</italic><sub>1</sub> and in the <italic>loop closed by b</italic><sub>2</sub><italic>.</italic> The base pair <italic>a</italic><sub>1</sub> is the <italic>parent</italic> of the highlighted positions in <italic>A</italic> and of <italic>a</italic><sub>2</sub>. The base pair <italic>a</italic><sub>1</sub> closes a 2<italic>-loop</italic>; <italic>a</italic><sub>2</sub>, a 1<italic>-loop</italic> and <italic>a</italic><sub>3</sub>, a <italic>multiloop</italic>. The latter is a 3<italic>-loop</italic>, since <italic>a</italic><sub>3</sub> has two <italic>inner</italic> base pairs (<italic>a</italic><sub>4</sub> and <italic>a</italic><sub>5</sub>.) Note that the <italic>structure alignment triple</italic>
<inline-formula><mml:math id="MM8"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> covers the <italic>external</italic> base pairs <inline-formula><mml:math id="MM9"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM10"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula> as well as the inner base pairs of the two multiloops. Finally, <inline-formula><mml:math id="MM11"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<italic>deletes the entire</italic> 2<italic>-loop of a</italic><sub>1</sub> and <italic>inserts the entire</italic> 2<italic>-loop of b</italic><sub>2</sub></p></caption><graphic xlink:href="btv185f1p"/></fig>
</p>
    <sec>
      <title/>
      <sec>
        <title>RNAs</title>
        <p>An <italic>RNA sequence A</italic> is a string over the alphabet <inline-formula><mml:math id="MM12"><mml:mrow><mml:mo>{</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>U</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with <italic>length</italic>
<inline-formula><mml:math id="MM13"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>. We denote the base at the <italic>i</italic>-th position of <italic>A</italic> by <inline-formula><mml:math id="MM14"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>; the substring from position <italic>i</italic> to <italic>j</italic>, by <inline-formula><mml:math id="MM15"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>; such substrings of RNA sequences are subsequently called <italic>subsequences</italic>. A <italic>base pair a of A</italic> is a pair <inline-formula><mml:math id="MM16"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="MM17"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>≤</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. A <italic>non-crossing RNA structure </italic><inline-formula><mml:math id="MM18"><mml:mi>S</mml:mi></mml:math></inline-formula><italic> of A</italic>, in the following called <italic>structure</italic>, is a set of base pairs, where each two different base pairs (<italic>i</italic>, <italic>j</italic>) and <inline-formula><mml:math id="MM19"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <inline-formula><mml:math id="MM20"><mml:mi>S</mml:mi></mml:math></inline-formula> do not share any end, i.e. <inline-formula><mml:math id="MM21"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM22"><mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> are pairwise different, and base pairs of <inline-formula><mml:math id="MM23"><mml:mi>S</mml:mi></mml:math></inline-formula> do not cross, i.e. there are no <inline-formula><mml:math id="MM24"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="MM25"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. For reasons of simplicity, we introduce a pseudo base pair <inline-formula><mml:math id="MM26"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which formally closes the external loop of <italic>A</italic>. Although <inline-formula><mml:math id="MM27"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> does not satisfy <inline-formula><mml:math id="MM28"><mml:mrow><mml:mn>1</mml:mn><mml:mo> ≤ </mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>&lt;</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo> ≤ </mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula>, it is otherwise handled like a base pair of <italic>A</italic>. The position <italic>k</italic> of <italic>A</italic> is <italic>paired</italic> according to <inline-formula><mml:math id="MM29"><mml:mi>S</mml:mi></mml:math></inline-formula>, iff there exists <inline-formula><mml:math id="MM30"><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> such that <inline-formula><mml:math id="MM31"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="MM32"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>. Otherwise <italic>k</italic> is <italic>unpaired</italic>.</p>
      </sec>
      <sec>
        <title>Loops</title>
        <p>For any position <italic>k</italic> of <italic>A</italic>, we define the <italic>parent of k in </italic><inline-formula><mml:math id="MM33"><mml:mi>S</mml:mi></mml:math></inline-formula>, written <inline-formula><mml:math id="MM34"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, as the <inline-formula><mml:math id="MM35"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> with <italic>i</italic> &lt; <italic>k</italic> &lt; <italic>j</italic> such that there does not exist any <inline-formula><mml:math id="MM36"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="MM37"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. Analogously, the <italic>parent of a base pair a in </italic><inline-formula><mml:math id="MM38"><mml:mi>S</mml:mi></mml:math></inline-formula>, written <inline-formula><mml:math id="MM39"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is the parent of <inline-formula><mml:math id="MM40"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula> (or, equivalently, the parent of <inline-formula><mml:math id="MM41"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula>). A position <italic>k</italic> in <italic>A</italic> or base pair <inline-formula><mml:math id="MM42"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> is <italic>in the loop closed by a</italic> iff <inline-formula><mml:math id="MM43"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>external</italic> according to <inline-formula><mml:math id="MM44"><mml:mi>S</mml:mi></mml:math></inline-formula> iff <inline-formula><mml:math id="MM45"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, otherwise <italic>internal</italic>. Furthermore, for a base pair <inline-formula><mml:math id="MM46"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>, the <italic>loop closed by a</italic> consists of the positions <inline-formula><mml:math id="MM47"><mml:mrow><mml:msub><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. In a structure <inline-formula><mml:math id="MM48"><mml:mi>S</mml:mi></mml:math></inline-formula>, a <italic>k-loop</italic> is a loop with closing base pair <italic>a</italic> and <italic>k</italic>−1 <italic>inner base pairs</italic>
<inline-formula><mml:math id="MM49"><mml:mrow><mml:mi>a</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM50"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula>. A <italic>multiloop</italic> is a <italic>k</italic>-loop where <italic>k</italic> &gt; 2.</p>
      </sec>
      <sec>
        <title>Alignments</title>
        <p>An <italic>alignment </italic><inline-formula><mml:math id="MM51"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula><italic> of RNA sequences A and B</italic> consists of a set of edges written as pairs (<italic>i</italic>, <italic>k</italic>), where <italic>i</italic> is a position in <inline-formula><mml:math id="MM51a"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula>, and <italic>k</italic> a position in <italic>B</italic>. Alignment edges do not <italic>cross</italic>, i.e. for all <inline-formula><mml:math id="MM52"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo>:</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>⇒</mml:mo><mml:mi>j</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM53"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>⇔</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Usually, we consider alignments <inline-formula><mml:math id="MM54"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula> together with structures <inline-formula><mml:math id="MM55"><mml:mi>S</mml:mi></mml:math></inline-formula> of <italic>A</italic> and <inline-formula><mml:math id="MM56"><mml:mi>T</mml:mi></mml:math></inline-formula> of <italic>B</italic>, forming the triple <inline-formula><mml:math id="MM57"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
        <p>The position <italic>i</italic> of <italic>A</italic> is called <italic>deleted by </italic><inline-formula><mml:math id="MM58"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula>, iff there is no <italic>k</italic> of <italic>B</italic> s.t. <inline-formula><mml:math id="MM59"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula>
<italic>k</italic> of <italic>B</italic> is <italic>inserted by </italic><inline-formula><mml:math id="MM60"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula>, iff there is no <italic>i</italic> of <italic>A</italic> s.t. <inline-formula><mml:math id="MM61"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:mrow></mml:math></inline-formula>. Positions that are neither deleted nor inserted by <inline-formula><mml:math id="MM62"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula> are <italic>covered by </italic><inline-formula><mml:math id="MM63"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula><italic>.</italic> Analogously, we call a base pair <inline-formula><mml:math id="MM64"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>
<italic>covered by </italic><inline-formula><mml:math id="MM65"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, iff there is a base pair <inline-formula><mml:math id="MM66"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>, s.t. <inline-formula><mml:math id="MM67"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula> symmetrically, we define <italic>covered by </italic><inline-formula><mml:math id="MM68"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for base pairs <inline-formula><mml:math id="MM69"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>. A base pair (<italic>i</italic>, <italic>j</italic>) is called <italic>inserted</italic> (<italic>deleted</italic>), iff <italic>i</italic> and <italic>j</italic> are <italic>inserted</italic> (<italic>deleted</italic>), respectively. <inline-formula><mml:math id="MM70"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula>
<italic>matches two positions i and k to each other</italic>, iff <inline-formula><mml:math id="MM71"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:mrow></mml:math></inline-formula>. Two base pairs are <italic>matched to each other by </italic><inline-formula><mml:math id="MM72"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, iff <inline-formula><mml:math id="MM73"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula> matches their left and right ends to each other.</p>
        <p>For 2-loops, we define the notion of insertion or deletion of entire loops. <inline-formula><mml:math id="MM74"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> deletes (inserts) the entire 2-loop closed by the base pair <inline-formula><mml:math id="MM75"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="MM76"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, iff it deletes (inserts) all bases in <inline-formula><mml:math id="MM77"><mml:mrow><mml:msub><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<inline-formula><mml:math id="MM78"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively.</p>
      </sec>
    </sec>
    <sec>
      <title>2.1 Lightweight Sankoff-style alignment</title>
      <p>Given two RNA sequences <italic>A</italic> and <italic>B</italic> (of respective sizes <italic>n</italic> and <italic>m</italic>), Sankoff’s problem of simultaneous alignment and folding (<xref rid="btv185-B22" ref-type="bibr">Sankoff, 1985</xref>) asks for an alignment and RNA structures <inline-formula><mml:math id="MM79"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM80"><mml:mi>T</mml:mi></mml:math></inline-formula> for both sequences that simultaneously optimize a score of the form ‘energy of <inline-formula><mml:math id="MM81"><mml:mi>S</mml:mi></mml:math></inline-formula> + energy of <inline-formula><mml:math id="MM82"><mml:mi>T</mml:mi></mml:math></inline-formula> + sequence edit distance’ in a loop-based energy model (<xref rid="btv185-B15" ref-type="bibr">Mathews <italic>et al.</italic>, 1999</xref>). Importantly, the alignment <inline-formula><mml:math id="MM83"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula> and the structures <inline-formula><mml:math id="MM84"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM85"><mml:mi>T</mml:mi></mml:math></inline-formula> are not independent of each other: Sankoff requires that all external base pairs and interior base pairs of multiloops of both RNAs are covered by <inline-formula><mml:math id="MM86"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Moreover, <xref rid="btv185-B22" ref-type="bibr">Sankoff (1985)</xref> requires that any <italic>k</italic>-loop (<italic>k</italic> &gt; 2) is ‘<italic>aligned with a single k-loop in the other structure</italic><italic>’</italic>, whereas 2-loops can be flexibly ‘<italic>inserted or deleted in toto</italic><italic>’</italic> to align stems of different length. Due to these conditions, aligned multiloops are of the same degree, which preserves the shape [called <italic>branching configuration</italic> in <xref rid="btv185-B22" ref-type="bibr">Sankoff (1985)</xref>] of the RNA structures.</p>
      <sec>
        <title>2.1.1 PMcomp—a lightweight and simplified Sankoff variant</title>
        <p>PMcomp (<xref rid="btv185-B12" ref-type="bibr">Hofacker <italic>et al.</italic>, 2004</xref>) transfers Sankoff’s idea to a <italic>lightweight</italic> energy model based on base pairs, which allows much faster computation. However, PMcomp simplifies the problem even more by introducing a one-to-one dependency between the predicted structures for <inline-formula><mml:math id="MM87"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM88"><mml:mi>T</mml:mi></mml:math></inline-formula>. In consequence, PMcomp predicts only a single consensus structure, whereas Sankoff much more flexibly predicts two <italic>compatible</italic> structures of <italic>A</italic> and <italic>B</italic>. We are going to show that PMcomp’s second simplification (namely, to predict only the consensus structure) is not required for fast computation and even more has adverse effects.</p>
        <p>In the simplified energy model of PMcomp, the energy of a structure is the sum of energy-like weights <inline-formula><mml:math id="MM89"><mml:mrow><mml:msub><mml:mi>Ψ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> of the single base pairs in each structure. Because PMcomp defines <inline-formula><mml:math id="MM90"><mml:mrow><mml:msub><mml:mi>Ψ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> as log odds of the base pair probability <italic>p<sub>ij</sub></italic> (<xref rid="btv185-B17" ref-type="bibr">McCaskill, 1990</xref>), the model effectively multiplies single base pair probabilities. Here, PMcomp follows the general idea to simplify probability calculations by assuming independence. Otherwise PMcomp, like the original Sankoff algorithm, optimizes a score composed of the sequence similarity and energies.</p>
        <p>We rephrase the <italic>alignment and folding score</italic> of PMcomp, which is assigned to an alignment <inline-formula><mml:math id="MM91"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula> and RNA structures <inline-formula><mml:math id="MM92"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM93"><mml:mi>T</mml:mi></mml:math></inline-formula>, as
<disp-formula id="btv185-M1"><label>(1)</label><mml:math id="MM94"><mml:mtable><mml:mtr><mml:mtd><mml:maligngroup/><mml:mtext>score</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msubsup></mml:mrow></mml:mstyle><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:malignmark/><mml:mtext> </mml:mtext><mml:mo>+</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:mrow></mml:munder><mml:mi>σ</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mtext>indel</mml:mtext></mml:mrow></mml:msub><mml:mi>γ</mml:mi><mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
where <italic>σ</italic> is the base similarity, <italic>γ</italic> is the gap penalty (<inline-formula><mml:math id="MM95"><mml:mrow><mml:mi>γ</mml:mi><mml:mo> ≤ </mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>) and <inline-formula><mml:math id="MM96"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:mtext>indel</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the number of insertion and deletions in <inline-formula><mml:math id="MM97"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula>.</p>
        <p>Due to its second simplification of Sankoff, PMcomp maximizes this score only over the <inline-formula><mml:math id="MM98"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that cover all base pairs in <inline-formula><mml:math id="MM99"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM100"><mml:mi>T</mml:mi></mml:math></inline-formula>. This is a strong restriction compared with the more expressive Sankoff algorithm, which requires only that the interior base pairs of multiloops and the external base pairs are covered by <inline-formula><mml:math id="MM101"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, while Sankoff allows flexibly aligning stems of different lengths due to insertion and deletion of 2-loops, PMcomp cannot handle loop deletions and insertions at all.</p>
      </sec>
      <sec>
        <title>2.1.2 PARSE—lightweight and flexible folding and alignment</title>
        <p>In the novel algorithm PARSE, we overcome the limitations of PMcomp, maximizing the score of <xref ref-type="disp-formula" rid="btv185-M1">Equation (1)</xref> with the full flexibility of Sankoff’s specification in terms of dependencies between alignment and predicted structures. Here, we paraphrase Sankoff’s constraints using our notation and terminology.<statement><title>D<sc>efinition</sc> 1</title><p>(Sankoff’s Dependencies Between Alignment and Structures). Let <italic>A</italic> and <italic>B</italic> be sequences; <inline-formula><mml:math id="MM102"><mml:mi>S</mml:mi></mml:math></inline-formula> of <italic>A</italic> and <inline-formula><mml:math id="MM103"><mml:mi>T</mml:mi></mml:math></inline-formula> of <italic>B</italic>, structures; and <inline-formula><mml:math id="MM104"><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:math></inline-formula>, an alignment of <italic>A</italic> and <italic>B</italic>. <inline-formula><mml:math id="MM105"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a <italic>structure alignment triple of A and B</italic> (satisfying Sankoff’s dependencies), iff for each base pair <inline-formula><mml:math id="MM106"><mml:mrow><mml:mi>a</mml:mi><mml:mtext> </mml:mtext><mml:mo>∈</mml:mo><mml:mtext>S</mml:mtext></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM107"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula>
<list list-type="order"><list-item><p><inline-formula><mml:math id="MM108"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic> covers a or deletes the entire loop of </italic><inline-formula><mml:math id="MM109"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>S</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p><inline-formula><mml:math id="MM110"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula><italic> covers b or inserts the entire loop of </italic><inline-formula><mml:math id="MM111"><mml:mrow><mml:msub><mml:mrow><mml:mtext>parent</mml:mtext></mml:mrow><mml:mi>T</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:math></inline-formula></p></list-item></list></p><p><italic>in</italic> (1) <italic>and</italic> (2)<italic>, the deleted or inserted loops have to be</italic> 2<italic>-loops.</italic></p></statement></p>
        <p><xref ref-type="fig" rid="btv185-F1">Figure 1</xref> shows a structure alignment triple. The definition makes explicit that base pairs are inserted or deleted only together with their entire 2-loop. This enables predicting stems of different length and align them to each other. At the same time, the two predicted structures cannot differ arbitrarily, but must have the same shape.</p>
      </sec>
      <sec>
        <title>2.1.3 Realistic gap cost</title>
        <p>Because PARSE supports insertion and deletion (indel) of entire loops, which—unlike base indels—correspond to elongation or shortening of stems in the RNA structure, it is reasonable to distinguish the different evolutionary events of base indel and loop indel in our scoring function. Technically, we introduce two different gap penalties <inline-formula><mml:math id="MM112"><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for gaps due to base indels and <inline-formula><mml:math id="MM113"><mml:mrow><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for gaps due to loop indels. To produce biologically relevant alignments, we extend the above score to support affine gap costs. The different nature of loop indels and base indels suggests two different gap opening penalties <inline-formula><mml:math id="MM114"><mml:mrow><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM115"><mml:mrow><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Thus, in addition to the regular gap opening costs for base indels, we penalize the change of structure by loop indels with a specific loop gap opening cost.</p>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Algorithms</title>
    <p>In general, the structures <inline-formula><mml:math id="MM116"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM117"><mml:mi>T</mml:mi></mml:math></inline-formula> are selected from respective sets of possible base pairs <inline-formula><mml:math id="MM118"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM119"><mml:mi>Q</mml:mi></mml:math></inline-formula> of sizes <italic>N</italic> and <italic>M</italic>. For example, <inline-formula><mml:math id="MM120"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM121"><mml:mi>Q</mml:mi></mml:math></inline-formula> could consist of all canonical base pairs, but subsequently we are going to sparsify those sets. In our context, we generally assume that <inline-formula><mml:math id="MM122"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM123"><mml:mi>Q</mml:mi></mml:math></inline-formula> are sparse subsets of all possible base pairs. For example, in LocARNA (<xref rid="btv185-B27" ref-type="bibr">Will <italic>et al.</italic>, 2007</xref>), <inline-formula><mml:math id="MM124"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM125"><mml:mi>Q</mml:mi></mml:math></inline-formula> consist of—in the sequence length—only linearly many base pairs due to filtering by a fixed threshold probability.</p>
    <sec>
      <title>3.1 A sparsification perspective on PMcomp</title>
      <p>Originally, PMcomp was presented (<xref rid="btv185-B12" ref-type="bibr">Hofacker <italic>et al.</italic>, 2004</xref>) without sparsification in mind, defining dynamic programming matrices indexed by the ends of the aligned subsequences <inline-formula><mml:math id="MM126"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i..</mml:mi><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM127"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mi>..l</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. To make the correspondence to base pairs in <inline-formula><mml:math id="MM128"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM129"><mml:mi>Q</mml:mi></mml:math></inline-formula> explicit, we define matrix entries <inline-formula><mml:math id="MM130"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that represent the scores of matching the two base pairs <italic>a</italic> and <italic>b</italic> and aligning the two enclosed subsequences. Each <inline-formula><mml:math id="MM131"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is computed from entries <inline-formula><mml:math id="MM132"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> that store the best score of any two structures and alignment of subsequences <inline-formula><mml:math id="MM133"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1..</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM134"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1..</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, where all base pairs in <inline-formula><mml:math id="MM135"><mml:mi>S</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM136"><mml:mi>T</mml:mi></mml:math></inline-formula> are covered by <inline-formula><mml:math id="MM137"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; subsequence scores are defined in the appendix.</p>
      <p>The PMcomp algorithm is defined by recurrences for all <inline-formula><mml:math id="MM138"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>i</italic> (<inline-formula><mml:math id="MM139"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula>), and <italic>k</italic> (<inline-formula><mml:math id="MM140"><mml:mrow><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula>) (Recall that we simplified the score; still, the original recursions are easily obtained by adding the base pair match contribution <inline-formula><mml:math id="MM141"><mml:mrow><mml:mi>τ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="MM142"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.):
<disp-formula><mml:math id="MM143"><mml:mtable><mml:mtr><mml:mtd><mml:maligngroup/><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>γ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>γ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>Q</mml:mi><mml:mtext> </mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtext>s.t.  </mml:mtext><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mtext>  </mml:mtext><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:munder></mml:mstyle><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<disp-formula><mml:math id="MM144"><mml:mtable><mml:mtr><mml:mtd><mml:maligngroup/><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:malignmark/><mml:mo>=</mml:mo><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:maligngroup/><mml:malignmark/><mml:mtext> </mml:mtext><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mi>a</mml:mi><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mi>b</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
The score of the best pair of consensus structure and alignment of <italic>A</italic> and <italic>B</italic> is <inline-formula><mml:math id="MM144a"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; recall that <inline-formula><mml:math id="MM145"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM146"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denote the pseudo-base pairs covering the entire sequences <italic>A</italic> and <italic>B</italic>. The alignment and structures themselves are obtained by traceback.</p>
      <p>Notably, these recursions can be evaluated in <inline-formula><mml:math id="MM147"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space—i.e. space depends on the respective lengths of <italic>A</italic> and <italic>B</italic> and sizes <italic>N</italic> and <italic>M</italic> of the sets <inline-formula><mml:math id="MM148"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM149"><mml:mi>Q</mml:mi></mml:math></inline-formula> of considered base pairs. This space complexity is realized in the same way as in LocARNA: at each time, only one <inline-formula><mml:math id="MM150"><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> matrix needs to be represented in space, since one matrix <inline-formula><mml:math id="MM151"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> recurses only to itself and <inline-formula><mml:math id="MM152"><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula>, but does not depend on other <inline-formula><mml:math id="MM153"><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> matrices. Even the traceback does not require to store all <inline-formula><mml:math id="MM154"><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> matrices, because recomputing the matrices on the trace is comparably inexpensive.</p>
      <p>The time complexity is dominated by computing the <inline-formula><mml:math id="MM155"><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> matrices. Evaluating a single matrix <inline-formula><mml:math id="MM156"><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula> takes <inline-formula><mml:math id="MM157"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. Because, the straightforward evaluation of PMcomp’s recursions computes <italic>NM</italic> such matrices, this results in <inline-formula><mml:math id="MM158"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mi>N</mml:mi><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>M</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Assuming a linear number of base pairs in <inline-formula><mml:math id="MM159"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM160"><mml:mi>Q</mml:mi></mml:math></inline-formula> (as it holds for LocARNA), this yields <inline-formula><mml:math id="MM161"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time.</p>
      <p>However, this evaluation strategy would consider certain subsequences repeatedly, namely as prefixes of different loops, albeit their scores are identical: by definition, the matrices <inline-formula><mml:math id="MM162"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM163"><mml:mrow><mml:msup><mml:mover accent="true"><mml:mi>M</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> share common entries, if their base pairs share the same left ends, i.e. <inline-formula><mml:math id="MM164"><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>2</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM165"><mml:mrow><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>2</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup></mml:mrow></mml:math></inline-formula>; thus, LocARNA combines the computation of such matrices. Although (assuming <italic>N</italic> and <italic>M</italic> are linearly bound) this does not change the complexity, it substantially speeds up the computation in practice.</p>
    </sec>
    <sec>
      <title>3.2 The PARSE core algorithm</title>
      <p>Alignment and folding with the original structure and alignment dependencies of Sankoff requires substantially different recursions. However, we keep the presentation as uniform as possible to our presentation of the PMcomp algorithm. Most obviously, the deletion and insertion of loops requires additional matrices (<inline-formula><mml:math id="MM166"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM167"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>). More subtly, but centrally, we change the definition of matrix entries for pairs of base pairs. Where the PMcomp algorithm defines <inline-formula><mml:math id="MM168"><mml:mrow><mml:mover accent="true"><mml:mi>D</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the score of a consensus structure and an alignment matching <italic>a</italic> and <italic>b</italic>, PARSE requires optimum scores of structure alignment triples of the subsequences between (and excluding) the ends of <italic>a</italic> and <italic>b</italic> without assuming the match of those base pairs; these scores are stored in entries <italic>D</italic>(<italic>a</italic>,<italic>b</italic>). We recursively define entries for all <inline-formula><mml:math id="MM169"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula>, <italic>i</italic>
<inline-formula><mml:math id="MM170"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <italic>k</italic>
<inline-formula><mml:math id="MM171"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; <xref ref-type="fig" rid="btv185-F2">Figure 2</xref> visualizes these recursions.
<disp-formula><mml:math id="MM173"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="MM174"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>γ</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>γ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:munder></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mtext> </mml:mtext><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mtext> </mml:mtext><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>σ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>R</mml:mtext></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="MM175"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>γ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>γ</mml:mi><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msubsup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula><mml:math id="MM176"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>γ</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mi>γ</mml:mi><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math></disp-formula>
<fig id="btv185-F2" position="float"><label>Fig. 2.</label><caption><p>Recursions of the novel lightweight alignment algorithm PARSE</p></caption><graphic xlink:href="btv185f2p"/></fig>
</p>
      <p>The <inline-formula><mml:math id="MM173a"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> [resp. <inline-formula><mml:math id="MM174a"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>] matrix correspond to the new case of a loop insertion into <italic>A</italic> (resp. <inline-formula><mml:math id="MM175a"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The additional cases and matrices do not add to the time or space complexity over the PMcomp algorithm; in particular, the space and time for the <inline-formula><mml:math id="MM176a"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM177"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> matrices is dominated by the <italic>M</italic> matrices. Therefore, analogous arguments let us conclude that, assuming LocARNA-style ensemble-based sparsification, the algorithm runs (like LocARNA) in quadratic space and quartic time.</p>
      <sec>
        <title>Affine gap cost</title>
        <p>We add the affine gap costs of the previous section without increasing the complexity; in parallel to distinguishing opening costs for base and loop gaps, we apply different gap penalties. First, similar to the algorithm of <xref rid="btv185-B8" ref-type="bibr">Gotoh (1982)</xref>, we introduce matrices with entries <inline-formula><mml:math id="MM178"><mml:mrow><mml:msup><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM179"><mml:mrow><mml:msup><mml:mi>F</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; these contain best scores of structure alignment triples like the entries <inline-formula><mml:math id="MM180"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, however, constrain the alignments to delete <inline-formula><mml:math id="MM181"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and insert <inline-formula><mml:math id="MM182"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. Thus, we define
<disp-formula><mml:math id="MM183"><mml:mrow><mml:msup><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
for deletion, define <inline-formula><mml:math id="MM184"><mml:mrow><mml:msup><mml:mi>F</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> analogously for insertion, and replace the deletion and insertion cases of the <italic>M</italic>-recursion of PARSE by <inline-formula><mml:math id="MM185"><mml:mrow><mml:msup><mml:mi>E</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM186"><mml:mrow><mml:msup><mml:mi>F</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. Second, we extend the recursions for <inline-formula><mml:math id="MM187"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM188"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula>. We show the case of <inline-formula><mml:math id="MM189"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula>, since <inline-formula><mml:math id="MM190"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> is analogous. It suffices to make explicit the case of recursing to <inline-formula><mml:math id="MM191"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which extends an already open gap, and add loop gap opening penalty <inline-formula><mml:math id="MM192"><mml:mrow><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> in the general case of recursing to <inline-formula><mml:math id="MM193"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.
<disp-formula><mml:math id="MM194"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle displaystyle="true"><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>P</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>R</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder></mml:mstyle><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mo>+</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msubsup><mml:mi>Ψ</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mi>β</mml:mi><mml:mrow><mml:mtext>loop</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
Notably, these extensions do not change the time or space complexity.</p>
      </sec>
    </sec>
    <sec>
      <title>3.3 SPARSE—folding and alignment of RNA with ensemble-based sparsification</title>
      <p>This section describes the sparsification of PARSE, resulting in SPARSE, which achieves quadratic time complexity. Instead of filling the whole matrix <italic>M<sup>ab</sup></italic> for each pair of base pairs <italic>a</italic>, <italic>b</italic>, we are going to skip matrix cells that do not contribute to probable solutions. To define the probable structures and alignments, and thus determine the ‘relevant’ entries of the matrix, we define several probabilities of structure elements in the structure ensemble of a sequence <italic>A</italic>. For defining these probabilities, we assume that the structures of an RNA sequence <italic>A</italic> are Boltzmann-distributed in the structure ensemble, where RNA energy is given by a loop-based energy model.
<list list-type="bullet"><list-item><p><inline-formula><mml:math id="MM195"><mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:msub><mml:mo>∑</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="normal">∋</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mi>Pr</mml:mi><mml:mo>⁡</mml:mo></mml:mrow></mml:mstyle><mml:mo stretchy="false">[</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> denotes the probability that a structure in the ensemble of <italic>A</italic> contains the base pair (<italic>i</italic>, <italic>j</italic>).</p></list-item><list-item><p><inline-formula><mml:math id="MM196"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, denotes the joint probability that for a structure <inline-formula><mml:math id="MM197"><mml:mi>S</mml:mi></mml:math></inline-formula> in the ensemble of <italic>A</italic>, (<italic>i</italic>, <italic>j</italic>) is a base pair of <inline-formula><mml:math id="MM198"><mml:mi>S</mml:mi></mml:math></inline-formula> or the pseudo base pair <italic>and k</italic> is unpaired in the loop closed by (<italic>i</italic>, <italic>j</italic>).</p></list-item><list-item><p><inline-formula><mml:math id="MM199"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>, denotes the joint probability that for a structure <inline-formula><mml:math id="MM200"><mml:mi>S</mml:mi></mml:math></inline-formula> in the ensemble of <italic>A</italic>, (<italic>i</italic>, <italic>j</italic>) is base pair of <inline-formula><mml:math id="MM201"><mml:mi>S</mml:mi></mml:math></inline-formula> or the pseudo base pair <italic>and</italic> the ends of <inline-formula><mml:math id="MM202"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are in the loop closed by (<italic>i</italic>, <italic>j</italic>).</p></list-item></list>Note that we explicitly include the case that (<italic>i</italic>, <italic>j</italic>) is the pseudo base pair <inline-formula><mml:math id="MM203"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, which closes the external loop. The base pair probabilities are the immediate outcome of McCaskill’s original algorithm (<xref rid="btv185-B17" ref-type="bibr">McCaskill, 1990)</xref>, whereas we calculate the joint probabilities by an extension of this algorithm with the same computational complexity (<xref rid="btv185-B18" ref-type="bibr">Otto <italic>et al.</italic>, 2014</xref>). Importantly for the complexity of our final algorithm, all these probabilities can be precomputed since they depend only on the single sequences.</p>
      <sec>
        <title>3.3.1 Sparse structure and alignment space</title>
        <p>The key to sparsifying PARSE, is to optimize only over a subset of solutions, namely probable structures and alignments defined applying fixed probability thresholds <italic>θ</italic><sub>1</sub>, <italic>θ</italic><sub>2</sub> and <italic>θ</italic><sub>3</sub> to the above probabilities.<statement><title>D<sc>efinition</sc> 2</title><p>(Sparse Structure and Alignment Space). Assume fixed thresholds <inline-formula><mml:math id="MM204"><mml:mrow><mml:msub><mml:mi>θ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and sequences <italic>A</italic> and <italic>B</italic>. The structure alignment triple <inline-formula><mml:math id="MM205"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of <italic>A</italic> and <italic>B</italic> is contained in the <italic>sparse structure and alignment space</italic> of <italic>A</italic> and <italic>B</italic> and, for this reason, called <italic>sparse</italic> iff
<table-wrap id="inline_01" position="anchor"><table frame="hsides" rules="groups"><tbody align="left"><tr><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM206"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>C</mml:mtext><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM207"><mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula><mml:math id="MM208"><mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><italic>for all base pairs</italic><inline-formula><mml:math id="MM209"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula><mml:math id="MM210"><mml:mrow><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:math></inline-formula></td></tr><tr><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM211"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>C</mml:mtext><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM212"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mtext> </mml:mtext><mml:mo>∈</mml:mo><mml:mtext> loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula><mml:math id="MM213"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><italic>for all </italic><inline-formula><mml:math id="MM214"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:mrow></mml:math></inline-formula><italic>, i unpaired and internal in </italic><inline-formula><mml:math id="MM215"><mml:mi>S</mml:mi></mml:math></inline-formula><italic>, k unpaired and internal in </italic><inline-formula><mml:math id="MM216"><mml:mi>T</mml:mi></mml:math></inline-formula><italic>, where </italic><inline-formula><mml:math id="MM217"><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula><italic> denotes the parent of i in </italic><inline-formula><mml:math id="MM218"><mml:mi>S</mml:mi></mml:math></inline-formula><italic> and </italic><inline-formula><mml:math id="MM219"><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula><italic>, the parent of k in </italic><inline-formula><mml:math id="MM220"><mml:mi>T</mml:mi></mml:math></inline-formula></td></tr><tr><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM221"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>C</mml:mtext><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><mml:math id="MM222"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula><italic>and</italic><inline-formula><mml:math id="MM223"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></td><td rowspan="1" colspan="1"><italic>for all internal base pairs a in S and b in T, where </italic><inline-formula><mml:math id="MM224"><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula><italic> denotes the parent of a in S; </italic><inline-formula><mml:math id="MM225"><mml:mover accent="true"><mml:mi>b</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:math></inline-formula><italic>, the parent of b in T.</italic></td></tr></tbody></table></table-wrap></p></statement></p>
        <p>Note that in those definitions, explicitly we do not restrict elements in the external loop by Conditions (C2) and (C3), since this does not improve the final complexity further (see Complexity Analysis), but allows more flexibility. An alternative, which we have chosen in our implementation, is filtering the external bases and base pairs by their probabilities to be external (i.e. treating them as elements of the external loops <inline-formula><mml:math id="MM246"><mml:mrow><mml:msub><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM247"><mml:mrow><mml:msub><mml:mi>B</mml:mi><mml:mi>ψ</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>).</p>
        <p>Finding the best structure alignment triple in the sparse space is a form of <italic>constrained evaluation</italic> of the PARSE recursions (see previous section). We modify the recursions such that only cases are considered that extend a sub-solution in a way that satisfies the conditions of Definition 2. First of all, only matrices for base pairs <italic>a</italic> and <italic>b</italic> satisfying Condition (C1) are considered. This restricts the cases of the recursions for <italic>M</italic>, <inline-formula><mml:math id="MM248"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM249"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> that predict base pairs (in <inline-formula><mml:math id="MM250"><mml:mi>S</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="MM251"><mml:mi>T</mml:mi></mml:math></inline-formula> or both.) Furthermore, Condition (C2) constrains the base match case of the <italic>M</italic>-recursion; and Condition (C3), its base pair match case.</p>
        <p>Constraining the recursion cases based on these probabilities is possible only because, during the evaluation, one has determined the base pairs closing the loop containing the considered bases and base pairs in the single structures. In contrast, previous PMcomp-like algorithms, e.g. LocARNA (<xref rid="btv185-B27" ref-type="bibr">Will <italic>et al.</italic>, 2007</xref>), RAF (<xref rid="btv185-B5" ref-type="bibr">Do <italic>et al.</italic>, 2008</xref>) and FoldAlignM (<xref rid="btv185-B25" ref-type="bibr">Torarinsson <italic>et al.</italic>, 2007</xref>), keep track of only the consensus structure (i.e. the pairs of base pairs matched to each other). Thus, one cannot apply the appropriate joint probabilities with respect to closing base pairs in the single structures; consequently, the developed techniques are not applicable. <xref ref-type="fig" rid="btv185-F3">Figure 3</xref>A illustrates that constraining according to loops in the consensus structure would discard relevant structure alignment triples. In the figure, the base pair <italic>a</italic><sub>3</sub> is highly unlikely contained in the loop closed by <italic>a</italic><sub>1</sub> (due to stacking, it is much more likely in the loop closed by <italic>a</italic><sub>2</sub>.) Consequently, even moderate thresholds would disallow its alignment to <italic>b</italic><sub>2</sub>.
<fig id="btv185-F3" position="float"><label>Fig. 3.</label><caption><p>(A) Example alignment. Due to stacking effects, the probability of a base pair <italic>a</italic><sub>3</sub> in the loop closed by <italic>a</italic><sub>2</sub> (loop of single structure) is much higher than its probability in the loop closed by <italic>a</italic><sub>1</sub> [loop of the consensus structure <inline-formula><mml:math id="MM252"><mml:mrow><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>b</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>]. (<bold>B</bold>) Computing represented entries in the sparsified algorithm. We show the matrix <italic>M<sup>ab</sup></italic>; the rounded bars left and on top of the matrix symbolize the represented positions for <italic>a</italic> and <italic>b</italic>; the gray areas contain the represented entries for <italic>M<sup>ab</sup></italic>. In our example, the entry <inline-formula><mml:math id="MM253"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> recurses (solid arrows) to unrepresented entries <inline-formula><mml:math id="MM254"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="MM255"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM256"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (white boxes); the latter via matching base pairs; their left ends correspond to the dashed box at <inline-formula><mml:math id="MM257"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The numbers 1-4 at the arrow heads refer to the respective recursion case. The unrepresented entries are computed from represented entries (dashed arrows to black boxes), each in constant time</p></caption><graphic xlink:href="btv185f3p"/></fig>
</p>
      </sec>
      <sec>
        <title>3.3.2 Sparsified evaluation</title>
        <p>Constraining the evaluation allows us to represent and fill the matrices only partially for optimizing in the sparse structure and alignment space. Concretely, we do not represent all matrix entries that can be derived only via insertion and deletion cases, since we calculate them from smaller represented entries by adding appropriate gap cost (<xref ref-type="fig" rid="btv185-F3">Fig. 3</xref>B).<statement><title>D<sc>efinition</sc> 3</title><p>(Represented entries). <italic>A position i in A is</italic> represented for a base pair <inline-formula><mml:math id="MM258"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM259"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>R</mml:mtext></mml:msup></mml:mrow></mml:math></inline-formula>), <italic>iff</italic>
<inline-formula><mml:math id="MM260"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mtext> loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>
<italic>or there exists some</italic>
<inline-formula><mml:math id="MM261"><mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> (<inline-formula><mml:math id="MM262"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>): <inline-formula><mml:math id="MM263"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>
<italic>and</italic>
<inline-formula><mml:math id="MM264"><mml:mrow><mml:mi>Pr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. <italic>The position</italic>
<inline-formula><mml:math id="MM265"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mo>{</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mtext> </mml:mtext><mml:mi>i</mml:mi><mml:mi>s</mml:mi><mml:mtext> </mml:mtext><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mtext> </mml:mtext><mml:mi>f</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mtext> </mml:mtext><mml:mi>a</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>
<italic>is called</italic> predecessor of <italic>i</italic> for <italic>a</italic>. <italic>The entry</italic>
<inline-formula><mml:math id="MM266"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>A</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>
<italic>is</italic> represented <italic>iff i is represented for a</italic>; <inline-formula><mml:math id="MM267"><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mtext>B</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>iff k is represented for b; and</italic>
<inline-formula><mml:math id="MM268"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>iff both conditions hold</italic>.</p></statement><statement><title>L<sc>emma</sc> 1</title><p>(Value of unrepresented entries). Restricting the optimization to the sparse alignment and structure space, an unrepresented entry <inline-formula><mml:math id="MM269"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has the value <inline-formula><mml:math id="MM270"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mi>b</mml:mi></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>γ</mml:mi><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mi>γ</mml:mi></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM271"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is the predecessor of <italic>i</italic> for <italic>a</italic> and <inline-formula><mml:math id="MM272"><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> is the predecessor of <italic>k</italic> for <italic>b</italic>.</p></statement></p>
        <p>Intuitively, Lemma 1 holds, since the unrepresented entries in a matrix <italic>M<sup>ab</sup></italic> correspond to alignments of subsequences <inline-formula><mml:math id="MM273"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1..</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM274"><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>+</mml:mo><mml:mn>1..</mml:mn><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> that must end in a gap (because the base match (<italic>i</italic>, <italic>k</italic>) and the match of base pairs with right ends <italic>i</italic> and <italic>k</italic> are disallowed). Moreover, in such an alignment the entire subsequences <inline-formula><mml:math id="MM275"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mn>1..</mml:mn><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM276"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mo>*</mml:mo></mml:msup><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mi>..k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> cannot be aligned. The formal proof of Lemma 1 is given in the appendix.</p>
      </sec>
      <sec>
        <title>3.3.3 Complexity analysis</title>
        <p>Let us prepare the analysis of SPARSE by first deriving the time complexity of PMcomp, where we apply the weak ensemble-based sparsification of LocARNA, i.e. <inline-formula><mml:math id="MM277"><mml:mi>P</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="MM278"><mml:mi>Q</mml:mi></mml:math></inline-formula> contain only base pairs satisfying Condition (C1) of Definition 2. Then, for each position <italic>i</italic> of <italic>A</italic>, the number of base pairs <inline-formula><mml:math id="MM279"><mml:mrow><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="MM280"><mml:mrow><mml:msup><mml:mi>a</mml:mi><mml:mtext>L</mml:mtext></mml:msup><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> is constantly bounded by <inline-formula><mml:math id="MM281"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>; analogously, this holds for <inline-formula><mml:math id="MM282"><mml:mi>Q</mml:mi></mml:math></inline-formula> (<xref rid="btv185-B27" ref-type="bibr">Will <italic>et al.</italic>, 2007</xref>). Consequently, evaluating each single entry takes constant time; it remains to count the computed entries. Define the number of times each respective position <italic>i</italic> (or <italic>k</italic>) in sequence <italic>A</italic> (or <italic>B</italic>) is considered in combination with some base of the second sequence in the entire computation. Denote this number of times by <inline-formula><mml:math id="MM283"><mml:mrow><mml:msub><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Then, we count the computed entries by <inline-formula><mml:math id="MM284"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mo>#</mml:mo><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Because, <inline-formula><mml:math id="MM285"><mml:mrow><mml:msub><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM286"><mml:mrow><mml:msub><mml:mo>#</mml:mo><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we have re-derived the time complexity <inline-formula><mml:math id="MM287"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>m</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.<statement><title>T<sc>heorem</sc> 1</title><p>SPARSE optimizes the folding and alignment score in the sparse structure and alignment space in <italic>O</italic>(<italic>nm</italic>) time and space.</p></statement><statement><title>PROOF</title><p>Analogous to the above analysis of PMcomp, we bound the time complexity in the same way from numbers <inline-formula><mml:math id="MM288"><mml:mrow><mml:msubsup><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mrow><mml:mtext>sp</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM289"><mml:mrow><mml:msubsup><mml:mo>#</mml:mo><mml:mi>B</mml:mi><mml:mrow><mml:mtext>sp</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM290"><mml:mrow><mml:msubsup><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mrow><mml:mtext>sp</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the number of base pairs <italic>a</italic> in <inline-formula><mml:math id="MM291"><mml:mi>P</mml:mi></mml:math></inline-formula> such that <italic>i</italic> is represented for <italic>a</italic>. The sum over all such base pairs <italic>a</italic> of the terms <inline-formula><mml:math id="MM292"><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>Pr</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mtext>loop</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is smaller or qual 1, since this is a sum of probabilities of disjoint events. Due to the Conditions (C2) and (C3), each term is at least <inline-formula><mml:math id="MM293"><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, which bounds the number of such base pairs <italic>a</italic>, i.e. <inline-formula><mml:math id="MM294"><mml:mrow><mml:msubsup><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mrow><mml:mtext>sp</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, by <inline-formula><mml:math id="MM295"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>θ</mml:mi><mml:mn>3</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic>O</italic>(1). Finally, the complexity is bounded by <inline-formula><mml:math id="MM296"><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>1..</mml:mn><mml:mi>m</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mo>#</mml:mo><mml:mi mathvariant="script" class="calligraphy">A</mml:mi><mml:mrow><mml:mtext>sp</mml:mtext></mml:mrow></mml:msubsup></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msubsup><mml:mo>#</mml:mo><mml:mi>B</mml:mi><mml:mrow><mml:mtext>sp</mml:mtext></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for computing all entries <inline-formula><mml:math id="MM297"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and filling <inline-formula><mml:math id="MM298"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>ψ</mml:mn></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mn>ψ</mml:mn></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> in <italic>O</italic>(<italic>nm</italic>).</p></statement></p>
      </sec>
      <sec>
        <title>3.3.4 Relaxing the problem for further speedup</title>
        <p>So far, we have considered finding the best sparse structure alignment triple. In practice, it is usually sufficient to find some (not necessarily sparse) triple that is at least as good as any sparse triple. For solving the relaxed problem, analogously to the optimization of PMcomp, we combine the computation of all matrices <inline-formula><mml:math id="MM299"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mtext> </mml:mtext><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>ℓ</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>ℓ</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="MM300"><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mi>q</mml:mi><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="MM301"><mml:mrow><mml:msubsup><mml:mi>b</mml:mi><mml:mi>q</mml:mi><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="MM302"><mml:mrow><mml:mn>1</mml:mn><mml:mo> ≤ </mml:mo><mml:mi>q</mml:mi><mml:mo> ≤ </mml:mo><mml:mi>ℓ</mml:mi></mml:mrow></mml:math></inline-formula> and positions <italic>i</italic> and <italic>k</italic>. For all these matrices, we consider an entry iff it is a represented entry of any of the matrices. Consequently, each considered entry would have been considered by the first algorithm at least once, but possibly several times for different matrices <inline-formula><mml:math id="MM303"><mml:mrow><mml:msup><mml:mi>M</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:msub><mml:mi>b</mml:mi><mml:mi>q</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. Although, thus, we do not increase the complexity, we save computation time in the latter case. This algorithm searches completely through all sparse structure alignment triples. However, it can not guarantee that the triple is sparse. For example, a solution could match a base that is not represented for a predicted base pair <italic>a</italic><sub>1</sub> (<inline-formula><mml:math id="MM304"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>), but is represented for an (unpredicted) base pair <italic>a</italic><sub>2</sub> (<inline-formula><mml:math id="MM305"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:menclose notation="updiagonalstrike"><mml:mo>∉</mml:mo></mml:menclose><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula>) that shares the left end with <italic>a</italic><sub>1</sub> (<inline-formula><mml:math id="MM306"><mml:mrow><mml:msubsup><mml:mi>a</mml:mi><mml:mn>1</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>a</mml:mi><mml:mn>2</mml:mn><mml:mtext>L</mml:mtext></mml:msubsup></mml:mrow></mml:math></inline-formula>).</p>
      </sec>
    </sec>
    <sec>
      <title>3.4 Multiple alignment</title>
      <p>To construct multiple alignments, we suggest a progressive alignment pipeline based on the pairwise SPARSE algorithm. There, we apply SPARSE to construct the guide tree and to align profiles in each progressive step. Unlike PMmulti, the multiple alignment extension to PMcomp (<xref rid="btv185-B12" ref-type="bibr">Hofacker <italic>et al.</italic>, 2004</xref>), which otherwise applies a similar strategy, we apply RNAalifold (<xref rid="btv185-B11" ref-type="bibr">Hofacker <italic>et al.</italic>, 2002</xref>; <xref rid="btv185-B1" ref-type="bibr">Bernhart <italic>et al.</italic>, 2008</xref>) to compute ‘profile’ consensus dot plots in the progressive phase.</p>
      <p>For aligning <italic>k</italic> sequences with maximal length <italic>n</italic>, we start by computing pairwise alignments between all pairs of the input sequences. Because the required ensemble probabilities depend only on the single sequences, they are precomputed for each sequence. Thus, all pairwise alignments are performed in <inline-formula><mml:math id="MM307"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time. Then, the pipeline constructs a guide tree in <inline-formula><mml:math id="MM308"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time by UPGMA (<xref rid="btv185-B9" ref-type="bibr">Gronau and Moran, 2007</xref>). In each step of the progressive alignment, RNAalifold computes all required ensemble probabilities in <inline-formula><mml:math id="MM309"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and SPARSE calculates an alignment in <inline-formula><mml:math id="MM310"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (We extended RNAalifold to compute the additional joint probabilities without changing the complexity.). Thus, the progressive alignment takes <inline-formula><mml:math id="MM311"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, resulting in total time <inline-formula><mml:math id="MM312"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>k</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In comparison, the corresponding pipeline for LocARNA requires <inline-formula><mml:math id="MM313"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>3</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:msup><mml:mi>n</mml:mi><mml:mn>4</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results</title>
    <sec>
      <title>4.1 Speedup and alignment quality</title>
      <p>We evaluated our implementation of SPARSE on the Bralibase 2.1 (<xref rid="btv185-B29" ref-type="bibr">Wilm <italic>et al.</italic>, 2006</xref>) benchmark sets k2 and k3, which consist of pairwise and three-way alignments, respectively. We compared SPARSE to LocARNA and RAF; For set k2, which contains only short and medium-sized RNAs of ∼110 nt average length, SPARSE and RAF achieve similar speed ups over LocARNA (<xref ref-type="table" rid="btv185-T1">Table 1</xref>) (For SPARSE, we used these values: <italic>θ</italic><sub>1</sub> = 1e-3, <italic>θ</italic><sub>2</sub> = 5e-5, <italic>θ</italic><sub>3</sub> = 1e-4, <italic>β<sub>base</sub></italic> = −900, <italic>γ<sub>base</sub></italic> = −3500, <italic>β<sub>loop</sub></italic> = −900 and <italic>γ<sub>loop</sub></italic> = −350; for LocARNA and RAF, we used default settings.). For each alignment tool, <xref ref-type="fig" rid="btv185-F4">Figure 4</xref> shows the dependency of alignment quality on sequence identity across k2; for each benchmark instance, the quality is measured as similarity to the Rfam-derived reference alignment reported as sum-of-pairs score (SPS) by <monospace>compalignp</monospace> (<xref rid="btv185-B29" ref-type="bibr">Wilm <italic>et al.</italic>, 2006</xref>). The dependencies are estimated by non-parametric regression (lowess; <xref rid="btv185-B4" ref-type="bibr">Cleveland, 1981</xref>). This resulting curve visualizes the approximate average SPS at each sequence identity. To furthermore visualize the distribution of the SPS values, we iterated the lowess method both on the elements above and below of the main lowess curve. LocARNA and SPARSE show qualitatively similar performance; across the entire range of sequence identities, we observe a largely constant quality offset, where both tools maintain a high alignment quality even for low sequence identities. In contrast, the quality of RAF alignment drops dramatically when sequence similarity decreases; we conjecture that this is a consequence of the strong sequence-based heuristics in RAF. Our benchmarks on k3 (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btv185/-/DC1">Supplementary Fig. S1</ext-link>) suggest that this behavior extends to multiple alignment. Although all RNA comparison tools introduce some form of time-quality trade-off, remarkably, in terms of alignment quality SPARSE and RAF behave strongly different at very similar run times.
<fig id="btv185-F4" position="float"><label>Fig. 4.</label><caption><p>Alignment quality (measured by SPS) at different sequence identities for pairwise alignments (Bralibase 2.1 set k2). The curves are lowess curves (<xref rid="btv185-B4" ref-type="bibr">Cleveland, 1981</xref>) through data points for each benchmark instance. The thin lines visualize the distribution of scores by estimating the respective instance averages above and below of the main lowess curve</p></caption><graphic xlink:href="btv185f4p"/></fig>
<table-wrap id="btv185-T1" position="float"><label>Table 1.</label><caption><p>Total run-time and speed up of pairwise alignments due to sparsification across Bralibase 2.1 set k2</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Tool</th><th rowspan="1" colspan="1">Total time (s)</th><th rowspan="1" colspan="1">Mean time (s)</th><th rowspan="1" colspan="1">Speedup (versus LocARNA)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">LocARNA</td><td align="char" char="." rowspan="1" colspan="1">13400</td><td align="char" char="." rowspan="1" colspan="1">1.49</td><td align="char" char="." rowspan="1" colspan="1">1.0</td></tr><tr><td rowspan="1" colspan="1">SPARSE</td><td align="char" char="." rowspan="1" colspan="1">3600</td><td align="char" char="." rowspan="1" colspan="1">0.40</td><td align="char" char="." rowspan="1" colspan="1">3.7</td></tr><tr><td rowspan="1" colspan="1">RAF</td><td align="char" char="." rowspan="1" colspan="1">3200</td><td align="char" char="." rowspan="1" colspan="1">0.36</td><td align="char" char="." rowspan="1" colspan="1">4.2</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec>
      <title>4.2 The SPARSE model improves folding</title>
      <p>Moreover, we studied the effect of the novelties in the SPARSE alignment model. Recall that only SPARSE maintains the full flexibility of Sankoff’s approach in the lightweight model, while all previous methods restrict Sankoff’s model by disallowing loop insertions and deletions. Furthermore, the sparsification of SPARSE is expected to affect structure prediction (cf. <xref ref-type="fig" rid="btv185-F3">Fig. 3</xref>A.) Comparing our implementations of SPARSE and LocARNA enables isolating these effects, since by design these implementations behave as similar as possible otherwise. The quality of each predicted structure is measured as Matthews Correlation Coefficient (MCC; <xref rid="btv185-B16" ref-type="bibr">Matthews, 1975</xref>) relative to the Rfam-derived reference structure. For each sequence of the benchmark, we derive reference structures from Rfam, by constrained folding of the associated Rfam consensus structure of the sequence. We compute MCC values for predictions by SPARSE and LocARNA across k2. <xref ref-type="fig" rid="btv185-F5">Figure 5</xref> compares the structure prediction quality by SPARSE and LocARNA. Visualized by the non-overlapping notches, there is strong evidence for improvements (<xref rid="btv185-B2" ref-type="bibr">Chambers <italic>et al.</italic>, 1983</xref>) across all sequence identity ranges covered by the benchmark set. For example, these effects are illustrated well by RNAs of the family gcvT (Appendix).
<fig id="btv185-F5" position="float"><label>Fig. 5.</label><caption><p>Structure prediction quality measured by MCC within different ranges of average pairwise sequence identity (APSI) shown as boxplots. (Bralibase 2.1 set k2) whiskers are extended up to one interquartile range from the boxes</p></caption><graphic xlink:href="btv185f5p"/></fig>
</p>
      <p>Although SPARSE improved prediction quality and speed over LocARNA, these results suggest even more general conclusions. That is, the improvements can be directly ascribed to the single differences of the tools: sparsification and model flexibility.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p>We presented a novel method for simultaneous alignment and folding of RNAs. The relevance of this method is 2-fold. First, we developed the first <italic>full-featured</italic> lightweight variant of the Sankoff model. This fundamentally improves over the lightweight model of PMcomp. Because this model drastically lowered the computational burden of simultaneous alignment and folding, it has been adopted by many successful RNA alignment approaches. However, all of these methods lack the full flexibility of the Sankoff model; for the first time, SPARSE combines this flexibility with lightweight computation. Second, we present a novel method to speed up Sankoff-style alignment that is purely based on the structure ensemble of RNAs; in particular, it does not have to resort to sequence-based heuristics, which could compromise the alignment quality. We showed that by sparsification based on ensemble probabilities of unpaired bases and base pairs in specific loops, simultaneous alignment and folding requires only quadratic time.</p>
    <p>Performing Bralibase 2.1 benchmarks, we demonstrated that, also in practice, the method provides a profound speed up. At similar speed as one of the fastest known simultaneous alignment and folding tools RAF, SPARSE maintains high alignment and folding quality for the ‘twilight’ zone of RNAs with low sequence identity, which are particularly hard to align. Finally, these benchmarks (and concrete examples, see Appendix) suggest that the added expressivity of the novel lightweight model improves the folding accuracy.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_31_15_2489__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btv185_appendix.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>We would like to thank Niklas Meinzer for implementing a benchmark tool for our evaluation and the anonymous reviewers for their help to improve this article.</p>
  </ack>
  <sec>
    <title>Funding</title>
    <p>This work was partially supported by the <funding-source>German Research Foundation</funding-source> (<award-id>DFG grants BA 2168/3-3</award-id>, <award-id>BA 2168/4-3 SPP 1395 InKoMBio</award-id>, <award-id>MO 2402/1-1</award-id>) and German Federal Ministry of Education and Research (<award-id>BMBF grant 031 6165A</award-id> e:Bio RNAsys) to R.B.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="btv185-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Bernhart</surname><given-names>S.H.</given-names></name><etal/></person-group><italic>.</italic> (<year>2008</year>) <article-title>RNAalifold: improved consensus structure prediction for RNA alignments</article-title>. <source>BMC Bioinformatics</source>, <volume>9</volume>, <fpage>474</fpage>.<pub-id pub-id-type="pmid">19014431</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B2">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Chambers</surname><given-names>J.M.</given-names></name><etal/></person-group> (<year>1983</year>) <source>Graphical Methods for Data Analysis</source><italic>.</italic>
<comment>Wadsworth, Belmont, CA</comment>.</mixed-citation>
    </ref>
    <ref id="btv185-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Clark</surname><given-names>M.B.</given-names></name><etal/></person-group><italic>.</italic> (<year>2011</year>) <article-title>The reality of pervasive transcription</article-title>. <source>PLoS Biol</source>, <volume>9</volume>, <comment>e1000625; discussion e1001102</comment>.</mixed-citation>
    </ref>
    <ref id="btv185-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Cleveland</surname><given-names>W.S.</given-names></name></person-group> (<year>1981</year>) <article-title>Lowess: a program for smoothing scatterplots by robust locally weighted regression</article-title>. <source>Am. Stat.</source>, <volume>35</volume>, <fpage>54</fpage>.</mixed-citation>
    </ref>
    <ref id="btv185-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Do</surname><given-names>C.B.</given-names></name><etal/></person-group><italic>.</italic> (<year>2008</year>) <article-title>A max-margin model for efficient simultaneous alignment and folding of RNA sequences</article-title>. <source>Bioinformatics</source>, <volume>24</volume>, <fpage>i68</fpage>–<lpage>i76</lpage>.<pub-id pub-id-type="pmid">18586747</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dowell</surname><given-names>R.D.</given-names></name><name><surname>Eddy</surname><given-names>S.R.</given-names></name></person-group> (<year>2006</year>) <article-title>Efficient pairwise RNA structure prediction and alignment using sequence alignment constraints</article-title>. <source>BMC Bioinformatics</source>, <volume>7</volume>, <fpage>400</fpage>.<pub-id pub-id-type="pmid">16952317</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gardner</surname><given-names>P.P.</given-names></name><etal/></person-group><italic>.</italic> (<year>2005</year>) <article-title>A benchmark of multiple sequence alignment programs upon structural RNAs</article-title>. <source>Nucleic Acids Res.</source>, <volume>33</volume>, <fpage>2433</fpage>–<lpage>2439</lpage>.<pub-id pub-id-type="pmid">15860779</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gotoh</surname><given-names>O.</given-names></name></person-group> (<year>1982</year>) <article-title>An improved algorithm for matching biological sequences</article-title>. <source>J. Mol. Biol.</source>, <volume>162</volume>, <fpage>705</fpage>–<lpage>708</lpage>.<pub-id pub-id-type="pmid">7166760</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gronau</surname><given-names>I.</given-names></name><name><surname>Moran</surname><given-names>S.</given-names></name></person-group> (<year>2007</year>) <article-title>Optimal implementations of UPGMA and other common clustering algorithms</article-title>. <source>Inf. Process. Lett.</source>, <volume>104</volume>, <fpage>205</fpage>–<lpage>210</lpage>.</mixed-citation>
    </ref>
    <ref id="btv185-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Harmanci</surname><given-names>A.O.</given-names></name><etal/></person-group><italic>.</italic> (<year>2007</year>) <article-title>Efficient pairwise RNA structure prediction using probabilistic alignment constraints in Dynalign</article-title>. <source>BMC Bioinformatics</source>, <volume>8</volume>, <fpage>130</fpage>.<pub-id pub-id-type="pmid">17445273</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hofacker</surname><given-names>I.L.</given-names></name><etal/></person-group><italic>.</italic> (<year>2002</year>) <article-title>Secondary structure prediction for aligned RNA sequences</article-title>. <source>J. Mol. Biol.</source>, <volume>319</volume>, <fpage>1059</fpage>–<lpage>1066</lpage>.<pub-id pub-id-type="pmid">12079347</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hofacker</surname><given-names>I.L.</given-names></name><etal/></person-group><italic>.</italic> (<year>2004</year>) <article-title>Alignment of RNA base pairing probability matrices</article-title>. <source>Bioinformatics</source>, <volume>20</volume>, <fpage>2222</fpage>–<lpage>2227</lpage>.<pub-id pub-id-type="pmid">15073017</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Holmes</surname><given-names>I.</given-names></name></person-group> (<year>2005</year>) <article-title>Accelerated probabilistic inference of RNA structure evolution</article-title>. <source>BMC Bioinformatics</source>, <volume>6</volume>, <fpage>73</fpage>.<pub-id pub-id-type="pmid">15790387</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jacquier</surname><given-names>A.</given-names></name></person-group> (<year>2009</year>) <article-title>The complex eukaryotic transcriptome: unexpected pervasive transcription and novel small RNAs</article-title>. <source>Nat. Rev. Genet.</source>, <volume>10</volume>, <fpage>833</fpage>–<lpage>844</lpage>.<pub-id pub-id-type="pmid">19920851</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mathews</surname><given-names>D.</given-names></name><etal/></person-group><italic>.</italic> (<year>1999</year>) <article-title>Expanded sequence dependence of thermodynamic parameters improves prediction of RNA secondary structure</article-title>. <source>J. Mol. Biol.</source>, <volume>288</volume>, <fpage>911</fpage>–<lpage>940</lpage>.<pub-id pub-id-type="pmid">10329189</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Matthews</surname><given-names>B.</given-names></name></person-group> (<year>1975</year>) <article-title>Comparison of the predicted and observed secondary structure of t4 phage lysozyme</article-title>. <source>Biochem. Biophys. Acta</source>, <volume>405</volume>, <fpage>442</fpage>–<lpage>451</lpage>.<pub-id pub-id-type="pmid">1180967</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>McCaskill</surname><given-names>J.S.</given-names></name></person-group> (<year>1990</year>) <article-title>The equilibrium partition function and base pair binding probabilities for RNA secondary structure</article-title>. <source>Biopolymers</source>, <volume>29</volume>, <fpage>1105</fpage>–<lpage>1119</lpage>.<pub-id pub-id-type="pmid">1695107</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Otto</surname><given-names>C.</given-names></name><etal/></person-group><italic>.</italic> (<year>2014</year>) <article-title>ExpaRNA-P: simultaneous exact pattern matching and folding of RNAs</article-title>. <source>BMC Bioinformatics</source>, <volume>15</volume>, <fpage>6602</fpage>.</mixed-citation>
    </ref>
    <ref id="btv185-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Parker</surname><given-names>B.J.</given-names></name><etal/></person-group> (<year>2011</year>) <article-title>New families of human regulatory RNA structures identified by comparative analysis of vertebrate genomes</article-title>. <source>Genome Res</source>. <volume>21</volume>, <fpage>1929</fpage>–<lpage>1943</lpage>.<pub-id pub-id-type="pmid">21994249</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rederstorff</surname><given-names>M.</given-names></name><etal/></person-group><italic>.</italic> (<year>2010</year>) <article-title>RNPomics: defining the ncRNA transcriptome by cDNA library generation from ribonucleo-protein particles</article-title>. <source>Nucleic Acids Res.</source>, <volume>38</volume>, <fpage>e113</fpage>.<pub-id pub-id-type="pmid">20150415</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Saito</surname><given-names>Y.</given-names></name><etal/></person-group><italic>.</italic> (<year>2011</year>) <article-title>Fast and accurate clustering of noncoding RNAs using ensembles of sequence alignments and secondary structures</article-title>. <source>BMC Bioinformatics</source>, <volume>12</volume> (<issue>Suppl 1</issue>), <fpage>S48</fpage>.<pub-id pub-id-type="pmid">21342580</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sankoff</surname><given-names>D.</given-names></name></person-group> (<year>1985</year>) <article-title>Simultaneous solution of the RNA folding, alignment and protosequence problems</article-title>. <source>SIAM J. Appl. Math.</source>, <volume>45</volume>, <fpage>810</fpage>–<lpage>825</lpage>.</mixed-citation>
    </ref>
    <ref id="btv185-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Shi</surname><given-names>Y.</given-names></name><etal/></person-group><italic>.</italic> (<year>2009</year>) <article-title>Metatranscriptomics reveals unique microbial small RNAs in the ocean’s water column</article-title>. <source>Nature</source>, <volume>459</volume>, <fpage>266</fpage>–<lpage>269</lpage>.<pub-id pub-id-type="pmid">19444216</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sorescu</surname><given-names>D.A.</given-names></name><etal/></person-group><italic>.</italic> (<year>2012</year>) <article-title>CARNA—alignment of RNA structure ensembles</article-title>. <source>Nucleic Acids Res.</source>, <volume>40</volume>, <fpage>W49</fpage>–<lpage>W53</lpage>. <comment>DAS, MMö, and MMa contributed equally to this work</comment>.<pub-id pub-id-type="pmid">22689637</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Torarinsson</surname><given-names>E.</given-names></name><etal/></person-group><italic>.</italic> (<year>2007</year>) <article-title>Multiple structural alignment and clustering of RNA sequences</article-title>. <source>Bioinformatics</source>, <volume>23</volume>, <fpage>926</fpage>–<lpage>932</lpage>.<pub-id pub-id-type="pmid">17324941</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Tseng</surname><given-names>H.-H.</given-names></name><etal/></person-group><italic>.</italic> (<year>2009</year>) <article-title>Finding non-coding RNAs through genome-scale clustering</article-title>. <source>J. Bioinform. Comput. Biol.</source>, <volume>7</volume>, <fpage>373</fpage>–<lpage>388</lpage>.<pub-id pub-id-type="pmid">19340921</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Will</surname><given-names>S.</given-names></name><etal/></person-group><italic>.</italic> (<year>2007</year>) <article-title>Inferring non-coding RNA families and classes by means of genome-scale structure-based clustering</article-title>. <source>PLoS Comput. Biol.</source>, <volume>3</volume>, <fpage>e65</fpage>.<pub-id pub-id-type="pmid">17432929</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Will</surname><given-names>S.</given-names></name><etal/></person-group><italic>.</italic> (<year>2012</year>) <article-title>LocARNA-P: accurate boundary prediction and improved detection of structural RNAs</article-title>. <source>RNA</source>, <volume>18</volume>, <fpage>900</fpage>–<lpage>914</lpage>.<pub-id pub-id-type="pmid">22450757</pub-id></mixed-citation>
    </ref>
    <ref id="btv185-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Wilm</surname><given-names>A.</given-names></name><etal/></person-group><italic>.</italic> (<year>2006</year>) <article-title>An enhanced RNA alignment benchmark for sequence alignment programs</article-title>. <source>Algorithms Mol. Biol.</source>, <volume>1</volume>, <fpage>19</fpage>.<pub-id pub-id-type="pmid">17062125</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
