<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Neurosci</journal-id>
    <journal-id journal-id-type="iso-abbrev">Front Neurosci</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Neurosci.</journal-id>
    <journal-title-group>
      <journal-title>Frontiers in Neuroscience</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1662-4548</issn>
    <issn pub-type="epub">1662-453X</issn>
    <publisher>
      <publisher-name>Frontiers Media S.A.</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6257411</article-id>
    <article-id pub-id-type="doi">10.3389/fnins.2018.00816</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Neuroscience</subject>
        <subj-group>
          <subject>Original Research</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>sPyNNaker: A Software Package for Running PyNN Simulations on SpiNNaker</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Rhodes</surname>
          <given-names>Oliver</given-names>
        </name>
        <xref ref-type="corresp" rid="c001">
          <sup>*</sup>
        </xref>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/531415/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bogdan</surname>
          <given-names>Petruţ A.</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/462169/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brenninkmeijer</surname>
          <given-names>Christian</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Davidson</surname>
          <given-names>Simon</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/70824/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Fellows</surname>
          <given-names>Donal</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Gait</surname>
          <given-names>Andrew</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/608479/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Lester</surname>
          <given-names>David R.</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mikaitis</surname>
          <given-names>Mantas</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/484529/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Plana</surname>
          <given-names>Luis A.</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/185595/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Rowley</surname>
          <given-names>Andrew G. D.</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/407227/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stokes</surname>
          <given-names>Alan B.</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/185930/overview"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Furber</surname>
          <given-names>Steve B.</given-names>
        </name>
        <uri xlink:type="simple" xlink:href="http://loop.frontiersin.org/people/71641/overview"/>
      </contrib>
    </contrib-group>
    <aff>
      <institution>Advanced Processor Technologies Group, School of Computer Science</institution>
      <country>University of Manchester, Manchester, United Kingdom</country>
    </aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p>Edited by: Gert Cauwenberghs, University of California, San Diego, United States</p>
      </fn>
      <fn fn-type="edited-by">
        <p>Reviewed by: James B. Aimone, Sandia National Laboratories (SNL), United States; Chris Karl, Intel, United States</p>
      </fn>
      <corresp id="c001">*Correspondence: Oliver Rhodes <email>oliver.rhodes@manchester.ac.uk</email></corresp>
      <fn fn-type="other" id="fn001">
        <p>This article was submitted to Neuromorphic Engineering, a section of the journal Frontiers in Neuroscience</p>
      </fn>
    </author-notes>
    <pub-date pub-type="epub">
      <day>20</day>
      <month>11</month>
      <year>2018</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2018</year>
    </pub-date>
    <volume>12</volume>
    <elocation-id>816</elocation-id>
    <history>
      <date date-type="received">
        <day>31</day>
        <month>8</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>19</day>
        <month>10</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2018 Rhodes, Bogdan, Brenninkmeijer, Davidson, Fellows, Gait, Lester, Mikaitis, Plana, Rowley, Stokes and Furber.</copyright-statement>
      <copyright-year>2018</copyright-year>
      <copyright-holder>Rhodes, Bogdan, Brenninkmeijer, Davidson, Fellows, Gait, Lester, Mikaitis, Plana, Rowley, Stokes and Furber</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License (CC BY). The use, distribution or reproduction in other forums is permitted, provided the original author(s) and the copyright owner(s) are credited and that the original publication in this journal is cited, in accordance with accepted academic practice. No use, distribution or reproduction is permitted which does not comply with these terms.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>This work presents sPyNNaker 4.0.0, the latest version of the software package for simulating PyNN-defined spiking neural networks (SNNs) on the SpiNNaker neuromorphic platform. Operations underpinning realtime SNN execution are presented, including an event-based operating system facilitating efficient time-driven neuron state updates and pipelined event-driven spike processing. Preprocessing, realtime execution, and neuron/synapse model implementations are discussed, all in the context of a simple example SNN. Simulation results are demonstrated, together with performance profiling providing insights into how software interacts with the underlying hardware to achieve realtime execution. System performance is shown to be within a factor of 2 of the original design target of 10,000 synaptic events per millisecond, however SNN topology is shown to influence performance considerably. A cost model is therefore developed characterizing the effect of network connectivity and SNN partitioning. This model enables users to estimate SNN simulation performance, allows the SpiNNaker team to make predictions on the impact of performance improvements, and helps demonstrate the continued potential of the SpiNNaker neuromorphic hardware.</p>
    </abstract>
    <kwd-group>
      <kwd>neuromorphic</kwd>
      <kwd>PyNN</kwd>
      <kwd>SpiNNaker machine</kwd>
      <kwd>spiking neural network (SNN)</kwd>
      <kwd>realtime</kwd>
    </kwd-group>
    <counts>
      <fig-count count="12"/>
      <table-count count="2"/>
      <equation-count count="10"/>
      <ref-count count="47"/>
      <page-count count="20"/>
      <word-count count="14929"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>1. Introduction</title>
    <p>A platform enabling efficient simulation of large-scale networks of spiking neurons (distinct from artificial neural networks, as used in the deep learning community) has the ability to provide advances in multiple areas of research. These include: exploration of scale within the field of computational neuroscience; understanding of brain-like information processing and how it can be harnessed in traditional computational problems; and the ability to embed brain-like systems in physical applications, e.g., facilitating efficient realtime processing in robots such as controllable prosthetics and driver-less vehicles. The benefits of using bespoke hardware to address such problems are well known, and have led to development of the field of neuromorphic engineering (Indiveri and Horiuchi, <xref rid="B21" ref-type="bibr">2011</xref>). Multiple platforms now exist capable of high performance simulation of large numbers of neurons and synapses, often at speeds greatly exceeding biological realtime. Example systems include the Stanford NeuroGrid (Benjamin et al., <xref rid="B4" ref-type="bibr">2014</xref>), IBM TrueNorth (Akopyan et al., <xref rid="B1" ref-type="bibr">2015</xref>), and the BrainScaleS platform (Schemmel et al., <xref rid="B37" ref-type="bibr">2010</xref>) from Heidelberg University; with many bespoke chip-level systems also being developed (Qiao et al., <xref rid="B34" ref-type="bibr">2015</xref>). These systems share a common feature that they offer predefined simulation capability through neurons modeled in analog hardware or digital hardware with fixed software. However, a number of neuromorphic systems instead focus on delivering a flexible platform offering researchers the opportunity to reconfigure simulation functionality to meet their problem requirements. Examples include the Intel Loihi (Davies et al., <xref rid="B8" ref-type="bibr">2018</xref>) system, which has configurable features such as a synaptic plasticity engine for learning; and the SpiNNaker system, which is comprised of fully-programmable ARM cores (Furber, <xref rid="B14" ref-type="bibr">2016</xref>). While this flexible nature compromises these platforms relative to other neuromorphic systems in terms of absolute energy consumption or processing speed, it makes them valuable research tools enabling exploration of new and emerging concepts in computational neuroscience and beyond.</p>
    <p>For example, this flexibility has led to the SpiNNaker platform executing large-scale networks of neurons (Sen-Bhattacharya et al., <xref rid="B39" ref-type="bibr">2017</xref>; van Albada et al., <xref rid="B47" ref-type="bibr">2018</xref>), and performing analysis of cognitive tasks such as action selection (Sen-Bhattacharya et al., <xref rid="B38" ref-type="bibr">2018</xref>). Applications of learning in SNNs have also been investigated, such as the study of learning based on Bayesian inference in Knight et al. (<xref rid="B26" ref-type="bibr">2016</xref>), and reinforcement learning in Mikaitis et al. (<xref rid="B30" ref-type="bibr">2018</xref>). Outside the field of computational neuroscience, SpiNNaker has also been applied to constraint satisfaction problems, e.g., solving computationally hard Sudoku or map color problems in Fonseca Guerra and Furber (<xref rid="B13" ref-type="bibr">2017</xref>). In addition to these processing applications, the embodiment of SpiNNaker systems in multiple physical autonomous robots has also been demonstrated, with perhaps the most impressive application being the combination of musculoskeletal robotic hardware with neural control systems implemented on SpiNNaker (Christoph et al., <xref rid="B7" ref-type="bibr">2016</xref>). However, despite these advances, significant challenges are yet to be faced across all of the aforementioned fields. Developing understanding of memory, action selection, and attention will all be crucial in order to take the next steps in understanding of both the brain and brain-inspired systems. The SpiNNaker approach of using programmable ARM cores to simulate neurons and synapses enables upgrading and expansion of system functionality hand-in-hand with developments across the fields of theoretical neuroscience, parallel computing, and robotics. This not only facilitates research in these fields, but provides valuable insights into the design of higher performing, but more “rigid,” hardware-based neuromorphic solutions. However, the creation of such software is unlike that for most other computing machinery (Furber et al., <xref rid="B16" ref-type="bibr">2013</xref>; Brown et al., <xref rid="B5" ref-type="bibr">2015</xref>; Lin et al., <xref rid="B27" ref-type="bibr">2018</xref>); and while development of the SpiNNaker hardware has been well documented (Furber et al., <xref rid="B16" ref-type="bibr">2013</xref>, <xref rid="B15" ref-type="bibr">2014</xref>; Painkras et al., <xref rid="B33" ref-type="bibr">2013</xref>), the software has until now been given less focus.</p>
    <p>This paper gives a complete overview of the current state-of-the art in SpiNNaker software pertaining to modeling spiking neural networks. As such, it will focus on describing the software within the sPyNNaker repository<xref ref-type="fn" rid="fn0001"><sup>1</sup></xref>, including the internal operations used to simulate networks of neurons, use of hardware resources, and user interaction. This description will assume the existence of SpiNNTools, the low-level graph-based software for managing execution of general parallel software on the SpiNNaker machine, as described in Rowley et al. (<xref rid="B36" ref-type="bibr">2018</xref>). While versions of SpiNNaker software have in part been published previously (Jin et al., <xref rid="B24" ref-type="bibr">2010</xref>; Sharp et al., <xref rid="B40" ref-type="bibr">2011</xref>, <xref rid="B42" ref-type="bibr">2012</xref>; Davies et al., <xref rid="B9" ref-type="bibr">2012</xref>), this work contributes a comprehensive overview of the underlying operations and associated hardware interactions which have guided API design. It is hoped this will provide insight to users of the system, and hence improve performance when extending the software framework for future neural applications. As background for the remainder of the paper, this introduction is followed by a high-level overview of both the SpiNNaker hardware, and the PyNN interface for defining networks of spiking neurons. A methods and implementation section follows, providing an in-depth look at the sPyNNaker API developed by the SpiNNaker software team based at the University of Manchester, UK. Results exhibiting performance profiling are then provided. Finally, a discussion section completes the paper, together with suggestions for the future direction of the API.</p>
  </sec>
  <sec id="s2">
    <title>2. Background</title>
    <sec>
      <title>2.1. The spiNNaker platform—hardware to simulate 1 billion neurons</title>
      <p>The SpiNNaker hardware was designed to simulate in realtime networks of spiking neurons, with neurons and synapses modeled in software. The machine targets large-scale networks containing approximately 10<sup>9</sup> neurons and 10<sup>12</sup> synapses, giving a 10<sup>3</sup> mean fan in/out per neuron (Furber et al., <xref rid="B16" ref-type="bibr">2013</xref>), and was scoped to handle mean firing rates of 10Hz (with peak rates of 100Hz). The machine was sized according to the computational power required to simulate synapses, as these typically dominate neural network processing. Assuming processing of a single synaptic event requires 20 instructions (where a synaptic event is defined as a single neuron receiving a single spike), the machine was sized to provide 2 × 10<sup>8</sup>MIPS to handle 10<sup>13</sup> synaptic events per second. For simplicity and cost reasons, off-the-shelf components were used, specifically the ARM9 core for processing. At 200MHz clock speed, 10<sup>6</sup> ARM9 cores are required for synaptic processing, and it follows that each ARM core should simultaneously model 10<sup>3</sup> of the 10<sup>9</sup> neurons. The remainder of this section gives an overview of the subsequent SpiNNaker chip, including details on chip layout and features pertinent to neural simulation.</p>
      <p>The SpiNNaker chip houses 18 cores, together with network on chip (NoC) and an external RAM controller—as shown in Figure <xref ref-type="fig" rid="F1">1</xref>. Each core contains: an ARM968 (ARM, <xref rid="B3" ref-type="bibr">2004</xref>), direct memory access (DMA) controller, communications controller, network interface controller, and other peripherals including the timer. Each core operates at 200MHz clock speed, and typically runs an application simulating a group of neurons. Each core has 96kB of tightly coupled memory (TCM), which to avoid contention is split: 32kB for instructions (ITCM) and 64kB for data (DTCM). Application code is compiled into an ARM968 executable and loaded to ITCM, while DTCM contains application data including heap, stack and other read/write and zero initialized data. Each chip has an additional 128MB of shared memory (SDRAM), directly accessible by all cores on the chip. Access times to these different memories vary considerably, and are therefore a key consideration when designing SpiNNaker software applications.</p>
      <list list-type="bullet">
        <list-item>
          <p>Access to DTCM is fast at ≈5ns/word (where unless otherwise stated a word is 32bits), but is limited to only the local core.</p>
        </list-item>
        <list-item>
          <p>SDRAM can be accessed via bridge, however this is relatively slow at &gt;100ns/word, and subject to contention with other cores.</p>
        </list-item>
        <list-item>
          <p>A direct memory access (DMA) controller is therefore provided for each core, enabling efficient bulk transfer of data from SDRAM to core DTCM. Setup of the DMA incurs a fixed overhead, however data is then transferred at ≈10ns/word, independently from the processor.</p>
        </list-item>
      </list>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p>The SpiNNaker Chip, containing: 18 cores, each with local instruction and data memory; network on chip; and SDRAM controller providing access to 128MB of chip-level shared memory.</p>
        </caption>
        <graphic xlink:href="fnins-12-00816-g0001"/>
      </fig>
      <p>A single DMA request can transfer up to 64kB, but is broken down into smaller data bursts to facilitate transfer. This burst size is typically set at 16 double words, with a small time penalty incurred during setup of each burst. DMA requests are subject to contention at the SDRAM controller, however each DMA controller can submit only a single burst request at a time, introducing a fair queuing policy between cores. Note also that the requests themselves are subject to contention, which can lead to latency in initiation of DMA operations. Despite this contention between DMA requests, the SDRAM controller bandwidth has the capacity to sustain DMA transfers to multiple cores simultaneously, both reading and writing data to and from SDRAM. However, when three or more cores read, and two or more cores write, performance becomes bandwidth limited—with maximum bandwidth reported as 900MBs<sup>−1</sup> (Painkras et al., <xref rid="B33" ref-type="bibr">2013</xref>; Sharp and Furber, <xref rid="B41" ref-type="bibr">2013</xref>).</p>
      <p>Individual SpiNNaker chips are assembled onto boards in a two-dimensional mesh, with common board sizes containing 4 and 48 chips. Multiple boards can then be connected to create a SpiNNaker “machine.” Cores operate in a globally asynchronous locally synchronous (GALS) manner, and communicate through small messages or packets sent via the NoC and SpiNNaker router (Navaridas et al., <xref rid="B32" ref-type="bibr">2015</xref>). The router allows transmission of packets to any subset of the cores on a chip, and to a subset of the 6 off-chip links (enabling chip-to-chip transmission, and hence routing of packets to any core on the machine). The neural applications presented herein use multicast packets, designed to be transmitted from a source to multiple targets simultaneously. A multicast packet contains an 8-bit control byte used by the system, and a 32-bit key used to route the packet. This key is looked up within a table of entries, each of which indicates which of the matching cores and/or links packets should be sent to. This multicast behavior allows a core to send a single message targeting multiple destinations, without having to send an individual message to each of them. It also allows fire-and-forget sending of packets, removing the need for network level interlocking between source and destination. The resulting source-directed routing architecture enables highly efficient message distribution compared to traditional network architectures.</p>
      <p>SpiNNaker software applications are typically written in C, and compiled into ARM executable code for maximum execution speed. When designing applications which solve systems of equations, consideration must be given to the impact of precision on results and their numerical stability. The SpiNNaker ARM968 has no hardware floating-point support, and software-implemented floating-point operations are costly in terms of both ITCM and execution time. Fixed point arithmetic is therefore the preferred data representation when solving systems of equations governing neural dynamics. While creation of custom fixed point datatypes is possible, and potentially achieves optimal performance (Jin et al., <xref rid="B23" ref-type="bibr">2008</xref>), the ISO/IEC TR 18037:2008<xref ref-type="fn" rid="fn0002"><sup>2</sup></xref> standard is recommended and used throughout unless otherwise stated. This provides types and operators similar to those defining standard floating point operations, improving ease of reading and code development for non-specialist ARM968 programmers. This standard has been implemented in the GCC toolchain for the ARM target, with version 5.4 the recommended compiler for sPyNNaker 4.0.0. Unless otherwise stated, variables in this work will be defined according to the ISO standard <italic>accum</italic> type: a signed 16-integer and 15-fractional bit fixed-point number, as discussed by Hopkins and Furber (<xref rid="B20" ref-type="bibr">2015</xref>). Variables typed as <italic>accum</italic> have an absolute lower limit of 0.000030517578125 (below which underflow occurs and 0 will be returned), and absolute upper limit of 65535.999969482421875 (above which it will overflow and wrap). Division is expensive due to a lack of hardware support, and should be replaced with multiplication by the reciprocal when developing performance-critical applications. An extension to the fixed-point standard implements exponential and logarithm functions, however they are costly to evaluate and hence should be precalculated on host when used as constants to optimize performance.</p>
    </sec>
    <sec>
      <title>2.2. Pynn</title>
      <p>PyNN is a Python interface to define SNN simulations for a range of simulator back-ends (Davison et al., <xref rid="B10" ref-type="bibr">2008</xref>). It allows users to specify an SNN simulation via a Python script once, and have it executed on any or all of the supported back-ends including NEST (Gewaltig and Diesmann, <xref rid="B18" ref-type="bibr">2007</xref>), NEURON (Carnevale and Hines, <xref rid="B6" ref-type="bibr">2006</xref>), and Brian (Goodman and Brette, <xref rid="B19" ref-type="bibr">2009</xref>). This encourages standardization of simulators, reproducibility of results, and increases productivity of neural network modelers through code sharing and reuse, and by providing a foundation for simulator-agnostic post-processing, visualization and data-management tools.</p>
      <p>PyNN has continued development as part of the European Flagship Human Brain Project (Amunts et al., <xref rid="B2" ref-type="bibr">2016</xref>), and has hence been adopted as a modeling language by a number of partners including SpiNNaker. It provides a structured interface for the definition of neurons, synapses, and input sources, giving users the flexibility to build a range of network topologies. Models typically consist of single-compartment point neurons, grouped together in “populations.” These populations are then linked with “projections,” representing the synaptic connections between the axons of neurons in a source population, and the dendrites of neurons in a target population. Once defined, a number of simulation controls are used to execute the model for a given time period, with the option to update parameters and initialize state variables between runs. On simulation completion data can be extracted for post-processing and future reference. Neuron variables such as spike trains, total synaptic conductances, and neuron membrane potential are accessible from population objects; while synaptic weights and delays are extracted from projections. This data can be subsequently saved, or visualized using the built-in plotting functionality.</p>
      <p>Example PyNN commands for the generation of populations and projections are detailed in <bold>Code 1</bold>. Here the sPyNNaker version of the simulator is imported as <italic>sim</italic>, and subsequently used to construct and execute a simulation. A population of 250 Poisson source neurons is created with label “poisson_source,” and provides 50Hz input to the network for 5s. A second population of 500 integrate and fire neurons is then created and labeled as “excitatory_pop.” Excitatory connections are made between “poisson_source” and “excitatory_pop” with a 20% probability of connection, each with a weight of 0.06nA and delays specified via a probability distribution. Data recording is then enabled for “excitatory_pop,” and the simulation executed for 5s. Finally, the “excitatory_pop” spike history data is extracted from the simulator.</p>
      <p>
        <inline-graphic xlink:href="fnins-12-00816-i0001.jpg"/>
      </p>
      <p>The job of a PyNN simulator is therefore to provide a backend-specific implementation of the PyNN language, enabling execution of simulations defined in model scripts such as Code S1. The PyNN implementation for SpiNNaker hardware (s-PyNN-aker) is detailed in section 3, and is the major contribution of this work. It covers the process of converting a PyNN script into a form suitable for execution on a SpiNNaker machine, and the low-level execution on the machine itself.</p>
    </sec>
  </sec>
  <sec id="s3">
    <title>3. sPyNNaker: methods and implementation</title>
    <p>The sPyNNaker API is comprised of two software stacks as shown in Figure <xref ref-type="fig" rid="F2">2</xref>: one running on host predominantly written in Python, the other running on the SpiNNaker machine written in C. Users create an SNN model via the PyNN interface, which is then preprocessed via the Python sPyNNaker software into a form suitable for a SpiNNaker machine. Simulations execute on the SpiNNaker machine via an event-driven operating system, and on simulation completion results data are extracted back to host for post-processing and visualization via the PyNN API. This section details the software implementation of these stages, beginning with a summary of the SNN-specific aspects of preprocessing (for further explanation of the Python-based preprocessing stages readers are referred to Rowley et al., <xref rid="B36" ref-type="bibr">2018</xref>). Simulation execution on the SpiNNaker machine is then covered in detail, including an overview of the event-driven operating system SpiN1API. The software framework for defining neuron and synapse models is then introduced, followed by an overview of existing implementations. Finally, auxiliary applications are discussed, including generation of input spikes to drive network behavior.</p>
    <fig id="F2" position="float">
      <label>Figure 2</label>
      <caption>
        <p>SpiNNaker software stacks. From top left anti-clockwise to top right: users create SNN models on host via the PyNN interface; the sPyNNaker Python software stack then translates the SNN model into a form suitable for a SpiNNaker machine, and loads the appropriate data to SpiNNaker memory via Ethernet; sPyNNaker applications, built on the SARK system management and SpiN1API event-driven processing libraries, use the loaded data to perform realtime simulation of neurons and synapses.</p>
      </caption>
      <graphic xlink:href="fnins-12-00816-g0002"/>
    </fig>
    <sec>
      <title>3.1. Preprocessing</title>
      <p>At the top of the left-hand side stack in Figure <xref ref-type="fig" rid="F2">2</xref>, users create a PyNN script defining an SNN. The SpiNNaker back-end is specified, which translates the SNN into a form suitable for execution on a SpiNNaker machine. This process includes: mapping of the SNN into an application graph, partitioning into a machine graph, generation of the required routing information, and loading of data and applications to a SpiNNaker machine. Once loading is complete, all core applications are instructed to begin execution, and run for a predefined period. On simulation completion, requested output data are extracted from the machine and made accessible through the PyNN API. Documentation of the complete simulation workflow is beyond the scope of this work, however aspects not detailed here are covered in Rowley et al. (<xref rid="B36" ref-type="bibr">2018</xref>) for generic graph-based simulations (extending SpiNNaker beyond neural applications). However, as certain aspects of SNNs have a direct impact on the simulation workflow, a walkthrough of the key points in this process in the context of neural simulation is included below.</p>
      <p>A sample SNN is developed as a vehicle by which to describe the stages of preprocessing. A random balanced network is defined according to the PyNN script detailed in Code <xref ref-type="supplementary-material" rid="SM1">S1</xref> (Supplementary Material), with the resulting network topology shown in Figure <xref ref-type="fig" rid="F3">3A</xref>. The network consists of 500 excitatory and 125 inhibitory neurons, which make excitatory and inhibitory projections to one another, respectively. Each population additionally makes recurrent connections to itself with the same effect. Excitatory Poisson-distributed input is included to represent background activity, while predefined spike patterns are injected via a spike source array. The neuronal populations consist of current-based leaky integrate-and-fire (LIF) neurons, with the membrane potential of each neuron in the excitatory population initialized via a uniform distribution bounded by the threshold and resting potentials. The sPyNNaker API first interprets the PyNN defined network to construct an application graph: a vertices and edges view of the neural network, where each edge corresponds to a projection carrying synapses, and each vertex to a population of neurons. This application graph is then partitioned into a machine graph, by subdividing application vertices and edges based on available hardware resources and requirement constraints, ultimately ensuring each resulting machine vertex can be executed on a single SpiNNaker core. From hereon-in the term <italic>vertex</italic> will refer to a machine vertex, and is synonymous with the term sub-population, representing a group of neurons which can be simulated on a single core. An example of this partitioning is shown in Figure <xref ref-type="fig" rid="F3">3</xref>, where due to its size “Excitatory Population” is split into two sub-partitions (A and B). Figure <xref ref-type="fig" rid="F3">3</xref> also shows how additional machine edges are created to preserve network topology between partitions A, B, and the other populations, and how different PyNN connectors are treated differently during this process. For example, a PyNN <italic>OneToOneConnector</italic> connects each neuron in a population to itself. This results in both partitions A and B having a machine edge representing their own connections, but with no edge required to map the connector from one sub-population to the other. Conversely, the PyNN <italic>FixedProbabilityConnector</italic> links neurons in the source and target populations based on connection probability, and hence requires machine edges to carry all possible synaptic connections (e.g., both between vertices A and B, and to themselves).</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p>Network partitioning to fit machine resources. <bold>(A)</bold> Application graph generated from interpretation of PyNN script: circles represent PyNN populations, and arrows PyNN projections. <bold>(B)</bold> Machine graph partitioned into vertices and edges to suit machine resources: squares represent populations (or partitioned sub-populations) of neurons which fit on a single SpiNNaker core—hence the model described by the machine graph in <bold>(B)</bold> requires 5 SpiNNaker cores for execution.</p>
        </caption>
        <graphic xlink:href="fnins-12-00816-g0003"/>
      </fig>
      <p>Once partitioned, the machine graph is placed onto a virtual representation of a SpiNNaker machine to facilitate allocation of chip-based resources such as cores and memory. Known failed cores, chips and board links which compromise the performance of a SpiNNaker machine are removed from this virtual representation, and the machine graph placed accordingly. Chip-specific routing tables are then generated facilitating transmission of spikes according to the machine edges representing the PyNN-defined projections. These tables are subsequently compressed and loaded into router memory (as described in section 2.1). The Python software stack from Figure <xref ref-type="fig" rid="F2">2</xref> then generates the core-specific neuron and synapse data structures, and loads them onto the SpiNNaker machine using the SpiNNTools software. Core-specific neuron data is loaded to the appropriate DTCM, while the associated synapse data is loaded into core-specific regions of SDRAM on the same chip, ready for use according to section 3.2. Finally, programs for execution on application cores are loaded to ITCM, with each core executing an initialization function to load appropriate datastructures (from SDRAM) and prepare the core before switching to a <italic>Ready</italic> state. Once all simulation cores are <italic>Ready</italic>, the signal to begin simulation is given to all cores from host, and the SNN will execute according to the processes defined in section 3.2.</p>
    </sec>
    <sec>
      <title>3.2. SpiNNaker runtime execution</title>
      <p>sPyNNaker applications execute SNNs via a hybrid simulation approach, using time-driven neuron updates and event-driven synapse updates, similar to that discussed in Morrison et al. (<xref rid="B31" ref-type="bibr">2005</xref>). This neuron update scheme provides a flexible framework in which to embed a range of neuron models, and is of comparable efficiency to event-based approaches when considering biologically representative spike rates. Synapse events are handled efficiently, with no intermediate information required to update synaptic state between presynaptic neuron spikes, which are relatively infrequent on the order of 1Hz in biological networks. Cores executing sPyNNaker applications hold neuron state variables in local DTCM, allowing efficient access to the required datastructures for the periodic time-driven neuron update. Spike transmission between cores is via the Address Event Representation (AER) model (Mead, <xref rid="B29" ref-type="bibr">1989</xref>), with neuronal action potentials communicated as multicast packets, with their key containing only the source neuron ID (in the remainder of this work the terms: action potential, spike, and packet are synonymous). Each packet can be delivered to multiple locations simultaneously via the SpiNNaker routing fabric, replicating the one-to-many connectivity of an axon. Processing of the packet is performed by the core simulating the postsynaptic neuron, which contains functions to evaluate the spike-based synaptic contribution using only the packet key. Due to the potentially large fan-in to a neuron, memory constraints prevent storage of synaptic data in DTCM. Therefore, the source neuron ID is used to locate the associated synaptic data stored in the relatively large but slower SDRAM memory, and copy it locally on spike arrival to facilitate evaluation of the contribution to the synaptic state.</p>
      <p>This section focuses on the deployment of this simulation approach within a single core modeling a sub-population of neurons, such as “Excitatory A” in Figure <xref ref-type="fig" rid="F3">3B</xref>. It includes: an overview of the underlying event-based operating system and low-level software libraries; a discussion of the execution framework and key software functions (also known as callbacks); and finally a discussion of runtime operation giving readers insight into the processing hierarchy. A subsequent discussion of the effect of this simulation approach on neuron and synapse model dynamics is given in section 3.3.</p>
      <sec>
        <title>3.2.1. Operating system and low-level libraries</title>
        <p>To abstract away the complexities of low-level programming and enable focusing on the task of neural modeling, sPyNNaker applications are compiled against the SpiNNaker Application Runtime Kernel (SARK) (Temple, <xref rid="B46" ref-type="bibr">2016</xref>), and the event-driven library SpiN1API (Sharp et al., <xref rid="B40" ref-type="bibr">2011</xref>; SpiNNaker, <xref rid="B44" ref-type="bibr">2011a</xref>). SARK provides low-level hardware management, simplifying interaction with the DMA, Network Interface and Communications controllers. SpiN1API provides an event-based operating system, as shown in Figure <xref ref-type="fig" rid="F4">4</xref>, with three processing threads per core: one for task scheduling, one for task dispatch, and one to service fast interrupt requests (FIQ). SpiN1API also provides the mechanism to link software callbacks to hardware events, and enables triggering of actions such as sending a packet to another core and initiating a DMA. Callbacks are registered with different <italic>priority</italic> levels ranging from -1 to 2 depending on their desired function, with lower numbers scheduled preferentially. Callback tasks of priority 1 &amp; 2 can be queued (in queues of maximum length 15), with new events added to the back of the queue. Callbacks of priority -1 and 0 are not queued, but instead pre-empt tasks assigned higher priority level numbers. Operation of this system follows the flow detailed in Figure <xref ref-type="fig" rid="F4">4A</xref>. The scheduler thread places callbacks in queues for priority levels 1 and above, and the dispatcher picks these callbacks and executes them based on priority. When the dispatcher is executing a callback of priority 1 or higher, and a callback of priority 0 is scheduled, this task pre-empts that currently being executed causing it to be suspended until the higher priority callback has completed. Callbacks of priority −1 use the FIQ thread to interact with the scheduler and dispatcher, enabling fast response and pre-emption of priority 0 and above tasks. Pointers are stored allowing fast access to the callback code, and the processor switches to FIQ banked registers to avoid the need for stacking (Sloss et al., <xref rid="B43" ref-type="bibr">2004</xref>), optimizing the response time of priority −1 callbacks. However, this optimized performance limits the application to registering only a single −1 priority event and callback.</p>
        <fig id="F4" position="float">
          <label>Figure 4</label>
          <caption>
            <p>SpiNNaker realtime OS. <bold>(A)</bold> SpiN1API multi-threaded event-based operating system: scheduler thread to queue callbacks; dispatcher thread to execute callbacks; and FIQ thread to service interrupts from high-priority (-1) events. <bold>(B)</bold> Events and associated callbacks for updating neuron state variables, and processing incoming packets representing spikes into synaptic input. Figures reproduced with permission from Sharp et al. (<xref rid="B40" ref-type="bibr">2011</xref>, <xref rid="B42" ref-type="bibr">2012</xref>).</p>
          </caption>
          <graphic xlink:href="fnins-12-00816-g0004"/>
        </fig>
        <p>In sPyNNaker applications modeling systems of neurons and synapses, callbacks are registered against hardware events: <italic>timer, packet received</italic>, and <italic>DMA complete</italic>; and a software-triggered <italic>user</italic> event, as shown in Table <xref rid="T1" ref-type="table">1</xref>. The associated callbacks facilitate the periodic updating of neuron state, and the event-based processing of synapses when packets representing spikes arrive at a core. These events (squares) and their callbacks (circles) are shown schematically in Figure <xref ref-type="fig" rid="F4">4B</xref>. The function <monospace>timer_callback</monospace> evolves the state of neurons in time, and is called periodically against <italic>timer</italic> events throughout a simulation. A <italic>packet received</italic> event triggers a <monospace>_multicast_packet_received_callback</monospace>, which reads the packet to extract and transfer the source neuron ID to a spike queue. If no spike processing is currently being performed, the software-triggered <italic>user</italic> event is issued, and in turn executes a <monospace>user_callback</monospace> which reads the next ID from the spike queue, locates the associated synaptic information stored in SDRAM, and initiates a DMA to copy it into DTCM for subsequent processing. Finally the <monospace>_dma_complete_callback</monospace> is executed on a <italic>DMA complete</italic> event, and initiates processing of the synaptic contribution(s) to the postsynaptic neuron(s). If on completion of this processing there are items remaining in the input spike queue, this callback initiates processing of the next spike: meaning this collection of callbacks can be thought of as a spike processing pipeline.</p>
        <table-wrap id="T1" position="float">
          <label>Table 1</label>
          <caption>
            <p>Hardware (and single software) events, along with their registered callback and associated priority level.</p>
          </caption>
          <table frame="hsides" rules="groups">
            <thead>
              <tr>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Event</bold>
                </th>
                <th valign="top" align="left" rowspan="1" colspan="1">
                  <bold>Callback</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>Priority</bold>
                </th>
                <th valign="top" align="center" rowspan="1" colspan="1">
                  <bold>Pre-empts Priority</bold>
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <italic>Packet Received</italic>
                </td>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <monospace>_multicast_packet_received_callback</monospace>
                </td>
                <td valign="top" align="center" rowspan="1" colspan="1">−1</td>
                <td valign="top" align="center" rowspan="1" colspan="1">0, 1, 2</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <italic>DMA Complete</italic>
                </td>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <monospace>_dma_complete_callback</monospace>
                </td>
                <td valign="top" align="center" rowspan="1" colspan="1">0</td>
                <td valign="top" align="center" rowspan="1" colspan="1">1, 2</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <italic>Timer</italic>
                </td>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <monospace>timer_callback</monospace>
                </td>
                <td valign="top" align="center" rowspan="1" colspan="1">2</td>
                <td valign="top" align="center" rowspan="1" colspan="1">–</td>
              </tr>
              <tr>
                <td valign="top" align="left" rowspan="1" colspan="1"><italic>User</italic> (Software)</td>
                <td valign="top" align="left" rowspan="1" colspan="1">
                  <monospace>user_callback</monospace>
                </td>
                <td valign="top" align="center" rowspan="1" colspan="1">0</td>
                <td valign="top" align="center" rowspan="1" colspan="1">1, 2</td>
              </tr>
            </tbody>
          </table>
        </table-wrap>
      </sec>
      <sec>
        <title>3.2.2. Time-driven neuron update</title>
        <p>A sPyNNaker simulation typically contains multiple cores, each simulating a different population of neurons (see Figure <xref ref-type="fig" rid="F3">3B</xref>). Each core advances the states of its neurons in time via an explicit update scheme with fixed simulation timestep (Δ<italic>t</italic>). When a neuron is deemed to have fired, packets are delivered to all cores that neuron projects to, and processed in realtime by the postsynaptic core to evaluate the resulting synaptic contribution. Therefore, while all cores operate asynchronously, it is desirable to advance neurons on all cores approximately in parallel in order to march forward a simulation coherently. All cores in a simulation therefore start synchronized, and register <italic>timer</italic> events with common frequency, with the period between events defined by a fixed number of clock cycles, as shown in Figure <xref ref-type="fig" rid="F5">5</xref>. All cores will therefore initiate a <italic>timer</italic> event and execute a <monospace>timer_callback</monospace> to advance the state of their neurons approximately in parallel, although the system is asynchronous as there is no hardware or software mechanism to synchronize cores. Individual update times may vary due to any additional spike processing (see section 3.2.6), however cores which have additional spikes to process between one pair of timer events can catch up during subsequent periods of lower activity. Relative drift between boards is possible due to slight variations in clock speed (from clock crystal manufacturing variability), however this effect is small relative to simulation times (SpiNNaker, <xref rid="B45" ref-type="bibr">2011b</xref>). Small variations placing core updates slightly out of phase can also occur due to the way the “start” signal is communicated, particularly on larger machines, however again this effect is negligible. A consequence of this update scheme is that generated spikes are constrained to the time grid (multiples of the simulation timestep Δ<italic>t</italic>). It also enforces a finite minimum simulation spike transit time between neurons of Δ<italic>t</italic>, as input cannot be guaranteed to arrive in the current timestep before a neuron has been updated. From the hardware perspective, the maximum packet transit time for the million core machine is ≤ 25μs (assuming 200ns per router (SpiNNaker, <xref rid="B45" ref-type="bibr">2011b</xref>), and a maximum path length of 128).</p>
        <fig id="F5" position="float">
          <label>Figure 5</label>
          <caption>
            <p>Time-driven updates by neuron cores simulating the network in Figure <xref ref-type="fig" rid="F3">3B</xref>: periodic <italic>timer</italic> events trigger callbacks advancing neuron states by Δ<italic>t</italic>. Cores can be out of phase due to communication of the start signal, and relative drift can occur due to manufacturing variability between boards. Note that state update times vary with the level of additional spike processing within a simulation timestep, however cores which experience high levels of spike activity delaying the subsequent <monospace>timer_callback</monospace> can catch up during subsequent periods of lower spike activity (as shown by Core 2).</p>
          </caption>
          <graphic xlink:href="fnins-12-00816-g0005"/>
        </fig>
        <p>A design goal of the SpiNNaker platform is to achieve realtime simulation of SNNs, where “realtime” is defined as when the time taken to simulate a network matches the amount of time the network has modeled. Therefore, an SNN with a simulation timestep of Δ<italic>t</italic> = 1ms, requires the period of <italic>timer</italic> events to be set at 200, 000clock cycles (where at 200MHz each clock cycle has a period of 5ns—see section 2.1). This causes 1ms of simulation to be executed in 1ms, meaning the solution will keep up with wall-clock time, enabling advantageous performance, and interaction with systems operating on the same clock (such as robots, humans and animals). In practice, realtime execution is not always possible, and therefore users are free to reduce the value of Δ<italic>t</italic> in special cases, and also adjust the number of clock cycles between <italic>timer</italic> events. For example, if a neuron model requires Δ<italic>t</italic> = 0.1ms for accuracy, it is common practice to let the period between <italic>timer</italic> events remain at 200, 000clock cycles, to ensure there is sufficient processing time to update the neurons and process incoming spikes (Sen-Bhattacharya et al., <xref rid="B38" ref-type="bibr">2018</xref>). This enforces a slowdown factor of 10 relative to realtime.</p>
        <p>From the perspective of an individual core, each neuron is initialized with user-defined parameters at time <italic>t</italic><sub>0</sub> (supplied via a PyNN script). All state variables are then updated one timestep at a time up to the simulation end time <italic>t</italic><sub><italic>end</italic></sub>. The number of required updates and hence <italic>timer</italic> events is calculated based on <italic>t</italic><sub><italic>end</italic></sub> and the user-defined simulation timestep Δ<italic>t</italic> (which is fixed for the duration of simulation). Each call to <monospace>timer_callback</monospace> advances all the neurons on a core by Δ<italic>t</italic> according to Algorithm S1, which is shown schematically on the left-hand side of Figure <xref ref-type="fig" rid="F6">6</xref>. First the synapse state for all neurons on the core is updated according to the model shaping rule, and any new input this timestep is added from the synaptic input buffers (discussed below). Interrupts are disabled during this update to prevent concurrent access to the buffers from spike processing operations. The states of all neurons on the core are then updated sequentially. An individual neuron state at the current time <italic>N</italic><sub><italic>i, t</italic></sub> is accessed in memory, and if the neuron is not refractory, its state is updated according to the model characterizing its sub-threshold dynamics (see examples in section 3.3). If it is judged to have emitted a spike, the refractory dynamics are initiated and the router instructed to send a multicast packet to the network. Finally, all requested neuron variables are recorded as belonging to this new timestep (<italic>t</italic>+Δ<italic>t</italic>), and stored in core memory for subsequent extraction by the SpiNNTools software—interrupts are disabled during this process to prevent concurrent access to recording datastructures.</p>
        <fig id="F6" position="float">
          <label>Figure 6</label>
          <caption>
            <p><bold>(Left)</bold> Update flow advancing state of neuron <italic>N</italic><sub><italic>i</italic></sub> by Δ<italic>t</italic>. <bold>(Center)</bold> Circular synaptic input buffers accumulate scaled input at different locations based on synaptic delay (buffers are rotated one slot at the end of every timestep). <bold>(Right top)</bold> Synaptic input buffer values are converted to fixed-point format and scaled before adding to <italic>N</italic><sub><italic>i</italic></sub>. <bold>(Right bottom)</bold> Decoding of synaptic word into circular synaptic buffer input.</p>
          </caption>
          <graphic xlink:href="fnins-12-00816-g0006"/>
        </fig>
        <p>Synaptic input buffers (Figure <xref ref-type="fig" rid="F6">6</xref>, center) are used to accumulate all synaptic input on a given receptor type, removing the computational cost of managing state variables for individual synapses (as developed in Morrison et al., <xref rid="B31" ref-type="bibr">2005</xref>). Each buffer is constructed from a number of “slots,” where each slot represents input at a future simulation timestep. All input designated to arrive at a particular time is accumulated in the appropriate slot, constraining synapse models to those whose contributions can be summed linearly. A pointer is maintained to the input associated with the proceeding timestep (<italic>t</italic>+Δ<italic>t</italic>). Each neuron update consumes the input addressed by this pointer and then advances it forward one slot (effectively rotating the buffer). When the pointer reaches the last slot it cycles back to the first, meaning these slots continuously represent input over the next <italic>d</italic> timesteps, where <italic>d</italic> is the number of slots. By default the value of <italic>d</italic> is set via a 4-bit unsigned integer, enabling representation of delays up to 16 timesteps (however section 3.4.2 contains information on extending this delay). In the default sPyNNaker implementation a synaptic input buffer is created per neuron, per receptor type, and is a collection of 16 slots each constructed from unsigned 16-bit integers. The use of an integer representation reduces buffer size in DTCM, and also the size of synaptic weights in SDRAM, relative to using standard 32-bit fixed point <italic>accum</italic> type. However, it requires conversion to <italic>accum</italic> type for use in the neuron model calculations—as shown in Figure <xref ref-type="fig" rid="F6">6</xref>. This conversion is performed via a union and left-shift, the size of which represents a trade-off between headroom and precision. An example shift of 6 is shown, causing the smallest bit of the synaptic input buffer to represent 2<sup>−9</sup> = 1.953125 × 10<sup>−3</sup>, and the largest 2<sup>7</sup> = 128, in the <italic>accum</italic> type of the synapse state. Under extreme conditions a buffer slot will saturate from concurrent spike activity, meaning the shift size should be increased. However, the shift is also intrinsic to the weight representation and affects precision, as all weights must be scaled by 2<sup>(15−<italic>shift</italic>)</sup> before being written as integers to the synaptic matrices discussed in section 3.2.5. For example, in Figure <xref ref-type="fig" rid="F6">6</xref> a weight of 1.15nA was converted to 589 on host during generation of synaptic data, but is returned as 1.150390625nA when used during simulation (with a shift of 6). The shift value is currently calculated by the sPyNNaker toolchain to provide a balance between handling large weights, high fan-in and/or presynaptic firing rates, and maintaining precision—see van Albada et al. (<xref rid="B47" ref-type="bibr">2018</xref>) for further details.</p>
      </sec>
      <sec>
        <title>3.2.3. Receiving a spike</title>
        <p>A <monospace>_multicast_packet_received_callback</monospace> is triggered by a <italic>packet received</italic> event, raised when a multicast packet arrives at the core. This callback is assigned highest priority (−1), and hence makes use of the FIQ thread and pre-empts all other core processing (see Figure <xref ref-type="fig" rid="F4">4A</xref>). This callback cannot be queued, therefore to prevent traffic backing up on the network this callback is designed to execute quickly, and simply extracts the source neuron ID (from the 32-bit key) and stores it in an input spike buffer for subsequent processing. Note that by default this buffer is 256 entries long, enabling queuing of 256 spikes simultaneously. The callback then checks for activity in the spike processing pipeline, and registers a <italic>user</italic> event if inactive. Pseudo code for this callback is available in Algorithm S2.</p>
      </sec>
      <sec>
        <title>3.2.4. Activation of the spike processing pipeline</title>
        <p>A <monospace>user_callback</monospace> callback is triggered by the <italic>user</italic> event registered in a section 3.2.3, and kick-starts the spike processing pipeline. The callback locates in SDRAM the synaptic data associated with the spike ID, and initiates its DMA transfer to DTCM for subsequent processing. Three core-specific data structures are used in this process, the: <italic>master population table, address list</italic>, and <italic>synaptic matrix</italic>. Use of these datastructures is shown schematically in Figure <xref ref-type="fig" rid="F7">7</xref>, from the perspective of the core simulating the Excitatory A population in Figure <xref ref-type="fig" rid="F3">3B</xref>, when receiving a spike from the Excitatory A population. The <italic>master population table</italic> is a lightweight list taking a masked source neuron ID as the key by which a source vertex can be identified. Each row pertains to a single source vertex, and consists of: 32-bit key; 32-bit mask; 16-bit start location of the first row in the <italic>address list</italic> pertaining to this source vertex; and a 16-bit value defining the number of rows, where each row in the <italic>address list</italic> represents a PyNN projection. When searching this table the key from the incoming packet is masked using each entry-specific mask before comparing to the entry key. This masks off the individual neuron ID bits, and enables source vertices to simulate different numbers of neurons. The entry keys are masked on host before loading for efficiency, and are structured to prevent overlap after masking and facilitate binary searching. The structure of an <italic>address list</italic> row consists of: a single header bit detailing whether the synaptic matrix associated with this projection is located in DTCM or SDRAM; 32-bit memory address indicating the first row of the synaptic matrix; and an 8-bit value detailing the synaptic matrix row length (i.e., the maximum number of postsynaptic neurons connected to by a presynaptic neuron in a particular projection). Note that synaptic matrix rows are indexed by source neuron ID, and that all rows are padded to the maximum row length to facilitate retrieval, including empty rows for presynaptic neurons not connected to neurons on this core. The row data structure is covered in detail in section 3.2.5.</p>
        <fig id="F7" position="float">
          <label>Figure 7</label>
          <caption>
            <p>Data structures for processing incoming spikes: <italic>Master Population Table, Address List</italic>, and <italic>Synaptic Matrix</italic>; shown from the perspective of the core simulating the Excitatory A population in Figure <xref ref-type="fig" rid="F3">3B</xref>. The path in bold represents that taken when a packet is received by Excitatory A, originating from itself, and hence two projections must be processed.</p>
          </caption>
          <graphic xlink:href="fnins-12-00816-g0007"/>
        </fig>
        <p>This callback therefore takes from the input spike buffer the next spike ID to process, and uses it in a binary search of the <italic>master population table</italic> to locate the <italic>address list</italic> regions capturing the projections carrying the spike to this vertex. The SDRAM location and size specified by each row are then used in sequential processing of the projections. For the case shown in Figure <xref ref-type="fig" rid="F7">7</xref>, searching the <italic>master population table</italic> yields two rows in the <italic>address list</italic>, which in turn define the location of the corresponding synaptic matrices in SDRAM. Each synaptic matrix is indexed according to presynaptic neuron ID, enabling location of the appropriate row to copy to core DTCM for processing of each spike. Details of this row are then passed to the DMA controller to begin the data transfer, marking the end of the callback. This allows the core to return to processing other callbacks, hiding the DMA transfer as shown for “Spike 1” in Figure <xref ref-type="fig" rid="F9">9</xref>.</p>
        <fig id="F9" position="float">
          <label>Figure 9</label>
          <caption>
            <p>Interaction of callbacks shown over the time period between two <italic>timer</italic> events. Four spike events are processed representing the scenarios: receiving a packet while processing a <italic>timer</italic> event; receiving a packet while the core is idling; and receiving a packet while the spike processing pipeline is active. Note that a lighter color shade indicates suspension of a callback, which is resumed on completion of higher priority tasks.</p>
          </caption>
          <graphic xlink:href="fnins-12-00816-g0009"/>
        </fig>
      </sec>
      <sec>
        <title>3.2.5. Synapse processing</title>
        <p>On completion of the DMA in section 3.2.4, a <italic>DMA complete</italic> event triggers a <monospace>_dma_complete_callback</monospace>, initiating processing of the synaptic row. As described previously, each row pertains to synapses made, within a single PyNN projection, between a single presynaptic neuron and multiple postsynaptic neurons. At the highest level, a synaptic row is an array of synaptic words, where each word is defined as a 32-bit unsigned integer. The row is split into three designated regions to enable identification of static and plastic synapses (connections capable of changing their weight at runtime). The row regions contain: dynamic plastic data; constant fixed plastic data; and static data. Three header fields are also included, detailing the size of each region and enabling easy navigation of the row. A schematic breakdown of the synaptic row structure is detailed in Figure <xref ref-type="fig" rid="F8">8</xref>. Note that because a PyNN projection cannot be both static and plastic simultaneously, a single row contains only either static or plastic data. Plastic data is intentionally segregated into dynamic and fixed regions to facilitate processing. While all plastic data must be copied locally to evaluate synaptic contributions to a neuron, only the dynamic region—i.e., that changing at runtime—requires updating for use when processing subsequent spikes. Keeping this dynamic data in a separate block facilitates writing back to the synaptic matrix with a single DMA, and writing back less data helps compensate for reduced DMA write bandwidth (relative to read—see section 2.1).</p>
        <fig id="F8" position="float">
          <label>Figure 8</label>
          <caption>
            <p>Synaptic row structure with breakdown of substructures for both static and plastic synapses.</p>
          </caption>
          <graphic xlink:href="fnins-12-00816-g0008"/>
        </fig>
        <p>The static region occupies the lower portion of the synaptic row, and is itself an array of synaptic words, where each word corresponds to a synaptic connection between the row's presynaptic neuron and a single postsynaptic neuron. As shown in Figure <xref ref-type="fig" rid="F8">8</xref>, each 32-bit data structure is split such that the top 16 bits represent the weight, while the lower 16 bits typically split: bottom 8 bits specifying the postsynaptic neuron ID; 1 bit to specify the synapse type (excitatory 0, or inhibitory 1); 4 bits to specify synaptic delay; leaving 3 bits of padding (useful for model customization, e.g., adding additional receptor types). Data defining plastic synapses is divided across the dynamic and fixed regions. Fixed plastic data is defined by a 16-bit unsigned integer, and matches the structure of the lower half of a static synapse (see lower half of Figure <xref ref-type="fig" rid="F8">8</xref>). These 16-bit synaptic half-words enable double-packing inside the 32-bit array of the synaptic row, meaning an empty half-slot will be apparent if the row targets an odd number of postsynaptic neurons. The dynamic plastic region contains a header defining the <italic>Presynaptic Event History</italic>, followed by a series of <italic>Synapse Structures</italic> capturing the weight of each synapse. Note that for typical plasticity models this defaults to the same 16-bit weight describing static synapses, however <italic>Synapse Structure</italic> can be extended to include additional parameters (in multiples of 16 bits) if required by a given plasticity rule.</p>
        <p>A task of the <monospace>_dma_complete_callback</monospace> is therefore to convert the synaptic row into individual postsynaptic neuron input. The callback processes the row headers to ascertain whether it contains static or plastic data, adjusts synapses according to a given plasticity rule, and then loops over each synaptic word and extracts its neuronal contribution—pseudo code for this callback is detailed in Algorithm S4. An example of this process for a single static synaptic word is shown in the lower-right of Figure <xref ref-type="fig" rid="F6">6</xref>, where a synaptic word of [00000010010011010001010100001100] leads to a contribution of 589 to slot 10 of the inhibitory synaptic input buffer for neuron <italic>N</italic><sub>12</sub>.</p>
      </sec>
      <sec>
        <title>3.2.6. Callback interaction</title>
        <p>The callbacks described above define how a sPyNNaker application responds to hardware events and updates an SNN simulation. The interaction of these events is a complex process, with the potential to impact the ability of a SpiNNaker machine to perform realtime execution. Figure <xref ref-type="fig" rid="F9">9</xref> covers the time between two <italic>timer</italic> events, and shows interaction of spike processing and neuron update callbacks for four scenarios detailed by the arrival of spikes 1–4. The first <italic>timer</italic> event initiates processing of the neuron update, however after completion of approximately one third of the update, the core receives Spike 1, interrupting the <monospace>timer_callback</monospace> and triggering execution of a <monospace>_multicast_packet_received_callback</monospace>, which in turn raises a <italic>user</italic> event, initiating DMA transfer of the appropriate synaptic information. On completion of the callback, the core returns to the <monospace>timer_callback</monospace>, with the DMA transfer occurring in parallel. On completion of the DMA, a <monospace>_dma_complete_callback</monospace> is initiated, which processes the transferred synaptic information into neuronal input. The core then returns to the <monospace>timer_callback</monospace>, which continues to completion. The core is idle when it receives Spike 2, therefore processing of the spike begins immediately, and the subsequent <italic>user</italic> event and hence DMA request is initiated. While waiting for the data to transfer, Spike 3 is received, and the associated <monospace>_multicast_packet_received_callback</monospace> processed. This time, due to the active spike processing pipeline, no <italic>user</italic> event is raised, and instead the DMA for Spike 3 is initiated at the beginning of the <monospace>_dma_complete_callback</monospace> triggered by Spike 2. Whilst processing this callback, Spike 4 is received, and the associated <monospace>_multicast_packet_received_callback</monospace> interrupts the core to place the packet key in the input spike buffer. This buffer entry is eventually processed at the beginning of the <monospace>_dma_complete_callback</monospace> for Spike 3, demonstrating the spike processing pipeline in action. This also shows the benefit of having two hardware “threads” working in parallel, as the core is utilized completely, and the DMA transfer hidden behind the <monospace>_dma_complete_callback</monospace>, when the pipeline is active. Finally, after an idle period (where the processor is put to sleep in a low energy state) the next <italic>timer</italic> event is issued at time <italic>t</italic>+Δ<italic>t</italic>.</p>
        <p>From Figure <xref ref-type="fig" rid="F9">9</xref> it is seen that core processing is dependent on SNN activity. When targeting realtime execution (section 3.2.2), it is important to consider extreme circumstances and how they will affect both the core and global simulation. For example, it is clear from Figure <xref ref-type="fig" rid="F9">9</xref> that when a core receives spikes, it can delay completion of the <monospace>timer_callback</monospace> due to the assigned callback priorities (as shown in Figure <xref ref-type="fig" rid="F5">5</xref>). This is a design choice, as it helps maximize core utilization by hiding DMA transfers behind the <monospace>timer_callback</monospace> when the spike processing pipeline is inactive. However, in the extreme case spike processing will delay completion of the callback beyond the issuing of the next <italic>timer</italic> event. While the core can potentially catch up this lost time, this scenario has the potential to delay the neuron update beyond a single <italic>timer</italic> event, and ultimately cause any spike packets emitted from this core to be received and processed at the wrong time by the rest of the network. To guard against this, sPyNNaker applications report any occurrences of an overrun, where a <monospace>timer_callback</monospace> is not complete before the next <italic>timer</italic> event is raised; and also the maximum number of <italic>timer</italic> events that a single <monospace>timer_callback</monospace> overruns. Similar metrics are also reported when the input spike buffer overflows (exceeds 256 entries), and when the synaptic input buffers saturate. Together these metrics provide a window into the ability of a core to handle the required processing within a simulation.</p>
        <p>Another important performance consideration when responding to spike packets using prioritized events is the time taken to switch between the associated callbacks. Events are displayed in Figure <xref ref-type="fig" rid="F9">9</xref> by solid black lines, the width of which represents the time taken to switch context and begin execution of the callback. The <monospace>timer_callback</monospace> takes longest to respond due to queuing of events with priority &gt;0; while the <monospace>_multicast_packet_received_callback</monospace> is quickest due to its priority of −1 and use of the FIQ thread. Other chip-level factors can also influence execution, such as SDRAM contention with applications running on adjacent cores. As DMAs are processed in serial bursts, if multiple simultaneous requests are received by the SDRAM controller, there may be latency in beginning the DMA for some cores, and a reduced rate of transfer (see section <xref ref-type="supplementary-material" rid="SM1">S1.2</xref> in Supplementary Material for further information).</p>
      </sec>
    </sec>
    <sec>
      <title>3.3. Neural modeling</title>
      <p>At the heart of a sPyNNaker application is the solution of a series of mathematical models governing neural dynamics. It is these models which determine how incoming spikes affect a neuron and when a neuron itself reaches threshold. While the preceding section described the underlying event-based operating system facilitating simulation and interaction of neurons, this section focuses on the solution of equations governing neural state, and how they are structured in software.</p>
      <sec>
        <title>3.3.1. Software structure</title>
        <p>PyNN defines a number of standard cell models, such as the leaky integrate and fire (LIF) neuron, and the Izhikevich neuron. Implementations of these standard models are included in sPyNNaker, however the API is also designed to support users wishing to extend this core functionality and implement neuron models of their own. To facilitate this extension the model framework is defined in an object-oriented fashion, through the use of C code on the SpiNNaker machine. This modular approach provides structure and aids code re-use between different models (e.g., sharing of a synaptic plasticity rule between different neuron models). A neuron model is built from components:
<list list-type="simple"><list-item><p>– <italic>synapse_type</italic>, defining how synapse state evolves between presynaptic spikes, and how contributions from new spikes are added to the model. A fundamental requirement is that multiple synaptic inputs can be summed and shaped linearly, such as the α-kernel (Destexhe et al., <xref rid="B12" ref-type="bibr">2014</xref>).</p></list-item><list-item><p>– <italic>neuron_model</italic>, implementing the sub-threshold update scheme and refractory dynamics.</p></list-item><list-item><p>– <italic>input_type</italic>, governing the process of converting synaptic input into neuron input current. Examples include current-based and conductance-based formulations (Dayan and Abbott, <xref rid="B11" ref-type="bibr">2005</xref>).</p></list-item><list-item><p>– <italic>threshold_type</italic>, defining a system against which a neuron membrane potential is compared to adjudge whether the neuron has emitted a spike.</p></list-item><list-item><p>– <italic>additional_input_type</italic>, offering a flexible framework to model intrinsic currents dependent on the instantaneous membrane potential, and potentially responding discontinuously on neuron firing (such as the Ca<sup>2+</sup>-activated K<sup>+</sup> current described in Liu and Wang, <xref rid="B28" ref-type="bibr">2001</xref>).</p></list-item></list></p>
        <p>The individual model components each produce a subset of the neuron and synapse dynamics, and are therefore the entry point for a user looking to deploy a custom neuron model<xref ref-type="fn" rid="fn0003"><sup>3</sup></xref>. In-keeping with the aforementioned software stacks in Figure <xref ref-type="fig" rid="F2">2</xref>, interfaces to each component are written in both Python and C. A single instance of each component is collected via a C header file, and compiled against the underlying operating system described in section 3.2 to generate a runtime application. Python classes for each component facilitate user-interaction with each part of the model, enabling setting of parameter values and initial conditions from a PyNN SNN script.</p>
        <p>The runtime execution framework calls each component as part of the <monospace>timer_callback</monospace>, as detailed in Algorithm <xref ref-type="supplementary-material" rid="SM1">S1</xref> (Supplementary Material) and shown schematically in Figure <xref ref-type="fig" rid="F6">6</xref>. First the synaptic state is advanced forward in time by a single simulation timestep, using the functions defined by the <italic>synapse_type</italic> component. Core interrupts are disabled during this process to prevent concurrent access of the synaptic input buffers from a <monospace>_dma_complete_callback</monospace>. Interrupts are re-enabled when all synaptic states for all receptor types for all neurons on a core have been updated. Each neuron then has its state advanced by Δ<italic>t</italic>. The <italic>input_type</italic> component is called first, converting the updated synaptic state into neuron input current. This includes separate excitatory and inhibitory components, with core implementations capable of handling both current- and conductance-based formulations. The <italic>additional_input</italic> component is then evaluated to calculate the level of any intrinsic currents. The synaptic and intrinsic currents, together with any background current, are then supplied to the <italic>neuron_model</italic> component which subsequently marches forward the neuron state by Δ<italic>t</italic>. The neuron membrane potential is now passed to the <italic>threshold_type</italic> component which tests whether the neuron has fired. If the neuron is above threshold a number of actions are performed: a refractory counter begins to instigate any refractory period; the <italic>additional_input</italic> is notified of the spike to allow updating of appropriate state variables; and finally the core is instructed to send a multicast packet to the router with the neuron ID as key.</p>
      </sec>
      <sec>
        <title>3.3.2. Leaky integrate and fire neuron</title>
        <p>The sPyNNaker implementation of a current-based leaky integrate and fire neuron (LIF) is described by the hybrid system in Equations (1) and (2). The sub-threshold dynamics are governed according to Equation (1), where <italic>V</italic> is the membrane potential, <italic>I</italic> the input current (combining synaptic, intrinsic and background input), <italic>R</italic><sub><italic>m</italic></sub> the membrane resistance, τ<sub><italic>m</italic></sub> the membrane leak time constant, and <italic>E</italic><sub><italic>l</italic></sub> the membrane leak (resting) potential.</p>
        <disp-formula id="E1">
          <label>(1)</label>
          <mml:math id="M1">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>V</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mtd>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:mo>-</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>V</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mrow>
                        <mml:mo stretchy="false">(</mml:mo>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>E</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>l</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mo>+</mml:mo>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>R</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>m</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                          <mml:mi>I</mml:mi>
                          <mml:mrow>
                            <mml:mo stretchy="false">(</mml:mo>
                            <mml:mrow>
                              <mml:mi>t</mml:mi>
                            </mml:mrow>
                            <mml:mo stretchy="false">)</mml:mo>
                          </mml:mrow>
                        </mml:mrow>
                        <mml:mo stretchy="false">)</mml:mo>
                      </mml:mrow>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>τ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>m</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mtext>  </mml:mtext>
                  <mml:mtext class="textrm" mathvariant="normal">if</mml:mtext>
                  <mml:mi>V</mml:mi>
                  <mml:mo>&gt;</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>V</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>θ</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>,</mml:mo>
                  <mml:mi>V</mml:mi>
                  <mml:mo>=</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>V</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>r</mml:mi>
                      <mml:mi>e</mml:mi>
                      <mml:mi>s</mml:mi>
                      <mml:mi>e</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <disp-formula id="E2">
          <label>(2)</label>
          <mml:math id="M2">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>I</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mi>y</mml:mi>
                          <mml:mi>n</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mtd>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:mo>-</mml:mo>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>I</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mi>y</mml:mi>
                          <mml:mi>n</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>τ</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>s</mml:mi>
                          <mml:mi>y</mml:mi>
                          <mml:mi>n</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                  </mml:mfrac>
                  <mml:mo>+</mml:mo>
                  <mml:mi>δ</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>If <italic>V</italic> exceeds the threshold level <italic>V</italic><sub>θ</sub>, the neuron is reported to have spiked and <italic>V</italic> is set to the reset potential <italic>V</italic><sub><italic>reset</italic></sub> for the refractory period duration <italic>t</italic><sub><italic>r</italic></sub>. Synaptic currents <italic>I</italic><sub><italic>syn</italic></sub> are modeled according to Equation (2), where τ<sub><italic>syn</italic></sub> is the synaptic time constant (independent value for each receptor type), and the delta function represents addition of a step change in input from the weight of an incoming spike.</p>
        <p>The sPyNNaker implementation embeds Equation (2) in a <italic>synapse type</italic> component, providing mechanisms to update the input current both between spikes (i.e., when the synaptic input buffer contribution is zero), and on spike arrival. Exact integration is used to update the synapse state during the periodic neuron update, with step changes made from synaptic input buffer contributions according to Equation (3).</p>
        <disp-formula id="E3">
          <label>(3)</label>
          <mml:math id="M3">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>I</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>I</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>e</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mo>-</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>Δ</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>τ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>s</mml:mi>
                              <mml:mi>y</mml:mi>
                              <mml:mi>n</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>Σ</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>w</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>i</mml:mi>
                      <mml:mi>j</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mi>δ</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>j</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>The constant factor <inline-formula><mml:math id="M4"><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mo>-</mml:mo><mml:mfrac><mml:mrow><mml:mi>Δ</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>τ</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mi>y</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:msup></mml:math></inline-formula> is pre-calculated before loading to the SpiNNaker machine to avoid evaluation at runtime, as both the divide and exponential operations are relatively expensive on the ARM968 (≈100 clock cycles each). A <italic>neuron model</italic> component captures the neuron state update mechanism, which solves Equation (1) via exponential integration (Rotter and Diesmann, <xref rid="B35" ref-type="bibr">1999</xref>) and assuming the change in current over the timestep is small (Dayan and Abbott, <xref rid="B11" ref-type="bibr">2005</xref>), yielding the update function in Equation (4).</p>
        <disp-formula id="E4">
          <label>(4)</label>
          <mml:math id="M5">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>V</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mn>1</mml:mn>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>=</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>E</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>l</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>+</mml:mo>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>R</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>m</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:msub>
                    <mml:mrow>
                      <mml:mi>I</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                      <mml:mo>+</mml:mo>
                      <mml:mi>Δ</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:msub>
                  <mml:mo>-</mml:mo>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>e</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mo>-</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mi>Δ</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:msub>
                            <mml:mrow>
                              <mml:mi>τ</mml:mi>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>m</mml:mi>
                            </mml:mrow>
                          </mml:msub>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>E</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>l</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>+</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>R</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>m</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>I</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                          <mml:mo>+</mml:mo>
                          <mml:mi>Δ</mml:mi>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>-</mml:mo>
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>V</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>t</mml:mi>
                        </mml:mrow>
                      </mml:msub>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>To compensate for this assumption, <italic>w</italic><sub><italic>ij</italic></sub> is decayed before adding to the synapse to ensure the total charge input to a neuron matches the exact solution (van Albada et al., <xref rid="B47" ref-type="bibr">2018</xref>). Static thresholding defined via the <italic>threshold type</italic>, compares the instantaneous membrane potential to the threshold level <italic>V</italic><sub>θ</sub>.</p>
      </sec>
      <sec>
        <title>3.3.3. Izhikevich neuron</title>
        <p>The Izhikevich neuron model (Izhikevich, <xref rid="B22" ref-type="bibr">2003</xref>), allows reproduction of biologically observed neuronal characteristics such as spiking and bursting. Its dynamics follow a type of “quadratic integrate and fire” model, as detailed in Equation (5)</p>
        <disp-formula id="E5">
          <label>(5)</label>
          <mml:math id="M6">
            <mml:mtable class="eqnarray" columnalign="left">
              <mml:mtr>
                <mml:mtd>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>v</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mtd>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:mn>0</mml:mn>
                  <mml:mo>.</mml:mo>
                  <mml:mn>04</mml:mn>
                  <mml:msup>
                    <mml:mrow>
                      <mml:mi>v</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                    </mml:mrow>
                  </mml:msup>
                  <mml:mo>+</mml:mo>
                  <mml:mn>5</mml:mn>
                  <mml:mi>v</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mn>140</mml:mn>
                  <mml:mo>-</mml:mo>
                  <mml:mi>u</mml:mi>
                  <mml:mo>+</mml:mo>
                  <mml:mi>I</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr>
                <mml:mtd>
                  <mml:mfrac>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>u</mml:mi>
                    </mml:mrow>
                    <mml:mrow>
                      <mml:mi>d</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:mrow>
                  </mml:mfrac>
                </mml:mtd>
                <mml:mtd>
                  <mml:mo>=</mml:mo>
                  <mml:mi>a</mml:mi>
                  <mml:mrow>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mrow>
                      <mml:mi>b</mml:mi>
                      <mml:mi>v</mml:mi>
                      <mml:mo>-</mml:mo>
                      <mml:mi>u</mml:mi>
                    </mml:mrow>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <disp-formula id="E7">
          <label>(6)</label>
          <mml:math id="M8">
            <mml:mtext>if</mml:mtext>
            <mml:mi>v</mml:mi>
            <mml:mo>≥</mml:mo>
            <mml:msub>
              <mml:mi>V</mml:mi>
              <mml:mi>θ</mml:mi>
            </mml:msub>
            <mml:mo>,</mml:mo>
            <mml:mtext>then</mml:mtext>
            <mml:mrow>
              <mml:mo>{</mml:mo>
              <mml:mrow>
                <mml:mtable columnalign="left">
                  <mml:mtr columnalign="left">
                    <mml:mtd columnalign="left">
                      <mml:mrow>
                        <mml:mi>v</mml:mi>
                        <mml:mo>←</mml:mo>
                        <mml:mi>c</mml:mi>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr columnalign="left">
                    <mml:mtd columnalign="left">
                      <mml:mrow>
                        <mml:mi>u</mml:mi>
                        <mml:mo>←</mml:mo>
                        <mml:mi>u</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>d</mml:mi>
                      </mml:mrow>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:mrow>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>where <italic>v</italic> and <italic>u</italic> are dimensionless variables representing the membrane potential and a recovery variable, respectively. Dimensionless parameters <italic>a</italic>, <italic>b</italic>, <italic>c</italic>, and <italic>d</italic> are used to tune the model dynamics, and <italic>I</italic> represents combined background, intrinsic and synaptic currents. If <italic>v</italic> exceeds a threshold <italic>V</italic><sub>θ</sub>, <italic>v</italic> and <italic>u</italic> are reset according to Equation (6).</p>
        <p>The sPyNNaker implementation of this model uses the same <italic>synapse type</italic>, current-based <italic>input type</italic>, and static <italic>threshold type</italic> components as the aforementioned LIF implementation. However, updating the neuron state and hence solving the system defined by Equation (5) requires numerical integration. A range of solvers were explored with fixed-point datatypes in Hopkins and Furber (<xref rid="B20" ref-type="bibr">2015</xref>), with the RK-2 midpoint preferred as a trade-off between speed and accuracy. The resulting explicit update scheme is detailed in Equation (7).</p>
        <disp-formula id="E9">
          <label>(7)</label>
          <mml:math id="M10">
            <mml:mtable columnalign="left">
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mi>θ</mml:mi>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mn>140</mml:mn>
                    <mml:mo>+</mml:mo>
                    <mml:msub>
                      <mml:mi>I</mml:mi>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>Δ</mml:mi>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>−</mml:mo>
                    <mml:msub>
                      <mml:mi>u</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mtext>  </mml:mtext>
                    <mml:mi>α</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mi>θ</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mn>5</mml:mn>
                    <mml:mo>+</mml:mo>
                    <mml:mn>0.04</mml:mn>
                    <mml:msub>
                      <mml:mi>v</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:msub>
                      <mml:mi>v</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mi>η</mml:mi>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:mfrac>
                      <mml:mi>h</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:mfrac>
                    <mml:mo>+</mml:mo>
                    <mml:msub>
                      <mml:mi>v</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mtext>  </mml:mtext>
                    <mml:mi>β</mml:mi>
                    <mml:mo>=</mml:mo>
                    <mml:mo>−</mml:mo>
                    <mml:mfrac>
                      <mml:mi>h</mml:mi>
                      <mml:mn>2</mml:mn>
                    </mml:mfrac>
                    <mml:mi>a</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>u</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:mi>b</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:msub>
                      <mml:mi>v</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>v</mml:mi>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>Δ</mml:mi>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mi>v</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:mi>h</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>β</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mn>0.04</mml:mn>
                    <mml:mi>η</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mn>5</mml:mn>
                    <mml:mo stretchy="false">)</mml:mo>
                    <mml:mi>η</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>θ</mml:mi>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
              <mml:mtr columnalign="left">
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:msub>
                      <mml:mi>u</mml:mi>
                      <mml:mrow>
                        <mml:mi>t</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:mi>Δ</mml:mi>
                        <mml:mi>t</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                  </mml:mrow>
                </mml:mtd>
                <mml:mtd columnalign="left">
                  <mml:mrow>
                    <mml:mo>=</mml:mo>
                    <mml:msub>
                      <mml:mi>u</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mo>+</mml:mo>
                    <mml:mi>a</mml:mi>
                    <mml:mi>h</mml:mi>
                    <mml:mo stretchy="false">(</mml:mo>
                    <mml:mi>b</mml:mi>
                    <mml:mi>η</mml:mi>
                    <mml:mo>+</mml:mo>
                    <mml:mi>β</mml:mi>
                    <mml:mo>−</mml:mo>
                    <mml:msub>
                      <mml:mi>u</mml:mi>
                      <mml:mi>t</mml:mi>
                    </mml:msub>
                    <mml:mo stretchy="false">)</mml:mo>
                  </mml:mrow>
                </mml:mtd>
              </mml:mtr>
            </mml:mtable>
          </mml:math>
        </disp-formula>
        <p>While it is hard to recognize the original equations in this form, refactoring of the update scheme and algebraic manipulation leads to several improvements in the implementation. The use of intermediate variables not only enables compiler optimizations improving speed and code size, but also helps prevent over/underflow of the <italic>accum</italic> datatype during intermediate calculations (Hopkins and Furber, <xref rid="B20" ref-type="bibr">2015</xref>).</p>
      </sec>
    </sec>
    <sec>
      <title>3.4. Auxiliary application code</title>
      <p>While neuron-simulating applications capture the core operations of an SNN, several additional sPyNNaker applications are required to generate network input and facilitate network operation. These single-core applications are built following similar principals to those defined in section 3.2, responding via the same event-based operating system to send and receive packets, and interact with neuron cores. They are embedded in the machine graph during network preprocessing, and loaded onto a SpiNNaker machine together with configuration data.</p>
      <sec>
        <title>3.4.1. Spike input generation</title>
        <p>Generating spikes is an integral part of SNN simulation. It enables modeling of network response to specific patterns of spikes, and input representing adjacent brain regions or background noise. The sPyNNaker API includes two applications for spike generation: <italic>Spike Source Array</italic>, and <italic>Poisson Spike Source</italic>. These applications are built from compiled C and require a single SpiNNaker core per instance. They follow <italic>timer</italic> events in parallel (but asynchronously) with neuron-simulating cores, and send multicast packets representing spikes as discussed previously. These applications do not receive spikes, and hence have their functionality encoded entirely in callbacks registered against <italic>timer</italic> events. As with all sPyNNaker applications, a corresponding Python class enables construction of a spike generator in a PyNN script, and allows configuration data to be specified and subsequently loaded to a SpiNNaker machine.</p>
        <p>The <italic>Spike Source Array</italic> application contains a population of neuron-like units which emit spikes at specific times (see Code S1). The times and keys to emit are stored in SDRAM and only copied into local DTCM when required during execution. The buffer of times/keys is pre-loaded up to memory limits and can be replenished during execution by sending requests to the host, although this is limited by the bandwidth of the on-board Ethernet. Callbacks issued on <italic>timer</italic> events (corresponding to timestep updates on neuron cores) then send packets to the router at the prescribed times.</p>
        <p>The <italic>Poisson Spike Source</italic> application emits packets according to a Poisson distribution about a given frequency. A population of neuron-like units is specified, each of which can be assigned an individual mean firing rate (see Code S1). At runtime, periodic <italic>timer</italic> events trigger a callback every simulation timestep Δ<italic>t</italic>, which assesses whether the core should send a packet to the router representing a spike. A distinction is made between slow and fast Poisson spike sources based on whether they emit fewer or greater than 1 spike per Δ<italic>t</italic>. For fast spike sources, the number of spikes to send between <italic>timer</italic> events is calculated, and the corresponding packets sent interspersed with random delays. This random spacing reduces the chance of synchronized spike arrival at postsynaptic cores, easing pressure on both the source and target routers. For slow sources, after each spike, an inter-spike interval is evaluated in multiples of Δ<italic>t</italic>, which is then counted down between sending packets. For fast spike sources, the postsynaptic core is likely to retrieve from SDRAM the same pieces of synaptic matrix many times during a simulation. Therefore, to remove the overhead of the DMA, a mechanism is included to store the synaptic matrices from fast spike sources in DTCM.</p>
      </sec>
      <sec>
        <title>3.4.2. Simulating extended synaptic delays</title>
        <p>While there is a mechanism in the synaptic row to account for delays of up to 16Δ<italic>t</italic>, it can be necessary to prescribe longer delays (particularly when Δ<italic>t</italic> is small). To account for this case, an application called a <italic>delay extension</italic> is created (van Albada et al., <xref rid="B47" ref-type="bibr">2018</xref>), running on an adjacent core. Packets representing spikes exhibiting a delay ≥16Δ<italic>t</italic> are routed to the core running this application, which subsequently sends new spikes targeting the postsynaptic core after a sufficient portion of the delay has elapsed such that any remaining delay can be handled within the synaptic row.</p>
        <p>Two datastructures are used to manage delay handling: a “delay stage configuration” is generated during preprocessing, and captures the size of delay associated with each presynaptic neuron; and a “spike counter” registers the time and presynaptic neuron of incoming spikes. Two callbacks are used in the <italic>delay extension</italic>, registered against <italic>packet received</italic> and <italic>timer</italic> hardware events. On packet arrival the first callback extracts the presynaptic neuron ID to an input spike buffer, similar to the process described in section 3.2.3. The second callback is executed on <italic>timer</italic> events occurring in parallel (but asynchronously) with those on neuron processing cores. The callback processes any spikes received since the previous <italic>timer</italic> event, taking entries from the input spike buffer and using them to update the spike counting datastructure to register the incoming spikes against multiples of the number of synaptic input buffer slots on the corresponding postsynaptic core. There are typically 16 such slots, where in this context a collection of 16 slots is referred to as a “delay stage.” A second data structure captures how many delay stages each spike should be held for before being released to the postsynaptic core. Therefore, using these two data structures it is possible to assess the incoming spikes to calculate the corresponding outgoing spike times, and hence schedule the necessary spikes for distribution to the network.</p>
        <p>While this application solves the problem of simulating extended delays, it cannot do so indefinitely and an effective new upper limit of 144Δ<italic>t</italic> is enforced due to DTCM constraints. It should also be noted that this mechanism introduces additional overhead to the system: an extra core is required to run the application; and two packets are now required to transmit a spike. The postsynaptic core also performs additional processing during look-up of the source vertex in the <italic>master population table</italic>. An additional row must be included to identify spikes traveling directly from the presynaptic core, and also those sent from each individual delay stage of the <italic>delay extension</italic>. This increased <italic>master population table</italic> size can be costly to search, and detrimental for realtime performance (see section 4.2).</p>
      </sec>
    </sec>
  </sec>
  <sec id="s4">
    <title>4. Results</title>
    <p>This section demonstrates results from simulations executed through the sPyNNaker API. The random balanced network used as a demonstration vehicle throughout this work is presented first, demonstrating realtime operation of small scale networks. The section then concludes with results from profiling operations detailed in section 3.2, in order to characterize system performance.</p>
    <sec>
      <title>4.1. Simulation of a random balanced network</title>
      <p>The network shown in Figure <xref ref-type="fig" rid="F3">3</xref> and described in Code <xref ref-type="supplementary-material" rid="SM1">S1</xref> (Supplementary Material) is executed on a SpiNNaker machine, utilizing 5 cores. Execution is realtime, with 5 s of simulation performed over 5 s of wall-clock time, and all spikes delivered and processed successfully. Output spike trains are accessed via the PyNN interface, and plotted in Figure <xref ref-type="fig" rid="F10">10</xref> (excitatory neuron spikes in blue, inhibitory in red). Network oscillations of ≈15Hz are observed throughout, with additional stimulation from the prescribed spike source input at <italic>t</italic> = 1s.</p>
      <fig id="F10" position="float">
        <label>Figure 10</label>
        <caption>
          <p>Output spike trains from realtime execution of the random balanced network of Figure <xref ref-type="fig" rid="F3">3A</xref>, from the PyNN script of Code S1. Spikes from inhibitory neurons are shown in red, and excitatory neurons in blue. The excitatory population receives an additional stimulus at <italic>t</italic> = 1s.</p>
        </caption>
        <graphic xlink:href="fnins-12-00816-g0010"/>
      </fig>
    </sec>
    <sec>
      <title>4.2. Performance profiling</title>
      <p>Realtime performance of a sPyNNaker application is principally governed by: the number of neurons simulated on a core; the complexity of the underlying neuron and synapse models; the peak incoming spike rate to a core during simulation; and the number of neurons each spike targets. To understand how these factors interact, a comprehensive profiling analysis is performed in section <xref ref-type="supplementary-material" rid="SM1">S1</xref> (Supplementary Material). This led to development of the cost model in Equation (8), predicting the total number of synaptic events a core can process between <italic>timer</italic> events while maintaining realtime execution. This model assumes a continuously-active pipeline (which is shown to be valid by the results in Figure <xref ref-type="fig" rid="F11">11</xref>), and that all spikes targetting the core will project to the same number of neurons. Subscript <italic>n</italic> refers to neuron processing contributions; while <italic>s</italic> refers to spike contributions, with <italic>f</italic>, <italic>s</italic>, and <italic>l</italic> referring respectively to the first, subsequent and last spikes in an active pipeline.</p>
      <disp-formula id="E10">
        <label>(8)</label>
        <mml:math id="M11">
          <mml:mtable class="eqnarray" columnalign="left">
            <mml:mtr>
              <mml:mtd>
                <mml:msub>
                  <mml:mrow>
                    <mml:mi>E</mml:mi>
                  </mml:mrow>
                  <mml:mrow>
                    <mml:mi>s</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mi>n</mml:mi>
                <mml:mi>P</mml:mi>
                <mml:mrow>
                  <mml:mo stretchy="true">(</mml:mo>
                  <mml:mrow>
                    <mml:mfrac>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>t</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>p</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>-</mml:mo>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>m</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>n</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mi>n</mml:mi>
                            <mml:mo>+</mml:mo>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>c</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>n</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:mrow>
                          <mml:mo stretchy="true">(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>m</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>f</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mi>n</mml:mi>
                            <mml:mi>P</mml:mi>
                            <mml:mo>+</mml:mo>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>c</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>f</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                        <mml:mo>-</mml:mo>
                        <mml:mrow>
                          <mml:mo stretchy="false">(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>m</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>l</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mi>n</mml:mi>
                            <mml:mi>P</mml:mi>
                            <mml:mo>+</mml:mo>
                            <mml:msub>
                              <mml:mrow>
                                <mml:mi>c</mml:mi>
                              </mml:mrow>
                              <mml:mrow>
                                <mml:mi>s</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>l</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo stretchy="false">)</mml:mo>
                        </mml:mrow>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>m</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>s</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>s</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mi>n</mml:mi>
                        <mml:mi>P</mml:mi>
                        <mml:mo>+</mml:mo>
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>c</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mi>s</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>s</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mrow>
                    </mml:mfrac>
                    <mml:mo>+</mml:mo>
                    <mml:mn>2</mml:mn>
                  </mml:mrow>
                  <mml:mo stretchy="true">)</mml:mo>
                </mml:mrow>
              </mml:mtd>
            </mml:mtr>
          </mml:mtable>
        </mml:math>
      </disp-formula>
      <p>The time taken to update the state of neurons (<italic>m</italic><sub><italic>n</italic></sub><italic>n</italic>+<italic>c</italic><sub><italic>n</italic></sub>) is subtracted from the period between <italic>timer events</italic> (<italic>t</italic><sub><italic>p</italic></sub>) to give the time available for processing spikes. The costs of processing the first and last spikes in the pipeline are then subtracted from this time (compensated for by the 2), and the remainder is divided by the cost of processing an intermediate spike (<italic>m</italic><sub><italic>s, s</italic></sub><italic>nP</italic>+<italic>c</italic><sub><italic>s, s</italic></sub>), to give the total number of spikes which can be processed. This total number of spikes is then multiplied by the number of neurons <italic>n</italic> and connection probability <italic>P</italic>, to give the total synaptic events <italic>E</italic><sub><italic>s</italic></sub> (as discussed in section 2.1).</p>
      <fig id="F11" position="float">
        <label>Figure 11</label>
        <caption>
          <p>Total number of synaptic events which can be processed between <italic>timer</italic> events: solid lines represent cost model predictions, while markers show measurements taken from sPyNNaker simulations. <bold>(A)</bold> Variation of total synaptic events with connection probability for a range of simulated neurons per core. <bold>(B)</bold> Variation of total synaptic events with neurons per core for a range of connection probabilities.</p>
        </caption>
        <graphic xlink:href="fnins-12-00816-g0011"/>
      </fig>
      <p>Model coefficients for current-based LIF and Izhikevich neurons are developed in section S1, and given in Table <xref rid="T2" ref-type="table">2</xref>. The difference of <italic>m</italic><sub><italic>n</italic></sub> for the two neurons models highlights the additional operations introduced by Equation (5), relative to Equation (1). However, this demonstrates that with careful consideration, SpiNNaker is able to update neurons with dynamics beyond those of a LIF neuron, despite the constraint of fixed-point arithmetic, and with only limited software libraries and processor speed.</p>
      <table-wrap id="T2" position="float">
        <label>Table 2</label>
        <caption>
          <p>Cost model parameters for LIF and Izhikevich neuron models and static synapse processing.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Paramter</bold>
              </th>
              <th valign="top" align="left" rowspan="1" colspan="1">
                <bold>Value</bold>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1"><italic>m</italic><sub><italic>n</italic></sub> (LIF)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">1.015μs / neuron</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1"><italic>c</italic><sub><italic>n</italic></sub> (LIF)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">3.235μs</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1"><italic>m</italic><sub><italic>n</italic></sub> (IZK)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">1.450μs / neuron</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1"><italic>c</italic><sub><italic>n</italic></sub> (IZK)</td>
              <td valign="top" align="left" rowspan="1" colspan="1">3.231μs</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>m</italic>
                <sub>
                  <italic>s, f</italic>
                </sub>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">0.126μs / synaptic word</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>c</italic>
                <sub>
                  <italic>s, f</italic>
                </sub>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">6.567μs</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>m</italic>
                <sub>
                  <italic>s, s</italic>
                </sub>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">0.115μs / synaptic word</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>c</italic>
                <sub>
                  <italic>s, s</italic>
                </sub>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">3.96μs</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>m</italic>
                <sub>
                  <italic>s, l</italic>
                </sub>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">0.115μs / synaptic word</td>
            </tr>
            <tr>
              <td valign="top" align="left" rowspan="1" colspan="1">
                <italic>m</italic>
                <sub>
                  <italic>s, l</italic>
                </sub>
              </td>
              <td valign="top" align="left" rowspan="1" colspan="1">2.48μs</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>Using the parameters of Table <xref rid="T2" ref-type="table">2</xref>, it is possible to estimate the interaction of neuron and spike processing for a range of SNN conditions. Constructing an SNN with single source neuron population, targetting a neuron population of variable size (16–512), with a connecting projection of variable probability (0.05–1.0), it is possible to evaluate the total number of synaptic events which can be processed while maintaining realtime execution. Predictions are generated for LIF neurons, assuming a single activation of the spike processing pipeline, and that all spikes target the same number of neurons. Model predictions are verified against sPyNNaker simulations containing SNNs replicating the network and assumptions above. Simulations are executed where the spike source emits increasing numbers of spikes to the postsynaptic neuron population within each timestep, in order to find the limiting case beyond which realtime execution can no longer be honored. Test data is plotted as circular markers in Figure <xref ref-type="fig" rid="F11">11</xref>, together with model predictions shown by continuous lines. Figure <xref ref-type="fig" rid="F11">11A</xref> shows the total number of synaptic events against connection probability for a range of numbers of neurons simulated on a single core. For all cases, increasing connection probability increases the total synaptic events, as each spike will now target greater numbers of neurons. As the number of neurons on a core increases, this behavior is reinforced up to maximum of 5,922 synaptic events when each spike targets 128 neurons with a connection probability of 1. However Figure <xref ref-type="fig" rid="F11">11B</xref>, which displays the same data plotted against numbers of neuron per core for a range of connection probabilities, shows this is a limiting case. Increasing beyond 128 neurons per core for full connectivity shows a reduction in the total synaptic events, as the additional time required to process neuron state updates leaves less time available to process incoming spikes. At lower connectivity, this performance peak occurs at higher numbers of neurons: e.g., at 20% connectivity the maximum number of synaptic events is achieved for ≈255 neurons per core. Also included in Figure <xref ref-type="fig" rid="F11">11</xref> are performance predictions for a core simulating 512 neurons. Although sPyNNaker does not currently support simulating this many neurons on a single core, it is useful to use Equation (8) to predict the effect of further increasing the number of neurons. It is seen that for the model coefficients in Table <xref rid="T2" ref-type="table">2</xref>, performance is comparable to simulating 255 neurons per core at low connection probabilities, however total synaptic events plateaus around 30% connectivity (Figure <xref ref-type="fig" rid="F11">11A</xref>), processing only 68% of the synaptic events achievable when running 255 neurons per core with a fully-connected network.</p>
      <p>Inspection of Equation (8) shows several coefficients govern overall performance. For example, in all cases the variable component of updating a single neuron dominates the associated fixed processing cost, meaning <italic>m</italic><sub><italic>n</italic></sub> plays the governing role in determining the remaining time available for processing incoming spikes. In terms of how many spikes can be processed, it is the subsequent spikes within an active pipeline which dominate throughput (as the first and last spikes are assumed to occur only once). At high connection probabilities and neurons per core <italic>m</italic><sub><italic>s, s</italic></sub><italic>nP</italic>&gt;<italic>c</italic><sub><italic>s, s</italic></sub>, meaning the variable per-target-neuron cost (<italic>m</italic><sub><italic>s, s</italic></sub>) dominates the total number of spikes which can be processed. Conversely, when connection probabilities and neurons per core are low, the fixed cost of processing a spike within the pipeline (<italic>c</italic><sub><italic>s, s</italic></sub>) dominates.</p>
      <p>The components of these coefficients have been profiled in detail for a range of neuron models and network topologies in section <xref ref-type="supplementary-material" rid="SM1">S1</xref> (Supplementary Material). The coefficient <italic>m</italic><sub><italic>n</italic></sub> is a function of neuron model and output spike rates, while <italic>m</italic><sub><italic>s, s</italic></sub> is dependent on processing a synaptic row into synaptic input buffer contributions. The coefficient <italic>c</italic><sub><italic>s, s</italic></sub> is predominantly dependent on the spike processing pipeline, with major contributions coming from: locating the memory address of synaptic information associated with an incoming spike; initializing a DMA of this data; and responding to interrupts and context switching within the pipeline. From Equation (8) it is seen that reducing <italic>m</italic><sub><italic>n</italic></sub> has the effect of enabling higher numbers of neurons per core, unlocking additional performance from low connectivities through targetting more neurons for the same probability of connection. Reducing <italic>m</italic><sub><italic>s, s</italic></sub> has the effect of increasing the number of spikes which can be processed, shifting the peak in maximum synaptic events of Figure <xref ref-type="fig" rid="F11">11B</xref> to higher values of neurons per core for the same probability of connection. Reducing <italic>c</italic><sub><italic>s, s</italic></sub> improves performance across all connection probabilities, but shifts the peak of maximum synaptic events in Figure <xref ref-type="fig" rid="F11">11B</xref> to lower numbers of neurons per core—i.e., improving performance for sparsely-connected networks. The model of Equation (8) therefore provides a useful tool for focusing development effort in order to optimize sPyNNaker for different SNN topologies.</p>
      <p>In addition to core processing, memory allocation is also an important consideration for a SpiNNaker application. To demonstrate typical memory consumption, the use of DTCM by the application simulating the Excitatory A population in Figure <xref ref-type="fig" rid="F3">3B</xref> is shown in Figure <xref ref-type="fig" rid="F12">12</xref> [explanations of memory use are detailed in section <xref ref-type="supplementary-material" rid="SM1">S1.4</xref> (Supplementary Material)]. When simulating 255 neurons per core, the synaptic input buffers require 16.32kB (section 3.2.2), while the current-based LIF neuron and synapse model parameters require 14.28kB. The data structures for locating synaptic information associated with an incoming spike (section 3.2.4), require 0.084kB to define entries covering 5 source vertices, one with two <italic>address list</italic> rows. Additional space is required for the DMA and input spike buffers, and for recording of output state variables. The remaining space is occupied by the operating system libraries SARK and SpiN1API (≈6kB), stack (2kB), with the rest allocated as heap.</p>
      <fig id="F12" position="float">
        <label>Figure 12</label>
        <caption>
          <p>DTCM footprint for neuron application simulating the Excitatory A population in Figure <xref ref-type="fig" rid="F3">3B</xref>.</p>
        </caption>
        <graphic xlink:href="fnins-12-00816-g0012"/>
      </fig>
      <p>The large heap appears wasteful for this example network, however when an SNN contains more populations and projections, a vertex is likely to receive spikes from many different locations, and hence the <italic>master population table</italic> length and number of <italic>address list</italic> rows will increase significantly requiring additional memory. It is also worth noting that additional memory can be allocated to improve runtime performance. For example, synaptic matrices associated with high frequency sources can be stored in DTCM, negating their transfer from SDRAM on spike arrival.</p>
    </sec>
  </sec>
  <sec id="s5">
    <title>5. Discussion</title>
    <p>This work presents the latest version of sPyNNaker: a software package for running PyNN SNN simulations on the SpiNNaker neuromorphic platform. It provides a detailed overview of software executed on the SpiNNaker machine, and shows how this interacts with the underlying hardware to achieve realtime execution. An event-driven operating system is described, together with details of the individual callbacks facilitating realtime neural simulation. Neuron updates are time driven, while spike processing is event driven, and handled by a series of pipelined callbacks to optimize performance. Implementation of standard neuron models from the literature is then discussed, both from the perspective of software engineering, and the performance impact of different numerical modeling techniques. Results are then presented for an example network used as a vehicle for explanation throughout the methods section, demonstrating realtime execution of a balanced oscillating SNN. Finally, performance analysis of key operations is presented, demonstrating how neuron and spike processing interact at runtime to govern the limits of realtime simulation.</p>
    <p>This software aims to address the original design goal of the SpiNNaker hardware: to simulate large-scale SNNs in realtime. Neurons were intended to be simulated 1,000 per core, and to have 1,000 incoming connections, switching at 10Hz: giving a potential 10,000 synaptic events per neuron per second (10 per neuron per ms, and 10,000 per core per ms). Neuron updates were to be time driven with a default simulation step size of Δ<italic>t</italic> = 1ms, giving 200,000 clock cycles between neuron updates to achieve realtime execution. A number of features have deviated from the original design, including: the use of C code and an event-based operating system to program cores, where it was originally intended to use assembly code and interrupt service routines to define neuron behavior; and the reduction of the default number of neurons simulated by a core to 255. To quantify the impact of these design changes, performance of the presented software is assessed in terms of the maximum number of synaptic events which can be processed while maintaining realtime simulation. Performance is dependent on SNN topology and how the simulation is partitioned onto machine resources (see Figure <xref ref-type="fig" rid="F11">11</xref>), however over 5,000 synaptic events were handled by cores simulating postsynaptic populations of 255 neurons in fully-connected SNNs—demonstrating performance within a factor of two of the original design target.</p>
    <p>However, SNN topology plays an important role in the total number of synaptic events which can be processed within a timestep, as spikes which target greater numbers of postsynaptic neurons enable the fixed costs associated with spike processing to be amortized over more synaptic events. To this end, increasing the number of neurons simulated by a core improves the total number of synaptic events which can be processed, however this effect peaks around 255 neurons per core for the majority of connection probabilities, as the increased time the core must spend updating neurons leaves less for spike processing. This variation in performance with the number of neurons simulated on a core is counter intuitive, as one would expect reducing the number to help parallelize computation and reduce the load on a single core. However it is seen for all cases except a fully-connected network, that the total number of synaptic events which can be processed reduces with neurons per core for connection probabilities of &lt;50% (see Figure <xref ref-type="fig" rid="F11">11B</xref>). The reduced default of 255 neurons per core is therefore a sensible design choice, as it is close to maximizing the peak number of synaptic events which can be processed for all connection probabilities.</p>
    <p>To characterize system performance a detailed profiling analysis was performed (see section <xref ref-type="supplementary-material" rid="SM1">S1</xref> in Supplementary Material), resulting in the cost model in Equation (8). This model revealed three SNN-independent parameters governing performance: <italic>m</italic><sub><italic>n</italic></sub> the time taken to update a single neuron; <italic>m</italic><sub><italic>s, s</italic></sub> the time taken to evaluate the synaptic contribution of a single spike to a single postsynaptic neuron; and <italic>c</italic><sub><italic>s, s</italic></sub> the fixed cost associated with an incoming spike in the active spike processing pipeline. To reduce <italic>m</italic><sub><italic>n</italic></sub> would require more efficient handling of the neuron state update, but also the infrastructure code managing the circular synaptic input buffers, and the shaping of synaptic currents. The value of <italic>m</italic><sub><italic>s, s</italic></sub> is already close to the original design target of 20 instructions per spike event, and at 23clock cycles is near the optimum which can be produced by standard compilers. However, given the repeated operations performed while processing the synaptic row, there is potential to use hand-crafted assembly code to interleave operations and reduce total row processing times. There is greater scope for minimizing the fixed cost of processing a spike in the pipeline <italic>c</italic><sub><italic>s, s</italic></sub>. For example, while the <italic>master population table</italic> search is relatively efficient, the surrounding infrastructure software could be improved significantly. There is also potential to remove the use of interrupts and events to cycle between the functionality accessed through repeated calls to <monospace>_dma_complete_callback</monospace>, and hence avoid the cost of context switching. This means a reduction of 50% is viable for <italic>c</italic><sub><italic>s, s</italic></sub>, and if this could also be achieved for <italic>m</italic><sub><italic>n</italic></sub> and <italic>m</italic><sub><italic>s, s</italic></sub>, then Equation (8) predicts the original design target of 10,000 synaptic events per ms would be achievable. Simulating 255 neurons per core, these reductions would enable ≈12,700 synaptic events for a fully-connected projection, ≈10, 250 at 30% connectivity, and ≈4, 050 at 5% connectivity.</p>
    <p>This work presents a comprehensive overview of the sPyNNaker software package and assesses its performance. It is noted that alternative prototype software models have also been investigated by the SpiNNaker group: such as distributing computation for a group of neurons across multiple cores, each with bespoke roles (Galluppi et al., <xref rid="B17" ref-type="bibr">2015</xref>; Knight and Furber, <xref rid="B25" ref-type="bibr">2016</xref>). This research, together with this work, demonstrates the continued potential of the SpiNNaker chip, and provides important information to inform the design of the next-generation SpiNNaker 2 system.</p>
  </sec>
  <sec id="s6">
    <title>Author contributions</title>
    <p>This work presents the latest version of the sPyNNaker software package produced by the SpiNNaker group at the University of Manchester, UK. The current SpiNNaker software team is comprised of CB, DF, AG, OR, and AS, and led by AR, all of whom have made significant contributions to sPyNNaker. SD, DL, and LP are researchers within the SpiNNaker group, and worked on earlier versions of SpiNNaker software, and provided assistance with low-level programming and hardware interactions during performance analysis. MM assisted with performance profiling, and PB with tuning and development of the example random balanced network used throughout. OR led the research and wrote the manuscript, while SF leads the SpiNNaker project and supervised this work. All authors reviewed and refined the final manuscript.</p>
    <sec>
      <title>Conflict of interest statement</title>
      <p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <p>The software stack has been built on previous contributions from multiple parties, all of which are gratefully acknowledged. Specific individual contributions must be recognized from: Sergio Davies, Francesco Galluppi, Michael Hopkins, Jamie Knight, Andrew Mundy, Thomas Sharp, and Steve Temple.</p>
  </ack>
  <fn-group>
    <fn id="fn0001">
      <p>
        <sup>1</sup>
        <ext-link ext-link-type="uri" xlink:href="https://github.com/SpiNNakerManchester/sPyNNaker">https://github.com/SpiNNakerManchester/sPyNNaker</ext-link>
      </p>
    </fn>
    <fn id="fn0002">
      <p>
        <sup>2</sup>
        <ext-link ext-link-type="uri" xlink:href="https://www.iso.org/obp/ui/#iso:std:iso-iec:tr:18037:ed-2:v1:en">https://www.iso.org/obp/ui/#iso:std:iso-iec:tr:18037:ed-2:v1:en</ext-link>
      </p>
    </fn>
    <fn id="fn0003">
      <p><sup>3</sup>A detailed guide to this process can be found at: <ext-link ext-link-type="uri" xlink:href="http://spinnakermanchester.github.io/workshops/seventh.html">http://spinnakermanchester.github.io/workshops/seventh.html</ext-link></p>
    </fn>
  </fn-group>
  <fn-group>
    <fn fn-type="financial-disclosure">
      <p><bold>Funding.</bold> The design and construction of the SpiNNaker machine was supported by the EPSRC (UK Engineering and Physical Sciences Research Council) under grants EP/D07908X/1 and EP/G015740/1, in collaboration with the universities of Southampton, Cambridge and Sheffield and with industry partners ARM Ltd., Silistix Ltd. and Thales. Ongoing development of the software is supported by the EU ICT Flagship Human Brain Project (H2020 785907), in collaboration with many university and industry partners across the EU and beyond, and our own exploration of the capabilities of the machine is supported by the European Research Council under the European Union Seventh Framework Programme (FP7/20072013)/ERC grant agreement 320689.</p>
    </fn>
  </fn-group>
  <sec sec-type="supplementary-material" id="s9">
    <title>Supplementary material</title>
    <p>The Supplementary Material for this article can be found online at: <ext-link ext-link-type="uri" xlink:href="https://www.frontiersin.org/articles/10.3389/fnins.2018.00816/full#supplementary-material">https://www.frontiersin.org/articles/10.3389/fnins.2018.00816/full#supplementary-material</ext-link></p>
    <supplementary-material content-type="local-data" id="SM1">
      <media xlink:href="Data_Sheet_1.PDF">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Akopyan</surname><given-names>F.</given-names></name><name><surname>Sawada</surname><given-names>J.</given-names></name><name><surname>Cassidy</surname><given-names>A.</given-names></name><name><surname>Alvarez-Icaza</surname><given-names>R.</given-names></name><name><surname>Arthur</surname><given-names>J.</given-names></name><name><surname>Merolla</surname><given-names>P.</given-names></name><etal/></person-group> (<year>2015</year>). <article-title>TrueNorth: design and tool flow of a 65 mW 1 million neuron programmable neurosynaptic chip</article-title>. <source>IEEE Trans. Comput. Aided Design Integr. Circ. Syst.</source>
<volume>34</volume>, <fpage>1537</fpage>–<lpage>1557</lpage>. <pub-id pub-id-type="doi">10.1109/TCAD.2015.2474396</pub-id></mixed-citation>
    </ref>
    <ref id="B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Amunts</surname><given-names>K.</given-names></name><name><surname>Ebell</surname><given-names>C.</given-names></name><name><surname>Muller</surname><given-names>J.</given-names></name><name><surname>Telefont</surname><given-names>M.</given-names></name><name><surname>Knoll</surname><given-names>A.</given-names></name><name><surname>Lippert</surname><given-names>T.</given-names></name></person-group> (<year>2016</year>). <article-title>The human brain project: creating a European research infrastructure to decode the human brain</article-title>. <source>Neuron</source>
<volume>92</volume>, <fpage>574</fpage>–<lpage>581</lpage>. <pub-id pub-id-type="doi">10.1016/j.neuron.2016.10.046</pub-id><?supplied-pmid 27809997?><pub-id pub-id-type="pmid">27809997</pub-id></mixed-citation>
    </ref>
    <ref id="B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><collab>ARM</collab></person-group> (<year>2004</year>). <source>ARM968E-S Tech Reference Manual</source>.</mixed-citation>
    </ref>
    <ref id="B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Benjamin</surname><given-names>B. V.</given-names></name><name><surname>Gao</surname><given-names>P.</given-names></name><name><surname>McQuinn</surname><given-names>E.</given-names></name><name><surname>Choudhary</surname><given-names>S.</given-names></name><name><surname>Chandrasekaran</surname><given-names>A. R.</given-names></name><name><surname>Bussat</surname><given-names>J. M.</given-names></name><etal/></person-group> (<year>2014</year>). <article-title>Neurogrid: a mixed-analog-digital multichip system for large-scale neural simulations</article-title>. <source>Proc. IEEE</source>
<volume>102</volume>, <fpage>699</fpage>–<lpage>716</lpage>. <pub-id pub-id-type="doi">10.1109/JPROC.2014.2313565</pub-id></mixed-citation>
    </ref>
    <ref id="B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Brown</surname><given-names>A. D.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name><name><surname>Reeve</surname><given-names>J. S.</given-names></name><name><surname>Garside</surname><given-names>J. D.</given-names></name><name><surname>Dugan</surname><given-names>K. J.</given-names></name><name><surname>Plana</surname><given-names>L. A.</given-names></name><etal/></person-group> (<year>2015</year>). <article-title>SpiNNaker - Programming model</article-title>. <source>IEEE Trans. Comput.</source>
<volume>64</volume>, <fpage>1769</fpage>–<lpage>1782</lpage>. <pub-id pub-id-type="doi">10.1109/TC.2014.2329686</pub-id></mixed-citation>
    </ref>
    <ref id="B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Carnevale</surname><given-names>N. T.</given-names></name><name><surname>Hines</surname><given-names>M. L.</given-names></name></person-group> (<year>2006</year>). <source>The NEURON Book</source>. <publisher-loc>Cambridge</publisher-loc>: <publisher-name>Cambridge University Press</publisher-name>
<pub-id pub-id-type="doi">10.1017/CBO9780511541612</pub-id></mixed-citation>
    </ref>
    <ref id="B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Christoph</surname><given-names>R.</given-names></name><name><surname>Jentzsch</surname><given-names>S.</given-names></name><name><surname>Hostettler</surname><given-names>R.</given-names></name></person-group> (<year>2016</year>). <article-title>Musculoskeletal robots: scalability in neural control</article-title> in <source>IEEE Robotics &amp; Automation Magazine</source>, Vol. <volume>23</volume>, <fpage>128</fpage>–<lpage>137</lpage>. <pub-id pub-id-type="doi">10.1109/MRA.2016.2535081</pub-id></mixed-citation>
    </ref>
    <ref id="B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Davies</surname><given-names>M.</given-names></name><name><surname>Srinivasa</surname><given-names>N.</given-names></name><name><surname>Lin</surname><given-names>T. H.</given-names></name><name><surname>Chinya</surname><given-names>G.</given-names></name><name><surname>Joshi</surname><given-names>P.</given-names></name><name><surname>Lines</surname><given-names>A.</given-names></name><etal/></person-group> (<year>2018</year>). <article-title>Loihi: a neuromorphic manycore processor with on-chip learning</article-title>. <source>IEEE Micro</source>. <volume>38</volume>, <fpage>82</fpage>–<lpage>99</lpage>. <pub-id pub-id-type="doi">10.1109/MM.2018.112130359</pub-id></mixed-citation>
    </ref>
    <ref id="B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Davies</surname><given-names>S.</given-names></name><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Rast</surname><given-names>A. D.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name></person-group> (<year>2012</year>). <article-title>A forecast-based STDP rule suitable for neuromorphic implementation</article-title>. <source>Neural Netw.</source>
<volume>32</volume>, <fpage>3</fpage>–<lpage>14</lpage>. <pub-id pub-id-type="doi">10.1016/j.neunet.2012.02.018</pub-id><?supplied-pmid 22386500?><pub-id pub-id-type="pmid">22386500</pub-id></mixed-citation>
    </ref>
    <ref id="B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Davison</surname><given-names>A. P.</given-names></name><name><surname>Brüderle</surname><given-names>D.</given-names></name><name><surname>Eppler</surname><given-names>J.</given-names></name><name><surname>Kremkow</surname><given-names>J.</given-names></name><name><surname>Muller</surname><given-names>E.</given-names></name><name><surname>Pecevski</surname><given-names>D.</given-names></name><etal/></person-group>. (<year>2008</year>). <article-title>PyNN: a common interface for neuronal network simulators</article-title>. <source>Front. Neuroinform.</source><volume>2</volume>:<fpage>11</fpage>. <pub-id pub-id-type="doi">10.3389/neuro.11.011.2008</pub-id><?supplied-pmid 19194529?><pub-id pub-id-type="pmid">19194529</pub-id></mixed-citation>
    </ref>
    <ref id="B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Dayan</surname><given-names>P.</given-names></name><name><surname>Abbott</surname><given-names>L. F.</given-names></name></person-group> (<year>2005</year>). <source>Theoretical Neuroscience: Computational and Mathematical Modeling of Neural Systems (Computational Neuroscience)</source>. <publisher-name>The MIT Press</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Destexhe</surname><given-names>A.</given-names></name><name><surname>Maimen</surname><given-names>F.</given-names></name><name><surname>Sejnowski</surname><given-names>T. J.</given-names></name></person-group> (<year>2014</year>). <article-title>Kinetic models of synaptic transmission</article-title> in <source>Methods in Neuronal Modeling , 2nd Edn.</source>, eds C. Koch and I. Segev (<publisher-loc>Cambridge, MA</publisher-loc>: <publisher-name>MIT Press</publisher-name>), <fpage>1</fpage>–<lpage>25</lpage>.</mixed-citation>
    </ref>
    <ref id="B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Fonseca Guerra</surname><given-names>G. A.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name></person-group> (<year>2017</year>). <article-title>Using stochastic spiking neural networks on SpiNNaker to solve constraint satisfaction problems</article-title>. <source>Front. Neurosci.</source>
<volume>11</volume>:<fpage>714</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2017.00714</pub-id><?supplied-pmid 29311791?><pub-id pub-id-type="pmid">29311791</pub-id></mixed-citation>
    </ref>
    <ref id="B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Furber</surname><given-names>S.</given-names></name></person-group> (<year>2016</year>). <article-title>Large-scale neuromorphic computing systems</article-title>. <source>J. Neural Eng.</source>
<volume>13</volume>:<fpage>51001</fpage>. <pub-id pub-id-type="doi">10.1088/1741-2560/13/5/051001</pub-id><?supplied-pmid 27529195?><pub-id pub-id-type="pmid">27529195</pub-id></mixed-citation>
    </ref>
    <ref id="B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Furber</surname><given-names>S. B.</given-names></name><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Temple</surname><given-names>S.</given-names></name><name><surname>Plana</surname><given-names>L. A.</given-names></name></person-group> (<year>2014</year>). <article-title>The SpiNNaker project</article-title> in <source>Proceedings of the IEEE</source>, Vol. <volume>102</volume>, <fpage>652</fpage>–<lpage>665</lpage>. <pub-id pub-id-type="doi">10.1109/JPROC.2014.2304638</pub-id></mixed-citation>
    </ref>
    <ref id="B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Furber</surname><given-names>S. B.</given-names></name><name><surname>Lester</surname><given-names>D. R.</given-names></name><name><surname>Plana</surname><given-names>L. A.</given-names></name><name><surname>Garside</surname><given-names>J. D.</given-names></name><name><surname>Painkras</surname><given-names>E.</given-names></name><name><surname>Temple</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2013</year>). <article-title>Overview of the SpiNNaker system architecture</article-title>. <source>IEEE Trans. Comput.</source>
<volume>62</volume>, <fpage>2454</fpage>–<lpage>2467</lpage>. <pub-id pub-id-type="doi">10.1109/TC.2012.142</pub-id></mixed-citation>
    </ref>
    <ref id="B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Lagorce</surname><given-names>X.</given-names></name><name><surname>Stromatias</surname><given-names>E.</given-names></name><name><surname>Pfeiffer</surname><given-names>M.</given-names></name><name><surname>Plana</surname><given-names>L. A.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name><etal/></person-group>. (<year>2015</year>). <article-title>A framework for plasticity implementation on the SpiNNaker neural architecture</article-title>. <source>Front. Neurosci.</source><volume>8</volume>:<fpage>429</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2014.00429</pub-id><?supplied-pmid 25653580?><pub-id pub-id-type="pmid">25653580</pub-id></mixed-citation>
    </ref>
    <ref id="B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Gewaltig</surname><given-names>M.-O.</given-names></name><name><surname>Diesmann</surname><given-names>M.</given-names></name></person-group> (<year>2007</year>). <article-title>NEST (NEural Simulation Tool)</article-title>. <source>Scholarpedia</source>
<volume>2</volume>:<fpage>1430</fpage>
<pub-id pub-id-type="doi">10.4249/scholarpedia.1430</pub-id></mixed-citation>
    </ref>
    <ref id="B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Goodman</surname><given-names>D. F.</given-names></name><name><surname>Brette</surname><given-names>R.</given-names></name></person-group> (<year>2009</year>). <article-title>The brian simulator</article-title>. <source>Front. Neurosci.</source>
<volume>3</volume>:<fpage>192</fpage>–<lpage>197</lpage>. <pub-id pub-id-type="doi">10.3389/neuro.01.026.2009</pub-id><?supplied-pmid 20011141?><pub-id pub-id-type="pmid">20011141</pub-id></mixed-citation>
    </ref>
    <ref id="B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hopkins</surname><given-names>M.</given-names></name><name><surname>Furber</surname><given-names>S.</given-names></name></person-group> (<year>2015</year>). <article-title>Accuracy and efficiency in fixed-point neural ODE solvers</article-title>. <source>Neural Comput.</source>
<volume>27</volume>, <fpage>2148</fpage>–<lpage>2182</lpage>. <pub-id pub-id-type="doi">10.1162/NECO_a_00772</pub-id><?supplied-pmid 26313605?><pub-id pub-id-type="pmid">26313605</pub-id></mixed-citation>
    </ref>
    <ref id="B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Indiveri</surname><given-names>G.</given-names></name><name><surname>Horiuchi</surname><given-names>T. K.</given-names></name></person-group> (<year>2011</year>). <article-title>Frontiers in neuromorphic engineering</article-title>. <source>Front. Neurosci.</source>
<volume>5</volume>:<fpage>118</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2011.00118</pub-id><?supplied-pmid 22013408?><pub-id pub-id-type="pmid">22013408</pub-id></mixed-citation>
    </ref>
    <ref id="B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Izhikevich</surname><given-names>E. M.</given-names></name></person-group> (<year>2003</year>). <article-title>Simple model of spiking neurons</article-title>. <source>IEEE Trans. Neural Netw.</source>
<volume>14</volume>, <fpage>1569</fpage>–<lpage>1572</lpage>. <pub-id pub-id-type="doi">10.1109/TNN.2003.820440</pub-id><?supplied-pmid 18244602?><pub-id pub-id-type="pmid">18244602</pub-id></mixed-citation>
    </ref>
    <ref id="B23">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Jin</surname><given-names>X.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name><name><surname>Woods</surname><given-names>J. V.</given-names></name></person-group> (<year>2008</year>). <article-title>Efficient modelling of spiking neural networks on a scalable chip multiprocessor</article-title> in <source>2008 IEEE International Joint Conference on Neural Networks</source> (<publisher-loc>Hong Kong</publisher-loc>), <fpage>2813</fpage>–<lpage>2820</lpage>. <pub-id pub-id-type="doi">10.1109/IJCNN.2008.4634194</pub-id></mixed-citation>
    </ref>
    <ref id="B24">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Jin</surname><given-names>X.</given-names></name><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Patterson</surname><given-names>C.</given-names></name><name><surname>Rast</surname><given-names>A.</given-names></name><name><surname>Davies</surname><given-names>S.</given-names></name><name><surname>Temple</surname><given-names>S.</given-names></name><etal/></person-group> (<year>2010</year>). <article-title>Algorithm and software for simulation of spiking neural networks on the multi-chip SpiNNaker system</article-title> in <source>Proceedings of the International Joint Conference on Neural Networks</source> (<publisher-loc>Barcelona</publisher-loc>), <fpage>1</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Knight</surname><given-names>J. C.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name></person-group> (<year>2016</year>). <article-title>Synapse-centric mapping of cortical models to the SpiNNaker neuromorphic architecture</article-title>. <source>Front. Neurosci.</source>
<volume>10</volume>:<fpage>420</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2016.00420</pub-id><?supplied-pmid 27683540?><pub-id pub-id-type="pmid">27683540</pub-id></mixed-citation>
    </ref>
    <ref id="B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Knight</surname><given-names>J. C.</given-names></name><name><surname>Tully</surname><given-names>P. J.</given-names></name><name><surname>Kaplan</surname><given-names>B. A.</given-names></name><name><surname>Lansner</surname><given-names>A.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name></person-group> (<year>2016</year>). <article-title>Large-scale simulations of plastic neural networks on neuromorphic hardware</article-title>. <source>Front. Neuroanat.</source>
<volume>10</volume>:<fpage>37</fpage>. <pub-id pub-id-type="doi">10.3389/fnana.2016.00037</pub-id><?supplied-pmid 27092061?><pub-id pub-id-type="pmid">27092061</pub-id></mixed-citation>
    </ref>
    <ref id="B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lin</surname><given-names>C.-K.</given-names></name><name><surname>Wild</surname><given-names>A.</given-names></name><name><surname>Chinya</surname><given-names>G. N.</given-names></name><name><surname>Cao</surname><given-names>Y.</given-names></name><name><surname>Davies</surname><given-names>M.</given-names></name><name><surname>Lavery</surname><given-names>D. M.</given-names></name><etal/></person-group> (<year>2018</year>). <article-title>Programming spiking networks on intel's loihi</article-title>. <source>Computer</source>
<volume>51</volume>, <fpage>52</fpage>–<lpage>61</lpage>. <pub-id pub-id-type="doi">10.1109/MC.2018.157113521</pub-id></mixed-citation>
    </ref>
    <ref id="B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>Y. H.</given-names></name><name><surname>Wang</surname><given-names>X. J.</given-names></name></person-group> (<year>2001</year>). <article-title>Spike-frequency adaptation of a generalized leaky integrate-and-fire model neuron</article-title>. <source>J. Comput. Neurosci.</source>
<volume>10</volume>, <fpage>25</fpage>–<lpage>45</lpage>. <pub-id pub-id-type="doi">10.1023/A:1008916026143</pub-id><?supplied-pmid 11316338?><pub-id pub-id-type="pmid">11316338</pub-id></mixed-citation>
    </ref>
    <ref id="B29">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Mead</surname><given-names>C.</given-names></name></person-group> (<year>1989</year>). <source>Analog VLSI and Neural Systems</source>. <publisher-loc>Boston, MA</publisher-loc>: <publisher-name>Addison-Wesley Longman Publishing Co., Inc</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mikaitis</surname><given-names>M.</given-names></name><name><surname>Pineda García</surname><given-names>G.</given-names></name><name><surname>Knight</surname><given-names>J. C.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name></person-group> (<year>2018</year>). <article-title>Neuromodulated synaptic plasticity on the SpiNNaker neuromorphic system</article-title>. <source>Front. Neurosci.</source>
<volume>12</volume>:<fpage>105</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2018.00105</pub-id><?supplied-pmid 29535600?><pub-id pub-id-type="pmid">29535600</pub-id></mixed-citation>
    </ref>
    <ref id="B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Morrison</surname><given-names>A.</given-names></name><name><surname>Mehring</surname><given-names>C.</given-names></name><name><surname>Geisel</surname><given-names>T.</given-names></name><name><surname>Aertsen</surname><given-names>A.</given-names></name><name><surname>Diesmann</surname><given-names>M.</given-names></name></person-group> (<year>2005</year>). <article-title>Advancing the boundaries of high-connectivity network simulation with distributed computing</article-title>. <source>Neural Comput.</source>
<volume>17</volume>, <fpage>1776</fpage>–<lpage>1801</lpage>. <pub-id pub-id-type="doi">10.1162/0899766054026648</pub-id><?supplied-pmid 15969917?><pub-id pub-id-type="pmid">15969917</pub-id></mixed-citation>
    </ref>
    <ref id="B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Navaridas</surname><given-names>J.</given-names></name><name><surname>Luján</surname><given-names>M.</given-names></name><name><surname>Plana</surname><given-names>L. A.</given-names></name><name><surname>Temple</surname><given-names>S.</given-names></name><name><surname>Furber</surname><given-names>S. B.</given-names></name></person-group> (<year>2015</year>). <article-title>SpiNNaker: enhanced multicast routing</article-title>. <source>Parall. Comput.</source>
<volume>45</volume>, <fpage>49</fpage>–<lpage>66</lpage>. <pub-id pub-id-type="doi">10.1016/j.parco.2015.01.002</pub-id></mixed-citation>
    </ref>
    <ref id="B33">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Painkras</surname><given-names>E.</given-names></name><name><surname>Plana</surname><given-names>L. A.</given-names></name><name><surname>Garside</surname><given-names>J.</given-names></name><name><surname>Temple</surname><given-names>S.</given-names></name><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Patterson</surname><given-names>C.</given-names></name><etal/></person-group> (<year>2013</year>). <article-title>SpiNNaker: a 1-W 18-core system-on-chip for massively-parallel neural network simulation</article-title>. <source>IEEE J. Solid-State Circ.</source>
<volume>48</volume>, <fpage>1943</fpage>–<lpage>1953</lpage>. <pub-id pub-id-type="doi">10.1109/JSSC.2013.2259038</pub-id></mixed-citation>
    </ref>
    <ref id="B34">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Qiao</surname><given-names>N.</given-names></name><name><surname>Mostafa</surname><given-names>H.</given-names></name><name><surname>Corradi</surname><given-names>F.</given-names></name><name><surname>Osswald</surname><given-names>M.</given-names></name><name><surname>Stefanini</surname><given-names>F.</given-names></name><name><surname>Sumislawska</surname><given-names>D.</given-names></name><etal/></person-group>. (<year>2015</year>). <article-title>A reconfigurable on-line learning spiking neuromorphic processor comprising 256 neurons and 128K synapses</article-title>. <source>Front. Neurosci.</source><volume>9</volume>:<fpage>141</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2015.00141</pub-id><?supplied-pmid 25972778?><pub-id pub-id-type="pmid">25972778</pub-id></mixed-citation>
    </ref>
    <ref id="B35">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rotter</surname><given-names>S.</given-names></name><name><surname>Diesmann</surname><given-names>M.</given-names></name></person-group> (<year>1999</year>). <article-title>Exact digital simulation of time-invariant linear systems with applications to neuronal modeling</article-title>. <source>Biol. Cybern.</source>
<volume>81</volume>, <fpage>381</fpage>–<lpage>402</lpage>. <pub-id pub-id-type="doi">10.1007/s004220050570</pub-id><?supplied-pmid 10592015?><pub-id pub-id-type="pmid">10592015</pub-id></mixed-citation>
    </ref>
    <ref id="B36">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rowley</surname><given-names>A. G. D.</given-names></name><name><surname>Brenninkmeijer</surname><given-names>C. Y.</given-names></name><name><surname>Davidson</surname><given-names>S.</given-names></name><name><surname>Fellows</surname><given-names>D.</given-names></name><name><surname>Gait</surname><given-names>A.</given-names></name><name><surname>Lester</surname><given-names>D. R.</given-names></name><etal/></person-group> (<year>2018</year>). <article-title>SpiNNTools: the execution engine for the SpiNNaker platform</article-title>. <volume>arxiv:1810.06835</volume>, <fpage>1</fpage>–<lpage>13</lpage>.</mixed-citation>
    </ref>
    <ref id="B37">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Schemmel</surname><given-names>J.</given-names></name><name><surname>Brüderle</surname><given-names>D.</given-names></name><name><surname>Grübl</surname><given-names>A.</given-names></name><name><surname>Hock</surname><given-names>M.</given-names></name><name><surname>Meier</surname><given-names>K.</given-names></name><name><surname>Millner</surname><given-names>S.</given-names></name></person-group> (<year>2010</year>). <article-title>A wafer-scale neuromorphic hardware system for large-scale neural modeling</article-title> in <source>ISCAS 2010 - 2010 IEEE International Symposium on Circuits and Systems: Nano-Bio Circuit Fabrics and Systems</source> (<publisher-loc>Paris</publisher-loc>), <fpage>1947</fpage>–<lpage>1950</lpage>. <pub-id pub-id-type="doi">10.1109/ISCAS.2010.5536970</pub-id></mixed-citation>
    </ref>
    <ref id="B38">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sen-Bhattacharya</surname><given-names>B.</given-names></name><name><surname>James</surname><given-names>S.</given-names></name><name><surname>Rhodes</surname><given-names>O.</given-names></name><name><surname>Sugiarto</surname><given-names>I.</given-names></name><name><surname>Rowley</surname><given-names>A.</given-names></name><name><surname>Stokes</surname><given-names>A. B.</given-names></name><etal/></person-group> (<year>2018</year>). <article-title>Building a spiking neural network model of the basal ganglia on spiNNaker</article-title> in <source>IEEE Transactions on Cognitive and Developmental Systems</source>, <fpage>823</fpage>–<lpage>836</lpage>. <pub-id pub-id-type="doi">10.1109/TCDS.2018.2797426</pub-id></mixed-citation>
    </ref>
    <ref id="B39">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sen-Bhattacharya</surname><given-names>B.</given-names></name><name><surname>Serrano-Gotarredona</surname><given-names>T.</given-names></name><name><surname>Balassa</surname><given-names>L.</given-names></name><name><surname>Bhattacharya</surname><given-names>A.</given-names></name><name><surname>Stokes</surname><given-names>A. B.</given-names></name><name><surname>Rowley</surname><given-names>A.</given-names></name><etal/></person-group>. (<year>2017</year>). <article-title>A spiking neural network model of the Lateral Geniculate Nucleus on the SpiNNaker Machine</article-title>. <source>Front. Neurosci.</source><volume>11</volume>:<fpage>454</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2017.00454</pub-id><?supplied-pmid 28848380?><pub-id pub-id-type="pmid">28848380</pub-id></mixed-citation>
    </ref>
    <ref id="B40">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sharp</surname><given-names>T</given-names></name><name><surname>Plana</surname><given-names>L.A</given-names></name><name><surname>Galluppi</surname><given-names>F</given-names></name><name><surname>Furber</surname><given-names>S</given-names></name></person-group> (<year>2011</year>). <article-title>Event-driven simulation of arbitrary spiking neural networks on SpiNNaker</article-title> in <source>Neural Information Processing, ICONIP 2011. Lecture Notes in Computer Science</source>, <volume>Vol. 7064</volume>, eds <person-group person-group-type="editor"><name><surname>Lu</surname><given-names>B. L.</given-names></name><name><surname>Zhang</surname><given-names>L.</given-names></name><name><surname>Kwok</surname><given-names>J.</given-names></name></person-group> (<publisher-loc>Berlin; Heidelberg</publisher-loc>: <publisher-name>Springer</publisher-name>), <fpage>424</fpage>–<lpage>430</lpage>.</mixed-citation>
    </ref>
    <ref id="B41">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sharp</surname><given-names>T.</given-names></name><name><surname>Furber</surname><given-names>S.</given-names></name></person-group> (<year>2013</year>). <article-title>Correctness and performance of the SpiNNaker architecture</article-title> in <source>Proceedings of the International Joint Conference on Neural Networks (IJCNN)</source> (<publisher-loc>Dallas, TX</publisher-loc>), <fpage>1</fpage>–<lpage>8</lpage>. <pub-id pub-id-type="doi">10.1109/IJCNN.2013.6706988</pub-id></mixed-citation>
    </ref>
    <ref id="B42">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Sharp</surname><given-names>T.</given-names></name><name><surname>Galluppi</surname><given-names>F.</given-names></name><name><surname>Rast</surname><given-names>A.</given-names></name><name><surname>Furber</surname><given-names>S.</given-names></name></person-group> (<year>2012</year>). <article-title>Power-efficient simulation of detailed cortical microcircuits on SpiNNaker</article-title>. <source>J. Neurosci. Methods</source>
<volume>210</volume>, <fpage>110</fpage>–<lpage>118</lpage>. <pub-id pub-id-type="doi">10.1016/j.jneumeth.2012.03.001</pub-id><?supplied-pmid 22465805?><pub-id pub-id-type="pmid">22465805</pub-id></mixed-citation>
    </ref>
    <ref id="B43">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name><surname>Sloss</surname><given-names>A.</given-names></name><name><surname>Symes</surname><given-names>D.</given-names></name><name><surname>Wright</surname><given-names>C.</given-names></name></person-group> (<year>2004</year>). <source>ARM System Developer's Guide: Designing and Optimizing System Software</source>. <publisher-loc>San Francisco, CA</publisher-loc>: <publisher-name>Morgan Kaufmann Publishers Inc</publisher-name>.</mixed-citation>
    </ref>
    <ref id="B44">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><collab>SpiNNaker</collab></person-group> (<year>2011a</year>). <source>SpiNNaker Application Programming Interface</source>. Technical report.</mixed-citation>
    </ref>
    <ref id="B45">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><collab>SpiNNaker</collab></person-group> (<year>2011b</year>). <source>SpiNNaker Datasheet Version 2.02</source>. Technical report.</mixed-citation>
    </ref>
    <ref id="B46">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Temple</surname><given-names>S.</given-names></name></person-group> (<year>2016</year>). <source>SARK - SpiNNaker Application Runtime Kernel</source>. Technical report.</mixed-citation>
    </ref>
    <ref id="B47">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name><surname>van Albada</surname><given-names>S. J.</given-names></name><name><surname>Rowley</surname><given-names>A. G.</given-names></name><name><surname>Senk</surname><given-names>J.</given-names></name><name><surname>Hopkins</surname><given-names>M.</given-names></name><name><surname>Schmidt</surname><given-names>M.</given-names></name><name><surname>Stokes</surname><given-names>A. B.</given-names></name><etal/></person-group>. (<year>2018</year>). <article-title>Performance comparison of the digital neuromorphic hardware SpiNNaker and the neural network simulation software NEST for a full-scale cortical microcircuit model</article-title>. <source>Front. Neurosci.</source><volume>12</volume>:<fpage>291</fpage>. <pub-id pub-id-type="doi">10.3389/fnins.2018.00291</pub-id><?supplied-pmid 29875620?><pub-id pub-id-type="pmid">29875620</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
