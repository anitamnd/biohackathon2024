<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">1780122</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-7-S4-S4</article-id>
    <article-id pub-id-type="pmid">17217522</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-7-S4-S4</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A fast parallel algorithm for finding the longest common sequence of multiple biosequences</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Chen</surname>
          <given-names>Yixin</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>chen@cse.wustl.edu</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Wan</surname>
          <given-names>Andrew</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>awan@wustl.edu</email>
      </contrib>
      <contrib id="A3" contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Wei</given-names>
        </name>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>yzliuwei@126.com</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>Department of Computer Science and Engineering, Washington University in St. Louis, St. Louis, MO 63130, USA</aff>
    <aff id="I2"><label>2</label>Department of Computer Science, Yangzhou University, Yangzhou 225009, China</aff>
    <pub-date pub-type="collection">
      <year>2006</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>12</month>
      <year>2006</year>
    </pub-date>
    <volume>7</volume>
    <issue>Suppl 4</issue>
    <supplement>
      <named-content content-type="supplement-title">Symposium of Computations in Bioinformatics and Bioscience (SCBB06)</named-content>
      <named-content content-type="supplement-editor">Youping Deng, Jun Ni</named-content>
      <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/content/pdf/1471-2105-7-S4-info.pdf">http://www.biomedcentral.com/content/pdf/1471-2105-7-S4-info.pdf</ext-link>
    </supplement>
    <fpage>S4</fpage>
    <lpage>S4</lpage>
    <permissions>
      <copyright-statement>Copyright © 2006 Chen et al; licensee BioMed Central Ltd</copyright-statement>
      <copyright-year>2006</copyright-year>
      <copyright-holder>Chen et al; licensee BioMed Central Ltd</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Chen
               Yixin
               
               chen@cse.wustl.edu
            </dc:author><dc:title>
            A fast parallel algorithm for finding the longest common sequence of multiple biosequences
         </dc:title><dc:date>2006</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 7(Suppl 4): S4-. (2006)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2006)7:Suppl 4&#x0003c;S4&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Searching for the longest common sequence (LCS) of multiple biosequences is one of the most fundamental tasks in bioinformatics. In this paper, we present a parallel algorithm named FAST_LCS to speedup the computation for finding LCS.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>A fast parallel algorithm for LCS is presented. The algorithm first constructs a novel successor table to obtain all the identical pairs and their levels. It then obtains the LCS by tracing back from the identical character pairs at the last level. Effective pruning techniques are developed to significantly reduce the computational complexity. Experimental results on gene sequences in the <italic>tigr </italic>database show that our algorithm is optimal and much more efficient than other leading LCS algorithms.</p>
      </sec>
      <sec>
        <title>Conclusion</title>
        <p>We have developed one of the fastest parallel LCS algorithms on an MPP parallel computing model. For two sequences <italic>X </italic>and <italic>Y </italic>with lengths <italic>n </italic>and <italic>m</italic>, respectively, the memory required is max{4*(<italic>n</italic>+1)+4*(<italic>m</italic>+1), <italic>L</italic>}, where <italic>L </italic>is the number of identical character pairs. The time complexity is O(<italic>L</italic>) for sequential execution, and <italic>O</italic>(|LCS(<italic>X</italic>, <italic>Y</italic>)|) for parallel execution, where |LCS(<italic>X</italic>, <italic>Y</italic>)| is the length of the LCS of <italic>X </italic>and <italic>Y</italic>. For <italic>n </italic>sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>, the time complexity is O(<italic>L</italic>) for sequential execution, and <italic>O</italic>(|LCS(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>)|) for parallel execution. Experimental results support our analysis by showing significant improvement of the proposed method over other leading LCS algorithms.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>June 20–24 2006</conf-date>
      <conf-name>Symposium of Computations in Bioinformatics and Bioscience (SCBB06) in conjunction with the International Multi-Symposiums on Computer and Computational Sciences 2006 (IMSCCS|06)</conf-name>
      <conf-loc>Hangzhou, China</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <p>Biological sequence [<xref ref-type="bibr" rid="B1">1</xref>] can be represented as a sequence of symbols. For instance, a protein [<xref ref-type="bibr" rid="B2">2</xref>] is a sequence of 20 different letters (amino acids), and DNA sequences (genes) can be represented as sequences of four letters A, C, G and T corresponding to the four sub-molecules forming DNA. When a new biosequence is found, we want to know what other sequences it is most similar to. Sequence comparison [<xref ref-type="bibr" rid="B3">3</xref>-<xref ref-type="bibr" rid="B5">5</xref>] has been used successfully to establish the link between cancer-causing genes and a gene evolved in normal growth and development. One way of detecting the similarity of two or more sequences is to find their LCS.</p>
    <p>The LCS problem is to find a substring that is common to two or more given strings and is the longest one of such strings. Since the LCS problem is essentially a special case of the global sequence alignment, all the algorithms for the sequence alignment can be used to solve the LCS problem. Presented in 1981, the Smith-Waterman algorithm [<xref ref-type="bibr" rid="B6">6</xref>] is a well known LCS algorithm which was evolved from the Needleman-Wunsch [<xref ref-type="bibr" rid="B7">7</xref>] algorithm, and can guarantee the correctness. Aho and et al. [<xref ref-type="bibr" rid="B8">8</xref>] gave a lower bound of <italic>O</italic>(<italic>mn</italic>) on time for the LCS problem using a decision tree model. It is shown in [<xref ref-type="bibr" rid="B9">9</xref>] that the problem can be solved in <italic>O</italic>(<italic>mn</italic>) time using <italic>O</italic>(<italic>mn</italic>) space by dynamic programming. Mayers and Miller [<xref ref-type="bibr" rid="B10">10</xref>] used the technique proposed by Hirschberg [<xref ref-type="bibr" rid="B11">11</xref>] to reduce the space complexity to <italic>O</italic>(<italic>m</italic>+<italic>n</italic>) on the premise of the same time complexity.</p>
    <p>To further reduce the computation time, some parallel algorithms [<xref ref-type="bibr" rid="B12">12</xref>-<xref ref-type="bibr" rid="B14">14</xref>] have been proposed for different computational models. For the CREW-PRAM model, Aggarwal [<xref ref-type="bibr" rid="B15">15</xref>] and Apostolico et al [<xref ref-type="bibr" rid="B16">16</xref>] independently proposed an <italic>O</italic>(log <italic>m </italic>log <italic>n</italic>) time algorithm using <italic>mn</italic>/log <italic>m </italic>processors. Lu et al [<xref ref-type="bibr" rid="B17">17</xref>] designed two parallel LCS algorithms, one uses <italic>mn</italic>/log <italic>m </italic>processors with a time complexity of <italic>O</italic>(log<sup>2 </sup><italic>n</italic>+log <italic>m</italic>), and the other uses <italic>mn/</italic>(log<sup>2 </sup><italic>m </italic>loglog <italic>m</italic>) processors with a running time of <italic>O</italic>(log<sup>2 </sup><italic>m </italic>loglog <italic>m</italic>). For the CRCW-PRAM model, Apostolico et al [<xref ref-type="bibr" rid="B16">16</xref>] gave an <italic>O</italic>(log <italic>n </italic>(loglog <italic>m</italic>)<sup>2</sup>) time algorithm using <italic>mn</italic>/loglogm processors. Babu and Saxena [<xref ref-type="bibr" rid="B18">18</xref>] improved these algorithms for the CRCW-PRAM model. They designed an <italic>O</italic>(log <italic>m</italic>) algorithm with <italic>mn </italic>processors and an O(log<sup>2</sup><italic>n</italic>) time parallel algorithm. Many parallel LCS algorithms have also been proposed using systolic arrays. Robert et al [<xref ref-type="bibr" rid="B19">19</xref>] proposed a parallel algorithm with <italic>n </italic>+ 5<italic>m </italic>steps using <italic>m</italic>(<italic>m</italic>+1) processing elements. Chang et al [<xref ref-type="bibr" rid="B20">20</xref>] put forward an algorithm with 4<italic>n</italic>+2<italic>m </italic>steps using <italic>mn </italic>processing elements. Luce et al [<xref ref-type="bibr" rid="B21">21</xref>] designed a systolic array with <italic>m</italic>(<italic>m</italic>+1)/2 processing elements and <italic>n</italic>+3<italic>m</italic>+<italic>q </italic>steps where <italic>q </italic>is the length of the LCS. Freschi and Bogliolo [<xref ref-type="bibr" rid="B22">22</xref>] addressed the problem of computing the LCS between run-length-encoded (RLE) strings. Their algorithm requires <italic>O</italic>(<italic>m</italic>+<italic>n</italic>) steps on a systolic array of <italic>M</italic>+<italic>N </italic>processing elements, where <italic>M </italic>and <italic>N </italic>are the lengths of the original strings and <italic>m </italic>and <italic>n </italic>are the number of runs in their RLE representation.</p>
    <p>For the LCS problem of multiple sequences, the time complexity tends to grow very fast when the number of the sequences increases. For instance, using the Smith-Waterman algorithm to solve the LCS for multiple sequences, the time complexity is <inline-graphic xlink:href="1471-2105-7-S4-S4-i1.gif"/>, where <italic>n </italic>is the number of sequences, and <italic>n</italic><sub><italic>i </italic></sub>is the length of the <italic>i</italic>th sequence. It is not practicable when <italic>n </italic>is large. Some improvements have been made on the algorithm. The MSA program [<xref ref-type="bibr" rid="B23">23</xref>] can process up to ten closely related sequences. It is an implementation of the Carrillo and Lipman algorithm [<xref ref-type="bibr" rid="B24">24</xref>] that identifies in advance the portions of the hyperspace not contributing to the solution and excludes them from the computation. Stoye described a new divide and conquer algorithm DCA [<xref ref-type="bibr" rid="B25">25</xref>] that extends the capability of MSA. Recently, OMA [<xref ref-type="bibr" rid="B26">26</xref>], an iterative implementation of DCA is proposed to speed up the DCA strategy and reduce memory requirements. Based on Feng and Doolittle's algorithm [<xref ref-type="bibr" rid="B28">28</xref>], Clustal-W [<xref ref-type="bibr" rid="B27">27</xref>] is one of the most widely used multiple sequence alignment software that can also be used for LCS computation.</p>
  </sec>
  <sec>
    <title>Results</title>
    <p>In this paper, we present a fast algorithm named FAST_LCS for efficient computation of LCS. The algorithm first seeks the successors of the initial identical character pairs according to a successor table to obtain all the identical pairs and their levels. Then by tracing back from the identical character pair in the last level, it obtains the result of LCS.</p>
    <p>The key technique of our algorithm is the use of several effective <bold>pruning operations</bold>. In the process of generating the successors, pruning techniques can remove the identical pairs which can not generate the LCS so as to reduce the search space and accelerate the search speed. The algorithm can be extended to find the LCS of multiple biosequences.</p>
    <p>Experimental results on the gene sequences of the <italic>tigr </italic>database, using an MPP parallel computer Shenteng 1800, show that our algorithm can obtain the exact optimal results and is much faster than some other leading LCS algorithms.</p>
  </sec>
  <sec>
    <title>Conclusion</title>
    <p>In this paper, we have developed FAST_LCS, one of the fastest parallel LCS algorithms on an MPP parallel computing model. For two sequences <italic>X </italic>and <italic>Y </italic>with lengths <italic>n </italic>and <italic>m</italic>, respectively, the memory complexity of FAST_LCS is max{4*(<italic>n</italic>+1)+4*(<italic>m</italic>+1), <italic>L</italic>}, where <italic>L </italic>is the number of identical character pairs. The time complexity is O<italic>(L</italic>) for sequential execution of the algorithm, and <italic>O</italic>(|LCS(<italic>X</italic>,<italic>Y</italic>)|) for parallel execution, where |LCS(<italic>X</italic>,<italic>Y</italic>)| is the length of the LCS of <italic>X </italic>and <italic>Y</italic>. The algorithm can be extended to solve the LCS for multiple biosequences. For <italic>n </italic>sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>, the time complexity is O<italic>(L</italic>) for sequential execution, and <italic>O</italic>(|LCS(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>)|), which is independent of the number of sequences, for parallel execution. Experimental results support our analysis by showing significant improvement of the proposed method over some other leading LCS algorithms.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>The identical character pair and its successor table</title>
      <p>Let <italic>X </italic>= (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, ..., <italic>x</italic><sub><italic>n</italic></sub>), <italic>Y </italic>= (<italic>y</italic><sub>1</sub>, <italic>y</italic><sub>2</sub>, ..., <italic>y</italic><sub><italic>m</italic></sub>) be two biosequences, where <italic>x</italic><sub><italic>i</italic></sub>, <italic>y</italic><sub><italic>i </italic></sub>∈ {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>}. We can define an array CH of the four characters so that CH(1) = "<italic>A</italic>", CH(2)= "C", CH(3)= "G" and CH(4)= "T". To find the LCS of <italic>X </italic>and <italic>Y</italic>, we first build the successor tables of the identical characters for the two strings. The successor tables of the identical characters of <italic>X </italic>and <italic>Y </italic>are denoted as <italic>TX </italic>and <italic>TY</italic>, which are two dimensional arrays of size 4(n+1) × 4*(m+1). For sequence <italic>X </italic>= (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>, ..., <italic>x</italic><sub><italic>n</italic></sub>), <italic>TX </italic>(<italic>i</italic>, <italic>j</italic>) in table <italic>TX </italic>is defined as follows.</p>
      <p>
        <inline-graphic xlink:href="1471-2105-7-S4-S4-i2.gif"/>
      </p>
      <p>Here, <italic>SX </italic>(<italic>i</italic>, <italic>j</italic>) = {<italic>k</italic>| <italic>x</italic><sub><italic>k </italic></sub>= CH(<italic>i</italic>), <italic>k </italic>&gt;<italic>j</italic>}, where <italic>i </italic>= 1,2,3,4 and <italic>j </italic>= 0,1,...<italic>n</italic>. It can be seen from the definition that if <italic>TX</italic>(<italic>i</italic>, <italic>j</italic>) is not "-", it indicates the position of the next character identical to CH(<italic>i</italic>) after the <italic>j</italic>th position in sequence <italic>X</italic>, otherwise it means there is no such character after the <italic>j</italic>th position.</p>
      <p>Example 1</p>
      <p>Let <italic>X </italic>= "T G C A T A" and <italic>Y </italic>= "A T C T G A T". Their successor tables <italic>TX </italic>and <italic>TY </italic>are shown in Table <xref ref-type="table" rid="T1">1</xref>.</p>
      <p>For the sequences <italic>X </italic>and <italic>Y</italic>, if <italic>x</italic><sub><italic>i </italic></sub>= <italic>y</italic><sub><italic>j </italic></sub>= CH(<italic>k</italic>), we call them an identical pair of CH(<italic>k</italic>) and denote it as (<italic>i</italic>, <italic>j</italic>). The set of all the identical character pairs of <italic>X </italic>and <italic>Y </italic>is denoted as <italic>S</italic>(<italic>X</italic>, <italic>Y</italic>).</p>
      <p>Let (<italic>i</italic>, <italic>j</italic>) and (<italic>k</italic>, <italic>l</italic>) be two identical character pairs of <italic>X </italic>and <italic>Y</italic>. If <italic>i </italic>&lt;<italic>k </italic>and <italic>j </italic>&lt;<italic>l</italic>, we call (<italic>i</italic>,<italic>j</italic>) a predecessor of (<italic>k</italic>, <italic>l</italic>), or (<italic>k</italic>, <italic>l</italic>) a successor of (<italic>i</italic>, <italic>j</italic>), and denote the relationship as (<italic>i</italic>, <italic>j</italic>) &lt; (<italic>k</italic>, <italic>l</italic>).</p>
      <p>Let <italic>P</italic>(<italic>i</italic>, <italic>j</italic>) = {(<italic>r</italic>, <italic>s</italic>) | (<italic>i</italic>, <italic>j</italic>) &lt; (<italic>r</italic>, <italic>s</italic>), (<italic>r</italic>, <italic>s</italic>)∈<italic>S</italic>(<italic>X,Y</italic>)} be the set of all the successors of identical pair (<italic>i</italic>, <italic>j</italic>), if (<italic>k</italic>, <italic>l</italic>)∈<italic>P</italic>(<italic>i</italic>, <italic>j</italic>) and there is no (<italic>k</italic>', <italic>l</italic>')∈<italic>P</italic>(<italic>i</italic>, <italic>j</italic>) satisfying the condition: (<italic>k</italic>', <italic>l</italic>') &lt; (<italic>k</italic>, <italic>l</italic>) and <italic>x</italic><sub><italic>k' </italic></sub>= <italic>x</italic><sub><italic>k</italic></sub>, we call (<italic>k</italic>, <italic>l</italic>) the direct successor of (<italic>i</italic>, <italic>j</italic>), and denote the relationship as (<italic>i</italic>, <italic>j</italic>)≺(<italic>k</italic>, <italic>l</italic>).</p>
      <p>If an identical pair (<italic>i</italic>, <italic>j</italic>) ∈ <italic>S</italic>(<italic>X, Y</italic>) and there is no (<italic>k</italic>, <italic>l</italic>)∈<italic>S</italic>(<italic>X, Y</italic>) satisfying (<italic>k</italic>, <italic>l</italic>) &lt; (<italic>i</italic>, <italic>j</italic>), we call (<italic>i</italic>, <italic>j</italic>) an initial identical pair.</p>
      <p>For an identical pair (<italic>i</italic>, <italic>j</italic>)∈<italic>S </italic>(<italic>X, Y</italic>), its level is defined as follows:</p>
      <p>
        <inline-graphic xlink:href="1471-2105-7-S4-S4-i3.gif"/>
      </p>
      <p>From the definitions above, the following theorems can be easily deduced:</p>
      <p><bold>Theorem1. </bold>Denote the length of the LCS of <italic>X </italic>and <italic>Y </italic>as |LCS(<italic>X</italic>, <italic>Y</italic>)|, then |LCS(<italic>X</italic>, <italic>Y</italic>)| = max{level (<italic>i</italic>, <italic>j</italic>)|(<italic>i</italic>, <italic>j</italic>)∈<italic>S</italic>(<italic>X</italic>, <italic>Y</italic>)}.</p>
      <p><bold>Proof: </bold>Suppose the identical character pairs corresponding to the longest common subsequence of <italic>X</italic>, <italic>Y </italic>are (<italic>x</italic><sub><italic>i</italic>1</sub>, <italic>y</italic><sub><italic>j</italic>1</sub>), (<italic>x</italic><sub><italic>i</italic>2</sub>, <italic>y</italic><sub><italic>j</italic>2</sub>), ..., (<italic>x</italic><sub><italic>ir</italic></sub>, <italic>y</italic><sub><italic>jr</italic></sub>), here <italic>r </italic>= |LCS(<italic>X</italic>, <italic>Y</italic>)|. Since (<italic>i</italic><sub>1</sub>, <italic>j</italic><sub>1</sub>) is an initial identical character pair, we have: (<italic>i</italic><sub><italic>k</italic></sub>, <italic>j</italic><sub><italic>k</italic></sub>)≺(<italic>i</italic><sub><italic>k</italic>+1</sub>, <italic>j</italic><sub><italic>k</italic>+1</sub>), for <italic>k </italic>= 1,2,...,<italic>r</italic>-1, and the level of (<italic>x</italic><sub><italic>ik</italic></sub>, <italic>y</italic><sub><italic>jk</italic></sub>) is <italic>k</italic>. Then we can conclude that the maximal level of all the identical character pairs is <italic>r</italic>, i.e. <italic>r </italic>= max{level(<italic>i</italic>, <italic>j</italic>)|(<italic>i</italic>, <italic>j</italic>)∈<italic>S</italic>(<italic>X</italic>, <italic>Y</italic>)}. The reason is as follows: if <italic>r </italic>is not the maximal level of the identical character pairs of <italic>X</italic>, <italic>Y</italic>, there must be an integer <italic>r</italic>' &gt;<italic>r </italic>and identical character pairs: (<italic>x</italic><sub><italic>i</italic>1'</sub>, <italic>y</italic><sub><italic>j</italic>1</sub>,)≺(<italic>x</italic><sub><italic>i</italic>2'</sub>, <italic>y</italic><sub><italic>j</italic>2</sub>,)≺ .....≺(<italic>x</italic><sub><italic>ir</italic></sub>', <italic>y</italic><sub><italic>jr</italic></sub>'). It corresponds to another common subsequence of <italic>X </italic>and <italic>Y </italic>with length <italic>r</italic>' &gt;<italic>r</italic>. This is in contradiction with the condition <italic>r </italic>= |LCS(<italic>X</italic>, <italic>Y</italic>)|.</p>
    </sec>
    <sec>
      <title>The operation of producing successors</title>
      <p>In our algorithm, all direct successors of all the initial identical character pairs are first produced in parallel using the successor tables. Then the direct successors of all those successors produced in the first step are generated in parallel. Repeat these operations of generating the direct successors until no more successors could be produced. Therefore, producing all the direct successors for the identical character pairs is a basic operation in our algorithm.</p>
      <p>For an identical character pair (<italic>i</italic>, <italic>j</italic>)∈<italic>S</italic>(<italic>X</italic>, <italic>Y</italic>), the operation of producing all its direct successors is as follows:</p>
      <p>(<italic>i</italic>,<italic>j</italic>) →{(<italic>TX</italic>(<italic>k,i</italic>),<italic>TY</italic>(<italic>k,j</italic>))|<italic>k </italic>= 1,2,3,4, <italic>TX</italic>(<italic>k,i</italic>)≠'-' and <italic>TY</italic>(<italic>k,j</italic>)≠'-'}     (3)</p>
      <p>From (3) we can see that this operation is to couple the elements of the <italic>i</italic>th column of <italic>TX </italic>and the <italic>j</italic>th column of <italic>TY </italic>to get the pairs.</p>
      <p>For instance, the successors of the identical character pair (2,5) in Example 1 can be obtained by coupling the elements of the 2<sup>nd </sup>column of <italic>TX </italic>and the 5<sup>th </sup>column of <italic>TY</italic>. They are (4, 6), (3, -), (-, -) and (5, 7). Here (3, -) and (-,-) do not represent identical character pairs, they only indicate the end of the process of searching for the successors in the branches they located. After discarding (3,-) and (-,-), the successors of (2, 5) are just (4, 6) and (5, 7).</p>
      <p><bold>Theorem 2. </bold>For an identical character pair (<italic>i</italic>, <italic>j</italic>), the method in (3) above can produce all its direct successors.</p>
      <p><bold>Proof: </bold>By (3), we can produce all direct successors (<italic>TX</italic>(<italic>k</italic>, <italic>i</italic>),<italic>TY</italic>(<italic>k</italic>, <italic>j</italic>)), where <italic>k </italic>= 1,2,3,4, of (<italic>i</italic>, <italic>j</italic>). According to (1),<italic>TX</italic>(<italic>k</italic>, <italic>i</italic>) is the location of the nearest character identical to CH(<italic>k</italic>) after <italic>x</italic><sub><italic>i </italic></sub>in string <italic>X</italic>, and<italic>TY</italic>(<italic>k</italic>, <italic>j</italic>) is the location of the nearest such character of CH(<italic>k</italic>) after <italic>y</italic><sub><italic>j </italic></sub>in string <italic>Y</italic>. This means that identical pairs (<italic>TX</italic>(<italic>k</italic>, <italic>i</italic>),<italic>TY</italic>(<italic>k</italic>, <italic>j</italic>)), where <italic>k </italic>= 1,2,3,4, contain all the direct successors of (<italic>i</italic>, <italic>j</italic>). Consequently, by the same operation on the newly generated identical pairs (<italic>TX</italic>(<italic>k</italic>, <italic>i</italic>),<italic>TY</italic>(<italic>k</italic>, <italic>j</italic>)), where <italic>k </italic>= 1,2,3,4, we can get all of their direct successors. It can be seen that by repeating this operation of producing successors, we can obtain all the successors of (<italic>i</italic>, <italic>j</italic>).</p>
      <p>It is obvious that (<italic>TX</italic>(<italic>k</italic>, 0),<italic>TY</italic>(<italic>k</italic>, 0)), where <italic>k </italic>= 1,2,3,4, are all the initial identical pairs of <italic>X </italic>and <italic>Y</italic>. By Theorem 2, we know that starting from these initial identical pairs, all the other identical pairs of <italic>X, Y</italic>, and their levels can be produced.</p>
    </sec>
    <sec>
      <title>The operations of pruning</title>
      <p>In the process of generating the successors, pruning techniques can be implemented to remove the identical pairs which can not generate the LCS so as to reduce the search space and improve the efficiency.</p>
      <sec>
        <title>Pruning Operation 1</title>
        <p>If on the same level, there are two identical character pairs (<italic>i</italic>, <italic>j</italic>) and <italic>(k, l) </italic>satisfying (<italic>k</italic>, <italic>l</italic>)<italic>&gt;</italic>(<italic>i</italic>, <italic>j</italic>), then (<italic>k</italic>, <italic>l</italic>) can be pruned without affecting the correctness of the algorithm in obtaining the LCS of <italic>X </italic>and <italic>Y</italic>.</p>
        <sec>
          <title>Rationale</title>
          <p>The reason we can prune (<italic>k</italic>, <italic>l</italic>) is as follows. Suppose the two identical character pairs (<italic>i</italic>, <italic>j</italic>) and (<italic>k</italic>, <italic>l</italic>) are produced by the identical pairs (<italic>i</italic><sub>1</sub>, <italic>j</italic><sub>1</sub>) and (<italic>k</italic><sub>1</sub>, <italic>l</italic><sub>1</sub>) on the previous level. Let the LCS produced via (<italic>k</italic><sub>1</sub>, <italic>l</italic><sub>1</sub>) and (<italic>k</italic>, <italic>l</italic>) be <italic>a</italic><sub>1</sub><italic>a</italic><sub>2</sub>...<italic>a</italic><sub><italic>m</italic></sub><italic>a</italic><sub><italic>m</italic>+1</sub>...<italic>a</italic><sub><italic>r</italic></sub>, here <italic>a</italic><sub><italic>m </italic></sub>corresponds to (<italic>k</italic><sub>1</sub>, <italic>l</italic><sub>1</sub>) and <italic>a</italic><sub><italic>m</italic>+1 </sub>corresponds to (<italic>k</italic>, <italic>l</italic>). Similarly, let the subsequence produced via (<italic>i</italic><sub>1</sub>, <italic>j</italic><sub>1</sub>) and (<italic>i</italic>, <italic>j</italic>) be <italic>b</italic><sub>1</sub><italic>b</italic><sub>2</sub>...<italic>b</italic><sub><italic>m</italic></sub><italic>b</italic><sub><italic>m</italic>+1</sub>...<italic>b</italic><sub><italic>s</italic></sub>...<italic>b</italic><sub><italic>q</italic></sub>, here, <italic>b</italic><sub><italic>m </italic></sub>corresponds to (<italic>i</italic><sub>1</sub>,<italic>j</italic><sub>1</sub>) and <italic>b</italic><sub><italic>m</italic>+1 </sub>corresponds to (<italic>i</italic>, <italic>j</italic>). Since (<italic>k</italic>, <italic>l</italic>)&gt;(<italic>i</italic>, <italic>j</italic>), by Theorem 2 (<italic>k</italic>, <italic>l</italic>) must be produced after (<italic>i</italic>, <italic>j</italic>). Then there must exist <italic>b</italic><sub><italic>s </italic></sub>(<italic>m</italic>+1 &lt;<italic>s </italic>&lt;<italic>q</italic>) corresponding to (<italic>k</italic>, <italic>l</italic>). Since <italic>a</italic><sub><italic>m</italic>+1</sub>...<italic>a</italic><sub><italic>r </italic></sub>and <italic>b</italic><sub><italic>s</italic></sub><italic>b</italic><sub><italic>s</italic>+1</sub>...<italic>b</italic><sub><italic>q </italic></sub>are both the local longest common subsequences obtained by the operations of producing successors on (<italic>k</italic>, <italic>l</italic>), we have "<italic>a</italic><sub><italic>m</italic>+1</sub>...<italic>a</italic><sub><italic>r</italic></sub>" = "<italic>b</italic><sub><italic>s</italic></sub><italic>b</italic><sub><italic>s</italic>+1</sub>...<italic>b</italic><sub><italic>q</italic></sub>" which means <italic>q-s = r-(m+1)</italic>, and <italic>q = r</italic>+s-(m+1). Since <italic>s&gt;m+1</italic>, we have <italic>q &gt; r</italic>. Therefore the subsequence "<italic>a</italic><sub><italic>m</italic></sub><italic>a</italic><sub><italic>m</italic>+1</sub>...<italic>a</italic><sub><italic>r</italic></sub>", which is produced on the <italic>m</italic>th level via (<italic>k</italic><sub>1</sub>, <italic>l</italic><sub>1</sub>), can not be included in the LCS of <italic>X </italic>and <italic>Y</italic>, and (<italic>k</italic>, <italic>l</italic>) can be pruned without affecting the algorithm to get the LCS of <italic>X </italic>and <italic>Y</italic>.</p>
          <p>This pruning operation can be implemented to remove all those redundant identical pairs. After each level of identical pairs are generated, the algorithm checks all the newly generated identical pairs on the same level to find all such identical pairs (<italic>i</italic>, <italic>j</italic>) and (<italic>k</italic>, <italic>l</italic>) satisfying (<italic>k</italic>, <italic>l</italic>) &gt; (<italic>i</italic>, <italic>j</italic>) and then prune (<italic>k</italic>, <italic>l</italic>).</p>
          <p>For instance, (4, 6) and (5, 7) in Example 1 are the successors of the identical pair (2, 5). Since they are on the same level and (4, 6)≺(5, 7), we can prune (5, 7).</p>
          <p>For another identical character pair (1,2) in Example 1, its successors are (4,6), (3,3), (2,5) and (5,2) which are obtained by coupling the 1<sup><italic>st </italic></sup>column of <italic>TX </italic>and the 2<sup><italic>nd </italic></sup>column of <italic>TY</italic>.</p>
          <p>Since (3, 3) &lt; (4, 6), (4, 6) can be omitted by pruning operation 1. On the next level, the successors of (3, 3), (2, 5) and (5, 2) are (4, 6), (5, 4), (5, 7) and (6, 6). Since identical pair (6, 6) is a successor of (5, 4), (5, 7) is a successor of (4, 6) and they are on the same level, (6, 6) and (5, 7) can be pruned.</p>
        </sec>
      </sec>
      <sec>
        <title>Pruning Operation 2</title>
        <p>If on the same level, there are two identical character pairs (<italic>i</italic><sub>1</sub>, <italic>j</italic>) and (<italic>i</italic><sub>2</sub>, <italic>j</italic>) satisfying <italic>i</italic><sub>1 </sub>&lt;<italic>i</italic><sub>2</sub>, then (<italic>i</italic><sub>2</sub>, <italic>j</italic>) can be pruned without affecting the correctness of the algorithm in obtaining the LCS of <italic>X </italic>and <italic>Y</italic>.</p>
        <sec>
          <title>Rationale</title>
          <p>The reason we can prune (<italic>i</italic><sub>2</sub>, <italic>j</italic>) is as follows. Let the successors of (<italic>i</italic><sub>1</sub>, <italic>j</italic>) be (<italic>l</italic><sub>2</sub>, <italic>j</italic><sub>2</sub>)≺(<italic>l</italic><sub>3</sub>, <italic>j</italic><sub>3</sub>)≺...≺(<italic>l</italic><sub><italic>r</italic></sub>, <italic>j</italic><sub><italic>r</italic></sub>), then the length of common subsequence of "<italic>x</italic><sub><italic>i</italic>1</sub><italic>x</italic><sub><italic>i</italic>1+1 </sub>...<italic>x</italic><sub><italic>n</italic></sub>" and "<italic>y</italic><sub><italic>j</italic></sub><italic>y</italic><sub><italic>j</italic>+1 </sub>...<italic>y</italic><sub><italic>m</italic></sub>" is just <italic>r</italic>. Let the successors of (<italic>i</italic><sub>2</sub>, <italic>j</italic>) are (<italic>k</italic><sub>2</sub>, <italic>j</italic><sub>2</sub>')≺(<italic>k</italic><sub>3</sub>, <italic>j</italic><sub>3</sub>')≺...≺(<italic>k</italic><sub><italic>q</italic></sub>, <italic>j</italic><sub><italic>q</italic></sub>'). Because i1 &lt; i2, if an LCS contains a subsequence following (i2, j), this exact subsequence(note that all the x index is larger than i2) can be added at the end of (i1, j). Since (i1, j) and (i2, j) are on the same level, there must exist an LCS containing (i1, j). In other words, for any LCS containing identical character pair (i2, j), there is at least a corresponding LCS containing identical character pair (i1, j). Thus (<italic>i</italic><sub>2</sub>, <italic>j</italic>) can be pruned without affecting the algorithm to get the LCS of <italic>X </italic>and <italic>Y</italic>.</p>
          <p>By extending pruning operation 2, we can get the following pruning operation.</p>
        </sec>
      </sec>
      <sec>
        <title>Pruning Operation 3</title>
        <p>If there are identical character pairs (i<sub>1</sub>, j), (i<sub>2</sub>, j), ...,(i<sub><italic>r</italic></sub>, j) and <italic>i</italic><sub>1 </sub>&lt;<italic>i</italic><sub>2</sub>&lt;...&lt;<italic>i</italic><sub><italic>r</italic></sub>, then we can prune(<italic>i</italic><sub>2</sub>, <italic>j</italic>),...,(<italic>i</italic><sub><italic>r</italic></sub>, <italic>j</italic>).</p>
      </sec>
    </sec>
    <sec>
      <title>Framework of FAST_LCS and complexity analysis</title>
      <p>Based on the operations of generating the successors of the identical character pairs using successor tables and the pruning operations, we present a fast parallel LCS algorithm named FAST_LCS. The algorithm consists of two phases: searching for all the identical character pairs and tracing back to get the LCS. The first phase begins with the initial identical character pairs; then continuously searches for successors using the successor tables. In this phase, the pruning technology is implemented to discard those search branches that obviously can not obtain the optimum solution so as to reduce the search space and speed up the process of searching.</p>
      <p>The framework of the FAST_LCS algorithm is as follows, where the phase of searching for all the identical character pairs consists of steps 1, 2, 3 and the phase of tracing back is in step 4.</p>
      <p>Step 1. Build tables <italic>TX </italic>and<italic>TY</italic>;</p>
      <p>Step 2. Find all the initial identical character pairs:(<italic>TX</italic>(<italic>k</italic>, 0),<italic>TY</italic>(<italic>k</italic>, 0)), where <italic>k </italic>= 1,2,3,4, and add the records of the initial identical pairs (<italic>k</italic>, <italic>TX</italic>(<italic>k</italic>, 0), <italic>TY</italic>(<italic>k</italic>, 0), 1, <italic>Φ</italic>, <italic>active</italic>), <italic>k </italic>= 1,2,3,4 to the table <italic>pairs</italic>.</p>
      <p>Step 3. Repeat the following until there is no record in <italic>active </italic>state in table <italic>pairs</italic>.</p>
      <p>Step 3.1 For all <italic>active </italic>identical pairs (<italic>k</italic>, <italic>i</italic>, <italic>j</italic>, <italic>level</italic>, <italic>pred</italic>, <italic>active</italic>) in <italic>pairs </italic>parallel-do</p>
      <p>Step 3.1.1 Produce all the direct successors of (<italic>k</italic>, <italic>i</italic>, <italic>j</italic>, <italic>level</italic>, <italic>pred</italic>, <italic>active</italic>).</p>
      <p>Step 3.1.2 For each identical character pair (<italic>g</italic>, <italic>h</italic>) in the direct successors set of (<italic>k</italic>, <italic>i</italic>, <italic>j</italic>, <italic>level</italic>, <italic>pred</italic>, <italic>active</italic>), a new record (<italic>k'</italic>, <italic>g</italic>, <italic>h</italic>, <italic>level</italic>+1, <italic>k</italic>, <italic>active</italic>) is generated and inserted into the table <italic>pairs</italic>.</p>
      <p>Step 3.1.3 Change the state of (<italic>k</italic>, <italic>i</italic>, <italic>j</italic>, <italic>level</italic>, <italic>pred</italic>, <italic>active</italic>) into <italic>inactive</italic>.</p>
      <p>Step 3.2 Use the pruning operations on all the successors produced on this level to remove all the redundant identical pairs from table <italic>pairs</italic>.</p>
      <p>Step 4. Compute <italic>r </italic>= the maximum level in the table <italic>pairs</italic>.</p>
      <p>For all the identical pairs (<italic>k</italic>, <italic>i</italic>, <italic>j</italic>, <italic>r</italic>,<italic>l</italic>,<italic>inactive</italic>) in <italic>pairs </italic>parallel-do</p>
      <p>Step 4.1. <italic>pred </italic>= <italic>l</italic>; <italic>LCS</italic>(<italic>r</italic>) = <italic>x</italic><sub><italic>i</italic></sub>.</p>
      <p>Step 4.2 While <italic>pred </italic>≠ <italic>Φ </italic>do</p>
      <p>Step 4.2.1 get the <italic>pred</italic>-th record (<italic>pred</italic>, <italic>g</italic>, <italic>h</italic>, <italic>r</italic>',<italic>l</italic>', <italic>inactive</italic>) from table <italic>pairs</italic>.</p>
      <p>Step 4.2.2 <italic>pred </italic>= <italic>l</italic>'; <italic>LCS</italic>(<italic>r</italic>') = <italic>x</italic><sub><italic>g</italic></sub>.</p>
      <p>In the algorithm, a table called <italic>pairs </italic>is used to store the identical character pairs obtained in the algorithm. In the table <italic>pairs</italic>, each record takes the form of (<italic>k</italic>, <italic>i</italic>, <italic>j</italic>, <italic>level</italic>, <italic>pred</italic>, <italic>state</italic>) where the data denote the index of the record, the identical character pair (<italic>i</italic>, <italic>j</italic>), its level, the index of its direct predecessor, and its current state, respectively. Each record in <italic>pairs </italic>has two states. For the identical pairs whose successors have not been searched, it is in the <italic>active </italic>state, otherwise it is in the i<italic>nactive </italic>state. In every step of search process, the algorithm searches for the successors of all the identical pairs in <italic>active </italic>state in parallel, and repeat this search process until there is no more identical pairs in <italic>active </italic>state in the table. The phase of tracing back starts from the identical pairs with the maximum level in the table, and traces back according to the <italic>pred </italic>of each identical pair. This tracing back process ends when it reaches an initial identical pair, and the trail indicates the LCS. If there are more than one identical pairs with the maximum level in the table, the tracing back procedure for those identical pairs can be carried out in parallel and several LCS can be obtained concurrently.</p>
      <p>The LCS of <italic>X</italic>, <italic>Y </italic>is stored in the array <italic>LCS</italic>. In our algorithm, every identical pair must have the operation of producing successors at least once. Because of the pruning technology, this operation will only be run exactly once on each identical character pair. Therefore, assuming that the number of the identical character pairs of <italic>X</italic>, <italic>Y </italic>is <italic>L</italic>, the time complexity for a sequential execution of the algorithm FAST_LCS (<italic>X</italic>, <italic>Y</italic>) is <italic>O</italic>(<italic>L</italic>). Since the table <italic>pairs </italic>has to store all the identical character pairs, it requires <italic>O</italic>(<italic>L</italic>) memory space. Considering that the space cost of <italic>TX</italic>, <italic>TY </italic>are 4*(<italic>n</italic>+1) and 4*(<italic>m</italic>+1), the storage complexity of our algorithm is max{4*(<italic>n</italic>+1)+4*(<italic>m</italic>+1), <italic>L</italic>}. In parallel implementation of the algorithm, since the process for each identical pair can be assigned to one processor, all the operations on the identical pairs can be carried out in parallel. Thus, the processing of each level requires <italic>O</italic>(1) time, and the number of time steps required for a parallel execution of FAST_LCS is equal to the maximum level of the identical pairs. By Theorem 1, we know that the length of the LCS of <italic>X</italic>, <italic>Y</italic>, |LCS (<italic>X</italic>, <italic>Y</italic>)|, is equal to the maximum level of the identical pairs. Therefore, the time complexity of parallel FAST_LCS is <italic>O</italic>(|LCS(<italic>X</italic>,<italic>Y</italic>)|).</p>
    </sec>
    <sec>
      <title>Finding the LCS of multiple sequences using FAST_LCS</title>
      <p>Our algorithm FAST_LCS can be easily extended to the LCS problem of multiple sequences. Suppose there are <italic>n </italic>sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>, where <italic>X </italic>= (<italic>x</italic><sub><italic>i</italic>1</sub>, <italic>x</italic><sub><italic>i</italic>2</sub>, ..., <italic>x</italic><sub><italic>i</italic>,<italic>ni</italic></sub>), <italic>n</italic><sub><italic>i </italic></sub>is the length of <italic>X</italic><sub><italic>i</italic></sub>, <italic>x</italic><sub><italic>ij </italic></sub>∈ {<italic>A</italic>, <italic>C</italic>, <italic>G</italic>, <italic>T</italic>} where j = 1, 2, ..., <italic>n</italic><sub><italic>i</italic></sub>. To find their LCS, similar to the case of two sequences, the algorithm for multiple sequences first builds the successor tables for all the sequences. Denote the successor tables of <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n </italic></sub>as <italic>TX</italic><sub>1</sub>, <italic>TX</italic><sub>2</sub>, ..., <italic>TX</italic><sub><italic>n</italic></sub>, respectively, where <italic>TX</italic><sub><italic>s </italic></sub>is a two-dimensional array of size 4*(<italic>n</italic><sub><italic>s </italic></sub>+ 1 [-del-n<sub><italic>i</italic></sub>+1]) for the sequence <italic>X</italic><sub>s </sub>= (<italic>x</italic><sub><italic>s</italic>1</sub>, <italic>x</italic><sub><italic>s</italic>2</sub>, ..., <italic>x</italic><sub><italic>s</italic>,<italic>ns</italic></sub>), <italic>s </italic>= 1,2,...<italic>n</italic>, and successor table <italic>TX</italic><sub><italic>s </italic></sub>of identical characters is defined as:</p>
      <p>
        <inline-graphic xlink:href="1471-2105-7-S4-S4-i4.gif"/>
      </p>
      <p>where <italic>SX</italic><sub><italic>s </italic></sub>(<italic>i</italic>, <italic>j</italic>) = {<italic>k</italic>|<italic>x</italic><sub><italic>sk </italic></sub>= CH(<italic>i</italic>), <italic>k</italic>&gt;<italic>j</italic>} where i = 1, 2, 3, 4.</p>
      <p>Similar to identical character pairs in the case of two sequences, we define the concept of <bold><italic>identical character tuple </italic></bold>for LCS of multiple sequences. For the sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>, if <inline-graphic xlink:href="1471-2105-7-S4-S4-i5.gif"/>,we record them in an identical character tuple of the sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ...,<italic>X</italic><sub><italic>n </italic></sub>and denote it as (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>). The set of all the identical character tuples of <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ...,<italic>X</italic><sub><italic>n </italic></sub>is denoted as <italic>S</italic>(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>).</p>
      <p>Let (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) and (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ...,<italic>j</italic><sub><italic>n</italic></sub>) be two identical character tuples of <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>. If <italic>i</italic><sub><italic>k </italic></sub>&lt;<italic>j</italic><sub><italic>k</italic></sub>, for <italic>k </italic>= 1,2,...<italic>n</italic>, we call (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) a predecessor of (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ..., <italic>j</italic><sub><italic>n</italic></sub>), or (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ..., <italic>j</italic><sub><italic>n</italic></sub>) a successor of (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>), and denote them as (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) &lt; (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ..., <italic>j</italic><sub><italic>n</italic></sub>).</p>
      <p>Let <italic>P</italic>(<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) = {(<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ..., <italic>j</italic><sub><italic>n</italic></sub>) | (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) &lt; (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ..., <italic>j</italic><sub><italic>n</italic></sub>), (<italic>j</italic><sub>1</sub>, <italic>j</italic><sub>2</sub>, ..., <italic>j</italic><sub><italic>n</italic></sub>)∈<italic>S</italic>(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>)} be the set of all the successors of identical tuple (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>), if (<italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub>, ...,<italic>k</italic><sub><italic>n</italic></sub>)∑<italic>P </italic>(<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) and there is no (<italic>k</italic><sub>1</sub>', <italic>k</italic><sub>2</sub>', ..., <italic>k</italic><sub><italic>n</italic></sub>')∈<italic>P</italic>(<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>,..., <italic>i</italic><sub><italic>n</italic></sub>) satisfying the condition: (<italic>k</italic><sub>1</sub>', <italic>k</italic><sub>2</sub>', ..., <italic>k</italic><sub><italic>n</italic></sub>') &lt; (<italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub>, ..., <italic>k</italic><sub><italic>n</italic></sub>) and <inline-graphic xlink:href="1471-2105-7-S4-S4-i6.gif"/>, we call (<italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub>, ..., <italic>k</italic><sub><italic>n</italic></sub>) the direct successor of (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>), and denoted it as (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>)≺(<italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub>, ..., <italic>k</italic><sub><italic>n</italic></sub>).</p>
      <p>If an identical tuple (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>)∈<italic>S</italic>(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>) and there is no (<italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub>, ..., <italic>k</italic><sub><italic>n</italic></sub>)∈<italic>S</italic>(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>) satisfying (<italic>k</italic><sub>1</sub>, <italic>k</italic><sub>2</sub>, ..., <italic>k</italic><sub><italic>n</italic></sub>)≺(<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>), we call (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) an initial identical tuple.</p>
      <p>For an identical tuple (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>)∈<italic>S</italic>(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>), its level is defined as follows:</p>
      <p>
        <inline-graphic xlink:href="1471-2105-7-S4-S4-i7.gif"/>
      </p>
      <p>Similar to the case of two sequences LCS, the following theorems can be easily deduced.</p>
      <p><bold>Theorem 3. </bold>Denote the length of the LCS of <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>,..., <italic>X</italic><sub><italic>n </italic></sub>as |LCS(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>,...,<italic>X</italic><sub><italic>n</italic></sub>)|, then</p>
      <p>|LCS(<italic>X</italic><sub>1</sub>,<italic>X</italic><sub>2</sub>,...,<italic>X</italic><sub><italic>n</italic></sub>)| = max {<italic>level</italic>(<italic>i</italic><sub>1</sub>,<italic>i</italic><sub>2</sub>,...<italic>i</italic><sub><italic>n</italic></sub>)|(<italic>i</italic><sub>1</sub>,<italic>i</italic><sub>2</sub>,...<italic>i</italic><sub><italic>n</italic></sub>)∈<italic>S</italic>(<italic>X</italic><sub>1</sub>,<italic>X</italic><sub>2</sub>,...,<italic>X</italic><sub><italic>n</italic></sub>)}.</p>
      <p>Proof of Theorem 3 is similar to that of Theorem 1.</p>
      <p>In our parallel algorithm for LCS of multiple sequences, all direct successors of all the initial identical character tuples are produced in parallel using the successor tables. Then, the direct successors of all those successors produced in the first step are generated in parallel. Repeat these operations of generating the direct successors until no more successors could be produced. For an identical character tuple (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>) ∈ <italic>S </italic>(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>,..., <italic>X</italic><sub><italic>n</italic></sub>), this operation is as follows:</p>
      <p>(<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>,...,<italic>i</italic><sub><italic>n</italic></sub>)→{(<italic>TX</italic><sub>1</sub>(<italic>k</italic>, <italic>i</italic><sub>1</sub>), <italic>TX</italic><sub>2</sub>(<italic>k</italic>, <italic>i</italic><sub>2</sub>),...,<italic>TX</italic><sub><italic>n</italic></sub>(<italic>k</italic>, <italic>i</italic><sub><italic>n</italic></sub>))| <italic>k </italic>= 1,2,3,4, <italic>TX</italic><sub><italic>j</italic></sub>(<italic>k</italic>, <italic>i</italic><sub><italic>j</italic></sub>) ≠ '-', <italic>j </italic>= 1,2,...,<italic>n</italic>}     (6)</p>
      <p>From (6) we can see that this operation is to assemble the elements of the <italic>i</italic><sub><italic>j</italic></sub>-th column of <italic>TX</italic><sub><italic>j</italic></sub>, for <italic>j </italic>= 1,2,...,<italic>n </italic>to get the new tuples.</p>
      <p><bold>Example 2. </bold>Let <italic>n </italic>= 3, and <italic>X</italic><sub>1 </sub>= "T G C A T A", <italic>X</italic><sub>2 </sub>= "A T C T G A T", and <italic>X</italic><sub>3 </sub>= "C T G A T T C". Their successor tables <italic>TX</italic><sub>1</sub>, <italic>TX</italic><sub>2 </sub>and <italic>TX</italic><sub>3 </sub>are shown in Table <xref ref-type="table" rid="T2">2</xref>.</p>
      <p>By assembling the 0<sup>th </sup>columns of the successor tables, we can get the initial identical triples (4,1,4), (3,3,1), (2,5,3) and (1,2,2).</p>
      <p>The direct successors of the identical character triple (1,2,2) can be obtained by grouping the elements of the 1<sup>st </sup>column of <italic>TX</italic><sub>1 </sub>and the 2<sup>nd </sup>columns of <italic>TX</italic><sub>2 </sub>and <italic>TX</italic><sub>3</sub>, which are (4,6,4),(3,3,7) (2,5,3) and (5,4,5).</p>
      <p><bold>Theorem 4. </bold>For an identical character tuple (<italic>i</italic><sub>1</sub>, <italic>i</italic><sub>2</sub>, ..., <italic>i</italic><sub><italic>n</italic></sub>), the method in (6) can produce all its successors.</p>
      <p>Proof of Theorem 4 is similar to that of Theorem 2.</p>
      <p>From Theorem 4, we know that all the successors of the identical tuples on each level can be generated by the operation of producing successors. Starting from the initial identical tuples, all the identical tuples can be produced. In such process of generating the successors, pruning techniques can be implemented to remove the identical tuples which can not generate the longest common subsequence so as to reduce the search space. All the pruning operations for two-sequence LCS can be easily extended to the case of multiple sequences.</p>
      <p>For instance, in Example 2, among the successors of triple (1,2,2), we have (2,5,3)≺(4,6,4), since they are on the same level, we can prune (4,6,4). For another instance in Example 2, among the initial identical triples (4,1,4), (3,3,1), (2,5,3) and (1,2,2), since they are in the same level and (1,2,2)≺(2,5,3) we can prune (2,5,3).</p>
      <p>Assume that the number of the identical character tuples of the sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n </italic></sub>is <italic>L</italic>. In our algorithm, since every identical tuple must have the operation of producing successors exactly once, the time complexity for sequentially executing of the algorithm on the sequences <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n </italic></sub>is <italic>O</italic>(<italic>L</italic>). The algorithm uses a table <italic>tuples </italic>to store all the identical character tuples, it requires <italic>O</italic>(<italic>L</italic>) memory space. Considering that the memory space cost of <italic>TX</italic><sub><italic>j</italic></sub>, for <italic>j </italic>= 1,2,...,<italic>n</italic>, is 4<inline-graphic xlink:href="1471-2105-7-S4-S4-i8.gif"/>, the storage complexity of our algorithm is max{4 <inline-graphic xlink:href="1471-2105-7-S4-S4-i8.gif"/>, <italic>L</italic>}. In a parallel implementation, since the computation for each identical tuple can be assigned on one processor, all the process on the identical tuples can be carried out in parallel. Therefore, the processing of each level requires <italic>O</italic>(1) time, and the time required for the parallel computation is equal to the maximum level of the identical tuples which is equal to the length of the longest common subsequence of <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>. Therefore the time complexity of the parallel execution of FAST_LCS on multiple sequences is <italic>O</italic>(|LCS(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>)|).</p>
      <p>It should be pointed out that for most of the algorithms for multiple-sequence LCS, their time complexity strongly depends on the number of the sequences. For instance, if we use the Smith-Waterman algorithm to find the LCS of multiple sequences, the time complexity is <inline-graphic xlink:href="1471-2105-7-S4-S4-i9.gif"/>, where <italic>n </italic>is the number of sequences, which is not practicable when <italic>n </italic>is large. The time complexity of our algorithm is <italic>O</italic>(<italic>L</italic>) for sequential computation and <italic>O </italic>(|LCS(<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, ..., <italic>X</italic><sub><italic>n</italic></sub>)|) for parallel implementation, where the time complexity of FAST_LCS is <bold><italic>independent of the number of sequences n</italic></bold>. This means that our algorithm is much more efficient for finding the LCS of a large number of sequences.</p>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <sec>
      <title>The results of sequential computation on two sequences</title>
      <p>We test our algorithm FAST_LCS on the rice gene sequences of the <italic>tigr </italic>[<xref ref-type="bibr" rid="B29">29</xref>] database and compare the performance of FAST_LCS with that of Smith-Waterman algorithm [<xref ref-type="bibr" rid="B30">30</xref>] and FASTA algorithm [<xref ref-type="bibr" rid="B31">31</xref>,<xref ref-type="bibr" rid="B32">32</xref>] which are currently the most widely used LCS algorithms. Since both our algorithm and Smith-Waterman's can obtain exactly correct solution, we compare the computation speed of our algorithm FAST_LCS with that of Smith-Waterman algorithm. Also, we compare the precision of our algorithm with that of FASTA using the same computation time.</p>
      <p>Table <xref ref-type="table" rid="T3">3</xref> compares the computation speed of FAST_LCS with that of Smith-Waterman algorithm on groups of gene sequence pairs with different lengths. Since a test on one pair of sequences takes very short time, it is hard to compare the speed of the algorithms using a single pair of sequence. Therefore we test the algorithms on groups of sequence pairs with similar lengths. We test five groups of sequence pairs each of which consisting of 100 pairs of sequences. The total time for each group by the two algorithms are listed in Table <xref ref-type="table" rid="T3">3</xref>.</p>
      <p>Fig. <xref ref-type="fig" rid="F1">1</xref> shows the comparison of the computation time of our algorithm with that of Smith-Waterman algorithm. From the table and the figure, we can see that our algorithm is obviously faster than Smith-Waterman algorithm for sequence sets of all different lengths. The difference of the computation time between the two algorithms grows exponentially when the length of sequences becomes greater than 150. This means that our algorithm is much faster and more efficient than Smith-Waterman's for finding the LCS of long sequences.</p>
      <p>We also compare the precision of our algorithm with that of FASTA on the premise of the same computing time. Here precision is defined as:</p>
      <p>
        <inline-graphic xlink:href="1471-2105-7-S4-S4-i10.gif"/>
      </p>
      <p>Fig. <xref ref-type="fig" rid="F2">2</xref> shows the comparison of the precision of the results by our algorithm with that by FASTA using the same computation time. From Fig. <xref ref-type="fig" rid="F2">2</xref>, we can see that our algorithm can obtain the correct result no matter how long the sequence is, while the precision of FASTA declines when the length of the sequences is increased. Therefore the precision of our algorithm is much higher than that of FASTA.</p>
    </sec>
    <sec>
      <title>The results of sequential computing on multiple sequences</title>
      <p>We test our algorithm FAST_LCS on the multiple sequences and compare with the Clustal-W[<xref ref-type="bibr" rid="B27">27</xref>] algorithm which is a popular algorithm for multiple-sequence LCS. Fig. <xref ref-type="fig" rid="F3">3</xref> and Fig. <xref ref-type="fig" rid="F4">4</xref> show the comparison of the computation time of our algorithm FAST_LCS with that of Clustal-W algorithm. Table <xref ref-type="table" rid="T4">4</xref> lists the computation time of the two algorithms on 5 sets of different numbers of sequences with length of 50. Comparison of the computation time of the two algorithms on sequences sets of different numbers of sequences is shown in Fig. <xref ref-type="fig" rid="F3">3</xref>.</p>
      <p>From Fig. <xref ref-type="fig" rid="F3">3</xref> and Table <xref ref-type="table" rid="T4">4</xref>, we can see that FAST_LCS is faster than Clustal-W for sets with different numbers of sequences. When the number of sequences is larger than five, the speed up is significant.</p>
      <p>Table <xref ref-type="table" rid="T5">5</xref> lists the computation time of the two algorithms on five sequences sets with different lengths. Comparison of the computation time of the two algorithms on sequence sets of different lengths is shown in Fig. <xref ref-type="fig" rid="F4">4</xref>. From Table <xref ref-type="table" rid="T5">5</xref> and Fig. <xref ref-type="fig" rid="F4">4</xref>, we can see that FAST_LCS is faster than Clustal-W for sequence sets with different lengths.</p>
      <p>We also compare the precision of our FAST_LCS algorithm with that of Clustal-W algorithm. Fig. <xref ref-type="fig" rid="F5">5</xref> shows the comparison of precision of FAST_LCS with that of Clustal-W on the sets with different numbers of sequences, and Fig. <xref ref-type="fig" rid="F6">6</xref> shows the comparison of precision of the two algorithms on the sets of sequences with different lengths. From these two figures, we can see that no matter how the length and the number of sequences are increased, our algorithm can obtain the exactly correct results. The precision of Clustal-W declines when the number or the length of the sequences is increased. Therefore the precision of our algorithm is much higher than Clustal-W.</p>
    </sec>
    <sec>
      <title>The results of parallel computing</title>
      <p>We also test our algorithm on the rice gene sequence from the <italic>tigr </italic>database [<xref ref-type="bibr" rid="B29">29</xref>] on the Shenteng 1800 supercomputer using MPI (C bounding). In the parallel implementation of FAST_LCS, the identical character pairs in the <italic>active </italic>state are assigned and processed in different processors. The experimental results by using different numbers of processors are shown in Fig. <xref ref-type="fig" rid="F7">7</xref>. Three pairs of gene sequences are tested. The names, lengths, and computation times are listed in Table <xref ref-type="table" rid="T6">6</xref>. From Fig. <xref ref-type="fig" rid="F7">7</xref> and Table <xref ref-type="table" rid="T6">6</xref> we can see that the computation will become faster as the number of processors increases. Due to the communication overhead between processors, the speedup of our algorithm is slower than linear, which conforms to the Amdahl's Law.</p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>This work is supported in part by research funds from an Early Career Principal Investigator Award from the Department of Energy of the United States, the Washington University in St. Louis, the Chinese National Natural Science Foundation under grant No. 60673060, the Chinese National Foundation for Science and Technology Development under contract 2003BA614A-14, and the Natural Science Foundation of Jiangsu Province under contract BK2005047.</p>
      <p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 7, Supplement 4, 2006: Symposium of Computations in Bioinformatics and Bioscience (SCBB06). The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/7?issue=S4"/>.</p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Hao</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>SY</given-names>
          </name>
        </person-group>
        <article-title>The manual of bioinformatics</article-title>
        <source>Shanghai Science and Technology Publishing Company</source>
        <year>2000</year>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>YD</given-names>
          </name>
          <name>
            <surname>Sun</surname>
            <given-names>ZR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Bioinformatics – The practice guide for the analysis of gene and protein</article-title>
        <source>Tsinghua University Publishing Company</source>
        <year>2000</year>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Edmiston</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Core</surname>
            <given-names>NG</given-names>
          </name>
          <name>
            <surname>Saltz</surname>
            <given-names>JH</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Parallel processing of biological sequence comparison algorithms</article-title>
        <source>International Journal of Parallel Programming</source>
        <year>1988</year>
        <volume>17</volume>
        <fpage>259</fpage>
        <lpage>275</lpage>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Lander</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Protein sequence comparison on a data parallel computer</article-title>
        <source>Proceedings of the 1988 International Conference on Parallel Processing</source>
        <year>1988</year>
        <fpage>257</fpage>
        <lpage>263</lpage>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Galper</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Brutlag</surname>
            <given-names>DL</given-names>
          </name>
        </person-group>
        <article-title>Parallel similarity search and alignment with the dynamic programming method</article-title>
        <source>Technical Report</source>
        <year>1990</year>
        <publisher-name>California: Stanford University</publisher-name>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequence</article-title>
        <source>Journal of Molecular Biology</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J Mol Biol</source>
        <year>1970</year>
        <volume>48</volume>
        <fpage>443</fpage>
        <lpage>453</lpage>
        <pub-id pub-id-type="pmid">5420325</pub-id>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Aho</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hirschberg</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Ullman</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Bounds on the complexity of the longest common subsequence problem</article-title>
        <source>J Assoc Comput Mach</source>
        <year>1976</year>
        <volume>23</volume>
        <fpage>1</fpage>
        <lpage>12</lpage>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>J Molec Biol</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>705</fpage>
        <lpage>708</lpage>
        <pub-id pub-id-type="pmid">7166760</pub-id>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mayers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Optimal alignment in linear space</article-title>
        <source>Comput Appl Biosci</source>
        <year>1998</year>
        <volume>4</volume>
        <fpage>11</fpage>
        <lpage>17</lpage>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hirschberg</surname>
            <given-names>DS</given-names>
          </name>
        </person-group>
        <article-title>A Linear space algorithm for computing maximal Common Subsequences</article-title>
        <source>Commun ACM</source>
        <year>1975</year>
        <volume>18</volume>
        <fpage>341</fpage>
        <lpage>343</lpage>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pan</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Linear array with a reconfigurable pipelined bus system – concepts and applications</article-title>
        <source>Journal of Information Science</source>
        <year>1998</year>
        <volume>106</volume>
        <fpage>237</fpage>
        <lpage>258</lpage>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Myoupo</surname>
            <given-names>JF</given-names>
          </name>
          <name>
            <surname>David Seme</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Time-efficient parallel algorithms for the longest common subsequence and related problems</article-title>
        <source>Journal of Parallel and Distributed Computing</source>
        <year>1999</year>
        <volume>57</volume>
        <fpage>212</fpage>
        <lpage>223</lpage>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Bergroth</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Hakonen</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Raita</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>A survey of longest common subsequence algorithms</article-title>
        <source>Seventh International Symposium on String Processing Information Retrieval</source>
        <year>2000</year>
        <fpage>39</fpage>
        <lpage>48</lpage>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Aggarwal</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Park</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Notes on searching in multidimensional monotone Arrays</article-title>
        <source>Proc 29th Ann IEEE Symp Foundations of Comput Sci</source>
        <year>1988</year>
        <fpage>497</fpage>
        <lpage>512</lpage>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Apostolico</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Atallah</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Larmore</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Mcfaddin</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Efficient parallel algorithms for string editing and related problems</article-title>
        <source>SIAM J Computing</source>
        <year>1990</year>
        <volume>19</volume>
        <fpage>968</fpage>
        <lpage>988</lpage>
      </citation>
    </ref>
    <ref id="B17">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lu</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Lin</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Parallel algorithms for the longest common subsequence Problem</article-title>
        <source>IEEE Transaction on Parallel and Distributed System</source>
        <year>1994</year>
        <volume>5</volume>
        <fpage>835</fpage>
        <lpage>848</lpage>
      </citation>
    </ref>
    <ref id="B18">
      <citation citation-type="other">
        <person-group person-group-type="author">
          <name>
            <surname>Babu</surname>
            <given-names>KN</given-names>
          </name>
          <name>
            <surname>Systems</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Saxena</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Parallel algorithms for the longest common subsequence problem</article-title>
        <source>4th International Conference on High Performance Computing</source>
        <year>1997</year>
        <fpage>18</fpage>
        <lpage>21</lpage>
      </citation>
    </ref>
    <ref id="B19">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Robert</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Tchuente</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>A Systolic Array for the Longest Common Subsequence Problem</article-title>
        <source>Inform Process Lett</source>
        <year>1985</year>
        <volume>21</volume>
        <fpage>191</fpage>
        <lpage>198</lpage>
      </citation>
    </ref>
    <ref id="B20">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chang</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Ibarra</surname>
            <given-names>OH</given-names>
          </name>
          <name>
            <surname>Pallis</surname>
            <given-names>MA</given-names>
          </name>
        </person-group>
        <article-title>Parallel parsing on a one-way array of finite-state machines</article-title>
        <source>IEEE Trans Computers</source>
        <year>1987</year>
        <volume>C-36</volume>
        <fpage>64</fpage>
        <lpage>75</lpage>
      </citation>
    </ref>
    <ref id="B21">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luce</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Myoupo</surname>
            <given-names>JF</given-names>
          </name>
        </person-group>
        <article-title>Systolic-based parallel architecture for the longest common subsequences problem</article-title>
        <source>Integration</source>
        <year>1998</year>
        <volume>25</volume>
        <fpage>53</fpage>
        <lpage>70</lpage>
      </citation>
    </ref>
    <ref id="B22">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Freschi</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Bogliolo</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Longest common subsequence between run-length-encoded strings:a new algorithm with improved parallelism</article-title>
        <source>Information Processing Letters</source>
        <year>2004</year>
        <volume>90</volume>
        <fpage>167</fpage>
        <lpage>173</lpage>
      </citation>
    </ref>
    <ref id="B23">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Kececioglu</surname>
            <given-names>JD</given-names>
          </name>
        </person-group>
        <article-title>A tool for multiple sequence alignment</article-title>
        <source>Proc Natl Acad Sci USA</source>
        <year>1989</year>
        <volume>86</volume>
        <fpage>4412</fpage>
        <lpage>4415</lpage>
        <pub-id pub-id-type="pmid">2734293</pub-id>
      </citation>
    </ref>
    <ref id="B24">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Carrillo</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>The multiple sequence alignment problem in biology</article-title>
        <source>SIAM J Appl Math</source>
        <year>1988</year>
        <volume>48</volume>
        <fpage>1073</fpage>
        <lpage>1082</lpage>
      </citation>
    </ref>
    <ref id="B25">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Moulton</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Dress</surname>
            <given-names>AW</given-names>
          </name>
        </person-group>
        <article-title>DCA: an efficient implementation of the divide-andconquer approach to simultaneous multiple sequence alignment</article-title>
        <source>Comput Appl Biosci</source>
        <year>1997</year>
        <volume>13</volume>
        <fpage>625</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="pmid">9475994</pub-id>
      </citation>
    </ref>
    <ref id="B26">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Will</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>An iterative method for faster sum-of-pair multiple sequence alignment</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <fpage>808</fpage>
        <lpage>814</lpage>
        <pub-id pub-id-type="pmid">11108703</pub-id>
      </citation>
    </ref>
    <ref id="B27">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>JD</given-names>
          </name>
          <name>
            <surname>Higgins</surname>
            <given-names>DG</given-names>
          </name>
          <name>
            <surname>Gibson</surname>
            <given-names>TJ</given-names>
          </name>
        </person-group>
        <article-title>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position specific gap penalties and weight matrix choice</article-title>
        <source>Nucleic Acids Research</source>
        <year>1994</year>
        <volume>22</volume>
        <fpage>4673</fpage>
        <lpage>4680</lpage>
        <pub-id pub-id-type="pmid">7984417</pub-id>
      </citation>
    </ref>
    <ref id="B28">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Feng</surname>
            <given-names>DF</given-names>
          </name>
          <name>
            <surname>Doolittle</surname>
            <given-names>RF</given-names>
          </name>
        </person-group>
        <article-title>Progressive sequence alignment as a prerequisite to correct phylogenetic trees</article-title>
        <source>J Mol Evol</source>
        <year>1987</year>
        <volume>25</volume>
        <fpage>351</fpage>
        <lpage>360</lpage>
        <pub-id pub-id-type="pmid">3118049</pub-id>
      </citation>
    </ref>
    <ref id="B29">
      <citation citation-type="other">
        <ext-link ext-link-type="uri" xlink:href="http://www.tigr.org/tdb/benchmark"/>
      </citation>
    </ref>
    <ref id="B30">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
          <name>
            <surname>Gish</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>EW</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Basic local alignment search tool</article-title>
        <source>J Mol Biol</source>
        <year>1990</year>
        <volume>215</volume>
        <fpage>403</fpage>
        <lpage>410</lpage>
        <pub-id pub-id-type="pmid">2231712</pub-id>
      </citation>
    </ref>
    <ref id="B31">
      <citation citation-type="other">
        <ext-link ext-link-type="uri" xlink:href="http://alpha10.bioch.virginia.edu/fasta_www/cgi/"/>
      </citation>
    </ref>
    <ref id="B32">
      <citation citation-type="other">
        <ext-link ext-link-type="uri" xlink:href="http://www.ebi.ac.uk/services/"/>
      </citation>
    </ref>
  </ref-list>
  <sec sec-type="display-objects">
    <title>Figures and Tables</title>
    <fig position="float" id="F1">
      <label>Figure 1</label>
      <caption>
        <p>Comparison of the computation time of FAST_LCS with that of Smith – Waterman algorithm.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-1"/>
    </fig>
    <fig position="float" id="F2">
      <label>Figure 2</label>
      <caption>
        <p>Comparison of the precision of FAST_LCS with that of FASTA using the same computation time.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-2"/>
    </fig>
    <fig position="float" id="F3">
      <label>Figure 3</label>
      <caption>
        <p>Comparison of the computation time of FAST_LCS with that of Clustal-W on sequence sets of different numbers of sequences.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-3"/>
    </fig>
    <fig position="float" id="F4">
      <label>Figure 4</label>
      <caption>
        <p>Comparison of the computation time of FAST_LCS with that of Clustal-W on sequence sets of different lengths.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-4"/>
    </fig>
    <fig position="float" id="F5">
      <label>Figure 5</label>
      <caption>
        <p>Comparison of the precision of FAST_LCS with that of Clustal-W on sequence sets with different numbers of sequences.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-5"/>
    </fig>
    <fig position="float" id="F6">
      <label>Figure 6</label>
      <caption>
        <p>Comparison of the precision of FAST_LCS with that of Clustal-W on sequence sets of different lengths.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-6"/>
    </fig>
    <fig position="float" id="F7">
      <label>Figure 7</label>
      <caption>
        <p>Parallel computational time of FAST_LCS using different processor numbers.</p>
      </caption>
      <graphic xlink:href="1471-2105-7-S4-S4-7"/>
    </fig>
    <table-wrap position="float" id="T1">
      <label>Table 1</label>
      <caption>
        <p>Their successor tables <italic>TX </italic>and <italic>TY </italic>in Example 1.</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <td align="left"><italic>TX</italic>:</td>
            <td/>
            <td/>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">
              <italic>i</italic>
            </td>
            <td align="left">CH(<italic>i</italic>)</td>
            <td align="left">0 1 2 3 4 5 6</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">
              <bold>A</bold>
            </td>
            <td align="left">4 4 4 4 6 6 -</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">
              <bold>C</bold>
            </td>
            <td align="left">3 3 3 - - - -</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">
              <bold>G</bold>
            </td>
            <td align="left">2 2 - - - - -</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">
              <bold>T</bold>
            </td>
            <td align="left">1 5 5 5 5 - -</td>
          </tr>
          <tr>
            <td colspan="3">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">
              <italic>TY:</italic>
            </td>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="3">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">
              <italic>i</italic>
            </td>
            <td align="left">CH(<italic>i</italic>)</td>
            <td align="left">0 1 2 3 4 5 6 7</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">
              <bold>A</bold>
            </td>
            <td align="left">1 6 6 6 6 6 - -</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">
              <bold>C</bold>
            </td>
            <td align="left">3 3 3 - - - - -</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">
              <bold>G</bold>
            </td>
            <td align="left">5 5 5 5 5 - - -</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">
              <bold>T</bold>
            </td>
            <td align="left">2 2 4 4 7 7 7 -</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="T2">
      <label>Table 2</label>
      <caption>
        <p>Their successor tables <italic>TX</italic><sub>1</sub>, <italic>TX</italic><sub>2 </sub>and <italic>TX</italic><sub>3 </sub>in Example 2</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <td align="left"><italic>TX</italic><sub>1</sub>:</td>
            <td/>
            <td/>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">
              <italic>i</italic>
            </td>
            <td align="left">CH(<italic>i</italic>)</td>
            <td align="left">0 1 2 3 4 5 6</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">
              <bold>A</bold>
            </td>
            <td align="left">4 4 4 4 6 6 -</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">
              <bold>C</bold>
            </td>
            <td align="left">3 3 3 - - - -</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">
              <bold>G</bold>
            </td>
            <td align="left">2 2 - - - - -</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">
              <bold>T</bold>
            </td>
            <td align="left">1 5 5 5 5 - -</td>
          </tr>
          <tr>
            <td colspan="3">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left"><italic>TX</italic><sub>2</sub>:</td>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="3">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">
              <italic>i</italic>
            </td>
            <td align="left">CH(<italic>i</italic>)</td>
            <td align="left">0 1 2 3 4 5 6 7</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">
              <bold>A</bold>
            </td>
            <td align="left">1 6 6 6 6 6 - -</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">
              <bold>C</bold>
            </td>
            <td align="left">3 3 3 - - - - -</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">
              <bold>G</bold>
            </td>
            <td align="left">5 5 5 5 5 - - -</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">
              <bold>T</bold>
            </td>
            <td align="left">2 2 4 4 7 7 7 -</td>
          </tr>
          <tr>
            <td colspan="3">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left"><italic>TX</italic><sub>3</sub>:</td>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="3">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">
              <italic>i</italic>
            </td>
            <td align="left">CH(<italic>i</italic>)</td>
            <td align="left">0 1 2 3 4 5 6 7</td>
          </tr>
          <tr>
            <td align="left">1</td>
            <td align="left">
              <bold>A</bold>
            </td>
            <td align="left">4 4 4 4 - - - -</td>
          </tr>
          <tr>
            <td align="left">2</td>
            <td align="left">
              <bold>C</bold>
            </td>
            <td align="left">1 7 7 7 7 7 7 -</td>
          </tr>
          <tr>
            <td align="left">3</td>
            <td align="left">
              <bold>G</bold>
            </td>
            <td align="left">3 3 3 - - - - -</td>
          </tr>
          <tr>
            <td align="left">4</td>
            <td align="left">
              <bold>T</bold>
            </td>
            <td align="left">2 2 5 5 5 6 - -</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="T3">
      <label>Table 3</label>
      <caption>
        <p>Comparison of computation speed of FAST_LCS with that of Smith-Waterman algorithm</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <td/>
            <td/>
            <td/>
            <td align="left" colspan="2">Time of FAST_LCS (s)</td>
            <td align="left" colspan="2">Time of S-W algorithm(s)</td>
          </tr>
          <tr>
            <td/>
            <td/>
            <td/>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">Name of Sequences</td>
            <td align="left">Length <italic>l</italic></td>
            <td align="left">Number of pairs</td>
            <td align="left">Total time</td>
            <td align="left">Average time</td>
            <td align="left">Total time</td>
            <td align="left">Average time</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">gi|21466196 ~</td>
            <td align="left">0≤<italic>l</italic>≤50</td>
            <td align="left">100</td>
            <td align="left">0.49</td>
            <td align="left">0.0049</td>
            <td align="left">1.09</td>
            <td align="left">0.0109</td>
          </tr>
          <tr>
            <td align="left">gi|21466195 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466168 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466167 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466166 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30250556 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30230255 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30230254 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229613 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229612 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229449 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229448 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|30229047 ~</td>
            <td align="left">50≤ <italic>l</italic>≤ 100</td>
            <td align="left">100</td>
            <td align="left">5.88</td>
            <td align="left">0.0588</td>
            <td align="left">11.55</td>
            <td align="left">0.1155</td>
          </tr>
          <tr>
            <td align="left">gi|30229046 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229001 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229000 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30228999 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30228998 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30228849 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30228848 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|30229447 ~</td>
            <td align="left">10≤ <italic>l</italic>≤ 150</td>
            <td align="left">100</td>
            <td align="left">29.41</td>
            <td align="left">0.2941</td>
            <td align="left">65.95</td>
            <td align="left">0.6595</td>
          </tr>
          <tr>
            <td align="left">gi|30229446 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229249 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229248 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|30228846 ~</td>
            <td align="left">15≤ <italic>l</italic>≤ 200</td>
            <td align="left">100</td>
            <td align="left">94.11</td>
            <td align="left">0.9411</td>
            <td align="left">172.213</td>
            <td align="left">1.7213</td>
          </tr>
          <tr>
            <td align="left">gi|30228845 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30228648 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30228647 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|30229247 ~</td>
            <td align="left">20≤ <italic>l</italic>≤ 250</td>
            <td align="left">100</td>
            <td align="left">230.51</td>
            <td align="left">2.3051</td>
            <td align="left">425.16</td>
            <td align="left">4.2516</td>
          </tr>
          <tr>
            <td align="left">gi|30229246 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229049 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|30229048 ~</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="T4">
      <label>Table 4</label>
      <caption>
        <p>Comparison of computation time of FAST_LCS and that of Clustal-W on sequences sets of different numbers of sequences</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <td align="left">Sequence name</td>
            <td align="left">Sequence Number</td>
            <td align="left">Time of FAST_LCS (s)</td>
            <td align="left">Time of Clustal-W (s)</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">gi|21466194</td>
            <td align="left">3</td>
            <td align="left">0.609</td>
            <td align="left">0.804</td>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466196</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|21466192</td>
            <td align="left">5</td>
            <td align="left">2.656</td>
            <td align="left">2.732</td>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466196</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|21466189</td>
            <td align="left">8</td>
            <td align="left">6.14</td>
            <td align="left">7.91</td>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466196</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|21466186</td>
            <td align="left">11</td>
            <td align="left">5.71</td>
            <td align="left">8.20</td>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466196</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="4">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|21466183</td>
            <td align="left">14</td>
            <td align="left">6.34</td>
            <td align="left">8.49</td>
          </tr>
          <tr>
            <td align="left">...</td>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td align="left">gi|21466196</td>
            <td/>
            <td/>
            <td/>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="T5">
      <label>Table 5</label>
      <caption>
        <p>Comparison of computation time of FAST_LCS with that of Clustal-W on sequences sets of different lengths</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <td/>
            <td align="left" colspan="5">The length of input sequences</td>
          </tr>
          <tr>
            <td/>
            <td colspan="5">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">Algorithm</td>
            <td align="left">20</td>
            <td align="left">30</td>
            <td align="left">50</td>
            <td align="left">60</td>
            <td align="left">80</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">Time of FAST_LCS (S)</td>
            <td align="left">0.109</td>
            <td align="left">0.391</td>
            <td align="left">2.656</td>
            <td align="left">3.516</td>
            <td align="left">6.166</td>
          </tr>
          <tr>
            <td align="left">Time of Clustal-W (S)</td>
            <td align="left">0.312</td>
            <td align="left">1.053</td>
            <td align="left">2.732</td>
            <td align="left">3.612</td>
            <td align="left">5.992</td>
          </tr>
        </tbody>
      </table>
    </table-wrap>
    <table-wrap position="float" id="T6">
      <label>Table 6</label>
      <caption>
        <p>Computational time of parallel FAST_LCS using different numbers of processors</p>
      </caption>
      <table frame="hsides" rules="groups">
        <thead>
          <tr>
            <td/>
            <td/>
            <td align="left" colspan="5">Computational time using different numbers of processors (s)</td>
          </tr>
          <tr>
            <td/>
            <td/>
            <td colspan="5">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">Sequence name</td>
            <td align="left">Length</td>
            <td align="left">1</td>
            <td align="left">2</td>
            <td align="left">4</td>
            <td align="left">8</td>
            <td align="left">16</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">gi|21466166 ~</td>
            <td align="left">250</td>
            <td align="left">2.3051</td>
            <td align="left">0.7955</td>
            <td align="left">0.51085</td>
            <td align="left">0.3300</td>
            <td align="left">0.2313</td>
          </tr>
          <tr>
            <td align="left">gi|30250556</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|30228999 ~</td>
            <td align="left">200</td>
            <td align="left">0.9411</td>
            <td align="left">0.4247</td>
            <td align="left">0.2669</td>
            <td align="left">0.15421</td>
            <td align="left">0.09379</td>
          </tr>
          <tr>
            <td align="left">gi|30228998</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
          <tr>
            <td colspan="7">
              <hr/>
            </td>
          </tr>
          <tr>
            <td align="left">gi|30229447 ~</td>
            <td align="left">150</td>
            <td align="left">0.3941</td>
            <td align="left">0.2015</td>
            <td align="left">0.10271</td>
            <td align="left">0.06975</td>
            <td align="left">0.04702</td>
          </tr>
          <tr>
            <td align="left">gi|30229446</td>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
            <td/>
          </tr>
        </tbody>
      </table>
    </table-wrap>
  </sec>
</back>
