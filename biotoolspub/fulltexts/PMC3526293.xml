<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <?epub August-16-2012?>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="iso-abbrev">Nucleic Acids Res</journal-id>
    <journal-id journal-id-type="publisher-id">nar</journal-id>
    <journal-id journal-id-type="hwp">nar</journal-id>
    <journal-title-group>
      <journal-title>Nucleic Acids Research</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">0305-1048</issn>
    <issn pub-type="epub">1362-4962</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3526293</article-id>
    <article-id pub-id-type="pmid">22904078</article-id>
    <article-id pub-id-type="doi">10.1093/nar/gks754</article-id>
    <article-id pub-id-type="publisher-id">gks754</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Methods Online</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Compression of next-generation sequencing reads aided by highly efficient de novo assembly</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Jones</surname>
          <given-names>Daniel C.</given-names>
        </name>
        <xref ref-type="aff" rid="gks754-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="gks754-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ruzzo</surname>
          <given-names>Walter L.</given-names>
        </name>
        <xref ref-type="aff" rid="gks754-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="gks754-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="gks754-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Peng</surname>
          <given-names>Xinxia</given-names>
        </name>
        <xref ref-type="aff" rid="gks754-AFF1">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Katze</surname>
          <given-names>Michael G.</given-names>
        </name>
        <xref ref-type="aff" rid="gks754-AFF1">
          <sup>4</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="gks754-AFF1"><sup>1</sup>Department of Computer Science and Engineering, University of Washington, Seattle, WA 98195-2350, <sup>2</sup>Department of Genome Sciences, University of Washington, Seattle, WA 98195-5065, <sup>3</sup>Fred Hutchinson Cancer Research Center, Seattle, WA 98109 and <sup>4</sup>Department of Microbiology, University of Washington, Seattle, WA 98195-7242, USA</aff>
    <author-notes>
      <corresp id="gks754-COR1">*To whom correspondence should be addressed. Tel: <phone>+1 206 543 1695</phone>; Fax: <fax>+1 206 543 2969</fax>; Email: <email>dcjones@cs.washington.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>12</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>13</day>
      <month>8</month>
      <year>2012</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>8</month>
      <year>2012</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>40</volume>
    <issue>22</issue>
    <fpage>e171</fpage>
    <lpage>e171</lpage>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>6</month>
        <year>2012</year>
      </date>
      <date date-type="rev-recd">
        <day>14</day>
        <month>7</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>17</day>
        <month>7</month>
        <year>2012</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2012. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2012</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">http://creativecommons.org/licenses/by-nc/3.0</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>We present Quip, a lossless compression algorithm for next-generation sequencing data in the FASTQ and SAM/BAM formats. In addition to implementing reference-based compression, we have developed, to our knowledge, the first assembly-based compressor, using a novel <italic>de novo</italic> assembly algorithm. A probabilistic data structure is used to dramatically reduce the memory required by traditional de Bruijn graph assemblers, allowing millions of reads to be assembled very efficiently. Read sequences are then stored as positions within the assembled contigs. This is combined with statistical compression of read identifiers, quality scores, alignment information and sequences, effectively collapsing very large data sets to &lt;15% of their original size with no loss of information. Availability: Quip is freely available under the 3-clause BSD license from <ext-link ext-link-type="uri" xlink:href="http://cs.washington.edu/homes/dcjones/quip">http://cs.washington.edu/homes/dcjones/quip</ext-link>.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>INTRODUCTION</title>
    <p>With the development of next-generation sequencing (NGS) technology, researchers have had to adapt quickly to cope with the vast increase in raw data. Experiments that would previously have been conducted with microarrays and resulted in several megabytes of data, are now performed by sequencing, producing many gigabytes, and demanding a significant investment in computational infrastructure. While the cost of disk storage has also steadily decreased over time, it has not matched the dramatic change in the cost and volume of sequencing. A transformative breakthrough in storage technology may occur in the coming years, but the era of the $1000 genome is certain to arrive before that of the $100 petabyte hard disk.</p>
    <p>As cloud computing and software as a service become increasingly relevant to molecular biology research, hours spent transferring NGS data sets to and from off-site servers for analysis will delay meaningful results. More often researchers will be forced to maximize bandwidth by physically transporting storage media (via the ‘sneakernet’), an expensive and logistically complicated option. These difficulties will only be amplified as exponentially more sequencing data are generated, implying that even moderate gains in domain-specific compression methods will translate into a significant reduction in the cost of managing these massive data sets over time.</p>
    <p>Storage and analysis of NGS data centers primarily around two formats that have arisen recently as <italic>de facto</italic> standards: FASTQ and SAM. FASTQ stores, in addition to nucleotide sequences, a unique identifier for each read and quality scores, which encode estimates of the probability that each base is correctly called. For its simplicity, FASTQ is a surprisingly ill-defined format. The closest thing to an accepted specification is the description by Cock <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B1">1</xref>), but the format arose <italic>ad hoc</italic> from multiple sources (primarily Sanger and Solexa/Illumina), so a number of variations exist, particularly in how quality scores are encoded. The SAM format is far more complex but also more tightly defined, and comes with a reference implementation in the form of SAMtools (<xref ref-type="bibr" rid="gks754-B2">2</xref>). It is able to store alignment information in addition to read identifiers, sequences and quality scores. SAM files, which are stored in plain text, can also be converted to the BAM format, a compressed binary version of SAM, which is far more compact and allows for relatively efficient random access.</p>
    <p>Compression of nucleotide sequences has been the target of some interest, but compressing NGS data, made up of millions of short fragments of a greater whole, combined with metadata in the form of read identifiers and quality scores, presents a very different problem and demands new techniques. Splitting the data into separate contexts for read identifiers, sequences and quality scores, and compressing them with the Lempel-Zip algorithm and Huffman coding has been explored by Tembe <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B3">3</xref>) and Deorowicz and Grabowski (<xref ref-type="bibr" rid="gks754-B4">4</xref>), who demonstrate the promise of domain-specific compression with significant gains over general-purpose programs like gzip and bzip2.</p>
    <p>Kozanitis <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B5">5</xref>) and Hsi-Yang Fritz <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B6">6</xref>) proposed reference-based compression methods, exploiting the redundant nature of the data by aligning reads to a known reference genome sequence and storing genomic positions in place of nucleotide sequences. Decompression is then performed by copying the read sequences from the genome. Though any differences from the reference sequence must also be stored, referenced-based approaches can achieve much higher compression and they grow increasing efficient with longer read lengths, since storing a genomic position requires the same amount of space, regardless of the length of the read.</p>
    <p>This idea is explored also in the Goby format (<ext-link ext-link-type="uri" xlink:href="http://campagnelab.org/software/goby/">http://campagnelab.org/software/goby/</ext-link>), which has been proposed as an alternative to SAM/BAM, the primary functional difference being that sequences of aligned reads are not stored but looked up in a reference genome when needed (frequently they are not). For some applications, reference-based compression can be taken much further by storing only single nucleotide polymorphism (SNP) information, summarizing a sequencing experiment in several megabytes (<xref ref-type="bibr" rid="gks754-B7">7</xref>). However, even when SNP calls are all that is needed, discarding the raw reads would prevent any reanalysis of the data.</p>
    <p>While a reference-based approach typically results in superior compression, it has a number of disadvantages. Most evidently, an appropriate reference sequence database is not always available, particularly in the case of metagenomic sequencing. One could be contrived by compiling a set of genomes from species expected to be represented in the sample. However, a high degree of expertise is required to curate and manage such a project-dependent database. Secondly, there is the practical concern that files compressed with a reference-based approach are not self-contained. Decompression requires precisely the same reference database used for compression, and if it is lost or forgotten, the compressed data becomes inaccessible.</p>
    <p>Another recurring theme in the the growing literature on short read compression is lossy encoding of sequence quality scores. This follows naturally from the realization that quality scores are particularly difficult to compress. Unlike read identifiers, which are highly redundant, or nucleotide sequences, which contain some structure, quality scores are inconsistently encoded between protocols and computational pipelines and are often simply high-entropy. It is dissatisfying that metadata (quality scores) should consume more space than primary data (nucleotide sequences). Yet, also dissatisfying to many researchers is the thought of discarding information without a very good understanding of its effect on downstream analysis.</p>
    <p>A number of lossy compression algorithms for quality scores have been proposed, including various binning schemes implemented in QScores-Archiver (<xref ref-type="bibr" rid="gks754-B8">8</xref>) and SCALCE (<ext-link ext-link-type="uri" xlink:href="http://scalce.sourceforge.net">http://scalce.sourceforge.net</ext-link>), scaling to a reduced alphabet with randomized rounding in SlimGene (<xref ref-type="bibr" rid="gks754-B5">5</xref>), and discarding quality scores for bases which match a reference sequence in Cramtools (<xref ref-type="bibr" rid="gks754-B6">6</xref>). In SCALCE, SlimGene and Cramtools, quality scores may also be losslessly compressed. Kozanitis <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B5">5</xref>) analyzed the effects of their algorithm on downstream analysis. Their results suggest that while some SNP calls are affected, they are primarily marginal, low-confidence calls between hetero- and homozygosity.</p>
    <p>Decreasing the entropy of quality scores while retaining accuracy is an important goal, but successful lossy compression demands an understanding of what is lost. For example, lossy audio compression (e.g. MP3) is grounded in psychoacoustic principles, preferentially discarding the least perceptible sound. Conjuring a similarly principled method for NGS quality scores is difficult given that both the algorithms that generate them and the algorithms that are informed by them are moving targets. In the analysis by Kozanitis <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B5">5</xref>), the authors are appropriately cautious in interpreting their results, pointing out that ‘there are dozens of downstream applications and much work needs to be done to ensure that coarsely quantized quality values will be acceptable for users.’</p>
    <p>In the following sections, we describe and evaluate Quip, a new lossless compression algorithm which leverages a variety of techniques to achieve very high compression over sequencing data of many types, yet remains efficient and practical. We have implement this approach in an open-source tool that is capable of compressing both BAM/SAM and FASTQ files, retaining all information from the original file.</p>
  </sec>
  <sec sec-type="materials|methods">
    <title>MATERIALS AND METHODS</title>
    <sec>
      <title>Statistical compression</title>
      <p>The basis of our approach is founded on statistical compression using arithmetic coding, a form of entropy coding which approaches optimality, but requires some care to implement efficiently [see Said (<xref ref-type="bibr" rid="gks754-B9">9</xref>) for an excellent review]. Arithmetic coding can be thought of as a refinement of Huffman coding, the major advantage being that it is able to assign codes of a non-integral number of bits. If a symbol appears with probability 0.1, it can be encoded near to its optimal code length of −log<sub>2</sub>(0.1) ≈ 3.3 bits. Despite its power, it has historically seen much less use than Huffman coding, due in large part to fear of infringing on a number of patents that have now expired.</p>
      <p>Arithmetic coding is a particularly elegant means of compression in that it allows a complete separation between statistical modeling and encoding. In Quip, the same arithmetic coder is used to encode quality scores, read identifiers, nucleotide sequences and alignment information, but with very different statistical models for each, which gives it a tremendous advantage over general-purpose compression algorithms that lump everything into a single context. Furthermore, all parts of our algorithm use adaptive modeling: parameters are trained and updated as data are compressed, so that an increasingly tight fit and higher compression is achieved on large files.</p>
      <sec>
        <title>Read identifiers</title>
        <p>The only requirement of read identifiers is that they uniquely identify the read. A single integer would do, but typically each read comes with a complex string containing the instrument name, run identifier, flow cell identifier and tile coordinates. Much of this information is the same for every read and is simply repeated, inflating the file size.</p>
        <p>To remove this redundancy, we use a form of delta encoding. A parser tokenizes the ID into separate fields which are then compared with the previous ID. Tokens that remain the same from read to read (e.g. instrument name) can be compressed to a negligible amount of space—arithmetic coding produces codes of less than 1 bit in such cases. Numerical tokens are recognized and stored efficiently, either directly or as an offset from the token in the same position in previous read. Otherwise, non-identical tokens are encoded by matching as much of the prefix as possible to the previous read's token before directly encoding the non-matching suffix.</p>
        <p>The end result is that read IDs, which are often 50 bytes or longer, are typically stored in 2–4 bytes. Notably, in reads produced from Illumina instruments, most parts of the ID can be compressed to consume almost no space; the remaining few bytes are accounted for by tile coordinates. These coordinates are almost never needed in downstream analysis, so removing them as a preprocessing step would shrink file sizes even further. The parser used is suitably general so that no change to the compression algorithm would be needed.</p>
      </sec>
      <sec>
        <title>Nucleotide sequences</title>
        <p>To compress nucleotide sequences, we adopt a very simple model based on high-order Markov chains. The nucleotide at a given position in a read is predicted using the preceding 12 positions. This model uses more memory than traditional general-purpose compression algorithms (4<sup>13</sup> = 67 108 864 parameters are needed, each represented in 32 bits) but it is simple and extremely efficient (very little computation is required and run time is limited primarily by memory latency, as lookups in such a large table result in frequent cache misses).</p>
        <p>An order-12 Markov chain also requires a very large amount of data to train, but there is no shortage with the data sets we wish to compress. Though less adept at compressing extremely short files, after compressing several million reads, the parameters are tightly fit to the nucleotide composition of the data set so that the remaining reads will be highly compressed. Compressing larger files only results in a tighter fit and higher compression.</p>
      </sec>
      <sec>
        <title>Quality scores</title>
        <p>It has been previously noted that the quality score at a given position is highly correlated with the score at the preceding position (<xref ref-type="bibr" rid="gks754-B5">5</xref>). This makes a Markov chain a natural model, but unlike nucleotides, quality scores are over a much larger alphabet (typically 41–46 distinct scores). This limits the order of the Markov chain: long chains will require a great deal of space and take a unrealistic amount of data to train.</p>
        <p>To reduce the number of parameters, we use an order-3 Markov chain, but coarsely bin the distal two positions. In addition to the preceding three positions, we condition on the position within the read and a running count of the number large jumps in quality scores between adjacent positions (where a ‘large jump’ is defined as |<italic>q</italic><sub><italic>i</italic></sub> − <italic>q</italic><sub><italic>i</italic>−1</sub>| &gt; 1), which allows reads with highly variable quality scores to be encoded using separate models. Both of these variables are binned to control the number of parameters.</p>
      </sec>
    </sec>
    <sec>
      <title>Reference-based compression</title>
      <p>We have also implemented lossless reference-based compression. Given aligned reads in SAM or BAM format, and the reference sequence to which they are aligned (in FASTA format), the reads are compressed preserving all information in the SAM/BAM file, including the header, read IDs, alignment information and all optional fields allowed by the SAM format. Unaligned reads are retained and compressed using the Markov chain model.</p>
    </sec>
    <sec>
      <title>Assembly-based compression</title>
      <p>To complement the reference-based approach, we developed an assembly-based approach which offers some of the advantages of reference-based compression, but requires no external sequence database and produces files which are entirely self-contained. We use the first (by default) 2.5 million reads to assemble contigs which are then used in place of a reference sequence database to encode aligned reads compactly as positions.</p>
      <p>Once contigs are assembled, read sequences are aligned using a simple ‘seed and extend’ method: 12-mer seeds are matched using a hash table, and candidate alignments are evaluated using Hamming distance. The best (lowest Hamming distance) alignment is chosen, assuming it falls below a given cutoff, and the read is encoded as a position within the contig set. This alignment method is simple and exceedingly fast, but it is most effective on platforms in which erroneous indels occur infrequently (e.g. Illumina).</p>
      <p>Roughly, assembly-based compression can be thought of as a variation on the Lempel-Ziv algorithm: as sequences are read, they are matched to previously observed data, or in this case, contigs assembled from previously observed data. These contigs are not explicitly stored, but rather reassembled during decompression.</p>
      <p>Traditionally, <italic>de novo</italic> assembly is extremely computationally intensive. The most commonly used technique involves constructing a de Bruijn graph, a directed graph in which each vertex represents a nucleotide <italic>k</italic>-mer present in the data for some fixed <italic>k</italic> (e.g. <italic>k</italic> = 25 is a common choice). A directed edge from a <italic>k</italic>-mer <italic>u</italic> to <italic>v</italic> occurs if and only if the (<italic>k</italic> − 1)-mer suffix of <italic>u</italic> is also the prefix of <italic>v</italic>. In principle, given such a graph, an assembly can be produced by finding an Eulerian path, i.e. a path that follows each edge in the graph exactly once (<xref ref-type="bibr" rid="gks754-B10">10</xref>). In practice, since NGS data have a non-negligible error rate, assemblers augment each vertex with the number of observed occurrences of the <italic>k</italic>-mer and leverage these counts using a variety of heuristics to filter out spurious paths.</p>
      <p>A significant bottleneck of the de Bruijn graph approach is building an implicit representation of the graph by counting and storing <italic>k</italic>-mer occurrences in a hash table. The assembler implemented in Quip overcomes this bottleneck to a large extent by using a data structure based on the Bloom filter to count <italic>k</italic>-mers. The Bloom filter (<xref ref-type="bibr" rid="gks754-B11">11</xref>) is a probabilistic data structure that represents a set of elements extremely compactly, at the cost of elements occasionally colliding and incorrectly being reported as present in the set. It is probabilistic in the sense that these collisions occur pseudo-randomly, determined by the size of the table and the hash functions chosen, but generally with low probability.</p>
      <p>The Bloom filter is generalized in the counting Bloom filter, in which an arbitrary count can be associated with each element (<xref ref-type="bibr" rid="gks754-B12">12</xref>). A very similar data structure, the CountMin Sketch, is described by Cormode and Muthukrishnan (<xref ref-type="bibr" rid="gks754-B13">13</xref>), which was arrived at independently of the prior Bloom filter research. Bonomi <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B14">14</xref>) subsequently described the d-left counting Bloom filter (dlCBF), a refinement of the counting Bloom filter requiring significantly less space to achieve the same false positive rate.</p>
      <p>We base our assembler on a realization of the dlCBF. Since we use a probabilistic data structure, <italic>k</italic>-mers are occasionally reported to have incorrect (inflated) counts. The assembly can be made less accurate by these incorrect counts, however a poor assembly only results in slightly increasing the compression ratio. Compression remains lossless regardless of the assembly quality, and in practice collisions in the dlCBF occur at a very low rate (this is explored in the ‘Results’ section).</p>
      <p>Given a probabilistic de Bruijn graph, we assemble contigs using a very simple greedy approach. A read sequence is used as a seed and extended on both ends one nucleotide at a time by repeatedly finding the most abundant <italic>k</italic>-mer that overlaps the end of the contig by <italic>k</italic> − 1 bases. More sophisticated heuristics have been developed, but we choose to focus on efficiency, sacrificing a degree of accuracy.</p>
      <p>Memory efficient assembly has been a goal of particular interest and is a topic of ongoing research. Conway and Bromage (<xref ref-type="bibr" rid="gks754-B15">15</xref>) have developed a more efficient means of representing de Bruijn graphs using sparse bitmaps compressed with Elias–Fano encoding. The String Graph Assembler described by Simpson and Durbin (<xref ref-type="bibr" rid="gks754-B16">16</xref>) takes an entirely different approach, relying on the FM-index (<xref ref-type="bibr" rid="gks754-B17">17</xref>) to build a compact representation of the set of short reads from which contigs are generated by searching for overlaps. Both of these algorithms sacrifice time-efficiency for their promising increases in space-efficiency, reporting significantly longer run times than traditional assemblers [e.g. both with compared with ABySS (<xref ref-type="bibr" rid="gks754-B18">18</xref>)].</p>
      <p>Our work is a significant departure in that we abandon exact representations and rely on a probabilistic data structure, an idea that has only very recently been breached. Counting <italic>k</italic>-mers efficiently with the help of Bloom filters was previously explored by Melsted and Pritchard (<xref ref-type="bibr" rid="gks754-B19">19</xref>), who use it in addition, rather than in place, of a hash table. The Bloom filter is used as a ‘staging area’ to store <italic>k</italic>-mers occurring only once, reducing the memory required by the hash table.</p>
      <p>Concurrently with our work, Pell <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B20">20</xref>) explore the use of probabilistic data structures in assembly, implementing a probabilistic de Bruijn graph based on the Bloom filter. While we go somewhat further, developing a full assembler using the more versatile dlCBF data structure, we have limited our discussion to data compression. Pell <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B20">20</xref>) on the other hand provide a compelling justification for the practicality of probabilistic de Bruijn graphs in the assembly problem, showing that the false-positive rate of the data structure is dwarfed by base-calling error in the data itself.</p>
    </sec>
    <sec>
      <title>Metadata</title>
      <p>In designing the file format used by Quip, we included several useful features to protect data integrity. First, output is divided into blocks of several megabytes each. In each block a separate 64-bit checksum is computed for read identifiers, nucleotide sequences and quality scores. When the archive is decompressed, these checksums are recomputed on the decompressed data and compared with the stored checksums, verifying the correctness of the output. The integrity of an archived data set can also be checked with the ‘quip-test’ command.</p>
      <p>Apart from data corruption, reference-based compression creates the possibility of data loss if the reference used for compression is lost, or an incorrect reference is used. To protect against this, Quip files store a 64-bit hash of the reference sequence, ensuring that the same sequence is used for decompression. To assist in locating the correct reference, the file name, and the lengths and names of the sequences used in compression are also stored and accessible without decompression.</p>
      <p>Additionally, block headers store the number of reads and bases compressed in the block, allowing summary statistics of a data set to be listed without decompression using the ‘quip-list’ command.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="SEC3">
    <title>RESULTS</title>
    <sec>
      <title>Compression of sequencing data</title>
      <p>We compared Quip with three commonplace general-purpose compression algorithms: gzip, bzip2 and xz, as well as more recently developed domain-specific compression algorithms: DSRC (<xref ref-type="bibr" rid="gks754-B4">4</xref>) and Cramtools (<xref ref-type="bibr" rid="gks754-B6">6</xref>). Other methods have been proposed (<xref ref-type="bibr" rid="gks754-B3">3</xref>,<xref ref-type="bibr" rid="gks754-B5">5</xref>,<xref ref-type="bibr" rid="gks754-B21">21</xref>), but without publicly available software we were unable independently evaluate them. We have also restricted our focus to lossless compression, and have not evaluated a number of promising lossy methods (<xref ref-type="bibr" rid="gks754-B6">6</xref>,<xref ref-type="bibr" rid="gks754-B8">8</xref>), nor methods only capable of compressing nucleotide sequences (<xref ref-type="bibr" rid="gks754-B22">22</xref>). We invoked Quip in three ways: using only statistical compression (‘quip’), using reference-based compression (‘quip -r’), and finally with assembly-based compression (‘quip -a’). <xref ref-type="table" rid="gks754-T1">Table 1</xref> gives an overview of the methods evaluated.
<table-wrap id="gks754-T1" position="float"><label>Table 1.</label><caption><p>Methods evaluated in the ‘Results’ section</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Program</th><th align="left" rowspan="1" colspan="1">Input</th><th align="left" rowspan="1" colspan="1">Methods</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">gzip (1.4)</td><td rowspan="1" colspan="1">Any</td><td rowspan="1" colspan="1">Lempel–Ziv</td></tr><tr><td rowspan="1" colspan="1">bzip2 (1.0.6)</td><td rowspan="1" colspan="1">Any</td><td rowspan="1" colspan="1">Burrows–Wheeler and Huffman coding</td></tr><tr><td rowspan="1" colspan="1">xz (5.0.3)</td><td rowspan="1" colspan="1">Any</td><td rowspan="1" colspan="1">Lempel–Ziv with arithmetic coding</td></tr><tr><td rowspan="1" colspan="1">sra (2.1.10)</td><td rowspan="1" colspan="1">FASTQ</td><td rowspan="1" colspan="1">No published description</td></tr><tr><td rowspan="1" colspan="1">dsrc (0.3)</td><td rowspan="1" colspan="1">FASTQ</td><td rowspan="1" colspan="1">Lempel–Ziv and Huffman coding.</td></tr><tr><td rowspan="1" colspan="1">cramtools (0.85-b51)</td><td rowspan="1" colspan="1">BAM</td><td rowspan="1" colspan="1">Reference-based compression</td></tr><tr><td rowspan="1" colspan="1">quip (1.1.0)</td><td rowspan="1" colspan="1">FASTQ, SAM, BAM</td><td rowspan="1" colspan="1">Statistical modeling with arithmetic coding</td></tr><tr><td rowspan="1" colspan="1">quip -a (1.1.0)</td><td rowspan="1" colspan="1">FASTQ, SAM, BAM</td><td rowspan="1" colspan="1">Quip with assembly-based compression</td></tr><tr><td rowspan="1" colspan="1">quip -r (1.1.0)</td><td rowspan="1" colspan="1">SAM, BAM</td><td rowspan="1" colspan="1">Quip with reference-reference based compression</td></tr></tbody></table><table-wrap-foot><fn><p>All methods compared are lossless, with the exception of Cramtools which does not preserve the original read identifiers.</p></fn></table-wrap-foot></table-wrap></p>
      <p>We acquired six data sets (<xref ref-type="table" rid="gks754-T2">Table 2</xref>) from the Sequence Read Archive (<xref ref-type="bibr" rid="gks754-B23">23</xref>), representing a broad sampling of recent applications of NGS. Genome and exome sequencing data were taken from 1000 Genomes Project (<xref ref-type="bibr" rid="gks754-B24">24</xref>), total and mRNA data from the Illumina BodyMap 2.0 data set (<xref ref-type="bibr" rid="gks754-B25">25</xref>), Runx2 ChIP-Seq performed in a prostate cancer cell line (<xref ref-type="bibr" rid="gks754-B26">26</xref>) and metagenomic DNA sequencing of biofilm found in the extremely acidic drainage from the Richmond Mine in California (<xref ref-type="bibr" rid="gks754-B27">27</xref>).
<table-wrap id="gks754-T2" position="float"><label>Table 2.</label><caption><p>We evaluated compression on a single lane of sequencing data taken from a broad collection of seven studies</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th align="left" rowspan="1" colspan="1">Accession number</th><th align="left" rowspan="1" colspan="1">Description</th><th align="left" rowspan="1" colspan="1">Source</th><th align="left" rowspan="1" colspan="1">Read length</th><th align="left" rowspan="1" colspan="1">Size (GB)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">SRR400039</td><td rowspan="1" colspan="1">Whole genome</td><td rowspan="1" colspan="1">The 1000 Genomes Project (<xref ref-type="bibr" rid="gks754-B24">24</xref>)</td><td rowspan="1" colspan="1">101</td><td rowspan="1" colspan="1">67.6</td></tr><tr><td rowspan="1" colspan="1">SRR125858</td><td rowspan="1" colspan="1">Exome</td><td rowspan="1" colspan="1">The 1000 Genomes Project (<xref ref-type="bibr" rid="gks754-B24">24</xref>)</td><td rowspan="1" colspan="1">76</td><td rowspan="1" colspan="1">55.2</td></tr><tr><td rowspan="1" colspan="1">SRR372816</td><td rowspan="1" colspan="1">Runx2 ChIP-Seq</td><td rowspan="1" colspan="1">Little <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B26">26</xref>)</td><td rowspan="1" colspan="1">50</td><td rowspan="1" colspan="1">14.6</td></tr><tr><td rowspan="1" colspan="1">ERR030867</td><td rowspan="1" colspan="1">Total RNA</td><td rowspan="1" colspan="1">The BodyMap 2.0 Project, Asmann <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B25">25</xref>)</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">19.5</td></tr><tr><td rowspan="1" colspan="1">ERR030894</td><td rowspan="1" colspan="1">mRNA</td><td rowspan="1" colspan="1">The BodyMap 2.0 Project, Asmann <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B25">25</xref>)</td><td rowspan="1" colspan="1">75</td><td rowspan="1" colspan="1">16.4</td></tr><tr><td rowspan="1" colspan="1">SRR359032</td><td rowspan="1" colspan="1">Metagenomic DNA</td><td rowspan="1" colspan="1">Denef <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B27">27</xref>)</td><td rowspan="1" colspan="1">100</td><td rowspan="1" colspan="1">8.9</td></tr></tbody></table><table-wrap-foot><fn><p>Except for the metagenomic data, each was generated from human samples. Uncompressed file sizes are shown in gigabytes.</p></fn></table-wrap-foot></table-wrap></p>
      <p>The Sequence Read Archive provides data in its own SRA compression format which we also evaluate here. Programs for working with SRA files are provided in the SRA Toolkit, but a convenient means of converting from FASTQ to SRA is not, so we have not measured compression time and memory in this case.</p>
      <p>In the case of reference-based compression implemented in Cramtools and Quip, we aligned reads from all but the metagenomic data to the GRCh37/hg19 assembly of the human genome using GSNAP (<xref ref-type="bibr" rid="gks754-B28">28</xref>) generating a BAM file. Splice-junction prediction was enabled for the two RNA-Seq data sets. In the case of multiple alignments, we removed all but the the primary (i.e. highest scoring). Quip is able to store secondary alignments, but the version of Cramtools we evaluated was not. When the purpose of alignment in simply compactly archiving the reads, secondary alignments have no purpose and merely inflate the file size, but in downstream analysis they are often extremely informative and retaining them may be desirable in some cases.</p>
      <p>It is important to note pure lossless compression is not the intended goal of Cramtools. Though we invoked Cramtools with options to include all quality scores (<monospace>––capture–all–quality–scores</monospace>), optional tags (<monospace>––capture–all–tags</monospace>) and retain unaligned reads (<monospace>––include–unmapped–reads</monospace>), it is unable to store the original read IDs. Since all other programs evaluated were entirely lossless, measuring compressed file sizes is not an entirely fair comparison. Cramtools is put at some advantage simply by excluding identifiers. However, as the only other available reference-based compression method, it is a useful comparison.</p>
      <p>With each method, we compressed then decompressed each data set on a server with a 2.8Ghz Intel Xeon processor and 64 GB of memory. In addition to recording the compressed file size (<xref ref-type="fig" rid="gks754-F1">Figure 1</xref>), we measured wall clock run-time (<xref ref-type="fig" rid="gks754-F3">Figure 3</xref>) and maximum memory usage (<xref ref-type="table" rid="gks754-T3">Table 3</xref>) using the Unix <monospace>time</monospace> command. Run time was normalized to the size of the original FASTQ file, measuring throughput in megabytes per second.
<fig id="gks754-F1" position="float"><label>Figure 1.</label><caption><p>One lane of sequencing data from each of six publicly available data sets (<xref ref-type="table" rid="gks754-T2">Table 2</xref>) was compressed using a variety of methods (<xref ref-type="table" rid="gks754-T1">Table 1</xref>). The size of the compressed data is plotted in proportion to the size of uncompressed data. Note that all methods evaluated are entirely lossless with the exception of Cramtools, marked in this plot with an asterisk, which does not preserve read IDs, giving it some advantage in these comparisons. Reference-based compression methods, in which an external sequence database is used, were not applied to the metagenomic data set for lack of an obvious reference. These plots are marked ‘N/A’.</p></caption><graphic xlink:href="gks754f1"/></fig>
<table-wrap id="gks754-T3" position="float"><label>Table 3.</label><caption><p>Maximum memory usage was recorded for each program and data set</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="2" align="left" colspan="1">Method</th><th colspan="2" align="center" rowspan="1">Average memory usage (MB)<hr/></th></tr><tr><th align="left" rowspan="1" colspan="1">Compression</th><th align="left" rowspan="1" colspan="1">Decompression</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">gzip</td><td rowspan="1" colspan="1">0.8</td><td rowspan="1" colspan="1">0.7</td></tr><tr><td rowspan="1" colspan="1">bzip2</td><td rowspan="1" colspan="1">7.0</td><td rowspan="1" colspan="1">4.0</td></tr><tr><td rowspan="1" colspan="1">xz</td><td rowspan="1" colspan="1">96.2</td><td rowspan="1" colspan="1">9.0</td></tr><tr><td rowspan="1" colspan="1">sra</td><td rowspan="1" colspan="1">NA</td><td rowspan="1" colspan="1">46.9</td></tr><tr><td rowspan="1" colspan="1">dsrc</td><td rowspan="1" colspan="1">28.3</td><td rowspan="1" colspan="1">15.1</td></tr><tr><td rowspan="1" colspan="1">cramtools</td><td rowspan="1" colspan="1">6803.8</td><td rowspan="1" colspan="1">6749.3</td></tr><tr><td rowspan="1" colspan="1">quip</td><td rowspan="1" colspan="1">412.1</td><td rowspan="1" colspan="1">412.9</td></tr><tr><td rowspan="1" colspan="1">quip -a</td><td rowspan="1" colspan="1">823.0</td><td rowspan="1" colspan="1">794.1</td></tr><tr><td rowspan="1" colspan="1">quip -r</td><td rowspan="1" colspan="1">1710.0</td><td rowspan="1" colspan="1">1717.2</td></tr></tbody></table><table-wrap-foot><fn><p>We list the average across data sets of these measurements. For most of the programs, memory usage varied by &lt;10% across data sets and well summarized by the mean, with the exception of SRA. Decompression used &lt;60 MB except in the human exome sequencing data set, in which &gt;1.4 GB was used. We report the mean with this outlier removed.</p></fn></table-wrap-foot></table-wrap></p>
      <p>For the reference-based compressors, time spent aligning reads to the genome was not included, though it required up to several hours. Furthermore, while Quip is able to compress aligned reads in an uncompressed SAM file and then decompress back to SAM (or FASTQ), the input and output of Cramtools is necessarily a BAM file, and so we also use BAM files as input and output in our benchmarks of ‘quip-r’. This conflates measurements of compression and decompression time: since BAM files are compressed with zlib, compression times for the reference-based compressors include time needed to decompress the BAM file, and decompression times include re-compressing the output to BAM. Consequently, decompression speeds in particular for both Cramtools and reference-based Quip (‘quip-r’) appear significantly lower than they otherwise might.</p>
      <p>In the single-genome samples, we find that reference-based compression using Quip consistently results in the smallest file size (i.e. highest compression), yet even without a reference sequence, compression is quite high, even matching the reference-based approach used by Cramtools in two of the data sets. Assembly-based compression provides almost no advantage in the single-genome ChIP-Seq, Whole Genome and Exome data sets. Since we assembly only several million reads (2.5 million, by default), coverage is only enough to assemble representatives of certain families of repeats in these data sets.</p>
      <p>In the RNA-Seq data sets, more is assembled (∼35 and 70% of the reads are aligned to assembled contigs in the total RNA-Seq and mRNA-Seq data sets, respectively), but this only provides a small increase in the compression overall. Mostly probably, the aligned reads in these data sets are relatively low-entropy, composed largely of protein-coding sequence, and would be encoded only moderately less compactly with the Markov chain method.</p>
      <p>Nevertheless, assembly-based compression does provide a significant advantage in the metagenomic data set. Nearly 95% of reads align to assembled contigs, resulting in a large reduction in compressed file size. Metagenomic sequencing is performed on such a wide variety of samples, that these results can not be easily generalized to all metagenomic data sets. Since success in assembly relies on high coverage, a significant role is played by species diversity, which can vary widely. Yet these results do show that assembly-based compression is beneficial in certain cases. Though it comes at some cost, we are able to perform assembly with exceedingly high efficiently: memory usage is increased only by 400 MB and compression time is faster than all but DSRC and assembly-free Quip even while assembling 2.5 million reads and aligning millions more reads to the assembled contigs.</p>
      <p>With all invocations of Quip, the size of the resulting file is dominated, sometimes overwhelmingly, by quality scores (<xref ref-type="fig" rid="gks754-F2">Figure 2</xref>). There is not a direct way to measure this using the other methods evaluated, but this result suggests that increased compression of nucleotide sequences will result in diminishing returns.
<fig id="gks754-F2" position="float"><label>Figure 2.</label><caption><p>After compressing with Quip using the base algorithm (labeled ‘quip’), assembly-based compression (‘quip -a’) and reference-based compression (‘quip -r’), we measure the size of read identifiers, nucleotide sequences and quality scores in proportion to the total compressed file size. Reference-based compression (‘quip -r’) was not applied to the metagenomic data.</p></caption><graphic xlink:href="gks754f2"/></fig>
<fig id="gks754-F3" position="float"><label>Figure 3.</label><caption><p>The wall clock run-time of each evaluation was recorded using the Unix time command. Run-time is normalized by the size of the original FASTQ file to obtain a measure of compression and decompression throughput, plotted here in megabytes per second. Compression speed is plotted to the left of the zero axis, and decompression speed to the right. There is a not a convenient means of converting from FASTQ to SRA, so compression time is not measured for SRA. Additionally, reference-based methods are not applied to the metagenomic data. In the case of reference-based compression implemented in ‘cramtools’ and ‘quip -r’, input and output is in the BAM format, so the speeds plotted here include time needed to decompress and compress the BAM input and output, respectively.</p></caption><graphic xlink:href="gks754f3"/></fig></p>
    </sec>
    <sec>
      <title>Characteristics of the dlCBF</title>
      <p>Though our primary goal is efficient compression of sequencing data, the assembly algorithm we developed to achieve this is of independent interest. Only very recently has the idea of using probabilistic data structures in assembly been breached, and to our knowledge, we are the first to build a functioning assembler using any version of the counting Bloom filter. Data structures based on the Bloom filter make a trade-off between space and the probability of inserted elements colliding. Tables can be made arbitrarily small at the cost of increasing the number of collisions. To elucidate this trade-off, we performed a simple simulation comparing the dlCBF to a hash table.</p>
      <p>Comparisons of data structures are notoriously sensitive to the specifics of the implementation. To perform a meaningful benchmark, we compared our dlCBF implementation with the sparsehash library (<ext-link ext-link-type="uri" xlink:href="http://code.google.com/p/sparsehash/">http://code.google.com/p/sparsehash/</ext-link>), an open-source hash table implementation with the expressed goal of maximizing space efficiency. Among many other uses, it is the core data structure in the ABySS (<xref ref-type="bibr" rid="gks754-B18">18</xref>) and PASHA (<xref ref-type="bibr" rid="gks754-B29">29</xref>) assemblers.</p>
      <p>We randomly generated 10 million unique, uniformly distributed 25-mers and inserted them into a hash table, allocated in advance to be of minimal size while avoiding resizing and rehashing. We repeated this with dlCBF tables of increasing sizes. Upon insertion, a collision occurs when the hash functions computed on the inserted <italic>k</italic>-mer collide with a previously inserted <italic>k</italic>-mer. An insertion may also fail when a fixed size table is filled to capacity and no empty cells are available. For simplicity, we count these occurrences also as collisions. Wall clock run-time and maximum memory usage were both recorded using the Unix time command.</p>
      <p>We find that with only 20% of the space of the hash table, the dlCBF accrues a collision rate of less than 0.001 (<xref ref-type="fig" rid="gks754-F4">Figure 4</xref>). While the hash table performed the 10 million insertions in 7.34 s, it required only 4.48 s on average for the dlCBF to do the same, with both simulations run on a 2.8 Ghz Intel Xeon processor. Table size did not greatly affect the run time of the dlCBF. The assembler implemented in Quip uses a fixed table size, conservatively set to allow for 100 million unique <italic>k</italic>-mers with a collision rate of ∼0.08% in simulations.
<fig id="gks754-F4" position="float"><label>Figure 4.</label><caption><p>The trade-off between memory usage and false positive rate in the dlCBF is evaluated by inserting 10 million unique 25-mers into tables of increasing size. Memory usage is reported as the proportion of the memory used by a memory efficient hash table to do the same.</p></caption><graphic xlink:href="gks754f4"/></fig></p>
      <p>Though the authors of sparsehash claim only a 4-bit overhead for each entry, and have gone to considerably effort to achieve such efficiency, it still must store the <italic>k</italic>-mer itself, encoded in 64 bits. The dlCBF avoids this, storing instead a 14-bit ‘fingerprint’, or hash of a <italic>k</italic>-mer, resulting in the large savings we observe. Of course, a 25-mer cannot be uniquely identified with 14 bits. False positives are thus introduced, yet they are kept at a very low rate by the d-left hashing scheme. Multiple hash functions are used under this scheme, so that multiple hash function must collide to result in a collision, an infrequent event if reasonably high-quality hash functions are chosen.</p>
      <p>A previous analysis of the dlCBF by Zhang <italic>et al.</italic> (<xref ref-type="bibr" rid="gks754-B30">30</xref>) compared it with two other variations of the counting Bloom filter and concluded that ‘the dlCBF outperforms the others remarkably, in terms of both space efficiency and accuracy.’ Overall, this data structure appears particularly adept for high efficiency <italic>de novo</italic> assembly.</p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="SEC4">
    <title>DISCUSSION</title>
    <p>Compared with the only other published and freely-available reference-based compressor, Cramtools, we see a significant reduction in compressed file size, despite read identifiers being discarded by Cramtools and retained by Quip. This is combined with dramatically reduced memory usage, comparable run-time (slightly faster compression paired with varying relative decompression speeds), and increased flexibility (e.g. Quip is able to store multiple alignments of the same read and does not require that the BAM file be sorted or indexed). Conversely, Cramtools implements some potentially very useful lossy methods not provided by Quip. For example, a number of options are available for selectively discarding quality scores that are deemed unnecessary, which can significantly reduce compressed file sizes.</p>
    <p>We find that assembly-based compression offers only a small advantage in many data sets. Since we assemble a relatively small subset of the data, coverage is too low when sequencing a large portion of a eukaryotic genome. In principle, the assembler used could be scaled to handle exponentially more reads, but at the cost of being increasingly computationally intensive. In such cases, the reference-based approach may be more appropriate. Yet, in the metagenomic data set we evaluate, where there is no obvious reference sequence, nucleotide sequences are reduced in size by over 40% (<xref ref-type="fig" rid="gks754-F2">Figure 2</xref>). While limited in scope, for certain projects assembly-based compression can prove to be invaluable, and the algorithm devised here makes it a tractable option.</p>
    <p>The Lempel-Ziv algorithm, particularly as implemented in gzip/libz has become a reasonable default choice for compression. The zlib library has matured and stabilized over the course of two decades and is widely available. The BAM and Goby formats both use zlib for compression, and compressing FASTQ files with gzip is still common practice. Despite its ubiquity, our benchmarks show that it is remarkably poorly suited to NGS data. Both compression ratio and compression time were inferior to the other programs evaluated. For most purposes, the gains in decompression time do not make up for its shortcomings. With the more sophisticated variation implemented in xz, compression is improved but at the cost of tremendously slow compression.</p>
    <p>Our use of high-order Markov chain models and <italic>de novo</italic> assembly results in a program that uses significantly more memory than the others tested, with the exception of Cramtools. Though limiting the memory used by a general purpose compression program enables it to be used on a wider variety of systems, this is less important in this domain-specific application. Common analysis of NGS data, whether it be alignment, assembly, isoform quantification, peak calling or SNP calling, all require significant computational resources. Targeting low-memory systems would not be of particular benefit: NGS precludes previous-generation hardware.</p>
    <p>Though memory consumption is not a top priority, run time is important. Newer instruments like the HiSeq 2000 produce far more data per lane than previously possible. And, as the cost of sequencing continues to decrease, experiments will involve more conditions, replicates and timepoints. Quip is able to compress NGS data at three times the speed of gzip, while performing <italic>de novo</italic> assembly of millions of reads, and up to five times as fast without the assembly step. Only DSRC is faster, but with consistently lower compression. In addition, our reference-based compression algorithm matches the speed of Cramtools but with substantially better lossless compression.</p>
    <p>As illustrated in <xref ref-type="fig" rid="gks754-F2">Figure 2</xref>, the size of compressed NGS data is dominated by quality scores. More sophisticated compression of nucleotide sequences may be possible but will result in only minor reductions to the overall file size. The largest benefit would be seen by reducing quality scores. While it is easy to reduce the size of quality data by coarse binning or other lossy methods, it is very hard to determine the effect such transformations will have on downstream analysis. Future work should concentrate on studying lossy quality score compression, strictly guided by minimizing loss of accuracy in alignment, SNP calling and other applications. Quality scores are encoded in Quip using an algorithm that is suitably general so that lossy transformations (e.g. binning) can be automatically exploited, and can be treated as an optional preprocessing step.</p>
    <p>Other aspects of the algorithm presented here can be improved, and will be with future versions of the software. A large body of work exists exploring heuristics to improve the the quality of <italic>de novo</italic> assembly, however the algorithm in Quip uses a very simple greedy approach. Assembly could likely be improved without greatly reducing efficiency by exploring more sophisticated methods. We currently perform no special handling of paired-end reads, so that mates are compressed independently of each other. In principle, some gains to compression could be made by exploiting pair information. We also intend to implement parallel compression and decompression. This is non-trivial, but quite possible and worthwhile given the abundance of data and ubiquity of multi-core processors.</p>
    <p>Combining reference-based and assembly-based techniques, with carefully tuned statistical compression, the algorithm presented in Quip probes the limit to which NGS data can be compressed losslessly, yet remains efficient enough be a practical tool when coping with the deluge of data that biology research is now presented with.</p>
  </sec>
  <sec>
    <title>FUNDING</title>
    <p>Funding for open access charge: Federal funds from the <funding-source>National Institute of Allergy</funding-source> and <funding-source>Infectious Diseases, National Institutes of Health, Department of Health and Human Services</funding-source>, under Contract [No. <award-id>HHSN272200800060C</award-id>]; <funding-source>Public Health Service</funding-source> [<award-id>P51RR000166</award-id>]; <funding-source>National Institutes of Health</funding-source>, in whole or in part.</p>
    <p><italic>Conflict of interest statement</italic>. None declared.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We are grateful to James Bonfield, Matt Mahoney, Seth Hillbrand and other participants in the Pistoia Alliance Sequence Squeeze competition, whose work inspired many improvements to our own. While preparing the manuscript, Richard Green provided valuable feedback and suggestions.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="gks754-B1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cock</surname>
            <given-names>PJA</given-names>
          </name>
          <name>
            <surname>Fields</surname>
            <given-names>CJ</given-names>
          </name>
          <name>
            <surname>Goto</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Heuer</surname>
            <given-names>ML</given-names>
          </name>
          <name>
            <surname>Rice</surname>
            <given-names>PM</given-names>
          </name>
        </person-group>
        <article-title>The Sanger FASTQ file format for sequences with quality scores, and the Solexa/Illumina FASTQ variants</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>1767</fpage>
        <lpage>71</lpage>
        <pub-id pub-id-type="pmid">20015970</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Handsaker</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wysoker</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fennell</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Ruan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Homer</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Marth</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Abecasis</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>The sequence alignment/map format and SAMtools</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>2078</fpage>
        <lpage>2079</lpage>
        <pub-id pub-id-type="pmid">19505943</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tembe</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Lowey</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Suh</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>G-SQZ: compact encoding of genomic sequence and quality data</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2192</fpage>
        <lpage>2194</lpage>
        <pub-id pub-id-type="pmid">20605925</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Grabowski</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Compression of DNA sequence reads in FASTQ format</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>860</fpage>
        <lpage>862</lpage>
        <pub-id pub-id-type="pmid">21252073</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kozanitis</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Saunders</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Kruglyak</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Bafna</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Varghese</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Compressing genomic sequence fragments using SlimGene</article-title>
        <source>J. Comput. Biol.</source>
        <year>2011</year>
        <volume>18</volume>
        <fpage>401</fpage>
        <lpage>413</lpage>
        <pub-id pub-id-type="pmid">21385043</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fritz</surname>
            <given-names>MH-Y</given-names>
          </name>
          <name>
            <surname>Leinonen</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Cochrane</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Birney</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Efficient storage of high throughput DNA sequencing data using reference-based compression</article-title>
        <source>Genome Res.</source>
        <year>2011</year>
        <volume>21</volume>
        <fpage>734</fpage>
        <lpage>740</lpage>
        <pub-id pub-id-type="pmid">21245279</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Christley</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Lu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Xie</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Human genomes as email attachments</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>274</fpage>
        <lpage>275</lpage>
        <pub-id pub-id-type="pmid">18996942</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Anh</surname>
            <given-names>VN</given-names>
          </name>
          <name>
            <surname>Asai</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Transformations for the compression of FASTQ quality scores of next generation sequencing data</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>28</volume>
        <fpage>628</fpage>
        <lpage>635</lpage>
        <pub-id pub-id-type="pmid">22171329</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B9">
      <label>9</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Said</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Introduction to arithmetic coding - theory and practice</article-title>
        <source>Hewlett-Packard Laboratories Report, HPL-2004-76</source>
        <year>2004</year>
        <publisher-loc>Palo Alto, CA, USA</publisher-loc>
      </element-citation>
    </ref>
    <ref id="gks754-B10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pevzner</surname>
            <given-names>PA</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>An Eulerian path approach to DNA fragment assembly</article-title>
        <source>Proc. Natl Acad. Sci. USA</source>
        <year>2001</year>
        <volume>98</volume>
        <fpage>9748</fpage>
        <lpage>9753</lpage>
        <pub-id pub-id-type="pmid">11504945</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bloom</surname>
            <given-names>BH</given-names>
          </name>
        </person-group>
        <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>
        <source>Comm. ACM</source>
        <year>1970</year>
        <volume>13</volume>
        <fpage>422</fpage>
        <lpage>426</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fan</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Cao</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Almeida</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Broder</surname>
            <given-names>AZ</given-names>
          </name>
        </person-group>
        <article-title>Summary cache: a scalable wide-area Web cache sharing protocol</article-title>
        <source>IEEE/ACM Trans. Netw.</source>
        <year>2000</year>
        <volume>8</volume>
        <fpage>281</fpage>
        <lpage>293</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cormode</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>An improved data stream summary: the count-min sketch and its applications</article-title>
        <source>J. Algor.</source>
        <year>2005</year>
        <volume>55</volume>
        <fpage>58</fpage>
        <lpage>75</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B14">
      <label>14</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bonomi</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Mitzenmacher</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Panigrahy</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>An improved construction for counting Bloom filters</article-title>
        <source>14th Annual European Symposium on Algorithms, Vol. 4168. LNCS</source>
        <year>2006</year>
        <publisher-loc>Berlin/Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
        <fpage>684</fpage>
        <lpage>695</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Conway</surname>
            <given-names>TC</given-names>
          </name>
          <name>
            <surname>Bromage</surname>
            <given-names>AJ</given-names>
          </name>
        </person-group>
        <article-title>Succinct data structures for assembling large genomes</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>479</fpage>
        <lpage>486</lpage>
        <pub-id pub-id-type="pmid">21245053</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Durbin</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Efficient de novo assembly of large genomes using compressed data structures</article-title>
        <source>Genome Res.</source>
        <year>2012</year>
        <volume>22</volume>
        <fpage>549</fpage>
        <lpage>556</lpage>
        <pub-id pub-id-type="pmid">22156294</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B17">
      <label>17</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Ferragina</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Manzini</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Opportunistic data structures with applications</article-title>
        <source>In: Proceedings of the 41st Annual Symposium on Foundations of Computer Science</source>
        <year>2000</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>390</fpage>
        <lpage>398</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Simpson</surname>
            <given-names>JT</given-names>
          </name>
          <name>
            <surname>Wong</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Jackman</surname>
            <given-names>SD</given-names>
          </name>
          <name>
            <surname>Schein</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Birol</surname>
            <given-names>I</given-names>
          </name>
        </person-group>
        <article-title>ABySS: a parallel assembler for short read sequence data</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>1117</fpage>
        <lpage>1123</lpage>
        <pub-id pub-id-type="pmid">19251739</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B19">
      <label>19</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pritchard</surname>
            <given-names>JK</given-names>
          </name>
        </person-group>
        <article-title>Efficient counting of k-mers in DNA sequences using a Bloom Filter</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>333</fpage>
        <pub-id pub-id-type="pmid">21831268</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pell</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Hintze</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Canino-Koning</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Howe</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Tiedje</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Brown</surname>
            <given-names>CT</given-names>
          </name>
        </person-group>
        <article-title>Scaling metagenome sequence assembly with probabilistic de Bruijn graphs</article-title>
        <year>2011</year>
        <comment><italic>Arxiv preprint arXiv</italic>, <bold>I</bold>, 1–11</comment>
      </element-citation>
    </ref>
    <ref id="gks754-B21">
      <label>21</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bhola</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Bopardikar</surname>
            <given-names>AS</given-names>
          </name>
          <name>
            <surname>Narayanan</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ahn</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>No-reference compression of genomic data stored in FASTQ format</article-title>
        <source>2011 IEEE International Conference on Bioinformatics and Biomedicine</source>
        <year>2011</year>
        <publisher-loc>Washington, DC</publisher-loc>
        <publisher-name>IEEE Computer Society</publisher-name>
        <fpage>147</fpage>
        <lpage>150</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cox</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>MJ</given-names>
          </name>
          <name>
            <surname>Jakobi</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Rosone</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Large-scale compression of genomic sequence databases with the Burrows-Wheeler transform</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>1415</fpage>
        <lpage>1419</lpage>
        <pub-id pub-id-type="pmid">22556365</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leinonen</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Sugawara</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Shumway</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The sequence read archive</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2011</year>
        <volume>39</volume>
        <fpage>D19</fpage>
        <lpage>D21</lpage>
        <pub-id pub-id-type="pmid">21062823</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B24">
      <label>24</label>
      <element-citation publication-type="other">
        <comment>The 1000 Genomes Consortium. (2010) A map of human genome variation from population-scale sequencing. <italic>Nature</italic><bold>467</bold>, 1061–1073</comment>
      </element-citation>
    </ref>
    <ref id="gks754-B25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Asmann</surname>
            <given-names>YW</given-names>
          </name>
          <name>
            <surname>Necela</surname>
            <given-names>BM</given-names>
          </name>
          <name>
            <surname>Kalari</surname>
            <given-names>KR</given-names>
          </name>
          <name>
            <surname>Hossain</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Baker</surname>
            <given-names>TR</given-names>
          </name>
          <name>
            <surname>Carr</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Getz</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Hostetter</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>X</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Detection of redundant fusion transcripts as biomarkers or disease-specific therapeutic targets in breast cancer</article-title>
        <source>Cancer Res.</source>
        <year>2012</year>
        <volume>72</volume>
        <fpage>1921</fpage>
        <lpage>1928</lpage>
        <pub-id pub-id-type="pmid">22496456</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Little</surname>
            <given-names>GH</given-names>
          </name>
          <name>
            <surname>Noushmehr</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Baniwal</surname>
            <given-names>SK</given-names>
          </name>
          <name>
            <surname>Berman</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Coetzee</surname>
            <given-names>GA</given-names>
          </name>
          <name>
            <surname>Frenkel</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Genome-wide Runx2 occupancy in prostate cancer cells suggests a role in regulating secretion</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2011</year>
        <fpage>1</fpage>
        <lpage>10</lpage>
      </element-citation>
    </ref>
    <ref id="gks754-B27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Denef</surname>
            <given-names>VJ</given-names>
          </name>
          <name>
            <surname>Mueller</surname>
            <given-names>RS</given-names>
          </name>
          <name>
            <surname>Banfield</surname>
            <given-names>JF</given-names>
          </name>
        </person-group>
        <article-title>AMD biofilms: using model communities to study microbial evolution and ecological complexity in nature</article-title>
        <source>ISME J.</source>
        <year>2010</year>
        <volume>4</volume>
        <fpage>599</fpage>
        <lpage>610</lpage>
        <pub-id pub-id-type="pmid">20164865</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Nacu</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast and SNP-tolerant detection of complex variants and splicing in short reads</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>873</fpage>
        <lpage>881</lpage>
        <pub-id pub-id-type="pmid">20147302</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B29">
      <label>29</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Maskell</surname>
            <given-names>DL</given-names>
          </name>
        </person-group>
        <article-title>Parallelized short read assembly of large genomes using de Bruijn graphs</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>354</fpage>
        <pub-id pub-id-type="pmid">21867511</pub-id>
      </element-citation>
    </ref>
    <ref id="gks754-B30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Lan</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Performance evaluation and comparison of three counting Bloom filter schemes</article-title>
        <source>J. Electrons.</source>
        <year>2009</year>
        <volume>26</volume>
        <fpage>332</fpage>
        <lpage>340</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
