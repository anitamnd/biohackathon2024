<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">9822538</article-id>
    <article-id pub-id-type="pmid">36548365</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btac824</article-id>
    <article-id pub-id-type="publisher-id">btac824</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>NanoSNP: a progressive and haplotype-aware SNP caller on low-coverage nanopore sequencing data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Huang</surname>
          <given-names>Neng</given-names>
        </name>
        <aff><institution>School of Computer Science and Engineering, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
        <aff><institution>Hunan Provincial Key Lab on Bioinformatics, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xu</surname>
          <given-names>Minghua</given-names>
        </name>
        <aff><institution>School of Computer Science and Engineering, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
        <aff><institution>Hunan Provincial Key Lab on Bioinformatics, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Nie</surname>
          <given-names>Fan</given-names>
        </name>
        <aff><institution>School of Computer Science and Engineering, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
        <aff><institution>Hunan Provincial Key Lab on Bioinformatics, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ni</surname>
          <given-names>Peng</given-names>
        </name>
        <aff><institution>School of Computer Science and Engineering, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
        <aff><institution>Hunan Provincial Key Lab on Bioinformatics, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xiao</surname>
          <given-names>Chuan-Le</given-names>
        </name>
        <aff><institution>State Key Laboratory of Ophthalmology, Zhongshan Ophthalmic Center, Sun Yat-sen University</institution>, Guangzhou 510060, <country country="CN">China</country></aff>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-4813-2403</contrib-id>
        <name>
          <surname>Luo</surname>
          <given-names>Feng</given-names>
        </name>
        <aff><institution>School of Computing, Clemson University</institution>, Clemson, SC 29634, <country country="US">USA</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0003-1516-0480</contrib-id>
        <name>
          <surname>Wang</surname>
          <given-names>Jianxin</given-names>
        </name>
        <aff><institution>School of Computer Science and Engineering, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
        <aff><institution>Hunan Provincial Key Lab on Bioinformatics, Central South University</institution>, Changsha 410083, <country country="CN">China</country></aff>
        <xref rid="btac824-cor1" ref-type="corresp"/>
        <!--jxwang@mail.csu.edu.cn-->
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Birol</surname>
          <given-names>Inanc</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btac824-cor1">To whom correspondence should be addressed. <email>jxwang@mail.csu.edu.cn</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2022-12-22">
      <day>22</day>
      <month>12</month>
      <year>2022</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>22</day>
      <month>12</month>
      <year>2022</year>
    </pub-date>
    <volume>39</volume>
    <issue>1</issue>
    <elocation-id>btac824</elocation-id>
    <history>
      <date date-type="received">
        <day>13</day>
        <month>6</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>16</day>
        <month>11</month>
        <year>2022</year>
      </date>
      <date date-type="editorial-decision">
        <day>15</day>
        <month>12</month>
        <year>2022</year>
      </date>
      <date date-type="accepted">
        <day>21</day>
        <month>12</month>
        <year>2022</year>
      </date>
      <date date-type="corrected-typeset">
        <day>03</day>
        <month>1</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2022. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2022</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btac824.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Oxford Nanopore sequencing has great potential and advantages in population-scale studies. Due to the cost of sequencing, the depth of whole-genome sequencing for per individual sample must be small. However, the existing single nucleotide polymorphism (SNP) callers are aimed at high-coverage Nanopore sequencing reads. Detecting the SNP variants on low-coverage Nanopore sequencing data is still a challenging problem.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We developed a novel deep learning-based SNP calling method, NanoSNP, to identify the SNP sites (excluding short indels) based on low-coverage Nanopore sequencing reads. In this method, we design a multi-step, multi-scale and haplotype-aware SNP detection pipeline. First, the pileup model in NanoSNP utilizes the naive pileup feature to predict a subset of SNP sites with a Bi-long short-term memory (LSTM) network. These SNP sites are phased and used to divide the low-coverage Nanopore reads into different haplotypes. Finally, the long-range haplotype feature and short-range pileup feature are extracted from each haplotype. The haplotype model combines two features and predicts the genotype for the candidate site using a Bi-LSTM network. To evaluate the performance of NanoSNP, we compared NanoSNP with Clair, Clair3, Pepper-DeepVariant and NanoCaller on the low-coverage (∼16×) Nanopore sequencing reads. We also performed cross-genome testing on six human genomes HG002–HG007, respectively. Comprehensive experiments demonstrate that NanoSNP outperforms Clair, Pepper-DeepVariant and NanoCaller in identifying SNPs on low-coverage Nanopore sequencing data, including the difficult-to-map regions and major histocompatibility complex regions in the human genome. NanoSNP is comparable to Clair3 when the coverage exceeds 16×.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><ext-link xlink:href="https://github.com/huangnengCSU/NanoSNP.git" ext-link-type="uri">https://github.com/huangnengCSU/NanoSNP.git</ext-link>.</p>
      </sec>
      <sec id="s5">
        <title>Supplementary information</title>
        <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Single nucleotide polymorphisms, commonly referred to as SNPs, are human’s most common genetic variation. SNPs are widespread in a person’s DNA, with an average of one SNP occurring in every 1000 nucleotides. Currently, more than 100 million human SNPs have been identified worldwide (<xref rid="btac824-B1" ref-type="bibr">1000 Genomes Project Consortium <italic toggle="yes">et al.</italic>, 2015</xref>). SNPs may help predict an individual’s response to certain drugs, susceptibility to environmental factors and risk of developing specific diseases (<xref rid="btac824-B20" ref-type="bibr">Shastry, 2007</xref>). SNPs can also track the inheritance of disease genes in families (<xref rid="btac824-B18" ref-type="bibr">Reshef <italic toggle="yes">et al.</italic>, 2018</xref>). Identification of SNPs has important implications for clinical applications and genetic studies.</p>
    <p>Next-generation sequencing (NGS) has the advantages of low cost and high per-base accuracy. SNP identification on Illumina short-read sequencing data has been well practiced. GATK (<xref rid="btac824-B4" ref-type="bibr">DePristo <italic toggle="yes">et al.</italic>, 2011</xref>) uses logistic regression models, hidden Markov models (HMM) and Naive Bayes models to identify SNP sites, and then uses Gaussian mixture models to remove false-positive sites. DeepVariant (<xref rid="btac824-B16" ref-type="bibr">Poplin <italic toggle="yes">et al.</italic>, 2018</xref>) is a deep learning-based SNP caller that calls genetic variation from aligned Illumina sequencing reads by learning statistical relationships between images of reads pileups around putative variant and actual variant calls. However, due to the fundamental limitations of short reads, the sequencing reads frequently fail to align unambiguously in the repetitive regions, resulting in erroneous SNP calls.</p>
    <p>Third-generation sequencing technologies (TGS), including PacBio Biosciences (PacBio) and Oxford Nanopore Technologies (ONT), have made significant breakthroughs in a series of genomics studies (<xref rid="btac824-B7" ref-type="bibr">Jain <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btac824-B3" ref-type="bibr">Chen <italic toggle="yes">et al.</italic>, 2021</xref>; <xref rid="btac824-B12" ref-type="bibr">Ni <italic toggle="yes">et al.</italic>, 2021</xref>). Compared with the NGS technologies, the TGS technologies have the advantages of long read length, no PCR amplification and no GC bias. When long reads span repetitive elements, reads can be unambiguously aligned to unique positions in the genome. The Telomere-to-Telomere (T2T) Consortium leverages the additional capabilities of long reads and short reads to finish the first truly complete 3.055 billion base pairs of sequence in the human genome, representing the largest improvement in the human reference genome since its initial release (<xref rid="btac824-B13" ref-type="bibr">Nurk <italic toggle="yes">et al.</italic>, 2021</xref>).</p>
    <p>PacBio offers a sequencing mode called circular consensus sequencing. The resulting HiFi reads have comparable per-base accuracy (99.8%) to Illumina and read lengths of 15–20 kb (<xref rid="btac824-B22" ref-type="bibr">Wenger <italic toggle="yes">et al.</italic>, 2019</xref>). Due to high per-base accuracy, the SNP identification with DeepVariant on 35× HiFi reads can reach an F1 score of 99.9% (<xref rid="btac824-B16" ref-type="bibr">Poplin <italic toggle="yes">et al.</italic>, 2018</xref>). The main innovation of Nanopore sequencing is to measure the current changes as single-stranded DNA/RNA goes through a protein nanopore. The current signals are transformed into DNA or RNA sequences by basecalling tools. Nanopore sequencing provides the longest read length of at most 4 Mb (<xref rid="btac824-B15" ref-type="bibr">Payne <italic toggle="yes">et al.</italic>, 2019</xref>). However, the high median error rate of 6–15% for R9.4 Nanopore reads makes SNP identification challenging (<xref rid="btac824-B21" ref-type="bibr">Wang <italic toggle="yes">et al.</italic>, 2021</xref>).</p>
    <p>Recently, many SNP detection tools have been developed for Nanopore sequencing data, such as Clairvoyante (<xref rid="btac824-B9" ref-type="bibr">Luo <italic toggle="yes">et al.</italic>, 2018</xref>), Clair (<xref rid="btac824-B10" ref-type="bibr">Luo <italic toggle="yes">et al.</italic>, 2020</xref>), Clair3 (<xref rid="btac824-B24" ref-type="bibr">Zheng <italic toggle="yes">et al.</italic>, 2021</xref>), NanoCaller (<xref rid="btac824-B2" ref-type="bibr">Ahsan <italic toggle="yes">et al.</italic>, 2021</xref>) and Pepper-DeepVariant (<xref rid="btac824-B19" ref-type="bibr">Shafin <italic toggle="yes">et al.</italic>, 2021</xref>). Clairvoyante is a deep-learning approach to identify SNPs by using a multi-task convolution neural network. Clair is a neural network-based SNP detection tool consisting of two bidirectional long short-term memory layer (LSTM) layers and three feed-forward layers. Clair is the successor to Clairvoyante, and both use the pileup data from reads-to-reference alignment to predict the zygosity and the alternative allele of the candidate SNP site. On the Nanopore dataset with coverage 60×, the performance of SNP identification with Clair can reach an F1 score of 98.5% (<xref rid="btac824-B10" ref-type="bibr">Luo <italic toggle="yes">et al.</italic>, 2020</xref>). Clair3 (<xref rid="btac824-B24" ref-type="bibr">Zheng <italic toggle="yes">et al.</italic>, 2021</xref>) is the third generation of Clairvoyante and Clair. Clair3 predicts most variant candidates with pileup calling as Clair and applies full-alignment calling to handle complicated candidates. In full-alignment calling, Clair3 combines the reads alignment and phasing information at the candidate site to form an image of the candidate and uses a residual neural network (ResNet) to predict the genotype and zygosity. Clair3 has superior accuracy for SNP detection of low-coverage Nanopore sequencing reads. NanoCaller solely uses long-range haplotype information from reads alignment for SNP calling. Compared to local pileup information, haplotype structure can span hundreds or even thousands of bases away from the candidate site. In NanoCaller, the haplotype information is fed into a deep convolution neural network for predicting the zygosity and the alternate allele of the candidate site. On 50× Nanopore sequencing reads, the performance of SNP calling with NanoCaller can reach an F1 score of 98.6% (<xref rid="btac824-B2" ref-type="bibr">Ahsan <italic toggle="yes">et al.</italic>, 2021</xref>). Pepper-DeepVariant is a haplotype-aware pipeline for identifying SNPs against a reference genome with Nanopore sequencing reads. The pipeline employs several methods to generate highly accurate variant calls. PEPPER-SNP adopts a recurrent neural network to find candidate SNPs from pileup data of reads alignment. Then, Margin uses an HMM model to phase the alignment file according to the candidate SNPs. PEPPER-HP has a similar network structure as PEPPER-SNP but predicts the candidate SNP sites with the pileup data of phased alignment files. Finally, the candidate SNPs are verified by DeepVariant, which is a bigger neural network with more parameters. Combining PEPPER with DeepVariant allows a faster network to find the candidates and a larger network to achieve high accuracy. When the sequencing reads have at least 50× coverages, the performance of SNP calling with Pepper-DeepVariant can reach an F1 score of 99.6% (<xref rid="btac824-B19" ref-type="bibr">Shafin <italic toggle="yes">et al.</italic>, 2021</xref>).</p>
    <p>The aforementioned SNP callers designed for Nanopore sequencing reads have high accuracy, but there are still limitations. Currently, most SNP callers require high-coverage sequencing reads. The sequencing reads with low coverage will reduce the accuracy of SNP calling. Since the human genome has about 3 billion base pairs, the sequencing cost of high-coverage Nanopore sequencing cannot be ignored. The cheapest option for generating long reads is the ONT PromethION platform, which can generate 100–150 Gbp of data per flowcell. In a large population study with 2500 samples, assuming a diploid genome with a similar size to a haploid human genome (3.2 Gbp), it will cost approximately $1 375 000 to obtain the Nanopore dataset with 50× sequencing coverage. Therefore, it is very urgent to improve the accuracy of identifying SNPs on low-coverage sequencing reads. The difficulty of SNP identification for low-coverage Nanopore sequencing is that the error rate of Nanopore reads is high, and the coverage of reads is insufficient to determine whether the base difference between reads and reference is a sequencing error or an actual variation. For the lack of SNP information in low-coverage Nanopore reads, phasing can divide the sequencing reads into different haplotypes, which provides additional information. Phasing information can help to improve the accuracy of SNP detection. Likewise, family structure data can also provide additional information for SNP detection, which can help to increase the sensitivity of low-coverage SNP detection.</p>
    <p>This article presents a neural network-based SNP caller named NanoSNP for low-coverage Nanopore sequencing data. To overcome the lack of information on SNP detection with low-coverage Nanopore sequencing data, we successively apply two prediction models to identify SNPs from different perspectives. We divided the main process into the following three steps. We first identified a set of SNP sites with the pileup model based on the read pileups of aligned reads. Then the SNP sites are phased and used to divide the Nanopore sequencing reads into different haplotypes. Finally, the high-quality SNPs predicted in the pileup model and the reads of each haplotype are used to construct the haplotype features of candidate sites. We use the haplotype model to combine the long-range haplotype feature and short-range pileup feature from each haplotype and predict the genotype of each candidate SNP. We train NanoSNP on the dataset of HG001 as Clair and NanoCaller. On the six low-coverage (∼16×) Nanopore sequencing datasets of human genomes HG002-HG007, NanoSNP has the highest precision score and second highest recall and F1 score on each dataset compared to Clair, Clair3, Pepper-DeepVariant and NanoCaller. When evaluating the SNPs in the difficult-to-map regions, NanoSNP outperforms the compared Nanopore SNP callers on each genome.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 NanoSNP framework for low-coverage nanopore SNP calling</title>
      <p>The workflow of NanoSNP is shown in <xref rid="btac824-F1" ref-type="fig">Figure 1a</xref>. First, the Nanopore reads are aligned to the reference genome using Minimap2 (<xref rid="btac824-B8" ref-type="bibr">Li, 2018</xref>). The candidate site is determined by the coverage and the alternative allele frequency at a specific genomic position. Then, the pileup feature is extracted from the reads-to-reference alignment at each candidate site. NanoSNP uses a recurrent neural network-based (<xref rid="btac824-B5" ref-type="bibr">Hochreiter and Schmidhuber, 1997</xref>) pileup model for the first round of SNP detection. From the results of the pileup model, the low-quality predictions and the high-quality heterozygous SNP sites are selected. The low-quality predictions will enter the second round of SNP detection. The high-quality heterozygous SNP sites are phased by WhatsHap (<xref rid="btac824-B11" ref-type="bibr">Martin <italic toggle="yes">et al.</italic>, 2016</xref>). According to the phasing result, the reads alignment is divided into different haplotypes. On each haplotype, NanoSNP extracts the long-range haplotype feature and the short-range pileup feature of each candidate SNP site as shown in <xref rid="btac824-F1" ref-type="fig">Figure 1b</xref>. These two types of features are fed into the haplotype model of NanoSNP to perform the second round of SNP detection. The haplotype model consists of two bidirectional LSTM networks. Finally, the results of two rounds of SNP calling are merged.</p>
      <fig position="float" id="btac824-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>(<bold>a</bold>) The workflow of SNP caller NanoSNP. (<bold>b</bold>) The pileup information (upper) and the haplotype information (lower) of the alignment. (<bold>c</bold>) The network architecture of the pileup model in NanoSNP. (<bold>d</bold>) The network architecture of the haplotype model in NanoSNP</p>
        </caption>
        <graphic xlink:href="btac824f1" position="float"/>
      </fig>
      <p><bold>Search for candidate SNP.</bold> Pileup format is a text-based format for summarizing the base calls of aligned reads to a reference sequence. We use Samtools to generate the pileup data from reads-to-reference alignment. The candidate site is determined by the depth and alternative allele frequency at a specific genomic position. Given the pileup data and the reference base <italic toggle="yes">B<sub>r</sub></italic> at site <italic toggle="yes">b</italic>, the alternative allele frequency <italic toggle="yes">f<sub>b</sub></italic> is calculated as follows:
<disp-formula id="E1"><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mtext>num</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>base</mml:mtext><mml:mo> </mml:mo><mml:mi>B</mml:mi><mml:mo> </mml:mo><mml:mtext>at</mml:mtext><mml:mo> </mml:mo><mml:mtext>site</mml:mtext><mml:mo> </mml:mo><mml:mi>b</mml:mi><mml:mo>|</mml:mo><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mi>r</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mtext>depth</mml:mtext><mml:mo> </mml:mo><mml:mtext>at</mml:mtext><mml:mo> </mml:mo><mml:mtext>site</mml:mtext><mml:mo> </mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>If the depth is greater than <italic toggle="yes">d</italic> and the alternative allele frequency is greater than <italic toggle="yes">e</italic>, genomic position <italic toggle="yes">b</italic> is considered a candidate SNP site. We set the default thresholds of depth and allele frequency to 6 and 12%, respectively. Smaller values of these two thresholds will increase the accuracy of SNP calling but will also increase the number of candidate sites and thus increase computational resources.</p>
      <p><bold>Generation of pileup image in pileup model.</bold> For a given candidate site <italic toggle="yes">b</italic> and a window size <italic toggle="yes">w</italic>, we extract the read fragments aligned to the region <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> on the reference. We select the forward reads first and extract the pileup feature (<inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>C</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="italic">IMA</mml:mi><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">DMA</mml:mi><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) for each position <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Here, <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>}</mml:mo><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>I</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> are <italic toggle="yes">m</italic> forward reads. IMAX<sub><italic toggle="yes">p</italic></sub> is the maximum length of inserted fragments at position <italic toggle="yes">p</italic> and DMAX<sub><italic toggle="yes">p</italic></sub> is the maximum length of deleted fragments at position <italic toggle="yes">p</italic>. The processing of the reverse reads is similar to that of the forward reads. We construct two feature matrices from forward reads and reverse reads, respectively. Each feature matrix is in size of <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>8</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. The whole pileup image <italic toggle="yes">P<sub>b</sub></italic> of the candidate site <italic toggle="yes">b</italic> has the shape of <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>16</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> by concatenating the two feature matrices. Referring to other pileup-based SNP calling methods such as Clair, we set the default value of <italic toggle="yes">w</italic> to 16.</p>
      <p><bold>Pileup prediction model.</bold> Given the pileup image <italic toggle="yes">P<sub>b</sub></italic> of the candidate site <italic toggle="yes">b</italic>, NanoSNP has a two-tasks recurrent neural network to predict the zygosity and genotype. The number of zygosities is 3, including homozygous reference (0/0), homozygous variant (1/1) and heterozygous variant (0/1). The number of genotypes is 21, including ‘AA, AC, AG, AT, CC, CG, CT, GG, GT, TT, AI, AD, CI, CD, GI, GD, TI, TD, II, DD, ID’. The architecture of the neural network is shown in <xref rid="btac824-F1" ref-type="fig">Figure 1c</xref>. The neural network of the pileup model consists of two bidirectional LSTM layers followed by two fully connected layers. The hidden size of both bidirectional LSTM layers is 128, and the output size of the fully connected layer is 512. To predict the zygosity and genotype of the candidate SNP, we extract the middle time step in the sequence of tensor after the tanh activation. Then, the fully connected layer and the softmax activation are used to calculate two types of probabilities. Let <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the probability of the most likely class <italic toggle="yes">L</italic>1 in genotype prediction and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be the probability of the most likely class <italic toggle="yes">L</italic>2 in zygosity prediction. With the probabilities, we can calculate the quality scores of the genotype prediction and the zygosity prediction as <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mn>10</mml:mn><mml:mo>−</mml:mo><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mi>ln</mml:mi><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mi>ln</mml:mi><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>P</mml:mi></mml:mrow><mml:mi>P</mml:mi></mml:mfrac><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The final quality score is the smaller of the genotype score and the zygosity score. During training, we apply cross-entropy loss and label smoothing to calculate the losses of the two tasks, and the total loss is obtained by adding the two losses. The optimizer in the pileup model is Adam combined with the lookahead strategy (<xref rid="btac824-B23" ref-type="bibr">Wright and Demeure, 2021</xref>). The batch size equals 2000, the learning rate equals 0.0001 and the number of training epochs equals 200. The training of the pileup model takes around 80 h on a GPU device.</p>
      <p><bold>Haplotyping.</bold> Phasing for long-read sequencing improves SNP calling, structural variant calling and genome assembly (<xref rid="btac824-B14" ref-type="bibr">Patterson <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btac824-B6" ref-type="bibr">Huddleston <italic toggle="yes">et al.</italic>, 2017</xref>; <xref rid="btac824-B17" ref-type="bibr">Porubsky <italic toggle="yes">et al.</italic>, 2021</xref>). On the low-coverage sequencing reads, when the alternative allele frequency of the SNP and the sequencing error rate are close to each other, it is difficult to identify actual SNP by local pileup information. So, we try to phase the reads to distinguish sequencing errors and SNPs in different haplotypes. We have identified a subset of SNPs from the candidate sites with the pileup model of NanoSNP. Then, the high-quality heterozygous SNP sites are selected from the output of the pileup model and these heterozygous SNPs are phased by WhatsHap (<xref rid="btac824-B11" ref-type="bibr">Martin <italic toggle="yes">et al.</italic>, 2016</xref>). Afterward, we divide the alignment bam file into different haplotypes based on the phased SNPs with the command ‘WhatsHap haplotag’. Each phased bam stores the sequencing reads from the same haplotype.</p>
      <p><bold>Generation of haplotype image and pileup image in haplotype model.</bold> For a set of reads aligned to the reference, we represent the reads-to-reference alignment, the base quality of each read and the mapping quality of each read with the following matrices <italic toggle="yes">A</italic>, <italic toggle="yes">Q</italic> and <italic toggle="yes">M</italic>:
<disp-formula id="E2"><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E3"><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E4"><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mi>M</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>…</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo stretchy="true">]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Here, <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> are the aligned base, base quality and mapping quality of a given read at the reference position <italic toggle="yes">j</italic>. The number of aligned reads is <italic toggle="yes">m </italic>+<italic toggle="yes"> </italic>1 and the size of the region in the reference is <italic toggle="yes">n </italic>+<italic toggle="yes"> </italic>1.</p>
      <p>For a set of aligned reads, we designed three kinds of features, which are nucleotide distribution, base quality distribution and mapping quality distribution. The details of three kinds of features are described below.
</p>
      <list list-type="order">
        <list-item>
          <p>Nucleotide distribution: the number of different nucleotides <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and the frequency of different nucleotide <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> at the given reference position. For each nucleotide <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the computations of the features are as follows:
<disp-formula id="E5"><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>1</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="E6"><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>*</mml:mo><mml:msubsup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E7"><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        </list-item>
        <list-item>
          <p>Base quality distribution: the sum of base qualities of different nucleotides <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and the mean value of base qualities of different nucleotides <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> at the given reference position. For each nucleotide other than the deletion <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, we calculate the features as follows:
<disp-formula id="E8"><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>*</mml:mo><mml:msubsup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E9"><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        </list-item>
        <list-item>
          <p>Mapping quality distribution: the sum of mapping qualities of different nucleotides <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> and the mean value of mapping qualities of different nucleotides <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:math></inline-formula> at the given reference position. For each nucleotide <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, the features of the mapping qualities are computed as follows:
<disp-formula id="E10"><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>*</mml:mo><mml:msubsup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula><disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>B</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mi>B</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
        </list-item>
      </list>
      <p>Then, we concatenate the three aforementioned types of features into a flattened tensor <italic toggle="yes">T<sub>j</sub></italic> as a combined feature tensor at each position <italic toggle="yes">j</italic> of the reference as follows:
<disp-formula id="E12"><mml:math id="M12" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>=</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>+</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>+</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>+</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>+</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mo>+</mml:mo></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>A</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>G</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>The local pileup extracts the reads alignment information from the adjacent region around the candidate SNP site. The long range haplotype feature can take full advantage of the long read length of Nanopore reads to collect the alignment information in the region that is far away from the candidate SNP site. For a given candidate SNP site <italic toggle="yes">b</italic> and flanking size <italic toggle="yes">w</italic>, the combined feature <italic toggle="yes">T<sub>j</sub></italic> at each position in the region <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> forms the local pileup image <italic toggle="yes">P<sub>b</sub></italic> with the shape of <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>26</mml:mn></mml:mrow></mml:math></inline-formula> like:
<disp-formula id="E13"><mml:math id="M13" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mo>…</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mo>…</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:mi>w</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>In order to extract the long-range haplotype information, we select the subset of the high-quality heterozygous SNP sites around the candidate SNP site. Let <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be <italic toggle="yes">t</italic> high-quality heterozygous sites on the left side of the candidate SNP site <italic toggle="yes">b</italic> and <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> be <italic toggle="yes">t</italic> high-quality heterozygous sites on the right side of the candidate site. For a candidate SNP site <italic toggle="yes">b</italic>, the combined feature <italic toggle="yes">T<sub>j</sub></italic> at each position in the sites <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> forms the long-range haplotype image <italic toggle="yes">H<sub>b</sub></italic> with the shape of <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>26</mml:mn></mml:mrow></mml:math></inline-formula> like:
<disp-formula id="E14"><mml:math id="M14" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mo>…</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>l</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mi>b</mml:mi></mml:msub><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>;</mml:mo><mml:mo>…</mml:mo><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>In the haplotype model, to extract the SNP information from different haplotypes, we divide the original alignment into three parts according to the phasing result, which is the alignment of haplotype 1, the alignment of haplotype 2 and the unphased alignment. For each candidate SNP site <italic toggle="yes">b</italic>, we extract four pileup images (<inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mtext>ori</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mtext>hap</mml:mtext><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mtext>hap</mml:mtext><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mi mathvariant="italic">unp</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) and four haplotype images (<inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mtext>ori</mml:mtext></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mtext>hap</mml:mtext><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mtext>hap</mml:mtext><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>b</mml:mi><mml:mrow><mml:mi mathvariant="italic">unp</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>) from the original alignment and the three sub-alignments, respectively. Finally, the four pileup images are concatenated from the second dimension to form the complete pileup image with the size of <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>w</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>104</mml:mn></mml:mrow></mml:math></inline-formula>. The four haplotype images are processed similarly to obtain the complete haplotype image with the size of <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mn>104</mml:mn></mml:mrow></mml:math></inline-formula>. Here, the flanking size <italic toggle="yes">w</italic> of the pileup image has the same value as the flanking size in the pileup model which equals 16. The number of high quality heterozygous sites <italic toggle="yes">t</italic> on either side of a candidate site affects the number of reads which cover all the heterozygous sites simultaneously. When the number of heterozygous sites is big, the number of aligned reads will be insufficient. When the number of heterozygous sites is small, the haplotype feature cannot provide long range information. So we set the quality threshold of high quality heterozygous sites to 14 according to <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref> and the number of the selected heterozygous sites <italic toggle="yes">t</italic> of each side of the candidate is set to 5. In <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>, we evaluate the effect of the pileup image and the haplotype image in the haplotype model. Neither the pileup image nor the haplotype image alone can achieve the best performance. The model achieves the highest F1 score when using the pileup image and the haplotype image together.</p>
      <p><bold>Haplotype prediction model.</bold> In NanoSNP, the haplotype model consists of two modules, the pileup image processing module and the haplotype image processing module. The architecture of the haplotype model is shown in <xref rid="btac824-F1" ref-type="fig">Figure 1d</xref>. Both modules apply the same neural network architecture, which consists of two bidirectional LSTM layers followed by a fully connected layer. Since both the pileup image and the haplotype image are essentially the combination of alignment features at different positions of the reference, the bidirectional LSTM layers are used to capture the feature correlation before and after the candidate SNP site. Behind the pileup processing module and the haplotype processing module, there is a fully connected layer combining the outputs of the two modules. Finally, two fully connected layers take the combined outputs as the input and predict the genotype and zygosity of the candidate SNP site, respectively.</p>
      <p>The number of genotypes is 10, including ‘AA, AC, AG, AT, CC, CG, CT, GG, GT, TT’. The number of zygosities is 3, including homozygous reference, homozygous variant and heterozygous variant. During training, the parameters are optimized by Adam combined with the lookahead strategy (<xref rid="btac824-B23" ref-type="bibr">Wright and Demeure, 2021</xref>). Meanwhile, we employ label smoothing of value 0.1 to improve the robustness of the model. The initial learning rate is set to be 0.00001. The batch size equals 512 and the number of training epochs equals 30. The training of the haplotype model takes around 45 h with a GPU device. During inference, we select the genotype class and zygosity class with the highest probabilities as the output of the haplotype model. Based on the probabilities, the quality score of the prediction is calculated as <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mn>10</mml:mn><mml:mo>−</mml:mo><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mi>ln</mml:mi><mml:mn>10</mml:mn><mml:mo>×</mml:mo><mml:mi>ln</mml:mi><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>P</mml:mi></mml:mrow><mml:mi>P</mml:mi></mml:mfrac><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability of the most likely class <italic toggle="yes">L</italic>1 in genotype prediction and <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>z</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability of the most likely class <italic toggle="yes">L</italic>2 in zygosity prediction. The smaller of the genotype score and the zygosity score is used as the score of the prediction by the haplotype model.</p>
      <p><bold>Merging SNP calls from the haplotype model and the pileup model.</bold> The final SNP calls of NanoSNP are obtained by combining the predictions of the pileup model and that of the haplotype model. If the SNP site identified by the haplotype model has a quality score greater than a quality threshold <italic toggle="yes">δ</italic>, NanoSNP will add the SNP site to the final VCF file. On the contrary, if the quality score is less than <italic toggle="yes">δ</italic>, the confidence of the SNP call by the haplotype model is not high enough. Then NanoSNP checks the prediction of the pileup model at the same position. If the quality score is greater than <italic toggle="yes">δ</italic>, the SNP site identified by the pileup model will be added to the final VCF file. If the quality score is also less than <italic toggle="yes">δ</italic>, the SNP call is considered a false-positive prediction and will be discarded. By testing different values of <italic toggle="yes">δ</italic> in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>, we set the default quality threshold <italic toggle="yes">δ</italic> to 14. The haplotype information used in NanoSNP is not written to the output VCF, but the genotype and zygosity predicted by the network are written to the output VCF.</p>
      <p><bold>Algorithmic comparison of NanoSNP and Clair3.</bold> NanoSNP and Clair3 have similarities in the process of SNP identification. The SNP caller first uses the naive pileup feature to perform the first round of SNP detection. The detected SNPs are then used to generate the phasing information. Afterward, the SNP caller combines the phasing information with the alignment information for the second round of SNP detection. Finally, the results of two rounds of SNP calling are merged. Actually, NanoSNP and Clair3 have many differences in implementation details. In the pileup model, the architecture of NanoSNP’s recurrent network differs from that of Clair3’s recurrent neural network. In the haplotype model, the feature matrix of NanoSNP is completely different from the full-alignment image of Clair3. NanoSNP uses complex feature extraction strategies to obtain the distribution of different bases, the base quality distribution of different bases, and the mapping quality distribution of different bases at each position of the reference. The features at the position around the candidate site form the local pileup feature, and the features at the position of the high-quality heterozygous sites around the candidate site form the long-range haplotype feature. And NanoSNP extracts the features from both the alignment before WhatsHap phasing and the phased alignment. Clair3 directly uses the phased local sequence alignment around the candidate SNP site as an feature image. The neural networks of the second round of SNP calling in NanoSNP and Clair3 are quite different. The neural network of the haplotype model in NanoSNP is two individual Bi-LSTM networks followed by several fully connected layers. The neural network of full-alignment model in Clair3 is a residual neural network with three standard residual blocks.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Experiments and results</title>
    <sec>
      <title>3.1 Training and testing datasets</title>
      <p>We train NanoSNP on HG001 Nanopore sequencing data subsampled at different coverage values (25×, 50× and 75×). The training dataset is a mixture of the three datasets including the 25× HG001 dataset, 50× HG001 dataset and 75× HG001 dataset. The raw Nanopore reads are basecalled by Guppy v4.2.2. We divide the dataset into two parts, chromosomes 1–19 are used for training, and chromosomes 20–22 are used for validation. The six testing datasets are made from Nanopore sequencing reads of human genomes HG002–HG007. The details of each human dataset are given in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>. In all the experiments, the sequencing reads are aligned to GRCh38 with Minimap2 (<xref rid="btac824-B8" ref-type="bibr">Li, 2018</xref>). Each human sample uses the GIAB variants v3.3.2 (<xref rid="btac824-B25" ref-type="bibr">Zook <italic toggle="yes">et al.</italic>, 2019</xref>) as the benchmark datasets.</p>
    </sec>
    <sec>
      <title>3.2 SNP-calling performance on different coverages of low-coverage nanopore sequencing reads</title>
      <p>The datasets of two human genomes HG002 and HG003 are used to evaluate the performance of several SNP callers on low-coverage Nanopore sequencing data with different coverage values. We randomly sampled four subsets from each genome of HG002 and HG003, respectively. The coverages of the subsets are 10×, 13×, 16×, 19×, 22× and 25×. The five Nanopore SNP callers are Clair, Clair3, Pepper-DeepVariant, NanoCaller and NanoSNP. Clair, Clair3, NanoCaller and NanoSNP were all trained on the genome HG001. The Nanopore sequencing reads of HG001 were basecalled by Guppy v4.2.2. Pepper-DeepVariant was trained on HG002 Nanopore sequencing data, which was basecalled by Guppy v4.2.2. During inference, we obtained the alignment bam files by aligning the sequencing reads of HG002 and HG003 to the reference GRCh38, respectively. Then, each SNP caller took the bam file as input and detected the SNPs with the default parameters for Nanopore data. The SNP calls of each method were evaluated with the haplotype comparison tool hay.py (<ext-link xlink:href="https://github.com/Illumina/hap.py" ext-link-type="uri">https://github.com/Illumina/hap.py</ext-link>) against the GIAB truth variants dataset (v3.3.2).</p>
      <p>The SNP calls of several SNP callers on HG002 Nanopore datasets with different coverages (10×, 13×, 16×, 19×, 22× and 25×) are shown in <xref rid="btac824-F2" ref-type="fig">Figure 2</xref>. NanoSNP and Clair3 outperform Clair, Pepper-DeepVariant and NanoCaller when the reads coverage is low. In each dataset, NanoSNP has the highest precision and second highest recall and F1 score. Clair3 has the highest recall and F1 score. As the sequencing coverage increases from 10× to 25×, the precision of NanoSNP increases from 94.0 to 98.8%, the recall increases from 80.6 to 98.9%, and the F1 score increases from 86.8 to 98.9%. When the coverage of the dataset is greater than 16×, the F1 score of NanoSNP exceeds 95% and the performance of NanoSNP is close to that of Clair3. When sequencing coverage is equal to 25×, the F1 score of Pepper-DeepVariant is close to that of NanoSNP and Clair3. Since the F1 score of each SNP caller on the dataset at 10× coverage is low, the SNP calls cannot be used in downstream analysis. Hence, we use the Nanopore datasets at 16× coverage to evaluate different SNP callers. TP is the number of SNPs correctly detected by an SNP caller, FP is the number of predicted SNPs which are not in benchmark and FN is the number of SNPs in benchmark which are not detected by an SNP caller. We cluster the FP/FN calls preduced by NanoSNP on the dataset of 16× HG002 reads (<xref rid="sup1" ref-type="supplementary-material">Supplementary Text S2</xref>). The FP calls are clustered in the large duplications of the genome and the FN calls are rarely clustered. The main reason for the FN calls is low read coverage. The coverage distributions at TP/FP/FN sites predicted by different SNP callers are shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Text S3</xref>. The coverage of FN sites in NanoSNP is lower than that of TP and FP sites, and the coverage of TP sites is slightly higher than that of FP sites. In <xref rid="sup1" ref-type="supplementary-material">Supplementary Text S4</xref>, we show the reads alignment of the SNP site that is correctly identified by NanoSNP but incorrectly identified by all other tools.</p>
      <fig position="float" id="btac824-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>Precision, Recall, and F1 score of the SNP calls on HG002 low-coverage Nanopore datasets with different coverages. The SNP callers are Clair, Clair3, Pepper-DeepVariant, NanoCaller and NanoSNP</p>
        </caption>
        <graphic xlink:href="btac824f2" position="float"/>
      </fig>
      <p>For the HG002 genome, we evaluate the accuracy of different SNP callers in non-diploid regions. We select the regions containing heterozygous deletions and duplications as non-diploid regions from the public structure variation dataset for HG002. We then evaluate the SNP sites falling in the non-diploid regions. From <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>, NanoSNP and Clair3 have higher accuracy than Clair, Pepper-DeepVariant and NanoCaller. The performance of NanoSNP and Clair3 is very close. There are a total of 2422 SNPs in the non-diploid regions, of which 2355 are identified by Clair3 and 2342 are detected by NanoSNP. Clair3 identifies 13 more SNPs than NanoSNP, and NanoSNP has 3 fewer false positive SNP than Clair3.</p>
      <p>The dataset of the genome HG003 is new to these five SNP callers, each tool has not been trained on this genome. The evaluation of five SNP callers on HG003 Nanopore datasets at different coverages is shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>. On six datasets, NanoSNP obtains the highest precisions in five SNP callers. Clair3 has the highest recalls and F1 scores. When the reads coverage is greater than 16×, the F1 scores of NanoSNP are close to that of Clair3. At the coverage of 16×, 19×, 22× and 25×, the F1 scores of NanoSNP are 97.1%, 98.1%, 98.6% and 98.8%. Clair3 obtains the F1 scores of 97.4%, 98.2%, 98.7% and 98.9%. The F1 scores of NanoSNP and Clair3 are much higher than the F1 scores of Clair (89.3%, 92.6%, 94.5% and 95.6%), Pepper-DeepVariant (92.8%, 96.3%, 97.7% and 98.4%) and NanoCaller (82.6%, 90.3%, 93.9% and 95.6%). The F1 score of NanoSNP gets improved by 8.7%, 4.6% and 17.6% compared to that of Clair, Pepper-DeepVariant and NanoCaller, respectively at the coverage of 16×.</p>
      <p>On low-coverage Nanopore sequencing data of HG002 and HG003, NanoSNP outperforms Clair, Pepper-DeepVariant and NanoCaller, and the performance of NanoSNP is close to that of Clair3. We then perform cross-reference validation on NanoSNP. NanoSNP is trained on HG001 and GRCh38, we test the accuracy of NanoSNP on HG002, HG003 sequencing data and GRCh37 reference. Both the sequencing data and reference genome are new to the model of NanoSNP. From <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>, the accuracy of NanoSNP on the GRCh37 reference is slightly higher than that on the GRCh38 reference, which can indicate that NanoSNP has good robustness for SNP detection on different references.</p>
    </sec>
    <sec>
      <title>3.3 SNP-calling performance on six human samples low-coverage nanopore data</title>
      <p>In real-world scenarios, SNP callers usually need to identify the SNPs in different human genomes, which requires the method to perform stably on different genomes. We used six human genomes (HG002–HG007) to perform cross-genome testing of five SNP callers Clair, Clair3, NanoCaller, Pepper-DeepVariant and NanoSNP. We used Samtools to randomly subsample the Nanopore sequencing data of each genome at low coverage 16×. We aligned the Nanopore reads to the reference GRCh38 with Minimap2 and then fed the alignment bam file into each SNP caller. The truth variants datasets are from GIAB variants v3.3.2.</p>
      <p>The evaluation of different SNP callers on low-coverage Nanopore sequencing reads of six human genomes is shown in <xref rid="btac824-F3" ref-type="fig">Figure 3</xref>. On the dataset of Ashkenazim Trio (HG002, HG003 and HG004), NanoSNP has the highest precisions among the five SNP callers. Clair3 has the highest recalls (97.6%, 97.6% and 97.4%) and F1 scores (97.4%, 97.4% and 96.9%) in five SNP callers and NanoSNP has the second-highest recalls (96.6%, 96.7% and 96.4%) and F1 scores (97.1%, 97.1% and 96.7%). The F1 scores of other SNP callers including Clair, Pepper-DeepVariant and NanoCaller are significantly lower than the F1 scores of NanoSNP and Clair3. The comparison of TP/FP/FN calls of NanoSNP and Clair3 on the dataset of HG003 is shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Text S5</xref>.</p>
      <fig position="float" id="btac824-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Cross-genome testing of Clair, Clair3, Pepper-DeepVariant, NanoCaller and NanoSNP on low-coverage (16×) Nanopore sequencing datasets of genomes HG002-HG007</p>
        </caption>
        <graphic xlink:href="btac824f3" position="float"/>
      </fig>
      <p>On the dataset of Chinese Trio (HG005, HG006 and HG007), NanoSNP achieves the highest precisions (96.6%, 97.3% and 97.3%) in five SNP callers. The F1 scores of NanoSNP are 96.4%, 97.0% and 96.9%. Clair3 obtains the highest recalls and F1 scores. The F1 scores of Clair3 are 96.8%, 97.4% and 97.2%. The F1 socres of other SNP callers are much lower than the F1 scores of NanoSNP and Clair3. The F1 scores of Clair are 85.7%, 88.0% and 87.9%. The F1 scores of Pepper-DeepVariant are 91.2%, 92.3% and 91.8%. The F1 scores of NanoCaller are 76.1%, 80.8% and 79.9%.</p>
      <p>We also evaluated the accuracy of different SNP detection tools on exonic regions. The performance of different SNP callers on exonic regions is shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S8</xref>. On each dataset, NanoSNP and Clair3 have significantly higher accuracies than Clair, Pepper-DeepVariant and NanoCaller. NanoSNP has the highest precisions and second highest recalls and F1 scores. Clair3 has the highest recalls and F1 scores. In each dataset, the F1 score of NanoSNP is close to that of Clair3. The difference between the F1 scores of NanoSNP and Clair3 is not more than 0.003.</p>
      <p>On the cross-genome testing of the low-coverage Nanopore sequencing data, Clair3 and NanoSNP outperform other SNP callers including Clair, Pepper-DeepVariant and NanoCaller on all six genomes. NanoSNP achieves the highest precision and second highest recall and F1 score in five SNP callers. Since NanoSNP is trained on HG001 genome, the Ashkenazim Trio and Chinese Trio genomes are new to NanoSNP. The SNP calling performance indicates that NanoSNP has good robustness for SNP identification on low-coverage Nanopore sequencing data in real-world scenarios.</p>
    </sec>
    <sec>
      <title>3.4 SNP-calling performance in difficult-to-map regions</title>
      <p>GA4GH and GIAB have defined the difficult-to-map regions on the reference genome GRCh38. The difficult-to-map regions are the union of all tandem repeats, all homopolymers &gt;6 bp, all imperfect homopolymers &gt;10 bp, all difficult to map regions, all segmental duplications, GC &lt;25 or &gt;65%, bad promoters, and other difficult regions such as major histocompatibility complex (MHC). We tested the SNP calling performance of several SNP callers in difficult-to-map regions on Nanopore reads of six genomes HG002–HG007. The coverage of each dataset is around 16×.</p>
      <p>We downloaded the BED files of difficult-to-map regions from the public website. Each difficult-to-map region on the reference is recorded as an interval including the start position and end position. The benchmark datasets are GIAB variants dataset v3.3.2 of each genome. Each benchmark contains two files, one is a VCF file that records variant sites, and the other is a BED file that records high-confidence regions for SNP detection. The SNP sites that fall in the high-confidence regions in the VCF file have higher confidence than the SNP sites in other regions. We used Bedtools to obtain the intersection of the difficult-to-map regions and the high-confidence regions for each human genome. In the genomes HG002, HG003 and HG004 of Ashkenazim Trio, SNPs in the difficult regions account for about 18% of total SNPs in the high-confidence regions. In the genome HG005, HG006 and HG007 of Chinese Trio, the percentage is around 15%. These proportions indicate that SNPs in the difficult-to-map regions account for a significant fraction of all the SNPs in the high-confidence regions.</p>
      <p>The evaluation of SNPs identified by NanoSNP and the compared SNP callers in the difficult-to-map regions is shown in <xref rid="btac824-T1" ref-type="table">Table 1</xref>. In the difficult-to-map regions on GRCh38, NanoSNP has the highest precisions and F1 scores in all the SNP callers on each dataset of Ashkenazim Trio and Chinese Trio. On the datasets of genomes HG002, HG003, HG004, the F1 scores of NanoSNP are 93.1%, 93.4% and 92.6% and the F1 scores of Clair3 are 92.8%, 93.0% and 92.5%. The F1 scores of other SNP callers are much lower than the F1 scores of NanoSNP and Clair3. On the dataset of genomes HG005, HG006 and HG007, the F1 scores of NanoSNP are 92.7%, 93.4% and 93.2%. The F1 scores of Clair3 are 92.3%, 93.0% and 92.8%.</p>
      <table-wrap position="float" id="btac824-T1">
        <label>Table 1.</label>
        <caption>
          <p>Evaluation of SNP calls identified by the different SNP calling methods in the difficult-to-map regions on the low-coverage (16×) Nanopore sequencing datasets.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Metrics</th>
              <th rowspan="1" colspan="1">Methods</th>
              <th rowspan="1" colspan="1">HG002</th>
              <th rowspan="1" colspan="1">HG003</th>
              <th rowspan="1" colspan="1">HG004</th>
              <th rowspan="1" colspan="1">HG005</th>
              <th rowspan="1" colspan="1">HG006</th>
              <th rowspan="1" colspan="1">HG007</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Precision</td>
              <td rowspan="1" colspan="1">Clair</td>
              <td rowspan="1" colspan="1">0.892</td>
              <td rowspan="1" colspan="1">0.897</td>
              <td rowspan="1" colspan="1">0.890</td>
              <td rowspan="1" colspan="1">0.854</td>
              <td rowspan="1" colspan="1">0.880</td>
              <td rowspan="1" colspan="1">0.880</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Clair3</td>
              <td rowspan="1" colspan="1">0.916</td>
              <td rowspan="1" colspan="1">0.916</td>
              <td rowspan="1" colspan="1">0.911</td>
              <td rowspan="1" colspan="1">0.901</td>
              <td rowspan="1" colspan="1">0.912</td>
              <td rowspan="1" colspan="1">0.911</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Pepper-DeepVariant</td>
              <td rowspan="1" colspan="1">0.881</td>
              <td rowspan="1" colspan="1">0.868</td>
              <td rowspan="1" colspan="1">0.860</td>
              <td rowspan="1" colspan="1">0.850</td>
              <td rowspan="1" colspan="1">0.862</td>
              <td rowspan="1" colspan="1">0.856</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">NanoCaller</td>
              <td rowspan="1" colspan="1">0.659</td>
              <td rowspan="1" colspan="1">0.672</td>
              <td rowspan="1" colspan="1">0.651</td>
              <td rowspan="1" colspan="1">0.603</td>
              <td rowspan="1" colspan="1">0.660</td>
              <td rowspan="1" colspan="1">0.647</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">NanoSNP</td>
              <td rowspan="1" colspan="1">
                <bold>0.935</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.935</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.926</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.925</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.933</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.933</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Recall</td>
              <td rowspan="1" colspan="1">Clair</td>
              <td rowspan="1" colspan="1">0.782</td>
              <td rowspan="1" colspan="1">0.796</td>
              <td rowspan="1" colspan="1">0.782</td>
              <td rowspan="1" colspan="1">0.780</td>
              <td rowspan="1" colspan="1">0.792</td>
              <td rowspan="1" colspan="1">0.788</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Clair3</td>
              <td rowspan="1" colspan="1">
                <bold>0.941</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.944</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.940</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.946</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.949</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.945</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Pepper-DeepVariant</td>
              <td rowspan="1" colspan="1">0.899</td>
              <td rowspan="1" colspan="1">0.906</td>
              <td rowspan="1" colspan="1">0.897</td>
              <td rowspan="1" colspan="1">0.898</td>
              <td rowspan="1" colspan="1">0.910</td>
              <td rowspan="1" colspan="1">0.904</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">NanoCaller</td>
              <td rowspan="1" colspan="1">0.902</td>
              <td rowspan="1" colspan="1">0.906</td>
              <td rowspan="1" colspan="1">0.898</td>
              <td rowspan="1" colspan="1">0.895</td>
              <td rowspan="1" colspan="1">0.906</td>
              <td rowspan="1" colspan="1">0.900</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">NanoSNP</td>
              <td rowspan="1" colspan="1">0.928</td>
              <td rowspan="1" colspan="1">0.932</td>
              <td rowspan="1" colspan="1">0.926</td>
              <td rowspan="1" colspan="1">0.929</td>
              <td rowspan="1" colspan="1">0.936</td>
              <td rowspan="1" colspan="1">0.930</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">F1 score</td>
              <td rowspan="1" colspan="1">Clair</td>
              <td rowspan="1" colspan="1">0.834</td>
              <td rowspan="1" colspan="1">0.843</td>
              <td rowspan="1" colspan="1">0.833</td>
              <td rowspan="1" colspan="1">0.815</td>
              <td rowspan="1" colspan="1">0.834</td>
              <td rowspan="1" colspan="1">0.832</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Clair3</td>
              <td rowspan="1" colspan="1">0.928</td>
              <td rowspan="1" colspan="1">0.930</td>
              <td rowspan="1" colspan="1">0.925</td>
              <td rowspan="1" colspan="1">0.923</td>
              <td rowspan="1" colspan="1">0.930</td>
              <td rowspan="1" colspan="1">0.928</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Pepper-DeepVariant</td>
              <td rowspan="1" colspan="1">0.890</td>
              <td rowspan="1" colspan="1">0.887</td>
              <td rowspan="1" colspan="1">0.878</td>
              <td rowspan="1" colspan="1">0.874</td>
              <td rowspan="1" colspan="1">0.885</td>
              <td rowspan="1" colspan="1">0.879</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">NanoCaller</td>
              <td rowspan="1" colspan="1">0.761</td>
              <td rowspan="1" colspan="1">0.772</td>
              <td rowspan="1" colspan="1">0.755</td>
              <td rowspan="1" colspan="1">0.721</td>
              <td rowspan="1" colspan="1">0.764</td>
              <td rowspan="1" colspan="1">0.753</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">NanoSNP</td>
              <td rowspan="1" colspan="1">
                <bold>0.931</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.934</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.926</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.927</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.934</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>0.932</bold>
              </td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p>The bold in the table means the best results.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The evaluation of SNP calls identified by several SNP callers in the MHC regions is shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S9</xref>. NanoSNP and Clair3 have higher accuracies than Clair, Pepper-DeepVariant and NanoCaller. NanoSNP achieves the highest precisions on all the genomes and Clair3 has the highest F1 scores. On the Ashkenazim Trio (HG002, HG003 and HG004), the F1 scores of NanoSNP are 95.9%, 97.5% and 97.9%, and the F1 score of Clair3 are 96.4%, 97.8% and 98.0%. On the Chinese Trio, the F1 scores of NanoSNP are 96.8%, 97.3% and 96.4%. The F1 scores of Clair3 are 97.3%, 98.0% and 97.4%. The F1 scores of Clair3 are slightly higher than that of NanoSNP. Overall, NanoSNP and Clair3 have similar SNP identification performance in difficult-to-map regions and MHC regions, and both are significantly better than other compared SNP callers.</p>
    </sec>
    <sec>
      <title>3.5 Performance of pileup model and haplotype model</title>
      <p>When the coverage of Nanopore sequencing reads is insufficient, it is difficult to determine whether the difference between the read base and reference base is caused by sequencing error or SNP. In NanoSNP, we employed two different models to identify SNP sites sequentially. The pileup model first detected a subset of SNP sites based on the pileup image of aligned reads. This set of SNPs is phased by WhatsHap and used for the phasing of Nanopore reads. We then generated the haplotype image and the pileup image of each haplotype and used the haplotype model to identify SNPs. We evaluated the SNPs called by the pileup model and the haplotype model on the low-coverage Nanopore sequencing of genomes HG002–HG007.</p>
      <p>The evaluations of SNPs identified by the two models in NanoSNP are shown in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S10</xref>. The precision, recall and F1 score of the pileup model on six human datasets are 90.3%, 93.6% and 91.9% on average. The precision, recall and F1 score of the haplotype model on six human datasets are 97.2%, 96.5% and 96.9% on average. The performance of the haplotype model has a significant improvement compared to that of the pileup model. Especially on the genome HG005, the precision, recall, F1 scores of the haplotype model get improved by around 11.0%, 3.4% and 7.2% than that of the pileup model. The improvement can indicate that phasing Nanopore reads benefits the SNP identification on low-coverage Nanopore sequencing data.</p>
    </sec>
    <sec>
      <title>3.6 Computational setup and runtime</title>
      <p>To assess the runtime of NanoSNP, we divided the pipeline of NanoSNP into four main steps, including feature generation of the pileup model, prediction of the pileup model, feature generation of the haplotype model and prediction of the haplotype model. The prediction of the pileup model and the haplotype model ran on a graphics processing unit (GPU), and the feature generation ran on a central processing unit (CPU). We ran NanoSNP and three other SNP callers on the server with 40 CPU processors, an Nvidia Tesla A100 GPU. For human whole-genome sequencing data with 16× sequencing depth, NanoSNP took a total of 16 h, where each main step took 4, 2, 7 and 3 h, respectively. We then ran NanoCaller, Pepper-DeepVariant, Clair, Clair3 to identify the SNPs under the same computing resources. The runtime of these four tools is around 8, 8, 9 and 10 h, respectively. In SNP calling, NanoSNP has two identification steps, including calling SNPs with the pileup information and calling SNPs with the haplotype information. Compared with the methods based on either pileup information (Clair) or haplotype information (NanoCaller), NanoSNP has one more identification step. Therefore, the running time of NanoSNP was nearly 50% longer than that of the compared SNP callers. Compare to Pepper-DeepVariant, the second step of NanoSNP verifies all the candidate SNP sites, which spends more computing time. Compare to Clair3, the full-alignment model in Clair3 directly takes phased local alignment as a feature image, while NanoSNP calculates both local features and long-range features of candidate SNP sites from reads alignment, which increases the runtime of NanoSNP.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusion</title>
    <p>On the low-coverage Nanopore sequencing dataset, it is difficult to determine whether the difference between the read base and reference base is a sequencing error or SNP due to the high sequencing error rate and insufficient sequencing coverage. This study proposed a novel deep learning-based SNP caller, NanoSNP for low-coverage Nanopore sequencing data. In NanoSNP, we design a two-step SNP identification workflow. In the first step, the pileup model of NanoSNP takes the pileup feature of aligned reads to identify a set of SNPs. This set of SNPs is used for phasing aligned reads, which divides the sequencing reads into different haplotypes. In the second step, the haplotype model of NanoSNP extracts the long-range haplotype information and short-range pileup information of each haplotype. The haplotype model can correct part of the false SNP calls of the pileup model and identifies SNPs that are missed by the pileup model.</p>
    <p>We evaluate several Nanopore SNP callers on low-coverage Nanopore sequencing reads with different coverage values (16×, 19×, 22× and 25×). NanoSNP performs better than Clair, Pepper-DeepVariant and NanoCaller. When the coverage is greater than 16×, the F1 scores of NanoSNP are close to that of Clair3. In the cross-genome testing on six human genomes HG002–HG007, NanoSNP achieves the highest precision, second highest recall and F1 score on each low-coverage Nanopore dataset. Usually, the SNP identification in the difficult-to-map regions and the MHC regions of the human genome is more difficult and error-prone. By benchmarking the SNPs in these regions, we find that NanoSNP has a good performance in the difficult-to-map regions and the MHC regions.</p>
    <p>NanoSNP is designed for identifying SNPs on low-coverage Nanopore sequencing data. NanoSNP cannot identify SNPs with PacBio reads and Illumina reads. We will further develop NanoSNP to support multiple sequencing platforms in future work.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btac824_Supplementary_Materials</label>
      <media xlink:href="btac824_supplementary_materials.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <sec>
    <title>Funding</title>
    <p>This work was supported in part by the National Key Research and Development Program of China [2021YFF1201200 to J.W.] and the National Natural Science Foundation of China [62150048 and U1909208 to J.W.]; the US National Institute of Food and Agriculture (NIFA) under grant (2017-70016-26051 to F.L.) and the US National Science Foundation (NSF) [ABI-1759856 to F.L.].</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btac824-B1">
      <mixed-citation publication-type="journal"><collab>1000 Genomes Project Consortium</collab><etal>et al</etal> (<year>2015</year>) <article-title>A global reference for human genetic variation</article-title>. <source>Nature</source>, <volume>526</volume>, <fpage>68</fpage>.<pub-id pub-id-type="pmid">26432245</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ahsan</surname><given-names>M.U.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Nanocaller for accurate detection of SNPs and indels in difficult-to-map regions from long-read sequencing by haplotype-aware deep neural networks</article-title>. <source>Genome Biol</source>., <volume>22</volume>, <fpage>1</fpage>–<lpage>33</lpage>.<pub-id pub-id-type="pmid">33397451</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chen</surname><given-names>Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Efficient assembly of nanopore reads via highly accurate and intact error correction</article-title>. <source>Nat. Commun</source>., <volume>12</volume>, <fpage>1</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">33397941</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>DePristo</surname><given-names>M.A.</given-names></string-name></person-group><etal>et al</etal> (<year>2011</year>) <article-title>A framework for variation discovery and genotyping using next-generation DNA sequencing data</article-title>. <source>Nat. Genet</source>., <volume>43</volume>, <fpage>491</fpage>–<lpage>498</lpage>.<pub-id pub-id-type="pmid">21478889</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hochreiter</surname><given-names>S.</given-names></string-name>, <string-name><surname>Schmidhuber</surname><given-names>J.</given-names></string-name></person-group> (<year>1997</year>) <article-title>Long short-term memory</article-title>. <source>Neural Comput</source>., <volume>9</volume>, <fpage>1735</fpage>–<lpage>1780</lpage>.<pub-id pub-id-type="pmid">9377276</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Huddleston</surname><given-names>J.</given-names></string-name></person-group><etal>et al</etal> (<year>2017</year>) <article-title>Discovery and genotyping of structural variation from long-read haploid genome sequence data</article-title>. <source>Genome Res</source>., <volume>27</volume>, <fpage>677</fpage>–<lpage>685</lpage>.<pub-id pub-id-type="pmid">27895111</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jain</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Nanopore sequencing and assembly of a human genome with ultra-long reads</article-title>. <source>Nat. Biotechnol</source>., <volume>36</volume>, <fpage>338</fpage>–<lpage>345</lpage>.<pub-id pub-id-type="pmid">29431738</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H.</given-names></string-name></person-group> (<year>2018</year>) <article-title>Minimap2: pairwise alignment for nucleotide sequences</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>3094</fpage>–<lpage>3100</lpage>.<pub-id pub-id-type="pmid">29750242</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Luo</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) A multi-task convolutional deep neural network for variant calling in single molecule sequencing. <italic toggle="yes">Nat. Commun.</italic>, <volume>10</volume>, 998.</mixed-citation>
    </ref>
    <ref id="btac824-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Luo</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2020</year>) <article-title>Exploring the limit of using a deep neural network on pileup data for germline variant calling</article-title>. <source>Nat. Mach. Intell</source>., <volume>2</volume>, <fpage>220</fpage>–<lpage>227</lpage>.</mixed-citation>
    </ref>
    <ref id="btac824-B11">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Martin</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2016</year>) WhatsHap: fast and accurate read-based phasing. <italic toggle="yes">bioRxiv</italic>. <pub-id pub-id-type="doi">10.1101/085050</pub-id>.</mixed-citation>
    </ref>
    <ref id="btac824-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ni</surname><given-names>P.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Genome-wide detection of cytosine methylations in plant from nanopore data using deep learning</article-title>. <source>Nat. Commun</source>., <volume>12</volume>, <fpage>1</fpage>–<lpage>11</lpage>.<pub-id pub-id-type="pmid">33397941</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Nurk</surname><given-names>S.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) The complete sequence of a human genome. <italic toggle="yes">Science</italic>, <volume>376</volume>, 44–53.</mixed-citation>
    </ref>
    <ref id="btac824-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Patterson</surname><given-names>M.</given-names></string-name></person-group><etal>et al</etal> (<year>2015</year>) <article-title>WhatsHap: weighted haplotype assembly for future-generation sequencing reads</article-title>. <source>J. Comput. Biol</source>., <volume>22</volume>, <fpage>498</fpage>–<lpage>509</lpage>.<pub-id pub-id-type="pmid">25658651</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Payne</surname><given-names>A.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Bulkvis: a graphical viewer for oxford nanopore bulk fast5 files</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>2193</fpage>–<lpage>2198</lpage>.<pub-id pub-id-type="pmid">30462145</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Poplin</surname><given-names>R.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>A universal SNP and small-indel variant caller using deep neural networks</article-title>. <source>Nat. Biotechnol</source>., <volume>36</volume>, <fpage>983</fpage>–<lpage>987</lpage>.<pub-id pub-id-type="pmid">30247488</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Porubsky</surname><given-names>D.</given-names></string-name></person-group><etal>et al</etal>; <collab>Human Genome Structural Variation Consortium</collab>. (<year>2021</year>) <article-title>Fully phased human genome assembly without parental data using single-cell strand sequencing and long reads</article-title>. <source>Nat. Biotechnol</source>., <volume>39</volume>, <fpage>302</fpage>–<lpage>308</lpage>.<pub-id pub-id-type="pmid">33288906</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Reshef</surname><given-names>Y.A.</given-names></string-name></person-group><etal>et al</etal> (<year>2018</year>) <article-title>Detecting genome-wide directional effects of transcription factor binding on polygenic disease risk</article-title>. <source>Nat. Genet</source>., <volume>50</volume>, <fpage>1483</fpage>–<lpage>1493</lpage>.<pub-id pub-id-type="pmid">30177862</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shafin</surname><given-names>K.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Haplotype-aware variant calling with pepper-margin-deepvariant enables high accuracy in nanopore long-reads</article-title>. <source>Nat. Methods</source>, <volume>18</volume>, <fpage>1322</fpage>–<lpage>1332</lpage>.<pub-id pub-id-type="pmid">34725481</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shastry</surname><given-names>B.S.</given-names></string-name></person-group> (<year>2007</year>) <article-title>Snps in disease gene mapping, medicinal drug development and evolution</article-title>. <source>J. Hum. Genet</source>., <volume>52</volume>, <fpage>871</fpage>–<lpage>880</lpage>.<pub-id pub-id-type="pmid">17928948</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>Y.</given-names></string-name></person-group><etal>et al</etal> (<year>2021</year>) <article-title>Nanopore sequencing technology, bioinformatics and applications</article-title>. <source>Nat. Biotechnol</source>., <volume>39</volume>, <fpage>1348</fpage>–<lpage>1365</lpage>.<pub-id pub-id-type="pmid">34750572</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wenger</surname><given-names>A.M.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>Accurate circular consensus long-read sequencing improves variant detection and assembly of a human genome</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>1155</fpage>–<lpage>1162</lpage>.<pub-id pub-id-type="pmid">31406327</pub-id></mixed-citation>
    </ref>
    <ref id="btac824-B23">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Wright</surname><given-names>L.</given-names></string-name>, <string-name><surname>Demeure</surname><given-names>N.</given-names></string-name></person-group> (<year>2021</year>) Ranger21: a synergistic deep learning optimizer. <italic toggle="yes">arXiv Pre-Print arXiv:2106.13731.</italic></mixed-citation>
    </ref>
    <ref id="btac824-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zheng</surname><given-names>Z.</given-names></string-name></person-group><etal>et al</etal> (<year>2022</year>) Symphonizing pileup and full-alignment for deep learning-based long-read variant calling. <italic toggle="yes">Nat. Comput. Sci.</italic>, <volume>2</volume>, 797–803<italic toggle="yes">.</italic></mixed-citation>
    </ref>
    <ref id="btac824-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zook</surname><given-names>J.M.</given-names></string-name></person-group><etal>et al</etal> (<year>2019</year>) <article-title>An open resource for accurately benchmarking small variant and reference calls</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>561</fpage>–<lpage>566</lpage>.<pub-id pub-id-type="pmid">30936564</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
