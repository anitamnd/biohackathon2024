<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7355244</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btaa463</article-id>
    <article-id pub-id-type="publisher-id">btaa463</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Comparative and Functional Genomics</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>TinGa: fast and flexible trajectory inference with Growing Neural Gas</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Todorov</surname>
          <given-names>Helena</given-names>
        </name>
        <xref ref-type="aff" rid="btaa463-aff1">b1</xref>
        <xref ref-type="aff" rid="btaa463-aff2">b2</xref>
        <xref ref-type="aff" rid="btaa463-aff3">b3</xref>
        <xref ref-type="corresp" rid="btaa463-cor1"/>
        <!--<email>helena.todorov@irc.vib-ugent.be</email>-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Cannoodt</surname>
          <given-names>Robrecht</given-names>
        </name>
        <xref ref-type="aff" rid="btaa463-aff1">b1</xref>
        <xref ref-type="aff" rid="btaa463-aff2">b2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Saelens</surname>
          <given-names>Wouter</given-names>
        </name>
        <xref ref-type="aff" rid="btaa463-aff1">b1</xref>
        <xref ref-type="aff" rid="btaa463-aff2">b2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Saeys</surname>
          <given-names>Yvan</given-names>
        </name>
        <xref ref-type="aff" rid="btaa463-aff1">b1</xref>
        <xref ref-type="aff" rid="btaa463-aff2">b2</xref>
        <xref ref-type="corresp" rid="btaa463-cor1"/>
        <!--<email>yvan.saeys@ugent.be</email>-->
      </contrib>
    </contrib-group>
    <aff id="btaa463-aff1">
      <label>b1</label>
      <institution>Department of Applied Mathematics, Computer Science and Statistics, Ghent University, Ghent 9000, Belgium</institution>
    </aff>
    <aff id="btaa463-aff2"><label>b2</label><institution>Data Mining and Modeling for Biomedicine, VIB Center for Inflammation Research</institution>, Ghent 9052, <country country="BE">Belgium</country></aff>
    <aff id="btaa463-aff3"><label>b3</label><institution>Centre International de recherche en Infectiologie, Université de Lyon, INSERM U1111, CNRS UMR 5308, Ecole Normale Supérieure de Lyon, Université Claude Bernard Lyon 1</institution>, 69007 Lyon, <country country="FR">France</country></aff>
    <author-notes>
      <corresp id="btaa463-cor1">To whom correspondence should be addressed. E-mail: <email>helena.todorov@irc.vib-ugent.be</email> or <email>yvan.saeys@ugent.be</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2020-07-13">
      <day>13</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>7</month>
      <year>2020</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>36</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB 2020 Proceedings</issue-title>
    <fpage>i66</fpage>
    <lpage>i74</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2020. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2020</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btaa463.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>During the last decade, trajectory inference (TI) methods have emerged as a novel framework to model cell developmental dynamics, most notably in the area of single-cell transcriptomics. At present, more than 70 TI methods have been published, and recent benchmarks showed that even state-of-the-art methods only perform well for certain trajectory types but not others.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this work, we present TinGa, a new TI model that is fast and flexible, and that is based on Growing Neural Graphs. We performed an extensive comparison of TinGa to five state-of-the-art methods for TI on a set of 250 datasets, including both synthetic as well as real datasets. Overall, TinGa improves the state-of-the-art by producing accurate models (comparable to or an improvement on the state-of-the-art) on the whole spectrum of data complexity, from the simplest linear datasets to the most complex disconnected graphs. In addition, TinGa obtained the fastest execution times, showing that our method is thus one of the most versatile methods up to date.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>R scripts for running TinGa, comparing it to top existing methods and generating the figures of this article are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/Helena-todd/TinGa">https://github.com/Helena-todd/TinGa</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Onderzoeksprogramma Artificiële Intelligentie</institution>
          </institution-wrap>
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Single-cell technologies have recently dramatically reshaped the landscape of techniques to model and better understand biological systems. Trajectory inference (TI) methods have recently emerged as a new category of unsupervised machine learning techniques to interpret single-cell data (<xref rid="btaa463-B3" ref-type="bibr">Cannoodt <italic>et al.</italic>, 2016</xref>). These methods aim to align cells along developmental trajectories, allowing researchers to get insight into the biological processes driving dynamic processes such as cell development and differentiation (<xref rid="btaa463-B9" ref-type="bibr">Ji and Ji, 2016</xref>; <xref rid="btaa463-B14" ref-type="bibr">Shin <italic>et al.</italic>, 2015</xref>; <xref rid="btaa463-B16" ref-type="bibr">Trapnell <italic>et al.</italic>, 2014</xref>). More than 70 TI methods have been published up to date, differing in their methodologies, the input they need from the user and in the type of trajectories that they can model. Indeed, the first TI tools [Wanderlust, <xref rid="btaa463-B2" ref-type="bibr">Bendall <italic>et al.</italic> (2014)</xref> and Monocle, <xref rid="btaa463-B8" ref-type="bibr">Hill <italic>et al.</italic> (2015)</xref>] were able to model very simple linear trajectories. With new tools being generated, the complexity of the trajectories that could be modelled increased greatly, from branching [DPT, <xref rid="btaa463-B7" ref-type="bibr">Haghverdi <italic>et al.</italic> (2016)</xref> and Wishbone, <xref rid="btaa463-B13" ref-type="bibr">Setty <italic>et al.</italic> (2016)</xref>] or cycling [reCAT, <xref rid="btaa463-B19" ref-type="bibr">Ye <italic>et al.</italic> (2019)</xref>], to more intricate graph structures [SLICER, <xref rid="btaa463-B17" ref-type="bibr">Welch <italic>et al.</italic> (2016)</xref>]. </p>
    <p>Even though a large number of trajectory methods exist, the spectrum of topologies that can be modelled is unevenly distributed. A large number of the existing tools allow analysing simple linear trajectories. However, for more complex graph structures, there are only a handful of adequate methods. For the most complex topology considered in this article, that is trajectories that might consist of several disconnected components, only three existing methods can be applied: PAGA (<xref rid="btaa463-B18" ref-type="bibr">Wolf <italic>et al.</italic>, 2019</xref>), StemID (<xref rid="btaa463-B6" ref-type="bibr">Grün <italic>et al.</italic>, 2016</xref>) and Monocle 3 (<xref rid="btaa463-B4" ref-type="bibr">Cao <italic>et al.</italic>, 2019</xref>). In a recently published paper on TI, <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref> compared 45 of the existing TI methods. Several interesting findings resulted from this study, including the strengths and weaknesses of existing tools as well as possible gaps in the field of TI. A first conclusion from this study was that no existing method was able to return accurate results for all the 350 datasets that were included in the study. Therefore, when facing a new unknown dataset, researchers need to apply several of the state-of-the-art methods and then compare their results in order to be able to gain biological insight into the data. It could be argued that the methods that can model the most complex trajectories could be applied in general, since they should also be able to model the simplest trajectories. However, a general observation made by the authors was that such methods then tend to be biased towards producing more complex trajectories in comparison to the ground truth. Therefore, when facing a new dataset with an unknown structure, there is still room for new methods that can deal with both simple and complex topologies in a flexible manner. Ideally, such methods would also be scalable, and able to run on datasets with millions of cells in an acceptable runtime.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Adaptive topology modelling using Growing Neural Gas</title>
      <p>In this article, we introduce TinGa, a fast and flexible TI method. It is the first method that applies the Growing Neural Gas algorithm [GNG, <xref rid="btaa463-B5" ref-type="bibr">Fritzke (1995)</xref>] to infer trajectories. The basic idea behind this algorithm is to build a (possibly disconnected) graph that aims to fit a set of data points as well as possible using a graph structure that is iteratively adapted. The algorithm starts by building a graph that consists of two nodes, linked by an edge. An iterative procedure is then applied in which a random cell from the dataset is picked as input at every iteration and subsequently the graph is adapted to the data. An algorithmic description of TinGa is given in Algorithm 1. All nodes have an associated error that is representative of how well each node covers a certain region of the data space. A new node is added to the graph every λ iterations until a maximum number of nodes is reached. The new nodes are added close to the nodes with a maximal error, such that the graph grows until it covers the data homogeneously. The edges in the graph age if they are not stimulated by any input data, and die after they reach a certain age. The procedure results in a graph whose nodes and edges are representative of the data density structure.</p>
      <p>After obtaining the graph structure using the GNG algorithm, putative noisy edges are cleared from this structure. The triangle structures in the graph are simplified by building a minimal spanning tree. However, this process can also remove edges that were representative of the data structure. A second post-processing step is therefore applied, in which nodes of degree one are identified. We then test if an edge should be added between pairs of nodes of degree one, following three rules:
</p>
      <list list-type="order">
        <list-item>
          <p>the edge should exist in the GNG original result (before a minimal spanning tree was computed);</p>
        </list-item>
        <list-item>
          <p>adding the new edge should not result in a triangle; and</p>
        </list-item>
        <list-item>
          <p>the cell density along the new edge should be comparable to the mean density across the rest of the graph’s edges (which we defined as equal or superior to the mean density in the rest of the graph).</p>
        </list-item>
      </list>
      <p>
        <boxed-text id="btaa463-BOX1" position="float" orientation="portrait">
          <sec>
            <title><bold>Algorithm 1:</bold> TinGa</title>
            <p>1: <bold>input</bold> the matrix of reduced dimensions <italic>d</italic></p>
            <p>2: <bold>parameters</bold> max_iter, age_max, max_nodes, α, β, ϵ<sub><italic>b</italic></sub>, ϵ<sub><italic>n</italic></sub>, λ</p>
            <p>3: <bold>procedure</bold> Compute a TinGa graph</p>
            <p>4: <italic>initialise objects that will store information about the graph</italic>.:</p>
            <p>5:  <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mi mathvariant="italic">Nodes</mml:mi><mml:mo>←</mml:mo><mml:mtext>matrix</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi><mml:mo> </mml:mo><mml:mtext>rows</mml:mtext><mml:mo>,</mml:mo><mml:mtext>ncol</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mtext>columns</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>6:  <inline-formula id="IE2"><mml:math id="IM2"><mml:mrow><mml:mi mathvariant="italic">Edges</mml:mi><mml:mo>←</mml:mo><mml:mtext>list</mml:mtext><mml:mo> </mml:mo><mml:mtext>that</mml:mtext><mml:mo> </mml:mo><mml:mtext>will</mml:mtext><mml:mo> </mml:mo><mml:mtext>contain</mml:mtext><mml:mo> </mml:mo><mml:mtext>the</mml:mtext><mml:mo> </mml:mo><mml:mtext>TinGa</mml:mtext><mml:mo> </mml:mo><mml:mtext>edges</mml:mtext></mml:mrow></mml:math></inline-formula></p>
            <p>7:  <italic>Nodes error</italic> ← list that will contain the node associated errors</p>
            <p>8:  <italic>Age edges</italic> ← matrix(<italic>max_nodes</italic> rows, <italic>max_nodes</italic> columns)</p>
            <p>9: <italic>initialise graph with two cells.:</italic></p>
            <p>10:  <inline-formula id="IE5"><mml:math id="IM3"><mml:mrow><mml:mi>N</mml:mi><mml:mo> </mml:mo><mml:mi mathvariant="italic">odes</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mo>.</mml:mo><mml:mn>25</mml:mn><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mo>.</mml:mo><mml:mn>75</mml:mn><mml:mo> </mml:mo><mml:mtext>quantiles</mml:mtext><mml:mo> </mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></p>
            <p>11:  <inline-formula id="IE6"><mml:math id="IM4"><mml:mrow><mml:mtext>add</mml:mtext><mml:mo> </mml:mo><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>age</mml:mtext><mml:mo> </mml:mo><mml:mn>0</mml:mn><mml:mo> </mml:mo><mml:mtext>between</mml:mtext><mml:mo> </mml:mo><mml:mtext>nodes</mml:mtext><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula></p>
            <p>12: <italic>while (iter &lt; max_iter):</italic></p>
            <p>13:  <inline-formula id="IE7"><mml:math id="IM5"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo><mml:mtext>sample</mml:mtext><mml:mo> </mml:mo><mml:mtext>input</mml:mtext><mml:mo> </mml:mo><mml:mtext>cell</mml:mtext><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula></p>
            <p>14:  <inline-formula id="IE8"><mml:math id="IM6"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>←</mml:mo><mml:mn>1</mml:mn><mml:mtext>st</mml:mtext><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mn>2</mml:mn><mml:mtext>nd</mml:mtext><mml:mo> </mml:mo><mml:mtext>closest</mml:mtext><mml:mo> </mml:mo><mml:mtext>nodes</mml:mtext><mml:mo> </mml:mo><mml:mtext>to</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>15:  <inline-formula id="IE9"><mml:math id="IM7"><mml:mrow><mml:mtext>increase</mml:mtext><mml:mo> </mml:mo><mml:mtext>age</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>all</mml:mtext><mml:mo> </mml:mo><mml:mtext>edges</mml:mtext><mml:mo> </mml:mo><mml:mtext>emanating</mml:mtext><mml:mo> </mml:mo><mml:mtext>from</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>16:  <inline-formula id="IE10"><mml:math id="IM8"><mml:mrow><mml:mtext>add</mml:mtext><mml:mo> </mml:mo><mml:mtext>distance</mml:mtext><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo> </mml:mo><mml:mtext>to</mml:mtext><mml:mo> </mml:mo><mml:mtext>error</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>17:  <inline-formula id="IE11"><mml:math id="IM9"><mml:mrow><mml:mtext>Move</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo> </mml:mo><mml:mtext>towards</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mo> </mml:mo><mml:mtext>factor</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi mathvariant="normal">ϵ</mml:mi><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>18:  <inline-formula id="IE12"><mml:math id="IM10"><mml:mrow><mml:mtext>Move</mml:mtext><mml:mo> </mml:mo><mml:msubsup><mml:mi>s</mml:mi><mml:mn>1</mml:mn><mml:mo>′</mml:mo></mml:msubsup><mml:mi mathvariant="normal">s</mml:mi><mml:mo> </mml:mo><mml:mtext>neighbors</mml:mtext><mml:mo> </mml:mo><mml:mtext>towards</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo> </mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mo> </mml:mo><mml:mtext>factor</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi mathvariant="normal">ϵ</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula></p>
            <p>19:  <inline-formula id="IE13"><mml:math id="IM11"><mml:mrow><mml:mtext>set</mml:mtext><mml:mo> </mml:mo><mml:mtext>age</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mtext>between</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo> </mml:mo><mml:mtext>to</mml:mtext><mml:mo> </mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p>
            <p>20:  <bold>if</bold><inline-formula id="IE14"><mml:math id="IM12"><mml:mrow><mml:mo>∃</mml:mo><mml:mo> </mml:mo><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>age</mml:mtext><mml:mo>&gt;</mml:mo><mml:mi mathvariant="italic">age</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>21:   <inline-formula id="IE15"><mml:math id="IM13"><mml:mrow><mml:mtext>remove</mml:mtext><mml:mo> </mml:mo><mml:mtext>it</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
            <p>22:   <bold>if</bold><inline-formula id="IE16"><mml:math id="IM14"><mml:mrow><mml:mo>∃</mml:mo><mml:mo> </mml:mo><mml:mtext>node</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>degree</mml:mtext><mml:mo> </mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>23:    <inline-formula id="IE17"><mml:math id="IM15"><mml:mrow><mml:mtext>remove</mml:mtext><mml:mo> </mml:mo><mml:mtext>it</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
            <p>24:  <bold>if</bold><inline-formula id="IE18"><mml:math id="IM16"><mml:mrow><mml:mtext>iter</mml:mtext><mml:mo> </mml:mo><mml:mo>%</mml:mo><mml:mo> </mml:mo><mml:mo>λ</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>25:   <bold>if</bold><inline-formula id="IE19"><mml:math id="IM17"><mml:mrow><mml:mtext>number</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>nodes</mml:mtext><mml:mo>&lt;</mml:mo><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>26:    <inline-formula id="IE20"><mml:math id="IM18"><mml:mrow><mml:mi>p</mml:mi><mml:mo>←</mml:mo><mml:mtext>node</mml:mtext><mml:mo> </mml:mo><mml:mtext>with</mml:mtext><mml:mo> </mml:mo><mml:mtext>maximum</mml:mtext><mml:mo> </mml:mo><mml:mtext>error</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
            <p>27:    <inline-formula id="IE21"><mml:math id="IM19"><mml:mrow><mml:mi>q</mml:mi><mml:mo>←</mml:mo><mml:mtext>neighbour</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mi>p</mml:mi><mml:mo> </mml:mo><mml:mtext>with</mml:mtext><mml:mo> </mml:mo><mml:mtext>maximum</mml:mtext><mml:mo> </mml:mo><mml:mtext>error</mml:mtext></mml:mrow></mml:math></inline-formula>.</p>
            <p>28:    <inline-formula id="IE22"><mml:math id="IM20"><mml:mrow><mml:mtext>insert</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mo> </mml:mo><mml:mtext>new</mml:mtext><mml:mo> </mml:mo><mml:mtext>node</mml:mtext><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mtext>between</mml:mtext><mml:mo> </mml:mo><mml:mi>p</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
            <p>29:    <inline-formula id="IE23"><mml:math id="IM21"><mml:mrow><mml:mtext>errors</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mi>p</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi>q</mml:mi><mml:mo> </mml:mo><mml:mtext>are</mml:mtext><mml:mo> </mml:mo><mml:mtext>multiplied</mml:mtext><mml:mo> </mml:mo><mml:mtext>by</mml:mtext><mml:mo> </mml:mo><mml:mo>α</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>30:    <inline-formula id="IE24"><mml:math id="IM22"><mml:mrow><mml:mi>r</mml:mi><mml:mo> </mml:mo><mml:mtext>gets</mml:mtext><mml:mo> </mml:mo><mml:mtext>the</mml:mtext><mml:mo> </mml:mo><mml:mtext>mean</mml:mtext><mml:mo> </mml:mo><mml:mtext>error</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mi>p</mml:mi><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mi>q</mml:mi></mml:mrow></mml:math></inline-formula></p>
            <p>31:    <italic>p</italic>–<italic>q</italic> edge is removed, <italic>p</italic>–<italic>r</italic> and <italic>r</italic>–<italic>q</italic> edges are added</p>
            <p>32:  <inline-formula id="IE26"><mml:math id="IM23"><mml:mrow><mml:mtext>decrease</mml:mtext><mml:mo> </mml:mo><mml:mtext>error</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>all</mml:mtext><mml:mo> </mml:mo><mml:mtext>nodes</mml:mtext><mml:mo> </mml:mo><mml:mtext>by</mml:mtext><mml:mo> </mml:mo><mml:mtext>factor</mml:mtext><mml:mo> </mml:mo><mml:mo>β</mml:mo></mml:mrow></mml:math></inline-formula></p>
            <p>33: <italic>post-process the graph.</italic>:</p>
            <p>34:  <inline-formula id="IE27"><mml:math id="IM24"><mml:mrow><mml:mtext>build</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mo> </mml:mo><mml:mtext>graph</mml:mtext><mml:mo> </mml:mo><mml:mtext>from</mml:mtext><mml:mo> </mml:mo><mml:mtext>Nodes</mml:mtext><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:mtext>Edges</mml:mtext></mml:mrow></mml:math></inline-formula></p>
            <p>35:  <inline-formula id="IE28"><mml:math id="IM25"><mml:mrow><mml:mtext>apply</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mo> </mml:mo><mml:mtext>minimal</mml:mtext><mml:mo> </mml:mo><mml:mtext>spanning</mml:mtext><mml:mo> </mml:mo><mml:mtext>tree</mml:mtext><mml:mo> </mml:mo><mml:mtext>to</mml:mtext><mml:mo> </mml:mo><mml:mtext>the</mml:mtext><mml:mo> </mml:mo><mml:mtext>graph</mml:mtext></mml:mrow></mml:math></inline-formula></p>
            <p>36:  <inline-formula id="IE29"><mml:math id="IM26"><mml:mrow><mml:mtext>identify</mml:mtext><mml:mo> </mml:mo><mml:mtext>nodes</mml:mtext><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mtext>the</mml:mtext><mml:mo> </mml:mo><mml:mtext>MST</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>degree</mml:mtext><mml:mo> </mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></p>
            <p>37:  <inline-formula id="IE30"><mml:math id="IM27"><mml:mrow><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mtext>each</mml:mtext><mml:mo> </mml:mo><mml:mtext>pair</mml:mtext><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>nodes</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo> </mml:mo><mml:mtext>of</mml:mtext><mml:mo> </mml:mo><mml:mtext>degree</mml:mtext><mml:mo> </mml:mo><mml:mn>1</mml:mn><mml:mtext>:</mml:mtext></mml:mrow></mml:math></inline-formula></p>
            <p>38:  <bold>if</bold><inline-formula id="IE31"><mml:math id="IM28"><mml:mrow><mml:mtext>graph</mml:mtext><mml:mo>⊆</mml:mo><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mn>1</mml:mn><mml:mo>-</mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>39:   <bold>if</bold><inline-formula id="IE32"><mml:math id="IM29"><mml:mrow><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mtext>doesn</mml:mtext><mml:mo>’</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo> </mml:mo><mml:mtext>result</mml:mtext><mml:mo> </mml:mo><mml:mtext>in</mml:mtext><mml:mo> </mml:mo><mml:mi mathvariant="normal">a</mml:mi><mml:mo> </mml:mo><mml:mtext>triangle</mml:mtext></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>40:    <bold>if</bold><inline-formula id="IE33"><mml:math id="IM30"><mml:mrow><mml:mtext>cell</mml:mtext><mml:mo> </mml:mo><mml:mtext>density</mml:mtext><mml:mo> </mml:mo><mml:mtext>along</mml:mtext><mml:mo> </mml:mo><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mtext>is</mml:mtext><mml:mo> </mml:mo><mml:mtext>sufficient</mml:mtext></mml:mrow></mml:math></inline-formula><bold>then</bold></p>
            <p>41:     <inline-formula id="IE34"><mml:math id="IM31"><mml:mrow><mml:mtext>add</mml:mtext><mml:mo> </mml:mo><mml:mtext>edge</mml:mtext><mml:mo> </mml:mo><mml:mtext>between</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo> </mml:mo><mml:mtext>and</mml:mtext><mml:mo> </mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
          </sec>
        </boxed-text>
      </p>
      <p>An example of different iterations of the algorithm on a disconnected trajectory is shown in <xref ref-type="fig" rid="btaa463-F1">Figure 1</xref>. The fact that an error is attributed to every node in the graph helps to keep track of the data coverage. Nodes with high errors help to localize regions that are not sufficiently covered, in which new nodes will be added to help capture the region’s structure. Since the nodes are allowed to move towards the input that stimulated them, the GNG graph iteratively evolves to cover the density structure of the dataset. The fact that edges get removed if they get too old allows the graph to split, and not linger over empty regions.
</p>
      <fig id="btaa463-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Different iterations of TinGa applied on a disconnected trajectory. The age of the graph edges is represented in different shades of blue to highlight edges that are getting old (in light blue) and are soon to be removed</p>
        </caption>
        <graphic xlink:href="btaa463f1"/>
      </fig>
    </sec>
    <sec>
      <title>2.2 Datasets</title>
      <p>For this study, we used 350 datasets that were used in the benchmarking study described in <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref>, all of which have a known ground truth trajectory useful for evaluation. A large spectrum of topologies is represented in these datasets, from the simplest linear trajectories to the most complex disconnected trajectories. In <xref ref-type="fig" rid="btaa463-F2">Figure 2</xref>, each of the nine possible topology types is represented as a graph. In bifurcations, a simple linear trajectory bifurcates into two branches. Converging trajectories are the exact opposite of bifurcations: two distinct branches merge into one. Trees consist of a succession of different bifurcations. Multi-furcations happen when a simple linear branch splits into more than two branches. Finally, some of the datasets are graphs; they can contain cycles or be acyclic, depending on the direction along the branches.
</p>
      <fig id="btaa463-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>Examples of the possible trajectory topologies. In each graph, the ground truth trajectory is represented by oriented lines, separated by nodes. The cells are coloured based on the node to which they are closest</p>
        </caption>
        <graphic xlink:href="btaa463f2"/>
      </fig>
      <p>We have split the 350 datasets in two. <xref rid="btaa463-T1" ref-type="table">Table 1</xref> describes the 100 out of 350 datasets that were used for testing TinGa’s robustness to its parameter setting, and fine-tuning of the max_nodes parameter. We then used the remaining 250 datasets to compare TinGa to 4 other TI methods. These 250 datasets contained 9 different types of trajectories, as can be seen in <xref rid="btaa463-T2" ref-type="table">Table 2</xref>. Both the 100 datasets used for parameter tuning as well as the 250 datasets used for benchmarking to other methods contained comparable numbers of real and synthetic datasets. The synthetic datasets were generated using four simulators: dyngen (<xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic>, 2019</xref>), which simulates gene regulatory networks, dyntoy (<xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic>, 2019</xref>), which builds random gradients of expression in the reduced space, PROSSTT (<xref rid="btaa463-B11" ref-type="bibr">Papadopoulos <italic>et al.</italic>, 2019</xref>), which samples the expression from a linear model that depends on pseudotime and Splatter (<xref rid="btaa463-B20" ref-type="bibr">Zappia <italic>et al.</italic>, 2017</xref>), which simulates non-linear paths between different expression states. In total, 240 synthetic datasets were thus generated using these four simulators. The cells in each dataset were then post-processed to match a real dataset’s characteristics such as the dropout rate. Combined with 110 real datasets, this thus resulted in the total number of 350 datasets, split in a set of 100 datasets for parameter tuning and 250 datasets for benchmarking to other TI methods.
</p>
      <table-wrap id="btaa463-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Datasets used for parameter tuning</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Trajectory type</th>
              <th rowspan="1" colspan="1">Real datasets</th>
              <th rowspan="1" colspan="1">Synthetic datasets</th>
              <th rowspan="1" colspan="1">Total datasets</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Linear</td>
              <td rowspan="1" colspan="1">18</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">22</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Cyclic</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Bifurcating</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">10</td>
              <td rowspan="1" colspan="1">16</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Converging</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">5</td>
              <td rowspan="1" colspan="1">6</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Multi-furcating</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Tree</td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">31</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Acyclic graph</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">3</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Connected graph</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Disconnected graph</td>
              <td rowspan="1" colspan="1">4</td>
              <td rowspan="1" colspan="1">3</td>
              <td rowspan="1" colspan="1">7</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Total</td>
              <td rowspan="1" colspan="1">38</td>
              <td rowspan="1" colspan="1">62</td>
              <td rowspan="1" colspan="1">100</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <table-wrap id="btaa463-T2" orientation="portrait" position="float">
        <label>Table 2.</label>
        <caption>
          <p>Datasets used to evaluate the methods</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Trajectory type</th>
              <th rowspan="1" colspan="1">Real datasets</th>
              <th rowspan="1" colspan="1">Synthetic datasets</th>
              <th rowspan="1" colspan="1">Total datasets</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Linear</td>
              <td rowspan="1" colspan="1">21</td>
              <td rowspan="1" colspan="1">26</td>
              <td rowspan="1" colspan="1">47</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Cyclic</td>
              <td rowspan="1" colspan="1">2</td>
              <td rowspan="1" colspan="1">21</td>
              <td rowspan="1" colspan="1">23</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Bifurcating</td>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">21</td>
              <td rowspan="1" colspan="1">28</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Converging</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">11</td>
              <td rowspan="1" colspan="1">11</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Multi-furcating</td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">6</td>
              <td rowspan="1" colspan="1">14</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Tree</td>
              <td rowspan="1" colspan="1">11</td>
              <td rowspan="1" colspan="1">45</td>
              <td rowspan="1" colspan="1">56</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Acyclic graph</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">13</td>
              <td rowspan="1" colspan="1">14</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Connected graph</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">28</td>
              <td rowspan="1" colspan="1">28</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Disconnected graph</td>
              <td rowspan="1" colspan="1">22</td>
              <td rowspan="1" colspan="1">7</td>
              <td rowspan="1" colspan="1">29</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Total</td>
              <td rowspan="1" colspan="1">72</td>
              <td rowspan="1" colspan="1">178</td>
              <td rowspan="1" colspan="1">250</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
    </sec>
    <sec>
      <title>2.3 Single-cell RNA-seq data preprocessing</title>
      <p>Real datasets were preprocessed following the standard bioconductor pipeline which uses both the scran and scater Bioconductor packages(<xref rid="btaa463-B1" ref-type="bibr">Amezquita <italic>et al.</italic>, 2020</xref>; <xref rid="btaa463-B10" ref-type="bibr">Lun <italic>et al.</italic>, 2016</xref>). The same settings were used as in <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref>, with a filtering that removed genes that were expressed in less than 5% of the cells and had an average expression lower than 0.02. Cell filtering was applied based on total counts, total amount of features, mitochondrial gene expression and if available, spike-ins, where cells with values higher than the median ± 3 MADs were removed. The most highly variable genes were selected by modelling the mean–variance relationship with a curve, and identifying genes that differed from this curve with a false discovery rate of 5% and a biological component (or effect size) higher than 0.5, using the scran R package.</p>
    </sec>
    <sec>
      <title>2.4 Benchmarking TinGa to state-of-the-art methods</title>
      <p>We compared TinGa to four top TI methods, as identified by the large-scale benchmarking study by <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref>. These are Slingshot (<xref rid="btaa463-B15" ref-type="bibr">Street <italic>et al.</italic>, 2018</xref>), PAGA (<xref rid="btaa463-B18" ref-type="bibr">Wolf <italic>et al.</italic>, 2019</xref>), RaceID/StemID (<xref rid="btaa463-B6" ref-type="bibr">Grün <italic>et al.</italic>, 2016</xref>) and Monocle 3 (<xref rid="btaa463-B4" ref-type="bibr">Cao <italic>et al.</italic>, 2019</xref>). Since the dynbenchmark package (<xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic>, 2019</xref>) contained wrappers for most of these methods, metrics for comparison, as well as 110 real and 240 synthetic datasets on which we could compare the methods, we re-used the same comparison settings. We created one new wrapper for Monocle 3, a method that was not yet included in the dynbenchmark package. Four metrics, earlier described in <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref>, were used to assess the performance of the method:
</p>
      <list list-type="bullet">
        <list-item>
          <p>Hamming–Ipsen–Mikhailov (HIM): provides information on the difference in topology between a method’s result and a gold standard, by taking into account both the edge lengths and the similarity in node degrees</p>
        </list-item>
        <list-item>
          <p>CORRELATION: provides information on the correlation between the cell ordering in a method’s results compared to a gold standard, taking the trajectory structure into account by using geodesic distances.</p>
        </list-item>
        <list-item>
          <p>F1 BRANCHES: provides information on the difference in branch assignment between a method’s result and a gold standard</p>
        </list-item>
        <list-item>
          <p>FEATURE IMPORTANCE: provides information on the genes that are differentially expressed along a method’s result trajectory compared to a gold standard</p>
        </list-item>
      </list>
      <p>Finally, we used a last metric, the MEAN SCORE, which is the geometric mean of the four aforementioned metrics.</p>
    </sec>
    <sec>
      <title>2.5 TinGa parameter settings</title>
      <p>We used the default parameters of GNG as described in <xref rid="btaa463-B5" ref-type="bibr">Fritzke (1995)</xref>. To test the applicability of each parameter setting, we performed a grid search for each parameter separately by varying the parameter over a large range of values while keeping the other parameters at their default value. These parameter values are as follows:
</p>
      <list list-type="bullet">
        <list-item>
          <p><inline-formula id="IE35"><mml:math id="IM32"><mml:mrow><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">iter</mml:mi></mml:mrow></mml:math></inline-formula>: the maximum number of iterations. Default: 10 000. No grid search was performed on this parameter, as the GNG has mostly converged after 10 000 iterations.</p>
        </list-item>
        <list-item>
          <p>ϵ<sub><italic>b</italic></sub>: how much the closest node will move towards the input cell. Default: 0.05. Grid search was performed on values varying from 0.005 to 1.</p>
        </list-item>
        <list-item>
          <p>ϵ<sub><italic>n</italic></sub>: how much the neighbours of the closest node will move towards the input. Default: 0.001. Grid search was performed on values varying from 0.0001 to 1.</p>
        </list-item>
        <list-item>
          <p>λ: the iteration at which a new node can be added. Default: 200. Grid search was performed on values varying from 100 to 500.</p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE36"><mml:math id="IM33"><mml:mrow><mml:mi mathvariant="italic">age</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:math></inline-formula>: the maximum age of an edge before it is removed. Default: 200. Grid search was performed on values varying from 100 to 500.</p>
        </list-item>
        <list-item>
          <p>α: the decay parameter for error when a new node is added. Default: 0.5. Grid search was performed on values varying from 0.1 to 0.9.</p>
        </list-item>
        <list-item>
          <p>β: the value by which all node errors decrease at every iteration. Default: 0.99. Grid search was performed on values varying from 0.2 to 0.999.</p>
        </list-item>
        <list-item>
          <p><inline-formula id="IE37"><mml:math id="IM34"><mml:mrow><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi></mml:mrow></mml:math></inline-formula>: the maximum number of nodes allowed in the GNG graph. Default: 30. Grid search was performed on values varying from 4 to 30.</p>
        </list-item>
      </list>
      <p>We tested every resulting parameter setting on 100 randomly sampled datasets among the 350 datasets described in <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref>, which we used as our training set. We then performed paired <italic>t</italic>-tests to assess whether the mean score of TinGa over the 100 training datasets would change significantly due to parameter tuning. Varying the parameters α, β, λ and <inline-formula id="IE38"><mml:math id="IM35"><mml:mrow><mml:mi mathvariant="italic">age</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">max</mml:mi></mml:mrow></mml:math></inline-formula> did not significantly change the results of TinGa over these datasets (with a <italic>P</italic>-value of 0.05). We noticed that setting too high ϵ<sub><italic>b</italic></sub> and ϵ<sub><italic>n</italic></sub> values decreased the performance of TinGa, and we therefore advise to keep the values of these parameters equal to or lower than 0.5 and 0.01 for the ϵ<sub><italic>b</italic></sub> and ϵ<sub><italic>n</italic></sub> parameters, respectively. We believe that the fact that GNG nodes should not be allowed to move excessively under the influence of one cell input makes sense, since this allows the method to be more robust to outlier cells.</p>
      <p>The only parameter whose default value showed sub-optimal results was the <inline-formula id="IE39"><mml:math id="IM36"><mml:mrow><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi></mml:mrow></mml:math></inline-formula> parameter. The GNG algorithm was originally designed to learn complex topologies, and the default number of nodes in the graph was set to a relatively high value (with a maximum of 30 nodes). In the context of TI, this number seems inappropriate, as allowing too many nodes in the graph can lead to the appearance of noisy structures, as can be seen in <xref ref-type="fig" rid="btaa463-F3">Figure 3</xref>. We tested various values for the <inline-formula id="IE40"><mml:math id="IM37"><mml:mrow><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi></mml:mrow></mml:math></inline-formula> parameter, ranging from 4 to the default of 30. The results of TinGa on the 100 datasets that we selected for training with different <inline-formula id="IE41"><mml:math id="IM38"><mml:mrow><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi></mml:mrow></mml:math></inline-formula> values can be seen in <xref ref-type="fig" rid="btaa463-F4">Figure 4</xref>. We observed that a maximum number of eight nodes was a good trade-off between performance, as assessed by the mean score in the figure, and running time. We set the <inline-formula id="IE42"><mml:math id="IM39"><mml:mrow><mml:mi mathvariant="italic">max</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">nodes</mml:mi></mml:mrow></mml:math></inline-formula> parameter to eight and all other TinGa parameters to their default value for the rest of the study.
</p>
      <fig id="btaa463-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>The trajectories identified by TinGa on a linear dataset. Even though the global structure of the data is captured in both examples, a total of 30 nodes seems to be too high and leads to a noisy trajectory, whereas 8 nodes seem sufficient to return a clean trajectory</p>
        </caption>
        <graphic xlink:href="btaa463f3"/>
      </fig>
      <fig id="btaa463-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Result of the max_nodes parameter tuning. For each max_nodes value, we represented the mean score over 100 train datasets and the time it took to the method to run in seconds</p>
        </caption>
        <graphic xlink:href="btaa463f4"/>
      </fig>
      <p>All TI methods use low-dimensional data as input. In the case of TinGa, we reduced the dimensionality of the count matrix of synthetic and real datasets to five dimensions using multi-dimensional scaling. In order to test the robustness of TinGa’s results to the choice of the number of dimensions in the lower space, we tested different numbers ranging from 3 to 50, on the same 100 datasets we had already used for grid search on TinGa’s parameters. The number of dimensions didn’t have a high impact on TinGa’s results, as can be seen in <xref ref-type="fig" rid="btaa463-F5">Figure 5</xref>. To confirm this, we performed paired <italic>t</italic>-tests to assess whether the number of dimensions that we selected would change the results of TinGa with regards to other methods. The <italic>P</italic>-values associated with these tests were all higher than 0.05. TinGa is therefore robust to the number of dimensions in the data, and we fixed this number to 5 for the rest of the study. Dimensionality reduction was applied as defined by default by the authors for the four other TI methods that we tested.
</p>
      <fig id="btaa463-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>The mean score of four state-of-the-art methods, TinGa with the default number of dimensions = 5, and four other settings for this parameter, on 100 train datasets. The five original methods are represented in colour, the four versions of TinGa with different numbers of dimensions are in gray</p>
        </caption>
        <graphic xlink:href="btaa463f5"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>We compared the performance of TinGa to a set of state-of-the-art methods for TI, namely PAGA, Slingshot, RaceID/StemID and Monocle 3. The performance of all five methods was assessed on 250 synthetic and real datasets offering a wide variety of complexities, from linear to disconnected trajectories. For each of these datasets, the ground truth trajectory is known, since it was either defined experimentally for the real datasets, or extracted from simulations for the synthetic datasets. Therefore, the results of any TI method can be compared to the ground truth trajectory and scored. We performed a comparison using four metrics that we described in Section 2. We report the results of the methods on the 178 synthetic and 72 real datasets separately.</p>
    <sec>
      <title>3.1 Synthetic datasets</title>
      <p>TinGa and Slingshot are the methods that found the best cell ordering across all synthetic datasets, as shown by the correlation scores (<xref ref-type="fig" rid="btaa463-F6">Fig. 6a</xref>). These two methods also found the best cell assignment across branches (<xref ref-type="fig" rid="btaa463-F6">Fig. 6b</xref>). However, Monocle 3 performed better than Slingshot for recovering the topology of the datasets and the features expressed along the trajectory, as can be seen in the boxplots showing the Feature Importance score and the HIM score in <xref ref-type="fig" rid="btaa463-F6">Figure 6c and d</xref>, respectively. TinGa, on the other hand, was consistently among the best methods for these four metrics when applied on the synthetic datasets. The scores of RaceID/StemID were greatly affected by the fact that it failed to return results on many datasets. In order to make the comparison of five methods on 250 datasets possible, we set a maximum memory use of 15 Gb for every method on every dataset. RaceID/StemID systematically ran out of memory on datasets containing more than 5000 cells. <xref ref-type="fig" rid="btaa463-F6">Figure 6f</xref> shows the time each method took to run on the datasets in function of the number of cells. All methods returned results in less than 10 s on datasets containing less than 1000 cells, except for RaceID/StemID, which already needed a few minutes on a dataset of 1000 cells. TinGa proved to be very scalable on larger datasets, while Slingshot and PAGA became significantly slower on datasets containing a few thousands of cells. Overall, the TinGa method obtained the best scores when compared to the four currently state-of-the-art TI methods on synthetic datasets, as can be seen in <xref ref-type="fig" rid="btaa463-F6">Figure 6e</xref>, where the Mean Score is the geometric mean of the four other metrics (Correlation, F1 Branches, HIM and Feature_Importance). We performed statistical tests to assess if TinGa’s mean score was significantly higher than the mean scores of the four other methods on the different trajectory types. The <italic>P</italic>-values associated with these one-sided <italic>t</italic>-tests can be seen in <xref rid="btaa463-T3" ref-type="table">Table 3</xref>, which contains <italic>P</italic>-values associated with paired <italic>t</italic>-tests computed on the 178 synthetic datasets. TinGa consistently performed significantly better than RaceID/StemID across all trajectory types. It also significantly outperformed Monocle 3 and PAGA on simpler trajectories such as linear, bifurcating, converging and cycles. On the other hand, the mean scores of TinGa were significantly higher than the mean scores of Slingshot on more complex trajectories such as trees and acyclic graphs (with a <italic>P</italic>-value of 0.05).
</p>
      <fig id="btaa463-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>Scores of TinGa and five top TI methods applied on 178 synthetic datasets. The methods are ordered decreasingly with the mean score along the x-axis across the whole figure. (<bold>a</bold>) The correlation between the cell ordering in a method’s result and the ground truth. (<bold>b</bold>) The accuracy in branch assignment for the cells in a method’s result compared to the ground truth. (<bold>c</bold>) The ability of a method to recover the main features that drive the trajectory. (<bold>d</bold>) The accuracy of the recovered topology compared to the ground truth. (<bold>e</bold>) The mean score: mean of the four previous scores. (<bold>f</bold>) The time every method took on datasets of differing numbers of cells (from less than 500 cells to 10 000 cells), in seconds. We represented the time on the y-axis on a log scale, so that differences between methods that were fast on large datasets such as TinGa and Monocle 3 could be seen</p>
        </caption>
        <graphic xlink:href="btaa463f6"/>
      </fig>
      <table-wrap id="btaa463-T3" orientation="portrait" position="float">
        <label>Table 3.</label>
        <caption>
          <p><italic>P</italic>-values associated with one-sided paired <italic>t</italic>-tests assessing whether TinGa performed significantly better than the other methods on the different trajectory types</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Trajectory type</th>
              <th rowspan="1" colspan="1">Monocle 3</th>
              <th rowspan="1" colspan="1">Slingshot</th>
              <th rowspan="1" colspan="1">PAGA</th>
              <th rowspan="1" colspan="1">RaceID/StemID</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Linear</td>
              <td rowspan="1" colspan="1">0.004</td>
              <td rowspan="1" colspan="1">0.433</td>
              <td rowspan="1" colspan="1">0.005</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Cyclic</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">0.016</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Bifurcating</td>
              <td rowspan="1" colspan="1">0.011</td>
              <td rowspan="1" colspan="1">0.297</td>
              <td rowspan="1" colspan="1">0.037</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Converging</td>
              <td rowspan="1" colspan="1">0.002</td>
              <td rowspan="1" colspan="1">0.062</td>
              <td rowspan="1" colspan="1">0.003</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Multi-furcating</td>
              <td rowspan="1" colspan="1">0.104</td>
              <td rowspan="1" colspan="1">0.546</td>
              <td rowspan="1" colspan="1">0.495</td>
              <td rowspan="1" colspan="1">0.005</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Tree</td>
              <td rowspan="1" colspan="1">0.742</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">0.356</td>
              <td rowspan="1" colspan="1">0.001</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Acyclic graph</td>
              <td rowspan="1" colspan="1">0.210</td>
              <td rowspan="1" colspan="1">0.007</td>
              <td rowspan="1" colspan="1">0.204</td>
              <td rowspan="1" colspan="1">0.001</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Connected graph</td>
              <td rowspan="1" colspan="1">0.942</td>
              <td rowspan="1" colspan="1">0.163</td>
              <td rowspan="1" colspan="1">0.064</td>
              <td rowspan="1" colspan="1">0.001</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Disconnected graph</td>
              <td rowspan="1" colspan="1">0.597</td>
              <td rowspan="1" colspan="1">0.086</td>
              <td rowspan="1" colspan="1">0.806</td>
              <td rowspan="1" colspan="1">0.006</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p>For each of the 178 synthetic datasets, we determined which of the five tested methods performed the best. The results are presented in <xref ref-type="fig" rid="btaa463-F7">Figure 7</xref>. TinGa had the best score on 68 out of the 178 datasets. We also observed that TinGa was the method that performed best on the greater diversity of synthetic trajectory types. Monocle 3, the second-best method that outperformed the other methods on 42 synthetic datasets, mainly showed its best performance in two types of trajectories: trees and graphs. Slingshot, the third-best method that outperformed the others on 28 synthetic datasets, mainly outperformed the other methods on simpler trajectories, from linear to cycles, while PAGA and RaceID/StemID performed best on trees. On the other hand, TinGa outperformed the other methods on linear, bifurcating, cyclic, tree, acyclic and graph trajectories.
</p>
      <fig id="btaa463-F7" orientation="portrait" position="float">
        <label>Fig. 7.</label>
        <caption>
          <p>Methods on the <italic>x</italic>-axis are ordered by the number of datasets on which they outperformed the others. The <italic>y</italic>-axis represents the number of datasets on which each method had the best mean score across all methods. For each method, bars represent the different trajectory types for which the method performed best. These bars are ordered and coloured from most simple (in light yellow) to most complex trajectory type (in dark red)</p>
        </caption>
        <graphic xlink:href="btaa463f7"/>
      </fig>
    </sec>
    <sec>
      <title>3.2 Real datasets</title>
      <p><xref ref-type="fig" rid="btaa463-F8">Figure 8</xref> shows violin plots of the scores of the five TI methods we tested on real datasets. These results were split between datasets with a silver and a gold standard. Datasets with a gold standard are datasets for which external information such as cell sorting or cell mixing were used for validation of the trajectory. In datasets with a silver standard, the ground truth trajectory was extracted directly from the expression data, typically by clustering and validation by experts.
</p>
      <fig id="btaa463-F8" orientation="portrait" position="float">
        <label>Fig. 8.</label>
        <caption>
          <p>(<bold>a</bold>–<bold>e</bold>) The results on 54 datasets with a silver standard and 18 datasets with a gold standard were represented separately in split violin plots. (a) The correlation between the cell ordering in a method’s result and the ground truth. (b) The accuracy in branch assignment for the cells in a method’s result compared to the ground truth. (c) The ability of a method to recover the main features that drive the trajectory. (d) The accuracy of the recovered topology compared to the ground truth. (e) The mean score: mean of the four previous scores. (<bold>f</bold>) The time every method took on datasets of differing numbers of cells (from 60 cells to 19 647 cells), in seconds</p>
        </caption>
        <graphic xlink:href="btaa463f8"/>
      </fig>
      <p>In datasets with a silver standard, we observed results that were comparable to the results previously shown on synthetic datasets. TinGa, Slingshot, Monocle 3 and PAGA were the methods that had the best correlation and F1 branches scores, as can be seen in <xref ref-type="fig" rid="btaa463-F8">Figure 8a and b</xref>, respectively. As observed previously, Monocle 3 outperformed Slingshot on the feature importance score (<xref ref-type="fig" rid="btaa463-F8">Fig. 8c</xref>). In the case of datasets with a silver standard, it not only performed better than Slingshot but also TinGa and PAGA on the topology HIM score (<xref ref-type="fig" rid="btaa463-F8">Fig. 8d</xref>). Overall, the mean scores of TinGa and Slingshot were relatively spread from mediocre (0.25) to very good scores (&gt;0.8) compared to Monocle 3 and PAGA, which returned more consistently mean scores around 0.55 on the real datasets with a silver standard. As observed on synthetic datasets, the scores of RaceID/StemID were greatly affected by the fact that it failed to return results on the large datasets, due to memory issues.</p>
      <p>We compared the time necessary for each method to run (<xref ref-type="fig" rid="btaa463-F8">Fig. 8f</xref>). TinGa was the fastest of the five TI tools. It took 11 s on average to run on small datasets and only 21 s on average on datasets containing more than 10 000 cells. Monocle 3 had very similar results on small datasets, but it took twice longer than TinGa on our largest datasets. Moreover, the method crashed on nine datasets. PAGA took slightly more time to run on large datasets, needing more than 3 min on average to run on datasets containing more than 10 000 cells. This method did not work on all datasets either: it crashed on 17 of them. RaceID/StemID was the second slowest method and already needed a few minutes to run on medium datasets. This method systematically crashed on datasets of more than 5000 cells, which represents 69 datasets. Slingshot and TinGa were the only methods that returned a result for all the 250 real and synthetic datasets on which they were tested. However, Slingshot was the least scalable of the five methods that we tested, and ran for more than 2 h when applied to the largest dataset of the study that contained 19 647 cells. In comparison, TinGa took 23 s on the same dataset.</p>
      <p>All methods performed significantly worse on datasets with a gold standard compared to silver-standard datasets. Since the validation of these trajectories does not rely on the data itself but on external measures, it might not reflect the processes in the data exactly and be more complex to infer. Even though Slingshot and Monocle 3 returned significantly lower correlation and featureimp_wcor scores than on the real datasets with a silver standard (<xref ref-type="fig" rid="btaa463-F8">Fig 8a and c</xref>), these two methods had the highest mean scores on datasets with a gold standard (<xref ref-type="fig" rid="btaa463-F8">Fig. 8e</xref>). The mean score of TinGa on these datasets was slightly lower than its results on silver and synthetic datasets, and the mean score of PAGA completely dropped on these datasets, never reaching a value higher than 0.5. This might in part be explained by the fact that datasets with a gold standard consisted mainly of linear and bifurcating trajectories, two trajectory types on which Slingshot tends to excel, while PAGA can over-estimate these datasets complexity (see <xref ref-type="fig" rid="btaa463-F9">Fig. 9</xref>).
</p>
      <fig id="btaa463-F9" orientation="portrait" position="float">
        <label>Fig. 9.</label>
        <caption>
          <p>The results for the five methods are represented in separate plots along the <italic>x</italic>-axis. The <italic>y</italic>-axis represents the number of datasets on which each method had the best mean score on real datasets across all methods. These results are split into two bars, representing the results on real datasets with a silver and a gold standard separately. For each method, bars represent the different trajectory types for which the method performed best. These bars are ordered and coloured from most simple (in light yellow) to most complex trajectory type (in dark red)</p>
        </caption>
        <graphic xlink:href="btaa463f9"/>
      </fig>
      <p>The number of real datasets on which each method performed best are presented in <xref ref-type="fig" rid="btaa463-F9">Figure 9</xref>, where results on datasets with a silver and a gold standard are shown separately. TinGa outperformed the other methods on 18 silver-standard datasets, which ranged from simple linear to most complex disconnected trajectories. As observed previously in synthetic datasets, PAGA performed best on a majority of tree trajectories. Slingshot and Monocle 3 returned the best results on 16 and 14 real silver-standard datasets, respectively. These two methods also performed best on a majority of the simple real datasets with a gold standard, while TinGa performed best on the only real complex dataset with a gold standard.</p>
      <p>We then performed statistical tests on the real datasets to assess whether TinGa’s mean score was significantly higher than the mean scores of the four other methods on any trajectory types. <xref rid="btaa463-T4" ref-type="table">Table 4</xref> shows the results of the one-sided paired <italic>t</italic>-tests that we performed, and contains the <italic>P</italic>-values computed among the real datasets. Since there was only one real dataset containing an acyclic graph, we could not compute any statistics on this trajectory type. As observed previously in synthetic datasets, TinGa consistently performed significantly better than RaceID/StemID across all trajectory types, except for real cyclic datasets. Moreover, the mean scores of TinGa were significantly higher than the mean scores of PAGA on both cyclic and linear datasets, and higher than the scores of Slingshot on the more complex trees and disconnected graphs (with a <italic>P</italic>-value of 0.05).
</p>
      <table-wrap id="btaa463-T4" orientation="portrait" position="float">
        <label>Table 4.</label>
        <caption>
          <p><italic>P</italic>-values associated with one-sided paired <italic>t</italic>-tests comparing TinGa to other methods on real datasets</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Trajectory type</th>
              <th rowspan="1" colspan="1">Monocle 3</th>
              <th rowspan="1" colspan="1">Slingshot</th>
              <th rowspan="1" colspan="1">PAGA</th>
              <th rowspan="1" colspan="1">RaceID/StemID</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Linear</td>
              <td rowspan="1" colspan="1">0.913</td>
              <td rowspan="1" colspan="1">0.986</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Cyclic</td>
              <td rowspan="1" colspan="1">0.761</td>
              <td rowspan="1" colspan="1">0.811</td>
              <td rowspan="1" colspan="1">0.042</td>
              <td rowspan="1" colspan="1">0.217</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Bifurcating</td>
              <td rowspan="1" colspan="1">0.378</td>
              <td rowspan="1" colspan="1">0.635</td>
              <td rowspan="1" colspan="1">0.119</td>
              <td rowspan="1" colspan="1">0.021</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Multi-furcating</td>
              <td rowspan="1" colspan="1">0.189</td>
              <td rowspan="1" colspan="1">0.439</td>
              <td rowspan="1" colspan="1">0.143</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Tree</td>
              <td rowspan="1" colspan="1">0.441</td>
              <td rowspan="1" colspan="1">0.021</td>
              <td rowspan="1" colspan="1">0.716</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Acyclic graph</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">—</td>
              <td rowspan="1" colspan="1">—</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Disconnected graph</td>
              <td rowspan="1" colspan="1">0.055</td>
              <td rowspan="1" colspan="1">0</td>
              <td rowspan="1" colspan="1">0.057</td>
              <td rowspan="1" colspan="1">0</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <p><xref ref-type="fig" rid="btaa463-F10">Figure 10</xref> is shown as an example of the trajectories returned by the different methods on a real linear dataset. On this dataset, TinGa and Slingshot accurately retrieved a linear trajectory that was similar to the real trajectory (at the top left of the figure). The cell ordering was therefore optimally retrieved by these two methods, while PAGA for instance found a trajectory that diverged greatly from the ground truth, and reordered the cells in a very different way. The trajectory identified by Monocle 3 consists of many nodes, and even though it globally resembles the ground truth, it identified two noisy micro-structures: a branch and a cycle. In this case, the mean score of Monocle 3 was therefore impacted by the fact that the topology it returned was more complex than expected, which resulted in a low HIM score. It also suffered from the fact that some cells were assigned to an extra branch and an extra cycle that were not present in the ground truth trajectory, which resulted in a bad F1_branches score. RaceID/StemID and PAGA also returned a trajectory that was much more complex than the ground truth.
</p>
      <fig id="btaa463-F10" orientation="portrait" position="float">
        <label>Fig. 10.</label>
        <caption>
          <p>Trajectories found by the different methods on a real dataset with a linear trajectory. The mean score of each method reflects the accuracy with which it inferred the trajectory compared to the gold standard, which is represented in the top-left figure. TinGa and Slingshot inferred the most accurate trajectories on this dataset</p>
        </caption>
        <graphic xlink:href="btaa463f10"/>
      </fig>
    </sec>
    <sec>
      <title>3.3 Topology bias</title>
      <p>In order to further investigate the type of trajectory topology that TinGa would return compared to other methods, we then focused on the bias in topology. <xref rid="btaa463-B12" ref-type="bibr">Saelens <italic>et al.</italic> (2019)</xref> had already highlighted the fact that some TI methods such as PAGA, tended to over-estimate the complexity of a trajectory, while other methods, amongst which Slingshot, typically under-estimated the complexity of a dataset. We assessed the difference in topology between the trajectories returned by the five TI methods tested in this article and the real data topologies (<xref ref-type="fig" rid="btaa463-F11">Fig. 11</xref>). Our results confirmed that PAGA, and also RaceID/StemID returned too complex trajectories when facing linear or cyclic datasets. We observed the same trend in Monocle 3, which also tends to reconstruct too complex topologies on linear or cyclic datasets. We also observe that RaceID/StemID tends to return extremely complex trajectories compared to ground truth, irrespective of the real topology in the data. On the other hand, slingshot and TinGa accurately returned linear topologies when facing simple datasets. We report however that Slingshot tends to model cyclic trajectories as linear, an error that TinGa typically circumvents.
</p>
      <fig id="btaa463-F11" orientation="portrait" position="float">
        <label>Fig. 11.</label>
        <caption>
          <p>The bias between the topology returned by a method and the ground truth topology is represented for each trajectory type (represented in rows), and for each method (represented in columns). This bias was computed as the difference in the number of nodes + the number of edges in the graph returned by a method compared to the ground truth. The dotted vertical lines represent a perfect match between a method’s and the ground truth topologies. The fact that a method’s results are on the right of the dotted line show us that this method tends to return too complex topologies compared to the real topology. Conversely, methods for which we observe results on the left of the dotted line tend to return too simple topologies</p>
        </caption>
        <graphic xlink:href="btaa463f11"/>
      </fig>
      <p>If we then focused on more complex datasets, such as converging, bifurcating or multi-furcating trajectories, we noticed that TinGa, PAGA and Slingshot were relatively unbiased towards the topology complexity. Monocle 3 and RaceID/StemID, on the contrary, tended to return overly complex trajectories for these topologies. Finally, if we focused on the most complex datasets on which we performed our comparison, we noticed that methods that tended to find too complex topologies in simple datasets performed more accurately on complex datasets. PAGA showed no bias in topology on disconnected graphs and showed only a slight bias in the direction of more simple topologies when applied to connected or acyclic graphs. Slingshot, on the other hand, under-estimated the complexity of disconnected, connected, acyclic and tree graphs. We observed the same trend in TinGa for the two last-mentioned topologies, but the bias was much less pronounced that the bias observed for Slingshot. All methods seemed to struggle with finding the right topology for tree datasets.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>So far, every new TI method that was published compared its results to a maximum of 10 other methods (which were not necessarily selected among the best ones), on a maximum of 10 datasets. In this work, we presented an extensive comparison of TinGa to four of the best existing TI methods to our knowledge on 250 datasets. This allowed us to clearly establish the relative performance of each method in a minimally biased setting, since adding more datasets automatically reduces the possibility that we would over-estimate the performance of our method. The datasets on which we tested TI methods were either generated by one of four different simulators or real single-cell RNA-seq datasets. This allowed us to test different aspects of the methods. In synthetic datasets, we have the advantage of having a refined gold standard, with information on every cell’s state of progression in the trajectory we simulated. Testing the methods on real datasets is of course essential, but in these datasets, a gold standard is more difficult to extract, and is usually based on a grouping of cells into time points or clusters, which is less refined than the single-cell information obtained in synthetic datasets.</p>
    <p>The TinGa method showed a very good performance on average on all types of trajectories, while we observed that Slingshot performed best on simple trajectory types, and PAGA and Monocle 3 were more prone to reconstructing complex trajectories types.</p>
    <p>Slingshot relies on two steps of first clustering the low-dimensional data and then fitting principal curves through these clusters. This results in the Slingshot trajectory typically being very well correlated with the gold-standard trajectory, since it follows the principal density structures in the data. However, this method also tends to smooth out the trajectory, possibly removing secondary structures such as branches or cycles. PAGA also starts with a clustering step, but the method then significantly differs from Slingshot since one small graph is then built per cluster. Several steps of refinement then allow linking the subgraphs that need to be linked while keeping separate the components that should not be merged, which allows the method to recover disconnected trajectories. This approach typically leads to more convoluted trajectories. Monocle 3 has a similar approach to PAGA, since it also performs clustering followed by a step where a principal graph is built for each cluster. Several refinement steps are then applied in order to produce a clean final graph, among which merging the subgraphs that should be linked. From what we observed in <xref ref-type="fig" rid="btaa463-F11">Figure 11</xref>, the similarities between PAGA and Monocle 3’s methodologies are reflected in the way they model simple trajectories, since they both tend to return more complex trajectories than needed when applied on linear or cyclic datasets. TinGa models the trajectory as a growing graph that naturally migrates towards the higher density regions in the data. It is comparable to Slingshot in the sense that it will approximate a principal curve’s result on simple trajectories. However, it also matches the best aspects of PAGA and Monocle 3 since it will eventually divide into subgraphs if the data are disconnected. From what we observed, TinGa seems to be a good trade-off between Slingshot, which is a method that performs optimally on simple trajectory types such as linear or bifurcating trajectories, and PAGA and Monocle 3, which perform best on graphs and trees but tend to return too complex topologies when facing simple trajectories. TinGa does not need the user to specify any topology. We reasoned that the fact that it can fit any topological structure in a scalable way with the number of inputs presented a real advantage in the context of TI.</p>
    <p>In this setting, we observed that TinGa was a promising TI method. Its performance is comparable to Slingshot on simple datasets, but also accurate on complex trajectories where it performed equally well and sometimes outperformed the PAGA and Monocle 3 methods. In a field as complex as is TI, we believe that more than one TI tool should be used at the same time, to increase understanding of the data. We provide TinGa, a method that is applicable to a wide range of trajectory types, and can play a role in the inference of complex disconnected trajectories, a problem that very few methods are able to tackle for now, while still being accurate on simple trajectories.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>Y.S. is an ISAC Marylou Ingram scholar. This research received funding from the Flemish Government under the ‘Onderzoeksprogramma Artificiële Intelligentie (AI) Vlaanderen’ programme. </p>
    <p><italic>Conflict of Interest</italic>: none declared. </p>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btaa463-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Amezquita</surname><given-names>R.A.</given-names></name></person-group><etal>et al</etal> (<year>2020</year>) 
<article-title>Orchestrating single-cell analysis with Bioconductor</article-title>. <source>Nat. Methods</source>, <volume>17</volume>, <fpage>137</fpage>–<lpage>145</lpage>.<pub-id pub-id-type="pmid">31792435</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bendall</surname><given-names>S.C.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Single-cell trajectory detection uncovers progression and regulatory coordination in human b cell development</article-title>. <source>Cell</source>, <volume>157</volume>, <fpage>714</fpage>–<lpage>725</lpage>.<pub-id pub-id-type="pmid">24766814</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Cannoodt</surname><given-names>R.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Computational methods for trajectory inference from single-cell transcriptomics</article-title>. <source>Eur. J. Immunol</source>., <volume>46</volume>, <fpage>2496</fpage>–<lpage>2506</lpage>.<pub-id pub-id-type="pmid">27682842</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Cao</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>The single-cell transcriptional landscape of mammalian organogenesis</article-title>. <source>Nature</source>, <volume>566</volume>, <fpage>496</fpage>–<lpage>502</lpage>.<pub-id pub-id-type="pmid">30787437</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fritzke</surname><given-names>B.</given-names></name></person-group> (<year>1995</year>) 
<article-title>A growing neural gas network learns topologies</article-title>. <source>Adv. Neural Inform. Process. Syst</source>., <volume>7</volume>, <fpage>625</fpage>–<lpage>632</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa463-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Grün</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>De novo prediction of stem cell identity using single-cell transcriptome data</article-title>. <source>Cell Stem Cell</source>, <volume>19</volume>, <fpage>266</fpage>–<lpage>277</lpage>.<pub-id pub-id-type="pmid">27345837</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Haghverdi</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Diffusion pseudotime robustly reconstructs lineage branching</article-title>. <source>Nat. Methods</source>, <volume>13</volume>, <fpage>845</fpage>–<lpage>848</lpage>.<pub-id pub-id-type="pmid">27571553</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hill</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Pseudo-temporal ordering of individual cells reveals dynamics and regulators of cell fate decisions</article-title>. <source>Proc. SPIEInt. Soc. Opt. Eng</source>., <volume>73</volume>, <fpage>389</fpage>–<lpage>400</lpage>.</mixed-citation>
    </ref>
    <ref id="btaa463-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ji</surname><given-names>Z.</given-names></name>, <name name-style="western"><surname>Ji</surname><given-names>H.</given-names></name></person-group> (<year>2016</year>) 
<article-title>TSCAN: pseudo-time reconstruction and evaluation in single-cell RNA-seq analysis</article-title>. <source>Nucleic Acids Res</source>., <volume>44</volume>, <fpage>e117</fpage>.<pub-id pub-id-type="pmid">27179027</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Lun</surname><given-names>A.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>A step-by-step workflow for low-level analysis of single-cell RNA-seq data [version 1; referees: 5 approved with reservations]</article-title>. <source>F1000Res</source>., <volume>5</volume>, <fpage>2122</fpage>.<pub-id pub-id-type="pmid">27909575</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Papadopoulos</surname><given-names>N.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>PROSSTT: probabilistic simulation of single-cell RNA-seq data for complex differentiation processes</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>3517</fpage>–<lpage>3519</lpage>.<pub-id pub-id-type="pmid">30715210</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Saelens</surname><given-names>W.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>A comparison of single-cell trajectory inference methods</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>547</fpage>–<lpage>554</lpage>.<pub-id pub-id-type="pmid">30936559</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Setty</surname><given-names>M.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Wishbone identifies bifurcating developmental trajectories from single-cell data</article-title>. <source>Nat. Biotechnol</source>., <volume>34</volume>, <fpage>637</fpage>–<lpage>645</lpage>.<pub-id pub-id-type="pmid">27136076</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Shin</surname><given-names>J.Y.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>Single-cell RNA-seq with waterfall reveals molecular cascades underlying adult neurogenesis</article-title>. <source>Cell Stem Cell</source>, <volume>17</volume>, <fpage>360</fpage>–<lpage>372</lpage>.<pub-id pub-id-type="pmid">26299571</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Street</surname><given-names>K.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Slingshot: cell lineage and pseudotime inference for single-cell transcriptomics</article-title>. <source>BMC Genomics</source>, <volume>19</volume>, <fpage>16</fpage>.<pub-id pub-id-type="pmid">29301493</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Trapnell</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</article-title>. <source>Nat. Biotechnol</source>., <volume>32</volume>, <fpage>381</fpage>–<lpage>386</lpage>.<pub-id pub-id-type="pmid">24658644</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Welch</surname><given-names>J.D.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>SLICER: inferring branched, nonlinear cellular trajectories from single cell RNA-seq data</article-title>. <source>BioMed Central</source>, <volume>17</volume>, <fpage>106</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa463-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wolf</surname><given-names>F.A.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>PAGA: graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells</article-title>. <source>Genome Biol</source>., <volume>20</volume>, <fpage>9</fpage>.<pub-id pub-id-type="pmid">30630522</pub-id></mixed-citation>
    </ref>
    <ref id="btaa463-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Ye</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) 
<article-title>Circular trajectory reconstruction uncovers cell-cycle progression and regulatory dynamics from single-cell Hi-C maps</article-title>. <source>Adv. Sci</source>., <volume>6</volume>, <fpage>1900986</fpage>.</mixed-citation>
    </ref>
    <ref id="btaa463-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zappia</surname><given-names>L.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Splatter: simulation of single-cell RNA sequencing data</article-title>. <source>Genome Biol</source>., <volume>18</volume>, <fpage>174</fpage>.<pub-id pub-id-type="pmid">28899397</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
