<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-archivearticle1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3621871</article-id>
    <article-id pub-id-type="pmid">23585840</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-12-23645</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0060593</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Biology</subject>
        <subj-group>
          <subject>Biotechnology</subject>
          <subj-group>
            <subject>Bioengineering</subject>
            <subj-group>
              <subject>Biological Systems Engineering</subject>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Computational Biology</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Genome Analysis Tools</subject>
              <subj-group>
                <subject>Genetic Networks</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Gene Networks</subject>
          </subj-group>
        </subj-group>
        <subj-group>
          <subject>Genomics</subject>
          <subj-group>
            <subject>Genome Analysis Tools</subject>
            <subj-group>
              <subject>Genetic Networks</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v2">
        <subject>Engineering</subject>
        <subj-group>
          <subject>Bioengineering</subject>
          <subj-group>
            <subject>Biological Systems Engineering</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>An Efficient Algorithm for Computing Attractors of Synchronous And Asynchronous Boolean Networks</article-title>
      <alt-title alt-title-type="running-head">Compute Attractors of Boolean Networks</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Zheng</surname>
          <given-names>Desheng</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="cor1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Yang</surname>
          <given-names>Guowu</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="cor1">
          <sup>*</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Li</surname>
          <given-names>Xiaoyu</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Zhicai</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Feng</given-names>
        </name>
        <xref ref-type="aff" rid="aff3">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>He</surname>
          <given-names>Lei</given-names>
        </name>
        <xref ref-type="aff" rid="aff2">
          <sup>2</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="aff1">
      <label>1</label>
      <addr-line>School of Computer Science and Engineering, University of Electronic Science and Technology of China, Chengdu, Sichuan, China</addr-line>
    </aff>
    <aff id="aff2">
      <label>2</label>
      <addr-line>Departmnent of Electronic Engineering, University of California Los Angeles, Los Angeles, California, United States of America</addr-line>
    </aff>
    <aff id="aff3">
      <label>3</label>
      <addr-line>Department of Pathology and Laboratory Medicine, David Geffen University of Califonia Los Angeles School of Medicine, Los Angeles, California, United States of America</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Androulakis</surname>
          <given-names>Ioannis P.</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>Rutgers University, United States of America</addr-line>
    </aff>
    <author-notes>
      <corresp id="cor1">* E-mail: <email>desheng619@gmail.com</email> (DZ); <email>guowu@uestc.edu.cn</email> (GY)</corresp>
      <fn fn-type="COI-statement">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <fn fn-type="con">
        <p>Conceived and designed the experiments: DZ GY. Performed the experiments: DZ XL ZW. Analyzed the data: FL LH. Contributed reagents/materials/analysis tools: DZ GY XL ZW. Wrote the paper: DZ FL LH.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2013</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>9</day>
      <month>4</month>
      <year>2013</year>
    </pub-date>
    <volume>8</volume>
    <issue>4</issue>
    <elocation-id>e60593</elocation-id>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>8</month>
        <year>2012</year>
      </date>
      <date date-type="accepted">
        <day>28</day>
        <month>2</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Â© 2013 Zheng et al</copyright-statement>
      <copyright-year>2013</copyright-year>
      <copyright-holder>Zheng et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are properly credited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p>Biological networks, such as genetic regulatory networks, often contain positive and negative feedback loops that settle down to dynamically stable patterns. Identifying these patterns, the so-called attractors, can provide important insights for biologists to understand the molecular mechanisms underlying many coordinated cellular processes such as cellular division, differentiation, and homeostasis. Both synchronous and asynchronous Boolean networks have been used to simulate genetic regulatory networks and identify their attractors. The common methods of computing attractors are that start with a randomly selected initial state and finish with exhaustive search of the state space of a network. However, the time complexity of these methods grows exponentially with respect to the number and length of attractors. Here, we build two algorithms to achieve the computation of attractors in synchronous and asynchronous Boolean networks. For the synchronous scenario, combing with iterative methods and reduced order binary decision diagrams (ROBDD), we propose an improved algorithm to compute attractors. For another algorithm, the attractors of synchronous Boolean networks are utilized in asynchronous Boolean translation functions to derive attractors of asynchronous scenario. The proposed algorithms are implemented in a procedure called <italic>geneFAtt</italic>. Compared to existing tools such as <italic>genYsis</italic>, <italic>geneFAtt</italic> is significantly <inline-formula><inline-graphic xlink:href="pone.0060593.e001.jpg"/></inline-formula> faster in computing attractors for empirical experimental systems.</p>
      <sec>
        <title>Availability</title>
        <p>The software package is available at <ext-link ext-link-type="uri" xlink:href="https://sites.google.com/site/desheng619/download">https://sites.google.com/site/desheng619/download</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <funding-statement>This work was supported by the National Natural Science Foundation of China under Grant (No. 60973016) and 973 Foundation (No. 2010CB328004). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
    </funding-group>
    <counts>
      <page-count count="7"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="s1">
    <title>Introduction</title>
    <p>Biological networks contribute a mathematical analysis of connections found in ecological, evolutionary, and physiological studies, such as genetic regulatory networks <xref rid="pone.0060593-Proulx1" ref-type="bibr">[1]</xref>. Pursuit for the nature of these networks is the central problem for biologists <xref rid="pone.0060593-Basso1" ref-type="bibr">[2]</xref>â<xref rid="pone.0060593-Hirose1" ref-type="bibr">[4]</xref>. In the past decades, a wide variety of research has focused on modeling genetic regulatory networks using Boolean networks and search for their attractors <xref rid="pone.0060593-Glass1" ref-type="bibr">[5]</xref>â<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>. Computing the attractors in the Boolean networks is critical in understanding corresponding genetic regulatory networks and coordinated cellular processes such as cell cycle and cell differentiation in living organisms <xref rid="pone.0060593-Kauffman1" ref-type="bibr">[6]</xref>, <xref rid="pone.0060593-Davidich1" ref-type="bibr">[11]</xref>. In classical Boolean networks (CBNs), all nodes update their values at the same time called as synchronous Boolean network (SBNs). However, a criticism of CBNs as models of genetic regulatory networks is that genes do not update their values all simultaneously. To reflect this property of gene regulatory networks, <italic>Harvey</italic> and <italic>Bossomaier</italic> defined asynchronous Boolean networks (ABNs) where the random nodes were selected at each time and updated <xref rid="pone.0060593-Harvey1" ref-type="bibr">[12]</xref>. Since that, depending on the different update schemes, Boolean networks can be generally categorized into synchronous Boolean networks <xref rid="pone.0060593-Faur1" ref-type="bibr">[7]</xref>â<xref rid="pone.0060593-Naldi1" ref-type="bibr">[9]</xref> and asynchronous Boolean networks <xref rid="pone.0060593-Faur1" ref-type="bibr">[7]</xref>, <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>, <xref rid="pone.0060593-Devloo1" ref-type="bibr">[13]</xref>, <xref rid="pone.0060593-Thomas1" ref-type="bibr">[14]</xref>. For the same update schemes with different priority of activator or inhibitor in genetic regulatory networks, classical equations <xref rid="pone.0060593-Li1" ref-type="bibr">[15]</xref>, prior inhibitor equations <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref> and a combination of these two <xref rid="pone.0060593-Ay1" ref-type="bibr">[16]</xref> are three types of Boolean translation functions. Therefore, given a Boolean network, there will be <inline-formula><inline-graphic xlink:href="pone.0060593.e002.jpg"/></inline-formula> different methods to represent its Boolean translation function.</p>
    <p>In a synchronous Boolean network, all genes update their values simultaneously at consecutive time points. <italic>Heidel et al.</italic>
<xref rid="pone.0060593-Heidel1" ref-type="bibr">[17]</xref> and <italic>Farrow et al.</italic>
<xref rid="pone.0060593-Farrow1" ref-type="bibr">[18]</xref> have proposed a scalar equation approach to compute attractors in SBNs. Based on the former, <italic>Zhao</italic>
<xref rid="pone.0060593-Zhao1" ref-type="bibr">[19]</xref> has proven that the way of computing attractors in SBNs is a NP-complete problem. <italic>Dubrova et al.</italic>
<xref rid="pone.0060593-Dubrova1" ref-type="bibr">[20]</xref> have presented two tools - <italic>BooleNet</italic> and <italic>Bns</italic> - to compute attractors of SBNs. By contrast, in an asynchronous Boolean network, all genes update their values at different time points. Because each interaction between two nodes of a biological network follows distinct kinetics, it is generally thought that ABNs more realistically represent biological networks. However, due to the complexity of ABNs, the algorithms for computing network attractors are still mostly based on SBNs.</p>
    <p>Previously, <italic>Garg et al.</italic> proposed a solution to compute the attractors in both SBNs and one class of ABNs <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>. First, they demonstrated that there were four types of attractors in a Boolean network: <italic>self loop</italic>, <italic>simple loop</italic>, <italic>syn-complex loop [or simple loop (type2)]</italic>, and <italic>asyn-complex loop</italic>, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref>. The first two types (i.e. <italic>self loop</italic> and <italic>simple loop</italic>) were shared by SBNs and ABNs. But the latter two types, the <italic>syn-complex loop</italic> and the <italic>asyn-complex loop</italic>, were respectively found in SBNs and ABNs. Subsequently, they developed a series of algorithms which could be applied to compute the four types of attractors in a given Boolean network. Based on Gargâs contribution, <italic>Ay F et al.</italic>
<xref rid="pone.0060593-Ay1" ref-type="bibr">[16]</xref> gave a faster method to list the states of <italic>self loops</italic> and <italic>one outgoing edge</italic>. Both <italic>Garg et al.</italic> and <italic>Ay et al.</italic> used the <italic>ROBDD</italic> data structure to support their algorithms.</p>
    <fig id="pone-0060593-g001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0060593.g001</object-id>
      <label>Figure 1</label>
      <caption>
        <title>Attractors in Synchronous/Asynchronous Boolean Networks.</title>
        <p><xref ref-type="fig" rid="pone-0060593-g001">Figure 1</xref>. Diagrams of four types of attractors in Boolean networks. Attractors are outlined by slide boxes, and transient states by dashed boxes. <italic>(a)</italic> A <italic>self loop</italic> is a single state attractor. <italic>(b)</italic> A <italic>simple loop</italic> includes two or more states: each state is connected with only another state, and any two adjacent states differ from each other by only one bit. <italic>(c)</italic> A <italic>syn-complex loop</italic> is similar to <italic>simple loop</italic>, but any two adjacent states differ from each other by more than one bit. <italic>(d)</italic> A <italic>asyn-complex loop</italic> includes multiple interlinked states: each state is connected with more than one states, and there is only one bit difference between any two adjacent states. In Boolean networks, the <italic>self loop</italic> and <italic>simple loop</italic> can be identified in both synchronous Boolean networks and asynchronous Boolean networks. But the <italic>syn-complex loop</italic> only exists in the synchronous Boolean networks, and the <italic>asyn-complex loop</italic> only exists in asynchronous Boolean networks.</p>
      </caption>
      <graphic xlink:href="pone.0060593.g001"/>
    </fig>
    <p>Here, we developed two algorithms to further improve the computation of complex attractors in both SBNs and ABNs. First, based on the works of <italic>Garg et al.</italic>, and <italic>Ay et al.</italic>, we show that iterative computing can be used to accelerate the identification of the attractors of SBNs. Second, we develop a method to compute the <italic>asyn-complex loop (complex loop)</italic> using <italic>syn-complex loop</italic>, which allows us to simplify the computation of attractors of complex loops in ABNs. We have a software package to accomplish our two algorithms which are used to locate attractors of Boolean dynamic networks (for both SBNs and ABNs), with significantly reduced time. The structure of this paper is organized as follows: Section 2 gives the methods to compute attractors and splits them into two subsections. Section 2.1 presents iterative computing attractorsâ theory and its algorithms for SBNs. Section 2.2 proves a novel algorithm to locate attractors of ABNs from attractors of SBNs by asynchronous Boolean translation functions (ABTF). Section 3 tests feasibility and efficiency of our algorithm by several classical experimental benchmarks. Section 4 gives a conclusion and description of the future work.</p>
  </sec>
  <sec sec-type="methods" id="s2">
    <title>Methods</title>
    <p>This section gives two methods to compute attractors in both SBNs and ABNs. The first subsection presents iterative computing attractorsâ theory and its algorithms for SBNs. The second subsection provides a novel algorithm to locate attractors of ABNs from attractors of SBNs by asynchronous Boolean translation functions.</p>
    <sec id="s2a">
      <title>Computing Attractors in Synchronous Boolean Networks</title>
      <p>In a synchronous Boolean network, all nodes update their values simultaneously at consecutive time points <xref rid="pone.0060593-Farrow1" ref-type="bibr">[18]</xref>. In another word, at a given time <inline-formula><inline-graphic xlink:href="pone.0060593.e003.jpg"/></inline-formula>, each node has only one Boolean value: 1 (Active) or 0 (Inhibit) <xref rid="pone.0060593-Zhao1" ref-type="bibr">[19]</xref>. Then, the equation of a synchronous Boolean network with <inline-formula><inline-graphic xlink:href="pone.0060593.e004.jpg"/></inline-formula> nodes is shown as Eq. 1 <xref rid="pone.0060593-Zhao1" ref-type="bibr">[19]</xref>.<disp-formula id="pone.0060593.e005"><graphic xlink:href="pone.0060593.e005.jpg" position="anchor" orientation="portrait"/><label>(1)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pone.0060593.e006.jpg"/></inline-formula> is a node in SBNs, <inline-formula><inline-graphic xlink:href="pone.0060593.e007.jpg"/></inline-formula> represents the Boolean function of node <inline-formula><inline-graphic xlink:href="pone.0060593.e008.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e009.jpg"/></inline-formula> is a state in <inline-formula><inline-graphic xlink:href="pone.0060593.e010.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e011.jpg"/></inline-formula> denotes the universal set with <inline-formula><inline-graphic xlink:href="pone.0060593.e012.jpg"/></inline-formula> different states, <inline-formula><inline-graphic xlink:href="pone.0060593.e013.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e014.jpg"/></inline-formula>. It can be simplified as follows.<disp-formula id="pone.0060593.e015"><graphic xlink:href="pone.0060593.e015.jpg" position="anchor" orientation="portrait"/><label>(2)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pone.0060593.e016.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e017.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e018.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e019.jpg"/></inline-formula> is the synchronous Boolean translation function (SBTF) from <inline-formula><inline-graphic xlink:href="pone.0060593.e020.jpg"/></inline-formula> to <inline-formula><inline-graphic xlink:href="pone.0060593.e021.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0060593.e022.jpg"/></inline-formula> is a subset of <inline-formula><inline-graphic xlink:href="pone.0060593.e023.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0060593.e024.jpg"/></inline-formula> is a set of forward reachable states, which are all the states that can be reached from the states set <inline-formula><inline-graphic xlink:href="pone.0060593.e025.jpg"/></inline-formula> by <inline-formula><inline-graphic xlink:href="pone.0060593.e026.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0060593.e027.jpg"/></inline-formula> is a set of backward reachable states, which are all the states that can reach the states set <inline-formula><inline-graphic xlink:href="pone.0060593.e028.jpg"/></inline-formula> by <inline-formula><inline-graphic xlink:href="pone.0060593.e029.jpg"/></inline-formula>. All the states in <inline-formula><inline-graphic xlink:href="pone.0060593.e030.jpg"/></inline-formula> or <inline-formula><inline-graphic xlink:href="pone.0060593.e031.jpg"/></inline-formula> are different.</p>
      <sec id="s2a1">
        <title>Definition 1</title>
        <p>An Attractor <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>: It is the set of states <inline-formula><inline-graphic xlink:href="pone.0060593.e032.jpg"/></inline-formula>
<italic>such that for all the states</italic>
<inline-formula><inline-graphic xlink:href="pone.0060593.e033.jpg"/></inline-formula>, <italic>their</italic>
<inline-formula><inline-graphic xlink:href="pone.0060593.e034.jpg"/></inline-formula>, <italic>shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref> (a),(b) and (c) in solid line boxes.</italic>
<inline-formula><inline-graphic xlink:href="pone.0060593.e035.jpg"/></inline-formula>
<italic>represents state number of attractor</italic>
<inline-formula><inline-graphic xlink:href="pone.0060593.e036.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0060593.e037.jpg"/></inline-formula>
<italic>is the union set of all the different attractors</italic>
<inline-formula><inline-graphic xlink:href="pone.0060593.e038.jpg"/></inline-formula>
<italic>, that is,</italic>
<inline-formula><inline-graphic xlink:href="pone.0060593.e039.jpg"/></inline-formula>.</p>
      </sec>
      <sec id="s2a2">
        <title>Remark 1</title>
        <p><italic>Definition 1 defines an attractor of a synchronous Boolean network. So similarly, we can define an attractor of an asynchronous Boolean network, when using</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e040.jpg"/></inline-formula><italic>instead of</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e041.jpg"/></inline-formula><italic>, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(a)</xref>,(b) and (d) in solid line boxes.</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e042.jpg"/></inline-formula><italic>represents an asynchronous Boolean translation function which will be introduced in section. We also use</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e043.jpg"/></inline-formula><italic>and</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e044.jpg"/></inline-formula><italic>to represent all the attractors of a synchronous Boolean network and its asynchronous Boolean network, respectively. If a state</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e045.jpg"/></inline-formula><italic>is in an attractor,</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e046.jpg"/></inline-formula><italic>is one of its transient states, where</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e047.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e048.jpg"/></inline-formula><italic>, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref> in dotted line boxes.</italic></p>
        <p>Because an attractor of a Boolean network is not known in advance, a common way to address this problem is setting a randomly chosen state as the initial state and exhaustively searching the entire state space. This approach has been successfully applied in several studies to compute the network attractors using empirically derived biological networks. However, the computational burden of this approach increases exponentially with respect to the number and length of attractors. Thus, it limits the application of this method for large biological networks.</p>
        <p>Due to the recurrent nature of attractors, we reason that iterative computing algorithms can be applied on the Boolean translation functions of SBNs, like <inline-formula><inline-graphic xlink:href="pone.0060593.e049.jpg"/></inline-formula>. An important implication is that identifying all attractors (Definition 1) does not require the computation of the entire state space. This suggests that we can use iterative computing to accelerate the identification of attractors in a given Boolean network. In the following, we present three theorems and their proof for iterative computation. Incorporating these theorems, an algorithm is demonstrated to compute attractors of SBNs.</p>
      </sec>
      <sec id="s2a3">
        <title>Theorems of computing attractors using iterative computing in synchronous boolean networks</title>
        <p>According to Eq. 2, it is easily inferred that <inline-formula><inline-graphic xlink:href="pone.0060593.e050.jpg"/></inline-formula>, where <inline-formula><inline-graphic xlink:href="pone.0060593.e051.jpg"/></inline-formula> is synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e052.jpg"/></inline-formula> after iteratively computing <inline-formula><inline-graphic xlink:href="pone.0060593.e053.jpg"/></inline-formula> three times. Therefore, a simplified form of iterative computational equations is described as below.<disp-formula id="pone.0060593.e054"><graphic xlink:href="pone.0060593.e054.jpg" position="anchor" orientation="portrait"/><label>(3)</label></disp-formula>where <inline-formula><inline-graphic xlink:href="pone.0060593.e055.jpg"/></inline-formula> is <inline-formula><inline-graphic xlink:href="pone.0060593.e056.jpg"/></inline-formula> after <inline-formula><inline-graphic xlink:href="pone.0060593.e057.jpg"/></inline-formula> times iterative computing. <inline-formula><inline-graphic xlink:href="pone.0060593.e058.jpg"/></inline-formula> can compute the state <inline-formula><inline-graphic xlink:href="pone.0060593.e059.jpg"/></inline-formula> to state <inline-formula><inline-graphic xlink:href="pone.0060593.e060.jpg"/></inline-formula> directly instead of <inline-formula><inline-graphic xlink:href="pone.0060593.e061.jpg"/></inline-formula> iterative computing steps by <inline-formula><inline-graphic xlink:href="pone.0060593.e062.jpg"/></inline-formula>. If state <inline-formula><inline-graphic xlink:href="pone.0060593.e063.jpg"/></inline-formula> is same with state <inline-formula><inline-graphic xlink:href="pone.0060593.e064.jpg"/></inline-formula>, that means state <inline-formula><inline-graphic xlink:href="pone.0060593.e065.jpg"/></inline-formula> is in an attractor, which can be located as much as <inline-formula><inline-graphic xlink:href="pone.0060593.e066.jpg"/></inline-formula> steps iterative computation.</p>
      </sec>
      <sec id="s2a4">
        <title>Definition 2</title>
        <p>
          <inline-formula>
            <inline-graphic xlink:href="pone.0060593.e067.jpg"/>
          </inline-formula>
          <italic>it represents the states that will return to themselves after</italic>
          <inline-formula>
            <inline-graphic xlink:href="pone.0060593.e068.jpg"/>
          </inline-formula>
          <italic>iterations, where</italic>
          <inline-formula>
            <inline-graphic xlink:href="pone.0060593.e069.jpg"/>
          </inline-formula>
          <italic>. This can be described by Eq. 4.</italic>
          <disp-formula id="pone.0060593.e070">
            <graphic xlink:href="pone.0060593.e070.jpg" position="anchor" orientation="portrait"/>
            <label>(4)</label>
          </disp-formula>
        </p>
        <p>Definition 2 gives a simplified description of attractors, whose states could return to themselves after finite iterations. A shallow example can be supposed that, in a synchronous Boolean network, there are two attractors with length of 1 and 3 respectively. <inline-formula><inline-graphic xlink:href="pone.0060593.e071.jpg"/></inline-formula> is the sum of the two attractors. Because the attractor whose length is 1 could also return to itself after 3 iterations. This feature can be proved by Theorem 1.</p>
      </sec>
      <sec id="s2a5">
        <title>Theorem 1</title>
        <p>
          <italic>For all <inline-formula><inline-graphic xlink:href="pone.0060593.e072.jpg"/></inline-formula>, if <inline-formula><inline-graphic xlink:href="pone.0060593.e073.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e074.jpg"/></inline-formula> (<inline-formula><inline-graphic xlink:href="pone.0060593.e075.jpg"/></inline-formula> is a factor of <inline-formula><inline-graphic xlink:href="pone.0060593.e076.jpg"/></inline-formula>), then, <inline-formula><inline-graphic xlink:href="pone.0060593.e077.jpg"/></inline-formula>.</italic>
        </p>
        <sec id="s2a5a">
          <title>Proof</title>
          <p>Let <inline-formula><inline-graphic xlink:href="pone.0060593.e078.jpg"/></inline-formula>
<disp-formula id="pone.0060593.e079"><graphic xlink:href="pone.0060593.e079.jpg" position="anchor" orientation="portrait"/></disp-formula>
<disp-formula id="pone.0060593.e080"><graphic xlink:href="pone.0060593.e080.jpg" position="anchor" orientation="portrait"/></disp-formula>
<disp-formula id="pone.0060593.e081"><graphic xlink:href="pone.0060593.e081.jpg" position="anchor" orientation="portrait"/></disp-formula>
<disp-formula id="pone.0060593.e082"><graphic xlink:href="pone.0060593.e082.jpg" position="anchor" orientation="portrait"/></disp-formula>
</p>
          <p>According to Theorem 1, a set of attractors, whose length is <inline-formula><inline-graphic xlink:href="pone.0060593.e083.jpg"/></inline-formula>, can be located after <inline-formula><inline-graphic xlink:href="pone.0060593.e084.jpg"/></inline-formula> steps of iterative computing, shown as Eq. 5.<disp-formula id="pone.0060593.e085"><graphic xlink:href="pone.0060593.e085.jpg" position="anchor" orientation="portrait"/><label>(5)</label></disp-formula>
</p>
          <p>If a synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e086.jpg"/></inline-formula> is same with <inline-formula><inline-graphic xlink:href="pone.0060593.e087.jpg"/></inline-formula>, that means all the states can return to themselves by less than <inline-formula><inline-graphic xlink:href="pone.0060593.e088.jpg"/></inline-formula> iterations. This is an important character to identify the numerous attractors in the SBNs, which has been proved by Theorem 2 and 3.</p>
        </sec>
      </sec>
      <sec id="s2a6">
        <title>Theorem 2</title>
        <p>
          <italic>Given a synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e089.jpg"/></inline-formula> with <inline-formula><inline-graphic xlink:href="pone.0060593.e090.jpg"/></inline-formula> nodes, after <inline-formula><inline-graphic xlink:href="pone.0060593.e091.jpg"/></inline-formula> iterations, if <inline-formula><inline-graphic xlink:href="pone.0060593.e092.jpg"/></inline-formula>, the period of this synchronous Boolean network is <inline-formula><inline-graphic xlink:href="pone.0060593.e093.jpg"/></inline-formula>, where <inline-formula><inline-graphic xlink:href="pone.0060593.e094.jpg"/></inline-formula>.</italic>
        </p>
        <sec id="s2a6a">
          <title>Proof</title>
          <p>
            <italic>We need to prove</italic>
            <inline-formula>
              <inline-graphic xlink:href="pone.0060593.e095.jpg"/>
            </inline-formula>
            <disp-formula id="pone.0060593.e096">
              <graphic xlink:href="pone.0060593.e096.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e097">
              <graphic xlink:href="pone.0060593.e097.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e098">
              <graphic xlink:href="pone.0060593.e098.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e099">
              <graphic xlink:href="pone.0060593.e099.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e100">
              <graphic xlink:href="pone.0060593.e100.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e101">
              <graphic xlink:href="pone.0060593.e101.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e102">
              <graphic xlink:href="pone.0060593.e102.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
          </p>
          <p><inline-formula><inline-graphic xlink:href="pone.0060593.e103.jpg"/></inline-formula><italic>The period of this synchronous Boolean network is</italic><inline-formula><inline-graphic xlink:href="pone.0060593.e104.jpg"/></inline-formula>.</p>
        </sec>
      </sec>
      <sec id="s2a7">
        <title>Theorem 3</title>
        <p>
          <italic>Given a synchronous translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e105.jpg"/></inline-formula> with <inline-formula><inline-graphic xlink:href="pone.0060593.e106.jpg"/></inline-formula> nodes, after <inline-formula><inline-graphic xlink:href="pone.0060593.e107.jpg"/></inline-formula> iterations, if <inline-formula><inline-graphic xlink:href="pone.0060593.e108.jpg"/></inline-formula>, all the states are in attractors.</italic>
        </p>
        <sec id="s2a7a">
          <title>Proof</title>
          <p>
            <disp-formula id="pone.0060593.e109">
              <graphic xlink:href="pone.0060593.e109.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e110">
              <graphic xlink:href="pone.0060593.e110.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e111">
              <graphic xlink:href="pone.0060593.e111.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
            <disp-formula id="pone.0060593.e112">
              <graphic xlink:href="pone.0060593.e112.jpg" position="anchor" orientation="portrait"/>
            </disp-formula>
          </p>
        </sec>
      </sec>
      <sec id="s2a8">
        <title>An improved algorithm to compute attractors in synchronous boolean networks</title>
        <p>Combining iterative computing (Theorem 1, 2, 3 and Eq. 5) and the ROBDD data structure, we have developed Algorithm 1 to compute attractors in SBNs. The input of Algorithm 1 is the synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e113.jpg"/></inline-formula>; its output is states of attractors (<inline-formula><inline-graphic xlink:href="pone.0060593.e114.jpg"/></inline-formula>) and number of all attractors (<inline-formula><inline-graphic xlink:href="pone.0060593.e115.jpg"/></inline-formula>). Specifically, Algorithm 1 starts with an initializing part, which initializes all the necessary variables. This is followed by a resolving part, which computes and deletes redundant attractors in a network. The resolving part further contains four components. The first component (Lines 12â13) will continue the next iterative computing and delete the visited attractors based on Theorem 1 and Eq. 5. The second component (Lines 15â20) judges whether synchronous Boolean translation functions are periodic or not, which has been proved by Theorem 2 and 3. The third component (Lines 22â27) verifies whether there will be a new attractor generated after one iteration. That is, if existing a new attractor, Algorithm 1 will add it into attractors (<inline-formula><inline-graphic xlink:href="pone.0060593.e116.jpg"/></inline-formula>). Meanwhile, it will also update the attractorsâ number (<inline-formula><inline-graphic xlink:href="pone.0060593.e117.jpg"/></inline-formula>) and continue the next iteration. If not, Algorithm 1 will go to the next iterative computing. The last component (Lines 11, 29) contains the fix-point condition. When satisfying this condition, it will output attractors and number of attractors. For more detailed information, please read the Algorithms 1.</p>
        <p>In the initializing part, <inline-formula><inline-graphic xlink:href="pone.0060593.e118.jpg"/></inline-formula> is the times of iterations. <inline-formula><inline-graphic xlink:href="pone.0060593.e119.jpg"/></inline-formula> is an empty set. <inline-formula><inline-graphic xlink:href="pone.0060593.e120.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e121.jpg"/></inline-formula> are the attractors and number of attractors, respectively. <inline-formula><inline-graphic xlink:href="pone.0060593.e122.jpg"/></inline-formula> is the fix-point condition to judge whether the algorithm can be terminated or not. <inline-formula><inline-graphic xlink:href="pone.0060593.e123.jpg"/></inline-formula> represents the states that will return to themselves after <inline-formula><inline-graphic xlink:href="pone.0060593.e124.jpg"/></inline-formula> iterations by synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e125.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0060593.e126.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e127.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e128.jpg"/></inline-formula> are ROBDD data structures. In the main resolving part, <inline-formula><inline-graphic xlink:href="pone.0060593.e129.jpg"/></inline-formula> represents state number of <inline-formula><inline-graphic xlink:href="pone.0060593.e130.jpg"/></inline-formula>. <inline-formula><inline-graphic xlink:href="pone.0060593.e131.jpg"/></inline-formula> are all the states that can reach to <inline-formula><inline-graphic xlink:href="pone.0060593.e132.jpg"/></inline-formula> by synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e133.jpg"/></inline-formula>.</p>
        <p>Algorithm 1 is different with <italic>Garg et al.</italic>, which randomly picks up a state from state space and computes its forward reachable states to get an attractor. If you want to find out the attractors whose length is <inline-formula><inline-graphic xlink:href="pone.0060593.e134.jpg"/></inline-formula>, it needs to exhaustively search the state space. However, our algorithm can easily compute the same attractors in <inline-formula><inline-graphic xlink:href="pone.0060593.e135.jpg"/></inline-formula> times iterative computing.</p>
        <boxed-text position="float" orientation="portrait">
          <sec id="s2a8a1">
            <title>Algorithm 1: Iterative Computing Attractors on Synchronous Boolean Translation Function</title>
            <p><bold>Function:</bold><inline-formula><inline-graphic xlink:href="pone.0060593.e136.jpg"/></inline-formula> will compute all the attractors of SBTF iteratively;</p>
            <p><bold>Input:</bold> The synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e137.jpg"/></inline-formula>;</p>
            <p><bold>Output:</bold> All attractors (<inline-formula><inline-graphic xlink:href="pone.0060593.e138.jpg"/></inline-formula>) and number of attractors (<inline-formula><inline-graphic xlink:href="pone.0060593.e139.jpg"/></inline-formula>);</p>
            <p>
              <bold>1 begin</bold>
            </p>
            <p><bold>2</bold>//Initializing part</p>
            <p>
              <bold>3</bold>
              <bold>begin</bold>
            </p>
            <p><bold>4</bold>âââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e140.jpg"/></inline-formula>
<inline-formula><inline-graphic xlink:href="pone.0060593.e141.jpg"/></inline-formula> is times of iteration</p>
            <p><bold>5</bold>âââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e142.jpg"/></inline-formula> //<inline-formula><inline-graphic xlink:href="pone.0060593.e143.jpg"/></inline-formula> is the number of attractors</p>
            <p><bold>6</bold>âââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e144.jpg"/></inline-formula>
<inline-formula><inline-graphic xlink:href="pone.0060593.e145.jpg"/></inline-formula> is a set of attractors</p>
            <p><bold>7</bold>âââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e146.jpg"/></inline-formula>
<inline-formula><inline-graphic xlink:href="pone.0060593.e147.jpg"/></inline-formula> is a set of unvisited states</p>
            <p><bold>8</bold>âââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e148.jpg"/></inline-formula> Initialize <inline-formula><inline-graphic xlink:href="pone.0060593.e149.jpg"/></inline-formula> as empty set</p>
            <p>
              <bold>9</bold>
              <bold>end</bold>
            </p>
            <p><bold>10</bold>â//Main resolving part</p>
            <p>
              <bold>11</bold>
              <bold>while</bold>
              <inline-formula>
                <inline-graphic xlink:href="pone.0060593.e150.jpg"/>
              </inline-formula>
              <bold>do</bold>
            </p>
            <p><bold>12</bold>ââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e151.jpg"/></inline-formula>One iterative computing</p>
            <p><bold>13</bold>ââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e152.jpg"/></inline-formula> //Delete the visited attractors as Theorem 1 &amp; Eq. 5</p>
            <p><bold>14</bold>ââââ//This part is equivalence with Theorem 2 and 3</p>
            <p>
              <bold>15ââââif<inline-formula><inline-graphic xlink:href="pone.0060593.e153.jpg"/></inline-formula>then</bold>
            </p>
            <p><bold>16</bold>âââââââreport attractors <inline-formula><inline-graphic xlink:href="pone.0060593.e154.jpg"/></inline-formula> and its number <inline-formula><inline-graphic xlink:href="pone.0060593.e155.jpg"/></inline-formula>
</p>
            <p><bold>17</bold>âââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e156.jpg"/></inline-formula> //Update the value of</p>
            <p><bold>18</bold>âââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e157.jpg"/></inline-formula> //All states are in attractors by Theorem 2 and 3</p>
            <p><bold>19</bold>âââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e158.jpg"/></inline-formula> Exit the while loop</p>
            <p>
              <bold>20ââââend</bold>
            </p>
            <p><bold>21</bold>ââââââ//If existing unvisited attractors, record them</p>
            <p>
              <bold>22ââââif<inline-formula><inline-graphic xlink:href="pone.0060593.e159.jpg"/></inline-formula></bold>
              <bold>then</bold>
            </p>
            <p><bold>23</bold>ââââââreport attractors <inline-formula><inline-graphic xlink:href="pone.0060593.e160.jpg"/></inline-formula> and its number <inline-formula><inline-graphic xlink:href="pone.0060593.e161.jpg"/></inline-formula>
</p>
            <p><bold>24</bold>ââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e162.jpg"/></inline-formula> //Update the value of <inline-formula><inline-graphic xlink:href="pone.0060593.e163.jpg"/></inline-formula>
</p>
            <p><bold>25</bold>ââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e164.jpg"/></inline-formula> //Add the new attractors into <inline-formula><inline-graphic xlink:href="pone.0060593.e165.jpg"/></inline-formula>
</p>
            <p><bold>26</bold>ââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e166.jpg"/></inline-formula> //<inline-formula><inline-graphic xlink:href="pone.0060593.e167.jpg"/></inline-formula> deletes the states can reach <inline-formula><inline-graphic xlink:href="pone.0060593.e168.jpg"/></inline-formula>
</p>
            <p><bold>27</bold>âââ
<bold>end.</bold>
</p>
            <p>
              <bold>28âend.</bold>
            </p>
            <p><bold>29âreturn</bold><inline-formula><inline-graphic xlink:href="pone.0060593.e169.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e170.jpg"/></inline-formula>;</p>
            <p>
              <bold>30 end.</bold>
            </p>
          </sec>
        </boxed-text>
      </sec>
    </sec>
    <sec id="s2b">
      <title>Computing Attractors in Asynchronous Boolean Networks</title>
      <p>As mentioned earlier, SBNs and ABNs differ in nodes updating schemes of Boolean translation functions. Instead of updating values of all the nodes simultaneously, ABNs only allow some of the nodes to update their values at a time point. For this reason, the computing of attractors in ABNs is more time consuming. Especially, it needs more intermediate steps when there are more than one bit different between two states.</p>
      <sec id="s2b1">
        <title>Analysis of attractors in asynchronous boolean networks</title>
        <p>It is essential to give a simple description of types of attractors. As represented in <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref>, there are four types of attractors, <italic>self loop</italic>, <italic>simple loop</italic>, <italic>syn-complex loop</italic> and <italic>asyn-complex loop</italic> in both SBNs and ABNs. A <italic>self loop</italic> is a single state attractor, shown in <xref ref-type="fig" rid="pone-0060593-g001">Fig.1</xref> (a). A <italic>simple loop</italic> includes two or more states, where every state is connected with only another state, and any two adjacent states differ from each other by only one bit, shown in <xref ref-type="fig" rid="pone-0060593-g001">Fig.1</xref> (b). A <italic>syn-complex loop</italic> is similar to <italic>simple loop</italic>, but any two adjacent states differ from each other by more than one bit, shown in <xref ref-type="fig" rid="pone-0060593-g001">Fig.1</xref> (c). A <italic>asyn-complex loop</italic> includes multiple interlinked states: every state is connected with more than one states, and there is only one bit different between any two adjacent states, shown in <xref ref-type="fig" rid="pone-0060593-g001">Fig.1</xref> (d). <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref> (a)(b)(c) and <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref> (a)(b)(d) stand for the different types of attractors in SBNs and ABNs, respectively.</p>
        <p>According to the properties of <italic>self loops</italic> and <italic>simple loops</italic>, they can easily be identified in SBNs, which also are same in ABNs. Interestingly, a closer examination of the structure of the <italic>syn-complex loops</italic> and <italic>asyn-complex loops</italic> suggests that every <italic>asyn-complex loop</italic> contains one <italic>syn-complex loop</italic> or some <italic>transient states</italic>. This suggests that it is possible to use <italic>syn-complex loop</italic> to easily locate the states in <italic>asyn-complex_loop</italic> by asynchronous Boolean translation functions.</p>
        <p>One example is shown in <xref ref-type="fig" rid="pone-0060593-g002">Fig. 2</xref>, here <inline-formula><inline-graphic xlink:href="pone.0060593.e171.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e172.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e173.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e174.jpg"/></inline-formula>. <xref ref-type="fig" rid="pone-0060593-g002">Fig. 2(a)</xref> is an asynchronous attractor, where the current state and its next states are different by one bit. Suppose that the <inline-formula><inline-graphic xlink:href="pone.0060593.e175.jpg"/></inline-formula> bit of the state <inline-formula><inline-graphic xlink:href="pone.0060593.e176.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e177.jpg"/></inline-formula> is different. If <inline-formula><inline-graphic xlink:href="pone.0060593.e178.jpg"/></inline-formula>, it means that state <inline-formula><inline-graphic xlink:href="pone.0060593.e179.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e180.jpg"/></inline-formula> are the same. The situation is also true for <inline-formula><inline-graphic xlink:href="pone.0060593.e181.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e182.jpg"/></inline-formula>. If state <inline-formula><inline-graphic xlink:href="pone.0060593.e183.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e184.jpg"/></inline-formula> are different at the <inline-formula><inline-graphic xlink:href="pone.0060593.e185.jpg"/></inline-formula> bit, then state <inline-formula><inline-graphic xlink:href="pone.0060593.e186.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e187.jpg"/></inline-formula> must differ at the <inline-formula><inline-graphic xlink:href="pone.0060593.e188.jpg"/></inline-formula> bit. Otherwise, state <inline-formula><inline-graphic xlink:href="pone.0060593.e189.jpg"/></inline-formula> cannot reach state <inline-formula><inline-graphic xlink:href="pone.0060593.e190.jpg"/></inline-formula> by changing one bit. When state <inline-formula><inline-graphic xlink:href="pone.0060593.e191.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e192.jpg"/></inline-formula> differ at the <inline-formula><inline-graphic xlink:href="pone.0060593.e193.jpg"/></inline-formula> bit, state <inline-formula><inline-graphic xlink:href="pone.0060593.e194.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e195.jpg"/></inline-formula> will be different at the <inline-formula><inline-graphic xlink:href="pone.0060593.e196.jpg"/></inline-formula> bit, and vice versa. <xref ref-type="fig" rid="pone-0060593-g002">Fig. 2(b)</xref> shows the corresponding synchronous attractor to <xref ref-type="fig" rid="pone-0060593-g002">Fig. 2(a)</xref>. The difference is that state <inline-formula><inline-graphic xlink:href="pone.0060593.e197.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e198.jpg"/></inline-formula> differ in the <inline-formula><inline-graphic xlink:href="pone.0060593.e199.jpg"/></inline-formula> and bits simultaneously. Other relations are the same except for state <inline-formula><inline-graphic xlink:href="pone.0060593.e200.jpg"/></inline-formula>. Therefore, an <italic>asyn-complex_loop</italic> contains one <italic>syn-complex loop</italic> or some <italic>transient states</italic>. That means we can use <italic>syn-complex loop</italic> to easily locate the states in <italic>asyn-complex_loop</italic> by asynchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e201.jpg"/></inline-formula>.</p>
        <fig id="pone-0060593-g002" orientation="portrait" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pone.0060593.g002</object-id>
          <label>Figure 2</label>
          <caption>
            <title>An Asynchronous Attractor to Synchronous Attractor.</title>
            <p><xref ref-type="fig" rid="pone-0060593-g002">Figure 2</xref>. Diagrams of an attractor in asynchronous (a) and synchronous (b) Boolean networks. Each state is represented by a circle, and is designated as <inline-formula><inline-graphic xlink:href="pone.0060593.e202.jpg"/></inline-formula>. The variable <inline-formula><inline-graphic xlink:href="pone.0060593.e203.jpg"/></inline-formula> represents that the <inline-formula><inline-graphic xlink:href="pone.0060593.e204.jpg"/></inline-formula> bit of the state <inline-formula><inline-graphic xlink:href="pone.0060593.e205.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e206.jpg"/></inline-formula> is different, which is also same as <inline-formula><inline-graphic xlink:href="pone.0060593.e207.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e208.jpg"/></inline-formula>. The numbers <inline-formula><inline-graphic xlink:href="pone.0060593.e209.jpg"/></inline-formula> indicate that state <inline-formula><inline-graphic xlink:href="pone.0060593.e210.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e211.jpg"/></inline-formula> differ by the <inline-formula><inline-graphic xlink:href="pone.0060593.e212.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e213.jpg"/></inline-formula> bits respectively. The <inline-formula><inline-graphic xlink:href="pone.0060593.e214.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e215.jpg"/></inline-formula> represents when state <inline-formula><inline-graphic xlink:href="pone.0060593.e216.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e217.jpg"/></inline-formula> differ at the <inline-formula><inline-graphic xlink:href="pone.0060593.e218.jpg"/></inline-formula> bit, state <inline-formula><inline-graphic xlink:href="pone.0060593.e219.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e220.jpg"/></inline-formula> will be different at the <inline-formula><inline-graphic xlink:href="pone.0060593.e221.jpg"/></inline-formula> bit, and vice versa. The difference between the two representations (i.e. synchronous versus asynchronous) of the attractor is that <inline-formula><inline-graphic xlink:href="pone.0060593.e222.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e223.jpg"/></inline-formula> differ in the <inline-formula><inline-graphic xlink:href="pone.0060593.e224.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e225.jpg"/></inline-formula> bits, <inline-formula><inline-graphic xlink:href="pone.0060593.e226.jpg"/></inline-formula>. That means we can use <italic>syn-complex loop</italic> to easily locate the states in <italic>asyn-complex_loop</italic> by asynchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e227.jpg"/></inline-formula>.</p>
          </caption>
          <graphic xlink:href="pone.0060593.g002"/>
        </fig>
      </sec>
      <sec id="s2b2">
        <title>An algorithm to compute attractors in asynchronous boolean networks</title>
        <p>An important implication of the above analysis is that the attractors of the ABNs can be derived from the attractors of the SBNs using synchronous and asynchronous Boolean translation functions. Therefore, we use attractors computed by Algorithm 1 in SBNs as the basis input for the new algorithm (Algorithm 2) to compute attractors of ABNs.</p>
        <p>Specifically, Algorithm 2 can be divided into three parts: initializing part (Lines 3â6), main resolving part (Lines 8â41) and checking unvisited states part (Lines 44â52). The initializing part also initializes all necessary variables in Algorithm 2. The main resolving part also can be split into five components. The first component (Lines 11â15) means <inline-formula><inline-graphic xlink:href="pone.0060593.e228.jpg"/></inline-formula> is a <italic>self loop</italic>. The second component (Lines 18â21) means <inline-formula><inline-graphic xlink:href="pone.0060593.e229.jpg"/></inline-formula> is a <italic>simple loop</italic>. The third component (Lines 24â29) means <inline-formula><inline-graphic xlink:href="pone.0060593.e230.jpg"/></inline-formula> is an unvisited <italic>asyn-complex loop</italic> and <inline-formula><inline-graphic xlink:href="pone.0060593.e231.jpg"/></inline-formula> is an unvisited <italic>syn-complex loop</italic>. The forth component (Lines 32â34) means <inline-formula><inline-graphic xlink:href="pone.0060593.e232.jpg"/></inline-formula> is a visited <italic>asyn-complex loop</italic> and <inline-formula><inline-graphic xlink:href="pone.0060593.e233.jpg"/></inline-formula> is an unvisited <italic>syn-complex loop</italic>. The fifth component (Lines 37â40) means <inline-formula><inline-graphic xlink:href="pone.0060593.e234.jpg"/></inline-formula> is the set of <italic>transient states</italic> and <inline-formula><inline-graphic xlink:href="pone.0060593.e235.jpg"/></inline-formula> is an unvisited <italic>syn-complex loop</italic>. After the main resolving part, if there exists unvisited states, Algorithm 2 will go to the checking unvisited states part. This part will check the unvisited states and report the left <italic>asyn-complex loops</italic>. For more detailed information, please read the Algorithms 2.</p>
        <p>Furthermore, in the initializing part, <inline-formula><inline-graphic xlink:href="pone.0060593.e236.jpg"/></inline-formula> is a state, <inline-formula><inline-graphic xlink:href="pone.0060593.e237.jpg"/></inline-formula> is an empty set, <inline-formula><inline-graphic xlink:href="pone.0060593.e238.jpg"/></inline-formula> is a set of recording unvisited states by <inline-formula><inline-graphic xlink:href="pone.0060593.e239.jpg"/></inline-formula>, <inline-formula><inline-graphic xlink:href="pone.0060593.e240.jpg"/></inline-formula> is the universal set. In the main resolving part and checking unvisited part, <inline-formula><inline-graphic xlink:href="pone.0060593.e241.jpg"/></inline-formula> represents picking up anyone state from attractors <inline-formula><inline-graphic xlink:href="pone.0060593.e242.jpg"/></inline-formula> of SBNs. <inline-formula><inline-graphic xlink:href="pone.0060593.e243.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e244.jpg"/></inline-formula> are the reachable states from <inline-formula><inline-graphic xlink:href="pone.0060593.e245.jpg"/></inline-formula> by synchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e246.jpg"/></inline-formula> and asynchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e247.jpg"/></inline-formula>, respectively. <inline-formula><inline-graphic xlink:href="pone.0060593.e248.jpg"/></inline-formula> is the reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e249.jpg"/></inline-formula> by asynchronous Boolean translation function <inline-formula><inline-graphic xlink:href="pone.0060593.e250.jpg"/></inline-formula>. We note that, our approach of identifying attractors is totaly different with <italic>Gary et al.</italic> and <italic>Ay et al</italic>. It is more efficient to compute the <italic>asyn-complex loop</italic> because it can easily locate the states in <inline-formula><inline-graphic xlink:href="pone.0060593.e251.jpg"/></inline-formula>.</p>
        <boxed-text position="float" orientation="portrait">
          <sec id="s2b2a1">
            <title>Algorithm 2: Compute and classify Four Types Attractors</title>
            <p><bold>Function.</bold><inline-formula><inline-graphic xlink:href="pone.0060593.e252.jpg"/></inline-formula> computes and classfies attractors as four types, shown in <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref>;</p>
            <p><bold>Input.</bold> Attractors of SBN(<inline-formula><inline-graphic xlink:href="pone.0060593.e253.jpg"/></inline-formula>), SBTF(<inline-formula><inline-graphic xlink:href="pone.0060593.e254.jpg"/></inline-formula>) and ABTF(<inline-formula><inline-graphic xlink:href="pone.0060593.e255.jpg"/></inline-formula>);</p>
            <p><bold>Output.</bold> Four types attractors (a)(b)(c)(d) of SBTF and ABTF shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1</xref>;</p>
            <p><bold>1</bold>â
<bold>begin</bold>
</p>
            <p><bold>2</bold>ââââââ// Initializing part</p>
            <p><bold>3</bold>ââââââ
<bold>begin</bold>
</p>
            <p><bold>4</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e256.jpg"/></inline-formula> // <inline-formula><inline-graphic xlink:href="pone.0060593.e257.jpg"/></inline-formula> is a state</p>
            <p><bold>5</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e258.jpg"/></inline-formula> / <inline-formula><inline-graphic xlink:href="pone.0060593.e259.jpg"/></inline-formula> is a set of unvisited states by <inline-formula><inline-graphic xlink:href="pone.0060593.e260.jpg"/></inline-formula>
</p>
            <p><bold>6</bold>âââââââ
<bold>end</bold>
</p>
            <p><bold>7</bold>ââââââââ// Main resolving part</p>
            <p><bold>8</bold>âââââââ
<bold>while</bold>
<inline-formula><inline-graphic xlink:href="pone.0060593.e261.jpg"/></inline-formula>
<bold>do</bold>
</p>
            <p><bold>9</bold>ââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e262.jpg"/></inline-formula> // <inline-formula><inline-graphic xlink:href="pone.0060593.e263.jpg"/></inline-formula> is any one state in <inline-formula><inline-graphic xlink:href="pone.0060593.e264.jpg"/></inline-formula>
</p>
            <p><bold>10</bold>ââââââââ// <inline-formula><inline-graphic xlink:href="pone.0060593.e265.jpg"/></inline-formula> is a self loop, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(a)</xref>
</p>
            <p><bold>11</bold>âââââââ
<bold>if</bold> (<inline-formula><inline-graphic xlink:href="pone.0060593.e266.jpg"/></inline-formula>) <bold>then</bold>
</p>
            <p><bold>12</bold>ââââââââââ
<italic>report s is a self loop state</italic>
</p>
            <p><bold>13</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e267.jpg"/></inline-formula> // Delete <inline-formula><inline-graphic xlink:href="pone.0060593.e268.jpg"/></inline-formula> from <inline-formula><inline-graphic xlink:href="pone.0060593.e269.jpg"/></inline-formula>
</p>
            <p><bold>14</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e270.jpg"/></inline-formula> // Delete reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e271.jpg"/></inline-formula>
</p>
            <p>
              <bold>15âââââââend</bold>
            </p>
            <p><bold>16ââââââââ// <inline-formula><inline-graphic xlink:href="pone.0060593.e272.jpg"/></inline-formula></bold> is a simple loop, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(b)</xref>
</p>
            <p><bold>17âââââââeles if</bold> (<inline-formula><inline-graphic xlink:href="pone.0060593.e273.jpg"/></inline-formula>) <bold>then</bold>
</p>
            <p><bold>18</bold>ââââââââââ
<italic>report FR(s, <inline-formula><inline-graphic xlink:href="pone.0060593.e274.jpg"/></inline-formula>) is the simple loop</italic>
<bold>then</bold>
</p>
            <p><bold>19</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e275.jpg"/></inline-formula> // Delete the simple loop from <inline-formula><inline-graphic xlink:href="pone.0060593.e276.jpg"/></inline-formula>
</p>
            <p><bold>20</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e277.jpg"/></inline-formula>//Delete reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e278.jpg"/></inline-formula>
</p>
            <p>
              <bold>21âââââââend</bold>
            </p>
            <p><bold>22</bold>ââââââââ// <inline-formula><inline-graphic xlink:href="pone.0060593.e279.jpg"/></inline-formula> is an unvisited asyn-complex loop, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(d)</xref>
</p>
            <p><bold>23</bold>âââââââ
<bold>eles if</bold>
<inline-formula><inline-graphic xlink:href="pone.0060593.e280.jpg"/></inline-formula>
<bold>then</bold>
</p>
            <p><bold>24</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e281.jpg"/></inline-formula>
<italic>is a asyn-complex loop</italic>
</p>
            <p><bold>25</bold>ââââââââââ// <inline-formula><inline-graphic xlink:href="pone.0060593.e282.jpg"/></inline-formula> is a syn-complex loop, shown as <xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(c)</xref>
</p>
            <p><bold>26</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e283.jpg"/></inline-formula>
<italic>is a syn-complex loop</italic>
</p>
            <p><bold>27</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e284.jpg"/></inline-formula> // Delete the syn-complex loop from <inline-formula><inline-graphic xlink:href="pone.0060593.e285.jpg"/></inline-formula>
</p>
            <p><bold>28</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e286.jpg"/></inline-formula>// Delete reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e287.jpg"/></inline-formula>
</p>
            <p>
              <bold>29âââââââend</bold>
            </p>
            <p><bold>30</bold>âââââââ// <inline-formula><inline-graphic xlink:href="pone.0060593.e288.jpg"/></inline-formula> is an visited asyn-complex loop</p>
            <p><bold>31</bold>âââââââ
<bold>eles if</bold>
<inline-formula><inline-graphic xlink:href="pone.0060593.e289.jpg"/></inline-formula>
<bold>then</bold>
</p>
            <p><bold>32</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e290.jpg"/></inline-formula>
<italic>is a syn-complex loop</italic>
</p>
            <p><bold>33</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e291.jpg"/></inline-formula> // Delete the syn-complex loop from <inline-formula><inline-graphic xlink:href="pone.0060593.e292.jpg"/></inline-formula>
</p>
            <p><bold>34</bold>âââââââ
<bold>end</bold>
</p>
            <p><bold>35</bold>âââââââ// <inline-formula><inline-graphic xlink:href="pone.0060593.e293.jpg"/></inline-formula> are the transient states</p>
            <p>
              <bold>36âââââââelse</bold>
            </p>
            <p><bold>37</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e294.jpg"/></inline-formula>
<italic>is a syn-complex loop</italic>
</p>
            <p><bold>38</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e295.jpg"/></inline-formula> // Delete the syn-complex loop from <inline-formula><inline-graphic xlink:href="pone.0060593.e296.jpg"/></inline-formula>
</p>
            <p><bold>39</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e297.jpg"/></inline-formula>// Delete reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e298.jpg"/></inline-formula>
</p>
            <p><bold>40</bold>âââââââ
<bold>end</bold>
</p>
            <p><bold>41</bold>ââââ
<bold>end</bold>
</p>
            <p><bold>42</bold>âââââ// Checking unvisited states</p>
            <p><bold>43</bold>ââââ
<bold>while</bold>
<inline-formula><inline-graphic xlink:href="pone.0060593.e299.jpg"/></inline-formula>
<bold>do</bold>
</p>
            <p><bold>44</bold>âââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e300.jpg"/></inline-formula> // <inline-formula><inline-graphic xlink:href="pone.0060593.e301.jpg"/></inline-formula> is a state in <inline-formula><inline-graphic xlink:href="pone.0060593.e302.jpg"/></inline-formula>
</p>
            <p><bold>45</bold>âââââââ
<bold>if</bold>
<inline-formula><inline-graphic xlink:href="pone.0060593.e303.jpg"/></inline-formula>
<bold>then</bold>
</p>
            <p><bold>46</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e304.jpg"/></inline-formula>
<italic>is a asyn-complex loop;</italic>
</p>
            <p><bold>47</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e305.jpg"/></inline-formula>// Delete reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e306.jpg"/></inline-formula>
</p>
            <p><bold>48</bold>âââââââ
<bold>end.</bold>
</p>
            <p><bold>49</bold>âââââââ
<bold>else.</bold>
</p>
            <p><bold>50</bold>ââââââââââ
<inline-formula><inline-graphic xlink:href="pone.0060593.e307.jpg"/></inline-formula>// Delete reachable states to <inline-formula><inline-graphic xlink:href="pone.0060593.e308.jpg"/></inline-formula>.</p>
            <p><bold>51</bold>âââââââ
<bold>end.</bold>
</p>
            <p>
              <bold>52ââââend.</bold>
            </p>
            <p>
              <bold>53âend.</bold>
            </p>
          </sec>
        </boxed-text>
      </sec>
    </sec>
  </sec>
  <sec id="s3">
    <title>Results and Discussion</title>
    <p>We have implemented our methodology in a software package called <italic>geneFAtt</italic>, which is based on a ROBDD data structure named BuDDy <xref rid="pone.0060593-LindNielsen1" ref-type="bibr">[21]</xref>. In this package, there are two parts, source code and benchmark. The source code part implements functions of Algorithm 1 (iterative computing attractors in synchronous Boolean networks) and Algorithm 2 (computing and classifying attractors as four types of synchronous Boolean networks and asynchronous Boolean networks). Algorithm 1 computes the attractors of SBNs, which are then used as the input of Algorithm 2 to classify the attractors of ABNs. Because the <italic>self loop</italic> (<xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(a)</xref>) and <italic>simple loop</italic> (<xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(b)</xref>) of SBNs are same with its corresponding type of attractors of ABNs, respectively. We can easily use <italic>syn-complex loops</italic> (<xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(c)</xref>) to locate the <italic>asyn-complex loops</italic> (<xref ref-type="fig" rid="pone-0060593-g001">Fig. 1(d)</xref>) by the asynchronous Boolean translation functions. The benchmark part includes five biological networks, <italic>Mammalian Cell</italic>
<xref rid="pone.0060593-Faur1" ref-type="bibr">[7]</xref>, <italic>T-helper</italic>
<xref rid="pone.0060593-Luis1" ref-type="bibr">[22]</xref>, <italic>Dendritic Cell</italic>
<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>, <italic>T-cell Receptor</italic>
<xref rid="pone.0060593-Klamt1" ref-type="bibr">[23]</xref>, and <italic>Protein-ex</italic>
<xref rid="pone.0060593-Heidel1" ref-type="bibr">[17]</xref>. We ran <italic>geneFAtt</italic> and <italic>genYsis</italic>
<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref> with the five synchronous/asynchronous biological models and have compared their running results.</p>
    <p>As shown in <xref ref-type="table" rid="pone-0060593-t001">Table 1</xref>, the first four biological networks, <italic>Mammalian Cell</italic>
<xref rid="pone.0060593-Faur1" ref-type="bibr">[7]</xref>, <italic>T-helper</italic>
<xref rid="pone.0060593-Luis1" ref-type="bibr">[22]</xref>, <italic>Dendritic Cell</italic>
<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref> and <italic>T-cell Receptor</italic>
<xref rid="pone.0060593-Klamt1" ref-type="bibr">[23]</xref> have been studied in <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>. <italic>Protein-ex</italic> is an extended case from <italic>Heidel et al.</italic>
<xref rid="pone.0060593-Heidel1" ref-type="bibr">[17]</xref>. It also represents a kind of biological networks that all the states are in attractors. Because we adopt to the same methods of modeling the SBNs and ABNs to setup the synchronous and asynchronous Boolean translation functions refereed to <italic>Garg et al.</italic> Meanwhile, using the same inputs, <italic>geneFAtt</italic> can obtain the same attractors as those by <italic>genYsis</italic>
<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref> shown in <xref ref-type="table" rid="pone-0060593-t001">Table 1</xref>, which suggests that our algorithms are valid for the analysis of biological networks.</p>
    <table-wrap id="pone-0060593-t001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0060593.t001</object-id>
      <label>Table 1</label>
      <caption>
        <title>Characters of Five Different Biological Networks.</title>
      </caption>
      <alternatives>
        <graphic id="pone-0060593-t001-1" xlink:href="pone.0060593.t001"/>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col align="left" span="1"/>
            <col align="center" span="1"/>
            <col align="center" span="1"/>
            <col align="center" span="1"/>
            <col align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <td align="left" rowspan="1" colspan="1">Benchmark</td>
              <td colspan="4" align="left" rowspan="1">Attractorsâ Number</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">Self Loop</td>
              <td align="left" rowspan="1" colspan="1">Simple Loop</td>
              <td align="left" rowspan="1" colspan="1">Syn-complex Loop</td>
              <td align="left" rowspan="1" colspan="1">Asyn-complex Loop</td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">Mammalian Cell</td>
              <td align="left" rowspan="1" colspan="1">1</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">1</td>
              <td align="left" rowspan="1" colspan="1">1</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">T-helper</td>
              <td align="left" rowspan="1" colspan="1">3</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Dendritic Cell</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">1</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">0</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">T-cell Receptor</td>
              <td align="left" rowspan="1" colspan="1">1</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">9</td>
              <td align="left" rowspan="1" colspan="1">7</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Protein-ex</td>
              <td align="left" rowspan="1" colspan="1">2</td>
              <td align="left" rowspan="1" colspan="1">0</td>
              <td align="left" rowspan="1" colspan="1">4114</td>
              <td align="left" rowspan="1" colspan="1">0</td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <p>With the same validity, <italic>geneFAtt</italic> shows more efficient and feasible compared to <italic>genYsis</italic>. <xref ref-type="table" rid="pone-0060593-t002">Table 2</xref> gives the running time and running time efficiency ratio (RTER, Eq. 6) of the five biological networks which have been produced by the two procedures <italic>genYsis</italic> and <italic>geneFAtt</italic>. <inline-formula><inline-graphic xlink:href="pone.0060593.e309.jpg"/></inline-formula> and <inline-formula><inline-graphic xlink:href="pone.0060593.e310.jpg"/></inline-formula> represent the running time on every biological network of the two procedures <italic>genYsis</italic> and <italic>geneFAtt</italic>, respectively. All experiments are performed on an IntelÂ® Core<inline-formula><inline-graphic xlink:href="pone.0060593.e311.jpg"/></inline-formula> CPU 4300 1.80 GHz with 2GB memory and a Ubuntu 9.04 Linux server. Importantly, we note that the running time of <italic>geneFAtt</italic> is much more shorter than <italic>genYsis</italic>
<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>. Specifically, compared with <italic>genYsis</italic>, <italic>geneFAtt</italic> improves the running time of <italic>Mammalian Cell</italic>
<xref rid="pone.0060593-Faur1" ref-type="bibr">[7]</xref>, <italic>T-helper</italic>
<xref rid="pone.0060593-Luis1" ref-type="bibr">[22]</xref>, <italic>Dendritic Cell</italic>
<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>, <italic>T-cell Receptor</italic>
<xref rid="pone.0060593-Klamt1" ref-type="bibr">[23]</xref>, and <italic>Protein-ex</italic>
<xref rid="pone.0060593-Heidel1" ref-type="bibr">[17]</xref> by <italic>3.25, 8.19, 116.00, 23.48, and 77.05</italic> times, respectively. Remarkable, <italic>geneFAtt</italic> improves the running time of the Dendritic Cell (<xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>) gene network by a striking <italic>116.00</italic> times.<disp-formula id="pone.0060593.e312"><graphic xlink:href="pone.0060593.e312.jpg" position="anchor" orientation="portrait"/><label>(6)</label></disp-formula>
</p>
    <table-wrap id="pone-0060593-t002" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0060593.t002</object-id>
      <label>Table 2</label>
      <caption>
        <title>Performance Comparison between genYsis <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref> and geneFAtt.</title>
      </caption>
      <alternatives>
        <graphic id="pone-0060593-t002-2" xlink:href="pone.0060593.t002"/>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col align="left" span="1"/>
            <col align="center" span="1"/>
            <col align="center" span="1"/>
            <col align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <td align="left" rowspan="1" colspan="1">Benchmark</td>
              <td colspan="2" align="left" rowspan="1">Time (<italic>sec</italic>)</td>
              <td align="left" rowspan="1" colspan="1">RTER</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1"/>
              <td align="left" rowspan="1" colspan="1">genYsis <xref rid="pone.0060593-Garg1" ref-type="bibr">[10]</xref>
</td>
              <td align="left" rowspan="1" colspan="1">geneFAtt</td>
              <td align="left" rowspan="1" colspan="1"/>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">Mammalian Cell</td>
              <td align="left" rowspan="1" colspan="1">0.102</td>
              <td align="left" rowspan="1" colspan="1">0.024</td>
              <td align="left" rowspan="1" colspan="1">3.25Ã</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">T-helper</td>
              <td align="left" rowspan="1" colspan="1">0.193</td>
              <td align="left" rowspan="1" colspan="1">0.021</td>
              <td align="left" rowspan="1" colspan="1">8.19Ã</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Dendritic Cell</td>
              <td align="left" rowspan="1" colspan="1">0.351</td>
              <td align="left" rowspan="1" colspan="1">0.003</td>
              <td align="left" rowspan="1" colspan="1">116.00Ã</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">T-cell Receptor</td>
              <td align="left" rowspan="1" colspan="1">330.643</td>
              <td align="left" rowspan="1" colspan="1">13.506</td>
              <td align="left" rowspan="1" colspan="1">23.48Ã</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">Protein-ex</td>
              <td align="left" rowspan="1" colspan="1">86.162</td>
              <td align="left" rowspan="1" colspan="1">1.104</td>
              <td align="left" rowspan="1" colspan="1">77.05Ã</td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <sec id="s3a">
      <title>Conclusions</title>
      <p>This paper has addressed a method to compute attractors in SBNs and ABNs. We have developed a new iterative computing algorithm to identify the attractors <inline-formula><inline-graphic xlink:href="pone.0060593.e313.jpg"/></inline-formula> of SBNs. Meanwhile, another computing and classifying algorithm has been proposed to locate the attractors of ABNs rapidly. Our approaches give a significant acceleration of computing and locating attractors in biological networks. It is a big challenge that how to identify attractors in the large biological networks. Based on above research, it is expected that we can find a pathway to resolve this problem from the modeling methods of biological networks.</p>
    </sec>
  </sec>
</body>
<back>
  <ack>
    <p>The authors also would like to express their sincere thanks to Dr. Hsien Hang Shieh and Mr. Rahul Krishnan for their help on the structure of this paper.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0060593-Proulx1">
      <label>1</label>
      <mixed-citation publication-type="journal"><name><surname>Proulx</surname><given-names>S</given-names></name>, <name><surname>Promislow</surname><given-names>D</given-names></name>, <name><surname>Phillips</surname><given-names>P</given-names></name> (<year>2005</year>) <article-title>Network thinking in ecology and evolution</article-title>. <source>Trends in Ecology &amp; Evolution</source>
<volume>20</volume>: <fpage>345</fpage>â<lpage>353</lpage>.<pub-id pub-id-type="pmid">16701391</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Basso1">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Basso</surname><given-names>K</given-names></name>, <name><surname>Margolin</surname><given-names>A</given-names></name>, <name><surname>Stolovitzky</surname><given-names>G</given-names></name>, <name><surname>Klein</surname><given-names>U</given-names></name>, <name><surname>Dalla-Favera</surname><given-names>R</given-names></name>, <etal>et al</etal> (<year>2005</year>) <article-title>Reverse engineering of regulatory networks in human b cells</article-title>. <source>Nature genetics</source>
<volume>37</volume>: <fpage>382</fpage>â<lpage>390</lpage>.<pub-id pub-id-type="pmid">15778709</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Margolin1">
      <label>3</label>
      <mixed-citation publication-type="journal"><name><surname>Margolin</surname><given-names>A</given-names></name>, <name><surname>Nemenman</surname><given-names>I</given-names></name>, <name><surname>Basso</surname><given-names>K</given-names></name>, <name><surname>Wiggins</surname><given-names>C</given-names></name>, <name><surname>Stolovitzky</surname><given-names>G</given-names></name>, <etal>et al</etal> (<year>2006</year>) <article-title>Aracne: an algorithm for the reconstruction of gene regulatory networks in a mammalian cellular context</article-title>. <source>BMC bioinformatics</source>
<volume>7</volume>: <fpage>S7</fpage>.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Hirose1">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Hirose</surname><given-names>O</given-names></name>, <name><surname>Yoshida</surname><given-names>R</given-names></name>, <name><surname>Imoto</surname><given-names>S</given-names></name>, <name><surname>Yamaguchi</surname><given-names>R</given-names></name>, <name><surname>Higuchi</surname><given-names>T</given-names></name>, <etal>et al</etal> (<year>2008</year>) <article-title>Statistical inference of transcriptional module-based gene networks from time course gene expression profiles by using state space models</article-title>. <source>Bioinformatics</source>
<volume>24</volume>: <fpage>932</fpage>â<lpage>942</lpage>.<pub-id pub-id-type="pmid">18292116</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Glass1">
      <label>5</label>
      <mixed-citation publication-type="other">Glass L (1985). Boolean and continuous models for the generation of biological rhythms.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Kauffman1">
      <label>6</label>
      <mixed-citation publication-type="other">Kauffman S (1995) At home in the universe. Oxford University Press New York.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Faur1">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>FaurÃ©</surname><given-names>A</given-names></name>, <name><surname>Naldi</surname><given-names>A</given-names></name>, <name><surname>Chaouiya</surname><given-names>C</given-names></name>, <name><surname>Thieffry</surname><given-names>D</given-names></name> (<year>2006</year>) <article-title>Dynamical analysis of a generic boolean model for the control of the mammalian cell cycle</article-title>. <source>Bioinformatics</source>
<volume>22</volume>: <fpage>e124</fpage>.<pub-id pub-id-type="pmid">16873462</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Remy1">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Remy</surname><given-names>E</given-names></name>, <name><surname>Ruet</surname><given-names>P</given-names></name>, <name><surname>Mendoza</surname><given-names>L</given-names></name>, <name><surname>Thieffry</surname><given-names>D</given-names></name>, <name><surname>Chaouiya</surname><given-names>C</given-names></name> (<year>2006</year>) <article-title>From logical regulatory graphs to standard petri nets: dynamical roles and functionality of feedback circuits</article-title>. <source>Transactions on Computational Systems Biology</source>
<volume>VII</volume>
<fpage>56</fpage>â<lpage>72</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Naldi1">
      <label>9</label>
      <mixed-citation publication-type="other">Naldi A, Thieffry D, Chaouiya C (2007) Decision diagrams for the representation and analysis of logical models of genetic networks. In: Proceedings of the 2007 international conference on Computational methods in systems biology. Springer-Verlag, 233â247.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Garg1">
      <label>10</label>
      <mixed-citation publication-type="journal"><name><surname>Garg</surname><given-names>A</given-names></name>, <name><surname>Di Cara</surname><given-names>A</given-names></name>, <name><surname>Xenarios</surname><given-names>I</given-names></name>, <name><surname>Mendoza</surname><given-names>L</given-names></name>, <name><surname>De Micheli</surname><given-names>G</given-names></name> (<year>2008</year>) <article-title>Synchronous versus asynchronous modeling of gene regulatory networks</article-title>. <source>Bioinformatics</source>
<volume>24</volume>: <fpage>1917</fpage>.<pub-id pub-id-type="pmid">18614585</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Davidich1">
      <label>11</label>
      <mixed-citation publication-type="journal"><name><surname>Davidich</surname><given-names>M</given-names></name>, <name><surname>Bornholdt</surname><given-names>S</given-names></name> (<year>2008</year>) <article-title>Boolean network model predicts cell cycle sequence of fission yeast</article-title>. <source>PLoS One</source>
<volume>3</volume>: <fpage>e1672</fpage>.<pub-id pub-id-type="pmid">18301750</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Harvey1">
      <label>12</label>
      <mixed-citation publication-type="other">Harvey I, Bossomaier T (1997) Time out of joint: Attractors in asynchronous random boolean networks. In: Proceedings of the Fourth European Conference on Artificial Life. MIT Press, Cambridge, 67â75.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Devloo1">
      <label>13</label>
      <mixed-citation publication-type="other">Devloo Vea (2003) Identification of all steady states in large biological systems by logical anslysis. Bull Math Biol : 1025â1051.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Thomas1">
      <label>14</label>
      <mixed-citation publication-type="journal"><name><surname>Thomas</surname><given-names>R</given-names></name> (<year>1991</year>) <article-title>Regulatory networks seen as asynchronous automata: a logical description</article-title>. <source>Journal of Theoretical Biology</source>
<volume>153</volume>: <fpage>1</fpage>â<lpage>23</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Li1">
      <label>15</label>
      <mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>F</given-names></name>, <name><surname>Long</surname><given-names>T</given-names></name>, <name><surname>Lu</surname><given-names>Y</given-names></name>, <name><surname>Ouyang</surname><given-names>Q</given-names></name>, <name><surname>Tang</surname><given-names>C</given-names></name> (<year>2004</year>) <article-title>The yeast cell-cycle network is robustly designed</article-title>. <source>Proceedings of the National Academy of Sciences of the United States of America</source>
<volume>101</volume>: <fpage>4781</fpage>.<pub-id pub-id-type="pmid">15037758</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Ay1">
      <label>16</label>
      <mixed-citation publication-type="journal"><name><surname>Ay</surname><given-names>F</given-names></name>, <name><surname>Xu</surname><given-names>F</given-names></name>, <name><surname>Kahveci</surname><given-names>T</given-names></name> (<year>2009</year>) <article-title>Scalable steady state analysis of boolean biological regulatory networks</article-title>. <source>PloS one</source>
<volume>4</volume>: <fpage>e7992</fpage>.<pub-id pub-id-type="pmid">19956604</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Heidel1">
      <label>17</label>
      <mixed-citation publication-type="journal"><name><surname>Heidel</surname><given-names>J</given-names></name>, <name><surname>Maloney</surname><given-names>J</given-names></name>, <name><surname>Farrow</surname><given-names>C</given-names></name>, <name><surname>Rogers</surname><given-names>J</given-names></name> (<year>2003</year>) <article-title>Finding cycles in synchronous boolean networks with applications to biochemical systems</article-title>. <source>International Journal of Bifurcation and Chaos in Applied Sciences and Engineering</source>
<volume>13</volume>: <fpage>535</fpage>â<lpage>552</lpage>.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Farrow1">
      <label>18</label>
      <mixed-citation publication-type="journal"><name><surname>Farrow</surname><given-names>C</given-names></name>, <name><surname>Heidel</surname><given-names>J</given-names></name>, <name><surname>Maloney</surname><given-names>J</given-names></name>, <name><surname>Rogers</surname><given-names>J</given-names></name> (<year>2004</year>) <article-title>Scalar equations for synchronous boolean networks with biological applications</article-title>. <source>IEEE Transactions on Neural Networks</source>
<volume>15</volume>: <fpage>348</fpage>â<lpage>354</lpage>.<pub-id pub-id-type="pmid">15384528</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Zhao1">
      <label>19</label>
      <mixed-citation publication-type="journal"><name><surname>Zhao</surname><given-names>Q</given-names></name> (<year>2005</year>) <article-title>A remark on âscalar equations for synchronous boolean networks with biological applications by C. Farrow, J. Heidel, J. Maloney, and J. Rogersâ</article-title>. <source>IEEE Transactions on Neural Networks</source>
<volume>16</volume>: <fpage>1715</fpage>â<lpage>1716</lpage>.<pub-id pub-id-type="pmid">16342513</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0060593-Dubrova1">
      <label>20</label>
      <mixed-citation publication-type="other">Dubrova E, Teslenko M, Martinelli A (2005) Kauffman networks: Analysis and applications. In: Proceedings of the 2005 IEEE/ACM International conference on Computer-aided design. IEEE Computer Society, 479â484.</mixed-citation>
    </ref>
    <ref id="pone.0060593-LindNielsen1">
      <label>21</label>
      <mixed-citation publication-type="other">Lind-Nielsen J (2000). Bdd package buddy, v. 1.9, august 2000, <ext-link ext-link-type="uri" xlink:href="http://www.itu.dk/research/buddy/index.html">http://www.itu.dk/research/buddy/index.html</ext-link>.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Luis1">
      <label>22</label>
      <mixed-citation publication-type="other">Luis M, Ioannis X (2006) A method for the generation of standardized qualitative dynamical systems of regulatory networks. Theoretical Biology and Medical Modelling 3.</mixed-citation>
    </ref>
    <ref id="pone.0060593-Klamt1">
      <label>23</label>
      <mixed-citation publication-type="journal"><name><surname>Klamt</surname><given-names>S</given-names></name>, <name><surname>Saez-Rodriguez</surname><given-names>J</given-names></name>, <name><surname>Lindquist</surname><given-names>J</given-names></name>, <name><surname>Simeoni</surname><given-names>L</given-names></name>, <name><surname>Gilles</surname><given-names>E</given-names></name> (<year>2006</year>) <article-title>A methodology for the structural and functional analysis of signaling and regulatory networks</article-title>. <source>BMC bioinformatics</source>
<volume>7</volume>: <fpage>56</fpage>.<pub-id pub-id-type="pmid">16464248</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
