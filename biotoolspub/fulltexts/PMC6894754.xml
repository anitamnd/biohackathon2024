<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 39.96?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">PLoS One</journal-id>
    <journal-id journal-id-type="iso-abbrev">PLoS ONE</journal-id>
    <journal-id journal-id-type="publisher-id">plos</journal-id>
    <journal-id journal-id-type="pmc">plosone</journal-id>
    <journal-title-group>
      <journal-title>PLoS ONE</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1932-6203</issn>
    <publisher>
      <publisher-name>Public Library of Science</publisher-name>
      <publisher-loc>San Francisco, CA USA</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6894754</article-id>
    <article-id pub-id-type="publisher-id">PONE-D-18-16631</article-id>
    <article-id pub-id-type="doi">10.1371/journal.pone.0224784</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Article</subject>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Computational Techniques</subject>
          <subj-group>
            <subject>Computational Pipelines</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Information Technology</subject>
          <subj-group>
            <subject>Data Processing</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Computational Biology</subject>
          <subj-group>
            <subject>Genome Analysis</subject>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Genome Analysis</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and life sciences</subject>
        <subj-group>
          <subject>Molecular biology</subject>
          <subj-group>
            <subject>Molecular biology techniques</subject>
            <subj-group>
              <subject>Sequencing techniques</subject>
              <subj-group>
                <subject>DNA sequencing</subject>
                <subj-group>
                  <subject>Next-Generation Sequencing</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and analysis methods</subject>
        <subj-group>
          <subject>Molecular biology techniques</subject>
          <subj-group>
            <subject>Sequencing techniques</subject>
            <subj-group>
              <subject>DNA sequencing</subject>
              <subj-group>
                <subject>Next-Generation Sequencing</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Computational Biology</subject>
          <subj-group>
            <subject>Genome Analysis</subject>
            <subj-group>
              <subject>Transcriptome Analysis</subject>
              <subj-group>
                <subject>Next-Generation Sequencing</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Genetics</subject>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Genome Analysis</subject>
              <subj-group>
                <subject>Transcriptome Analysis</subject>
                <subj-group>
                  <subject>Next-Generation Sequencing</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Molecular Biology</subject>
          <subj-group>
            <subject>Molecular Biology Techniques</subject>
            <subj-group>
              <subject>Gene Mapping</subject>
              <subj-group>
                <subject>Chromosome Mapping</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and Analysis Methods</subject>
        <subj-group>
          <subject>Molecular Biology Techniques</subject>
          <subj-group>
            <subject>Gene Mapping</subject>
            <subj-group>
              <subject>Chromosome Mapping</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and life sciences</subject>
        <subj-group>
          <subject>Molecular biology</subject>
          <subj-group>
            <subject>Molecular biology techniques</subject>
            <subj-group>
              <subject>Molecular biology assays and analysis techniques</subject>
              <subj-group>
                <subject>Nucleic acid analysis</subject>
                <subj-group>
                  <subject>DNA analysis</subject>
                </subj-group>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Research and analysis methods</subject>
        <subj-group>
          <subject>Molecular biology techniques</subject>
          <subj-group>
            <subject>Molecular biology assays and analysis techniques</subject>
            <subj-group>
              <subject>Nucleic acid analysis</subject>
              <subj-group>
                <subject>DNA analysis</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Cognitive Science</subject>
            <subj-group>
              <subject>Cognition</subject>
              <subj-group>
                <subject>Memory</subject>
              </subj-group>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Biology and Life Sciences</subject>
        <subj-group>
          <subject>Neuroscience</subject>
          <subj-group>
            <subject>Learning and Memory</subject>
            <subj-group>
              <subject>Memory</subject>
            </subj-group>
          </subj-group>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="Discipline-v3">
        <subject>Computer and Information Sciences</subject>
        <subj-group>
          <subject>Data Compression</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>SparkGA2: Production-quality memory-efficient Apache Spark based genome analysis framework</article-title>
      <alt-title alt-title-type="running-head">SparkGA2: Production-quality memory-efficient Apache Spark based genome analysis framework</alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-4129-9056</contrib-id>
        <name>
          <surname>Mushtaq</surname>
          <given-names>Hamid</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Conceptualization</role>
        <role content-type="http://credit.casrai.org/">Formal analysis</role>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Methodology</role>
        <role content-type="http://credit.casrai.org/">Software</role>
        <role content-type="http://credit.casrai.org/">Validation</role>
        <role content-type="http://credit.casrai.org/">Writing – original draft</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ahmed</surname>
          <given-names>Nauman</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Al-Ars</surname>
          <given-names>Zaid</given-names>
        </name>
        <role content-type="http://credit.casrai.org/">Funding acquisition</role>
        <role content-type="http://credit.casrai.org/">Resources</role>
        <role content-type="http://credit.casrai.org/">Supervision</role>
        <role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
        <xref ref-type="aff" rid="aff001"/>
        <xref ref-type="corresp" rid="cor001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff001">
      <addr-line>Quantum and Computer Engineering, Delft University of Technology, Delft, The Netherlands</addr-line>
    </aff>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Melcher</surname>
          <given-names>Ulrich</given-names>
        </name>
        <role>Editor</role>
        <xref ref-type="aff" rid="edit1"/>
      </contrib>
    </contrib-group>
    <aff id="edit1">
      <addr-line>Oklahoma State University, UNITED STATES</addr-line>
    </aff>
    <author-notes>
      <fn fn-type="COI-statement" id="coi001">
        <p><bold>Competing Interests: </bold>The authors have declared that no competing interests exist.</p>
      </fn>
      <corresp id="cor001">* E-mail: <email>z.al-ars@tudelft.nl</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>5</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <volume>14</volume>
    <issue>12</issue>
    <elocation-id>e0224784</elocation-id>
    <history>
      <date date-type="received">
        <day>16</day>
        <month>8</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>22</day>
        <month>10</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© 2019 Mushtaq et al</copyright-statement>
      <copyright-year>2019</copyright-year>
      <copyright-holder>Mushtaq et al</copyright-holder>
      <license xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
      </license>
    </permissions>
    <self-uri content-type="pdf" xlink:href="pone.0224784.pdf"/>
    <abstract>
      <p>Due to the rapid decrease in the cost of NGS (Next Generation Sequencing), interest has increased in using data generated from NGS to diagnose genetic diseases. However, the data generated by NGS technology is usually in the order of hundreds of gigabytes per experiment, thus requiring efficient and scalable programs to perform data analysis quickly. This paper presents SparkGA2, a memory efficient, production quality framework for high performance DNA analysis in the cloud, which can scale according to the available computational resources by increasing the number of nodes. Our framework uses Apache Spark’s ability to cache data in the memory to speed up processing, while also allowing the user to run the framework on systems with lower amounts of memory at the cost of slightly less performance. To manage the memory footprint, we implement an on-the-fly compression method of intermediate data and reduce memory requirements by up to 3x. Our framework also uses a streaming approach to gradually stream input data as processing is taking place. This makes our framework faster than other state of the art approaches while at the same time allowing users to adapt it to run on clusters with lower memory. As compared to the state of the art, SparkGA2 is up to 22% faster on a large big data cluster of 67 nodes and up to 9% faster on a smaller cluster of 6 nodes. Including the streaming solution, where data pre-processing is considered, SparkGA2 is 51% faster on a 6 node cluster. The source code of SparkGA2 is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/HamidMushtaq/SparkGA2">https://github.com/HamidMushtaq/SparkGA2</ext-link>.</p>
    </abstract>
    <funding-group>
      <funding-statement>This work was supported by a Microsoft Azure Sponsorship (e5f5c1c9-0ef8-4179-a58d-5559956983d3) given to Hamid Mushtaq and SURF cooperative (<ext-link ext-link-type="uri" xlink:href="https://www.surf.nl/en/expertises/compute-services">https://www.surf.nl/en/expertises/compute-services</ext-link>) given to Zaid Al-Ars.</funding-statement>
    </funding-group>
    <counts>
      <fig-count count="7"/>
      <table-count count="9"/>
      <page-count count="14"/>
    </counts>
    <custom-meta-group>
      <custom-meta id="data-availability">
        <meta-name>Data Availability</meta-name>
        <meta-value>All relevant data is publicly available as follows: Source code: <ext-link ext-link-type="uri" xlink:href="https://github.com/HamidMushtaq/SparkGA2">https://github.com/HamidMushtaq/SparkGA2</ext-link>. Datasets used: NA12878D_HiSeqX from <ext-link ext-link-type="uri" xlink:href="https://allseq.com/knowledge-bank/1000-genome/get-your-1000-genome-test-data-set/">https://allseq.com/knowledge-bank/1000-genome/get-your-1000-genome-test-data-set/</ext-link>. <ext-link ext-link-type="ftp" xlink:href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194147">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194147</ext-link><ext-link ext-link-type="ftp" xlink:href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194160">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194160</ext-link> Reference files used: We used b37 (For fasta we used the decoy version) from <ext-link ext-link-type="ftp" xlink:href="ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle">ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle</ext-link>. Help on downloading these files can be found on <ext-link ext-link-type="uri" xlink:href="https://gatkforums.broadinstitute.org/gatk/discussion/1215/how-can-i-access-the-gsa-public-ftp-server">https://gatkforums.broadinstitute.org/gatk/discussion/1215/how-can-i-access-the-gsa-public-ftp-server</ext-link>".</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
  <notes>
    <title>Data Availability</title>
    <p>All relevant data is publicly available as follows: Source code: <ext-link ext-link-type="uri" xlink:href="https://github.com/HamidMushtaq/SparkGA2">https://github.com/HamidMushtaq/SparkGA2</ext-link>. Datasets used: NA12878D_HiSeqX from <ext-link ext-link-type="uri" xlink:href="https://allseq.com/knowledge-bank/1000-genome/get-your-1000-genome-test-data-set/">https://allseq.com/knowledge-bank/1000-genome/get-your-1000-genome-test-data-set/</ext-link>. <ext-link ext-link-type="ftp" xlink:href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194147">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194147</ext-link><ext-link ext-link-type="ftp" xlink:href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194160">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194160</ext-link> Reference files used: We used b37 (For fasta we used the decoy version) from <ext-link ext-link-type="ftp" xlink:href="ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle">ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle</ext-link>. Help on downloading these files can be found on <ext-link ext-link-type="uri" xlink:href="https://gatkforums.broadinstitute.org/gatk/discussion/1215/how-can-i-access-the-gsa-public-ftp-server">https://gatkforums.broadinstitute.org/gatk/discussion/1215/how-can-i-access-the-gsa-public-ftp-server</ext-link>".</p>
  </notes>
</front>
<body>
  <sec sec-type="intro" id="sec001">
    <title>Introduction</title>
    <p>DNA sequence analysis has become an important tool used in many kinds of applications from forensics to medicine. The data is usually sequenced using next generation sequencing (NGS) machines, which produce oversampled data, resulting in a large amount of data to process by sequence analysis programs. The size of the whole human genome data produced by these machines is in the range of hundreds of GBs. In order to process this data fast, we need large amounts of computational resources.</p>
    <p>In this paper, we propose a new Apache Spark [<xref rid="pone.0224784.ref001" ref-type="bibr">1</xref>] based framework called SparkGA2 that allows the GATK best-practices pipeline [<xref rid="pone.0224784.ref002" ref-type="bibr">2</xref>] to run efficiently and cost-effectively on a scalable computational cluster. SparkGA2 uses Spark’s in-memory computation capabilities to improve the performance of the framework. We also use compression techniques to lower the memory footprint. In addition, we can configure the framework to require less system memory at the cost of increased runtime. Due to this feature, it can even be run on clusters with limited available RAM. Moreover, it uses the pipeline tools unmodified, meaning that one tool can easily be replaced with another one.</p>
    <p>In the following, we list the contributions of this paper.</p>
    <list list-type="bullet">
      <list-item>
        <p>We implemented an on-the-fly compression method of intermediate data that allows us to decrease the memory footprint by up to 3x.</p>
      </list-item>
      <list-item>
        <p>SparkGA2 is able to trade off performance at the expense of system resource utilization, allowing higher speed with more memory, while still allowing proper functionality with lower amounts of memory.</p>
      </list-item>
      <list-item>
        <p>By improving the efficiency of data access, we reduce reliance on the Hadoop file system and improve performance as compared to state-of-the-art tools, such as SparkGA [<xref rid="pone.0224784.ref003" ref-type="bibr">3</xref>].</p>
      </list-item>
      <list-item>
        <p>We ensured a modular implementation of the framework as three distinct steps that allow us to optimize the Spark runtime parameters for each step.</p>
      </list-item>
    </list>
    <p>This paper is organized as follows. In Section <bold>Background</bold>, we discuss the different stages of the GATK best-practices pipelines and related work. Section <bold>Methods</bold> presents the Apache Spark framework we implemented to enable pipeline scalability. This is followed by Section <bold>Results and discussion</bold>, which discusses the performance and accuracy evaluations. We finally conclude the paper with Section <bold>Conclusions</bold>.</p>
  </sec>
  <sec sec-type="intro" id="sec002">
    <title>Background</title>
    <p>In this section, first we discuss the GATK best-practices pipeline and afterwards discuss related work.</p>
    <sec id="sec003">
      <title>GATK best-practices pipeline</title>
      <p>DNA analysis is done with raw over-sampled sequencing reads obtained from a DNA sequencing machine. Due to oversampling, the sequenced data is quite large, usually in the range of 100s of GB, for the whole genome of a human. A standard way of storing such raw sequenced reads is the FASTQ file format [<xref rid="pone.0224784.ref004" ref-type="bibr">4</xref>].</p>
      <p>GATK best-practices pipeline [<xref rid="pone.0224784.ref002" ref-type="bibr">2</xref>], is an example of a DNA analysis pipeline, where using tools like Bowtie2 [<xref rid="pone.0224784.ref005" ref-type="bibr">5</xref>] or Burrows-Wheeler Aligner (BWA mem) [<xref rid="pone.0224784.ref006" ref-type="bibr">6</xref>], reads are mapped to the corresponding positions of the human genome using a reference genome. Afterwards, multiple copies of the same raw reads are marked as duplicates, by using Picard tools for example. Afterwards, several more steps are performed, such as performing local realignment of reads around indels (Indel realignment), adjusting quality scores of mapped reads (Base recalibration) and discovering all the variants (Haplotype caller), before we get the final output in a VCF file.</p>
      <p>In the pipeline, some of the tools scale very well, such as the mapping tools, while the other tools do not scale as well. Besides that, even the mapping tool cannot run in a distributed fashion on a cluster. Therefore, we have developed a generic framework, which can distribute such computation on a cluster. We achieve that with the help of Apache Spark.</p>
    </sec>
    <sec id="sec004">
      <title>Related work</title>
      <p>One of the earliest big data based DNA analysis frameworks is Churchill [<xref rid="pone.0224784.ref007" ref-type="bibr">7</xref>], which utilizes the available computational resources using a number of proprietary tools in a tightly-integrated computational pipeline. However, the proprietary closed-source nature of the pipeline makes it inaccessible in practice.</p>
      <p>Another example is Halvade [<xref rid="pone.0224784.ref008" ref-type="bibr">8</xref>], which uses the Hadoop MapReduce framework and allows the original unmodified GATK pipeline tools to be used. The pipeline execution is divided into three main parts. First, parallel map tasks are used to perform DNA mapping, the output of which is collected as &lt;chromosomal region, mapped read&gt; key-value pairs. Then a sorting step is performed to reorder the mapped reads according to their location in the genome. The rest of the pipeline is then executed by a set of reduce tasks performing mark duplicates, base recalibration and haplotype calling, and resulting in an output VCF file.</p>
      <p>Since Halvade uses the MapReduce framework, it performs the various steps in the pipeline primarily in disk rather than in memory. This causes an unnecessary disk access penalty as a result of the large genomics data sets used in practice. Secondly, it creates chromosomal regions based on the length of the chromosomes, while not checking the actual number of reads in each region. This causes some regions to become disproportionately larger than others resulting in high bottlenecks in the execution of all regions, as the framework waits for the largest region to finish.</p>
      <p>A couple of efforts [<xref rid="pone.0224784.ref009" ref-type="bibr">9</xref>, <xref rid="pone.0224784.ref010" ref-type="bibr">10</xref>] address the problems with MapReduce based solutions by using a Spark based implementation of the GATK best-practices pipeline. [<xref rid="pone.0224784.ref010" ref-type="bibr">10</xref>] processes the DNA pipeline fully in memory, and thus is able to create chromosomal regions based on the number of reads. However, since its load balancing step is done fully in memory, this results in out of memory errors for large input files. In addition, it does not differentiate between the requirements of the various stages of the GATK pipeline, and runs the whole pipeline as a single run, thereby not fully optimizing system utilization for each stage. [<xref rid="pone.0224784.ref009" ref-type="bibr">9</xref>] on the other hand does not have its source code publicly available.</p>
      <p>As a followup to [<xref rid="pone.0224784.ref010" ref-type="bibr">10</xref>], SparkGA [<xref rid="pone.0224784.ref003" ref-type="bibr">3</xref>] implements a load balancing step that is more memory efficient. In addition, it runs the program in 3 different steps: DNA mapping &amp; static load balancing; sorting &amp; dynamic load balancing; and marking of duplicates and variant discovery. This allows SparkGA to configure each step separately to optimize resource utilization and overall performance. This solution reduces the memory requirements of the load balancing step by dividing the genome into regions and only loading each region into memory one at a time. One drawback of this approach is that it creates too many files after the mapping step, all of which need to be uploaded to HDFS. This significantly impacts the performance on commercial cloud services where access to HDFS can be slow.</p>
      <p>SparkGA2, on the other hand, can adapt the number of files created depending on the available memory in the cluster, which allows for trading off performance for memory requirements. In addition, we reduce the memory footprint by compressing the data before copying it into the memory.</p>
    </sec>
  </sec>
  <sec sec-type="materials|methods" id="sec005">
    <title>Methods</title>
    <p>We created SparkGA2 based on the Apache Spark framework such that it can parallelize the execution of the various stages of the GATK pipeline. Most of the tools used in GATK are executed in SparkGA2 unchanged with the exception of “sorting” and “SAM to BAM conversion”. These tools are replaced with native Spark implementations within our framework. A summary of the used tools is listed in <xref rid="pone.0224784.t001" ref-type="table">Table 1</xref>.</p>
    <table-wrap id="pone.0224784.t001" orientation="portrait" position="float">
      <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t001</object-id>
      <label>Table 1</label>
      <caption>
        <title>Comparison of tools used in GATK best-practices pipeline and SparkGA2.</title>
      </caption>
      <alternatives>
        <graphic id="pone.0224784.t001g" xlink:href="pone.0224784.t001"/>
        <table frame="box" rules="all" border="0">
          <colgroup span="1">
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
            <col align="left" valign="middle" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th align="left" rowspan="1" colspan="1">Step</th>
              <th align="left" rowspan="1" colspan="1">GATK</th>
              <th align="left" rowspan="1" colspan="1">SparkGA2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>Align reads</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">BWA mem</td>
              <td align="left" rowspan="1" colspan="1">BWA mem</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>SAM to BAM</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">Picard</td>
              <td align="left" rowspan="1" colspan="1">Picard’s Java library</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>Sort reads</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">Picard</td>
              <td align="left" rowspan="1" colspan="1">Sorting in Scala</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>Mark duplicates</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">Picard</td>
              <td align="left" rowspan="1" colspan="1">Picard</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>Indel realignment</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">GATK</td>
              <td align="left" rowspan="1" colspan="1">GATK</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>Base recalibration</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">GATK</td>
              <td align="left" rowspan="1" colspan="1">GATK</td>
            </tr>
            <tr>
              <td align="left" rowspan="1" colspan="1">
                <bold>Haplotype caller</bold>
              </td>
              <td align="left" rowspan="1" colspan="1">GATK</td>
              <td align="left" rowspan="1" colspan="1">GATK</td>
            </tr>
          </tbody>
        </table>
      </alternatives>
    </table-wrap>
    <p>In the following, we first discuss the overview of our optimized parallel GATK approach, followed by our mapping and compression approach. Next, we discuss our sorting and system resource tradeoff methods, followed by our method to discover the variants.</p>
    <sec id="sec006">
      <title>Overview</title>
      <p><bold>Algorithm 1</bold> Mapping algorithm</p>
      <p specific-use="line"><bold>procedure</bold> DNAM<sc>apper</sc>R<sc>un</sc>(fileName)</p>
      <p specific-use="line">⊳ <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>content</bold>&gt;</p>
      <p specific-use="line">  <italic>mappedInfo</italic> ← <italic>runMapper</italic>(<italic>fileName</italic>)</p>
      <p specific-use="line">⊳ <bold>Calculate number of reads and compress each bin</bold>. <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>, <bold>compressedContent</bold>&gt;</p>
      <p specific-use="line">  <italic>compressedBins</italic> ← <italic>compressBins</italic>(<italic>mappedInfo</italic>)</p>
      <p specific-use="line">⊳ <bold>Write bins to the HDFS</bold></p>
      <p specific-use="line">  <italic>writeBinsToHDFS</italic>(<italic>compressedBins</italic>, <italic>mapperOutFolderPath</italic>)</p>
      <p specific-use="line">⊳ <bold>Return information</bold>. <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>&gt;</p>
      <p specific-use="line">  <italic>retArray</italic> ← <italic>compressedBins</italic>.<italic>map</italic>(<italic>x</italic> =&gt; (<italic>x</italic>._1, <italic>x</italic>._2))</p>
      <p specific-use="line">⊳ <bold>This RDD simply contains the name of the input fastq chunk files</bold></p>
      <p specific-use="line">  <italic>inputData</italic> ← <italic>sc</italic>.<italic>parallelize</italic>(<italic>getFilesList</italic>(<italic>inputFolderPath</italic>))</p>
      <p specific-use="line">⊳ <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>&gt;</p>
      <p specific-use="line">  <italic>bwaOut</italic> ← <italic>inputData</italic>.<italic>flatMap</italic>(<italic>fileName</italic> =&gt; <italic>DNAMapperRun</italic>(<italic>fileName</italic>))</p>
      <p specific-use="line">  <italic>bwaOutStr</italic> ← <italic>bwaOut</italic>.<italic>map</italic>(<italic>x</italic> =&gt; <italic>x</italic>._1 + “:” + <italic>x</italic>._2)</p>
      <p specific-use="line">  <italic>bwaOutStr</italic>.<italic>saveAsTextFile</italic>(<italic>outputFolderPath</italic> + “<italic>binsInfo</italic>”)</p>
      <p>The dataflow of the execution of SparkGA2 is shown in <xref ref-type="fig" rid="pone.0224784.g001">Fig 1</xref>. In a typical DNA sequencing experiment, two FASTQ files are generated, which represent the two ends of a pair of sequences. These two input FASTQ files are divided into interleaved input FASTQ chunks using a chunk segmentation tool, which also uploads these files to HDFS. Each DNA mapping task takes such a FASTQ chunk as an input and aligns its reads using BWA mem, producing a SAM file that contains the mapped reads in the form of SAM records.</p>
      <fig id="pone.0224784.g001" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g001</object-id>
        <label>Fig 1</label>
        <caption>
          <title>Data flow of SparkGA2.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g001"/>
      </fig>
      <p>The output in our case is a compressed output file containing mapped reads (represented as SAM records) in compressed form, along with some more information. The load balancer would decompress those files and extract the SAM records from them, before putting those SAM records into their corresponding regions. Afterwards, it would sort the SAM records in those regions, before writing them to BAM files, which would then be processed by the last stage of variant discovery.</p>
      <p>The last step is done in a single task for each chromosomal region. Each of these tasks produces a VCF file, all of which are then combined at the end to produce the final VCF file. Unlike [<xref rid="pone.0224784.ref003" ref-type="bibr">3</xref>], where a lot of intermediate files are produced between the first and second step, here we only produce as many files as the number of input FASTQ chunks. This greatly reduces access to the HDFS between those two stages.</p>
      <p>Moreover, our framework allows input data, which is in gzipped FASTQ format, to be streamed directly to the HDFS for the data nodes to start processing. The details of this streaming mechanism are explained in [<xref rid="pone.0224784.ref011" ref-type="bibr">11</xref>].</p>
      <p>We perform the execution in three different steps: 1. mapping; 2. decompression, sorting, and load balancing; and 3. variant discovery. This approach allows us to configure the parameters of each step separately to optimize its performance.</p>
    </sec>
    <sec id="sec007">
      <title>Step 1: Mapping and resource tradeoffs</title>
      <p>The first step of the implementation is the mapping step. Algorithm 1 describes this step, which is illustrated in <xref ref-type="fig" rid="pone.0224784.g002">Fig 2</xref>. In this step, for each input FASTQ chunk, a mapping task, such as BWA mem, is executed. The tasks map short reads to a reference and output this information in the form of SAM records, which are then grouped into bins. Bins here represent parts of chromosomes, according to their positions. For example, if we set the bin size to 5000, it would mean that all SAM records in bin 1 of chromosome 1 would have positions from 0 to 4999 of chromosome 1, while bin 2 would have positions from 5000 to 9999. Once BWA is finished, all these bins are then compressed in parallel, and then written to a file. For each bin, the file contains information about the bin’s region and the length of its content, so that the next step can extract them.</p>
      <fig id="pone.0224784.g002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g002</object-id>
        <label>Fig 2</label>
        <caption>
          <title>Mapping output in SparkGA2.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g002"/>
      </fig>
      <p>Besides these output files, a hash-map is also stored whose keys are binIDs and values are the number of reads in each bin. This information is later used in the load balancing step. Note that the larger the bin size is, the more compact this hash-map becomes. With a bin size of 5000, the size of the hash-map is just a few megabytes.</p>
      <p><bold>Algorithm 2</bold> Load balancing</p>
      <p specific-use="line"><bold>procedure</bold> L<sc>oad</sc>B<sc>alancer</sc>(binsInfoFolderPath)</p>
      <p specific-use="line">⊳ <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>&gt;</p>
      <p specific-use="line">  <italic>binsInfo</italic> ← <italic>getBinsInfo</italic>(<italic>binsInfoFolderPath</italic>)</p>
      <p specific-use="line">⊳ <bold>Sum up the number of reads</bold>. <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>&gt;</p>
      <p specific-use="line">  <italic>numReadsPerBin</italic> ← <italic>binsInfo</italic>.<italic>reduceByKey</italic>(_+ _).<italic>sortByKey</italic>().<italic>cache</italic>()</p>
      <p specific-use="line">⊳ <bold>Sum up the number of reads</bold>. <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>&gt;</p>
      <p specific-use="line">  <italic>avgReadsPerRegion</italic> ← <italic>numReadsPerBin</italic>.<italic>map</italic>(_._2).<italic>reduce</italic>(_+ _)/<italic>numRegions</italic></p>
      <p specific-use="line">⊳ <bold>Sum up the number of reads</bold>. <bold>RDD is of type</bold> &lt;<bold>binID</bold>, <bold>numReads</bold>&gt;</p>
      <p specific-use="line">  <italic>regionsMap</italic> ← <italic>makeRegionsMap</italic>(<italic>numReadsPerBin</italic>, <italic>avgReadsPerBin</italic>)</p>
      <p specific-use="line">⊳ <bold>This RDD simply contains the name of the files made by the DNA mapper part</bold></p>
      <p specific-use="line">  <italic>inputData</italic> ← <italic>sc</italic>.<italic>parallelize</italic>(<italic>getInputFilesList</italic>(<italic>mapperOutFolderPath</italic>))</p>
      <p specific-use="line">⊳ <bold>This RDD is of type</bold> &lt;<bold>regionID</bold>, <bold>compressedReads</bold>&gt;</p>
      <p specific-use="line">  <italic>compressedRegionReads</italic> ← <italic>inputData</italic>.<italic>flatMap</italic>(<italic>x</italic> =&gt; <italic>getCompressedReads</italic>(<italic>x</italic>, <italic>regionsMap</italic>)</p>
      <p specific-use="line">⊳ <bold>This RDD is of type</bold> &lt;<bold>regionID</bold>, <bold>Array</bold>[<bold>compressedReads</bold>]&gt;</p>
      <p specific-use="line">  <italic>compressedRegions</italic> ← <italic>compressedRegionReads</italic>.<italic>mapValues</italic>(<italic>x</italic> =&gt; <italic>Array</italic>(<italic>x</italic>)).<italic>reduceByKey</italic>((<italic>a</italic>, <italic>b</italic>) =&gt; <italic>a</italic> + +<italic>b</italic>)</p>
      <p specific-use="line">⊳ <bold>Finally build the bam and bed files for each region after decompressing the contents</bold></p>
      <p specific-use="line">  <italic>compressedRegions</italic>.<italic>foreach</italic>(<italic>buildBAMandBEDFiles</italic>(_._1, _._2)</p>
      <p>Our mapping approach is able to trade off performance at the expense of system resources, allowing higher speed with more memory, while still allowing proper functionality with lower amounts of memory. This approach is illustrated in <xref ref-type="fig" rid="pone.0224784.g003">Fig 3</xref>, where each map task is able to generate one or multiple SAM chunks for each input FASTQ chunk. For clusters with low amounts of memory, we can store multiple output files for each map task. This allows processing of smaller files in subsequent pipeline steps such as the load balancing step. For example, we can identify two genome regions by dividing the whole genome into 2 parts, which will reduce the memory requirements of the load balancing step by about half, at the expense of a small extra initialization overhead. The files containing mapped reads that belong to chromosomes from Region 1 would be saved in a specific folder, while the chromosomes from Region 2 in another folder. The load balancing step would then be run twice, each time for a different region. This procedure could improve overall performance on clusters with less memory, because in that way less data is spilled onto the disk.</p>
      <fig id="pone.0224784.g003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g003</object-id>
        <label>Fig 3</label>
        <caption>
          <title>Regions and tradeoff.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g003"/>
      </fig>
      <p>The input to our SparkGA2 framework is either a single end gzipped FASTQ file or a paired end gzipped FASTQ files. It has to be noted that creating chunks from these gzipped files takes a significant amount of time. Due to this reason, our framework allows data to be streamed directly to HDFS, so that data nodes can start processing data as soon as some data is available. This streaming approach can be done either from URLs directly or gzipped files found on the local file system of the master node. The mechanism of this streaming is explained in detail in [<xref rid="pone.0224784.ref011" ref-type="bibr">11</xref>].</p>
    </sec>
    <sec id="sec008">
      <title>Step 2: Sorting and load balancing</title>
      <p>The process of doing this step is shown in Algorithm 2. Initially, the files which contains the information about number of reads produced for each bin are read. Notice that each mapper task would have created its own such file, so we have to collect this information together by summing the number of reads together for each bin. This is done by using Spark’s <italic>reduceByKey</italic> method. Afterwards, we calculate the average number of reads per region, by dividing the total number of reads in the whole genome by the number of regions that have to be created. Here, the total number of reads is calculated by summing up the reads of all bins. With this information, we can identify the regions in which the different bins are located. We can do this using the <italic>makeRegionsMap</italic> function in Algorithm 2, which takes the number of reads in each bin, and the average number of reads per region. This function would assign the appropriate region to each bin, and return the regions map containing this information.</p>
      <p>Once regions map is created, each output file from the mapping step is read in parallel, through the <italic>getCompressedReads</italic> function. This function takes the regions map as input, and assigns a SAM record to the appropriate region. The output is flat mapped, and we get an RDD, whose key is regionID and value is the compressed reads belonging to that region. These compressed reads are then accumulated in arrays, so that we have an RDD, where the key is the region ID and value is an array of compressed SAM records. Finally, this is given to the function <italic>buildBAMandBEDFiles</italic>, which would decompress the SAM records for a region, sort them, and write them onto a BAM file. Besides a BAM file, a BED file is created as well. A BED file here is used to tell the tools in the next step to only work on the region specified in that BED file.</p>
    </sec>
    <sec id="sec009">
      <title>Step 3: Variant discovery</title>
      <p>In this step, the remaining tools in the GATK pipeline are executed using the BAM and BED files generated in Step 2. Each task takes a BAM and BED file as input and performs mark duplicates, base recalibration and haplotype calling to generate a VCF file. The VCF files generated by all the tasks in Step 3 are used to create a combined VCF file. In this step, three tools are used to perform variant discovery.</p>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec010">
    <title>Results and discussion</title>
    <p>We tested the results on the Microsoft cloud with different number of nodes. Each node contains an 8 core processor with 56 GB of RAM. We used the best practices GATK pipeline from the Broad institute to compute the results. We used BWA version 0.7.10, and GATK version 4.</p>
    <p>We also tested our framework on the high performance big data cluster provided by SURFsara (the Dutch HPC infrastructure), with 6, 24, 48 and 67 nodes. Each node on the SURFsara cluster has 56 GB of RAM with 8 cores. On the SURFsara cluster, we used BWA version 0.7.10, and GATK version 3.4 instead of GATK version 4, since the Java run time version found on the data nodes of the SURFsara cluster did not support running GATK version 4.</p>
    <p>For both experiments, we tested and compared SparkGA2 with SparkGA, using the publicly available NA12878D dataset (<ext-link ext-link-type="uri" xlink:href="https://allseq.com/knowledge-bank/1000-genome/get-your-1000-genome-test-data-set/">https://allseq.com/knowledge-bank/1000-genome/get-your-1000-genome-test-data-set/</ext-link>), which is 150bp paired-end WGS data having a total size of 272 GB. Moreover, for SURFsara, we used two more benchmarks, the ERR194147 dataset (<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194147">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194147</ext-link>) which has a total size of 395 GB, and the ERR194160 dataset (<ext-link ext-link-type="ftp" xlink:href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194160">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR194/ERR194160</ext-link>) which has a total size of 389 GB, to compare performance of SparkGA2 with SparkGA on 67 nodes.</p>
    <p>First we discuss the scalability of our approach followed by a comparison with SparkGA. Lastly, we discuss the memory size vs performance tradeoff capabilities of our framework.</p>
    <sec id="sec011">
      <title>Scalability</title>
      <p><xref rid="pone.0224784.t002" ref-type="table">Table 2</xref> lists the runtime of SparkGA2 on the Microsoft cloud with 4, 5 and 6 nodes. The table shows the breakdown of the total runtime for each of the 3 steps of the pipeline in terms of minutes as well as in percentages. The table shows that the performance improves significantly with more number of nodes, which decreases from 531 minutes on 4 nodes down to 344 minutes on 6 nodes. This translates to a reduction of runtime by 54% from 4 to 6 nodes, illustrating the linear scalability of the framework. We note that the mapping step has the highest execution time of up to 56% of the whole pipeline, making it the most appropriate step to optimize performance. It is also interesting to note that each step of the pipeline scales almost equally with the increasing size of the cluster, thereby keeping the same ratios of execution time for each step.</p>
      <table-wrap id="pone.0224784.t002" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t002</object-id>
        <label>Table 2</label>
        <caption>
          <title>Runtime of SparkGA2 on Microsoft cloud.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t002g" xlink:href="pone.0224784.t002"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="2" colspan="1">Step</th>
                <th align="center" rowspan="1" colspan="1">4 nodes</th>
                <th align="center" rowspan="1" colspan="1">5 nodes</th>
                <th align="center" rowspan="1" colspan="1">6 nodes</th>
              </tr>
              <tr>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 1</td>
                <td align="center" rowspan="1" colspan="1">292, <bold>55</bold>%</td>
                <td align="center" rowspan="1" colspan="1">222, <bold>53%</bold></td>
                <td align="center" rowspan="1" colspan="1">192, <bold>56%</bold></td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 2</td>
                <td align="center" rowspan="1" colspan="1">79, <bold>15%</bold></td>
                <td align="center" rowspan="1" colspan="1">66, <bold>16%</bold></td>
                <td align="center" rowspan="1" colspan="1">48, <bold>14%</bold></td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 3</td>
                <td align="center" rowspan="1" colspan="1">160, <bold>30%</bold></td>
                <td align="center" rowspan="1" colspan="1">129, <bold>31%</bold></td>
                <td align="center" rowspan="1" colspan="1">104, <bold>30%</bold></td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <bold>Total</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">531, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">417, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">344, <bold>100%</bold></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p><xref rid="pone.0224784.t003" ref-type="table">Table 3</xref> shows the runtime of SparkGA2 on the SURFSara cluster with 6, 24, 48 and 67 nodes. Here, we can also see significant improvement in performance as the number of nodes increases, where the total runtime is reduced from 821.5 minutes down to 87 minutes as the cluster scales up from 6 to 67 nodes. This results in a speedup of about 9.4x on the 67 node cluster compared to the 6 node cluster, which is slightly sub-linear compared to the expected 11.2x linear speedup. The relative percentage of the various pipeline steps stays similar as the cluster size increases, indicating little difference in the way the steps scale up. However, there is a slight decrease in the percentage of Step 1 (mapping), indicating better scalability capabilities of BWA. At the same time, we notice the small increase in the percentage of Step 2 (sorting and load balancing), since this step requires heavy network utilization, which becomes a bigger bottleneck as the size of the cluster increases.</p>
      <table-wrap id="pone.0224784.t003" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t003</object-id>
        <label>Table 3</label>
        <caption>
          <title>Runtime of SparkGA2 with NA12878 on the SURFSara cluster.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t003g" xlink:href="pone.0224784.t003"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="2" colspan="1">Step</th>
                <th align="center" rowspan="1" colspan="1">6 nodes</th>
                <th align="center" rowspan="1" colspan="1">24 nodes</th>
                <th align="center" rowspan="1" colspan="1">48 nodes</th>
                <th align="center" rowspan="1" colspan="1">67 nodes</th>
              </tr>
              <tr>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
                <th align="center" rowspan="1" colspan="1">(mins, %)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 1</td>
                <td align="center" rowspan="1" colspan="1">331.5, <bold>40%</bold></td>
                <td align="center" rowspan="1" colspan="1">72.5, <bold>38</bold>%</td>
                <td align="center" rowspan="1" colspan="1">38.5, <bold>35%</bold></td>
                <td align="center" rowspan="1" colspan="1">29, <bold>34%</bold></td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 2</td>
                <td align="center" rowspan="1" colspan="1">67.5, <bold>8%</bold></td>
                <td align="center" rowspan="1" colspan="1">15.5, <bold>8%</bold></td>
                <td align="center" rowspan="1" colspan="1">11, <bold>10%</bold></td>
                <td align="center" rowspan="1" colspan="1">10, <bold>11%</bold></td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 3</td>
                <td align="center" rowspan="1" colspan="1">422.5, <bold>51%</bold></td>
                <td align="center" rowspan="1" colspan="1">101, <bold>53%</bold></td>
                <td align="center" rowspan="1" colspan="1">62, <bold>56%</bold></td>
                <td align="center" rowspan="1" colspan="1">47, <bold>54%</bold></td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <bold>Total</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">821.5, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">189, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">111.5, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">87, <bold>100%</bold></td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>It is interesting to note that the total runtime of the 6-node cluster on SURFSara is 2.4x slower compared to the 6-node Microsoft cloud cluster. This can be attributed to two main reasons: 1. GATK version 4 (on Microsoft cloud) is much faster than the older GATK version 3.4, and 2. the processors used in the SURFSara cluster are slower than their Microsoft cloud counterparts. We also note that Step 3 consumes up to 56% of runtime on SURFSara, again as a result of a slower GATK version 3.4, which makes Step 3 the bottleneck in this case.</p>
    </sec>
    <sec id="sec012">
      <title>Comparison with SparkGA</title>
      <p><xref rid="pone.0224784.t004" ref-type="table">Table 4</xref> shows a comparison of SparkGA2 with SparkGA. The table lists a comparison of runtime for each of the three pipeline steps of the two frameworks for 4, 5 and 6 nodes on the Microsoft cloud, in terms of minutes (m) and relative improvement (imp). The performance comparison is also shown in <xref ref-type="fig" rid="pone.0224784.g004">Fig 4</xref>. Each column in the figure is divided into 3 segments representing Step 1, 2 and 3 of the pipeline from bottom to top of each column. The figure shows that the total runtime of both frameworks decreases linearly with an increasing number of nodes in the cluster. However, SparkGA2 is up to 9% faster than SparkGA on this cluster.</p>
      <fig id="pone.0224784.g004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g004</object-id>
        <label>Fig 4</label>
        <caption>
          <title>Performance comparison with SparkGA on the Microsoft cluster.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g004"/>
      </fig>
      <table-wrap id="pone.0224784.t004" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t004</object-id>
        <label>Table 4</label>
        <caption>
          <title>Comparison of SparkGA2 (SGA2) vs SparkGA (SGA) on Microsoft cloud with 4, 5 and 6 nodes.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t004g" xlink:href="pone.0224784.t004"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="2" style="border-right:thick" colspan="1">Step</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">4 nodes</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">5 nodes</th>
                <th align="center" colspan="3" rowspan="1">6 nodes</th>
              </tr>
              <tr>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" rowspan="1" colspan="1">imp</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 1</td>
                <td align="center" rowspan="1" colspan="1">347, <bold>60%</bold></td>
                <td align="center" rowspan="1" colspan="1">292, <bold>55</bold>%</td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>18%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">261, <bold>59%</bold></td>
                <td align="center" rowspan="1" colspan="1">222, <bold>53%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>18%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">212, <bold>56%</bold></td>
                <td align="center" rowspan="1" colspan="1">192, <bold>56%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>10%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 2</td>
                <td align="center" rowspan="1" colspan="1">76, <bold>13%</bold></td>
                <td align="center" rowspan="1" colspan="1">79, <bold>15%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-4%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">60, <bold>13%</bold></td>
                <td align="center" rowspan="1" colspan="1">66, <bold>16%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-10%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">51, <bold>14%</bold></td>
                <td align="center" rowspan="1" colspan="1">48, <bold>14%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>6%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 3</td>
                <td align="center" rowspan="1" colspan="1">155, <bold>27%</bold></td>
                <td align="center" rowspan="1" colspan="1">160, <bold>30%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-3%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">124, <bold>28%</bold></td>
                <td align="center" rowspan="1" colspan="1">129, <bold>31%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-4%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">113 <bold>30%</bold></td>
                <td align="center" rowspan="1" colspan="1">104, <bold>30%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>9%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>Total</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">578, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">531, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>9%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">445, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">417, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>7%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">376, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">344, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>9%</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>Furthermore, Step 1 of SparkGA2 is up to 18% faster than the corresponding Step 1 in SparkGA. This shows the advantage in performance gained using the two new techniques in Step 1 of SparkGA2: 1. the on-the-fly compression approach which allows for more efficient in-memory data processing, and 2. the reduction in the amount of data uploaded to HDFS during the mapping step.</p>
      <p><xref rid="pone.0224784.t005" ref-type="table">Table 5</xref> shows the results on the SURFsara cluster, where we ran our pipeline with 6, 24, 48 and 67 nodes. The results show that the total runtime of SparkGA2 is 22% faster than SparkGA on a 67 node cluster, with all stages of the pipeline showing an increase in performance. This indicates the impact of the optimizations in SparkGA2 on the total runtime. It is interesting to note that Step 2 shows a particularly high improvement in performance due to the optimized load balancing methods we used. For 24, 48 and 67 nodes, the SparkGA2 load balancer is 87%, 55% and 30% faster than the SparkGA load balancer, respectively. The performance comparison is also shown in <xref ref-type="fig" rid="pone.0224784.g005">Fig 5</xref> for 24, 48 and 67 nodes.</p>
      <fig id="pone.0224784.g005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g005</object-id>
        <label>Fig 5</label>
        <caption>
          <title>Performance comparison with SparkGA on the SURFsara cluster.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g005"/>
      </fig>
      <table-wrap id="pone.0224784.t005" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t005</object-id>
        <label>Table 5</label>
        <caption>
          <title>Comparison of SparkGA2 vs SparkGA on SURFsara cluster with 6, 24, 48 and 67 nodes, for NA12878.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t005g" xlink:href="pone.0224784.t005"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="2" style="border-right:thick" colspan="1">Step</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">6 nodes</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">24 nodes</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">48 nodes</th>
                <th align="center" colspan="3" rowspan="1">67 nodes</th>
              </tr>
              <tr>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" rowspan="1" colspan="1">imp</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 1</td>
                <td align="center" rowspan="1" colspan="1">316, <bold>38%</bold></td>
                <td align="center" rowspan="1" colspan="1">331.5, <bold>40%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-5%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">85, <bold>37%</bold></td>
                <td align="center" rowspan="1" colspan="1">72.5, <bold>38%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>17%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">46, <bold>34%</bold></td>
                <td align="center" rowspan="1" colspan="1">38.5, <bold>35%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>19%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">37.5, <bold>35%</bold></td>
                <td align="center" rowspan="1" colspan="1">30, <bold>34%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>25%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 2</td>
                <td align="center" rowspan="1" colspan="1">95, <bold>11%</bold></td>
                <td align="center" rowspan="1" colspan="1">67.5, <bold>8%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>41%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">29, <bold>13%</bold></td>
                <td align="center" rowspan="1" colspan="1">15.5, <bold>8%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>87%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">17, <bold>13%</bold></td>
                <td align="center" rowspan="1" colspan="1">11, <bold>10%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>55%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">13, <bold>12%</bold></td>
                <td align="center" rowspan="1" colspan="1">10, <bold>11%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>30%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 3</td>
                <td align="center" rowspan="1" colspan="1">419, <bold>50%</bold></td>
                <td align="center" rowspan="1" colspan="1">422.5, <bold>51%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-1%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">117.5, <bold>51%</bold></td>
                <td align="center" rowspan="1" colspan="1">101, <bold>53%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>16%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">70.5, <bold>53%</bold></td>
                <td align="center" rowspan="1" colspan="1">62, <bold>56%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>14%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">55.5, <bold>52%</bold></td>
                <td align="center" rowspan="1" colspan="1">47, <bold>54%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>18%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>Total</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">830, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">821.5, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>1%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">231.5, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">189, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>22%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">133.5, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">111.5, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>20%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">106, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">87, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>22%</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>It is also interesting to note that the total runtime in SparkGA2 shows an increased performance advantage compared to SparkGA as the cluster size increases. This indicates that SparkGA2 has better scalability characteristics, while still being able to run on a small cluster, making it suitable for usage in a practical production environment.</p>
      <p><xref rid="pone.0224784.t006" ref-type="table">Table 6</xref> shows comparison of SparkGA2’s performance with that of SparkGA for different benchmarks on 67 nodes. We can see that there is clear improvement for all the benchmarks for Step 1 and 2. Step 2 is as fast as 50% for one of the benchmark (ERR194160). Overall, SparkGA2 is up to 22% faster than SparkGA.</p>
      <table-wrap id="pone.0224784.t006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t006</object-id>
        <label>Table 6</label>
        <caption>
          <title>Comparison of SparkGA2 vs SparkGA on SURFSara cluster with 67 nodes, with different benchmarks.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t006g" xlink:href="pone.0224784.t006"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="2" style="border-right:thick" colspan="1">Step</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">ERR194147</th>
                <th align="center" colspan="3" style="border-right:thick" rowspan="1">ERR194160</th>
                <th align="center" colspan="3" rowspan="1">NA12878</th>
              </tr>
              <tr>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" style="border-right:thick" rowspan="1" colspan="1">imp</th>
                <th align="center" rowspan="1" colspan="1">SGA (m, %)</th>
                <th align="center" rowspan="1" colspan="1">SGA2 (m, %)</th>
                <th align="center" rowspan="1" colspan="1">imp</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 1</td>
                <td align="center" rowspan="1" colspan="1">41, <bold>36%</bold></td>
                <td align="center" rowspan="1" colspan="1">35, <bold>34</bold>%</td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>17%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">43.5, <bold>39%</bold></td>
                <td align="center" rowspan="1" colspan="1">34, <bold>34%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>28%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">37.5, <bold>35%</bold></td>
                <td align="center" rowspan="1" colspan="1">30, <bold>34%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>25%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 2</td>
                <td align="center" rowspan="1" colspan="1">14.5, <bold>13%</bold></td>
                <td align="center" rowspan="1" colspan="1">10, <bold>10%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>45%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">15, <bold>13%</bold></td>
                <td align="center" rowspan="1" colspan="1">10, <bold>10%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>50%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">13, <bold>12%</bold></td>
                <td align="center" rowspan="1" colspan="1">10, <bold>11%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>30%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">Step 3</td>
                <td align="center" rowspan="1" colspan="1">57.5, <bold>51%</bold></td>
                <td align="center" rowspan="1" colspan="1">58.5, <bold>56%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-2%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">54, <bold>48%</bold></td>
                <td align="center" rowspan="1" colspan="1">56, <bold>56%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>-4%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">55.5 <bold>52%</bold></td>
                <td align="center" rowspan="1" colspan="1">47, <bold>54%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>18%</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>Total</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">113, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">103.5, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>9%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">112.5, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">100, <bold>100%</bold></td>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>12.5%</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">106, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">87, <bold>100%</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>22%</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>Profiling results for SparkGA and SparkGA2 on the 6-node Microsoft cloud cluster are shown in Figs <xref ref-type="fig" rid="pone.0224784.g006">6</xref> and <xref ref-type="fig" rid="pone.0224784.g007">7</xref>, respectively. In those figures, the x-axis represents time and the y-axis represents the percentage of resource utilization. CPU usage is expressed in terms of user time and idle time, while I/O usage in terms of io wait time. From those figures we can see that for Step 1, the idle time in the case of SparkGA is much higher than in the case of SparkGA2. The reason is that SparkGA has to upload a lot more files to HDFS as compared to SparkGA2. For Step 2, the profile of SparkGA shows an increase in disk access, causing io wait time as compared to a negligible io wait time for SparkGA2. This can be explained by the large number of files that need to be created and accessed in SparkGA for each of the genome regions created in Step 1, which creates I/O access conflicts.</p>
      <fig id="pone.0224784.g006" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g006</object-id>
        <label>Fig 6</label>
        <caption>
          <title>Profile of a node with SparkGA on the 6-node Microsoft cloud cluster.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g006"/>
      </fig>
      <fig id="pone.0224784.g007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.g007</object-id>
        <label>Fig 7</label>
        <caption>
          <title>Profile of a node with SparkGA2 on the 6-node Microsoft cloud cluster.</title>
        </caption>
        <graphic xlink:href="pone.0224784.g007"/>
      </fig>
      <p><xref rid="pone.0224784.t007" ref-type="table">Table 7</xref> compares the runtime of SparkGA and SparkGA2 on the 6-node Microsoft cloud using the streaming solution for input data. Streaming of input data eliminates the need to spend execution time separately on uncompressing the input FASTQ files, making smaller input chunks for mapping, and uploading them to the HDFS. This is done by a chunking utility, which performs chunking in parallel to the mapping. The chunking utility here is run on the master node. When streaming of input data is taken into account, SparkGA2 is 51% faster than SparkGA, due to SparkGA2’s ability to have input data streamed directly to the HDFS, while data nodes are processing that data. In this way, it can completely overlap such chunking with mapping.</p>
      <table-wrap id="pone.0224784.t007" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t007</object-id>
        <label>Table 7</label>
        <caption>
          <title>Runtime in minutes using the streaming approach on Microsoft cloud with 6 nodes.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t007g" xlink:href="pone.0224784.t007"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <th align="center" rowspan="2" colspan="1">Step</th>
                <th align="center" rowspan="1" colspan="1">SparkGA</th>
                <th align="center" rowspan="1" colspan="1">SparkGA2</th>
              </tr>
              <tr>
                <th align="center" rowspan="1" colspan="1">mins</th>
                <th align="center" rowspan="1" colspan="1">mins</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="center" rowspan="1" colspan="1">Chunking</td>
                <td align="center" rowspan="1" colspan="1">143.5</td>
                <td align="center" rowspan="1" colspan="1">-</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 1</td>
                <td align="center" rowspan="1" colspan="1">212</td>
                <td align="center" rowspan="1" colspan="1">192</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 2</td>
                <td align="center" rowspan="1" colspan="1">51</td>
                <td align="center" rowspan="1" colspan="1">48</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">Step 3</td>
                <td align="center" rowspan="1" colspan="1">113</td>
                <td align="center" rowspan="1" colspan="1">104</td>
              </tr>
              <tr>
                <td align="center" rowspan="1" colspan="1">
                  <bold>Total</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>520</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>344</bold>
                </td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
    <sec id="sec013">
      <title>Efficient memory utilization</title>
      <p>We also checked the impact of our approach to trade off performance with system resource utilization in the mapping step, specifically the amount of memory utilization as a result of increasing the number of genome regions. The maximum memory needed to store the regions in-memory is dependent on the number of genome regions in the pipeline. <xref rid="pone.0224784.t008" ref-type="table">Table 8</xref> lists the amount of memory consumed for 1 to 10 genome regions. The table shows that memory requirements decrease from 122 GB with 1 region down to 20 GB with 10 regions. This indicates that by increasing the number of regions, we can significantly reduce the memory requirements of the cluster, making our framework executable even for a smaller cluster (albeit with an increased runtime).</p>
      <table-wrap id="pone.0224784.t008" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t008</object-id>
        <label>Table 8</label>
        <caption>
          <title>Maximum memory consumed by number of regions.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t008g" xlink:href="pone.0224784.t008"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1"><bold>No</bold>. <bold>of regions</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>1</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>2</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>4</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>6</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>8</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>10</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>Memory</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">122 GB</td>
                <td align="center" rowspan="1" colspan="1">69 GB</td>
                <td align="center" rowspan="1" colspan="1">37 GB</td>
                <td align="center" rowspan="1" colspan="1">29 GB</td>
                <td align="center" rowspan="1" colspan="1">20 GB</td>
                <td align="center" rowspan="1" colspan="1">20 GB</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
      <p>The impact on runtime is shown in <xref rid="pone.0224784.t009" ref-type="table">Table 9</xref>, which lists the runtime results of Step 2 (sorting and load balancing) for the 6-node Microsoft cluster. The table shows that the total time for Step 2 increases with increasing number of regions, from 48 minutes (6 regions) up to 56 minutes (10 regions), due to the startup overhead for Spark for each of the regions. For lower than 6 regions, the cluster is not able to run the pipeline, due to the increased memory consumed by Spark for storing region data, causing the cluster to go out of memory.</p>
      <table-wrap id="pone.0224784.t009" orientation="portrait" position="float">
        <object-id pub-id-type="doi">10.1371/journal.pone.0224784.t009</object-id>
        <label>Table 9</label>
        <caption>
          <title>Runtime in minutes for Step 2 on Microsoft cloud with 6 nodes, with different number of regions.</title>
        </caption>
        <alternatives>
          <graphic id="pone.0224784.t009g" xlink:href="pone.0224784.t009"/>
          <table frame="box" rules="all" border="0">
            <colgroup span="1">
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
              <col align="left" valign="middle" span="1"/>
            </colgroup>
            <tbody>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1"><bold>No</bold>. <bold>of regions</bold></td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>6</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>8</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">
                  <bold>10</bold>
                </td>
              </tr>
              <tr>
                <td align="center" style="border-right:thick" rowspan="1" colspan="1">
                  <bold>Time</bold>
                </td>
                <td align="center" rowspan="1" colspan="1">48 min</td>
                <td align="center" rowspan="1" colspan="1">51 min</td>
                <td align="center" rowspan="1" colspan="1">56 min</td>
              </tr>
            </tbody>
          </table>
        </alternatives>
      </table-wrap>
    </sec>
  </sec>
  <sec sec-type="conclusions" id="sec014">
    <title>Conclusions</title>
    <p>This paper proposed SparkGA2, a production quality, general purpose Spark framework which can run post sequencing DNA analysis pipelines on public clouds in an efficient manner. Our framework implements an on-the-fly compression method of intermediate data to reduce memory requirements by up to 3x. Furthermore, it uses a superior load balancing technique to reduce accesses to the HDFS. At the same time, our framework can hide data pre-processing time by streaming and pre-processing input data while the analysis pipeline is running. As compared to the state of the art GATK best-practices pipeline, SparkGA2 is up to 22% faster on a large big data cluster of 67 nodes and up to 9% faster on a smaller cluster of 6 nodes. This indicates that SparkGA2 has better scalability characteristics compared to existing solutions, while still being able to run on a small cluster, making it suitable for practical production environments. Including the streaming solution, where data pre-processing in parallel is considered, SparkGA2 is 51% faster on a 6 node cluster. The source code of SparkGA2 is publicly available at <ext-link ext-link-type="uri" xlink:href="https://github.com/HamidMushtaq/SparkGA2">https://github.com/HamidMushtaq/SparkGA2</ext-link>.</p>
  </sec>
</body>
<back>
  <ack>
    <p>We would like to acknowledge support from the Microsoft Azure for Research program (to Hamid Mushtaq) for providing their cloud computing resources for free to conduct this research. In addition, some experiments have been performed on the Dutch national e-infrastructure with support from the SURF cooperative.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="pone.0224784.ref001">
      <label>1</label>
      <mixed-citation publication-type="book"><name><surname>Zaharia</surname><given-names>M</given-names></name>, <name><surname>Chowdhury</surname><given-names>M</given-names></name>, <name><surname>Franklin</surname><given-names>MJ</given-names></name>, <name><surname>Shenker</surname><given-names>S</given-names></name> and <name><surname>Stoica</surname><given-names>I</given-names></name>. “<chapter-title>Spark: cluster computing with working sets</chapter-title>”, <source><italic toggle="yes">HotCloud’10</italic></source>, <publisher-name>USENIX Association</publisher-name>, <publisher-loc>Berkeley, CA, USA</publisher-loc>.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref002">
      <label>2</label>
      <mixed-citation publication-type="journal"><name><surname>Van der Auwera</surname><given-names>GA</given-names></name>, <name><surname>Carneiro</surname><given-names>M</given-names></name>, <name><surname>Hartl</surname><given-names>C</given-names></name>, <name><surname>Poplin</surname><given-names>R</given-names></name>, <name><surname>del Angel</surname><given-names>G</given-names></name>, <name><surname>Levy-Moonshine</surname><given-names>A</given-names></name>, <etal>et al</etal> “<article-title>From FastQ Data to High-Confidence Variant Calls: The Genome Analysis Toolkit Best Practices Pipeline</article-title>”, <source>Current Protocols in Bioinformatics</source>, <volume>43</volume>:<fpage>11.10.1</fpage>–<lpage>11.10.33</lpage>, <year>2013</year>.<pub-id pub-id-type="pmid">25431634</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0224784.ref003">
      <label>3</label>
      <mixed-citation publication-type="other">Mushtaq H, Liu F, Costa C, Liu G, Hofstee P and Al-Ars Z. “SparkGA: A Spark Framework for Cost Effective, Fast and Accurate DNA Analysis at Scale”, Proc. ACM Conference Bioinformatics, Computational Biology and Health Informatics, 2017.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref004">
      <label>4</label>
      <mixed-citation publication-type="journal"><name><surname>Jones</surname><given-names>DC</given-names></name>, <name><surname>Ruzzo</surname><given-names>WL</given-names></name>, <name><surname>Peng X and Katze</surname><given-names>MG</given-names></name>. “<article-title>Compression of next-generation sequencing reads aided by highly efficient de novo assembly</article-title>”, <source><italic toggle="yes">Nucleic Acids Research</italic></source>, <year>2012</year><pub-id pub-id-type="doi">10.1093/nar/gks754</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0224784.ref005">
      <label>5</label>
      <mixed-citation publication-type="journal"><name><surname>Langmead B and Salzberg</surname><given-names>SL</given-names></name>. “<article-title>Fast gapped-read alignment with Bowtie 2</article-title>”, <source>Nature Methods</source>, <volume>vol. 9</volume>, <issue>no. 4</issue>, pp. <fpage>357</fpage>–<lpage>359</lpage>, <year>2012</year><pub-id pub-id-type="doi">10.1038/nmeth.1923</pub-id><pub-id pub-id-type="pmid">22388286</pub-id></mixed-citation>
    </ref>
    <ref id="pone.0224784.ref006">
      <label>6</label>
      <mixed-citation publication-type="other">Li H. “Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM”, arXiv:1303.3997 [q-bio.GN], 2013.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref007">
      <label>7</label>
      <mixed-citation publication-type="journal"><name><surname>Kelly</surname><given-names>BJ</given-names></name>, <name><surname>Fitch</surname><given-names>JR</given-names></name>, <name><surname>Hu</surname><given-names>Y</given-names></name>, <name><surname>Corsmeier</surname><given-names>DJ</given-names></name>, <name><surname>Zhong</surname><given-names>H</given-names></name>, <name><surname>Wetzel</surname><given-names>AN</given-names></name>, <etal>et al</etal> “<article-title>Churchill: an ultra-fast, deterministic, highly scalable and balanced parallelization strategy for the discovery of human genetic variation in clinical and population-scale genomics</article-title>”, <source><italic toggle="yes">Genome Biology</italic></source>, <volume>vol. 16</volume>, <issue>no. 6</issue>, <year>2015</year>.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref008">
      <label>8</label>
      <mixed-citation publication-type="journal"><name><surname>Decap</surname><given-names>D</given-names></name>, <name><surname>Reumers</surname><given-names>J</given-names></name>, <name><surname>Herzeel</surname><given-names>C</given-names></name>, <name><surname>Costanza P and Fostier</surname><given-names>J</given-names></name>. “<article-title>Halvade: scalable sequence analysis with MapReduce</article-title>”, <source><italic toggle="yes">Bioinformatics</italic></source>, <fpage>btv179v2</fpage>–<lpage>btv179</lpage>, <year>2015</year>.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref009">
      <label>9</label>
      <mixed-citation publication-type="other">Deng L, Huang G, Zhuang Y, Wei J and Yan Y. “HiGene: A high-performance platform for genomic data analysis”, Proc. IEEE Inte’l Conf. Bioinformatics and Biomedicine, (BIBM16), Shenzhen, China, pp. 576–583, 2016.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref010">
      <label>10</label>
      <mixed-citation publication-type="other">Mushtaq H and Al-Ars Z. “Cluster-based Apache Spark implementation of the GATK DNA analysis pipeline”, 2015 IEEE International Conference on Bioinformatics and Biomedicine (BIBM), Washington, DC, pp. 1471–1477, 2015.</mixed-citation>
    </ref>
    <ref id="pone.0224784.ref011">
      <label>11</label>
      <mixed-citation publication-type="other">Mushtaq H, Ahmed N and Al-Ars Z. “Streaming Distributed DNA Sequence Alignment Using Apache Spark”, 17th IEEE International Conference on BioInformatics and BioEngineering, 2017.</mixed-citation>
    </ref>
  </ref-list>
</back>
