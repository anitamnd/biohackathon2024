<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Biol</journal-id>
    <journal-title-group>
      <journal-title>Genome Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1474-7596</issn>
    <issn pub-type="epub">1474-760X</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4888505</article-id>
    <article-id pub-id-type="publisher-id">973</article-id>
    <article-id pub-id-type="doi">10.1186/s13059-016-0973-5</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic>Vcfanno</italic>: fast, flexible annotation of genetic variants</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Pedersen</surname>
          <given-names>Brent S.</given-names>
        </name>
        <address>
          <email>bpederse@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
        <xref ref-type="aff" rid="Aff2"/>
        <xref ref-type="aff" rid="Aff3"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Layer</surname>
          <given-names>Ryan M.</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
        <xref ref-type="aff" rid="Aff2"/>
        <xref ref-type="aff" rid="Aff3"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Quinlan</surname>
          <given-names>Aaron R.</given-names>
        </name>
        <address>
          <email>aquinlan@genetics.utah.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
        <xref ref-type="aff" rid="Aff2"/>
        <xref ref-type="aff" rid="Aff3"/>
      </contrib>
      <aff id="Aff1"><label/>Department of Human Genetics, University of Utah, Salt Lake City, UT 84105 USA </aff>
      <aff id="Aff2"><label/>USTAR Center for Genetic Discovery, University of Utah, Salt Lake City, UT 84105 USA </aff>
      <aff id="Aff3"><label/>Department of Biomedical Informatics, University of Utah, Salt Lake City, UT 84105 USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>1</day>
      <month>6</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>1</day>
      <month>6</month>
      <year>2016</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2016</year>
    </pub-date>
    <volume>17</volume>
    <elocation-id>118</elocation-id>
    <history>
      <date date-type="received">
        <day>1</day>
        <month>3</month>
        <year>2016</year>
      </date>
      <date date-type="accepted">
        <day>3</day>
        <month>5</month>
        <year>2016</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© Pedersen et al. 2016</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold>This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p>The integration of genome annotations is critical to the identification of genetic variants that are relevant to studies of disease or other traits. However, comprehensive variant annotation with diverse file formats is difficult with existing methods. Here we describe <italic>vcfanno</italic>, which flexibly extracts and summarizes attributes from multiple annotation files and integrates the annotations within the INFO column of the original VCF file. By leveraging a parallel “chromosome sweeping” algorithm, we demonstrate substantial performance gains by annotating ~85,000 variants per second with 50 attributes from 17 commonly used genome annotation resources. <italic>Vcfanno</italic> is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/brentp/vcfanno">https://github.com/brentp/vcfanno</ext-link> under the MIT license.</p>
      <sec>
        <title>Electronic supplementary material</title>
        <p>The online version of this article (doi:10.1186/s13059-016-0973-5) contains supplementary material, which is available to authorized users.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Genetic variation</kwd>
      <kwd>SNP</kwd>
      <kwd>Annotation</kwd>
      <kwd>VCF</kwd>
      <kwd>Variant</kwd>
      <kwd>Variant prioritization</kwd>
      <kwd>Genome analysis</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000051</institution-id>
            <institution>National Human Genome Research Institute</institution>
          </institution-wrap>
        </funding-source>
        <award-id>R01HG006693</award-id>
        <principal-award-recipient>
          <name>
            <surname>Quinlan</surname>
            <given-names>Aaron R.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2016</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>The VCF files [<xref ref-type="bibr" rid="CR1">1</xref>] produced by software such as GATK [<xref ref-type="bibr" rid="CR2">2</xref>] and FreeBayes [<xref ref-type="bibr" rid="CR3">3</xref>] report the polymorphic loci observed among a cohort of individuals. Aside from the chromosomal location and observed alleles, these loci are essentially anonymous. Until they are embellished with genome annotations, it is nearly impossible to answer basic questions such as “was this variant seen in ClinVar,” or “what is the alternative allele frequency observed in the 1000 Genomes Project?” An extensive and growing number of publicly available annotation resources (Ensembl, UCSC) and reference databases of genetic variation (e.g., ClinVar, Exome Aggregation Consortium (ExAC), 1000 Genomes) provide context that is crucial to variant interpretation. It is also common for individual labs and research consortia to curate custom databases that are used, for example, to exclude variants arising in genes or exons that are systematic sources of false positives in exome or genome resequencing studies. Other annotations, such as low-complexity regions [<xref ref-type="bibr" rid="CR4">4</xref>], transcription factor binding sites, regulatory regions, or replication timing [<xref ref-type="bibr" rid="CR5">5</xref>], can further inform the prioritization of genetic variants related to a phenotype. The integration of such annotations is complementary to the gene-based approaches provided by snpEff [<xref ref-type="bibr" rid="CR6">6</xref>], Annovar [<xref ref-type="bibr" rid="CR7">7</xref>], and VEP [<xref ref-type="bibr" rid="CR8">8</xref>]. Each of these tools can provide additional, region-based annotation, yet they are limited to the genome annotation sets provided by the software. While extensive variant annotation is fundamental to nearly every modern study of genetic variation, no existing software can flexibly and simply annotate VCF files with so many diverse data sets.</p>
    <p>We have therefore developed <italic>vcfanno</italic> as a fast and general solution for variant annotation that allows variants to be “decorated” with any annotation dataset in common formats. In addition to providing the first method that is capable of annotating with multiple annotation sets at a time, <italic>vcfanno</italic> also avoids common issues such as inconsistent chromosome labeling (“chr1” versus “1”) and ordering (<italic>1</italic>,<italic>2</italic>,…<italic>10</italic>…, or <italic>1</italic>,<italic>10</italic>,<italic>11</italic>…) among the VCF and annotation files. To maximize performance with dozens of annotation files comprised of millions of genome intervals, we introduce a parallel sweeping algorithm with high scalability. In an effort to make <italic>vcfanno</italic>’s annotation functionality as flexible as possible, we have also embedded a lua (<ext-link ext-link-type="uri" xlink:href="http://www.lua.org/">http://www.lua.org/</ext-link>) scripting engine that allows users to write custom operations.</p>
  </sec>
  <sec id="Sec2">
    <title>Implementation</title>
    <sec id="Sec3">
      <title>Overview of the <italic>vcfanno</italic> functionality</title>
      <p><italic>Vcfanno</italic> annotates variants in a VCF file (the “query” intervals) with information aggregated from the set of intersecting intervals among many different annotation files (the “database” intervals) stored in common genomic formats such as BED, GFF, GTF, VCF, and BAM. It utilizes a “streaming” intersection algorithm that leverages sorted input files to greatly reduce memory consumption and improve speed. As the streaming intersection is performed (details below), database intervals are associated with a query interval if there is an interval intersection. Once all intersections for a particular query interval are known, the annotation proceeds according to user-defined operations that are applied to the attributes (e.g., the “score” column in a BED annotation file or an attribute in the INFO field of a VCF annotation file) data within the database intervals. As a simple example, consider a query VCF of single nucleotide variants (SNVs) that was annotated by SNVs from an annotation database such as a VCF file of the dbSNP resource. In this case, the query and database variants are matched on position, REF, and ALT fields when available and a value from the overlapping database interval (e.g., minor allele frequency) is carried forward to become the annotation stored in the INFO field of the query VCF. In a more complex scenario where a query structural variant intersects multiple annotation intervals from each database, the information from those intervals must be aggregated. One may wish to report each of the attributes as a comma-separated list via the “concat” operation. Alternatively, one could select the maximum allele frequency via the “max” operation. For cases where only a single database interval is associated with the query, the choice of operation will not affect the summarized value.</p>
      <p>An example VCF INFO field from a single variant before and after annotation with <italic>vcfanno</italic> is shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. A simple configuration file is used to specify both the source files and the set of attributes (in the case of VCF) or columns (in the case of BED or other tab-delimited formats) that should be added to the query file. In addition, the configuration file allows annotations to be renamed in the resulting VCF INFO field. For example, we can extract the allele frequency (AF) attribute from the ExAC VCF file [<xref ref-type="bibr" rid="CR9">9</xref>] and rename it as “exac_aaf” in the INFO field of the VCF query records. The configuration file allows one to extract as many attributes as needed from any number of annotation datasets.<fig id="Fig1"><label>Fig. 1</label><caption><p>Overview of the <italic>vcfanno</italic> workflow. An unannotated VCF (<bold>a</bold>) is sent to <italic>vcfanno</italic> (<bold>b</bold>) along with a configuration file that indicates the paths to the annotation files, the attributes to extract from each file, and the methods that should be used to describe or summarize the values extracted from those files. The new annotations in the resulting VCF (<bold>c</bold>) are shown in blue text with additional fields added to the INFO column</p></caption><graphic xlink:href="13059_2016_973_Fig1_HTML" id="MO1"/></fig></p>
    </sec>
    <sec id="Sec4">
      <title>Overview of the chrom-sweep algorithm</title>
      <p>The chromosome sweeping algorithm (“chrom-sweep”) is an adaptation of the streaming, sort-merge join algorithm, and is capable of efficiently detecting interval intersections among multiple interval files, as long as they are sorted by both chromosome and interval start position. Utilized by both BEDTOOLS [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR11">11</xref>] and BEDOPS [<xref ref-type="bibr" rid="CR12">12</xref>], chrom-sweep finds intersections in a single pass by advancing pointers in each file that are synchronized by genomic position. At each step in the sweep, these pointers maintain the set of intervals that intersect a particular position and, in turn, intersect each other. This strategy is advantageous for large datasets because it avoids the use of data structures such as interval trees or hierarchical bins (e.g., the UCSC binning algorithm [<xref ref-type="bibr" rid="CR13">13</xref>]). While these tree and binning techniques do not require sorted input, the memory footprint of these methods scales poorly, especially when compared with streaming algorithms, which typically exhibit low, average-case memory demands.</p>
      <p>The chrom-sweep algorithm implemented in <italic>vcfanno</italic> proceeds as follows. First, we create an iterator of interval records for the query VCF and for each database annotation file. We then merge intervals from the query VCF and each annotation into a single priority queue, which orders the intervals from all files by chromosome and start coordinate, while also tracking the file from which each interval came. <italic>Vcfanno</italic> progresses by requesting an interval from the priority queue and inserts it into a cache. If the most recently observed interval is from the query VCF, we check for intersections with all database intervals that are currently in the cache. Since <italic>vcfanno</italic> requires that all files be sorted, we know that intervals are entering the cache ordered by start coordinate. Therefore, in order to check for overlap, we only need to check that the start of the new interval is less than the end of any of the intervals in the cache (assuming half-open intervals). An example of the sweeping algorithm is shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref> for a case involving two annotation files and three records from a single query VCF. The contents of the cache are shown as the sweep reaches the start of each new interval. When a new query interval enters the cache, any interval that does not intersect it is ejected from the cache. If the removed interval originated from the query VCF, it is sent, together with each of the intersecting annotation intervals, to be processed according to the operations specified in the configuration file. The resulting annotations are stored in the INFO field of the VCF file and the updated VCF record is reported as output.<fig id="Fig2"><label>Fig. 2</label><caption><p>Overview of the chrom-sweep interval intersection algorithm. The chrom-sweep algorithm sweeps from <italic>left</italic> to <italic>right</italic> as it progresses along each chromosome. <italic>Green</italic> intervals from the query VCF in the <italic>first row</italic> are annotated by annotation files A (<italic>blue</italic>) and B (<italic>orange</italic>) in the <italic>second</italic> and <italic>third rows</italic>, respectively. The cache row indicates which intervals are currently in the cache at each point in the progression of the sweeping algorithm. Intervals enter the cache in order of their chromosomal start position. First <italic>A1</italic> enters the cache followed by <italic>Q1</italic>. Since <italic>Q1</italic> intersects <italic>A1</italic>, they are associated, as are <italic>Q1</italic> and <italic>B1</italic> when <italic>B1</italic> enters the cache. Each time a new query interval enters the cache, any interval it does not intersect is ejected. Therefore, when <italic>Q2</italic> enters the cache, <italic>Q1</italic> and <italic>A1</italic> are ejected. Since <italic>Q1</italic> is a query interval, it is sent to be reported as output. Proceeding to the right, <italic>A2</italic> and then <italic>Q3</italic> enter the cache; the latter is a query interval and so the intervals that do not overlap it—<italic>B1</italic>, <italic>Q2</italic>, and <italic>A2</italic>—are ejected from the cache with the query interval, <italic>Q2</italic>, which is sent to the caller. Finally, as we reach the end of the incoming intervals, we clear out the final <italic>Q3</italic> interval and finalize the output for this chromosome. EOF: End of File</p></caption><graphic xlink:href="13059_2016_973_Fig2_HTML" id="MO2"/></fig></p>
    </sec>
    <sec id="Sec5">
      <title>Limitations of the chrom-sweep algorithm</title>
      <p>Owing to the fact that annotation sets are not loaded into memory-intensive data structures, the chrom-sweep algorithm easily scales to large datasets. However, it does have some important limitations. First, it requires that all intervals from all annotation files adhere to the same chromosome order. While conceptually simple, this is especially onerous since VCFs produced by variant callers such as GATK impose a different chromosome order (1, 2, …21, X, Y, MT) than most other numerically sorted annotation files, which would put MT before X and Y. Of course, sorting the numeric chromosomes as characters or integers also results in different sort orders. Discrepancies in chromosome ordering among files are often not detected until substantial computation has already been performed. A related problem is when one file contains intervals from a given chromosome that the other does not, it’s not possible to distinguish whether the chromosome order is different or if that chromosome is simply not present in one of the files until all intervals are parsed.</p>
      <p>Second, the standard chrom-sweep implementation is suboptimal because it is often forced to consider (and parse) many annotation intervals that will never intersect the query intervals, resulting in unnecessary work [<xref ref-type="bibr" rid="CR14">14</xref>]. For example, given a VCF file of variants that are sparsely distributed throughout the genome (e.g., a VCF from a single exome study) and dense data sets of whole-genome annotations, chrom-sweep must parse and test each interval of the whole-genome annotations for intersection with a query interval, even though the areas of interest comprise less than 1 % of the regions in the file. In other words, sparse queries with dense annotation files represent a worst-case scenario for the performance of chrom-sweep because a high proportion of the intervals in the data sets will never intersect.</p>
      <p>A third limitation of the chrom-sweep algorithm is that, due to the inherently serial nature of the algorithm, it is difficult to parallelize the detection of interval intersections and the single CPU performance is limited by the speed at which intervals can be parsed. Since the intervals arrive in sorted order, skipping ahead to process a new region from each file in a different processing thread is difficult without a pre-computed spatial index of the intervals and reporting the intervals in sorted order after intersection requires additional bookkeeping.</p>
    </sec>
    <sec id="Sec6">
      <title>A parallel chrom-sweep algorithm</title>
      <p>To address these shortcomings, we developed a parallel algorithm that concurrently chrom-sweeps “chunks” of query and database intervals. Unlike previous in-memory parallel sweeping methods that uniformly partition the input [<xref ref-type="bibr" rid="CR15">15</xref>], we define (without the need for preprocessing [<xref ref-type="bibr" rid="CR16">16</xref>]) chunks by consecutive query intervals that meet one of two criteria: either the set reaches the “chunk size” threshold or the genomic distance to the next interval exceeds the “gap size” threshold. Restricting the chunk size creates reasonably even work among the threads to support efficient load balancing (i.e., to avoid task divergence). The gap size cutoff is designed to avoid processing an excessive number of unrelated database intervals that reside between distant query intervals.</p>
      <p>As soon as a chunk is defined, it is scheduled to be swept in parallel along with the other previously defined chunks. The bounds of the query intervals in the chunk determine the range of the intervals requested from each annotation file (Fig. <xref rid="Fig3" ref-type="fig">3</xref>). Currently these requests are to either a Tabix [<xref ref-type="bibr" rid="CR17">17</xref>] indexed file or a BAM file via the bíogo package [<xref ref-type="bibr" rid="CR18">18</xref>] but any spatial query can be easily supported. An important side effect of gathering database intervals using these requests is that, while the annotation files must be sorted, there is no need for the chromosome orders of the annotations to match. This, along with internally removing any “chr” prefix, alleviates the associated chromosome order and representation complexities detailed above. The set of intervals from these requests are integrated with the query intervals to complete the chunk, which is then processed by the standard chrom-sweep algorithm. However, in practice this is accomplished by streams so that only the query intervals are held in memory while the annotation intervals are retrieved from their iterators during the chrom-sweep. One performance bottleneck in this strategy is that the output should be sorted and, since chunks may finish in any order, we must buffer completed chunks to restore sorted order. This, along with disk speed limitations, is the primary source of overhead preventing optimal parallelization efficiency.<fig id="Fig3"><label>Fig. 3</label><caption><p>Parallel sweeping algorithm. As in Fig. <xref rid="Fig2" ref-type="fig">2</xref>, we sweep across the chromosome from lower to higher positions (and <italic>left</italic> to <italic>right</italic> in the figure). The <italic>green</italic> query intervals are to be annotated with the two annotation files depicted with <italic>blue</italic> and <italic>orange</italic> intervals. The parallelization occurs in <italic>chunks</italic> of query intervals delineated by the <italic>black vertical lines</italic>. One process reads query intervals into memory until a maximum gap size to the next interval is reached (e.g., chunks 2, 4) or the number of intervals exceeds the chunk size threshold (e.g., chunks 1, 3). While a new set of query intervals accumulates, the first chunk, bounded to the right by the first <italic>vertical black line</italic> above, is sent for sweeping and a placeholder is put into a FIFO (first-in, first-out) queue, so that the output remains sorted even though other chunks may finish first. The annotation files are queried with regions based on the bounds of intervals in the query chunk. The queries then return streams of intervals and, finally, those streams are sent to the chrom-sweep algorithm in a new process. When it finishes, its placeholder can be pulled from the FIFO queue and the results are yielded for output</p></caption><graphic xlink:href="13059_2016_973_Fig3_HTML" id="MO3"/></fig></p>
    </sec>
    <sec id="Sec7">
      <title><italic>Vcfanno</italic> implementation</title>
      <p><italic>Vcfanno</italic> is written in Go (<ext-link ext-link-type="uri" xlink:href="https://golang.org">https://golang.org</ext-link>), which provides a number of advantages. First, Go supports cross-compilation for 32- and 64-bit systems for Mac, Linux, and Windows. Go’s performance means that <italic>vcfanno</italic> can process large data sets relatively quickly. Go also offers a simple concurrency model, allowing <italic>vcfanno</italic> to perform intersections in parallel while minimizing the possibility of race conditions and load balancing problems that often plague parallel implementations. Moreover, as we demonstrate in the <xref rid="Sec8" ref-type="sec">Results</xref> section, <italic>vcfanno</italic>’s parallel implementation of the chrom-sweep algorithm affords speed and scalability. Lastly, it is a very flexible tool because of its support for annotations provided in many common formats such as BED, VCF, GFF, BAM, and GTF.</p>
    </sec>
  </sec>
  <sec id="Sec8">
    <title>Results</title>
    <sec id="Sec9">
      <title>Scalability of VCF annotation</title>
      <p>We annotated the publicly available VCF files from both ExAC (v3; 10,195,872 decomposed VCF records) and the 1000 Genomes Project (phase 3; 85,273,413 decomposed VCF records) to demonstrate <italic>vcfanno</italic>’s performance and scalability on both a whole-exome and a whole-genome dataset, respectively. We used an extensive set of annotations and extracted a total of 50 different attributes from 17 distinct data sets representative of common annotations (Additional file <xref rid="MOESM1" ref-type="media">1</xref>). We observed a near linear increase in annotation speed relative to a single core (3302 and 7457 seconds for ExAC and 1000 Genomes, respectively) when using two to four cores, but while performance continued to improve for additional cores, the improvement is sublinear (Fig. <xref rid="Fig4" ref-type="fig">4</xref>, Additional file <xref rid="MOESM3" ref-type="media">3</xref>: Table S1). This is expected because we inevitably reach the limits of disk speed by concurrently accessing 17 files. Moreover, the degree of parallelism is limited by how fast the main process is able to read chunks of query VCF records that are kept in memory. Nonetheless, using 16 cores, <italic>vcfanno</italic> was able to annotate the variants from ExAC in less than 8 minutes and the 1000 Genomes variants in less than 17 minutes, performing at a rate of 21,902 and 85,452 variants per second, respectively.<fig id="Fig4"><label>Fig. 4</label><caption><p>Parallelization efficiency. We show the efficiency of the parallelization strategy relative to one process on a whole-genome (1000 Genomes (<italic>1000G</italic>) in <italic>blue</italic>) and whole-exome (<italic>ExAC</italic> in <italic>green</italic>) dataset. In both cases, we are short of the ideal speedup (<italic>gray line</italic>) but we observe an approximately sevenfold speedup using 16 processors. Absolute times are provided in Additional file <xref rid="MOESM3" ref-type="media">3</xref>: Table S1</p></caption><graphic xlink:href="13059_2016_973_Fig4_HTML" id="MO4"/></fig></p>
    </sec>
    <sec id="Sec10">
      <title>The impact of interval distribution on performance</title>
      <p>As described above, chunks of intervals constitute the individual units of work in the parallel “chrom-sweep” algorithm. A chunk is “full” when either the number of intervals in the array reaches the chunk size or the genomic distance between two adjacent intervals is larger than the gap size. To understand the effect these parameters had on runtime, we varied both chunk size and gap size for the annotation of a whole-genome data set (variants from chromosome 20 of 1000 Genomes) and a whole-exome data set (variants from chromosome 20 of ExAC) given the same set of 17 annotation tracks from both whole-genome and whole-exome data sets that were used to create Fig. <xref rid="Fig4" ref-type="fig">4</xref>. The choice of whole-genome and whole-exome query sets not only represents two common annotation use cases but also serves to illuminate the effect these parameters have on different data distributions. Not surprisingly, the run times for 1000 Genomes were completely dependent on chunk size and effectively independent of gap size, while ExAC runtimes exhibited the opposite behavior (Fig. <xref rid="Fig5" ref-type="fig">5a</xref>). When intervals were more uniformly distributed throughout the genome, as with the 1000 Genomes data (Fig. <xref rid="Fig5" ref-type="fig">5b</xref>), the distance between intervals tended to be small and therefore the maximum chunk size (not gap size) determined the number of intervals contained in the typical processing chunk. In contrast, since the intervals from ExAC tend to reside in smaller and more discrete clusters, maximum chunk size had almost no effect on the size of the typical processing chunk. As a result of this exploration, we have set the default chunk and gap sizes to work well on both whole-genome and whole-exome datasets but we also allow them to be set by the user to maximize performance based on their knowledge of the datasets in question.<fig id="Fig5"><label>Fig. 5</label><caption><p>Effect of gap and chunk size on runtime for different data distributions. <bold>a</bold> Runtimes for annotating small variants on chromosome 20 for 1000 Genomes (<italic>1KG</italic>; 1,822,268 variants) and ExAC (256,057 variants) against 17 annotation files using four cores and different combinations of gap size and chunk size. <bold>b</bold> Data density for chromosome 20 of 1000 Genomes, ExAC, and the summation of the 17 annotation files</p></caption><graphic xlink:href="13059_2016_973_Fig5_HTML" id="MO5"/></fig></p>
    </sec>
    <sec id="Sec11">
      <title>Comparison to other methods</title>
      <p>While no existing tools have the same functionality as <italic>vcfanno</italic>, BCFTools [<xref ref-type="bibr" rid="CR19">19</xref>] includes an <italic>annotate</italic> command that allows one to extract fields from a <italic>single</italic> annotation file. Similarly, our own BEDTools [<xref ref-type="bibr" rid="CR10">10</xref>, <xref ref-type="bibr" rid="CR11">11</xref>] uses the chrom-sweep algorithm to facilitate single-threaded intersection across multiple annotation files, yet it does not allow one to store annotations in the INFO field of the query VCF. Nonetheless, these tools provide an informative means to assess the performance of <italic>vcfanno</italic>. Using nine different annotation sources ranging from whole-genome VCF to sparse BED files (see the <italic>vcfanno</italic> repository for replication code), we compared the runtime of <italic>vcfanno</italic> with 1, 4, 8, and 12 processes to that of BCFTools and BEDTools, both of which are single-threaded. We annotated the ExAC VCF with each tool. BEDTools can only intersect, not annotate, so we report the time to complete the intersections. BCFTools can only annotate one file at a time, so each of the nine annotations were conducted serially and we report the total time required. BEDTools is an extremely efficient method for detecting interval intersections among multiple annotation files but it is limited to a single core. BCFTools, on the other hand, can update the INFO field of the query with corresponding records from a single annotation file, but it takes longer than <italic>vcfanno</italic>, even with a single process. Using four processors, <italic>vcfanno</italic> is 3.0 times as fast as BEDTools and 6.8 times as fast as BCFTools. The performance increase resulting from using eight processors is substantial, reducing the run-time from 703 seconds down to 591, but increasing to 12 processors yields little additional benefit (Table <xref rid="Tab1" ref-type="table">1</xref>).<table-wrap id="Tab1"><label>Table 1</label><caption><p>Speed comparison with other methods</p></caption><table frame="hsides" rules="groups"><thead><tr><th>Method</th><th>Time (seconds)</th><th>Number of processors</th></tr></thead><tbody><tr><td>BEDTools</td><td char="." align="char">2135.67</td><td>1</td></tr><tr><td>BCFTools</td><td char="." align="char">4776.55</td><td>1</td></tr><tr><td><italic>vcfanno</italic></td><td char="." align="char">2621.80</td><td>1</td></tr><tr><td><italic>vcfanno</italic></td><td char="." align="char">702.72</td><td>4</td></tr><tr><td><italic>vcfanno</italic></td><td char="." align="char">590.71</td><td>8</td></tr><tr><td><italic>vcfanno</italic></td><td char="." align="char">571.65</td><td>12</td></tr></tbody></table><table-wrap-foot><p>We compare <italic>vcfanno</italic>’s performance with BEDTools and BCFTools using 1, 4, 8, and 12 processors when annotating the ExAC dataset using nine annotation files. For all tools, we stream the output to bgzip in an effort to make the comparison as fair as possible. BCFTools can annotate only a single file at a time, so the time reported is the sum of annotating each file and sending the result to the next annotation. This cannot be piped because the input to the BCFTools “annotate” tool must first be compressed by bgzip and subsequently indexed by Tabix</p></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="Sec12">
      <title>Additional features</title>
      <p><italic>Vcfanno</italic> includes additional features that provide unique functionality with respect to existing tools. Annotating structural variants (SV) is complicated by the fact that, owing to the alignment signals used for SV discovery, there is often uncertainty regarding the precise location of SV breakpoints [<xref ref-type="bibr" rid="CR20">20</xref>]. <italic>Vcfanno</italic> accounts for this uncertainty by taking into account the confidence intervals (defined by the CIPOS and CIEND attributes in the VCF specification) associated with SV breakpoints when considering annotation intersections. The confidence intervals define a genomic range in which the breakpoints are most likely to exist; therefore, it is crucial for <italic>vcfanno</italic> to take these intervals into consideration when it considers annotations associated with SV breakpoints. Moreover, since SVs frequently affect hundreds to thousands of nucleotides, they will often intersect multiple intervals per annotation file. In such cases, the summary operations described above can be used to distill the multiple annotation intersections into a single descriptive measure.</p>
      <p>Users will frequently need to further customize the annotations in the resulting VCF file. In order to facilitate this, <italic>vcfanno</italic> supports a concept of “post annotation”: that is, summary operations that are subsequently applied to the attributes that are extracted from annotation files for a given query VCF record. As an example, consider a situation where one would like to annotate each variant in one’s VCF file with the alternative allele frequency observed in the Exome Aggregation Consortium VCF. However, the ExAC VCF file solely provides the total count of chromosomes observed and the count of chromosomes exhibiting the alternative allele. Therefore, one cannot simply extract an alternative allele frequency directly from the ExAC VCF file. However, as illustrated in Fig. <xref rid="Fig6" ref-type="fig">6</xref>, if the total and alternative allele counts are extracted with <italic>vcfanno</italic> (as “exac_total” and “exac_alts”), one can define an additional “post-annotation” section that uses lua to compute the alternative allele frequency (“exac_aaf”) from the total and alternative allele counts extracted from the ExAC VCF file. Users can write extensive lua functions in an external script and subsequently call these in the <italic>annotation</italic> and <italic>post-annotation</italic> sections of the configuration file. For example, in Fig. <xref rid="Fig6" ref-type="fig">6c</xref>, we use an external lua script (provided to <italic>vcfanno</italic> on the command line) to implement a function (Additional file <xref rid="MOESM2" ref-type="media">2</xref>) that calculates the lower bound of the allele frequency confidence interval. This is useful for determining whether an allele frequency is different from 0 based on the 95 % confidence bounds. This type of specialized logic is simple to implement given lua’s scripting capabilities and allows <italic>vcfanno</italic> to be customized to a researcher’s specific needs. In fact, this “post-annotation” concept can be applied “in place” to a VCF without any annotation files, thereby allowing the user to perform modifications to a VCF file’s INFO field.<fig id="Fig6"><label>Fig. 6</label><caption><p>Using a “post-annotation” block to compute new annotations derived from existing annotations. <bold>a</bold> As described in the text, computing this post-annotation assumes that the <italic>“exac_total”</italic> and <italic>“exac_alts”</italic> fields have been extracted (via the <italic>AN</italic> and <italic>AC</italic> fields in the ExAC VCF) from the annotation file using standard annotation blocks. The AC field returns an array of alternative alleles for the variants in the annotation file that match a given variant in the query VCF. <bold>b</bold> In this post-annotation block, we calculate the alternative allele frequency in ExAC (<italic>“exac_aaf”</italic>) using “<italic>exac_alts</italic> [<xref ref-type="bibr" rid="CR1">1</xref>]” as the numerator because in this example we calculate the alternative allele frequency based on the first alternative allele. <bold>c</bold> An example of a post-annotation block that calls a function (<italic>af_conf_int</italic>) in an external lua script (Additional file <xref rid="MOESM2" ref-type="media">2</xref>) to compute the lower bound of the allele frequency confidence interval based upon counts of the alternative allele and total observed alleles. <bold>d</bold> An example invocation of <italic>vcfanno</italic> that annotates a BGZIP-compressed VCF file (<italic>example.vcf.gz</italic>) using the configuration file described in panels (<bold>a</bold>–<bold>c</bold>) (<italic>red</italic>), together with the lua script file (<italic>blue</italic>) containing the code underlying the <italic>af_conf_int</italic> function</p></caption><graphic xlink:href="13059_2016_973_Fig6_HTML" id="MO6"/></fig></p>
    </sec>
    <sec id="Sec13">
      <title>Use case demonstration</title>
      <p>Genetic studies of rare familial disease typically annotate the resulting VCF file with predictions of the consequence of each identified genetic variant on transcript function using VEP, snpEff, or VEP. However, further annotation with other reference databases is required to isolate the handful of variants that could plausibly underlie the phenotype. As an example, <italic>vcfanno</italic> could be used to further annotate the clinical significance of each variant, as well as any diseases known to be associated with the variant using the VCF files provided by ClinVar. In addition, the allele frequency and number of heterozygous and homozygous alternative genotypes observed in ExAC could be added to prevent consideration of alleles that are either too common or have too many homozygous alternative genotypes to be plausible for a rare, recessive disorder. We have provided a <italic>vcfanno</italic> configuration file that demonstrates this variant prioritization scenario at Github (<ext-link ext-link-type="uri" xlink:href="https://github.com/brentp/vcfanno/blob/master/scripts/paper/example.conf">https://github.com/brentp/vcfanno/blob/master/scripts/paper/example.conf</ext-link>).</p>
    </sec>
  </sec>
  <sec id="Sec14">
    <title>Discussion</title>
    <p>We have introduced <italic>vcfanno</italic> as a fast and flexible new software resource that facilitates the annotation of genetic variation in any species. We anticipate that <italic>vcfanno</italic> will be useful both as a standalone annotation tool and also in conjunction with downstream VCF filtering and manipulation software such as snpEff [<xref ref-type="bibr" rid="CR6">6</xref>], BCFTools [<xref ref-type="bibr" rid="CR19">19</xref>], BGT [<xref ref-type="bibr" rid="CR21">21</xref>], and GQT [<xref ref-type="bibr" rid="CR22">22</xref>]. There are, however, caveats to the proper use of <italic>vcfanno</italic> and it exhibits poorer performance in certain scenarios. Performance will vary depending upon the number of sample genotypes that are present in the input VCF file, as more samples yield a larger VCF file that requires more processing time. For example, the performance described in Figs. <xref rid="Fig4" ref-type="fig">4</xref> and <xref rid="Fig5" ref-type="fig">5</xref> reflect VCF files that lack sample genotypes (i.e., solely sites of genetic variation). When annotating the 1000 Genomes VCF that includes 2504 sample genotypes, <italic>vcfanno</italic> requires 42 minutes using 16 cores, versus 17 minutes without genotypes. Secondly, <italic>vcfanno</italic>’s relative performance is, not surprisingly, less impressive on very sparse datasets (e.g., one or two variants every 20 kb), such as a VCF resulting from the exome sequencing of one individual. While annotating these files is still quite fast (typically between 3 and 5 minutes), the sparsity of data exposes the overhead associated with using Tabix to create streams of database intervals that are germane to the current chunk. Tabix must decompress an entire BGZF block from each annotation file even if the query chunk merely includes a single variant because Tabix’s smallest block represents a genomic range of 16 kb. Therefore, when the query VCF is very sparse, an entire block from each annotation is frequently (and wastefully) decompressed for each query variant. In future versions of <italic>vcfanno</italic>, we will explore alternative approaches in order to avoid this limitation, thereby maximizing performance in all usage scenarios. Lastly, when annotating with other VCF files, it is recommended that both the variants in the query VCF and each database VCF are normalized and decomposed in order to ensure that both variant sites and alleles are properly matched when extracting attributes from the database VCF files [<xref ref-type="bibr" rid="CR23">23</xref>].</p>
  </sec>
  <sec id="Sec15">
    <title>Conclusions</title>
    <p><italic>Vcfanno</italic> is an extremely efficient and flexible software package for annotating genetic variants in VCF format in any species. It represents a substantial improvement over existing methods, enabling rapid annotation of whole-genome and whole-exome datasets and provides substantial analytical power to studies of disease, population genetics, and evolution.</p>
  </sec>
  <sec id="Sec16" sec-type="materials|methods">
    <title>Availability of data and materials</title>
    <p>Project name: <italic>vcfanno</italic></p>
    <p>Source code: <ext-link ext-link-type="uri" xlink:href="https://github.com/brentp/vcfanno">https://github.com/brentp/vcfanno</ext-link></p>
    <p>Pre-compiled binaries: <ext-link ext-link-type="uri" xlink:href="https://github.com/brentp/vcfanno/releases">https://github.com/brentp/vcfanno/releases</ext-link></p>
    <p>Documentation: <ext-link ext-link-type="uri" xlink:href="http://brentp.github.io/vcfanno/">http://brentp.github.io/vcfanno/</ext-link></p>
    <p>Scripts used in the manuscript: <ext-link ext-link-type="uri" xlink:href="https://github.com/brentp/vcfanno/tree/master/scripts/paper">https://github.com/brentp/vcfanno/tree/master/scripts/paper</ext-link></p>
    <p>Archived version: DOI: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.5281/zenodo.49500">http://dx.doi.org/10.5281/zenodo.49500</ext-link></p>
    <p>Operating system(s): Linux, OSX, Windows</p>
    <p>Programming language: Go</p>
    <p>License: MIT</p>
    <p>Any restrictions to use by non-academics: None</p>
  </sec>
</body>
<back>
  <app-group>
    <app id="App1">
      <sec id="Sec17">
        <title>Additional files</title>
        <p>
          <media position="anchor" xlink:href="13059_2016_973_MOESM1_ESM.txt" id="MOESM1">
            <label>Additional file 1:</label>
            <caption>
              <p><italic>Vcfanno</italic> configuration file for 50 different attributes from 17 distinct data sets. (TXT 3 kb)</p>
            </caption>
          </media>
          <media position="anchor" xlink:href="13059_2016_973_MOESM2_ESM.txt" id="MOESM2">
            <label>Additional file 2:</label>
            <caption>
              <p>External Lua script to compute allele frequency confidence intervals. (TXT 439 bytes)</p>
            </caption>
          </media>
          <media position="anchor" xlink:href="13059_2016_973_MOESM3_ESM.txt" id="MOESM3">
            <label>Additional file 3: Table S1.</label>
            <caption>
              <p>Detailed runtimes as a function of the number of processors. (TXT 2 kb)</p>
            </caption>
          </media>
        </p>
      </sec>
    </app>
  </app-group>
  <fn-group>
    <fn>
      <p>
        <bold>Competing interests</bold>
      </p>
      <p>The authors declare that they have no competing interests.</p>
    </fn>
    <fn>
      <p>
        <bold>Authors’ contributions</bold>
      </p>
      <p>BSP implemented the software, analyzed the data, and wrote the manuscript. RML contributed to the design of the parallel algorithm, analyzed the data, and wrote the manuscript. ARQ conceived of the software and wrote the manuscript. All authors read and approved the final manuscript.</p>
    </fn>
  </fn-group>
  <ack>
    <p>We acknowledge Liron Ganel for helpful suggestions in developing support for annotating structural variants.</p>
    <sec id="FPar1">
      <title>Funding</title>
      <p>This research was supported by a US National Human Genome Research Institute award to ARQ (NIH R01HG006693).</p>
    </sec>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <mixed-citation publication-type="other">Danecek P, Auton A, Abecasis G, Albers CA, Banks E, DePristo MA, Handsaker RE, Lunter G, Marth GT, Sherry ST, McVean G, Durbin R, 1000 Genomes Project Analysis Group. The variant call format and VCFtools. Bioinformatics. 2011;27:2156–8.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">McKenna A, Hanna M, Banks E, Sivachenko A, Cibulskis K, Kernytsky A, Garimella K, Altshuler D, Gabriel S, Daly M, DePristo MA. The Genome Analysis Toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data. Genome Res. 2010;20:1297–303.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">Garrison E, Marth G. Haplotype-based variant detection from short-read sequencing. arXiv [q-bio.GN]. 2012.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Toward better understanding of artifacts in variant calling from high-coverage samples</article-title>
        <source>Bioinformatics.</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>2843</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btu356</pub-id>
        <?supplied-pmid 24974202?>
        <pub-id pub-id-type="pmid">24974202</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">Koren A, Polak P, Nemesh J, Michaelson JJ, Sebat J, Sunyaev SR, McCarroll SA. Differential relationship of DNA replication timing to different forms of human mutation and variation. Am J Hum Genet. 2012;91:1033–40.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Cingolani P, Platts A, Wang LL, Coon M, Nguyen T, Wang L, Land SJ, Lu X, Ruden DM. A program for annotating and predicting the effects of single nucleotide polymorphisms, SnpEff: SNPs in the genome of Drosophila melanogaster strain w1118; iso-2; iso-3. Fly. 2012;6:80–92.</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hakonarson</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>ANNOVAR: functional annotation of genetic variants from high-throughput sequencing data</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <pub-id pub-id-type="doi">10.1093/nar/gkq603</pub-id>
        <?supplied-pmid 20601685?>
        <pub-id pub-id-type="pmid">20601685</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McLaren</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Pritchard</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Rios</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Flicek</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Cunningham</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Deriving the consequences of genomic variants with the Ensembl API and SNP Effect Predictor</article-title>
        <source>Bioinformatics.</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>2069</fpage>
        <lpage>70</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq330</pub-id>
        <?supplied-pmid 20562413?>
        <pub-id pub-id-type="pmid">20562413</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <mixed-citation publication-type="other">Exome Aggregation Consortium, Lek M, Karczewski K, Minikel E, Samocha K, Banks E, Fennell T, O‟Donnell-Luria A, Ware J, Hill A, Cummings B, Tukiainen T, Birnbaum D, Kosmicki J, Duncan L, Estrada K, Zhao F, Zou J, Pierce-Hoffman E, Cooper D, DePristo M, Do R, Flannick J, Fromer M, Gauthier L, Goldstein J, Gupta N, Howrigan D, Kiezun A, Kurki M, et al. Analysis of protein-coding genetic variation in 60,706 humans. bioRxiv. 2015:030338</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Quinlan</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Hall</surname>
            <given-names>IM</given-names>
          </name>
        </person-group>
        <article-title>BEDTools: a flexible suite of utilities for comparing genomic features</article-title>
        <source>Bioinformatics.</source>
        <year>2010</year>
        <volume>26</volume>
        <fpage>841</fpage>
        <lpage>2</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq033</pub-id>
        <?supplied-pmid 20110278?>
        <pub-id pub-id-type="pmid">20110278</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Quinlan</surname>
            <given-names>AR</given-names>
          </name>
        </person-group>
        <article-title>BEDTools: the Swiss-Army tool for genome feature analysis</article-title>
        <source>Curr Protoc Bioinformatics.</source>
        <year>2014</year>
        <volume>47</volume>
        <fpage>11.12.1</fpage>
        <lpage>11.12.34</lpage>
        <pub-id pub-id-type="doi">10.1002/0471250953.bi1112s47</pub-id>
        <pub-id pub-id-type="pmid">25199790</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <mixed-citation publication-type="other">Neph S, Kuehn MS, Reynolds AP, Haugen E, Thurman RE, Johnson AK, Rynes E, Maurano MT, Vierstra J, Thomas S, Sandstrom R, Humbert R, Stamatoyannopoulos JA. BEDOPS: high-performance genomic feature operations. Bioinformatics. 2012;28:1919–20.</mixed-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Kent WJ, Sugnet CW, Furey TS, Roskin KM, Pringle TH, Zahler AM, Haussler D. The human genome browser at UCSC. Genome Res. 2002;12:996–1006.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Layer RM, Quinlan AR. A parallel algorithm for $N$-way interval set intersection. Proc IEEE. 2015;99:1–10.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">McKenney M, McGuire T. A parallel plane sweep algorithm for multi-core systems. In: Proceedings of the 17th ACM SIGSPATIAL International Conference on Advances in Geographic Information Systems. ACM; 2009. pp. 392–395. <ext-link ext-link-type="uri" xlink:href="http://dl.acm.org/citation.cfm?id=1653827">http://dl.acm.org/citation.cfm?id=1653827</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Khlopotine</surname>
            <given-names>AB</given-names>
          </name>
          <name>
            <surname>Jandhyala</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Kirkpatrick</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>A variant of parallel plane sweep algorithm for multicore systems</article-title>
        <source>IEEE Trans Comput Aided Des Integr Circuits Syst.</source>
        <year>2013</year>
        <volume>32</volume>
        <fpage>966</fpage>
        <lpage>70</lpage>
        <pub-id pub-id-type="doi">10.1109/TCAD.2013.2245940</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Tabix: fast retrieval of sequence features from generic TAB-delimited files</article-title>
        <source>Bioinformatics.</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>718</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq671</pub-id>
        <?supplied-pmid 21208982?>
        <pub-id pub-id-type="pmid">21208982</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <mixed-citation publication-type="other">Daniel Kortschak R, Adelson DL. bíogo: a simple high-performance bioinformatics toolkit for the Go language. bioRxiv. 2014:005033.</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <mixed-citation publication-type="other">Li H, Handsaker B, Wysoker A, Fennell T, Ruan J, Homer N, Marth G, Abecasis G, Durbin R, 1000 Genome Project Data Processing Subgroup. The Sequence Alignment/Map format and SAMtools. Bioinformatics. 2009;25:2078–9.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Quinlan</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Hall</surname>
            <given-names>IM</given-names>
          </name>
        </person-group>
        <article-title>Characterizing complex structural variation in germline and somatic genomes</article-title>
        <source>Trends Genet.</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>43</fpage>
        <lpage>53</lpage>
        <pub-id pub-id-type="doi">10.1016/j.tig.2011.10.002</pub-id>
        <?supplied-pmid 22094265?>
        <pub-id pub-id-type="pmid">22094265</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>BGT: efficient and flexible genotype query across many samples</article-title>
        <source>Bioinformatics.</source>
        <year>2016</year>
        <volume>32</volume>
        <fpage>590</fpage>
        <lpage>2</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv613</pub-id>
        <?supplied-pmid 26500154?>
        <pub-id pub-id-type="pmid">26500154</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Layer RM, Kindlon N, Karczewski KJ, Exome Aggregation Consortium, Quinlan AR. Efficient genotype compression and analysis of large genetic-variation data sets. Nat Methods. 2015</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tan</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Abecasis</surname>
            <given-names>GR</given-names>
          </name>
          <name>
            <surname>Kang</surname>
            <given-names>HM</given-names>
          </name>
        </person-group>
        <article-title>Unified representation of genetic variants</article-title>
        <source>Bioinformatics.</source>
        <year>2015</year>
        <volume>31</volume>
        <fpage>2202</fpage>
        <lpage>4</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btv112</pub-id>
        <?supplied-pmid 25701572?>
        <pub-id pub-id-type="pmid">25701572</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
