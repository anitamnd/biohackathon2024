<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Acta Crystallogr D Struct Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Acta Crystallogr D Struct Biol</journal-id>
    <journal-id journal-id-type="publisher-id">Acta Cryst. D</journal-id>
    <journal-title-group>
      <journal-title>Acta Crystallographica. Section D, Structural Biology</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2059-7983</issn>
    <publisher>
      <publisher-name>International Union of Crystallography</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6400257</article-id>
    <article-id pub-id-type="pmid">30821710</article-id>
    <article-id pub-id-type="publisher-id">ba5291</article-id>
    <article-id pub-id-type="doi">10.1107/S205979831801238X</article-id>
    <article-id pub-id-type="coden">ACSDAD</article-id>
    <article-id pub-id-type="pii">S205979831801238X</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research Papers</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Processing serial crystallography data with <italic>CrystFEL</italic>: a step-by-step guide</article-title>
      <alt-title>Processing serial crystallography data with <italic>CrystFEL</italic></alt-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-8407-0270</contrib-id>
        <name>
          <surname>White</surname>
          <given-names>Thomas A.</given-names>
        </name>
        <xref ref-type="aff" rid="a">a</xref>
        <xref ref-type="corresp" rid="cor">*</xref>
      </contrib>
      <aff id="a"><label>a</label>Center for Free-Electron Laser Science, <institution>Deutsches Elektronen-Synchrotron DESY</institution>, Notkestrasse 85, Hamburg, <country>Germany</country></aff>
    </contrib-group>
    <author-notes>
      <corresp id="cor">Correspondence e-mail: <email>taw@physics.org</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <day>01</day>
      <month>2</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>31</day>
      <month>1</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>31</day>
      <month>1</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>75</volume>
    <issue>Pt 2</issue>
    <issue-id pub-id-type="publisher-id">d190200</issue-id>
    <fpage>219</fpage>
    <lpage>233</lpage>
    <history>
      <date date-type="received">
        <day>20</day>
        <month>4</month>
        <year>2018</year>
      </date>
      <date date-type="accepted">
        <day>31</day>
        <month>8</month>
        <year>2018</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© White 2019</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0/">
        <license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution (CC-BY) Licence, which permits unrestricted
use, distribution, and reproduction in any medium, provided the original authors and source are cited.</license-p>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/">http://creativecommons.org/licenses/by/4.0/</ali:license_ref>
      </license>
    </permissions>
    <self-uri xlink:href="https://doi.org/10.1107/S205979831801238X">A full version of this article is available from Crystallography Journals Online.</self-uri>
    <abstract abstract-type="toc">
      <p>A step-by-step guide to processing serial crystallography data from X-ray free-electron lasers and synchrotron sources using <italic>CrystFEL</italic> is provided.</p>
    </abstract>
    <abstract>
      <p>This article provides a step-by-step guide to the use of the <italic>CrystFEL</italic> software for processing serial crystallography data from an X-ray free-electron laser or a synchrotron light source. Whereas previous papers have described the theory and algorithms and their rationale, this paper describes the steps to be performed from a user perspective, including command-line examples.</p>
    </abstract>
    <kwd-group>
      <kwd>
        <italic>CrystFEL</italic>
      </kwd>
      <kwd>serial crystallography</kwd>
      <kwd>X-ray free-electron lasers</kwd>
      <kwd>data processing</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>Helmholtz Association</funding-source>
      </award-group>
      <funding-statement>This work was funded by <funding-source>Helmholtz Association</funding-source> grant . </funding-statement>
    </funding-group>
    <conference>
      <conf-date/>
      <conf-name>Multi and serial data collection and processing</conf-name>
      <conf-loc/>
    </conference>
    <counts>
      <page-count count="15"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="introduction" id="sec1">
    <label>1.</label>
    <title>Introduction   </title>
    <p>Serial crystallography (SX) techniques, in which a single diffraction snapshot is recorded from each of a large number of crystals, have recently become popular for use at X-ray free-electron laser (XFEL) facilities (Chapman <italic>et al.</italic>, 2011<xref ref-type="bibr" rid="bb9"> ▸</xref>) and synchrotron light sources (Stellato <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb35"> ▸</xref>). They represent part of a significant recent trend towards large data sets in crystallography, requiring automated data-processing pipelines and large-scale computing environments. <italic>CrystFEL</italic> was created to meet the needs arising from this trend, as a piece of software for processing serial crystallography data sets consisting of large numbers of essentially unrelated diffraction snapshots.</p>
    <p><italic>CrystFEL</italic> was first released in 2012 (White <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb40"> ▸</xref>). It is free and open-source software (Ince <italic>et al.</italic>, 2012<xref ref-type="bibr" rid="bb19"> ▸</xref>), which means that the full source code is provided, with freedom to study the code and make changes if necessary. Since the first version, incremental improvements to <italic>CrystFEL</italic> have had a significant impact on the scientific outcomes of experiments by improving the quality of the information that it can extract from a given set of raw data (Nass <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb30"> ▸</xref>)</p>
    <p><italic>CrystFEL</italic> can be downloaded from the <italic>CrystFEL</italic> website at <ext-link ext-link-type="uri" xlink:href="https://www.desy.de/~twhite/crystfel">https://www.desy.de/~twhite/crystfel</ext-link>. The website also contains a large amount of other information, including a tutorial, installation instructions, best-practice guidelines, frequently asked questions, changes between versions, presentation slides, a list of citations and programming-interface information for developers.</p>
    <p>Fig. 1<xref ref-type="fig" rid="fig1"> ▸</xref> shows the layout of the most important folders in the <italic>CrystFEL</italic> package. <italic>CrystFEL</italic> is a suite of software comprising 15 core programs: <italic>indexamajig</italic>, <italic>ambigator</italic>, <italic>process_hkl</italic>, <italic>partialator</italic>, <italic>compare_hkl</italic>, <italic>check_hkl</italic>, <italic>cell_explorer</italic>, <italic>geoptimiser</italic>, <italic>hdfsee</italic>, <italic>list_events</italic>, <italic>render_hkl</italic>, <italic>whirligig</italic>, <italic>get_hkl</italic>, <italic>partial_sim</italic> and <italic>pattern_sim</italic>. <italic>CrystFEL</italic> is primarily a command-line-driven piece of software, with some exceptions which will be detailed later. Once installed, reference documentation for these programs can be obtained using the standard Unix manual system by typing <monospace>man indexamajig</monospace> (or any other program name) at the command line. A top-level manual page, accessed via <monospace>man crystfel</monospace>, gives an overall introduction. The manual pages are also available on the <italic>CrystFEL</italic> website.</p>
    <p>The overall flow of data processing is shown in Figs. 2<xref ref-type="fig" rid="fig2"> ▸</xref>, 3<xref ref-type="fig" rid="fig3"> ▸</xref>, 4<xref ref-type="fig" rid="fig4"> ▸</xref> and 5<xref ref-type="fig" rid="fig5"> ▸</xref>, including the programs which are needed at each stage. The diagrams are not exhaustive, but show the main pathway through processing a data set, starting with preparing the data and ending with importing the data into external programs for structure solution.</p>
    <p>This article describes the processing pipeline using <italic>CrystFEL</italic> v.0.7.0, which is the latest version at the time of writing. Basic knowledge of the Unix command-line environment will be assumed. Lines beginning with <monospace>$</monospace> indicate examples of commands, in which line breaks should be ignored, <italic>i.e.</italic> they should be entered on a single line.</p>
    <p>In addition to the core programs, the <italic>CrystFEL</italic> package contains a repository of scripts which are intended to be copied to the working directory and customised to suit the individual situation. To make these scripts readily accessible, it is helpful to download a separate copy of <italic>CrystFEL</italic> even if it has been installed centrally on a facility computer system. After copying a script to the working directory, it will usually be necessary to mark it as executable using <monospace>chmod +x</monospace>.</p>
    <p>While this article attempts to describe alternative possibilities at each processing step, the supporting information contains a complete worked example for some freely available data. In the worked example, the full sequence of commands can be seen with only short comments, but including the expected outputs from each program.</p>
  </sec>
  <sec id="sec2">
    <label>2.</label>
    <title>Preparing the data   </title>
    <p>As with almost any computational data-processing procedure, the first task is to put the data into a file format that can be read by the software. <italic>CrystFEL</italic> can read image data in Crystallographic Binary Format (CBF) or Hierarchical Data Format v.5 (HDF5). HDF5 is itself a ‘container format’, meaning that the data inside it can be in variety of layouts. For example, one file on disk might contain a single two-dimensional image, or many two-dimensional images stacked together to form a three-dimensional array. The range of HDF5 layouts usable by <italic>CrystFEL</italic> has been described previously (White, Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb28"> ▸</xref>) and includes the formats written by <italic>Cheetah</italic> (Barty <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb2"> ▸</xref>), <italic>CASS</italic> (Foucar, 2016<xref ref-type="bibr" rid="bb12"> ▸</xref>), <italic>OnDA</italic> (Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb28"> ▸</xref>) and <italic>psocake</italic> (Shin <italic>et al.</italic>, 2018<xref ref-type="bibr" rid="bb34"> ▸</xref>), which all use their own layouts. The NeXus standard (Bernstein <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb3"> ▸</xref>; Könnecke <italic>et al.</italic>, 2015<xref ref-type="bibr" rid="bb25"> ▸</xref>) is based on HDF5 and can also be used by <italic>CrystFEL</italic>. Dectris EIGER detectors write data in NeXus HDF5 format.</p>
    <p>Duplication of the data in a new format should be avoided wherever possible, particularly if the total size of the data is very large. The support of <italic>CrystFEL</italic> for CBF and EIGER formats means that no data-format conversion step will be necessary for many synchrotron experiments. For other experiments, notably those performed using the Linac Coherent Light Source (LCLS), the data will need to be converted from the specialised format written by the data-acquisition system. In the case of LCLS, this format is known as eXtended Tagged Container (XTC; Thayer <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb36"> ▸</xref>). At the same time as converting the format, detector-calibration steps such as subtracting background signals may need to be performed. If a format conversion or detector-readout intensity calibration step is necessary, it is best combined with a ‘hit-finding’ step to reduce the amount of data duplicated. This means that output files are written only for frames which appear to contain Bragg spots and therefore have a good chance of being useful.</p>
    <p>The initial stages of file-format conversion, detector-readout calibration and hit finding, are beyond the scope of <italic>CrystFEL</italic> and therefore also beyond the scope of this article. Unfortunately, owing to the many differences between facility data formats and processing environments, this can be one of the most challenging steps. Several programs are available, including <italic>Cheetah</italic>, <italic>CASS</italic>, <italic>OnDA</italic> and <italic>psocake</italic>, which have all been mentioned above. Tutorials are available on the web for <italic>Cheetah</italic> (<ext-link ext-link-type="uri" xlink:href="https://www.desy.de/~barty/cheetah/Cheetah/">https://www.desy.de/~barty/cheetah/Cheetah/</ext-link>), including the steps necessary to get started at various facilities, and <italic>psocake</italic> (<ext-link ext-link-type="uri" xlink:href="https://confluence.slac.stanford.edu/display/PSDM/Psocake+SFX+tutorial">https://confluence.slac.stanford.edu/display/PSDM/Psocake+SFX+tutorial</ext-link>). For SX experiments at the SPring-8 Ångstrom Compact Laser (SACLA), a data-processing pipeline is provided which writes the hits in HDF5 format using <italic>Cheetah</italic> (Nakane <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb29"> ▸</xref>), and a tutorial is also available (<ext-link ext-link-type="uri" xlink:href="https://github.com/biochem-fan/cheetah/wiki">https://github.com/biochem-fan/cheetah/wiki</ext-link>).</p>
    <p><italic>CrystFEL</italic> requires a ‘detector geometry file’, the purpose of which is twofold. Firstly, it tells <italic>CrystFEL</italic> how the data are laid out in the input file, for instance whether there is just one frame or many frames per file. Secondly, it tells <italic>CrystFEL</italic> how the detector is laid out in physical space. Complicated multi-panel detectors are common in XFEL experiments (Philipp <italic>et al.</italic>, 2010<xref ref-type="bibr" rid="bb31"> ▸</xref>; Kameshima <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb22"> ▸</xref>; Allahgoli <italic>et al.</italic>, 2015<xref ref-type="bibr" rid="bb1"> ▸</xref>), and the geometry file describes the position and orientation of each panel in three dimensions, as well as additional constants such as the pixel size and the photon energy. The photon energy can vary from frame to frame because of the operating principle of an XFEL (Bonifacio <italic>et al.</italic>, 1994<xref ref-type="bibr" rid="bb5"> ▸</xref>), and so a location within the data file containing the energy for each frame can be given instead of a fixed number for all of the frames. The geometry file hence contains all of the information that is needed to interpret the contents of the data file as the physical setup of a diffraction experiment. As with almost all files used by <italic>CrystFEL</italic>, the geometry file is a plain-text file, and documention of the format can be accessed with the command <monospace>man crystfel_geometry</monospace>.</p>
    <p>Unfortunately, like hit finding and detector-readout intensity calibration, creating and refining a geometry file for a complicated multipanel detector is a daunting task, and is itself the subject of entire papers (Yefanov <italic>et al.</italic>, 2015<xref ref-type="bibr" rid="bb44"> ▸</xref>; Ginn &amp; Stuart, 2017<xref ref-type="bibr" rid="bb17"> ▸</xref>; Brewster <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb7"> ▸</xref>). Some example geometry files are distributed with <italic>CrystFEL</italic>, which can be used as templates, including examples for the CSPAD detector at LCLS in two different datafile layouts (see Fig. 1<xref ref-type="fig" rid="fig1"> ▸</xref>). The LCLS publishes a repository of geometry files for its detectors on its website (<ext-link ext-link-type="uri" xlink:href="https://confluence.slac.stanford.edu/display/PSDM/Geometry+History">https://confluence.slac.stanford.edu/display/PSDM/Geometry+History</ext-link>). Geometrical information about the detector and its position relative to the beam should be available from the X-ray facility as a rough starting point. As a general guideline, to get started with processing a data set, the panel positions need to be accurate to much less than the smallest separation between Bragg peaks which will be seen in any pattern. Once a few patterns can be processed, the geometry can be refined as described in Section 3.4;<xref ref-type="sec" rid="sec3.4"/>. For the final data analysis, the geometry should reach subpixel accuracy.</p>
    <p>The final preparatory task is to create a list of the files to process in text format. This can easily be performed using standard Unix command-line tools, for example, to create <monospace>files.lst</monospace> containing a list of all CBF files in the folder <monospace>data</monospace>:<disp-formula id="fdu1"><graphic xlink:href="d-75-00219-efd1.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>If the data are stored in files which contain more than one frame each, the procedure is the same. <italic>CrystFEL</italic> will recognise that each file contains more than one frame and process every frame individually. If all of the data are contained in a single file, then there need only be one filename in the list. The list of input files need not include every frame of data, allowing selective processing of data. To perform this when each file contains multiple frames, the program <italic>list_events</italic> can expand the list of multiframe files to a full list of frame identifiers, which can then be altered as required.</p>
  </sec>
  <sec id="sec3">
    <label>3.</label>
    <title>Indexing and integration   </title>
    <p>The flow of data preparation, indexing and integration is shown in Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref>. The heart of <italic>CrystFEL</italic> is the indexing and integration tool <italic>indexamajig</italic>. This program reads the list of filenames or event descriptors prepared earlier, reads the image data and executes the indexing and integration pipeline. A flowchart for the pipeline has been given previously (White, Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb28"> ▸</xref>). The first step is to find the locations of the obvious Bragg peaks in the image. These are then used to index the pattern, which is followed by a series of refinement and result-checking steps. If the indexing solution is accepted, the unit-cell parameters and orientation, combined with the detector geometry, wavelength and other information about the X-ray beam, are used to calculate the positions of the Bragg peaks in the frame. Their intensities are then measured from the image data. In this way, the intensities are measured not only for the strong reflections but also for the weak or absent reflections, which are equally important for solving the structure. The output from <italic>indexamajig</italic> is known as a stream file. It is a long text file which contains the indexing and integration results, as well as other information such as the locations of peaks and the unit-cell parameters, for each frame in succession.</p>
    <p>To begin processing the data, the list of files, geometry file and output stream filename need to be given to <italic>indexamajig</italic>. For example, for a list of files called <monospace>files.lst</monospace>, a geometry file called <monospace>my.geom</monospace> and an output filename <monospace>my.stream</monospace>, the command line would be<disp-formula id="fdu2"><graphic xlink:href="d-75-00219-efd2.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The command-line option <monospace>-i</monospace> specifies the input file, <monospace>-g</monospace> the geometry file and <monospace>-o</monospace> the output stream. In practice, additional parameters will be needed to tune the algorithms, as described below.</p>
    <sec id="sec3.1">
      <label>3.1.</label>
      <title>Setting up peak detection   </title>
      <p>Accurate peak detection is important for successful indexing. If too many spots are missed there may not be sufficient information for the indexing algorithm and subsequent refinement algorithms. If too many spurious spots are included, the indexing may not be able to find the true lattice repeats in the pattern. It therefore pays to take some time to optimise the peak-detection parameters. <italic>CrystFEL</italic> offers a choice of peak-detection algorithms. The simpler algorithms have fewer parameters to tune but are more susceptible to noise.</p>
      <p>If the raw data have been processed using <italic>Cheetah</italic>, the data files will usually contain lists of peak positions. Hit finding in <italic>Cheetah</italic> is performed by finding peaks in each pattern and accepting frames which contain at least a certain minimum number of peaks. Since the peak detection needs to be tuned in <italic>Cheetah</italic> anyway, it makes sense to reuse the peak-detection results in <italic>CrystFEL</italic> rather than to perform new peak detection. This can be performed by adding the following option to the <italic>indexamajig</italic> command line if <italic>Cheetah</italic> has been configured to generate single-frame data files,<disp-formula id="fdu3"><graphic xlink:href="d-75-00219-efd3.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>or the following if <italic>Cheetah</italic> has been configured to generate multiframe data files in CXI format,<disp-formula id="fdu4"><graphic xlink:href="d-75-00219-efd4.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>For other types of input data, the peak-detection algorithms built into <italic>CrystFEL</italic> should be used. The simplest of these is a gradient-based search (Zaefferer, 2000<xref ref-type="bibr" rid="bb45"> ▸</xref>),<disp-formula id="fdu5"><graphic xlink:href="d-75-00219-efd5.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>This algorithm has three tunable parameters: the threshold, the minimum gradient and the minimum signal-to-noise ratio. Peak detection is triggered when the pixel value is above the threshold and the local gradient of the pixel values exceeds the minimum gradient. For the candidate peak to be accepted, its total intensity must be greater than the specified number of times its estimated error. These three parameters are given using the following three options for <italic>indexamajig</italic>; for example for a threshold of 100 detector units (adu), a minimum gradient of 100 adu per pixel and a minimum signal-to-noise ratio of 5,<disp-formula id="fdu6"><graphic xlink:href="d-75-00219-efd6.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Owing to a historical mistake, the parameter given to <monospace>--min-gradient</monospace> is actually the <italic>square</italic> of the required gradient measured in adu per pixel. This has not been changed because of the importance of maintaining compatibility with earlier versions and giving consistent results with the same input parameters.</p>
      <p>The appropriate values for the peak-detection parameters depend strongly on the type of detector, the strength of the Bragg peaks and the amount of background scattering. Initial values can be determined by examining the image data. For this, any image viewer can be used. <italic>CrystFEL</italic> offers a simple viewer called <italic>hdfsee</italic>, which can be invoked as follows, in this case for an image file called <monospace>image.cbf</monospace> and a geometry file called <monospace>my.geom</monospace>,<disp-formula id="fdu7"><graphic xlink:href="d-75-00219-efd7.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>For simple data layouts, the geometry-file argument (<monospace>-g my.geom</monospace>) can be omitted. However, using the geometry file allows <italic>hdfsee</italic> to show the image data in the correct physical layout. Once started, the pixel values can be examined by opening the ‘View Numbers’ window from the ‘Tools’ menu. Clicking anywhere on the image results in the pixel values in that vicinity being shown in this window. Using this, the background level and heights of typical peaks can be estimated. The initial threshold should be a slightly larger value than most of the background pixels, but much smaller than the Bragg peaks. The initial (squared) gradient should be the square of about half of the difference between the average background and typical Bragg peak intensities. A value of 3 is usually a suitable initial estimate for the signal-to-noise ratio, provided that the geometry file contains the correct value for the number of detector intensity units per photon.</p>
      <p>Another peak-search algorithm in <italic>CrystFEL</italic> is called <italic>peakfinder</italic>8. This algorithm originated in <italic>Cheetah</italic> (Barty <italic>et al.</italic>, 2014<xref ref-type="bibr" rid="bb2"> ▸</xref>) and was incorporated in <italic>CrystFEL</italic> because it gives better results when the background intensity varies radially but has approximate circular symmetry. This algorithm searches for peaks above a radius-dependent threshold intensity, checks their signal-to-noise ratio and also requires that peaks contain a certain minimum number of pixels above the threshold. The command-line options for this peak-search algorithm can be found on the <italic>indexamajig</italic> manual page, which is accessed using the command <monospace>man indexamajig</monospace>.</p>
      <p>To test the peak-detection parameters, <italic>indexamajig</italic> should be run on the first few frames of the data set. Although not necessary, it simplifies matters to also tell <italic>indexamajig</italic> not to proceed with indexing and integrating each pattern at this stage. This can easily be performed by adding <monospace>--indexing=none</monospace>, an option which will be described in more detail in the next section. The full command line, combining the elements described above, might look like<disp-formula id="fdu8"><graphic xlink:href="d-75-00219-efd8.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p><italic>indexamajig</italic> will periodically display progress updates, including the number of frames processed. After sufficient frames have been processed for inspection (about 100), it can be interrupted by pressing Ctrl+C, the normal command-line interrupt keystroke.</p>
      <p>The stream file written by <italic>indexamajig</italic> can then be used to make an initial evaluation of the accuracy of the peak detection. A simple script has been provided for this purpose, called <italic>check-peak-detection</italic>. This script opens <italic>hdfsee</italic> sequentially for each frame, each time displaying the image with spot positions circled. If many false peaks are seen, the values of the peak-finding parameters should usually be increased to make the detection more stringent. If many real peaks are missed, the values should usually be decreased. After checking a frame, closing the <italic>hdfsee</italic> window will cause the script to open it again with the next frame. The script should be copied into the working directory from the scripts folder in the <italic>CrystFEL</italic> download package, marked as executable and then run, as follows:<disp-formula id="fdu9"><graphic xlink:href="d-75-00219-efd9.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>As might be expected, the geometry file should be given to allow the images to be displayed in a physically realistic layout. Here, it is assumed that the <italic>CrystFEL</italic> download package is located in the home directory (∼).</p>
      <p>Another option for checking the peak detection is to use the <italic>cxiview</italic> program from the <italic>Cheetah</italic> package. At the cost of installing a separate piece of software, this program offers a more comfortable experience, such as the ability to move backwards, skip frames or jump randomly among the frames in the stream, instead of viewing them in sequence. It also allows the peaks from the peak search and the calculated spot locations to be viewed together. Documentation for <italic>cxiview</italic> is available on the WWW at <ext-link ext-link-type="uri" xlink:href="https://www.desy.de/~barty/cheetah/Cheetah/cxiview.html">https://www.desy.de/~barty/cheetah/Cheetah/cxiview.html</ext-link>.</p>
      <p>Once the peak finding is approximately satisfactory, it can be further refined with reference to the fraction of indexed patterns, as described in Section 3.3<xref ref-type="sec" rid="sec3.3"/>.</p>
      <p>There are a few more parameters which will need to be determined at this stage for the best final data quality, namely the size of the integration regions used to measure the intensities of the reflections and the background around them. When integrating a reflection, <italic>CrystFEL</italic> will consider a circular region centred on the calculated reflection position, which should contain the peak itself, and an annulus further out, from which it estimates the background underneath the peak (White <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb39"> ▸</xref>). Three parameters need to be determined: the radius of the peak region and the inner and outer radii of the background annulus. The default parameters (four, five and seven pixels, respectively) are usually appropriate for data with sharp, widely separated Bragg peaks, but for less sharp peaks or closer spot separation they may need to be altered. This can be performed visually while inspecting the peak-detection results using <italic>hdfsee</italic> via the <italic>check-peak-detection</italic> script. Using the ‘View’ menu, the binning of the image can be set to 1, so that it is displayed pixel-for-pixel on the screen. The radii of the circles used to indicate the peak positions can also be set via the ‘View’ menu, allowing them to be visualised. The peak radius should be set such that the entirety of each peak is within the circle, with a pixel or two of buffer region to allow for residual inaccuracy in the detector geometry. The inner and outer background radii should be set such that the annulus falls entirely in the gaps between rows of reflections as far as possible, but otherwise is as large as possible. The three radii (peak, background inner and outer respectively) should then be given to <italic>indexamajig</italic> using the option <monospace>--int-radius</monospace>, as follows<disp-formula id="fdu10"><graphic xlink:href="d-75-00219-efd10.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>Finally, if the input data contain a large number of empty patterns, it will make the processing faster if patterns with a small number of peaks are skipped over. This can be performed using the option <monospace>--min-peaks</monospace>; for example, to ignore all patterns with fewer than 50 peaks this would be <monospace>--min-peaks=50</monospace>.</p>
    </sec>
    <sec id="sec3.2">
      <label>3.2.</label>
      <title>Determining the unit cell   </title>
      <p><italic>CrystFEL</italic> offers a choice of indexing methods. Most of the methods involve calling external indexing programs such as <italic>MOSFLM</italic> (Powell, 1999<xref ref-type="bibr" rid="bb32"> ▸</xref>), <italic>DirAx</italic> (Duisenberg, 1992<xref ref-type="bibr" rid="bb11"> ▸</xref>), <italic>FELIX</italic> (Beyerlein <italic>et al.</italic>, 2017<xref ref-type="bibr" rid="bb4"> ▸</xref>) or <italic>XDS</italic> (Kabsch, 1988<xref ref-type="bibr" rid="bb20"> ▸</xref>, 2010<xref ref-type="bibr" rid="bb21"> ▸</xref>). Other methods are built into <italic>CrystFEL</italic>, including an implementation of the <italic>TakeTwo</italic> algorithm (Ginn <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb16"> ▸</xref>). The indexing methods can be selected using the <monospace>--indexing</monospace> option in <italic>indexamajig</italic>. For example, the following option would select <italic>MOSFLM</italic>, using <italic>DirAx</italic> as a fallback if indexing with <italic>MOSFLM</italic> is not successful:<disp-formula id="fdu11"><graphic xlink:href="d-75-00219-efd11.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The sequence of fallback indexing methods can be any length, or a single indexing method can be used. Indexing can also be disabled completely by specifying ‘none’ as the indexing method, as was used above to set up peak detection.</p>
      <p>To make things easier, <italic>CrystFEL</italic> v.0.7.0 can automatically determine which indexing methods are available. Methods will be added to the list, in a preset order of priority, if the corresponding programs are installed on the computer. Some indexing methods require the unit-cell parameters to be known in advance, and these methods will be automatically added to the list when parameters are provided (see Section 3.3<xref ref-type="sec" rid="sec3.3"/>). Automatic selection of the indexing methods will occur unless the <monospace>--indexing</monospace> parameter is given to <italic>indexamajig</italic>. Therefore, the only change needed to enable indexing is to remove the <monospace>--indexing=none</monospace> option from the previous command line:<disp-formula id="fdu12"><graphic xlink:href="d-75-00219-efd12.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>Usually, the more indexing methods that can be used, the higher the overall indexing fraction will be. However, enabling more indexing methods will make the processing take longer. When determining the unit cell, it is usually better to restrict the indexing to one method because different programs may produce different representations of the same unit cell. For example, <italic>DirAx</italic> does not handle centred unit cells and will always give a primitive representation of a centred cell. <italic>MOSFLM</italic> is a good choice because it runs quickly but also offers the ability to use prior lattice-type information if available.</p>
      <p>In <italic>CrystFEL</italic> v.0.7.0, the order of priority for automatic determination places the fastest methods first. <italic>MOSFLM</italic> comes first of all, because it runs quickly but also offers many features such as the ability to use prior information. <italic>XDS</italic> is placed last, since in our experience it is the least successful at indexing snapshot patterns. <italic>TakeTwo</italic> and <italic>FELIX</italic> are excluded from automatic determination because they can take a long time to run. The order of indexing methods should not normally need to be overridden.</p>
      <p>Indexing frames takes significantly longer than just peak detection. Therefore, at this stage it may be useful to instruct <italic>indexamajig</italic> to process several frames in parallel. This can be performed by simply adding the option <monospace>-j <italic>n</italic></monospace>, where <italic>n</italic> is the number of frames which should be processed at once. Usually, <italic>n</italic> should equal the number of processors in the computer. This type of multiprocessing only works within one computer, whereas Section 6.3<xref ref-type="sec" rid="sec6.3"/> describes how to multiprocess across several computers in a cluster environment.</p>
      <p>If no prior information about the unit-cell parameters is given, <italic>indexamajig</italic> will index the patterns freely, meaning that the indexing algorithms will be required to determine the six unit-cell parameters (<italic>a</italic>, <italic>b</italic>, <italic>c</italic>, α, β, γ) and the crystal orientation (three further parameters). If everything goes well, the unit-cell parameters should have similar values for all frames. In practice, there will be some variation owing to experimental error and also some outlying sets of parameters. Since the output from <italic>indexamajig</italic> is a simple text file, albeit a large one, it is quite easy to find the unit-cell parameters. They appear on lines in the stream starting with the text ‘Cell parameters’. To conveniently inspect the overall distributions of parameters, the <italic>CrystFEL</italic> program <italic>cell_explorer</italic> can be used. It is invoked very simply:<disp-formula id="fdu13"><graphic xlink:href="d-75-00219-efd13.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>The graphical user interface of <italic>cell_explorer</italic> is shown in Fig. 6<xref ref-type="fig" rid="fig6"> ▸</xref>. It reads the unit-cell parameter information for every frame in the stream and plots histograms for the six unit-cell parameters, using colour coding to represent the different centring types. It allows the graphs to be panned (by click/dragging the mouse), zoomed in or out (using the scroll wheel) and the histogram binning to be altered (using the + and − keys). By click/dragging the mouse with the shift key held down, a range of values can be selected for one of the parameters. If this is performed, any set of unit-cell parameters which has that parameter outside the selected range will be excluded. This allows the true parameters to be extracted, even if there is a complicated mixture of different cells (whether this is owing to problems with the data processing or because there is truly a mixture of different lattices among the crystals).</p>
      <p>The true unit-cell parameters should appear as strong, sharp peaks in the histograms. Otherwise, a problem with the earlier data processing should be suspected; the most common cause is an inaccurate detector-geometry file, such as an incorrect beam-centre location or an incorrect camera-length value. Once a plausible set of parameters has been found, <italic>cell_explorer</italic> can fit curves to the selected peaks. To perform this, the peaks for all parameters should first be selected (using shift+click/drag) and the fitting procedure then triggered using ‘Fit cell’ in the ‘Tools’ menu or by pressing Ctrl+F. The fitted values will be displayed on each histogram, including an estimated standard deviation, and can be exported (using ‘Create unit cell file’ under the ‘File’ menu) to a text file for the next step.</p>
    </sec>
    <sec id="sec3.3">
      <label>3.3.</label>
      <title>Indexing and integrating using unit-cell constraints   </title>
      <p>Providing expected unit-cell parameters to <italic>indexamajig</italic> enables it to reject indexing solutions which do not match. It is obviously essential for merging the data that the unit-cell parameters for all crystals are consistent. In addition, providing unit-cell parameters allows the use of indexing algorithms which determine only the orientation of the crystal, which is in principle an easier task. The <italic>TakeTwo</italic> (Ginn <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb16"> ▸</xref>) and <italic>FELIX</italic> (Beyerlein <italic>et al.</italic>, 2017<xref ref-type="bibr" rid="bb4"> ▸</xref>) indexing algorithms belong to this category. Some indexing programs, such as <italic>MOSFLM</italic>, can make use of prior unit-cell information but do not require it, and this is also taken into account by <italic>indexamajig</italic>. Therefore, the only change that needs to be made to perform this step is to provide the unit-cell parameter file written by <italic>cell_explorer</italic>, which is performed using the option <monospace>-p</monospace>, <disp-formula id="fdu14"><graphic xlink:href="d-75-00219-efd14.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>An example of a full command line for <italic>indexamajig</italic>, including the option for multiprocessing on a four-processor machine, is therefore as follows:<disp-formula id="fdu15"><graphic xlink:href="d-75-00219-efd15.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>The ‘indexing rate’, which is defined as the fraction of frames in which at least one crystal lattice could be found, will periodically be displayed. It is normal for the indexing rate in this step to be lower than in the previous step, because all spurious indexing solutions which do not match the expected results are now being rejected. The overall indexing rate will be reported just as the <italic>indexamajig</italic> program finishes. The indexing rate is more sensitive than a visual analysis; therefore, it might be possible to increase the indexing rate by altering the peak-detection parameters from the values determined earlier or even trying a different peak-detection method (see Section 3.1<xref ref-type="sec" rid="sec3.1"/>). Making the peak detection more stringent may improve the results by avoiding spurious peaks, but making it less stringent may also help by providing more data points to the indexing algorithms. Slightly altering the detector geometry, for example by testing 0.5 or 1 mm either side of the current sample-to-detector distance in the geometry file, may also improve the indexing rate. Therefore, at least a few rounds of indexing should be performed before accepting the result as final.</p>
    </sec>
    <sec id="sec3.4">
      <label>3.4.</label>
      <title>Checking the quality of indexing   </title>
      <p>The internal indexing logic of <italic>CrystFEL</italic> already performs several tests to check that the indexing solution is correct. Despite these checks, it is possible to obtain incorrect indexing solutions, especially if the geometry is not accurate or the peak-search parameters are not set appropriately. Therefore, it is important to check the alignment of peaks visually, just as before when setting up the peak detection. A script called <italic>check-near-bragg</italic> is provided which behaves similarly to <italic>check-peak-detection</italic> (described above) except that it shows the calculated (‘predicted’) reflection locations instead of the peak locations identified by the peak search,<disp-formula id="fdu16"><graphic xlink:href="d-75-00219-efd16.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Alternatively, the <italic>cxiview</italic> program from <italic>Cheetah</italic> can also be used. Some experience is needed to be able to judge whether or not the spot positions are correct. The most important thing is that the patterns of reflections agree; for example, a line or arc of reflections should correspond to a line or arc of true spots, even if there might be an excessive number of reflections predicted either side of the true spots. If there are a large number of patterns where the calculated reflection patterns do not agree with the true spots, the earlier stages should be revisited.</p>
      <p>The prediction-refinement algorithm also refines the position of the central beam on the detector for each frame. The resulting shifts are stored in the stream, and these should also be checked using a scatter plot. This can be performed using a script called <italic>detector-shift</italic> provided with <italic>CrystFEL</italic>:<disp-formula id="fdu17"><graphic xlink:href="d-75-00219-efd17.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>The best outcome is for the shifts to be clustered tightly around the origin of the graph. Successful indexing despite an initially incorrect beam position will show as a cluster of points away from the origin (for an example, see Fig. 4 in White, Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb28"> ▸</xref>). This script can also be used to correct the offset by running it again, this time telling it the name of the geometry file which should be updated:<disp-formula id="fdu18"><graphic xlink:href="d-75-00219-efd18.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>This command will result in <monospace>my-predrefine.geom</monospace> (the filename for the input geometry suffixed with <monospace>-predrefine</monospace>) being created, which should be used for a new run of indexing to improve the overall results.</p>
      <p>The detector-shift tool can only correct offsets of the entire detector in two directions perpendicular to the beam direction (note that the detector panels need not necessarily be in this plane). A more advanced program in <italic>CrystFEL</italic> called <italic>geoptimiser</italic> can be used to refine the detector geometry down to the level of individual panels. The way that <italic>geoptimiser</italic> works has been described in detail in a separate paper (Yefanov <italic>et al.</italic>, 2015<xref ref-type="bibr" rid="bb44"> ▸</xref>). In particular, it allows the panels to be handled in groups which are either treated rigidly or used to calculate adjustments for panels for which there is not sufficient information for an individual refinement (by using the average of the adjustments for the other panels in the group). A few thousand indexed patterns should be used for a good refinement, and a typical command line for <italic>geoptimser</italic> would be as follows:<disp-formula id="fdu19"><graphic xlink:href="d-75-00219-efd19.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Here, the stream <monospace>my.stream</monospace> will be used to refine geometry file <monospace>my.geom</monospace> to produce <monospace>refined.geom</monospace>, treating panels grouped in <monospace>asics</monospace> as strictly rigid with respect to one another and using panels grouped in <monospace>quadrants</monospace> for the adjustment of panels with a low number of measurements. The names <monospace>asics</monospace> and <monospace>quadrants</monospace> are defined in the geometry file. For detectors which can be treated as single panels, which includes most detectors at synchrotron beamlines to a good approximation, it will not be necessary to use these panel-grouping options.</p>
      <p>As before, the indexing step should be repeated with the refined geometry file.</p>
    </sec>
  </sec>
  <sec id="sec4">
    <label>4.</label>
    <title>Resolving an indexing ambiguity   </title>
    <p>Certain symmetry classes are subject to indexing ambiguities. These occur when the crystal can be rotated, usually by 180°, in such a way that the spot positions stay exactly (or very nearly exactly) the same but the structure is not identical to before. The situations in which this can happen, and algorithms to address the problem, have been amply discussed previously (White <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb39"> ▸</xref>; White, Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb28"> ▸</xref>; Brehm &amp; Diederichs, 2014<xref ref-type="bibr" rid="bb6"> ▸</xref>; Donatelli &amp; Sethian, 2014<xref ref-type="bibr" rid="bb10"> ▸</xref>; Liu &amp; Spence, 2014<xref ref-type="bibr" rid="bb26"> ▸</xref>; Zhou <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb46"> ▸</xref>). <italic>CrystFEL</italic> includes a simplified version of the Brehm–Diederichs algorithm, the details of which have been given previously (White, Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb28"> ▸</xref>), in the program <italic>ambigator</italic>.</p>
    <p>If the space group of the structure under investigation is known in advance, it is easy to know whether an ambiguity is possible or not. A table of symmetry classes (point groups and space groups) is included with <italic>CrystFEL</italic> which highlights the relevant groups. The mathematical basis of an indexing ambiguity, and the manifestation of an indexing ambiguity in the data from an SX experiment, is exactly the same as that of perfect twinning by merohedry (or pseudomerohedry, in the case of approximate overlap of spot positions). Therefore, an indexing ambiguity should be suspected if a ‘twin warning’ is given by the structure-solution software after completing the merging steps described in the next section.</p>
    <p>At a minimum, <italic>ambigator</italic> needs the stream file from the previous step (which was called <monospace>my.stream</monospace>), the name which should be used for the resulting ‘detwinned’ stream (specified with <monospace>-o</monospace>), the true point symmetry of the structure (specified with <monospace>-y</monospace>) and either the symmetry operator corresponding to the ambiguity (specified with <monospace>--operator</monospace>) or the apparent point symmetry when the ambiguity is in effect (specified with <monospace>-w</monospace>):<disp-formula id="fdu20"><graphic xlink:href="d-75-00219-efd20.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>or<disp-formula id="fdu21"><graphic xlink:href="d-75-00219-efd21.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>respectively. Typical use will add the further options <monospace>--fg-graph</monospace>, <monospace>--lowres</monospace>, <monospace>--highres</monospace> and <monospace>-j</monospace>, which are described below:<disp-formula id="fdu22"><graphic xlink:href="d-75-00219-efd22.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The <monospace>-j</monospace> option tells <italic>ambigator</italic> to perform calculations in parallel across multiple CPUs, as described earlier for <italic>indexamajig</italic>. The <monospace>--fg-graph</monospace> option tells <italic>ambigator</italic> to write some diagnostic information to a file called <monospace>fg.dat</monospace>, which will be described later in this section. The notation used to specify point-group symbols is described in detail in Section 5.2<xref ref-type="sec" rid="sec5.2"/>.</p>
    <p>The lower and upper resolution limits, given in ångströms using <monospace>--lowres</monospace> and <monospace>--highres</monospace>, respectively, restrict the range of resolutions used by <italic>ambigator</italic> to calculate correlation coefficients. If the range is too wide, the correlations between data sets can be high even if they are totally un­related, simply because low-resolution reflections are usually strong and high-resolution reflections are usually weak. If the range is too narrow, there will not be enough reflections for an accurate calculation. The best resolution range depends on the data, so it needs to be adjusted based on the results.</p>
    <p>An example log output from <italic>ambigator</italic> is shown below:<disp-formula id="fdu23"><graphic xlink:href="d-75-00219-efd23.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Firstly, the re-indexing operation, calculated from the true and apparent point-group symmetries, is shown.<xref ref-type="fn" rid="fn1">1</xref> The most important numbers are the values of the mean correlation coefficients across all crystals in the correct and reversed orientations, called <italic>f</italic> and <italic>g</italic>, respectively. The two values will be similar on the first iteration (here, they are 0.018576 and 0.017307, respectively). If the resolution of the ambiguity is successful, the value of <italic>f</italic> should approximately double while the value of <italic>g</italic> should decrease approximately to zero. Here, the final values are 0.032755 and 0.003128, respectively, indicating a good result. If the final value of <italic>g</italic> is significantly above zero, the resolution range may be too large. If the final value of <italic>f</italic> is not much larger than its starting value, a larger resolution range may be necessary, or the earlier data-processing steps should be revisited.</p>
    <p><italic>Ambigator</italic> will create a new stream (<monospace>detwinned.stream</monospace> in the example above) identical to the input stream except that the reflections have been re-indexed and the basis vectors of the reciprocal unit cell have been altered to match. If the ambiguity resolution was successful, this can be merged normally, as described in the next section.</p>
    <p>The file <monospace>fg.dat</monospace> contains a list of the average correlation coefficients against all other crystals for each crystal, looping round to the first crystal again at the start of the next iteration. This can be used to plot graphs as shown in White, Mariani <italic>et al.</italic> (2016<xref ref-type="bibr" rid="bb41"> ▸</xref>). For this purpose, a script called <italic>fg-graph</italic> is provided. The script must first be edited to set the filename (usually <monospace>fg.dat</monospace>), the number of crystals, the number of iterations (default six) and the minimum and maximum correlation coefficients for the graph axes. Then, it can be run very simply,<disp-formula id="fdu24"><graphic xlink:href="d-75-00219-efd24.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>This will produced an image file <monospace>correlation.png</monospace> which can be viewed with any image viewer.</p>
    <p><italic>ambigator</italic> attempts to calculate the correlation of the reflection intensities of every crystal with all of the others. In practice, about 1000 correlation coefficients are normally sufficient, depending on the quality and the resolution of the data. If the number of crystals is large, as is the case in the example above, with an average of 3722.4 correlations per crystal, <italic>ambigator</italic> can be told to limit itself to a maximum number of correlation coefficients using the <monospace>--ncorr</monospace> option. This will make it finish sooner, usually without affecting the results.</p>
  </sec>
  <sec id="sec5">
    <label>5.</label>
    <title>Merging the measurements   </title>
    <sec id="sec5.1">
      <label>5.1.</label>
      <title>Checking for detector saturation   </title>
      <p>Before merging, it is wise to check for reflections that were too strong to be recorded by the detector. The dynamic range of several current detectors used at XFEL facilities can be as small as a few thousand photons at 8 keV (Carini <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb8"> ▸</xref>), so there are likely to be many overloaded reflections. They can be removed while merging, but the highest reliable pixel value must be known. Unfortunately, the maximum recordable value can vary as the calibration constants for the detector change over a period of days. This is a particular problem for detectors at XFEL facilities.</p>
      <p>The <italic>peakogram-stream</italic> script is provided to help to find the saturation value. It simply plots a point for every reflection in a stream, with the horizontal position being the resolution and the vertical position being the maximum intensity of all pixels in the integration region for that reflection. The plot is colour-coded according to the local density of spots. It is simply run on the stream:<disp-formula id="fdu25"><graphic xlink:href="d-75-00219-efd25.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>An example graph is shown in Fig. 7<xref ref-type="fig" rid="fig7"> ▸</xref> for a previously published data set from the human serotonin receptor 2B in complex with ergotamine (Liu <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb27"> ▸</xref>), for which the data frames have been made available (White, Barty <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb38"> ▸</xref>). The maximum values for some reflections, particularly at low resolution, have been clipped to lower values. Normally, this would manifest itself as a sharp horizontal line in the graph. However, the image data have been processed to subtract a background value (see Section 2<xref ref-type="sec" rid="sec2"/>). The background value varies between pixels, but the maximum raw value which can be measured does not. The effective maximum value, which is the maximum raw value minus the background value, therefore also varies between pixels, turning the sharp line into a cloud of points. The maximum reliable value, which is required for the merging step, is simply the highest value before the start of this cloud. In this example, a value of 7000 adu would be appropriate. Note that there are a few outlying values with even higher values of around 14 000 adu in the middle resolution ranges. These come from temporary glitches of the detector and will also be excluded by the cutoff of 7000 adu.</p>
      <p>The CSPAD detector (Philipp <italic>et al.</italic>, 2010<xref ref-type="bibr" rid="bb31"> ▸</xref>) allows pixels to be individually switched between two gain modes, so pixels in one gain mode must have their values multiplied by a certain factor to be consistent with the others. The saturation value is the same in either gain mode, but after performing this multiplication the pixels in high-gain mode would have a much lower saturation value than those in the low-gain mode, for which the pixel values, and therefore the saturation values, have been multiplied up. There are theoretically two possible solutions to this problem. The first is for <italic>CrystFEL</italic> to perform the multiplication, in which case the saturation value would be the same everywhere on the detector, but a gain map would need to be provided to <italic>CrystFEL</italic>. The second option is for the multiplication to be performed by the hit-finding software (see Section 2<xref ref-type="sec" rid="sec2"/>), in which case <italic>CrystFEL</italic> need not alter the intensity values, but the saturation value will now be different for pixels in one gain mode compared with the other. As a matter of design philosophy, <italic>CrystFEL</italic> adopts the second strategy. To handle the variation in saturation values, a separate HDF5 file can be provided, which matches the layout of the image data and contains the saturation value for each pixel. To assist with creating this map, a script called <italic>gaincal-to-saturation-map</italic> has been provided, but its detailed usage is beyond the scope of this article.</p>
    </sec>
    <sec id="sec5.2">
      <label>5.2.</label>
      <title>Simple merging using the Monte Carlo method   </title>
      <p>The simplest way to merge the intensities is to calculate a average intensity, across the entire data set, for each symmetrically unique reflection. This can be performed using <italic>process_hkl</italic>. For example, to merge <monospace>my.stream</monospace> to create <monospace>merged.hkl</monospace> using a saturation value of 7000 (see above), merging in point group 4/<italic>mmm</italic>:<disp-formula id="fdu26"><graphic xlink:href="d-75-00219-efd26.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>The fact that point group 4/<italic>mmm</italic> is centrosymmetric indicates to <italic>process_hkl</italic> that Friedel pairs are to be merged. To preserve Bijvoet differences in the merged data set, the appropriate symmetry option would be <monospace>-y 422</monospace>. The resulting reflection list will contain reflections within the asymmetric unit of reciprocal space for the point group given here. Although perhaps unfamiliar to some users, this way of specifying symmetry is simpler because there are very few point groups compared with space groups. It also avoids any suggestion that the space group is known (or that it needs to be known, or even that guessing it would affect the data processing in any way) at this early stage in the data processing. When specifying the point group for merging, overlines in the point-group symbols are represented by a minus sign, for example point group <inline-formula><inline-graphic xlink:href="d-75-00219-efi1.jpg" mimetype="image" mime-subtype="gif"/></inline-formula> is selected using <monospace>-y -42m</monospace>. For trigonal point groups, the type of axes, rhombohedral or hexagonal, must be specified by suffixing with <monospace>_R</monospace> or <monospace>_H</monospace>, respectively. Unconventional point-group settings can be used, for example point group 6 with the hexagonal axis along <italic>a</italic> can be selected using <monospace>-y 6_uaa</monospace>, where the suffix <monospace>_uaa</monospace> indicates ‘unique axis <italic>a</italic>’. It should be noted that <italic>CrystFEL</italic> assumes that the unique axis is <italic>c</italic> for all lattice types which have a distinct axis (monoclinic, tetragonal and hexagonal), whereas many other pieces of software prefer the ‘unique axis <italic>b</italic>’ representation for monoclinic structures. To help to avoid confusion, the <italic>CrystFEL</italic> programs will display a warning if a monoclinic point group is used without specifying a unique axis.</p>
    </sec>
    <sec id="sec5.3">
      <label>5.3.</label>
      <title>Advanced merging using scaling and partiality correction   </title>
      <p>In addition to <italic>process_hkl</italic>, the simple merging tool described in the last section, <italic>CrystFEL</italic> includes the more advanced merging program <italic>partialator</italic>. This program can perform more advanced merging methods involving scaling the intensities and correcting for their partialities.</p>
      <p>Scaling means to determine scaling factors (linear and Debye–Waller terms) for each crystal which, when the intensities are multiplied by them, bring the individual measurements into as close an agreement as possible. Partiality modelling means accounting for differences in the relative amounts of excitation of the reflections in each diffraction pattern, usually using a geometrical model of the diffraction process (White <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb39"> ▸</xref>; Ginn, Messerschmidt <italic>et al.</italic>, 2015<xref ref-type="bibr" rid="bb15"> ▸</xref>). Post-refinement means refining the parameters of the model for each crystal such that when the intensities are corrected for their partialities, the measurements agree as closely as possible (Winker <italic>et al.</italic>, 1979<xref ref-type="bibr" rid="bb42"> ▸</xref>; Rossmann <italic>et al.</italic>, 1979<xref ref-type="bibr" rid="bb33"> ▸</xref>).</p>
      <p>This type of procedure comes at the cost of having to hold the reflection intensities from the entire stream in memory, so that the program can compare them with the intermediate merged results as it iteratively improves the parameters affecting the correction factors. For large unit-cell structures with high-resolution data, this can require large amounts of memory. For 1000 crystals of tetragonal lysozyme (<italic>a</italic> = <italic>b</italic> = 79.2, <italic>c</italic> = 37.9 Å) at a resolution of 3 Å (at the detector edge, not the corner), about half a gigabyte of memory is required. The memory requirements scale linearly with the number of reflections, proportional to each of the unit-cell dimensions and the cube of the maximum resolution (measured as reciprocal distance). Even when modelling partialities and performing post-refinement, <italic>partialator</italic> does not need access to the original image data, only the contents of the stream file. This is the origin of the name ‘post-refinement’: it takes place after all of the other processing is complete (Kabsch, 2010<xref ref-type="bibr" rid="bb21"> ▸</xref>).</p>
      <p>The operation of <italic>partialator</italic> has been described elsewhere (White, 2014<xref ref-type="bibr" rid="bb37"> ▸</xref>; White, Mariani <italic>et al.</italic>, 2016<xref ref-type="bibr" rid="bb41"> ▸</xref>). It offers a choice of partiality models, including ‘unity’, which means setting all partialities to 1: in other words, not to model partialities at all and just perform the scaling. Scaling in <italic>partialator</italic> by default determines a linear and Debye–Waller scaling parameter for each crystal to optimize the agreement between it and an intermediate merged data set. The updated parameters are then used to produce the next intermediate merged data set.</p>
      <p>The command-line syntax is similar to <italic>process_hkl</italic>:<disp-formula id="fdu27"><graphic xlink:href="d-75-00219-efd27.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The only changes are the name of the program (<italic>process_hkl</italic> changed to <italic>partialator</italic>) and the addition of <monospace>--model=unity</monospace> to specify no partiality modelling and <monospace>--iterations=1</monospace> to specify only one iteration of scaling. The number of iterations refers to the number of ‘macrocycles’ of scaling, post-refinement and outlier rejection. The scaling algorithm itself performs its own iteration cycle within the macrocycles, and therefore only one iteration is sufficient if the ‘unity’ model is used. A higher number of iterations is likely to lead to divergence. If partiality modelling and post-refinement are used, about three iterations should be used.</p>
      <p>Although versions of <italic>CrystFEL</italic> going back several years have incorporated partiality models, it is only recently that models have become available that reliably improve experimental data. <italic>CrystFEL</italic> v.0.7.0 includes an implementation of partiality modelling and post-refinement that closely follows that of Ginn, Brewster <italic>et al.</italic> (2015<xref ref-type="bibr" rid="bb14"> ▸</xref>). This can be used simply by specifying <monospace>--model=xsphere</monospace>, as follows:<disp-formula id="fdu28"><graphic xlink:href="d-75-00219-efd28.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Partiality modelling and post-refinement introduces a lot of complexity into the merging process, and a full guide to the process and discussion of its behaviour would be both beyond the scope of this article and impossible to give at this stage, since the implementation in <italic>CrystFEL</italic> is still considered to be experimental and only works in favourable cases. More detailed discussion will therefore be left for future articles.</p>
      <p>The overall flow for merging data, including resolving an indexing ambiguity, is shown in Fig. 3<xref ref-type="fig" rid="fig3"> ▸</xref>.</p>
    </sec>
    <sec id="sec5.4">
      <label>5.4.</label>
      <title>Calculating figures of merit   </title>
      <p>The workflow for calculating figures of merit in <italic>CrystFEL</italic> is shown in Fig. 4<xref ref-type="fig" rid="fig4"> ▸</xref>. There are two programs for calculating figures of merit: <italic>check_hkl</italic> and <italic>compare_hkl</italic>. The former calculates figures of merit relating to just one reflection list, such as completeness and mean <italic>I</italic>/σ(<italic>I</italic>). The latter calculates figures of merit which involve splitting the data set into two halves which are merged separately and then compared, such as <italic>R</italic>
<sub>split</sub> and CC<sub>1/2</sub>.</p>
      <p><italic>check_hkl</italic> is run as follows:<disp-formula id="fdu29"><graphic xlink:href="d-75-00219-efd29.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>where the <monospace>--lowres</monospace> and <monospace>--highres</monospace> options can be used to restrict the resolution range which should be considered, since normally the usable data do not extend to the corner of the detector. The program will display several statistics on the terminal, and also create a file <monospace>shells.dat</monospace> containing the same statistics divided into resolution bins. The filename of this file can be changed if required, by adding <monospace>--shell-file=filename</monospace>, where <monospace>filename</monospace> is the desired filename.</p>
      <p><italic>compare_hkl</italic> is run similarly, except that it takes two reflection lists and has an additional option to specify which figure of merit should be calculated:<disp-formula id="fdu30"><graphic xlink:href="d-75-00219-efd30.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Possible figures of merit include <italic>R</italic>
<sub>split</sub>, CC, CC* and <italic>R</italic>
<sub>ano</sub>; a full list can be found in the manual page (<monospace>man compare_hkl</monospace>). It also writes <monospace>shells.dat</monospace>, and the filename can be altered as with <italic>check_hkl</italic>. In the example above, the correlation coefficient is being calculated between two half data sets; therefore the resulting values are CC<sub>1/2</sub>. This, or the closely related CC* (Karplus &amp; Diederichs, 2012<xref ref-type="bibr" rid="bb23"> ▸</xref>), are the preferred figures of merit (over <italic>R</italic>
<sub>split</sub>) for estimating the resolution limit of useful data (Karplus &amp; Diederichs, 2015<xref ref-type="bibr" rid="bb24"> ▸</xref>).</p>
      <p>The two merged half data sets, here called <monospace>merged.hkl1</monospace> and <monospace>merged.hkl2</monospace>, will automatically be created by <italic>partialator</italic>. To create them using <italic>process_hkl</italic> is more difficult, and requires that the program be run two more times in addition to the main merge, once using the even-numbered images and once using the odd-numbered images,<disp-formula id="fdu31"><graphic xlink:href="d-75-00219-efd31.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>The designations ‘odd’ and ‘even’ refer to the order that the crystals appear in the stream, which is effectively random owing to the variable amount of time taken to process each frame in parallel by <italic>indexamajig</italic>.</p>
      <p>The symmetry used for merging is written into the merged reflection files, and therefore does not need to be given to <italic>check_hkl</italic> and <italic>compare_hkl</italic> as was the case in earlier versions of <italic>CrystFEL</italic>.</p>
    </sec>
    <sec id="sec5.5">
      <label>5.5.</label>
      <title>Exporting to structure-solution packages   </title>
      <p>The merged reflection files in <italic>CrystFEL</italic> are plain text and can easily be imported into most structure-solution packages. Nevertheless, template scripts are provided to help. The scripts are <italic>create-mtz</italic> and <italic>create-xscale</italic> to create MTZ files and <italic>XSCALE</italic> files, respectively. The workflow for using <italic>create-mtz</italic> is shown in Fig. 5<xref ref-type="fig" rid="fig5"> ▸</xref>. <italic>create-mtz</italic> is a thin wrapper around the <italic>CCP</italic>4 import program <italic>F</italic>2<italic>MTZ</italic>, and <italic>create-xscale</italic> is a simple Perl script because <italic>XSCALE</italic> files are also plain text. Both scripts must be carefully edited before use to set the unit-cell parameters, data-set name and other values which will be written into the headers of the resulting file.</p>
    </sec>
  </sec>
  <sec id="sec6">
    <label>6.</label>
    <title>Additional features   </title>
    <p>At this stage, the processing of the data is essentially complete. However, there are many other features in <italic>CrystFEL</italic> which become useful for certain usage cases. The next few sections contain brief introductions to some of the most important ones.</p>
    <sec id="sec6.1">
      <label>6.1.</label>
      <title>Custom data-set splitting   </title>
      <p>Several types of experiment, such as time-resolved experiments or multi-data-set anomalous phasing experiments (SIR or MAD), involve multiple data sets which have small differences between them. For these types of experiment, it is important to ensure that all data sets are processed identically. To support this, <italic>partialator</italic> offers the possibility of merging all of the data together in one combined task and then separating the data sets just before creating the final merged output. In this way, the separate data sets are certain to be on the same scale, and concerns about the uniqueness of the solution when using post-refinement are greatly reduced.</p>
      <p>To use this feature, a separate file must be provided to <italic>partialator</italic> using the option <monospace>--custom-split=filename</monospace>. The file consists of one line per frame, each line consisting of the filename, frame identifier if applicable (see Section 2<xref ref-type="sec" rid="sec2"/>) and an arbitrary data-set identifier. The identifier can be any text string, for example ‘native’, ‘derivative’, ‘dark’, ‘light_1ns’ and so on. For each unique data-set identifier, three extra files will be written. In the example above, where the main merged output was <monospace>merged.hkl</monospace>, for a data-set identifier ‘native’ the extra files would be called <monospace>merged-native.hkl</monospace>, <monospace>merged-native.hkl1</monospace> and <monospace>merged-native.hkl2</monospace>. These files contain the merged data for the data set (<monospace>.hkl</monospace>) and two half-data-set merges (<monospace>.hkl1</monospace> and <monospace>.hkl2</monospace>) which can be used to calculate figures of merit for that data set alone.</p>
    </sec>
    <sec id="sec6.2">
      <label>6.2.</label>
      <title>Searching for ‘mini rotation series’   </title>
      <p>Whereas an XFEL pulse will usually destroy the crystal, in synchrotron serial crystallography experiments there is a chance that the same crystal might appear in two or more successive frames. This knowledge can be useful, for example to treat the accidental successive exposures as a rotation series and process them with rotation-processing software, leading to a hybrid approach similar to that described by Gati <italic>et al.</italic> (2014<xref ref-type="bibr" rid="bb13"> ▸</xref>). The information could also be used to avoid subsequent exposures in case they have suffered unacceptable levels of radiation damage. To this end, the <italic>whirligig</italic> program in <italic>CrystFEL</italic> can scan through a stream file and compare the orientations of crystals in subsequent frames. The program takes into account that there might be multiple crystals per frame, that the frames might not appear in the stream in the same order that they were mentioned in the input list (see Section 2<xref ref-type="sec" rid="sec2"/>) and also that the indexing of the series of crystals may not be consistent. It is very easy to run:<disp-formula id="fdu32"><graphic xlink:href="d-75-00219-efd32.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>
</p>
      <p>The only parameter that may need to be adjusted is the ‘window size’, which determines how widely separated two successive frames can be in the stream before the program abandons hope that they will appear. The program will report if this is necessary.</p>
      <p>For each series of crystals, a short text file will be written which contains the filenames, event descriptors and crystal numbers which make up the series. The example output below could arise from a series of three patterns, their filenames being <monospace>frame_00897.cbf</monospace>, <monospace>frame_00898.cbf</monospace> and <monospace>frame_00899.cbf</monospace>:<disp-formula id="fdu33"><graphic xlink:href="d-75-00219-efd33.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>Here, the last frame in fact contains two crystals, the second of which was apparently close in orientation to the previous crystal. The crystal indices start from zero, and the text ‘(none)’ would have been replaced by an event descriptor if the input files contained more than one frame each.</p>
    </sec>
    <sec id="sec6.3">
      <label>6.3.</label>
      <title>Running <italic>CrystFEL</italic> on a cluster system   </title>
      <p>Many of the <italic>CrystFEL</italic> programs support the use of the option <monospace>-j</monospace> to instruct them to perform multiple parts of their work in parallel. However, this parallelism only uses multiple CPUs within one computer. This is usually sufficient, except for the indexing and integration step. This is usually the most time-consuming part of processing an SX data set, firstly because of the amount of work involved (potentially including several attempts at indexing each pattern) and secondly because it involves reading the image data for every frame, creating a large input/output load. This step can be made much faster by parallelizing not only within one computer, but across many computers in a cluster, as are available at most X-ray light-source facilities.</p>
      <p>Splitting the indexing and integration task up across computers can be performed by creating many small <italic>indexamajig</italic> subtasks with separate input file lists (see Section 2<xref ref-type="sec" rid="sec2"/>), each containing about 1000 frames from the full data set. The tasks are submitted to a batch-queuing system which takes care of scheduling and running them on the cluster. Each subtask produces its own stream, and the streams can be combined by simple concatenation. For example, if the substreams have names <monospace>block00.stream</monospace>, <monospace>block01.stream</monospace>, <monospace>block02.stream</monospace> and so on, this could be performed with<disp-formula id="fd35"><graphic xlink:href="d-75-00219-efd34.jpg" mimetype="image" mime-subtype="gif" position="float" orientation="portrait"/></disp-formula>There is no conceptual difference between the substreams, the combined stream and the stream obtained by a single large run of <italic>indexamajig</italic>. The combined stream can be used exactly as described above for merging the data, or the substreams can be used to examine the indexing results for a subset of the complete data.</p>
      <p>As is perhaps already apparent, speeding up the processing in this way comes at the cost of convenience. To assist, two scripts are provided with <italic>CrystFEL</italic>, which should be considered as templates and customised to the exact task. The two scripts are called <italic>turbo-index-slurm</italic> and <italic>turbo-index-lsf</italic>, and are for systems using the SLURM (<ext-link ext-link-type="uri" xlink:href="https://slurm.schedmd.com/">https://slurm.schedmd.com/</ext-link>) and Platform LSF batch-queue systems, respectively. A full tutorial of how to modify and run these scripts is beyond the scope of this article, but they must be modified to set parameters including the number of frames per subtask, the <italic>indexamajig</italic> command-line parameters and any environment setup needed to run <italic>CrystFEL</italic> on the worker nodes, as well any parameters needed by the batch system such as an e-mail address for notifications, job priority and expected running time.</p>
    </sec>
  </sec>
  <sec id="sec7">
    <label>7.</label>
    <title>Conclusion   </title>
    <p>This step-by-step guide has covered the main processing pipeline for serial crystallography data using <italic>CrystFEL</italic>. Most, but not all, of the core programs in <italic>CrystFEL</italic> have been described. Those not covered are those for simulating diffraction data, which can be used for testing new types of analysis or determining expected signal levels for experiments. The programs for simulation are <italic>pattern_sim</italic> and <italic>partial_sim</italic>, which have both been described previously (White <italic>et al.</italic>, 2013<xref ref-type="bibr" rid="bb39"> ▸</xref>). There is also <italic>render_hkl</italic>, which can plot plane sections through reciprocal space, showing the intensities of reflections using a colour scale. The remaining program is <italic>get_hkl</italic>, which can be used for manipulating reflection lists, for example symmetry expansion, adding noise, applying a resolution cutoff or re-indexing a reflection list. These functions are also most commonly used when simulating data.</p>
    <p>The library of scripts provided with <italic>CrystFEL</italic> is much larger than those described here. A list is given below, with brief descriptions of the most important of the scripts which have not so far been mentioned. Although some of these refer to features which have not been described above, they are mentioned here to make the reader aware of their existence.<list list-type="simple" id="l1"><list-item><p><italic>ave-resolution</italic>: plot a histogram of the estimated resolution of the crystals in a stream and show the average and maximum values.</p></list-item><list-item><p><italic>eiger-badmap</italic>: create a bad pixel mask for a Dectris EIGER detector by finding very bright pixels in a single data file.</p></list-item><list-item><p><italic>move-entire-detector</italic>: apply an overall shift to all panels in a detector geometry file at once.</p></list-item><list-item><p><italic>mtz</italic>2<italic>hkl</italic>: create a <italic>CrystFEL</italic> reflection file from an MTZ file; the opposite of <italic>create-mtz</italic> described above.</p></list-item><list-item><p><italic>stream_grep</italic>: search a stream for chunks which match certain criteria and write a new, filtered stream.</p></list-item><list-item><p><italic>sum-peaks</italic>: create an image (in HDF5 format) where a single pixel is plotted for each of the peaks in a stream. This image can then be used to adjust the detector geometry.</p></list-item><list-item><p><italic>truncate-stream</italic>: extract a subset of chunks or crystals from a stream with a specified start point and length.</p></list-item></list>Also not mentioned is the <italic>CrystFEL</italic> shared library, called libcrystfel, which can be used to write separate programs in C or C++ which make use of the <italic>CrystFEL</italic> data structures. libcrystfel is not intended as a replacement for more complete crystallography libraries such as <italic>cctbx</italic> (Grosse-Kunstleve <italic>et al.</italic>, 2002<xref ref-type="bibr" rid="bb18"> ▸</xref>) or the CCP4 libraries (Winn <italic>et al.</italic>, 2011<xref ref-type="bibr" rid="bb43"> ▸</xref>), but rather as a way of supporting access to high-level functions such as the indexing system, for example when interfacing with online data-analysis frameworks at light-source facilities.</p>
    <p>As with all software, things change quickly as new features are added. The <italic>CrystFEL</italic> website features a tutorial which is kept up to date with the latest changes. The website also features a list of changes between versions, which can be consulted to quickly see where differences should be expected. Finally, ‘release notes’ are published for each new version, which contains details of the larger changes and new features.</p>
    <p><italic>Note added in proof</italic>: A new version of <italic>CrystFEL</italic> (0.8.0) was released shortly before this article went to press. See the <italic>CrystFEL</italic> website (<ext-link ext-link-type="uri" xlink:href="https://www.desy.de/~twhite/crystfel">https://www.desy.de/~twhite/crystfel</ext-link>) for more details.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data">
      <p>Worked example for human serotonin receptor 2B data.. DOI: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1107/S205979831801238X/ba5291sup1.pdf">10.1107/S205979831801238X/ba5291sup1.pdf</ext-link>
</p>
      <media mimetype="application" mime-subtype="pdf" xlink:href="d-75-00219-sup1.pdf" orientation="portrait" id="d35e103" position="anchor"/>
    </supplementary-material>
    <supplementary-material content-type="local-data">
      <p>Geometry file for human seotonin receptor 2B data, updated for CrystFEL v.0.7.0.. DOI: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1107/S205979831801238X/ba5291sup2.txt">10.1107/S205979831801238X/ba5291sup2.txt</ext-link>
</p>
      <media mimetype="text" mime-subtype="plain" xlink:href="d-75-00219-sup2.txt" orientation="portrait" id="d35e110" position="anchor"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <fn-group>
    <fn id="fn1">
      <label>1</label>
      <p>As a convenience, the ‘twin law’ relating any two point groups can be calculated by invoking <italic>ambigator</italic> with only the apparent and true symmetries; for example, <monospace> ambigator -y m-3 -w m-3m</monospace>.</p>
    </fn>
  </fn-group>
  <ack>
    <p>I thank Nadia Zatsepin, Anton Barty and Jose Luis Olmos Jr for valuable feedback on the manuscript.</p>
  </ack>
  <ref-list>
    <title>References</title>
    <ref id="bb1">
      <mixed-citation publication-type="other">Allahgoli, A., Becker, J., Bianco, L., Delfs, A., Dinapoli, R., Goettlicher, P., Graafsma, H., Greiffenberg, D., Hirsemann, H., Jack, S., Klanner, R., Klyuev, A., Krueger, H., Lange, S., Marras, A., Mezza, D., Mozzanica, A., Rah, S., Xia, Q., Schmitt, B., Schwandt, J., Sheviakov, I., Shi, X., Smoljanin, S., Trunk, U., Zhang, J. &amp; Zimmer, M. (2015). <italic>J. Instrum.</italic>
<bold>10</bold>, C01023.</mixed-citation>
    </ref>
    <ref id="bb2">
      <mixed-citation publication-type="other">Barty, A., Kirian, R. A., Maia, F. R. N. C., Hantke, M., Yoon, C. H., White, T. A. &amp; Chapman, H. (2014). <italic>J. Appl. Cryst.</italic>
<bold>47</bold>, 1118–1131.</mixed-citation>
    </ref>
    <ref id="bb3">
      <mixed-citation publication-type="other">Bernstein, H. J., Sloan, J. M., Winter, G., Richter, T. S., NeXus International Advisory Committee &amp; Committee on the Maintenance of the CIF Standard (2014). <italic>Comput. Crystallogr. Newsl.</italic>
<bold>5</bold>, 12–18.</mixed-citation>
    </ref>
    <ref id="bb4">
      <mixed-citation publication-type="other">Beyerlein, K. R., White, T. A., Yefanov, O., Gati, C., Kazantsev, I. G., Nielsen, N. F.-G., Larsen, P. M., Chapman, H. N. &amp; Schmidt, S. (2017). <italic>J. Appl. Cryst.</italic>
<bold>50</bold>, 1075–1083.</mixed-citation>
    </ref>
    <ref id="bb5">
      <mixed-citation publication-type="other">Bonifacio, R., De Salvo, L., Pierini, P., Piovella, N. &amp; Pellegrini, C. (1994). <italic>Nucl. Instrum. Methods Phys. Res. A</italic>, <bold>341</bold>, 181–185.</mixed-citation>
    </ref>
    <ref id="bb6">
      <mixed-citation publication-type="other">Brehm, W. &amp; Diederichs, K. (2014). <italic>Acta Cryst.</italic> D<bold>70</bold>, 101–109.</mixed-citation>
    </ref>
    <ref id="bb7">
      <mixed-citation publication-type="other">Brewster, A. S., Hattne, J., Parkhurst, J. M., Waterman, D. G., Bernstein, H. J., Winter, G. &amp; Sauter, N. K. (2014). <italic>Comput. Crystallogr. Newsl.</italic>
<bold>5</bold>, 19–24.</mixed-citation>
    </ref>
    <ref id="bb8">
      <mixed-citation publication-type="other">Carini, G. A., Boutet, S., Chollet, M., Dragone, A., Haller, G., Hart, P. A., Herrmann, S. C., Kenney, C. J., Koglin, J., Lemke, H. T., Messerschmidt, M., Nelson, S., Pines, J., Robert, A., Song, S., Thayer, J. B., Williams, G. J. &amp; Zhu, D. (2013). <italic>2013 IEEE Nuclear Science Symposium and Medical Imaging Conference</italic>. Piscataway: IEEE. https://doi.org/10.1109/NSSMIC.2013.6829694.</mixed-citation>
    </ref>
    <ref id="bb9">
      <mixed-citation publication-type="other">Chapman, H. N., Fromme, P., Barty, A., White, T. A., Kirian, R. A., Aquila, A., Hunter, M. S., Schulz, J., DePonte, D. P., Weierstall, U., Doak, R. B., Maia, F. R. N. C., Martin, A. V., Schlichting, I., Lomb, L., Coppola, N., Shoeman, R. L., Epp, S. W., Hartmann, R., Rolles, D., Rudenko, A., Foucar, L., Kimmel, N., Weidenspointner, G., Holl, P., Liang, M., Barthelmess, M., Caleman, C., Boutet, S., Bogan, M. J., Krzywinski, J., Bostedt, C., Bajt, S., Gumprecht, L., Rudek, B., Erk, B., Schmidt, C., Hömke, A., Reich, C., Pietschner, D., Strüder, L., Hauser, G., Gorke, H., Ullrich, J., Herrmann, S., Schaller, G., Schopper, F., Soltau, H., Kühnel, K.-U., Messer­schmidt, M., Bozek, J. D., Hau-Riege, S. P., Frank, M., Hampton, C. Y., Sierra, R. G., Starodub, D., Williams, G. J., Hajdu, J., Timneanu, N., Seibert, M. M., Andreasson, J., Rocker, A., Jönsson, O., Svenda, M., Stern, S., Nass, K., Andritschke, R., Schröter, C.-D., Krasniqi, F., Bott, M., Schmidt, K. E., Wang, X., Grotjohann, I., Holton, J. M., Barends, T. R. M., Neutze, R., Marchesini, S., Fromme, R., Schorb, S., Rupp, D., Adolph, M., Gorkhover, T., Andersson, I., Hirsemann, H., Potdevin, G., Graafsma, H., Nilsson, B. &amp; Spence, J. C. H. (2011). <italic>Nature (London)</italic>, <bold>470</bold>, 73–77.</mixed-citation>
    </ref>
    <ref id="bb10">
      <mixed-citation publication-type="other">Donatelli, J. &amp; Sethian, J. A. (2014). <italic>Proc. Natl. Acad. Sci. USA</italic>, <bold>111</bold>, 593–598.</mixed-citation>
    </ref>
    <ref id="bb11">
      <mixed-citation publication-type="other">Duisenberg, A. J. M. (1992). <italic>J. Appl. Cryst.</italic>
<bold>25</bold>, 92–96.</mixed-citation>
    </ref>
    <ref id="bb12">
      <mixed-citation publication-type="other">Foucar, L. (2016). <italic>J. Appl. Cryst.</italic>
<bold>49</bold>, 1336–1346.</mixed-citation>
    </ref>
    <ref id="bb13">
      <mixed-citation publication-type="other">Gati, C., Bourenkov, G., Klinge, M., Rehders, D., Stellato, F., Oberthür, D., Yefanov, O., Sommer, B. P., Mogk, S., Duszenko, M., Betzel, C., Schneider, T. R., Chapman, H. N. &amp; Redecke, L. (2014). <italic>IUCrJ</italic>, <bold>1</bold>, 87–94.</mixed-citation>
    </ref>
    <ref id="bb14">
      <mixed-citation publication-type="other">Ginn, H. M., Brewster, A. S., Hattne, J., Evans, G., Wagner, A., Grimes, J. M., Sauter, N. K., Sutton, G. &amp; Stuart, D. I. (2015). <italic>Acta Cryst.</italic> D<bold>71</bold>, 1400–1410.</mixed-citation>
    </ref>
    <ref id="bb15">
      <mixed-citation publication-type="other">Ginn, H. M., Messerschmidt, M., Ji, X., Zhang, H., Axford, D., Gildea, R. J., Winter, G., Brewster, A. S., Hattne, J., Wagner, A., Grimes, J. M., Evans, G., Sauter, N. K., Sutton, G. &amp; Stuart, D. I. (2015). <italic>Nature Commun.</italic>
<bold>6</bold>, 6435.</mixed-citation>
    </ref>
    <ref id="bb16">
      <mixed-citation publication-type="other">Ginn, H. M., Roedig, P., Kuo, A., Evans, G., Sauter, N. K., Ernst, O. P., Meents, A., Mueller-Werkmeister, H., Miller, R. J. D. &amp; Stuart, D. I. (2016). <italic>Acta Cryst.</italic> D<bold>72</bold>, 956–965.</mixed-citation>
    </ref>
    <ref id="bb17">
      <mixed-citation publication-type="other">Ginn, H. M. &amp; Stuart, D. I. (2017). <italic>J. Synchrotron Rad.</italic>
<bold>24</bold>, 1152–1162.</mixed-citation>
    </ref>
    <ref id="bb18">
      <mixed-citation publication-type="other">Grosse-Kunstleve, R. W., Sauter, N. K., Moriarty, N. W. &amp; Adams, P. D. (2002). <italic>J. Appl. Cryst.</italic>
<bold>35</bold>, 126–136.</mixed-citation>
    </ref>
    <ref id="bb19">
      <mixed-citation publication-type="other">Ince, D. C., Hatton, L. &amp; Graham-Cumming, J. (2012). <italic>Nature (London)</italic>, <bold>482</bold>, 485–488.</mixed-citation>
    </ref>
    <ref id="bb20">
      <mixed-citation publication-type="other">Kabsch, W. (1988). <italic>J. Appl. Cryst.</italic>
<bold>21</bold>, 916–924.</mixed-citation>
    </ref>
    <ref id="bb21">
      <mixed-citation publication-type="other">Kabsch, W. (2010). <italic>Acta Cryst.</italic> D<bold>66</bold>, 133–144.</mixed-citation>
    </ref>
    <ref id="bb22">
      <mixed-citation publication-type="other">Kameshima, T., Ono, S., Kudo, T., Ozaki, K., Kirihara, Y., Kobayashi, K., Inubushi, Y., Yabashi, M., Horigome, T., Holland, A., Holland, K., Burt, D., Murao, H. &amp; Hatsui, T. (2014). <italic>Rev. Sci. Instrum.</italic>
<bold>85</bold>, 033110.</mixed-citation>
    </ref>
    <ref id="bb23">
      <mixed-citation publication-type="other">Karplus, P. A. &amp; Diederichs, K. (2012). <italic>Science</italic>, <bold>336</bold>, 1030–1033.</mixed-citation>
    </ref>
    <ref id="bb24">
      <mixed-citation publication-type="other">Karplus, P. A. &amp; Diederichs, K. (2015). <italic>Curr. Opin. Struct. Biol.</italic>
<bold>34</bold>, 60–68.</mixed-citation>
    </ref>
    <ref id="bb25">
      <mixed-citation publication-type="other">Könnecke, M., Akeroyd, F. A., Bernstein, H. J., Brewster, A. S., Campbell, S. I., Clausen, B., Cottrell, S., Hoffmann, J. U., Jemian, P. R., Männicke, D., Osborn, R., Peterson, P. F., Richter, T., Suzuki, J., Watts, B., Wintersberger, E. &amp; Wuttke, J. (2015). <italic>J. Appl. Cryst.</italic>
<bold>48</bold>, 301–305.</mixed-citation>
    </ref>
    <ref id="bb26">
      <mixed-citation publication-type="other">Liu, H. &amp; Spence, J. C. H. (2014). <italic>IUCrJ</italic>, <bold>1</bold>, 393–401.</mixed-citation>
    </ref>
    <ref id="bb27">
      <mixed-citation publication-type="other">Liu, W., Wacker, D., Gati, C., Han, G. W., James, D., Wang, D., Nelson, G., Weierstall, U., Katritch, V., Barty, A., Zatsepin, N. A., Li, D., Messerschmidt, M., Boutet, S., Williams, G. J., Koglin, J. E., Seibert, M. M., Wang, C., Shah, S. T. A., Basu, S., Fromme, R., Kupitz, C., Rendek, K. N., Grotjohann, I., Fromme, P., Kirian, R. A., Beyerlein, K. R., White, T. A., Chapman, H. N., Caffrey, M., Spence, J. C. H., Stevens, R. C. &amp; Cherezov, V. (2013). <italic>Science</italic>, <bold>342</bold>, 1521–1524.</mixed-citation>
    </ref>
    <ref id="bb28">
      <mixed-citation publication-type="other">Mariani, V., Morgan, A., Yoon, C. H., Lane, T. J., White, T. A., O’Grady, C., Kuhn, M., Aplin, S., Koglin, J., Barty, A. &amp; Chapman, H. N. (2016). <italic>J. Appl. Cryst.</italic>
<bold>49</bold>, 1073–1080.</mixed-citation>
    </ref>
    <ref id="bb29">
      <mixed-citation publication-type="other">Nakane, T., Joti, Y., Tono, K., Yabashi, M., Nango, E., Iwata, S., Ishitani, R. &amp; Nureki, O. (2016). <italic>J. Appl. Cryst.</italic>
<bold>49</bold>, 1035–1041.</mixed-citation>
    </ref>
    <ref id="bb30">
      <mixed-citation publication-type="other">Nass, K., Meinhart, A., Barends, T. R. M., Foucar, L., Gorel, A., Aquila, A., Botha, S., Doak, R. B., Koglin, J., Liang, M., Shoeman, R. L., Williams, G., Boutet, S. &amp; Schlichting, I. (2016). <italic>IUCrJ</italic>, <bold>3</bold>, 180–191.</mixed-citation>
    </ref>
    <ref id="bb31">
      <mixed-citation publication-type="other">Philipp, H. T., Koerner, L. J., Hromalik, M. S., Tate, M. W. &amp; Gruner, S. M. (2010). <italic>IEEE Trans. Nucl. Sci.</italic>
<bold>57</bold>, 3795–3799.</mixed-citation>
    </ref>
    <ref id="bb32">
      <mixed-citation publication-type="other">Powell, H. R. (1999). <italic>Acta Cryst.</italic> D<bold>55</bold>, 1690–1695.</mixed-citation>
    </ref>
    <ref id="bb33">
      <mixed-citation publication-type="other">Rossmann, M. G., Leslie, A. G. W., Abdel-Meguid, S. S. &amp; Tsukihara, T. (1979). <italic>J. Appl. Cryst.</italic>
<bold>12</bold>, 570–581.</mixed-citation>
    </ref>
    <ref id="bb34">
      <mixed-citation publication-type="other">Shin, H., Kim, S. &amp; Yoon, C. H. (2018). <italic>J. Korean Phys. Soc.</italic>
<bold>73</bold>, 16–20.</mixed-citation>
    </ref>
    <ref id="bb35">
      <mixed-citation publication-type="other">Stellato, F., Oberthür, D., Liang, M., Bean, R., Gati, C., Yefanov, O., Barty, A., Burkhardt, A., Fischer, P., Galli, L., Kirian, R. A., Meyer, J., Panneerselvam, S., Yoon, C. H., Chervinskii, F., Speller, E., White, T. A., Betzel, C., Meents, A. &amp; Chapman, H. N. (2014). <italic>IUCrJ</italic>, <bold>1</bold>, 204–212.</mixed-citation>
    </ref>
    <ref id="bb36">
      <mixed-citation publication-type="other">Thayer, J., Damiani, D., Ford, C., Gaponenko, I., Kroeger, W., O’Grady, C., Pines, J., Tookey, T., Weaver, M. &amp; Perazzo, A. (2016). <italic>J. Appl. Cryst.</italic>
<bold>49</bold>, 1363–1369.</mixed-citation>
    </ref>
    <ref id="bb37">
      <mixed-citation publication-type="other">White, T. A. (2014). <italic>Philos. Trans. R. Soc. Lond. B Biol. Sci.</italic>
<bold>369</bold>, 20130330.</mixed-citation>
    </ref>
    <ref id="bb38">
      <mixed-citation publication-type="other">White, T. A., Barty, A., Liu, W., Ishchenko, A., Zhang, H., Gati, C., Zatsepin, N. A., Basu, S., Oberthür, D., Metz, M., Beyerlein, K. R., Yoon, C. H., Yefanov, O. M., James, D., Wang, D., Messerschmidt, M., Koglin, J. E., Boutet, S., Weierstall, U. &amp; Cherezov, V. (2016). <italic>Sci. Data</italic>, <bold>3</bold>, 160057.</mixed-citation>
    </ref>
    <ref id="bb39">
      <mixed-citation publication-type="other">White, T. A., Barty, A., Stellato, F., Holton, J. M., Kirian, R. A., Zatsepin, N. A. &amp; Chapman, H. N. (2013). <italic>Acta Cryst.</italic> D<bold>69</bold>, 1231–1240.</mixed-citation>
    </ref>
    <ref id="bb40">
      <mixed-citation publication-type="other">White, T. A., Kirian, R. A., Martin, A. V., Aquila, A., Nass, K., Barty, A. &amp; Chapman, H. N. (2012). <italic>J. Appl. Cryst.</italic>
<bold>45</bold>, 335–341.</mixed-citation>
    </ref>
    <ref id="bb41">
      <mixed-citation publication-type="other">White, T. A., Mariani, V., Brehm, W., Yefanov, O., Barty, A., Beyerlein, K. R., Chervinskii, F., Galli, L., Gati, C., Nakane, T., Tolstikova, A., Yamashita, K., Yoon, C. H., Diederichs, K. &amp; Chapman, H. N. (2016). <italic>J. Appl. Cryst.</italic>
<bold>49</bold>, 680–689.</mixed-citation>
    </ref>
    <ref id="bb42">
      <mixed-citation publication-type="other">Winkler, F. K., Schutt, C. E. &amp; Harrison, S. C. (1979). <italic>Acta Cryst.</italic> A<bold>35</bold>, 901–911.</mixed-citation>
    </ref>
    <ref id="bb43">
      <mixed-citation publication-type="other">Winn, M. D., Ballard, C. C., Cowtan, K. D., Dodson, E. J., Emsley, P., Evans, P. R., Keegan, R. M., Krissinel, E. B., Leslie, A. G. W., McCoy, A., McNicholas, S. J., Murshudov, G. N., Pannu, N. S., Potterton, E. A., Powell, H. R., Read, R. J., Vagin, A. &amp; Wilson, K. S. (2011). <italic>Acta Cryst.</italic> D<bold>67</bold>, 235–242.</mixed-citation>
    </ref>
    <ref id="bb44">
      <mixed-citation publication-type="other">Yefanov, O., Mariani, V., Gati, C., White, T. A., Chapman, H. N. &amp; Barty, A. (2015). <italic>Opt. Express</italic>, <bold>23</bold>, 28459–28470.</mixed-citation>
    </ref>
    <ref id="bb45">
      <mixed-citation publication-type="other">Zaefferer, S. (2000). <italic>J. Appl. Cryst.</italic>
<bold>33</bold>, 10–25.</mixed-citation>
    </ref>
    <ref id="bb46">
      <mixed-citation publication-type="other">Zhou, L., Liu, P. &amp; Dong, Y.-H. (2013). <italic>Chin. Phys. C</italic>, <bold>37</bold>, 028101.</mixed-citation>
    </ref>
  </ref-list>
</back>
<floats-group>
  <fig id="fig1" orientation="portrait" position="float">
    <label>Figure 1</label>
    <caption>
      <p>Layout of the <italic>CrystFEL</italic> download archive.</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig1"/>
  </fig>
  <fig id="fig2" orientation="portrait" position="float">
    <label>Figure 2</label>
    <caption>
      <p>Flow diagram for data import, indexing and integration with <italic>CrystFEL</italic>. Blue and red boxes indicate programs internal and external to <italic>CrystFEL</italic>, respectively, with program names in bold italic text. Grey boxes indicate files or data.</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig2"/>
  </fig>
  <fig id="fig3" orientation="portrait" position="float">
    <label>Figure 3</label>
    <caption>
      <p>Flow diagram for data merging with <italic>CrystFEL</italic>. See Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref> for the key to the colours.</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig3"/>
  </fig>
  <fig id="fig4" orientation="portrait" position="float">
    <label>Figure 4</label>
    <caption>
      <p>Flow diagram for calculating figures of merit with <italic>CrystFEL</italic>. See Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref> for the key to the colours.</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig4"/>
  </fig>
  <fig id="fig5" orientation="portrait" position="float">
    <label>Figure 5</label>
    <caption>
      <p>Flow diagram of data export from <italic>CrystFEL</italic>. See Fig. 2<xref ref-type="fig" rid="fig2"> ▸</xref> for the key to the colours. The gradient-shaded blue/red box indicates an external program (<italic>F</italic>2<italic>MTZ</italic> from <italic>CCP</italic>4) being driven by a <italic>CrystFEL</italic> script (<italic>create-mtz</italic>).</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig5"/>
  </fig>
  <fig id="fig6" orientation="portrait" position="float">
    <label>Figure 6</label>
    <caption>
      <p>Screenshot of <italic>cell_explorer</italic>, showing clear peaks for each of the six unit-cell parameters, each of which has been selected and fitted.</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig6"/>
  </fig>
  <fig id="fig7" orientation="portrait" position="float">
    <label>Figure 7</label>
    <caption>
      <p>Intensity plot created by the <italic>peakogram-stream</italic> script, showing a cloud of points owing to saturation at low resolution between 7000 and 10 000 intensity units.</p>
    </caption>
    <graphic xlink:href="d-75-00219-fig7"/>
  </fig>
</floats-group>
