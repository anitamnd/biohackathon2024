<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Environ Microbiome</journal-id>
    <journal-id journal-id-type="iso-abbrev">Environ Microbiome</journal-id>
    <journal-title-group>
      <journal-title>Environmental Microbiome</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2524-6372</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8066848</article-id>
    <article-id pub-id-type="publisher-id">361</article-id>
    <article-id pub-id-type="doi">10.1186/s40793-020-00361-y</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>BLAST-QC: automated analysis of BLAST results</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Torkian</surname>
          <given-names>Behzad</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hann</surname>
          <given-names>Spencer</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Preisner</surname>
          <given-names>Eva</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-4766-4376</contrib-id>
        <name>
          <surname>Norman</surname>
          <given-names>R. Sean</given-names>
        </name>
        <address>
          <email>rsnorman@mailbox.sc.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="GRID">grid.254567.7</institution-id><institution-id institution-id-type="ISNI">0000 0000 9075 106X</institution-id><institution>Department of Environmental Health Sciences, </institution><institution>University of South Carolina, </institution></institution-wrap>921 Assembly Street, Columbia, SC 29208 USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>12</day>
      <month>8</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>8</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>15</volume>
    <elocation-id>15</elocation-id>
    <history>
      <date date-type="received">
        <day>13</day>
        <month>2</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>7</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license>
        <ali:license_ref specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p><bold>Open Access</bold>This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">The Basic Local Alignment Search Tool (BLAST) from NCBI is the preferred utility for sequence alignment and identification for bioinformatics and genomics research. Among researchers using NCBI’s BLAST software, it is well known that analyzing the results of a large BLAST search can be tedious and time-consuming. Furthermore, with the recent discussions over the effects of parameters such as ‘-max_target_seqs’ on the BLAST heuristic search process, the use of these search options are questionable. This leaves using a stand-alone parser as one of the only options of condensing these large datasets, and with few available for download online, the task is left to the researcher to create a specialized piece of software anytime they need to analyze BLAST results. The need for a streamlined and fast script that solves these issues and can be easily implemented into a variety of bioinformatics and genomics workflows was the initial motivation for developing this software.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">In this study, we demonstrate the effectiveness of BLAST-QC for analysis of BLAST results and its desirability over the other available options. Applying genetic sequence data from our bioinformatic workflows, we establish BLAST_QC’s superior runtime when compared to existing parsers developed with commonly used BioPerl and BioPython modules, as well as C and Java implementations of the BLAST_QC program. We discuss the ‘max_target_seqs’ parameter, the usage of and controversy around the use of the parameter, and offer a solution by demonstrating the ability of our software to provide the functionality this parameter was assumed to produce, as well as a variety of other parsing options. Executions of the script on example datasets are given, demonstrating the implemented functionality and providing test-cases of the program. BLAST-QC is designed to be integrated into existing software, and we establish its effectiveness as a module of workflows or other processes.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">BLAST-QC provides the community with a simple, lightweight and portable Python script that allows for easy quality control of BLAST results while avoiding the drawbacks of other options. This includes the uncertain results of applying the -max_target_seqs parameter or relying on the cumbersome dependencies of other options like BioPerl, Java, etc. which add complexity and run time when running large data sets of sequences. BLAST-QC is ideal for use in high-throughput workflows and pipelines common in bioinformatic and genomic research, and the script has been designed for portability and easy integration into whatever type of processes the user may be running.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Basic Local Alignment Search Tool</kwd>
      <kwd>Blast</kwd>
      <kwd>Bioinformatics</kwd>
      <kwd>Genomics</kwd>
      <kwd>Sequencing</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000001</institution-id>
            <institution>National Science Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>DEB-1149447</award-id>
        <award-id>EF-0723707</award-id>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p id="Par10">The Basic Local Alignment Search Tool (BLAST) from NCBI has been a popular tool for analyzing the large data sets of genetic sequences that have become common when working with new generation sequencing technologies. BLAST has been the preferred utility for sequence alignment and identification in bioinformatics and genomics research and workflows for almost 30 years [<xref ref-type="bibr" rid="CR1">1</xref>]. One of the main challenges for researchers utilizing the NCBI BLAST is interpreting the huge amount of output data produced when analyzing large numbers of input sequences. While BLAST does allow for multiple output formats as well as limiting the number of top hit results (using -outfmt and -max_target_seqs, respectively) [<xref ref-type="bibr" rid="CR2">2</xref>], for some purposes such as pushing results down a workflow or pipeline, these tools may not be enough to ensure results that can be meaningfully and reasonably interpreted. The controversy raised by Shah et al. [<xref ref-type="bibr" rid="CR3">3</xref>] in their 2018 paper outlining a bug in the functionality of the -max_target_seqs parameter has started a discussion in the BLAST community over the usage and potential for misuse of the parameter. NCBI published a response stating that the utility of this parameter is simply misunderstood by the community and that the bug seen by Shah et al. was the result of “overly aggressive optimization” introduced in 2012, and patched the issue following the release of BLAST+ 2.8.1 in 2018 [<xref ref-type="bibr" rid="CR4">4</xref>]. However, follow up test cases and posts, including those by Peter Cock [<xref ref-type="bibr" rid="CR5">5</xref>], have shown that this issue is much more complex than simply “BLAST returns the first N hits that exceed the specified e-value threshold”. While the update 2.8.1 fixed 9/10 of Shah et al’s test cases, according to the post by Peter Cock, 1/10 remained invalid, due to an error with the internal candidate sequence limit introduced by -max_target_seqs 1. This is because, as was stated by Shah et al. [<xref ref-type="bibr" rid="CR3">3</xref>], the -max_target_seqs parameter is applied much earlier in the search, before the final gapped alignment stage. This means that the use of this parameter can change the number of sequences processed as well as the statistical significance of a hit if using composition-based statistics [<xref ref-type="bibr" rid="CR2">2</xref>]. This is contrary to the popular assumption that the parameter is simply a filter applied post search [<xref ref-type="bibr" rid="CR6">6</xref>]. This intuition is false, and may lead to errors in the resulting data of a BLAST search if the value of -max_target_seqs is too small. The use of -max_target_seqs in this way is not advised. As a result of the misinformation and confusion over ‘-max_target_seqs’ and other intricacies of the BLAST heuristic search and filtering process, there has been a push towards more detailed documentation of these processes and effects of parameters on the BLAST algorithm [<xref ref-type="bibr" rid="CR6">6</xref>], with NCBI adding a warning to the BLAST command-line application if the value of -max_target_seqs is less than 5 [<xref ref-type="bibr" rid="CR7">7</xref>]. The community has also moved towards better methods of narrowing the results of a large search, as opposed to using BLAST parameters that may affect the actual search process. These methods include resources like Bio-Perl and BioPython that can be used to create scripts to parse and filter result files. A few community written scripts can be found available online, such as the Perl script created by Dr. Xiaodong Bai and published online by Ohio State [<xref ref-type="bibr" rid="CR8">8</xref>], a version of this script produced by Erin Fichot [<xref ref-type="bibr" rid="CR9">9</xref>], and a XML to tabular parser by Peter Cock [<xref ref-type="bibr" rid="CR10">10</xref>]. While all of these scripts (and others like them) can potentially be very useful for parsing BLAST XML results into a concise tabular format, most have drawbacks that leave much to be desired. First and most importantly, for Bai and Fichot, the programs require Perl and Bio-Perl modules which can be unwieldy and slow for use in high-throughput workflows and pipelines, especially those which are built on a modern python framework. Furthermore, both scripts contain a bug, found on lines 77 and 93 respectively, that causes the query frame value to be lost through the parsing process, setting the value to 0. Our team sought to correct this and other errors and to provide a verified solution that can be soundly applied for research purposes. Secondly, the team saw a need for increased functionality, particularly the ability to filter results by threshold values input by the user. The only program that implements a threshold other than BLAST-QC is the script by Fichot, but only a bit score threshold is implemented. Our team sought to provide a single solution that would let researchers determine the best combination of values that would be optimal for any given experiment without the need to change parsers between runs. The team’s central motivation was to pursue creating a dedicated piece of quality control software for use in research workflows, find a solution that solely utilizes Python 3, streamlines the process, and reduces run times for parsing large data sets of BLAST results. Implementation:</p>
    <p id="Par11">BLASTQC has been implemented in a single python file, requiring only that Python3 be installed for all functionalities to be used. The team felt that an implementation in Python was important for the simplicity and ease of use that comes with the Python environment. Python is also one of the most popular and well understood languages for research purposes, and thus is a perfect choice for a tool that is designed for portability and integration into other research processes. Python is also capable of very fast runtimes when compared to other interpreted languages, such as Perl, and while it may be slower than a compiled language like C, the benefits in ease of use and portability outweigh the minor increase in runtimes. For example, C requires the use of dependencies like libxml2 for parsing, requiring a higher level of knowledge to make modifications to source code, and as such is less desirable as a simple addition to bioinformatic workflows already built within the Python framework. With Python 3 the parsing step of the workflow is simplified to a single file. Furthermore, the use of a standalone script rather than the use of a command line sorting option such as GNU sort not only provides a great increase in possible functionality, as implementing filtering parameters in bash on the command line can be cumbersome, but also allows for a better user experience for researchers who don’t want to memorize long sort commands that need to be changed constantly as experiment goals change. The BLAST-QC script implements thresholds on e-value, bit-score, percentage identity, and the number of ‘taxids’ (level of taxonomic or functional gene detail) in the definition of a hit (&lt;hit_def &gt; in BLAST XML results). It is also possible for the user to choose which of these values the output should be ordered by and how many top matches should be returned per query sequence in the input. Thus, the behavior of the -max_target_seqs parameter may be implemented with ease without altering the search process. Additionally, if the researcher decides that a higher bit-score is more important for a certain experiment, it is trivial to change the parsing process to return the highest bit-score hit, whereas max_target_seqs only supports returning top hits by e-value. Further, the Python script is also capable of setting a range on the threshold values, and selecting those sequences that produced a more detailed hit definition within that range. This is useful for researchers because it avoids the problem of finding a high scoring sequence that provides no relevant information, as there may be little use in knowing that a hit accurately matches an unknown sequence. For example, a BLAST search may return a hit sequence with a taxid of “protein of unknown function DUF1680”. This may not be a useful result for a study on the function of a specific protein, regardless of how low the evalue of the hit. BlastQC allows researchers to define the reasonable evalue for their application using input parameters, and returns hits with more informative taxids that still fit within the chosen parameters. Increased definition information is useful for narrowing the taxonomy of a species (for BLAST nucleotide) or the type/functionality of a protein sequence in a protein BLAST query. The team also found an issue in many of the available community parsers regarding the number of HSPs (high scoring pairs) per hit. In some cases BLAST may return multiple HSPs per hit sequence, and the BLAST-QC script handles this by considering it a separate hit that retains the same id and definition. This case was not covered in any of the scripts the team encountered online, causing hits with multiple HSPs to lose any data from the additional HSPs. The BLAST-QC Python script is compatible with all BLAST types (BLASTP, BLASTN, BLASTX, etc.) as well as both the tabular and XML output formats (−outfmt 6 and -outfmt 5, respectively) and reports all relevant data produced in a BLAST results file: query name, query length, accession number, subject length, subject description, e-value, bit-score, query frame, query start, query end, hit start, hit end, percent identity, and percent conserved (qseqid, sseqid, pident, length, mismatch, gapopen, qstart, qend, sstart, send, evalue, bitscore and salltitles (optional) for tabular output). Information on these values can be found in the BLAST glossary and manual [<xref ref-type="bibr" rid="CR2">2</xref>, <xref ref-type="bibr" rid="CR11">11</xref>], and the two percentage values (percent identity and percent conserved) have been calculated using the identity (Hsp_identity), positive (Hsp_positive) and align length values (Hsp_align-len). Percent identity is defined as the percent of the sequences that have identical residues at the same alignment positions and is calculated by the number of identical residues divided by the length of the alignment multiplied by 100 (100*(hsp_identity/hsp_align-len)). Percent conserved (positive) is defined as the percent of the sequences that have ‘positive’ residues (chemically similar) at the same alignment positions and is calculated by the number of positive residues divided by the length of the alignment multiplied by 100 (100*(hsp_positive/hsp_align-len)). Additionally, BLAST-QC supports parallel processing of results, using Python’s multiprocessing module. The number of concurrent BLASTQC processes defaults to the number of CPU cores present on the machine, but this value may be adjusted using the -p command line option. If sequential processing is desired, the number of processes may be set to 1 using “-p 1”. This along with the ability to pipe input from stdin allow for replication of some of GNU sort’s main features.</p>
  </sec>
  <sec id="Sec2">
    <title>Results</title>
    <p id="Par12">The objective of the development of BLAST-QC was to provide BLAST users with a method of quality control that ensures accuracy of results, posts superior runtimes, and provides configurations for many types of analysis processes, while remaining streamlined and simple to use and modify. In order to establish BLAST-QCs effectiveness as compared to other quality control options, we have compared BLAST-QC python to implementations of the program in compiled languages, both C and Java, to the community available parsers by Bai, Fichot and Cock, and to a standard approach to parsing for some researchers, GNU sort commands.</p>
    <p id="Par13">We demonstrate the ability of BLAST-QC to correct the issue with `max_target _seqs`, using the dataset provided in the case study from Shah et al. [<xref ref-type="bibr" rid="CR3">3</xref>]. This dataset is available on Shah’s github page, ‘<ext-link ext-link-type="uri" xlink:href="https://github.com/shahnidhi/BLAST_maxtargetseq_analysis">https://github.com/shahnidhi/BLAST_maxtargetseq_analysis</ext-link>’. As shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>, BLAST-QC was able to correctly identify the lowest e-value hit for the same query sequence while BLAST with ‘-max_target_seqs = 1’ was not. This result illustrates the potential for errors to be introduced into BLAST data by the use of this parameter, and we encourage researchers to seek more information on its usage and application [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR11">11</xref>]. To use BLAST-QC to replicate the function of ‘-max_target_seqs’ leave the parameter set to default while using BLAST to locate matching sequences, then run BLAST-QC on the resulting data, ordering output by e-value and setting a limit of 1 hit per query using the syntax shown at the bottom of Fig. <xref rid="Fig1" ref-type="fig">1</xref>. Although the issue with max_target_seqs has been corrected in BLAST 2.8.1, it is still not well understood by the BLAST community and, being a popular parameter, we felt that it was important to show this use case in order to demonstrate a safe way of achieving the desired effect, as well as to promote compatibility with older versions of the BLAST software. We also demonstrate the runtime of BLAST-QC as compared to existing parsers, two developed with the commonly used BioPerl modules, one written by Xiaodong Bai from Ohio State and an improved version of the same script developed by Erin Fichot [<xref ref-type="bibr" rid="CR9">9</xref>], an XML to tabular conversion script published by Peter Cock [<xref ref-type="bibr" rid="CR10">10</xref>], implementations of the BLAST-QC parser in both Java and C, as well as a standard GNU sort command. The implementations in C and Java were necessary to compare BLAST-QC Python to both compiled and interpreted languages, as both Python and Perl are interpreted languages. The sort command used for the runtime benchmarking is “sort -k1,1 -k11,11 blast.tab”, as this replicates ordering the hit sequences for each query sequence by evalue, BLAST-QCs default mode. Thus, we sort by query name first, then by evalue. All runtime data was gathered using a system with a 28 core Intel Xeon E5–2680 @ 2.4GHz and 128GB of RAM. All sample datasets used for figures were produced using nucleotide sequences extracted for use in another one of our teams bioinformatic workflows [<xref ref-type="bibr" rid="CR9">9</xref>]. The BLAST command used to produce the result data was: ‘ncbi-blast-2.10.0+/bin/blastn -query Aug2013_metaG_12142016-34108099_Experiment1_layer1.fasta -db SILVA_132_SSURef_Nr99_tax_silva_trunc -outfmt (5 and 6) -num_threads 28’. Result datasets were then split into 5 files containing 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, 10<sup>6</sup> and 10<sup>7</sup> query sequences respectively. As the datasets used for the runtime tests are very large (the largest being ~60gb for 10<sup>7</sup> query sequences), we have hosted the datasets on our team’s HPC server. For access to the exact data used for all test cases, please submit a request at: <ext-link ext-link-type="uri" xlink:href="https://sc.edu/about/offices_and_divisions/division_of_information_technology/rci/">https://sc.edu/about/offices_and_divisions/division_of_information_technology/rci/</ext-link>.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Demonstration of max_target_seqs error and correction (BLAST 2.8.0 or earlier) on the test cases presented by Shah et al. in 2018 [<xref ref-type="bibr" rid="CR3">3</xref>]. Command 1 demonstrates the usage of BLASTN to produce only 1 top e-value hit per query sequence, using ‘-max_target_seqs 1’. Command 2 demonstrates the usage of BLAST-QC to parse the top e-value hit from the standard BLAST output, using ‘-or e -n 1’ to order by e-value and return only 1 top hit per query. These commands are executed for 3 separate query sequences (represented in the respective commands by infile.fasta), sequences 1, 2 and 3. As the e-values in figure show (column 5), BLAST-QC is able to extract the top e-value hit from these test case examples, while max_target_seqs is not. This error has been corrected in BLAST 2.8.1, but we show this example for compatibility with those who might be running older versions of BLAST or have older BLAST results datasets</p></caption><graphic xlink:href="40793_2020_361_Fig1_HTML" id="MO1"/></fig></p>
    <p id="Par14">While each script is designed to operate on a BLAST output file, they all differ in functionality and implementation. All versions of BLAST-QC (Python, Java, C) can operate on both XML and tabular BLAST outformats, while the scripts by Bai, Fichot and Cock only operate on XML output, whereas GNU sort only functions on a tabular outformat. These scripts were chosen for comparison as they replicate many of the possible use cases for BLAST-QC, both direct tabular conversion of results as well as the application of filtering thresholds to provide quality control. Both scripts by Bai and Cock do not provide any quality control or threshold functionality, they simply function as XML to tabular format converters for BLAST results, while Fichot implements a bit-score threshold and support for both protein and nucleotide databases. All versions of BLAST-QC implement the ability to operate on both BLAST output formats, the ability to input various filters to narrow results to the highest quality sequences, and support for both protein and nucleotide databases. Figure <xref rid="Fig2" ref-type="fig">2</xref> plots runtime vs number of query sequences for all four programs that operate on tabular format, using the same dataset of BLAST result files. As the figure depicts, BLAST-QC C version is the fastest program, followed by Python, GNU sort then Java. While the C version is certainly faster, it requires the use of external libraries libxml2, requires more knowledge than python to operate and maintain, and is only marginally faster. Most notably, BLASTQC Python outperforms a GNU sort of the dataset at ordering hits by evalue. Many researchers choose GNU sort as a standard approach to parsing BLAST results as it is a widely available solution, but as the figure shows, it does not perform as well as the standalone parser. Furthermore, more complex QC tasks require a strong knowledge of GNU sort’s syntax and creates additional runtime, making standalone parsers much more functional for complex parsing tasks (eg. replicating -max_target_seqs). Lastly, the Java parser performed the worst of the four parsers in the tabular benchmark, despite the fact that Java is a compiled, rather than interpreted, language. This is most likely due to the high memory overhead required by the Java Virtual Machine (JVM), which takes up memory bandwidth that is needed for parsing the large BLAST files. Figure <xref rid="Fig3" ref-type="fig">3</xref> plots runtime vs number of query sequences for all 6 programs that operate on XML format, using the same dataset of BLAST result files. Both Bioperl parsers performed worst out of all the XML parsers, with Fichot’s script being somewhat of an outlier in the dataset (over 4 h to parse a file with 10<sup>6</sup> query sequences). This is most likely due to the combination of the cumbersome BioPerl modules and the more involved parsing of Fichot’s script as compared to the script by Xaiodong Bai, as well as the fact that Perl is an interpreted language. The C parser had the fastest runtime in the XML benchmark, followed by the blastxml_to_tabular. The blastxml_to_tabular script simply converts the data from XML to tabular, so no real computations are required. In both Figs. <xref rid="Fig1" ref-type="fig">2</xref> and <xref rid="Fig2" ref-type="fig">3</xref>, we plot runtimes for both sequential (1 core) and parallel processing modes (28 cores) of the BLAST-QC python application, to demonstrate the effect of the parameter on runtime. While the parallel processing takes more time for a lower number of query sequences, at a value of approximately 5.055 × 10<sup>5</sup> query sequences for XML out format, and 5.354 × 10<sup>6</sup> for tabular, the program running in parallel achieves a faster runtime than that of the sequential program. This is due to the fact that opening each separate process and facilitating communication creates more overhead than the parallelization can scale for smaller inputs, but over a larger number of query sequences the efficiency of parallelization decreases the overall runtime, despite the overhead of the required process management. In Figs. <xref rid="Fig4" ref-type="fig">4</xref>-<xref rid="Fig6" ref-type="fig">6</xref> we demonstrate some of the various functionalities of BLAST-QC and provide the results of their application to a sample dataset. In Fig. <xref rid="Fig4" ref-type="fig">4</xref> the range functionality is demonstrated using an e-value range of .0005. This means that BLAST-QC will consider hits found that fall within that range of the lowest e-value hit, if the target sequence provides an increase in the quality of the hit definition (taxids in &lt;Hit_def &gt; or salltitles). As depicted in Fig. <xref rid="Fig5" ref-type="fig">5</xref> the sequence returned by simply returning the lowest e-value hit provides a definition that may not be useful for research analysis, while the top hit using a range value provides an insightful description of the sequence while maintaining a reasonable e-value within that range. In BLAST-QC, range values are implemented on e-value, bit-score, and percent identity. Figure <xref rid="Fig5" ref-type="fig">5</xref> depicts the ordering functionality of BLAST-QC, and ordering by e-value, bit-score, percent identity and hit definition is implemented. For example, when ordering by definition, as in Fig. <xref rid="Fig5" ref-type="fig">5</xref> [<xref ref-type="bibr" rid="CR1">1</xref>], the hit that has the highest quality of hit definition that fits input thresholds will be returned. Figure <xref rid="Fig6" ref-type="fig">6</xref> demonstrates the threshold capability of the BLAST-QC program. The first sequence is returned when ordering by e-value with the number of hits set to one (replicating max_target_seqs). The second employs a bit-score threshold to find a matching sequence with the highest e-value that also has a bit-score above the threshold. Threshold values are implemented on e-value, bit-score, percent identity and hit definition. All of the resources needed for the BLAST-QC software are available for download from the BLAST-QC GitHub repository: <ext-link ext-link-type="uri" xlink:href="https://github.com/torkian/blast-QC">https://github.com/torkian/blast-QC</ext-link>. Additional test-cases and usage information for the program are located on the page as well.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Plot of runtime vs number of query sequences in a BLASTN tabular (−outfmt 6) results file. The graph is a linear-log plot, the number of query sequences is shown on a log scale, due to the exponential nature of runtime data and the large numbers of sequences involved. Each of the scripts were run against BLAST tabular files containing 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, 10<sup>6</sup> and 10<sup>7</sup> query sequences, respectively. All versions of BLAST QC were run using default parameters (no command line options specified), which is to order hit sequences for each query by e-value. To replicate this behavior using GNU sort, the command ‘sort -k1,1 -k11,11’, was used as this orders the rows in the tabular output by query id then e-value (the 1st and 11th columns respectively)</p></caption><graphic xlink:href="40793_2020_361_Fig2_HTML" id="MO2"/></fig><fig id="Fig3"><label>Fig. 3</label><caption><p>Plot of runtime vs number of query sequences in a BLASTN XML (−outfmt 5) results file. The graph is a linear-log plot, the number of query sequences is shown on a log scale, due to the exponential nature of runtime data and the large numbers of sequences involved. Each of the scripts were run against BLAST XML files containing 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>, 10<sup>6</sup> query sequences respectively. We did not include a run of 10<sup>7</sup> XML query sequences as the file size became impractical for our system, taking up all 128Gb of ram (this resulted in a outOfMemoryException on the Java parser). All versions of BLAST QC were run using default parameters (no command line options specified), which is to order hit sequences for each query by e-value. Fichot’s BioPerl script was also run using default parameters with no thresholds implemented. Both the BioPerl script by Xiaodong Bai and the Python script by Peter Cock only function as XML (outfmt 5) to tabular format (outfmt 6) converters, so no input parameters are required</p></caption><graphic xlink:href="40793_2020_361_Fig3_HTML" id="MO3"/></fig><fig id="Fig4"><label>Fig. 4</label><caption><p>Demonstration of range parameters of BLAST-QC. Command 1 depicts the usage of BLAST-QC to return a single top hit per query sequence. Command 2 depicts the same command with an additional range parameter, ‘-er .0005’. This will return a hit within this e-value range (+.0005 from the top e-value hit) that has the most taxids present. Thus, as the figure shows, the result of command 2 is a hit with a e-value that is .0005 more than the first top hit returned in command 1, but with more informative taxids</p></caption><graphic xlink:href="40793_2020_361_Fig4_HTML" id="MO4"/></fig><fig id="Fig5"><label>Fig. 5</label><caption><p>Demonstration of the order by function of BLAST-QC. Command 1 depicts the usage of BLAST-QC to order a BLAST results file by e-value, while command 2 depicts the usage of BLAST-QC to order results by percent identity. The result of each respective command is shown in the table above</p></caption><graphic xlink:href="40793_2020_361_Fig5_HTML" id="MO5"/></fig><fig id="Fig6"><label>Fig. 6</label><caption><p>Demonstration of threshold functionality of BLAST-QC. Command 1 demonstrates the usage of BLAST-QC to return the top e-value hit per query, while command 2 depicts the usage of BLAST-QC to return the top e-value hit per query with a bitscore threshold of 60 (−b 60). The results of command 1 return a hit with an e-value of .0015, while the hit’s bitscore is only 32.40. the results of command 2 return a hit with an e-value of .005, but with a bitscore of 66.5</p></caption><graphic xlink:href="40793_2020_361_Fig6_HTML" id="MO6"/></fig></p>
  </sec>
  <sec id="Sec3">
    <title>Discussion</title>
    <p id="Par15">BLAST-QC was developed using Python 3, and is designed for usage within a script or larger workflow, but also offers a headless command-line interface for use with smaller datasets. Usage information has been documented in this paper, and additional documentation, as well as all test-cases and datasets used in this paper can be found in the BLAST-QC GitHub repository, at <ext-link ext-link-type="uri" xlink:href="https://github.com/torkian/blast-QC">https://github.com/torkian/blast-QC</ext-link>. Our team seeks to standardize researchers’ approach to analyzing BLAST result datasets. Many researchers opt to apply ‘max_target_seqs’ as a quality control parameter in their research workflows (over 400 Google Scholar papers reference the value) [<xref ref-type="bibr" rid="CR12">12</xref>–<xref ref-type="bibr" rid="CR14">14</xref>], even though it has been shown that this parameter can cause issues with the search process and resulting data, and is simply not intended for this purpose. Those who use a standalone script are exchanging gains in the accuracy of results and greater functionality and control over parameters for increased bulk and runtime, which add up when running large datasets of sequences. With the added functionality and superior runtime that BLAST-QC provides over an option like GNU sort or max_target_seqs, the BLAST-QC script provides a practical option for parsing of BLAST result files, especially as with the use of Python, the task can be simplified to a single file. While there are other standalone quality control and filtering options available for BLAST results, BLAST-QC python takes a novel approach to the task, eliminating the necessity for other dependencies and allowing researchers to have increased control over the level of definition of results, while also providing greatly decreased runtimes when compared to other language and parsing options. We encourage the community to consider available options when seeking analysis of BLAST results, and to help contribute to and improve on our source code by submitting a pull request on the BLAST-QC GitHub page.</p>
  </sec>
  <sec id="Sec4">
    <title>Conclusions</title>
    <p id="Par16">BLAST-QC provides a fast and efficient method of quality control for NCBI BLAST result datasets. It offers greater functionality for controlling the desired QC parameters when compared to existing options and outperforms them in terms of runtime. We suggest that it is BLAST-QC’s Python 3 framework that allows it to outperform dense BioPerl and BioPython modules, while it also provides much higher functionality than GNU sort or even -max_target_seqs. Furthermore, BLAST-QC provides seamless integration into larger workflows developed with Python 3. With the increase in popularity of high-performance computing and new generation sequencing, novel approaches to BLAST quality control and other bioinformatic computational processes are needed to handle the increasing size of datasets, but also to take advantage of the increasing capacity of computing to provide solutions to these problems. Our team also sought to increase awareness of the controversy surrounding the application of the ‘max_target_seqs’ parameter in BLAST, and to provide a sound solution that replicates the function of the parameter and ensures the highest quality results. The BLAST-QC software and all other documentation and information can be located at BLAST-QC’s GitHub page.</p>
  </sec>
</body>
<back>
  <glossary>
    <title>Abbreviations</title>
    <def-list>
      <def-item>
        <term>BLAST</term>
        <def>
          <p id="Par4">Basic Local Alignment Search Tool</p>
        </def>
      </def-item>
      <def-item>
        <term>QC</term>
        <def>
          <p id="Par5">Quality Control</p>
        </def>
      </def-item>
      <def-item>
        <term>XML</term>
        <def>
          <p id="Par6">eXtensible Markup Language</p>
        </def>
      </def-item>
      <def-item>
        <term>HSP</term>
        <def>
          <p id="Par7">High Scoring Pairs</p>
        </def>
      </def-item>
      <def-item>
        <term>HPC</term>
        <def>
          <p id="Par8">High-Performance Computing</p>
        </def>
      </def-item>
      <def-item>
        <term>JVM</term>
        <def>
          <p id="Par9">Java Virtual Machine</p>
        </def>
      </def-item>
    </def-list>
  </glossary>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>BT, EP, and SN designed the study, with input from all authors. BT and SH implemented the software and performed thedata processing and analyses. BT and SH drafted the manuscript. All authors read, edited, and approved the final manuscript.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>- Project name: BLAST-QC.</p>
    <p>- Project home page: <ext-link ext-link-type="uri" xlink:href="https://github.com/torkian/blast-QC">https://github.com/torkian/blast-QC</ext-link></p>
    <p>- Operating system(s): Platform independent.</p>
    <p>- Programming language: Python 3.</p>
    <p>- Other requirements: None.</p>
    <p>- License: GNU GPL.</p>
    <p>- Any restrictions to use by non-academics: None.</p>
  </notes>
  <notes id="FPar3" notes-type="COI-statement">
    <title>Competing interests</title>
    <p id="Par72">The authors declare that they have no competing interest.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <mixed-citation publication-type="other">Altschul, Stephen F, et al. “Basic Local Alignment Search Tool.” Journal of Molecular Biology, Academic Press, 6 Feb. 2007, <ext-link ext-link-type="uri" xlink:href="http://www.sciencedirect.com/science/article/pii/S0022283605803602?via%3Dihub">www.sciencedirect.com/science/article/pii/S0022283605803602?via%3Dihub</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">BLAST® Command-Line Applications User Manual., National Center for Biotechnology Information, US National Library of Medicine, 14 Nov. 2018, <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/books/NBK279684/">www.ncbi.nlm.nih.gov/books/NBK279684/</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">Shah, Nidhi, et al. “Misunderstood Parameter of NCBI BLAST Impacts the Correctness of Bioinformatics Workflows.” OUP Academic, Oxford University Press, 24 Sept. 2018, <ext-link ext-link-type="uri" xlink:href="https://academic.oup.com/bioinformatics/article/35/9/1613/5106166">academic.oup.com/bioinformatics/article/35/9/1613/5106166</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <mixed-citation publication-type="other">Madden, Thomas L, et al. “Reply to the Paper: Misunderstood Parameters of NCBI BLAST Impacts the Correctness of Bioinformatics Workflows.” OUP Academic, Oxford University Press, 24 Dec. 2018, <ext-link ext-link-type="uri" xlink:href="http://academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/bty1026/5259186">academic.oup.com/bioinformatics/advance-article/doi/10.1093/bioinformatics/bty1026/5259186</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">Cock, Peter. What BLAST’s max-target-sequences Doesn't do, 2015, <ext-link ext-link-type="uri" xlink:href="https://blastedbio.blogspot.com/2015/12/blast-max-target-sequences-bug.html">blastedbio.blogspot.com/2015/12/blast-max-target-sequences-bug.html</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>González-Pech</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Stephens</surname>
            <given-names>TG</given-names>
          </name>
          <name>
            <surname>Chan</surname>
            <given-names>CX</given-names>
          </name>
        </person-group>
        <article-title>Commonly misunderstood parameters of NCBI BLAST and important considerations for users</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <issue>15</issue>
        <fpage>2697</fpage>
        <lpage>2698</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bty1018</pub-id>
        <pub-id pub-id-type="pmid">30541060</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Camacho, Christiam. “BLAST+ Release Notes.” BLAST® Help [Internet], U.S. National Library of Medicine, 16 Dec. 2019, <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/books/NBK131777/">www.ncbi.nlm.nih.gov/books/NBK131777/</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <mixed-citation publication-type="other">Bai, Xiaodong. Ohio State University, Blast_Parsing_for_Modification, <ext-link ext-link-type="uri" xlink:href="http://tomato.cfaes.ohio-state.edu/HCS806/blast_parsing_for_modification_pl.txt">https://tomato.cfaes.ohio-state.edu/HCS806/blast_parsing_for_modification_pl.txt</ext-link>. Accessed 16 July 2019.</mixed-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <mixed-citation publication-type="other">Preisner, Eva C, et al. “Microbial Mat Compositional and Functional Sensitivity to Environmental Disturbance.” Frontiers in microbiology vol. 7 1632. 17 Oct. 2016, 10.3389/fmicb.2016.01632.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">Cock, Peter J. “Peterjc/galaxy_blast.” GitHub, 19 Feb. 2019, <ext-link ext-link-type="uri" xlink:href="http://github.com/peterjc/galaxy_blast/blob/master/tools/ncbi_blast_plus/blastxml_to_tabular.py">github.com/peterjc/galaxy_blast/blob/master/tools/ncbi_blast_plus/blastxml_to_tabular.py</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <mixed-citation publication-type="other">Fassler, Jan, Peter Cooper. “BLAST Glossary.” BLAST® Help [Internet]., National Center for Biotechnology Information, U.S. National Library of Medicine, 14 July 2011, <ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/books/NBK62051/">www.ncbi.nlm.nih.gov/books/NBK62051/</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Meisel</surname>
            <given-names>JS</given-names>
          </name>
          <name>
            <surname>Hannigan</surname>
            <given-names>GD</given-names>
          </name>
          <name>
            <surname>Tyldsley</surname>
            <given-names>AS</given-names>
          </name>
          <name>
            <surname>San Miguel</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Hodkinson</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Zheng</surname>
            <given-names>Q</given-names>
          </name>
          <name>
            <surname>Elizabeth</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Grice, Skin Microbiome Surveys Are Strongly Influenced by Experimental Design</article-title>
        <source>J Invest Dermatol</source>
        <year>2016</year>
        <volume>136</volume>
        <issue>5</issue>
        <fpage>947</fpage>
        <lpage>956</lpage>
        <pub-id pub-id-type="doi">10.1016/j.jid.2016.01.016</pub-id>
        <pub-id pub-id-type="pmid">26829039</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Long, Kyle A., Nossa, Carlos W., Sewell, Mary A., Putnam, Nicholas H., Ryan, Joseph F., Low coverage sequencing of three echinoderm genomes: the brittle star Ophionereis fasciata, the sea star Patiriella regularis, and the sea cucumber Australostichopus mollis, GigaScience. December 2016;5(1). <ext-link ext-link-type="uri" xlink:href="https://gigascience.biomedcentral.com/articles/10.1186/s13742-016-0125-6">https://gigascience.biomedcentral.com/articles/10.1186/s13742-016-0125-6</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Giolai, Michael, et al. “Comparative Analysis of Targeted Long Read Sequencing Approaches for Characterization of a Plant’s Immune Receptor Repertoire.” BMC Genomics, BioMed Central, 26 July 2017, <pub-id pub-id-type="doi">10.1186/s12864-017-3936-7</pub-id>.</mixed-citation>
    </ref>
  </ref-list>
</back>
