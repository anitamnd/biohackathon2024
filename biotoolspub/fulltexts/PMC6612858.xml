<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.1?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6612858</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btz359</article-id>
    <article-id pub-id-type="publisher-id">btz359</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb/Eccb 2019 Conference Proceedings</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Population Genomics and Molecular Evolution</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>A divide-and-conquer method for scalable phylogenetic network inference from multilocus data</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Zhu</surname>
          <given-names>Jiafan</given-names>
        </name>
        <xref ref-type="aff" rid="btz359-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Liu</surname>
          <given-names>Xinhao</given-names>
        </name>
        <xref ref-type="aff" rid="btz359-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Ogilvie</surname>
          <given-names>Huw A</given-names>
        </name>
        <xref ref-type="aff" rid="btz359-aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0003-3288-6769</contrib-id>
        <name>
          <surname>Nakhleh</surname>
          <given-names>Luay K</given-names>
        </name>
        <xref ref-type="aff" rid="btz359-aff1">1</xref>
        <xref ref-type="aff" rid="btz359-aff2">2</xref>
        <xref ref-type="corresp" rid="btz359-cor1"/>
        <!--<email>nakhleh@rice.edu</email>-->
      </contrib>
    </contrib-group>
    <aff id="btz359-aff1"><label>1</label>Department of Computer Science, Rice University, Houston, TX, USA</aff>
    <aff id="btz359-aff2"><label>2</label>Department of BioSciences, Rice University, Houston, TX, USA</aff>
    <author-notes>
      <corresp id="btz359-cor1">To whom correspondence should be addressed. <email>nakhleh@rice.edu</email></corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2019-07-05">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>05</day>
      <month>7</month>
      <year>2019</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the <pub-date pub-type="epub"/>. -->
    <volume>35</volume>
    <issue>14</issue>
    <fpage>i370</fpage>
    <lpage>i378</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2019. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2019</copyright-year>
      <license license-type="cc-by-nc" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/4.0/">http://creativecommons.org/licenses/by-nc/4.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btz359.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Reticulate evolutionary histories, such as those arising in the presence of hybridization, are best modeled as phylogenetic networks. Recently developed methods allow for statistical inference of phylogenetic networks while also accounting for other processes, such as incomplete lineage sorting. However, these methods can only handle a small number of loci from a handful of genomes.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we introduce a novel two-step method for scalable inference of phylogenetic networks from the sequence alignments of multiple, unlinked loci. The method infers networks on subproblems and then merges them into a network on the full set of taxa. To reduce the number of trinets to infer, we formulate a Hitting Set version of the problem of finding a small number of subsets, and implement a simple heuristic to solve it. We studied their performance, in terms of both running time and accuracy, on simulated as well as on biological datasets. The two-step method accurately infers phylogenetic networks at a scale that is infeasible with existing methods. The results are a significant and promising step towards accurate, large-scale phylogenetic network inference.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>We implemented the algorithms in the publicly available software package PhyloNet (<ext-link ext-link-type="uri" xlink:href="https://bioinfocs.rice.edu/PhyloNet">https://bioinfocs.rice.edu/PhyloNet</ext-link>).</p>
      </sec>
      <sec id="s4">
        <title>Supplementary information</title>
        <p><xref ref-type="supplementary-material" rid="sup1">Supplementary data</xref> are available at <italic>Bioinformatics</italic> online.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">NSF</named-content>
          <named-content content-type="funder-identifier">10.13039/100000001</named-content>
        </funding-source>
        <award-id>DBI-1355998</award-id>
        <award-id>CCF-1302179</award-id>
        <award-id>CCF-1514177</award-id>
        <award-id>CCF-1800723</award-id>
        <award-id>DMS-1547433</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <named-content content-type="funder-name">NSF</named-content>
          <named-content content-type="funder-identifier">10.13039/100000001</named-content>
        </funding-source>
        <award-id>CNS-1338099</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Phylogenetic networks model non-treelike evolutionary histories, such as those arising when hybridization occurs, and take the shape of a rooted, directed acyclic graph. Phylogenetic network inference in the genomic era is most often carried out from data obtained from multiple unlinked loci across the genomes of species of interest. To account for the fact that processes such as incomplete lineage sorting (ILS) could co-occur with hybridization, the multispecies network coalescent (MSNC) model was introduced (<xref rid="btz359-B13" ref-type="bibr">Yu <italic>et al.</italic>, 2012</xref>, <xref rid="btz359-B14" ref-type="bibr">2014</xref>) to turn phylogenetic networks into a generative model of gene genealogies, and subsequently, a wide array of methods for statistical inference of phylogenetic networks under MSNC were introduced (<xref rid="btz359-B10" ref-type="bibr">Wen and Nakhleh, 2018</xref>; <xref rid="btz359-B11" ref-type="bibr">Wen <italic>et al.</italic>, 2016</xref>; <xref rid="btz359-B15" ref-type="bibr">Yu and Nakhleh, 2015</xref>; <xref rid="btz359-B14" ref-type="bibr">Yu <italic>et al.</italic>, 2014</xref>; <xref rid="btz359-B16" ref-type="bibr">Zhang <italic>et al.</italic>, 2018</xref>; <xref rid="btz359-B17" ref-type="bibr">Zhu and Nakhleh, 2018</xref>; <xref rid="btz359-B18" ref-type="bibr">Zhu et al., 2018</xref>).</p>
    <p>Initial evaluations of all these methods on simulated and biological data showed very promising results in terms of the accuracy of the inferences. However, these methods suffer from several major performance bottlenecks. Methods that evaluate the full likelihood [all of the aforementioned methods, except for the pseudo-likelihood method of <xref rid="btz359-B15" ref-type="bibr">Yu and Nakhleh (2015</xref>)] suffer from the prohibitive computational requirements of likelihood calculations (<xref rid="btz359-B2" ref-type="bibr">Elworth <italic>et al.</italic>, 2019</xref>; <xref rid="btz359-B17" ref-type="bibr">Zhu and Nakhleh, 2018</xref>). Currently, computing network likelihood is feasible only for fewer than 10 species and a very small number of reticulations. Second, all the aforementioned methods traverse the space of phylogenetic networks that is much larger than the space of phylogenetic trees, whose size is already exponential in the number of taxa. While the pseudo-likelihood method of <xref rid="btz359-B15" ref-type="bibr">Yu and Nakhleh (2015)</xref> circumvents the likelihood calculations, albeit in an approximate manner, it does not overcome the problem of exploring the space of the phylogenetic networks. Third, for Bayesian methods, exploring the trans-dimensional space of phylogenetic networks (the number of reticulations changes during the exploration) leads to poor mixing.</p>
    <p>In this article, we propose a method for large-scale phylogenetic network inference that ameliorates all three challenges. The method divides the set of taxa into small, overlapping subsets, builds accurate subnetworks on the subsets, and finally agglomerates the subnetworks into a network on the full set of taxa. By focusing on three-taxon subsets in this article, the likelihood calculations become very fast, exploring the space of all phylogenetic networks on large numbers of taxa is completely sidestepped. Also, mixing is improved because more iterations of the RJMCMC sampler can be run on three-taxon networks, especially since different subsets can be analyzed independently in parallel. Furthermore, to avoid building all <inline-formula id="IE1"><mml:math id="IM1"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> trinets, we provide a Hitting Set formulation of a problem for reducing the number of trinets based on gene trees, and demonstrate that the number of trinets can be reduced significantly without much effect on accuracy.</p>
    <p>We implemented our algorithms in PhyloNet (<xref rid="btz359-B12" ref-type="bibr">Wen <italic>et al.</italic>, 2018</xref>) and studied their accuracy and efficiency. When making use of error-free trinets, we show that the algorithm infers the correct network in all cases, whether making use of all trinets or a significantly reduced subset. When making use of inferred trinets, the algorithm has very good accuracy, where in many cases the correct network is inferred and in all others, a network with small error rate is inferred. This demonstrates the importance of inferring the trinets accurately. Equally important, the method allows for inferring large-scale networks whose inference is infeasible using existing statistical methods.</p>
    <p>The closest works to our proposed method here are those of <xref rid="btz359-B5" ref-type="bibr">Huber <italic>et al.</italic> (2017</xref>) and <xref rid="btz359-B4" ref-type="bibr">Hejase et al. (2018)</xref>. In <xref rid="btz359-B5" ref-type="bibr">Huber <italic>et al.</italic> (2017)</xref>, the authors devised an algorithm that is restricted to combining binet and trinet topologies (no divergence times) into level 1 networks (A phylogenetic network is level 1 if no two cycles in its underlying undirected graphs share a node). The work of <xref rid="btz359-B4" ref-type="bibr">Hejase et al. (2018)</xref> proposed another divide-and-conquer method to infer subnetworks and combine them. However, their method makes use of the subnetwork topologies and requires specifying the number of reticulations <italic>a priori</italic>.</p>
    <p>The divide-and-conquer method we present here is not only designed to be scalable and make possible the inference of large phylogenetic networks, it also makes use of divergence times so that the estimated network has a time scale. It, therefore, represents substantial improvement over the previous likelihood-based methods limited in scalability and previous heuristic or summary methods limited in their utility.</p>
  </sec>
  <sec>
    <title>2 Background</title>
    <p>A <italic>phylogenetic network</italic> Ψ on set <inline-formula id="IE2"><mml:math id="IM2"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula> of taxa is a rooted, directed acyclic graph in which every internal node, except for the root, has in-degree 1 and out-degree 2 (tree node) or in-degree 2 and out-degree 1 (reticulation node). The root has in-degree 0 and out-degree 2, and each leaf has in-degree 1 and out-degree 0. Edges incident into reticulation nodes are the reticulation edges of the network, and all other edges are its tree edges. The leaves of the network are bijectively labeled by the elements of <inline-formula id="IE3"><mml:math id="IM3"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula>.</p>
    <p>For a full probabilistic model, the edges of the network are also associated with continuous parameters as follows. For a given phylogenetic network Ψ, we denote by <inline-formula id="IE4"><mml:math id="IM4"><mml:mrow><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE5"><mml:math id="IM5"><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the network’s nodes, edges and leaf labels, respectively. Each edge <inline-formula id="IE6"><mml:math id="IM6"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE7"><mml:math id="IM7"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> has a length which is defined by the difference of heights of <italic>u</italic> and <italic>v</italic>, which are denoted by <italic>h</italic>(<italic>u</italic>) and <italic>h</italic>(<italic>v</italic>). Each pair of reticulation edges <italic>e</italic> and <inline-formula id="IE8"><mml:math id="IM8"><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> incident into the same reticulation node have inheritance probabilities <italic>γ<sub>e</sub></italic> and <inline-formula id="IE9"><mml:math id="IM9"><mml:mrow><mml:msub><mml:mrow><mml:mo>γ</mml:mo></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> associated with them, which are two non-negative numbers that satisfy <inline-formula id="IE10"><mml:math id="IM10"><mml:mrow><mml:msub><mml:mrow><mml:mo>γ</mml:mo></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mo>γ</mml:mo></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Roughly speaking, <italic>γ<sub>e</sub></italic> denotes the proportion of the genome (in the hybrid population denoted by the relevant reticulation node) that was inherited along edge <italic>e</italic>, and <inline-formula id="IE11"><mml:math id="IM11"><mml:mrow><mml:msub><mml:mrow><mml:mo>γ</mml:mo></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denotes the proportion of the genome that was inherited along edge <inline-formula id="IE12"><mml:math id="IM12"><mml:mrow><mml:mi>e</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>. The network’s topology, branch lengths and inheritance probabilities fully define the MSNC and allows for deriving gene tree probability distributions under ILS and hybridization (<xref rid="btz359-B13" ref-type="bibr">Yu <italic>et al.</italic>, 2012</xref>, <xref rid="btz359-B14" ref-type="bibr">2014</xref>).</p>
    <p>For <inline-formula id="IE13"><mml:math id="IM13"><mml:mrow><mml:mi>x</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow></mml:math></inline-formula>, we denote by <inline-formula id="IE14"><mml:math id="IM14"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE15"><mml:math id="IM15"><mml:mrow><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the sets of nodes and reticulation nodes, respectively, on all paths from the leaf labeled by <italic>x</italic>, or node <italic>x</italic>, to the root of Ψ (<inline-formula id="IE16"><mml:math id="IM16"><mml:mrow><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>). Additionally, we denote <italic>R</italic>(Ψ) to be the set of reticulation nodes in Ψ, with <inline-formula id="IE17"><mml:math id="IM17"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p><italic>Inference under the MSNC model</italic>. The data in phylogenomic inferences involves <italic>m</italic> independent loci (genomic regions) consisting of <inline-formula id="IE18"><mml:math id="IM18"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>S<sub>i</sub></italic> is the sequence data for locus <italic>i</italic>. Most commonly, <italic>S<sub>i</sub></italic> could be an alignment of sequences from each of the species under consideration, or <italic>S<sub>i</sub></italic> is data from a single bi-allelic marker (a vector of 0’s and 1’s), such as a single-nucleotide polymorphism.</p>
    <p>The model consists of Ψ, the phylogenetic network (topology and its continuous parameters such as divergence times), and vector Γ of the inheritance probabilities. The likelihood of the model is given by
<disp-formula id="E1"><mml:math id="M1"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>,</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>G</mml:mi></mml:msub><mml:mi>p</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo>|</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>,</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dg</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where the integration is taken over all possible gene trees, <inline-formula id="IE19"><mml:math id="IM19"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the probability of the sequence alignment <italic>S<sub>i</sub></italic> given a particular gene tree <italic>g</italic> (<xref rid="btz359-B3" ref-type="bibr">Felsenstein, 1981</xref>), and <inline-formula id="IE20"><mml:math id="IM20"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo>|</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>,</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the density of the gene tree (topologies and branch lengths) given the model parameters (<xref rid="btz359-B14" ref-type="bibr">Yu <italic>et al.</italic>, 2014</xref>). The posterior <inline-formula id="IE21"><mml:math id="IM21"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>,</mml:mo><mml:mo>Γ</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the model is proportional to
<disp-formula id="E2"><mml:math id="M2"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>,</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:munderover><mml:mo>∏</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:msub><mml:mo>∫</mml:mo><mml:mi>G</mml:mi></mml:msub><mml:mi>p</mml:mi></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>g</mml:mi><mml:mo>|</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>,</mml:mo><mml:mo>Γ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dg</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>p</italic>(Ψ) and <italic>p</italic>(Γ) are the priors on the phylogenetic network (and its parameters) and the inheritance probabilities, respectively.</p>
    <p>As discussed above, statistical inference methods under this model suffer from the computational complexity of computing the likelihood, and the challenges with exploring the astronomical and jagged space of phylogenetic networks. Next, we describe our method that ameliorates the problem to infer a large network via a two-step approach in which subnetworks are first inferred on smaller datasets of taxa and then the subnetworks are combined to produce the full network.</p>
  </sec>
  <sec>
    <title>3 Materials and Methods</title>
    <p>Our divide-and-conquer approach to large-scale phylogenetic network inference on set <inline-formula id="IE22"><mml:math id="IM22"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula> of taxa takes the following steps:
<list list-type="order"><list-item><p>determine a collection of overlapping subsets <inline-formula id="IE23"><mml:math id="IM23"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of taxa;</p></list-item><list-item><p>for each set <inline-formula id="IE24"><mml:math id="IM24"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of taxa, infer an accurate phylogenetic network Ψ<sub><italic>i</italic></sub> (topology, divergence times and inheritance probabilities) from the sequence data of <inline-formula id="IE25"><mml:math id="IM25"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>;</p></list-item><list-item><p>Combine the <italic>k</italic> subnetworks <inline-formula id="IE26"><mml:math id="IM26"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> into a phylogenetic network on the full set <inline-formula id="IE27"><mml:math id="IM27"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula> of taxa.</p></list-item></list></p>
    <p>A key issue here is that the sets <inline-formula id="IE28"><mml:math id="IM28"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are small enough so that accurate inference methods, such as <xref rid="btz359-B10" ref-type="bibr">Wen and Nakhleh (2018)</xref>, can efficiently and accurately estimate Ψ<sub><italic>i</italic></sub>. In this work, we first show the performance when we consider all <inline-formula id="IE29"><mml:math id="IM29"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> three-taxon subsets, and then propose a technique for reducing this number.</p>
    <p>For <inline-formula id="IE30"><mml:math id="IM30"><mml:mrow><mml:mi>Y</mml:mi><mml:mo>⊆</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow></mml:math></inline-formula>, we denote by <inline-formula id="IE31"><mml:math id="IM31"><mml:mrow><mml:mo>Ψ</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>Y</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> the phylogenetic network restricted to only the leaves labeled by elements of <italic>Y</italic>. We formulate Step (3) in our proposed approach as follows:
<list list-type="bullet"><list-item><p><italic>Input:</italic> Subnetworks <inline-formula id="IE32"><mml:math id="IM32"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> on overlapping sets <inline-formula id="IE33"><mml:math id="IM33"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of taxa.</p></list-item><list-item><p><italic>Output:</italic> Phylogenetic network Ψ with the fewest nodes and edges such that <inline-formula id="IE34"><mml:math id="IM34"><mml:mrow><mml:mo>Ψ</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE35"><mml:math id="IM35"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>.</p></list-item></list></p>
    <p>We now describe an iterative algorithm for this problem of combining subnetworks into a full network. The algorithm proceeds in three steps: (i) reconciling and summarizing the node heights across the subnetworks; (ii) selecting a starting backbone network (a three-taxon network in our case) and an order to add taxon-labeled leaves to it; and (iii) iteratively attaching new leaves (<italic>n −</italic> 3 of them) according to the computed order until a network on the full set of taxa is obtained.</p>
    <sec>
      <title>3.1 Reconciling and summarizing the subnetworks</title>
      <p>Although two nodes in different subnetworks can correspond to the same node in the true network, a degree of uncertainty is associated with the inferred parameters (mainly their heights) of the two nodes and so they will not exactly match. Those inexact heights will mislead a naïve algorithm that treats differences in heights as strictly pertaining to different nodes, therefore, we need to reconcile the parameter estimates in each subnetwork first.</p>
      <p>We construct a set <inline-formula id="IE36"><mml:math id="IM36"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> of disjoint sets of nodes (each node in each subnetwork has its height). Initially,
<disp-formula id="E3"><mml:math id="M3"><mml:mrow><mml:mi mathvariant="script">N</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>{</mml:mo><mml:mi>v</mml:mi><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>}</mml:mo><mml:mo>;</mml:mo></mml:mrow></mml:math></disp-formula>
that is, <inline-formula id="IE37"><mml:math id="IM37"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> is a set of singletons, one for each node in each of the subnetworks. For every pair (<inline-formula id="IE38"><mml:math id="IM38"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) of subnetworks, if <inline-formula id="IE39"><mml:math id="IM39"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, we obtain <inline-formula id="IE40"><mml:math id="IM40"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE41"><mml:math id="IM41"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> by restricting Ψ<sub><italic>i</italic></sub> and Ψ<sub><italic>j</italic></sub> to <inline-formula id="IE42"><mml:math id="IM42"><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. By such a restriction, we have two injective mappings from the nodes of <inline-formula id="IE43"><mml:math id="IM43"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE44"><mml:math id="IM44"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> to their corresponding nodes in <inline-formula id="IE45"><mml:math id="IM45"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE46"><mml:math id="IM46"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, respectively: <inline-formula id="IE47"><mml:math id="IM47"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE48"><mml:math id="IM48"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If <inline-formula id="IE49"><mml:math id="IM49"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE50"><mml:math id="IM50"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> are identical in topology, let <inline-formula id="IE51"><mml:math id="IM51"><mml:mrow><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo>:</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>→</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be a bijection between their node-sets. Then for every node <inline-formula id="IE52"><mml:math id="IM52"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>∈</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we find the two disjoint sets in <inline-formula id="IE53"><mml:math id="IM53"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula> containing <inline-formula id="IE54"><mml:math id="IM54"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE55"><mml:math id="IM55"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and replace these two sets with their union. If <inline-formula id="IE56"><mml:math id="IM56"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE57"><mml:math id="IM57"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> are not identical, we ignore them. In the end, for every node in every disjoint set in <inline-formula id="IE58"><mml:math id="IM58"><mml:mi mathvariant="script">N</mml:mi></mml:math></inline-formula>, we assign the average height of nodes in the same set.</p>
      <p>To summarize the height of each node in each subnetwork, here we introduce the ‘extended height matrix’, or EHM. An EHM <inline-formula id="IE59"><mml:math id="IM59"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub></mml:mrow></mml:math></inline-formula> of a network Ψ with <italic>n</italic> leaves is an <italic>n </italic>×<italic> n</italic> matrix, where element <inline-formula id="IE60"><mml:math id="IM60"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, for taxa <inline-formula id="IE61"><mml:math id="IM61"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is a sorted list of heights of tree nodes, which are common ancestors of <italic>x</italic> and <italic>y</italic> in the binet obtained by restricting Ψ to {<italic>x</italic>, <italic>y</italic>}. We combine <inline-formula id="IE62"><mml:math id="IM62"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> into an EHM <inline-formula id="IE63"><mml:math id="IM63"><mml:mi mathvariant="double-struck">M</mml:mi></mml:math></inline-formula> for the full network as follows. For <inline-formula id="IE64"><mml:math id="IM64"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow></mml:math></inline-formula>, we set <inline-formula id="IE65"><mml:math id="IM65"><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be the longest list among <inline-formula id="IE66"><mml:math id="IM66"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. If there are multiple longest lists, the list with smallest lexicographic rank is chosen. For example, if two longest lists (0.1, 0.2, 0.4, 0.9) and (0.1, 0.2, 0.3, 1.0) exist, the latter is chosen. We also define the ‘pairwise distance sum’, or PDS, for a subnetwork to be the sum of the height of the most recent common ancestor of every pair of taxa in the subnetwork.</p>
    </sec>
    <sec>
      <title>3.2 Generating a starting network and an order for leaf addition</title>
      <p>Here, we describe how (i) a starting backbone network is selected, and (ii) an order for adding all taxa to it is generated. We assume that a designated taxon <italic>z</italic> has been identified <italic>a priori</italic> to be a member of outgroup with at most two members. As this taxon, by definition, is farthest from all ingroup taxa, our task boils down to selecting one of the subnetworks that have <italic>z</italic> as a taxon (when all <inline-formula id="IE67"><mml:math id="IM67"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> trinets are built, there are <inline-formula id="IE68"><mml:math id="IM68"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> trinets that have <italic>z</italic> as a leaf label). We now describe how to choose one of those as the backbone network.</p>
      <p>Let Ψ<sub><italic>i</italic></sub> be a subnetwork whose leaves are labeled by the outgroup taxon <italic>z</italic>, and two other taxa <italic>x</italic> and <italic>y</italic>. We define <inline-formula id="IE69"><mml:math id="IM69"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be 1 if either <italic>x</italic> or <italic>y</italic> is under a reticulation node in any of the <italic>k</italic> subnetworks; otherwise, <inline-formula id="IE70"><mml:math id="IM70"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Furthermore, for two subnetworks <inline-formula id="IE71"><mml:math id="IM71"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE72"><mml:math id="IM72"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we define <inline-formula id="IE73"><mml:math id="IM73"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to be the topological difference (<xref rid="btz359-B7" ref-type="bibr">Nakhleh, 2010</xref>) of their corresponding restrictions to the set <inline-formula id="IE74"><mml:math id="IM74"><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of leaves when <inline-formula id="IE75"><mml:math id="IM75"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, otherwise, <inline-formula id="IE76"><mml:math id="IM76"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. We then take as the backbone network the subnetwork
<disp-formula id="E4"><mml:math id="M4"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>argmin</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where Ψ<sub><italic>i</italic></sub> iterates over all subnetworks that have <italic>z</italic> as a leaf label, and <italic>k</italic> is the number of subnetworks. If there are multiple subnetworks with the same criterion, the subnetwork with largest PDS is chosen.</p>
      <p>Before we add new taxa into the starting backbone, we need to generate an order for attaching new taxa according to the topologies of subnetworks to maximize the correct placement of reticulation nodes. Given two taxa <inline-formula id="IE77"><mml:math id="IM77"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow></mml:math></inline-formula> and a collection <inline-formula id="IE78"><mml:math id="IM78"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of subnetworks, we say that <italic>x</italic> precedes <italic>y</italic>, denoted by <inline-formula id="IE350"><mml:math id="IM79"><mml:mrow><mml:mi>x</mml:mi><mml:munder accentunder="true"><mml:mo>≺</mml:mo><mml:mo>_</mml:mo></mml:munder><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula>, if <inline-formula id="IE79"><mml:math id="IM80"><mml:mrow><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mo>φ</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE80"><mml:math id="IM81"><mml:mrow><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE81"><mml:math id="IM82"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. We build a directed graph whose nodes are the taxa set <inline-formula id="IE82"><mml:math id="IM83"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula>, and edge (<italic>x</italic>, <italic>y</italic>) is in the graph if and only if <inline-formula id="IE351"><mml:math id="IM84"><mml:mrow><mml:mi>x</mml:mi><mml:munder accentunder="true"><mml:mo>≺</mml:mo><mml:mo>_</mml:mo></mml:munder><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula>. Then we perform a topological sorting on the directed graph to get an order of attaching missing taxa. Note that there may be cycles in the directed graph; in such a case, when the topological sorting cannot proceed due to a cycle, we break the cycle by removing node <italic>x</italic> (and its incident edges) that appears under a reticulation node in the largest number of subnetworks. The final result is an order of the elements of <inline-formula id="IE83"><mml:math id="IM85"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula> (minus the three taxa that label the leaves of the backbone network). We create a list of distinct nodes (leaves), each labeled by one taxon, sorted according to the order obtained. The taxa are added to the initial backbone network one at a time according to the computed order. We now describe how each single taxon is added.</p>
    </sec>
    <sec>
      <title>3.3 Iterative attachment of new taxa</title>
      <p>Given the backbone network and the remaining set of taxon-labeled leaves (with their order), we describe how to attach a new taxon to the iteratively growing backbone network. We define the <italic>attachment</italic> of taxon <italic>x</italic> that labels a leaf in subnetwork <inline-formula id="IE84"><mml:math id="IM86"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, denoted by <inline-formula id="IE85"><mml:math id="IM87"><mml:mrow><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, as the set <inline-formula id="IE86"><mml:math id="IM88"><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where
<disp-formula id="E5"><mml:math id="M5"><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mrow><mml:mo>∪</mml:mo></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>≠</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>}</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
and <inline-formula id="IE87"><mml:math id="IM89"><mml:mrow><mml:mi>r</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are parent nodes not in <inline-formula id="IE88"><mml:math id="IM90"><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of all nodes in <inline-formula id="IE89"><mml:math id="IM91"><mml:mrow><mml:mi>i</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The edges of the attachment, denoted by <inline-formula id="IE90"><mml:math id="IM92"><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is the set of all edges of <inline-formula id="IE91"><mml:math id="IM93"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> that connect two nodes in the attachment.</p>
      <p>We add (leaf labeled by) taxon <italic>x</italic> to the current backbone <inline-formula id="IE92"><mml:math id="IM94"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as follows. We first compute <inline-formula id="IE93"><mml:math id="IM95"><mml:mrow><mml:mi>a</mml:mi><mml:msub><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for all <italic>k</italic> subnetworks <inline-formula id="IE94"><mml:math id="IM96"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Assuming there are <inline-formula id="IE95"><mml:math id="IM97"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> subnetworks that have <italic>x</italic> as a leaf label, we cluster the <inline-formula id="IE96"><mml:math id="IM98"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> attachments by their sizes (all attachments with the same number of nodes in <italic>rt</italic> belong to one cluster), and then choose the single attachment per cluster in which the parent node of the leaf labeled by <italic>x</italic> has the smallest height of all attachments in that cluster. In our implementation, we considered only attachments that have up to five nodes in <italic>rt</italic>. Let <italic>H</italic>(<italic>x</italic>) be the set of all resulting attachments (in our implementation, <italic>H</italic>(<italic>x</italic>) contains at most six attachments). For each attachment <inline-formula id="IE97"><mml:math id="IM99"><mml:mrow><mml:mi mathvariant="italic">at</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="italic">it</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mi mathvariant="italic">rt</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:mi>H</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we create a set of new backbone networks as follows:
<list list-type="order"><list-item><p>For each leaf <inline-formula id="IE98"><mml:math id="IM100"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we generate height-taxon pairs, or HT pairs, according to the overall EHM <inline-formula id="IE99"><mml:math id="IM101"><mml:mi mathvariant="double-struck">M</mml:mi></mml:math></inline-formula>. The height of the pair is an element of <inline-formula id="IE100"><mml:math id="IM102"><mml:mrow><mml:mi mathvariant="double-struck">M</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and the taxon of the pair is <inline-formula id="IE101"><mml:math id="IM103"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p><italic>Resolve</italic> HT pairs by finding the set <italic>P</italic> of positions on the path from <inline-formula id="IE102"><mml:math id="IM104"><mml:mrow><mml:mi>x</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> (taxon in the pairs) to the root of <inline-formula id="IE103"><mml:math id="IM105"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> where the height of each element in <italic>P</italic> is the height in the pairs. Map the elements of <italic>rt</italic>(<italic>x</italic>) to the positions in <italic>P</italic> in multiple ways. Remove from all the resulting backbone networks any nodes of in-degree 0 except for the original root of the <inline-formula id="IE104"><mml:math id="IM106"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. (Pseudo-code of this step is given in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>.)</p></list-item><list-item><p>Remove networks with same topology.</p></list-item></list></p>
      <p>The outcome of this procedure, when applied to all attachments in <italic>H</italic>(<italic>x</italic>), is a set of candidate backbone networks <italic>B</italic>(<italic>x</italic>). We then choose from set <italic>B</italic>(<italic>x</italic>) the network <inline-formula id="IE105"><mml:math id="IM107"><mml:mrow><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> whose score is minimum. The score of <inline-formula id="IE106"><mml:math id="IM108"><mml:mrow><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> is defined as follows with respect to each subnetwork <inline-formula id="IE107"><mml:math id="IM109"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>:
<disp-formula id="E6"><mml:math id="M6"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mo>Ψ</mml:mo><mml:mo>″</mml:mo></mml:mrow></mml:msub><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>″</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>d</italic> is the topological distance of <xref rid="btz359-B7" ref-type="bibr">Nakhleh (2010)</xref> applied to two networks restricted to their shared leaf-set, and <inline-formula id="IE108"><mml:math id="IM110"><mml:mrow><mml:mo>Ψ</mml:mo><mml:mo>″</mml:mo></mml:mrow></mml:math></inline-formula> is taken over all subnetworks of <inline-formula id="IE109"><mml:math id="IM111"><mml:mrow><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∩</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> that have <inline-formula id="IE110"><mml:math id="IM112"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> reticulation nodes. We choose <inline-formula id="IE111"><mml:math id="IM113"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> from set <italic>B</italic>(<italic>x</italic>) as the new backbone network on set <inline-formula id="IE112"><mml:math id="IM114"><mml:mrow><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>x</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> of leaves the network <inline-formula id="IE113"><mml:math id="IM115"><mml:mrow><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo></mml:mrow></mml:math></inline-formula> that minimizes
<disp-formula id="E7"><mml:math id="M7"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo>′</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Finally, we reconcile the heights of nodes in <inline-formula id="IE114"><mml:math id="IM116"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> according to subnetworks, by generating a mapping from nodes in <inline-formula id="IE115"><mml:math id="IM117"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> to a set of nodes in the subnetworks, then assign the average of height in each set to the nodes. For inheritance probabilities, we do the same thing for edges in <inline-formula id="IE116"><mml:math id="IM118"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>B</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.4 Asymptotic time complexity</title>
      <p>Here, we provide a loose analysis of asymptotic time complexity of our merger algorithm if all input subnetworks are trinets. Let the total number of taxa be <italic>n</italic>, and let the total number of reticulations in the true network be <italic>r</italic>. Then it takes at most <inline-formula id="IE117"><mml:math id="IM119"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to compute the topological difference (<xref rid="btz359-B7" ref-type="bibr">Nakhleh, 2010</xref>) for two networks which are subnetworks of the true network. Suppose the number of input trinets is <italic>k</italic>. The major time consumption is from the enumeration and evaluation of candidates while attaching new taxa to the growing backbone network.</p>
      <p>Suppose we have <inline-formula id="IE118"><mml:math id="IM120"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="italic">rt</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>≤</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> for all attachment in <italic>H</italic>(<italic>x</italic>). For one attachment, there will be at most <inline-formula id="IE119"><mml:math id="IM121"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo>!</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>m</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> new backbone networks. In our implementation, we set <italic>m</italic> to 5, which makes the number of candidates <inline-formula id="IE120"><mml:math id="IM122"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>5</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Note that there are far fewer candidates, as demonstrated by our simulation study. A loose upper bound on the time complexity for computing the score for a candidate is <inline-formula id="IE121"><mml:math id="IM123"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msup><mml:mi>k</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>The total asymptotic time complexity of our merger algorithm is <inline-formula id="IE122"><mml:math id="IM124"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>5</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msup><mml:mi>k</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mn>3</mml:mn></mml:mrow><mml:mi>r</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>7</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.5 Reducing the number of subproblems</title>
      <p>The first step of our method requires inferring a phylogenetic network for every combination of three taxa, and this causes the computational complexity of subnetwork inference to be <inline-formula id="IE123"><mml:math id="IM125"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> given <italic>n</italic> total taxa. If there are 100 taxa, the number of subnetworks to infer will be <inline-formula id="IE124"><mml:math id="IM126"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>100</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>161</mml:mn><mml:mo>,</mml:mo><mml:mn>700</mml:mn></mml:mrow></mml:math></inline-formula>, which is an overwhelmingly large number for researchers who do not have access to the largest supercomputers. Therefore, it is important to reduce the number of subnetworks by precomputing which subnetworks are actually needed.</p>
      <p>Let <italic>g</italic> be a rooted, binary phylogenetic tree leaf-labeled by set <inline-formula id="IE125"><mml:math id="IM127"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula> of taxa. For a node <italic>u</italic> in <italic>g</italic>, we denote by <italic>L</italic>(<italic>u</italic>) the set <inline-formula id="IE126"><mml:math id="IM128"><mml:mrow><mml:mi>X</mml:mi><mml:mo>′</mml:mo><mml:mo>⊆</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula> that labels the leaves of <italic>g</italic> that are under node <italic>u</italic>. Consider an internal edge <inline-formula id="IE127"><mml:math id="IM129"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic>g</italic> (that is, an edge that is not incident with a leaf). Let <italic>v</italic><sub>1</sub> and <italic>v</italic><sub>2</sub> be the two children of <italic>v</italic>, and let <italic>u</italic><sub>1</sub> be the child of <italic>u</italic> that is not <italic>v</italic>. We say that edge <italic>e</italic> is defined by the set <inline-formula id="IE128"><mml:math id="IM130"><mml:mrow><mml:mo>{</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> (i.e. it is a set of three sets of leaf labels). Finally, we say that a triplet of leaf labels <inline-formula id="IE129"><mml:math id="IM131"><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>}</mml:mo><mml:mo>⊆</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi></mml:mrow></mml:math></inline-formula><italic>covers</italic> edge <italic>e</italic> if
<disp-formula id="E8"><mml:math id="M8"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>∈</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>The algorithm we propose for reducing the number of subproblems to solve on a dataset of <italic>m</italic> loci is as follows:
<list list-type="order"><list-item><p>Let <inline-formula id="IE130"><mml:math id="IM132"><mml:mi mathvariant="double-struck">G</mml:mi></mml:math></inline-formula> be a set of <italic>m</italic> estimated gene trees, and denote by <inline-formula id="IE131"><mml:math id="IM133"><mml:mrow><mml:mi mathvariant="normal">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> the set of all internal edges in the gene trees in <inline-formula id="IE132"><mml:math id="IM134"><mml:mi mathvariant="normal">G</mml:mi></mml:math></inline-formula>.</p></list-item><list-item><p>Compute a smallest set <inline-formula id="IE133"><mml:math id="IM135"><mml:mrow><mml:mo>Δ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>}</mml:mo><mml:mo>:</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub><mml:mo>}</mml:mo><mml:mo>⊆</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> such that each edge <inline-formula id="IE134"><mml:math id="IM136"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is covered by at least one element of Δ.</p></list-item><list-item><p>Infer <inline-formula id="IE135"><mml:math id="IM137"><mml:mrow><mml:mo>|</mml:mo><mml:mo>Δ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> trinets, one for each element of Δ.</p></list-item></list></p>
      <p>We show how computing set Δ can be posed as an instance of the Hitting Set Problem, which allows one to make use of many existing algorithmic developments for this problem. The Hitting Set Problem is defined as follows:
<list list-type="bullet"><list-item><p><italic>Input:</italic> A collection <italic>C</italic> of subsets of <italic>S</italic>.</p></list-item><list-item><p><italic>Output:</italic> Smallest subset <inline-formula id="IE136"><mml:math id="IM138"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> that intersects every set in <italic>C</italic>.</p></list-item></list></p>
      <p>To pose our problem of finding a smallest set of three-taxon subproblems as an instance of the Hitting Set Problem, we define:
<list list-type="bullet"><list-item><p><italic>S</italic> is the set of all <inline-formula id="IE137"><mml:math id="IM139"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> three-taxon subsets of <inline-formula id="IE138"><mml:math id="IM140"><mml:mi mathvariant="double-struck">X</mml:mi></mml:math></inline-formula>.</p></list-item><list-item><p>Let edge <inline-formula id="IE139"><mml:math id="IM141"><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> be defined by the set {<italic>A</italic>, <italic>B</italic>, <italic>C</italic>} of three sets of taxa, as described in the main text. We create set <inline-formula id="IE140"><mml:math id="IM142"><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>}</mml:mo><mml:mo>:</mml:mo><mml:mi>a</mml:mi><mml:mo>∈</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>∈</mml:mo><mml:mi>B</mml:mi><mml:mo>,</mml:mo><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mi>C</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Then,
<disp-formula id="E9"><mml:math id="M9"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>∪</mml:mo></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="normal">E</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">G</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo>}</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p></list-item></list></p>
      <p>Finding a smallest subset <inline-formula id="IE141"><mml:math id="IM143"><mml:mrow><mml:mi>S</mml:mi><mml:mo>′</mml:mo><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:math></inline-formula> amounts to finding the smallest set of three-taxon sets on which to infer trinets.</p>
      <p>For certain networks (that are automatically identified by the algorithm), the smallest set Δ of trinets needs to be enriched with additional trinets that are identified in multiple rounds, a step that we discuss and describe in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>, along with the heuristic we implemented for solving the aforementioned problem.</p>
    </sec>
  </sec>
  <sec>
    <title>4 Results and discussion</title>
    <p>The way we ran our method is as follows: For each subproblem, MCMC_SEQ (<xref rid="btz359-B10" ref-type="bibr">Wen and Nakhleh, 2018</xref>) was run and a sample of subnetworks was collected from the posterior. We then selected one subnetwork randomly from the samples of each subset, and applied our merger algorithm. This step was repeated 100 times, and resulted in 100 candidate networks on the full set of taxa. We selected the final network as follows: if a network topology appeared in two-thirds or more of the 100 networks, it was selected as the final result; otherwise, we identify the most common topology for each of the subnetwork distributions from MCMC_SEQ. Then, we select the network which maximizes the number of subnetworks, contained in that network, which match those topologies. The parameters of the final network are averaged from the networks with same topology.</p>
    <p>Since our algorithm for combining subnetworks into a network on the full set of taxa is a heuristic with no established theoretical guarantees, we first set out to study its accuracy on a large number of networks. We then studied the performance of our full approach on simulated multilocus datasets, and finally analyzed a biological dataset.</p>
    <sec>
      <title>4.1 Accuracy of the merger algorithm</title>
      <p>We generated 10 000 16-taxon networks using a birth-hybridization model, and for each network, an outgroup was added to create a 17-taxon network. We restricted each of the 10 000 17-taxa networks to every combination of three taxa to produce <inline-formula id="IE142"><mml:math id="IM144"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>17</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>680</mml:mn></mml:mrow></mml:math></inline-formula> trinets that were used as input to our merger algorithm that combines the trinets into a network on the full set of taxa. We then inspected the accuracy of the resulting networks. <xref ref-type="fig" rid="btz359-F1">Figure 1</xref> shows the number of datasets on which the merger algorithm inferred the correct network with 10 000 17-taxon networks. As <xref ref-type="fig" rid="btz359-F1">Figure 1</xref> shows, in total, 9838 out of 10 000 inferred networks are identical to their corresponding true networks. When the true network had 0 or 1 reticulations, the algorithm always returned the correct network. Furthermore, the few cases where an incorrect network was returned mostly correspond to large numbers of reticulations (even in those cases, the computed network was very similar to the true one).
</p>
      <fig id="btz359-F1" orientation="portrait" position="float">
        <label>Fig. 1.</label>
        <caption>
          <p>Correctness of inferred networks from correct trinets, categorized by the number of reticulations in the true networks. The numbers of datasets on which the inferred network is identical to or different from the true one are shown in blue and orange, respectively</p>
        </caption>
        <graphic xlink:href="btz359f1"/>
      </fig>
      <p>To examine the performance of the merger algorithm with and without reduced number of subproblems for large networks, we generated 100 41-taxon networks and 81-taxon networks using a birth-hybridization model (each network had a designated outgroup that did not involve hybridization with any other taxa). We simulated 1000 gene trees within the branches of each network, using the program ms (<xref rid="btz359-B6" ref-type="bibr">Hudson, 2002</xref>), and generated the full set of all true trinets as well as subset obtained by our algorithm for reducing the number of trinets. We used each set of trinets as input to our merger algorithm. We inspected the accuracy in terms of whether the inferred network is identical to the true network. The results, as well as other characteristics of the data, are shown in <xref rid="btz359-T1" ref-type="table">Table 1</xref>. When the full set of trinets was used as input, all trinets were inferred in parallel in a single batch. When the reduced set of trinets was used as input, the first batch always consists of the set of reduced trinets being inferred in parallel. However, as we discussed above, in some cases, multiple rounds of enrichment of the reduced set of trinets are performed. Each such round corresponds to an addition batch where all new trinets in that round are inferred in parallel.</p>
      <table-wrap id="btz359-T1" orientation="portrait" position="float">
        <label>Table 1.</label>
        <caption>
          <p>Results of merger algorithm for large networks</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="left" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">
                <italic>N</italic>
              </th>
              <th align="left" rowspan="1" colspan="1">Quantity</th>
              <th align="left" rowspan="1" colspan="1">Full</th>
              <th align="left" rowspan="1" colspan="1">Reduced</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">41</td>
              <td rowspan="1" colspan="1">Number of trinets</td>
              <td rowspan="1" colspan="1">10 660</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE143">
                  <mml:math id="IM145">
                    <mml:mrow>
                      <mml:mn>151</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>386</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Number of batches</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE144">
                  <mml:math id="IM146">
                    <mml:mrow>
                      <mml:mn>1</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>6</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Candidates enumerated</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE145">
                  <mml:math id="IM147">
                    <mml:mrow>
                      <mml:mn>39</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>225</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE146">
                  <mml:math id="IM148">
                    <mml:mrow>
                      <mml:mn>39</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>228</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Accuracy</td>
              <td rowspan="1" colspan="1">98%</td>
              <td rowspan="1" colspan="1">83%</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Average running time (s)</td>
              <td rowspan="1" colspan="1">50.93</td>
              <td rowspan="1" colspan="1">3.57</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">81</td>
              <td rowspan="1" colspan="1">Number of trinets</td>
              <td rowspan="1" colspan="1">85 320</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE147">
                  <mml:math id="IM149">
                    <mml:mrow>
                      <mml:mn>347</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>772</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Number of batches</td>
              <td rowspan="1" colspan="1">1</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE148">
                  <mml:math id="IM150">
                    <mml:mrow>
                      <mml:mn>2</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>9</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Candidates enumerated</td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE149">
                  <mml:math id="IM151">
                    <mml:mrow>
                      <mml:mn>80</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>155</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
              <td rowspan="1" colspan="1">
                <inline-formula id="IE150">
                  <mml:math id="IM152">
                    <mml:mrow>
                      <mml:mn>80</mml:mn>
                      <mml:mo>∼</mml:mo>
                      <mml:mn>150</mml:mn>
                    </mml:mrow>
                  </mml:math>
                </inline-formula>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Accuracy</td>
              <td rowspan="1" colspan="1">100%</td>
              <td rowspan="1" colspan="1">88%</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1"/>
              <td rowspan="1" colspan="1">Average running time (s)</td>
              <td rowspan="1" colspan="1">1077.16</td>
              <td rowspan="1" colspan="1">10.90</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic>Note:</italic> Full and reduced correspond to the full set of trinets and the reduced set of trinets, and <italic>n</italic> is the number of leaves in the network. Each batch consists of multiple trinet inferences that are all run in parallel. ‘Candidates enumerated’ is the number of new backbone networks that are proposed and examined by the algorithm during the full network construction. Accuracy is measured as the percentage of datasets in which the constructed network is identical to the true network. The average running time in seconds is the time it took to construct the full network from the set of trinets.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>The table shows several important points. The algorithm achieves almost perfect accuracy on the 41-taxon networks, and perfect accuracy on the 81-taxon networks, when the full set of trinets is used. Our heuristic for reducing the number of trinets achieves two orders of magnitude reduction in the number of trinets, resulting in one or two orders of magnitude reduction in the running time. The accuracy decreases when the reduced set of trinets is used, since some information on the full network is lost by this reduction. We identify the problem of obtaining a better reduced set of trinets as a direction for future research.</p>
      <p>One reason the algorithm performs better on the larger networks (81-taxon networks) is that for a fixed number of reticulations, those reticulations would be sparser on a network with 81 taxa than on a network with 41 taxa, making the inference of the former less challenging. <xref ref-type="fig" rid="btz359-F2">Figure 2</xref> breaks the accuracy results of our algorithm on the 41- and 81-taxon networks by the number of reticulations in these networks.
</p>
      <fig id="btz359-F2" orientation="portrait" position="float">
        <label>Fig. 2.</label>
        <caption>
          <p>Correctness of inferred networks from correct trinets, categorized by the number of reticulations in the true networks. (<bold>a</bold>) Results from 100 41-taxon networks. (<bold>b</bold>) Results from 100 81-taxon networks. Blue: the number of cases where the inferred network is identical to the true one when using either the full or reduced set of trinets. Orange: the number of cases where the inferred network is identical to the true one only when the full, but not reduced, set of trinets is used. Grey: the number of cases where the inferred network is different from the true one, regardless of whether the full or reduced set of trinets was used</p>
        </caption>
        <graphic xlink:href="btz359f2"/>
      </fig>
    </sec>
    <sec>
      <title>4.2 Accuracy on simulated multilocus datasets</title>
      <p>We now set out to study the performance of our approach on simulated multilocus sequence data, where the method is applied to the sequence data directly. Given that computational complexity of Bayesian inference of trinets (<xref rid="btz359-B10" ref-type="bibr">Wen and Nakhleh, 2018</xref>), we focus our attention here on a subset of 24 phylogenetic networks that we sampled to reflect varying complexity levels. As discussed in (<xref rid="btz359-B2" ref-type="bibr">Elworth <italic>et al.</italic>, 2019</xref>; <xref rid="btz359-B19" ref-type="bibr">Zhu <italic>et al.</italic>, 2016</xref>), the complexity of phylogenetic networks arises not only from the number of leaves or number of reticulation nodes, but also in how the reticulation nodes are structured in the network. To allow for a careful assessment of the accuracy of our approach, we define a simple complexity measure of networks as follows. We define the complexity of Ψ as <inline-formula id="IE151"><mml:math id="IM153"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="double-struck">X</mml:mi><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mo>Ψ</mml:mo></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>L</italic>(<italic>u</italic>) is the set of leaves under node <italic>u</italic>, <inline-formula id="IE152"><mml:math id="IM154"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE153"><mml:math id="IM155"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are the two parents of reticulation node <italic>u</italic>.</p>
      <p>We selected the 24 networks from the 10 000 as follows. All simulated networks with 0 to 5 reticulation nodes were sorted by their complexities. For each of the six numbers of reticulation nodes, we selected four networks: the one with the minimum complexity, the one with the maximum complexity, and the two networks at tertiles. The 24 networks were divided into three groups of 8 ‘easy’ networks (E), 8 ‘medium-difficulty’ networks (M), and 8 ‘hard’ networks (H), and are shown in the <xref ref-type="supplementary-material" rid="sup1">Supplementary Material</xref>. We used these 24 networks as the ground truth and simulated multilocus sequence from these 24 networks.</p>
      <p>For each of the 24 networks, we generated the full set of all true trinets as well as subset obtained by our algorithm for reducing the number of trinets. Then, for each set of trinets (full or reduced), we perturbed the heights of the nodes in each trinet randomly by 0.1% and repeated this 100 times to obtain 100 ‘ideal’ MCMC-like samples of trinets. We then used the trinet sets as inputs to our merger algorithm and inspected the resulting networks. The algorithm obtained the correct networks in all 24 cases regardless of whether the full or reduced set of trinet ‘samples’ were used. While this result is perfect, Bayesian MCMC in practice is not guaranteed to yield as accurate a sample as the one we used here. Therefore, we next set out to study the performance of the method when we use sequence data of the multiple loci.</p>
      <p>For each of the 24 networks, we simulated 100 gene trees, with two individuals per species, for 100 loci using the program ms (<xref rid="btz359-B6" ref-type="bibr">Hudson, 2002</xref>), and generated sequence alignments of length 1000 for each locus using Seq-gen (<xref rid="btz359-B9" ref-type="bibr">Rambaut and Grassly, 1997</xref>) under GTR model. In other words, each locus consists of 34 aligned sequences. For each dataset, we inferred subnetworks using MCMC-SEQ (<xref rid="btz359-B10" ref-type="bibr">Wen and Nakhleh, 2018</xref>) as implemented in PhyloNet (<xref rid="btz359-B12" ref-type="bibr">Wen <italic>et al.</italic>, 2018</xref>) with <inline-formula id="IE154"><mml:math id="IM156"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> iterations, <inline-formula id="IE155"><mml:math id="IM157"><mml:mrow><mml:mn>1</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> burn-in iterations, and one sample collected per <inline-formula id="IE156"><mml:math id="IM158"><mml:mrow><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mrow><mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:math></inline-formula> iterations. To obtain the first state for the method, we inferred gene trees for the individual loci using IQ-TREE (<xref rid="btz359-B8" ref-type="bibr">Nguyen <italic>et al.</italic>, 2015</xref>), optimized their branch lengths using local search, and the resulting gene trees were used as the starting gene trees in the MCMC chain.</p>
      <p>For each dataset, the running time to infer all trinets is shown in <xref ref-type="fig" rid="btz359-F3">Figure 3(a)</xref>. This analysis was performed on NOTS (Night Owls Time-Sharing Service), which is a batch scheduled High-Throughput Computing (HTC) cluster. The average cost to infer all trinets for a dataset was 1636.82 CPU-hours, which means it takes about an hour to infer a trinet with a dual-core machine. Since the inferences of trinet are independent of each other, this task is embarrassingly parallel. <xref ref-type="fig" rid="btz359-F3">Figure 3(b)</xref> shows the accuracy of the inferred trinets. The figure shows that the more complex the true network, the harder it is to infer their subnetworks.
</p>
      <fig id="btz359-F3" orientation="portrait" position="float">
        <label>Fig. 3.</label>
        <caption>
          <p>Running times and accuracy for the inferred trinets. (<bold>a</bold>) The total running time in CPU-hours to infer all trinets for each dataset. (<bold>b</bold>) Accuracy of the inferred trinets. The number of datasets where the inferred trinet is correct (blue), the inferred trinet is inside the true network (orange) and all other cases (grey), are shown</p>
        </caption>
        <graphic xlink:href="btz359f3"/>
      </fig>
      <p>We then used the inferred trinets as input to our merger algorithm. The merger algorithm ran on a Macbook Pro with 2.9 GHz Intel Core i5. We used both the full and reduced sets of inferred trinets. The reduced sets contains between 61 and 132 trinets, which is a major reduction (especially when considering the running time, as shown in <xref ref-type="fig" rid="btz359-F3">Figure 3(a)</xref>) over the full set, which contains 680 subnetworks. Most datasets only need one batch of inference, three datasets need two batches, and one dataset needs three batches. The time that our algorithm took to merge the trinets into a full network (repeated 100 times) ranged between 148 and 1538 s when the full set of trinets was used, and between 44 and 141 s when the reduced set of trinets was used. This shows the additional efficiency gained by reducing the number of trinets.</p>
      <p>Finally, we fed the full and reduced sets of trinets to our merger algorithm and compared the inferred networks to the true ones. In measuring the difference between a true network <inline-formula id="IE157"><mml:math id="IM159"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and an inferred network <inline-formula id="IE158"><mml:math id="IM160"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we quantified false positive and false negative rates as follows. We find the backbone <inline-formula id="IE159"><mml:math id="IM161"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE160"><mml:math id="IM162"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and backbone <inline-formula id="IE161"><mml:math id="IM163"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE162"><mml:math id="IM164"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> whose topological differences (<xref rid="btz359-B7" ref-type="bibr">Nakhleh, 2010</xref>) are smallest and have the largest number of reticulation nodes among all such pairs of backbones. If the topological difference is 0, the inferred network has a backbone inside the true network. We compute the true positives as the number of nodes remaining in <inline-formula id="IE163"><mml:math id="IM165"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, minus the topological difference of <inline-formula id="IE164"><mml:math id="IM166"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE165"><mml:math id="IM167"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. We compute the false positives as the number of nodes deleted from <inline-formula id="IE166"><mml:math id="IM168"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE167"><mml:math id="IM169"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, plus the topological difference of <inline-formula id="IE168"><mml:math id="IM170"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE169"><mml:math id="IM171"><mml:mrow><mml:msubsup><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>. The false negative rate is computed by normalizing the true positives by the number of nodes in <inline-formula id="IE170"><mml:math id="IM172"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and subtracting it from 1, and the false positive rate is computed by normalizing the false positives by the number of nodes in <inline-formula id="IE171"><mml:math id="IM173"><mml:mrow><mml:msub><mml:mrow><mml:mo>Ψ</mml:mo></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
      <p>The inferred network was identical to the true network in 12 out of 24 datasets when full set of trinets were used. When the reduced set of trinets was used, nine inferred networks were identical to their corresponding true networks. We plot the false positives and false negatives for the datasets where the inferred network is not identical to the true one in <xref ref-type="fig" rid="btz359-F4">Figure 4(a)</xref>. As the results show, not much accuracy is lost when using the reduced set of trinets. In particular, for four datasets, the false negative rate when using the full set of trinets is higher than its counterpart when using the reduced set. On the other hand, more networks inferred from the reduced set have slightly higher false positive rates. It is important to note here that these results combined with the fact that all 24 inferred networks are completely accurate when using error-free trinets shows that the error in the final networks is mainly due to inaccuracy of the trinets, rather than the merger algorithm.
</p>
      <fig id="btz359-F4" orientation="portrait" position="float">
        <label>Fig. 4.</label>
        <caption>
          <p>Accuracy of the inferred networks, and comparison to maximum pseudo-likelihood. (<bold>a</bold>) The false positives and false negatives for the datasets where the inferred network is not identical to the true network. Squares correspond to hard networks, crosses correspond to medium-difficulty networks and triangles correspond to easy networks. Blue, red and green correspond to results based on the full and reduced sets of trinets, and maximum pseudo-likelihood, respectively. (<bold>b</bold>) The accuracy of our method on the full set of trinets (left set of bars) and on the reduced set of trinets (middle set of bars), and the accuracy of maximum pseudo-likelihood (right set of bars). Blue corresponds to the datasets where the inferred network is identical to the true network; orange corresponds to the datasets where the inferred network contains a backbone network that is present in the true network; grey corresponds to all other cases</p>
        </caption>
        <graphic xlink:href="btz359f4"/>
      </fig>
      <p>Finally, we compare the accuracy of the method to the only other statistical inference method that can scale to these datasets, namely maximum pseudo-likelihood (<xref rid="btz359-B15" ref-type="bibr">Yu and Nakhleh, 2015</xref>). As the method of <xref rid="btz359-B15" ref-type="bibr">Yu and Nakhleh (2015)</xref> requires gene trees as input, we ran it on the gene trees inferred by IQ-TREE, with the maximum number of reticulations set to 5 and the number of runs set to 20. <xref ref-type="fig" rid="btz359-F4">Figure 4(b)</xref> shows the results of this comparison. These results clearly show that our approach here outperforms maximum pseudo-likelihood, and there could be several explanations for this. First, maximum pseudo-likelihood is not good at estimating the correct number of reticulations, so it could be that the networks obtained by the method have unnecessary reticulation nodes. Second, maximum pseudo-likelihood searches the network space and could get stuck in local maxima, whereas our proposed approach here avoids such a search. It is important to also comment on the decreased accuracy of our approach when using a reduced set of trinets. As the set of trinets is much smaller than the full set, the method becomes more sensitive to inaccuracy in the inferred trinets, since when using the full set of trinets, signal from multiple trinets could mask the estimation error. All these results combined show that our proposed approach can produce very accurate results, especially when the individual trinets are accurately estimated.</p>
    </sec>
    <sec>
      <title>4.3 Inference on an empirical dataset</title>
      <p>We analyzed a dataset of multilocus sequence alignments of multiple Australian rainbow skinks (<xref rid="btz359-B1" ref-type="bibr">Bragg et al., 2018</xref>), where 11 taxa with 22 individuals were selected from the full dataset. At first we computed the maximum pairwise distance of each locus using IQ-TREE (<xref rid="btz359-B8" ref-type="bibr">Nguyen <italic>et al.</italic>, 2015</xref>), and we excluded the loci with maximum pairwise distance larger than 0.2, as that would imply impossible deep coalescence times. We then randomly selected 100 loci and used their sequence alignments as the input.</p>
      <p>The first step of our method is inferring subnetworks. So we restricted the dataset with 11 taxa to every combination of three taxa, then we added <italic>Lampropholis guichenoti</italic> into every subproblem to root the subnetworks. Therefore, for every subproblem, four-taxon networks were inferred and the number of subproblems remains <inline-formula id="IE172"><mml:math id="IM174"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>11</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>3</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>120</mml:mn></mml:mrow></mml:math></inline-formula>. We ran MCMC-SEQ (<xref rid="btz359-B10" ref-type="bibr">Wen and Nakhleh, 2018</xref>) for 6 000 000 iterations with 3 000 000 burn-in steps, collecting a sample for every 5000 iterations. We inferred gene trees using IQ-TREE (<xref rid="btz359-B8" ref-type="bibr">Nguyen <italic>et al.</italic>, 2015</xref>), and their branch lengths were optimized individually using local search. The resulting gene trees were used as the starting point of MCMC chain, and all gene tree topologies were fixed during Bayesian sampling. This analysis was performed on NOTS (Night Owls Time-Sharing Service). We used two CPU cores running at 2.6 GHz, and 8G RAM for each subproblem. It took 3670 CPU-hours to infer all subnetworks. Then we used the inferred subnetworks as the input to our merger algorithm to merge them on a Macbook Pro with 2.9 GHz Intel Core i5. It took 53.1 s to merge the subnetworks and generate the final result. The inferred network is shown in <xref ref-type="fig" rid="btz359-F5">Figure 5</xref>. The ingroup result agrees with the known analysis of this dataset. The topological relationships of the <italic>Carlia</italic> clade and the <italic>Lygisaurus</italic> clade are identical to <xref ref-type="fig" rid="btz359-F2">Figure 2</xref> in <xref rid="btz359-B1" ref-type="bibr">Bragg et al. (2018)</xref>.
</p>
      <fig id="btz359-F5" orientation="portrait" position="float">
        <label>Fig. 5.</label>
        <caption>
          <p>The inferred network for the empirical dataset. The reticulation, with inheritance probabilities (blue), is shown by the dashed line</p>
        </caption>
        <graphic xlink:href="btz359f5"/>
      </fig>
      <p>For comparison, we also ran the maximum pseudo-likelihood method of <xref rid="btz359-B15" ref-type="bibr">Yu and Nakhleh (2015)</xref> on this dataset, using the inferred gene trees as the input. The number of runs was set to 10. The number of reticulations allowed was set to 0, 1 and 2. The inferred networks are shown in <xref ref-type="fig" rid="btz359-F6">Figure 6</xref>. The inferred species tree was identical to the backbone tree in the inferred network using our merger algorithm. However, that is no longer the case when reticulations are added by the method.
</p>
      <fig id="btz359-F6" orientation="portrait" position="float">
        <label>Fig. 6.</label>
        <caption>
          <p>The inferred networks for the empirical dataset using maximum pseudo-likelihood. Top: the inferred network when no reticulation was allowed. Middle: the inferred network when one reticulation was allowed. Bottom: the inferred network when two reticulations were allowed. The reticulations, with inheritance probabilities (blue), are shown by the dashed lines</p>
        </caption>
        <graphic xlink:href="btz359f6"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>5 Conclusions and future work</title>
    <p>In this article, we proposed a divide-and-conquer approach for large-scale phylogenetic network inference. The approach makes use of inferred subnetworks—topologies and divergence times—on overlapping subsets of the taxa to obtain a phylogenetic network on the full dataset. We demonstrated the accuracy and efficiency of our approach on simulated and biological datasets.</p>
    <p>While we illustrated the performance of the algorithm on subproblems of size 3 (three taxa), the merger algorithm we introduced works on subnetworks with any number of taxa. There is a tradeoff between the size of the subproblems, the running time, and the accuracy. If the number of taxa in the full dataset is <italic>n</italic>, then the full set of subnetworks on <italic>k</italic> leaves consists of <inline-formula id="IE173"><mml:math id="IM175"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>n</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>k</mml:mi></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For example, for <italic>n </italic>=<italic> </italic>100 and <italic>k </italic>=<italic> </italic>5, the algorithm would have to infer on the order of 10<sup>10</sup> five-subnetworks. Not only is this number large by itself, but the inference of each five-subnetwork is much more demanding computationally than that of trinets.</p>
    <p>Two bottlenecks of the method are the number of subproblems to analyze, and the time it takes to infer a subnetwork on each subproblem using compute-heavy approaches such as Bayesian inference. To address the former, we introduced a formulation for reducing the number of subproblems to solve and demonstrated its effect on the efficiency and accuracy of the obtained results. However, our solution is a heuristic, and via our reduction of the problem to the Hitting Set Problem, one future direction is to explore the efficiency and accuracy of Hitting Set algorithms. For the latter bottleneck, and while subnetworks can be inferred in parallel on the subproblems, it is important to develop new techniques for accurate estimation of small networks—topologies and divergence times, as these are both used in our approach. Last but not least, while the efficiency of the merger algorithm could be improved, our analyses above show that the two aforementioned bottlenecks are the more important targets for further improvement.</p>
    <p>Finally, it is worth mentioning that our merger algorithm makes no assumption on what evolutionary processes were accounted for in the subnetwork inference. In this sense, our merger algorithm can be applied to merge subnetworks inferred under a variety of models (e.g. ILS, gene duplication and loss, and hybridization), as long as the subnetworks’ topologies and divergence times are accurately estimated.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported in part by NSF [DBI-1355998, CCF-1302179, CCF-1514177, CCF-1800723, and DMS-1547433]. This work was supported in part by the Big-Data Private-Cloud Research Cyberinfrastructure MRI-award funded by NSF under grant CNS-1338099 and by Rice University.</p>
    <p><italic>Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material content-type="local-data" id="sup1">
      <label>btz359_Supplementary_Data</label>
      <media xlink:href="btz359_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btz359-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bragg</surname><given-names>J.G.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Phylogenomics of a rapid radiation: the Australian rainbow skinks</article-title>. <source>BMC Evol. Biol</source>., <volume>18</volume>, <fpage>15.</fpage><pub-id pub-id-type="pmid">29402211</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B2">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><name name-style="western"><surname>Elworth</surname><given-names>R.L.</given-names></name></person-group><etal>et al</etal> (<year>2019</year>) Advances in computational methods for phylogenetic networks in the presence of hybridization. In: Warnow,T. (ed.) <source>Bioinformatics and Phylogenetics</source>, pp. <fpage>317</fpage>–<lpage>360</lpage>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btz359-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Felsenstein</surname><given-names>J.</given-names></name></person-group> (<year>1981</year>) 
<article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach</article-title>. <source>J. Mol. Evol</source>., <volume>17</volume>, <fpage>368</fpage>–<lpage>376</lpage>.<pub-id pub-id-type="pmid">7288891</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><name name-style="western"><surname>Hejase</surname><given-names>H.A.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) <chapter-title>Fastnet: fast and accurate statistical inference of phylogenetic networks using large-scale genomic sequence data</chapter-title> In: Blanchette,M. and Ouangraoua,A. (eds) <source>Comparative Genomics.</source> RECOMB-CG 2018. Lecture Notes in Computer Science, vol 11183. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btz359-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Huber</surname><given-names>K.T.</given-names></name></person-group><etal>et al</etal> (<year>2017</year>) 
<article-title>Reconstructing phylogenetic level-1 networks from nondense binet and trinet sets</article-title>. <source>Algorithmica</source>, <volume>77</volume>, <fpage>173</fpage>–<lpage>200</lpage>.</mixed-citation>
    </ref>
    <ref id="btz359-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Hudson</surname><given-names>R.R.</given-names></name></person-group> (<year>2002</year>) 
<article-title>Generating samples under a Wright-Fisher neutral model of genetic variation</article-title>. <source>Bioinformatics</source>, <volume>18</volume>, <fpage>337</fpage>–<lpage>338</lpage>.<pub-id pub-id-type="pmid">11847089</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2010</year>) 
<article-title>A metric on the space of reduced phylogenetic networks</article-title>. <source>IEEE/ACM Trans. Comput. Biol. Bioinform</source>., <volume>7</volume>, <fpage>218</fpage>–<lpage>222</lpage>.<pub-id pub-id-type="pmid">20431142</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Nguyen</surname><given-names>L.T.</given-names></name></person-group><etal>et al</etal> (<year>2015</year>) 
<article-title>IQ-TREE: a fast and effective stochastic algorithm for estimating maximum-likelihood phylogenies</article-title>. <source>Mol. Biol. Evol</source>., <volume>32</volume>, <fpage>268</fpage>–<lpage>274</lpage>.<pub-id pub-id-type="pmid">25371430</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Rambaut</surname><given-names>A.</given-names></name>, <name name-style="western"><surname>Grassly</surname><given-names>N.C.</given-names></name></person-group> (<year>1997</year>) 
<article-title>Seq-gen: an application for the Monte Carlo simulation of DNA sequence evolution along phylogenetic trees</article-title>. <source>Comp. Appl. Biosci</source>., <volume>13</volume>, <fpage>235</fpage>–<lpage>238</lpage>.<pub-id pub-id-type="pmid">9183526</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wen</surname><given-names>D.</given-names></name>, <name name-style="western"><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Co-estimating reticulate phylogenies and gene trees from multi-locus sequence data</article-title>. <source>Syst. Biol</source>., <volume>67</volume>, <fpage>439</fpage>–<lpage>457</lpage>.<pub-id pub-id-type="pmid">29088409</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wen</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>Bayesian inference of reticulate phylogenies under the multispecies network coalescent</article-title>. <source>PLoS Genet</source>., <volume>12</volume>, <fpage>e1006006.</fpage><pub-id pub-id-type="pmid">27144273</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wen</surname><given-names>D.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Inferring phylogenetic networks using PhyloNet</article-title>. <source>Syst. Biol</source>., <volume>67</volume>, <fpage>735</fpage>–<lpage>740</lpage>.<pub-id pub-id-type="pmid">29514307</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yu</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2012</year>) 
<article-title>The probability of a gene tree topology within a phylogenetic network with applications to hybridization detection</article-title>. <source>PLoS Genet</source>., <volume>8</volume>, <fpage>e1002660.</fpage><pub-id pub-id-type="pmid">22536161</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yu</surname><given-names>Y.</given-names></name></person-group><etal>et al</etal> (<year>2014</year>) 
<article-title>Maximum likelihood inference of reticulate evolutionary histories</article-title>. <source>Proc. Natl. Acad. Sci. USA</source>, <volume>111</volume>, <fpage>16448</fpage>–<lpage>16453</lpage>.<pub-id pub-id-type="pmid">25368173</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Yu</surname><given-names>Y.</given-names></name>, <name name-style="western"><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2015</year>) 
<article-title>A maximum pseudo-likelihood approach for phylogenetic networks</article-title>. <source>BMC Genomics</source>, <volume>16</volume>, <fpage>S10</fpage>.</mixed-citation>
    </ref>
    <ref id="btz359-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>C.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Bayesian inference of species networks from multilocus sequence data</article-title>. <source>Mol. Biol. Evol</source>., <volume>35</volume>, <fpage>504</fpage>–<lpage>517</lpage>.<pub-id pub-id-type="pmid">29220490</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhu</surname><given-names>J.</given-names></name>, <name name-style="western"><surname>Nakhleh</surname><given-names>L.</given-names></name></person-group> (<year>2018</year>) 
<article-title>Inference of species phylogenies from bi-allelic markers using pseudo-likelihood</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>i376</fpage>–<lpage>i385</lpage>.<pub-id pub-id-type="pmid">29950004</pub-id></mixed-citation>
    </ref>
    <ref id="btz359-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhu</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2018</year>) 
<article-title>Bayesian inference of phylogenetic networks from bi-allelic genetic markers</article-title>. <source>PLOS Comput. Biol</source>., <volume>14</volume>, <fpage>1</fpage>–<lpage>32</lpage>.</mixed-citation>
    </ref>
    <ref id="btz359-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Zhu</surname><given-names>J.</given-names></name></person-group><etal>et al</etal> (<year>2016</year>) 
<article-title>In the light of deep coalescence: revisiting trees within networks</article-title>. <source>BMC Bioinformatics</source>, <volume>17</volume>, <fpage>415.</fpage><pub-id pub-id-type="pmid">28185572</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
