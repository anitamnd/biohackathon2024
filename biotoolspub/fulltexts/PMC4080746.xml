<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4080746</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu331</article-id>
    <article-id pub-id-type="publisher-id">btu331</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Sequence Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>kmacs: the <italic>k</italic>-mismatch average common substring approach to alignment-free sequence comparison</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Leimeister</surname>
          <given-names>Chris-Andre</given-names>
        </name>
        <xref ref-type="aff" rid="btu331-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="corresp" rid="btu331-COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Morgenstern</surname>
          <given-names>Burkhard</given-names>
        </name>
        <xref ref-type="aff" rid="btu331-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="btu331-AFF1">
          <sup>2</sup>
        </xref>
      </contrib>
      <aff id="btu331-AFF1"><sup>1</sup>Department of Bioinformatics, Institute of Microbiology and Genetics, University of Göttingen, Goldschmidtstr. 1, 37073 Göttingen, Germany and <sup>2</sup>Laboratoire Statistique et Génome, Université d’Évry Val d’Essonne, UMR CNRS 8071, USC INRA, 23 Boulevard de France, 91037 Évry, France</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btu331-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="btu331-FN1">
        <p>Associate Editor: John Hancock</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>7</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>13</day>
      <month>5</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>5</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>14</issue>
    <fpage>2000</fpage>
    <lpage>2008</lpage>
    <history>
      <date date-type="received">
        <day>19</day>
        <month>12</month>
        <year>2013</year>
      </date>
      <date date-type="rev-recd">
        <day>25</day>
        <month>4</month>
        <year>2014</year>
      </date>
      <date date-type="accepted">
        <day>25</day>
        <month>4</month>
        <year>2014</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press. All rights reserved.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license xlink:href="http://creativecommons.org/licenses/by/3.0/" license-type="creative-commons">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <related-article id="d35e128" related-article-type="companion" ext-link-type="doi" xlink:href="10.1093/bioinformatics/btu177"/>
    <abstract>
      <p><bold>Motivation:</bold> Alignment-based methods for sequence analysis have various limitations if large datasets are to be analysed. Therefore, alignment-free approaches have become popular in recent years. One of the best known alignment-free methods is the <italic>average common substring approach</italic> that defines a distance measure on sequences based on the average length of longest common words between them. Herein, we generalize this approach by considering longest common substrings with <italic>k</italic> mismatches. We present a greedy heuristic to approximate the length of such <italic>k</italic>-mismatch substrings, and we describe <italic>kmacs</italic>, an efficient implementation of this idea based on generalized enhanced suffix arrays.</p>
      <p><bold>Results:</bold> To evaluate the performance of our approach, we applied it to phylogeny reconstruction using a large number of DNA and protein sequence sets. In most cases, phylogenetic trees calculated with <italic>kmacs</italic> were more accurate than trees produced with established alignment-free methods that are based on <italic>exact</italic> word matches. Especially on protein sequences, our method seems to be superior. On simulated protein families, <italic>kmacs</italic> even outperformed a classical approach to phylogeny reconstruction using multiple alignment and maximum likelihood.</p>
      <p><bold>Availability and implementation:</bold><italic>kmacs</italic> is implemented in C++, and the source code is freely available at <ext-link ext-link-type="uri" xlink:href="http://kmacs.gobics.de/">http://kmacs.gobics.de/</ext-link></p>
      <p>
        <bold>Contact:</bold>
        <email>chris.leimeister@stud.uni-goettingen.de</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu331/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>Comparative sequence analysis traditionally relies on pairwise or multiple sequence alignment. With the huge datasets that are produced by next-generation sequencing technologies, however, today’s alignment algorithms reach their limits. Thus, with the growing number of completely or partially sequenced genomes, there is an urgent demand for faster sequence-comparison methods. Over the past two decades, a wide variety of alignment-free approaches were proposed (<xref rid="btu331-B33" ref-type="bibr">Vinga and Almeida, 2003</xref>). Although aligning two sequences takes time proportional to the product of their lengths, most alignment-free methods run in linear time. They are, therefore, increasingly used for genome-based phylogeny reconstruction and for large-scale protein sequence comparison. It is known, however, that alignment-free methods are generally less accurate than alignment-based approaches.</p>
    <p>Most alignment-free methods calculate the relative frequencies of words of a fixed length <italic>k</italic>, also called <italic>k</italic>-mers, in the input sequences. Other methods are based on variable-length matches; they have the advantage that it is not necessary to specify a fixed word length (<xref rid="btu331-B4" ref-type="bibr">Comin and Verzotto, 2012</xref>; <xref rid="btu331-B5" ref-type="bibr">Didier <italic>et al.</italic>, 2012</xref>). These programs achieve usually better results than approaches relying on a fixed word length. However, algorithms using variable word lengths are typically more complex and require more sophisticated data structures than methods relying on fixed word lengths.</p>
    <p>A well-known approach that uses word matches of variable length is the <italic>average common substring</italic> (<italic>ACS</italic>) method (<xref rid="btu331-B32" ref-type="bibr">Ulitsky <italic>et al.</italic>, 2006</xref>), which calculates for each position <italic>i</italic> in one sequence the length of the longest substring starting at <italic>i</italic> and matching some substring of a second sequence. As a further development of this idea, the <italic>shortest unique substring</italic> (<italic>shustring</italic>) approach has been proposed by <xref rid="btu331-B13" ref-type="bibr">Haubold <italic>et al.</italic> (2005)</xref>. These authors also derived an estimator for the number of substitutions per site between two unaligned sequences based on the average <italic>shustring</italic> length; they implemented this approach in the program <italic>K<sub>r</sub></italic> (<xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic>, 2009</xref>). <italic>ACS</italic> and <italic>shustrings</italic> can be calculated efficiently using <italic>suffix trees</italic> (<xref rid="btu331-B34" ref-type="bibr">Weiner, 1973</xref>).</p>
    <p>As the aforementioned methods, most approaches for alignment-free phylogeny reconstruction are based on <italic>exact</italic> word matches. Recently, we suggested to use <italic>spaced-k-mers</italic> defined by pre-defined patterns of <italic>match</italic> and <italic>don’t care</italic> symbols, instead of contiguous <italic>k</italic>-mers (<xref rid="btu331-B3" ref-type="bibr">Boden <italic>et al.</italic>, 2013</xref>; <xref rid="btu331-B17" ref-type="bibr">Leimeister <italic>et al.</italic>, 2014</xref>). The aim of this study is to apply the idea of <italic>inexact</italic> matches to word matches of varying lengths. We generalize the <italic>ACS</italic> approach by considering, for each position <italic>i</italic> in one sequence, the longest substring starting at <italic>i</italic> and matching some substring in the second sequence with <italic>k</italic> mismatches. We propose an efficient heuristic to approximate the lengths of these substrings, and we describe <italic>kmacs</italic>, an implementation of this approach based on <italic>generalized enhanced suffix arrays</italic>. A web server for our program is described in <xref rid="btu331-B16" ref-type="bibr">Horwege <italic>et al.</italic> (2014)</xref>.</p>
  </sec>
  <sec id="SEC2">
    <title>2 APPROACH</title>
    <sec id="SEC2.1">
      <title>2.1 The <italic>ACS</italic> approach and <italic>k</italic>-mismatch substrings</title>
      <p>As usual, for a sequence <italic>S</italic> over an alphabet Σ, <italic>S</italic>[<italic>i</italic>] is the <italic>i</italic>-th element of <italic>S</italic>, by <inline-formula><mml:math id="I1"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:math></inline-formula> we denote the length of <italic>S</italic> and <inline-formula><mml:math id="I2"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the (contiguous) substring of <italic>S</italic> from <italic>i</italic> to <italic>j</italic>. In particular, <inline-formula><mml:math id="I3"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mn>..</mml:mn><mml:mo stretchy="false">|</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <italic>i</italic>-th <italic>suffix</italic> of <italic>S</italic>. For two sequences <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub>, the <italic>ACS</italic> approach determines for every position <italic>i</italic> in <italic>S</italic><sub>1</sub> the length <inline-formula><mml:math id="I4"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the longest substring of <italic>S</italic><sub>1</sub> starting at position <italic>i</italic> and exactly matching some substring in <italic>S</italic><sub>2</sub>. The lengths <inline-formula><mml:math id="I5"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are averaged and normalized to define a similarity measure
<disp-formula id="btu331-M1"><label>(1)</label><mml:math id="MM1"><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mfrac><mml:mo>*</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
which is turned into a (non-symmetric) distance measure by defining
<disp-formula id="btu331-M2"><label>(2)</label><mml:math id="MM2"><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
</p>
      <p>To obtain a symmetric distance, the distance between <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> is then defined by <xref rid="btu331-B32" ref-type="bibr">Ulitsky <italic>et al.</italic> (2006)</xref> as
<disp-formula id="btu331-M3"><label>(3)</label><mml:math id="MM3"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>A</mml:mi><mml:mi>C</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></disp-formula>
</p>
      <p>In this article, we generalize this distance measure by using substring matches with <italic>k</italic> mismatches instead of exact matches. That is, instead of using the maximum substring lengths <inline-formula><mml:math id="I6"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we define <inline-formula><mml:math id="I7"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mn>1</mml:mn><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as the length of the longest substring of <italic>S</italic><sub>1</sub> starting at position <italic>i</italic> and matching some substring of <italic>S</italic><sub>2</sub> with up to <italic>k</italic> mismatches, minus <italic>k</italic>. (We subtract <italic>k</italic> from the length of this string, counting only the <italic>matching</italic> positions). <inline-formula><mml:math id="I8"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mn>2</mml:mn><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is defined accordingly. We then define a distance measure as above, but with <inline-formula><mml:math id="I9"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> replaced by <inline-formula><mml:math id="I10"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mi>q</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In the special case where <italic>k</italic> = 0, we have <inline-formula><mml:math id="I11"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mi>q</mml:mi><mml:mn>0</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>s</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, so in this case our distance is exactly the distance <italic>d<sub>ACS</sub></italic>.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Approximating the length of k-mismatch substrings</title>
      <p>For a pair of sequences, the exact values <inline-formula><mml:math id="I12"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mi>q</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be calculated in <inline-formula><mml:math id="I13"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>*</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time using suffix trees or similar data structures where <italic>n</italic> is the maximal length of the sequences. As we want to compare sequences in linear time, however, we propose a heuristic to approximate these values. To do so, we first calculate for each position <italic>i</italic> in <italic>S</italic><sub>1</sub> the length <inline-formula><mml:math id="I14"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the longest common substring starting at <italic>i</italic> matching a substring of <italic>S</italic><sub>2</sub>, as is done in <italic>ACS</italic>. Let <italic>j</italic> be the start of this matching substring in <italic>S</italic><sub>2</sub>; the character <inline-formula><mml:math id="I15"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> must therefore differ from <inline-formula><mml:math id="I16"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. We then extend this match without gaps in <italic>S</italic><sub>1</sub> from position <inline-formula><mml:math id="I17"><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and in <italic>S</italic><sub>2</sub> from <inline-formula><mml:math id="I18"><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, until the next mismatch occurs. This is repeated until the <italic>k</italic> + 1-th mismatch or the end of one of the two sequences is reached.</p>
      <p>In the example below, for position <italic>i</italic> = 4 in <italic>S</italic><sub>1</sub> and with <italic>k</italic> = 2 mismatches, our approach would return the following <italic>k</italic>-mismatch common substring, starting at position <italic>j</italic> = 2 in <italic>S</italic><sub>2</sub>:</p>
      <p>
        <inline-graphic xlink:href="btu331ilf1.jpg"/>
      </p>
      <p>To obtain this <italic>k</italic>-mismatch common substring, our program would first determine the longest common substring for position <italic>i</italic> = 4 in <italic>S</italic><sub>1</sub> that exactly matches a substring in <italic>S</italic><sub>2</sub>. We find such a match at position <italic>j</italic> = 2 in <italic>S</italic><sub>2</sub> with the length <inline-formula><mml:math id="I19"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>. Then this match is extended without gaps until the third mismatch is reached. The length of this 2-mismatch substring is 7, so we have <inline-formula><mml:math id="I20"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula> (in the definition of <inline-formula><mml:math id="I21"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mi>q</mml:mi><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we count only the <italic>matching</italic> positions).</p>
      <p>It should be mentioned that, for a position <italic>i</italic> in <italic>S</italic><sub>1</sub>, the corresponding position <italic>j</italic> in <italic>S</italic><sub>2</sub> of the longest exact match to a substring starting at <italic>i</italic> may not be unique. Consider, <italic>e.g.</italic> position <italic>i</italic> = 2 in the first sequence of the above example:</p>
      <p>
        <inline-graphic xlink:href="btu331ilf2.jpg"/>
      </p>
      <p>Here, the substring <italic>AT</italic> starting at position 2 in <italic>S</italic><sub>1</sub> is the longest substring starting at this position and matching a substring of <italic>S</italic><sub>2</sub>—but this substring occurs at positions 1, 5 and 10 in <italic>S</italic><sub>2</sub>. In such a case, we calculate <italic>all k</italic>-mismatch extensions of these occurrences as described above, and we define <inline-formula><mml:math id="I22"><mml:mrow><mml:msubsup><mml:mi>s</mml:mi><mml:mn>1</mml:mn><mml:mi>k</mml:mi></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as length of the <italic>maximal</italic> possible extension minus <italic>k</italic>.</p>
      <p>The above heuristic reduces the complexity of finding the <italic>k</italic> mismatch maximal substring lengths from <inline-formula><mml:math id="I23"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>*</mml:mo><mml:msup><mml:mi>n</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="I24"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo>*</mml:mo><mml:mi>n</mml:mi><mml:mo>*</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic>z</italic> is the average number of maximal matches to a substring in <italic>S</italic><sub>2</sub> starting at a position <italic>i</italic> in <italic>S</italic><sub>1</sub>. In principle, this complexity could be achieved by using <italic>suffix trees</italic> (<xref rid="btu331-B34" ref-type="bibr">Weiner, 1973</xref>) as the underlying data structure. Here, one would build a <italic>generalized suffix tree</italic> for the sequences in <inline-formula><mml:math id="I25"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, e.g. using <italic>Ukkonen’s algorithm</italic> (<xref rid="btu331-B31" ref-type="bibr">Ukkonen, 1995</xref>). To determine the longest substring starting at <italic>i</italic> in <italic>S</italic><sub>1</sub> and also occurring in <italic>S</italic><sub>2</sub>, one needs to find the <italic>lowest</italic> node <italic>v</italic> in the suffix tree that is above leaf <italic>i</italic> and also above some leaf that belongs to <italic>S</italic><sub>2</sub>. The length <inline-formula><mml:math id="I26"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the longest common substring starting at <italic>i</italic> is then the <italic>string depth</italic> of the node <italic>v</italic>, that is, the length of the edge labels on the path from the root to <italic>v</italic>. Moreover, the leaves below <italic>v</italic> appertaining to <italic>S</italic><sub>2</sub> exactly correspond to the positions of this longest exact match in <italic>S</italic><sub>2</sub>.</p>
      <p>Next, we want to extend the longest exact matches that we have found by this procedure until the <italic>k</italic> + 1-th mismatch is found. Thus, we need be able to find the longest exact match between two sequences starting at two <italic>given</italic> positions <italic>i</italic> and <italic>j</italic> (the positions after a mismatch, in our case). In a suffix-tree approach, this could be accomplished by <italic>lowest common ancestor</italic> (<italic>LCA</italic>) queries. Similar to the aforementioned approach, we would have to look up the lowest node <italic>v</italic> that is above both leafs <italic>i</italic> and <italic>j</italic>; the string depth of <italic>v</italic> is then the length of the longest exact match starting at <italic>i</italic> and <italic>j</italic>, respectively. <italic>LCA</italic> queries can be carried out for any <italic>i</italic> and <italic>j</italic> in constant time after a linear-time preprocessing step (<xref rid="btu331-B12" ref-type="bibr">Harel and Tarjan, 1984</xref>), resulting in <italic>k</italic> constant-time <italic>LCA</italic> queries for the full <italic>k</italic>-mismatch extension of an exact longest match.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 IMPLEMENTATION</title>
    <p><xref rid="btu331-B1" ref-type="bibr">Abouelhoda <italic>et al.</italic> (2004)</xref> have shown that every algorithm that uses suffix-trees can be replaced by an algorithm using <italic>enhanced suffix arrays</italic> that has the same complexity. Here, an <italic>enhanced suffix array</italic> is defined as a data structure ‘consisting of the suffix array and additional tables’. Both, suffix trees and enhanced suffix arrays, can be calculated in linear time and space, but suffix arrays require substantially less memory per input character than suffix trees do (<xref rid="btu331-B20" ref-type="bibr">Manber and Myers, 1990</xref>). In our implementation, we therefore used <italic>enhanced</italic> suffix arrays instead of suffix trees, making use of recent improvements of linear-time suffix array construction algorithms.</p>
    <p>A <italic>suffix array SA</italic> of a string <inline-formula><mml:math id="I27"><mml:mrow><mml:mi>S</mml:mi><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>…</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is a permutation of the indices <inline-formula><mml:math id="I28"><mml:mrow><mml:mn>1...</mml:mn><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> according to the lexicographical ordering of the corresponding suffices. That is, we have <italic>SA</italic><inline-formula><mml:math id="I29"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> if the <italic>j</italic>-th suffix of <italic>S</italic> is at the <italic>i</italic>-th position in the lexicographical ordering of all suffices of <italic>S</italic>. In addition to the <italic>SA</italic>, we need the so-called <italic>longest common prefix (LCP) array</italic> for <italic>S</italic>. Here, the entry <italic>LCP</italic>[<italic>i</italic>] stores the length of the <italic>LCP</italic> of the <italic>SA</italic>[<italic>i</italic>]-th suffix and its predecessor in <italic>SA</italic>, the <italic>SA</italic><inline-formula><mml:math id="I30"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>-th suffix. The <italic>SA</italic> of a sequence <italic>S</italic> together with the corresponding <italic>LCP</italic> array is called, in this context, the <italic>enhanced suffix array</italic> of <italic>S</italic>. To calculate <italic>enhanced suffix arrays</italic> in linear time, we used a program described by <xref rid="btu331-B9" ref-type="bibr">Fischer (2011)</xref>, which is available at <ext-link ext-link-type="uri" xlink:href="http://algo2.iti.kit.edu/english/1828.php">http://algo2.iti.kit.edu/english/1828.php</ext-link>. The underlying algorithm is based on <italic>sais-lite</italic> by <italic>Yuta Mori</italic>, a fast implementation of <italic>induced sorting</italic> (<xref rid="btu331-B22" ref-type="bibr">Nong <italic>et al.</italic>, 2009</xref>). Suffix arrays provide an efficient solution to our longest <italic>k</italic>-mismatch substring problem.</p>
    <p>For a <italic>single</italic> sequence <italic>S</italic> and a position <italic>SA</italic>[<italic>i</italic>] in <italic>S</italic>, the enhanced suffix array of <italic>S</italic> can be used to find the length of the longest substring in <italic>S</italic> starting at a different position in <italic>S</italic> and matching a substring starting at <italic>SA</italic>[<italic>i</italic>]. It is easy to see that this substring must be the <italic>LCP</italic> of the <italic>SA</italic>[<italic>i</italic>]-th suffix with one of its neighbours in <italic>SA</italic>, i.e. either with the <italic>SA</italic><inline-formula><mml:math id="I31"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>-th or the <italic>SA</italic><inline-formula><mml:math id="I32"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>-th suffix, whichever is longer. With an <italic>enhanced</italic> suffix array, the length of this substring is given as the maximum of the values <italic>LCP</italic>[<italic>i</italic>] and <inline-formula><mml:math id="I33"><mml:mrow><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and can therefore be looked up in constant time. The position where this second substring starts is then either <italic>SA</italic><inline-formula><mml:math id="I34"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> or <italic>SA</italic><inline-formula><mml:math id="I35"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>—or both of these positions—depending on where the maximum is reached.</p>
    <p>If matches between two sequences are to be found, the situation is slightly more complicated. For a position in sequence <italic>S</italic><sub>1</sub>, we want to find a position in <italic>S</italic><sub>2</sub> such that the common substring starting at these two positions is maximal, and vice versa. To solve this problem, we build the <italic>generalized enhanced suffix array</italic> of our sequences, i.e. the enhanced suffix array of the concatenated sequence <inline-formula><mml:math id="I36"><mml:mrow><mml:mi>S</mml:mi><mml:mo>:</mml:mo><mml:mspace width="-.4em"/><mml:mo>=</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>$</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> where $ is a special character not contained the alphabet Σ; see also <xref rid="btu331-B2" ref-type="bibr">Babenko and Starikovskaya (2008)</xref> for a related approach. Thus, each suffix from <italic>S</italic><sub>1</sub> or <italic>S</italic><sub>2</sub> is represented in lexicographical order by an entry in <italic>SA</italic>. <xref ref-type="fig" rid="btu331-F1">Figure 1</xref> shows the enhanced suffix array for two sequences.
<fig id="btu331-F1" position="float"><label>Fig. 1.</label><caption><p>Generalized <italic>SA</italic> and <italic>LCP</italic> array for the strings <inline-formula><mml:math id="I37"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I38"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>, concatenated by the symbol $. Suffices of <inline-formula><mml:math id="I39"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mi>$</mml:mi><mml:msub><mml:mi>S</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula> starting in <italic>S</italic><sub>1</sub> are shown in orange, suffices starting in <italic>S</italic><sub>2</sub> are in blue</p></caption><graphic xlink:href="btu331f1p"/></fig></p>
    <p>To find the length of the longest substring starting at <italic>SA</italic>[<italic>i</italic>] in one sequence, matching a substring of the <italic>other</italic> sequence, and its occurrences there, we need to look up the <italic>largest</italic> integer <inline-formula><mml:math id="I40"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="I41"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, such that <italic>SA</italic><inline-formula><mml:math id="I42"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> belongs to the other sequence. Correspondingly, we need the <italic>smallest</italic> integer <inline-formula><mml:math id="I43"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> with <inline-formula><mml:math id="I44"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> with <italic>SA</italic><inline-formula><mml:math id="I45"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> belonging to the other sequence. The length of this common substring is then given as the <italic>minimum</italic> of all <italic>LCP</italic> values between <inline-formula><mml:math id="I46"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic>i</italic> or the minimum between the <italic>LCP</italic> values between <italic>i</italic> + 1 and <inline-formula><mml:math id="I47"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>—whichever minimum is larger. Formally, the length of the longest substring starting at a position <italic>SA</italic>[<italic>i</italic>] and matching a substring of the respective other sequence is given as follows:
<disp-formula id="btu331-M4"><label>(4)</label><mml:math id="MM4"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>y</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>
with <italic>p</italic><sub>1</sub> and <italic>p</italic><sub>2</sub> defined as above.</p>
    <p>The <italic>position</italic> of this longest substring in <italic>S</italic> is then <italic>SA</italic><inline-formula><mml:math id="I48"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> or <italic>SA</italic><inline-formula><mml:math id="I49"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (or both), depending on where the maximum in <xref ref-type="disp-formula" rid="btu331-M4">Equation (4)</xref> is reached. All positions in this formula refer to the <italic>concatenated</italic> sequence <italic>S</italic>, but it is trivial to retrieve the positions in the original sequences <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> from these values by subtracting <inline-formula><mml:math id="I50"><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> where necessary.</p>
    <p>As an example, consider <xref ref-type="fig" rid="btu331-F1">Figure 1</xref>. For <italic>i</italic> = 6, we want to find the longest common substring starting at <inline-formula><mml:math id="I51"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> (marked by an arrow) that exactly matches a substring starting at some position in the other sequence. Position <inline-formula><mml:math id="I52"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> in the concatenated sequence <italic>S</italic> corresponds to a position in sequence <italic>S</italic><sub>2</sub>, so we have <inline-formula><mml:math id="I53"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, as 4 is the largest integer smaller than 6 such that <inline-formula><mml:math id="I54"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> belongs to the <italic>other</italic> sequence, i.e. to <italic>S</italic><sub>1</sub>. Similarly, we obtain <inline-formula><mml:math id="I55"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula>. According to <xref ref-type="disp-formula" rid="btu331-M4">Equation (4)</xref>, we get the following:
<disp-formula><mml:math id="UM1"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>6</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo><mml:mo>{</mml:mo><mml:mn>5</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow><mml:mo stretchy="true">}</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mo>{</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mn>3.</mml:mn></mml:mrow></mml:math></disp-formula>
</p>
    <p>Position 10 in <italic>S</italic> corresponds to position 3 in the original sequence <italic>S</italic><sub>2</sub>, so, as a result, we obtain <inline-formula><mml:math id="I56"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, i.e. the longest substring starting at position 3 in <italic>S</italic><sub>2</sub> matching a substring from <italic>S</italic><sub>1</sub> has length 3 (the substring itself is ‘<italic>ana</italic>’).</p>
    <p>
      <boxed-text id="btu331-BOX1" position="float">
        <caption>
          <title><bold>Algorithm 1</bold> Calculation of Equation (4)</title>
        </caption>
        <p><bold>Require:</bold> SA {generalized suffix array for <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> of length <italic>n</italic>}</p>
        <p><bold>Require:</bold> LCP {corresponding longest common prefix array}</p>
        <p><bold>Ensure:</bold><italic>s</italic> {stores the results of <xref ref-type="disp-formula" rid="btu331-M4">Equation (4)</xref>}</p>
        <p> <inline-formula><mml:math id="I57"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p>
        <p> <bold>for</bold>
<italic>i</italic> = 2 to <italic>n</italic> – 1 <bold>do</bold></p>
        <p>  <bold>if</bold>
<inline-formula><mml:math id="I58"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I59"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> belong to the same sequence <bold>then</bold></p>
        <p>   <bold>if</bold>
<inline-formula><mml:math id="I60"><mml:mrow><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p>
        <p>    <inline-formula><mml:math id="I61"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>   <bold>end</bold> if</p>
        <p>   <inline-formula><mml:math id="I62"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula></p>
        <p>  <bold>else</bold></p>
        <p>   <inline-formula><mml:math id="I63"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>   <inline-formula><mml:math id="I64"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>  <bold>end</bold> if</p>
        <p> <bold>end for</bold></p>
        <p> <inline-formula><mml:math id="I65"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p>
        <p> <bold>for</bold>
<italic>i</italic> = <italic>n</italic> to 2 <bold>do</bold></p>
        <p>  <bold>if</bold>
<inline-formula><mml:math id="I66"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="I67"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> belong to the same sequence <bold>then</bold></p>
        <p>   <bold>if</bold>
<inline-formula><mml:math id="I68"><mml:mrow><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>
<bold>then</bold></p>
        <p>    <inline-formula><mml:math id="I69"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>   <bold>end</bold> if</p>
        <p>   <inline-formula><mml:math id="I70"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>  <bold>else</bold></p>
        <p>   <inline-formula><mml:math id="I71"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>   <inline-formula><mml:math id="I72"><mml:mrow><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p>
        <p>  <bold>end</bold> if</p>
        <p> <bold>end for</bold></p>
      </boxed-text>
    </p>
    <p>All values <italic>s</italic>(<italic>i</italic>) can be calculated for the entire concatenated string <italic>S</italic> in <italic>linear</italic> time using Algorithm 1. Here, the first loop computes <inline-formula><mml:math id="I73"><mml:mrow><mml:msub><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> for all indices <italic>i</italic> and stores them as <italic>s</italic>[<italic>i</italic>]. Then the second loop calculates <inline-formula><mml:math id="I74"><mml:mrow><mml:msub><mml:mrow><mml:mi>min</mml:mi><mml:mo>⁡</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>y</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and updates <italic>s</italic>[<italic>i</italic>] if the result is greater than the actual value of <italic>s</italic>[<italic>i</italic>]. This way, algorithm 1 applies <xref ref-type="disp-formula" rid="btu331-M4">Equation (4)</xref> to all indices <italic>i</italic> and stores the corresponding values <italic>s</italic>[<italic>i</italic>].</p>
    <p>Finally, for our heuristic we need to find for an index <italic>i all</italic> positions belonging to the respective other sequence, where a match of length <italic>s</italic>(<italic>i</italic>) occurs. This can be achieved by a simple extension of Algorithm 1. Without loss of generality, we assume that the first minimum in <xref ref-type="disp-formula" rid="btu331-M4">Equation (4)</xref> is strictly larger than the second minimum, so <inline-formula><mml:math id="I75"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a position where a maximal match to the other sequence occurs (as was the case in our small example above). To find possible additional matching positions, we consider <italic>all</italic> indices <inline-formula><mml:math id="I76"><mml:mrow><mml:mi>p</mml:mi><mml:mo>≤</mml:mo><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in descending order, as long as one has the following inequality:
<disp-formula><mml:math id="UM2"><mml:mrow><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>≤</mml:mo><mml:munder><mml:mrow><mml:mi>min</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>x</mml:mi><mml:mo>≤</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
    <p>For <italic>all</italic> such <italic>p</italic> that belong to the other sequence, the positions <italic>SA</italic>[<italic>p</italic>] are occurrences of longest substrings matching a substring starting at <italic>i</italic>. In our example, we find one further position <italic>p</italic> = 3, so <italic>SA</italic><inline-formula><mml:math id="I77"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> is an additional occurrence. If the maximum in (4) is achieved by the second term, one proceeds accordingly.</p>
    <p>Next, the second step in our approach involves finding the length of the longest common substring starting at pre-defined positions in <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub>, respectively. Using the enhanced suffix array of a sequence <italic>S</italic>, the length of the longest substring starting at positions <italic>SA</italic>[<italic>i</italic>] and <italic>SA</italic>[<italic>j</italic>] (with <italic>SA</italic><inline-formula><mml:math id="I78"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>&lt;</mml:mo></mml:mrow></mml:math></inline-formula>
<italic>SA</italic>[<italic>j</italic>]) is given as the minimum over the values <italic>LCP</italic>[<italic>p</italic>], <inline-formula><mml:math id="I79"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>p</mml:mi><mml:mo>≤</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. There is an approach similar to <italic>LCA</italic> queries to obtain this value known as <italic>range minimum queries (RMQ)</italic>. A <italic>RMQ</italic> returns the index of an array <italic>A</italic> that stores the smallest element between two specified indices <italic>l</italic> and <italic>r</italic>, denoted as <inline-formula><mml:math id="I80"><mml:mrow><mml:mi>R</mml:mi><mml:mi>M</mml:mi><mml:msub><mml:mi>Q</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    <p>Several algorithms are available that can solve <italic>RMQ</italic> in constant time, after a linear preprocessing step, e.g. <xref rid="btu331-B11" ref-type="bibr">Fischer and Heun (2007)</xref>. According to <xref rid="btu331-B10" ref-type="bibr">Fischer and Heun (2006)</xref>, the longest common substring starting at <italic>i</italic> and <italic>j</italic> can be calculated as <inline-formula><mml:math id="I81"><mml:mrow><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>R</mml:mi><mml:mi>M</mml:mi><mml:msub><mml:mi>Q</mml:mi><mml:mrow><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="I82"><mml:mrow><mml:mi>S</mml:mi><mml:msup><mml:mi>A</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> is the inverse suffix array. As a result, the same complexity as for suffix trees can be achieved by using <italic>enhanced suffix arrays</italic>. In our implementation, however, we extend the substrings by matching single characters because in our test runs this ‘naive’ approach was faster than the <italic>RMQ</italic> implementation that we tested. Nevertheless, our downloadable program has an option for using the <italic>RMQ</italic> algorithm so the user can compare these two approaches.</p>
  </sec>
  <sec id="SEC4">
    <title>4 BENCHMARKING</title>
    <sec id="SEC4.1">
      <title>4.1 Benchmark sequences</title>
      <p>To evaluate <italic>kmacs</italic> and to compare it with other methods of sequence comparison, we applied these methods phylogeny reconstruction. We used a large number of DNA and protein sequence sets for which reliable phylogenetic trees are available, and we measured how similar the constructed trees are to the respective reference trees. The following sequence sets were used in our study:</p>
      <p>For eukaryotic DNA comparison, we used a set of 27 primate mitochondrial genomes that were previously used by <xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic> (2009)</xref> as benchmark for alignment-free methods. These sequences have a total length of 446 <italic>kb</italic>. A benchmark tree that has been constructed based on a multiple alignment.</p>
      <p>As prokaryotic genomes, we used a set of 32 <italic>Roseobacter</italic> genomes, which were previously analysed by <xref rid="btu331-B21" ref-type="bibr">Newton <italic>et al.</italic> (2010)</xref>. They constructed a phylogenetic tree for these sequences based on alignments of 70 universal single-copy genes that we used as reference tree in our study. The total size of this sequence set is 135.9 <italic>mb</italic>.</p>
      <p>As benchmark proteins, we used 218 sequence sets contained in the <italic>BAliBASE (v3.0)</italic> database (<xref rid="btu331-B30" ref-type="bibr">Thompson <italic>et al.</italic>, 2005</xref>). To obtain reference trees, we applied <italic>Maximum Likelihood</italic> (<xref rid="btu331-B7" ref-type="bibr">Felsenstein, 1981</xref>), implemented in the program <italic>proml</italic> from <italic>PHYLIP</italic> to the <italic>reference multiple alignments</italic> in <italic>BAliBASE</italic>. As these reference alignments are considered to be reliable, the resulting trees should also be reliable.</p>
      <p>In addition to these real-world sequences, we used the program <italic>Rose</italic> (<xref rid="btu331-B28" ref-type="bibr">Stoye <italic>et al.</italic>, 1998</xref>) to generate simulated DNA and protein families. <italic>Rose</italic> generates sets of related sequences based on a probabilistic model of substitutions and insertions/deletions for which the parameters can be adjusted by the user. These sequences are created along a randomly generated tree, starting from one common ancestral sequence at the root of the tree. This way, the ‘evolution’ of the generated sequences is logged, so a reference tree is generated alongside the sequences. We used <italic>Rose</italic> with default parameters, except for the parameter <italic>relatedness</italic>, which defines the average evolutionary distance between the generated sequences, measured in <italic>PAM</italic> units. We generated 20 DNA sequence sets, each of which contains 50 sequences with an average length of 16 000 <italic>nt</italic> using a <italic>relatedness</italic> value of 70. Furthermore, we generated 20 protein sequence sets, each containing 125 sequences with an average length of 300 <italic>a</italic><italic>mino </italic><italic>a</italic><italic>cids</italic>. Here, we set the <italic>relatedness</italic> to 480.</p>
    </sec>
    <sec id="SEC4.2">
      <title>4.2 Compared methods</title>
      <p>We compared our new method with seven state-of-the-art alignment-free methods, namely <italic>ACS</italic> (<xref rid="btu331-B32" ref-type="bibr">Ulitsky <italic>et al.</italic>, 2006</xref>), <italic>K<sub>r</sub> v2.0.2</italic> (<xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic>, 2009</xref>), <italic>FFP</italic> (<xref rid="btu331-B27" ref-type="bibr">Sims <italic>et al.</italic>, 2009</xref>), <italic>spaced words</italic> (<xref rid="btu331-B17" ref-type="bibr">Leimeister <italic>et al.</italic>, 2014</xref>), CVTree (<xref rid="btu331-B23" ref-type="bibr">Qi <italic>et al.</italic>, 2004</xref>), the <italic>underlying approach (UA)</italic> (<xref rid="btu331-B4" ref-type="bibr">Comin and Verzotto, 2012</xref>) as well as to a generic <italic>k-mer</italic>-frequency approach. As an eighth method, we ran <italic>Clustal W</italic> (<xref rid="btu331-B29" ref-type="bibr">Thompson <italic>et al.</italic>, 1994</xref>) on those sequence sets where this was possible and meaningful. For <italic>ACS</italic> and the <italic>k-mer</italic> approach, we used our own implementations, namely <italic>kmacs</italic> with <italic>k</italic> = 0 and our <italic>spaced</italic><italic>-</italic><italic>words</italic> approach without <italic>don’t care</italic> positions in the underlying patterns, respectively.</p>
      <p><italic>FFP</italic>, <italic>K<sub>r</sub></italic> and <italic>CVTree</italic> return pairwise distances between the input sequences. For <italic>ACS</italic>, we calculated distances as defined in (3), and for <italic>spaced words</italic> and the <italic>k-mer</italic> approach we used the <italic>Jensen</italic><italic>–</italic><italic>Shannon divergence</italic> (<xref rid="btu331-B18" ref-type="bibr">Lin, 1991</xref>), applied to (spaced)-word frequency vectors as explained in <xref rid="btu331-B17" ref-type="bibr">Leimeister <italic>et al.</italic> (2014)</xref>. For each of the five groups of benchmark data, we used the word length <italic>k</italic> for which the <italic>k</italic>-mer approach produced the best results, i.e. trees with minimal average <italic>Robinson</italic><italic>–</italic><italic>Foulds</italic> (<italic>RF</italic>) distances to the reference trees. For <italic>spaced words</italic>, we used the same value for <italic>k</italic>, even though better results might be possible with different values. Accordingly, on every group of benchmark data, we tested <italic>FFP</italic>, <italic>CVTree</italic> and <italic>UA</italic> with different parameter values and used those which produced the best results on this group.</p>
      <p>We then constructed phylogenetic trees by applying <italic>Neighbor joining</italic> (<xref rid="btu331-B25" ref-type="bibr">Saitou and Nei, 1987</xref>) to the distance matrices obtained with the different alignment-free methods. Finally, we calculated phylogenetic trees for all sequence sets by applying <italic>Maximum Likelihood</italic> (<xref rid="btu331-B7" ref-type="bibr">Felsenstein, 1981</xref>) to the <italic>Clustal W</italic> multiple alignments. All resulting tree topologies were compared with the topologies of the respective reference trees using the <italic>RF metric</italic> (<xref rid="btu331-B24" ref-type="bibr">Robinson and Foulds, 1981</xref>). For <italic>Neighbor joining</italic> and to calculate the <italic>RF</italic> distances, we used the programs <italic>neighbor</italic> and <italic>treedist</italic> contained in the <italic>PHYLIP package</italic> (<xref rid="btu331-B8" ref-type="bibr">Felsenstein, 1989</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>5 RESULTS AND DISCUSSION</title>
    <p><xref ref-type="fig" rid="btu331-F2">Figures 2</xref> and <xref ref-type="fig" rid="btu331-F4 btu331-F5 btu331-F6 btu331-F7">4–7</xref> summarize our test results on the five groups of benchmark sequence sets that we used. The plots show the average <italic>RF</italic> distances between the produced trees and the corresponding reference trees. For <italic>kmacs</italic>, results are shown for various values of <italic>k</italic>. For <italic>FFP</italic>, <italic>CVTree</italic>, <italic>UA</italic> and the <italic>k</italic>-mer method, we also used a range of parameter values, but for each of these methods, the figures show only the <italic>best</italic> results on the respective group of benchmark sequences. Thus, for a fair comparison, these methods should be compared with the <italic>best</italic> results of <italic>kmacs</italic> in the corresponding figure. On the other hand, <italic>K<sub>r</sub></italic>, <italic>ACS</italic> and <italic>Clustal</italic> could be used with default parameters, which is clearly an advantage of these methods.
<fig id="btu331-F2" position="float"><label>Fig. 2.</label><caption><p>Performance of alignment-free methods on a set of 27 primate mitochondrial genomes. <italic>RF</italic> distances between constructed trees and a reference tree are shown. The tree calculated by <italic>kmacs</italic> with <italic>k</italic> = 70 is shown in <xref ref-type="fig" rid="btu331-F3">Figure 3</xref>, together with the reference tree</p></caption><graphic xlink:href="btu331f2p"/></fig></p>
    <p><xref ref-type="fig" rid="btu331-F2">Figure 2</xref> contains the test results on the primate mitochondrial genomes. The best method on this dataset was our previously developed <italic>spaced-words</italic> approach; the tree topology produced by this method precisely coincides with the topology of the reference tree, i.e. the <italic>RF</italic> distance is zero. The second best methods were <italic>FFP</italic> and <italic>kmacs</italic> with <italic>k</italic> = 3, 4 and <inline-formula><mml:math id="I83"><mml:mrow><mml:mn>64</mml:mn><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mn>117</mml:mn></mml:mrow></mml:math></inline-formula>. <italic>ACS</italic>, <italic>CVTree</italic>, <italic>UA</italic>, <italic>kmacs</italic> with other values for <italic>k</italic> and <italic>K<sub>r</sub></italic> performed worse on these data. As an example, <xref ref-type="fig" rid="btu331-F3">Figure 3</xref> compares the tree calculated with <italic>kmacs</italic> (<italic>k</italic> = 70) with the alignment-based reference tree from <xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic> (2009)</xref>. The tree topology calculated by <italic>kmacs</italic> almost coincides with the topology of the reference tree; the <italic>RF</italic> distance between these trees is 2.
<fig id="btu331-F3" position="float"><label>Fig. 3.</label><caption><p>Midpoint-rooted trees of 27 primate mitochondrial genomes. (<bold>A</bold>) is the alignment-based reference tree obtained from <xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic> (2009)</xref> and (<bold>B</bold>) is based on <italic>kmacs</italic> with <italic>k</italic> = 70. Red branches represent differences to the reference tree topology. Except for these three species, the topologies of the two trees coincide, resulting in a <italic>RF</italic> distance of 2 between our tree and the reference tree</p></caption><graphic xlink:href="btu331f3p"/></fig></p>
    <p>On the <italic>Roseobacter</italic> genomes, the best methods were <italic>kmacs</italic> with <italic>k</italic> = 4 and 6, <italic>FFP</italic> and <italic>CVTree</italic> as shown in <xref ref-type="fig" rid="btu331-F4">Figure 4</xref>. <italic>Spaced words</italic> and the generic <italic>k</italic>-mer approach performed slightly worse. None of the tested methods was able to exactly reconstruct the topology of the reference tree. <italic>UA</italic> is missing in this comparison, as this program is too slow to be run on full bacterial genomes in reasonable time. For our simulated DNA sequence sets, the results were similar as for the primate mitochondrial genomes; see <xref ref-type="fig" rid="btu331-F5">Figure 5</xref>. Here too, <italic>spaced words</italic> was the best alignment-free method, followed by <italic>kmacs</italic>. This time <italic>kmacs</italic> outperformed the established alignment-free approaches for <italic>all</italic> values of <italic>k</italic> that we tested. On our simulated DNA sequences, we could also run a classical approach to phylogeny reconstruction using <italic>Clustal W</italic> and <italic>Maximum Likelihood</italic>. Not surprisingly, this slow and accurate method performed better than all alignment-free approaches.
<fig id="btu331-F4" position="float"><label>Fig. 4.</label><caption><p>Performance of alignment-free methods on a set of 32 <italic>Roseobacter</italic> genome sequences. <italic>RF</italic> distances to the reference tree are shown</p></caption><graphic xlink:href="btu331f4p"/></fig>
<fig id="btu331-F5" position="float"><label>Fig. 5.</label><caption><p>Performance of alignment-based and alignment-free methods on 20 sets of 50 simulated DNA sequences of length 16 000 each. Average <italic>RF</italic> distances to the respective reference trees are shown</p></caption><graphic xlink:href="btu331f5p"/></fig></p>
    <p><xref ref-type="fig" rid="btu331-F6">Figure 6</xref> shows the results for the <italic>BAliBASE</italic> protein sequences. <italic>S</italic><italic>paced words</italic> and <italic>kmacs</italic> again produced better results than the existing alignment-free methods that we evaluated. This time, there was a large range of values for <italic>k</italic> where <italic>kmacs</italic> performed similar or even slightly better than <italic>spaced words</italic><italic>,</italic> and both methods outperformed the other alignment-free methods that we tested. As with the previous dataset, the classical approach based on multiple sequence alignment performed best; this time the difference between alignment-based and alignment-free methods was larger. This may be because of the fact that multiple-alignment programs are often tuned to perform well on <italic>BAliBASE</italic>, the main database to evaluate multiple-alignment methods.
<fig id="btu331-F6" position="float"><label>Fig. 6.</label><caption><p>Performance of different methods on 218 protein sequence sets from <italic>BAliBASE</italic>. Average <italic>RF</italic> distances to reference trees, calculated based on <italic>BAliBASE</italic> reference alignments, are shown</p></caption><graphic xlink:href="btu331f6p"/></fig></p>
    <p>Finally, the results on our simulated protein sequences are shown in <xref ref-type="fig" rid="btu331-F7">Figure 7</xref>. As in most previous examples, <italic>spaced words</italic> and <italic>kmacs</italic> outperformed other alignment-free approaches and, as on <italic>BAliBASE</italic>, <italic>kmacs</italic> was slightly better than <italic>spaced words</italic> if <italic>k</italic> was sufficiently large. Surprisingly, on these benchmark sequences <italic>spaced words</italic> and <italic>kmacs</italic> even outperformed <italic>Clustal W</italic> and <italic>Maximum Likelihood</italic>, although not dramatically.
<fig id="btu331-F7" position="float"><label>Fig. 7.</label><caption><p>Performance of different methods on 20 sets of 125 simulated protein sequences each</p></caption><graphic xlink:href="btu331f7p"/></fig></p>
    <p>So far, we evaluated alignment-free and alignment-based methods <italic>indirectly</italic>, by applying them to phylogeny reconstruction and comparing the resulting trees with trusted reference trees using the <italic>RF</italic> metric. This is a common procedure to evaluate alignment-free methods. <italic>RF</italic> distances to reference trees are only a rough measure of accuracy, though, as they are based on tree topologies alone and do not take branch lengths into account. Furthermore, the constructed trees depend not only on the underlying methods for sequence comparison but also on the methods used for tree reconstruction. A more direct and accurate way of comparing alignment-free methods is to <italic>directly</italic> compare the distance values that they calculate. This can be done, for example, by plotting the distances produced for simulated sequences against their <italic>real</italic> evolutionary distances (<xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic>, 2009</xref>). Ideally, this should be a linear relation. <xref ref-type="fig" rid="btu331-F8">Figure 8</xref> shows such plots for the algorithms that we compared in our study.
<fig id="btu331-F8" position="float"><label>Fig. 8.</label><caption><p>Distances calculated by different alignment-free methods as a function of substitutions per site for pairs of simulated DNA sequences. Distances were normalized such that they are equal for 0.75 substitutions per site</p></caption><graphic xlink:href="btu331f8p"/></fig></p>
    <p><xref ref-type="table" rid="btu331-T1">Tables 1</xref> and <xref ref-type="table" rid="btu331-T2">2</xref> summarize the run times of the different methods that we tested. When used with moderate values of <italic>k</italic>, <italic>kmacs</italic> is faster than <italic>spaced words</italic> run with a set of 100 different patterns. <italic>K<sub>r</sub></italic> was more than one order of magnitude faster than <italic>kmacs</italic> and <italic>spaced words</italic>, respectively, although <italic>UA</italic> was the slowest method. The fastest method was our implementation of the generic word-frequency approach, followed by <italic>K<sub>r</sub></italic> and <italic>CVTree</italic>. In general, <italic>spaced words</italic> used with the <italic>single-pattern</italic> option is only slightly slower than the <italic>k</italic>-mer approach. As shown in our companion paper, however, <italic>spaced words</italic> produces considerably better results when used with <italic>multiple</italic> patterns (<xref rid="btu331-B17" ref-type="bibr">Leimeister <italic>et al.</italic>, 2014</xref>). We therefore applied only the multiple-pattern version in this study.
<table-wrap id="btu331-T1" position="float"><label>Table 1.</label><caption><p>Program runtime for different methods on a set of 50 simulated DNA sequences of length 16 000 <italic>nt</italic> each</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Method</th><th rowspan="1" colspan="1">Runtime (<italic>s</italic>)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1"><italic>Clustal W</italic></td><td rowspan="1" colspan="1">1817</td></tr><tr><td rowspan="1" colspan="1"><italic>Clustal</italic> Ω</td><td rowspan="1" colspan="1">1039</td></tr><tr><td rowspan="1" colspan="1">8-mer</td><td rowspan="1" colspan="1">0.3</td></tr><tr><td rowspan="1" colspan="1"><italic>FFP</italic>, <italic>l</italic> = 23</td><td rowspan="1" colspan="1">123.3</td></tr><tr><td rowspan="1" colspan="1"><italic>spaced words</italic>, 100 patterns, <italic>k</italic> = 8</td><td rowspan="1" colspan="1">27.6</td></tr><tr><td rowspan="1" colspan="1"><italic>ACS</italic></td><td rowspan="1" colspan="1">2.8</td></tr><tr><td rowspan="1" colspan="1"><italic>K<sub>r</sub></italic></td><td rowspan="1" colspan="1">0.9</td></tr><tr><td rowspan="1" colspan="1">CVTree</td><td rowspan="1" colspan="1">0.5</td></tr><tr><td rowspan="1" colspan="1">UA</td><td rowspan="1" colspan="1">572</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 1</td><td rowspan="1" colspan="1">4.2</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 10</td><td rowspan="1" colspan="1">7.6</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 20</td><td rowspan="1" colspan="1">4.2</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 50</td><td rowspan="1" colspan="1">21.4</td></tr></tbody></table><table-wrap-foot><fn id="btu331-TF1"><p><italic>Note: Spaced words</italic> was run with 100 random patterns of varying length as described by <xref rid="btu331-B17" ref-type="bibr">Leimeister <italic>et al.</italic> (2014)</xref>. For <italic>Clustal W</italic> and <italic>Clustal</italic> Ω, the time for calculating a multiple alignment is shown; for the six alignment-free methods the time for calculating pairwise distances is shown.</p></fn></table-wrap-foot></table-wrap>
<table-wrap id="btu331-T2" position="float"><label>Table 2.</label><caption><p>Program run time for different methods on a set of 32 genome sequences of total length 135 <italic>mb</italic> from various <italic>Roseobacter</italic> species</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Method</th><th rowspan="1" colspan="1">Runtime (<italic>s</italic>)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">17-mer</td><td rowspan="1" colspan="1">34.9</td></tr><tr><td rowspan="1" colspan="1"><italic>FFP</italic>, <italic>l</italic> = 24</td><td rowspan="1" colspan="1">9022</td></tr><tr><td rowspan="1" colspan="1"><italic>Spaced words</italic>, 100 patterns, <italic>k</italic> = 17</td><td rowspan="1" colspan="1">3617</td></tr><tr><td rowspan="1" colspan="1"><italic>ACS</italic></td><td rowspan="1" colspan="1">531</td></tr><tr><td rowspan="1" colspan="1"><italic>K<sub>r</sub></italic></td><td rowspan="1" colspan="1">206</td></tr><tr><td rowspan="1" colspan="1">CVTree</td><td rowspan="1" colspan="1">84</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 1</td><td rowspan="1" colspan="1">784</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 10</td><td rowspan="1" colspan="1">1302</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 50</td><td rowspan="1" colspan="1">3158</td></tr><tr><td rowspan="1" colspan="1"><italic>kmacs</italic>, <italic>k</italic> = 100</td><td rowspan="1" colspan="1">5433</td></tr></tbody></table><table-wrap-foot><fn id="btu331-TF2"><p><italic>Note:</italic> Parameters for <italic>spaced words</italic> as in <xref ref-type="table" rid="btu331-T1">Table 1</xref>.</p></fn></table-wrap-foot></table-wrap></p>
    <p>The relatively long runtime of <italic>UA</italic> is partially because of the fact that this program is written in <italic>Java</italic>, while all other programs that we tested are written in <italic>C++</italic>. As expected, the multiple-alignment approaches <italic>Clustal W</italic> and <italic>Clustal</italic> Ω (<xref rid="btu331-B26" ref-type="bibr">Sievers <italic>et al.</italic>, 2011</xref>) were far slower than the alignment-free methods; the difference in speed between alignment-based and alignment-free methods was between three and four orders of magnitude. All test runs were done on a <italic>Intel Core i7 4820k</italic>, which we overclocked to <italic>4.5Ghz</italic>.</p>
    <p>As explained in Section 2.2, <italic>kmacs</italic> searches for each position <italic>i</italic> in one sequence the <italic>maximum</italic> substring starting at <italic>i</italic> that matches a substring in the second sequence. There can be more than one such maximal match, and <italic>all</italic> these matches are extended to <italic>k</italic>-mismatch common substrings. Thus, the runtime of <italic>kmacs</italic> depends on <italic>z</italic>, the average number of such maximal substring matches for a given position <italic>i</italic>. In principle, <italic>z</italic> can be large and the <italic>worst-case</italic> time complexity of our algorithm is therefore high. In practice, however, <italic>z</italic> is small, independent of sequence length and substitution probability. <xref ref-type="fig" rid="btu331-F9">Figure 9</xref> shows values of <italic>z</italic> for different sequence lengths and mutation frequencies.
<fig id="btu331-F9" position="float"><label>Fig. 9.</label><caption><p>Average number <italic>z</italic> of maximal exact matches starting at a position <italic>i</italic> in one sequence to a substring in a second sequence. We used simulated DNA sequences with different lengths and substitution frequencies</p></caption><graphic xlink:href="btu331f9p"/></fig></p>
    <p>Finally, we wanted to know how accurately our greedy heuristic approximates the <italic>exact</italic> maximal <italic>k</italic>-mismatch substring length. <xref ref-type="fig" rid="btu331-F10">Figure 10</xref> compares the average maximal <italic>k</italic>-mismatch substring length for varying substitution probabilities (<italic>a</italic>) as estimated with our heuristic and (<italic>b</italic>) calculated with a slow and exact algorithm. The figure shows that our heuristic is clearly suboptimal. But the goal of our project was not so much to precisely estimate the maximal <italic>k</italic>-mismatch substring lengths, but rather to define a distance measure on sequences that can be efficiently calculated and that can be used to obtain biologically meaningful results. Therefore, we think that the discrepancies between the optimal substring lengths and the values estimated by our heuristic are acceptable. <xref ref-type="fig" rid="btu331-F10">Figure 10</xref> suggests, however, that better estimates of the <italic>k</italic>-mismatch common substring lengths might improve the sensitivity of <italic>kmacs</italic> on divergent sequence sets because the curves for the exact solutions converge at higher substitution frequencies. In fact, on the mitochondrial genomes that we used as benchmark data, an exact algorithm led to better phylogenetic trees than our greedy heuristic (<ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu331/-/DC1">Supplementary Material</ext-link>). Therefore, it may be worthwhile to develop heuristics that approximate the maximal <italic>k</italic>-mismatch substring lengths more accurately.
<fig id="btu331-F10" position="float"><label>Fig. 10.</label><caption><p>Average common <italic>k</italic>-mismatch substring lengths depending on the substitution frequency in simulated DNA sequences, estimated with our greedy heuristic (lower curve) and calculated with an exact algorithm (upper curve) for various values of <italic>k</italic></p></caption><graphic xlink:href="btu331f10p"/></fig></p>
  </sec>
  <sec>
    <title>6 CONCLUSION</title>
    <p>Most alignment-free approaches to sequence analysis are based on <italic>exact</italic> word matches. In this article, we presented a novel alignment-free algorithm that takes mismatches into account. This is similar in spirit to the <italic>spaced</italic><italic>-</italic><italic>words</italic> approach that we previously proposed (<xref rid="btu331-B17" ref-type="bibr">Leimeister <italic>et al.</italic>, 2014</xref>). But while <italic>spaced words</italic> uses word pairs of a <italic>fixed</italic> length with possible mismatches at pre-defined positions, <italic>kmacs</italic> considers <italic>maximal</italic> substring matches with <italic>k</italic> mismatches at arbitrary positions. In the <italic>spaced</italic><italic>-</italic><italic>words</italic> approach, the number of <italic>match positions</italic> in the underlying patterns is a critical parameter for the performance of the method. In contrast, in <italic>kmacs</italic>, there seems to be a fairly large range of values for <italic>k</italic> that lead to high-quality results, as shown by our test results. <italic>kmacs</italic> seems therefore less sensitive to user-defined parameters.</p>
    <p>The implementation of our approach using <italic>generalized enhanced suffix arrays</italic> enables us to analyse large sequence sets efficiently. Still, the program <italic>K<sub>r</sub></italic> is roughly one order of magnitude faster than <italic>kmacs</italic>. One reason for this is that <italic>K<sub>r</sub></italic> uses <italic>one single</italic> generalized suffix tree representing <italic>all</italic> input sequences, which can be calculated in time proportional to the number of sequences (<xref rid="btu331-B6" ref-type="bibr">Domazet-Lošo and Haubold, 2009</xref>). In contrast, <italic>kmacs</italic> calculates one generalized enhanced suffix array for <italic>each pair</italic> of sequences, so its run time is <italic>quadratic</italic> in the number of sequences. On the other hand, calculating suffix arrays for two sequences at a time is less memory consuming, as one does not need to keep the suffix array for <italic>all</italic> input sequences simultaneously in main memory. Thus, our approach can be applied to larger datasets than <italic>K<sub>r</sub></italic>.</p>
    <p>The two approaches that we developed, <italic>kmacs</italic> and <italic>spaced words</italic>, are slower than the corresponding approaches based on exact matches, <italic>ACS</italic> and the generic <italic>k</italic>-mer approach. Our new approaches, however, produce significantly better results than those established methods. Our test results suggest that <italic>spaced words</italic> performs slightly better than <italic>kmacs</italic> on genomic sequences, whereas on protein sequences, <italic>kmacs</italic> is superior.</p>
    <p>In our program evaluation, we used DNA sequence sets with large evolutionary distances. On these sequences, our new alignment-free methods performed better than established methods that rely on exact word matches. Algorithms using exact matches, on the other hand, seem to work better on smaller evolutionary distances. <italic>K<sub>r</sub></italic>, for example, performs best on evolutionary distances of up to 0.6 substitutions per site (<xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic>, 2009</xref>). Similarly, we observed that on closely related DNA sequences, <italic>kmacs</italic> produces sometimes best results with <italic>k</italic> = 0, i.e. without mismatches (unpublished results). It seems therefore best to apply <italic>kmacs</italic> to distantly related sequence sets, while methods such as <italic>K<sub>r</sub></italic> and <italic>ACS</italic> may be preferred on evolutionarily more closely related sequences.</p>
    <p>In biological sequences, substitutions are more frequent than insertions and deletions. Consequently, <italic>exact</italic> matches between local homologies can usually be extended until the first <italic>substitution</italic> is reached. The average length of longest common substrings and of shortest unique substrings, respectively, can therefore be used to estimate <italic>substitution probabilities</italic> (<xref rid="btu331-B14" ref-type="bibr">Haubold <italic>et al.</italic>, 2009</xref>). This is similar for <italic>kmacs</italic> as long as <italic>k</italic> is small enough. In this case, all <italic>k</italic> mismatches are likely to be used up in a <italic>k</italic>-mismatch common substring extension <italic>before</italic> the first indel occurs. Thus, the average length of the longest <italic>k</italic>-mismatch common substrings depends on the frequency of mismatches and could be used to estimate substitution probabilities, just as in <italic>K<sub>r</sub></italic>.</p>
    <p>In contrast, if <italic>k</italic> is sufficiently large, substring matches between local homologies are essentially extended until the first <italic>indel</italic> occurs. From this point on, the mismatch frequency is high and the remaining mismatches will be used up quickly. So in this situation, the average <italic>k</italic>-mismatch substring length depends on the frequency of <italic>indels</italic> rather than on the frequency of substitutions. This may explain why <italic>ACS</italic> and <italic>K<sub>r</sub></italic> work well on closely related sequences, while <italic>kmacs</italic> is superior on distantly related sequences where the frequency of indels may be a better measure for evolutionary distances than the frequency of mismatches.</p>
    <p>In our study, we used alignment-free methods to reconstruct phylogenetic trees and evaluated the quality of these trees. But phylogeny reconstruction is only one important application of sequence comparison. Clustering, classification and remote-homology detection are other fundamental challenges in DNA and protein sequence analysis. With the rapidly growing size of sequence databases, alignment-free methods have become indispensable for these tasks (<xref rid="btu331-B4" ref-type="bibr">Comin and Verzotto, 2012</xref>; <xref rid="btu331-B15" ref-type="bibr">Hauser <italic>et al.</italic>, 2013</xref>; <xref rid="btu331-B19" ref-type="bibr">Lingner and Meinicke, 2006</xref>). Given the speed of <italic>kmacs</italic> and the quality of the phylogenetic trees that we could produce with it, our approach should be useful not only for fast phylogeny reconstruction, but also for other tasks in comparative sequence analysis.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_30_14_2000__index.html"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors want to thank Bernhard Haubold, Sebastian Horwege and Manuel Landesfeind for useful comments and discussions as well as Sebastian Lindner, Martin Schöneich and Marcus Boden for providing datasets used in this study.</p>
    <p><italic>Conflicts of Interest</italic>: none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu331-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abouelhoda</surname>
            <given-names>MI</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Replacing suffix trees with enhanced suffix arrays</article-title>
        <source>J. Discrete Algorithms</source>
        <year>2004</year>
        <volume>2</volume>
        <issue>1</issue>
        <fpage>53</fpage>
        <lpage>86</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B2">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Babenko</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Starikovskaya</surname>
            <given-names>TA</given-names>
          </name>
        </person-group>
        <article-title>Computing longest common substrings via suffix arrays</article-title>
        <source>Computer Science - Theory and Applications, volume 5010 of Lecture Notes in Computer Science</source>
        <year>2008</year>
        <publisher-loc>Heidelberg</publisher-loc>
        <publisher-name>Springer: Berlin</publisher-name>
        <fpage>64</fpage>
        <lpage>75</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B3">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Boden</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Alignment-free sequence comparison with spaced <italic>k</italic>-mers</article-title>
        <source>Proceedings German Conference on Bioinformatics (GCB’13)</source>
        <year>2013</year>
        <publisher-name>OpenAccess Series in Informatics</publisher-name>
        <fpage>21</fpage>
        <lpage>31</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Comin</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Verzotto</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Alignment-free phylogeny of whole genomes using underlying subwords</article-title>
        <source>Algorithms Mol. Biol.</source>
        <year>2012</year>
        <volume>7</volume>
        <fpage>34</fpage>
        <pub-id pub-id-type="pmid">23216990</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Didier</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Variable length local decoding and alignment-free sequence comparison</article-title>
        <source>Theor. Comput. Sci.</source>
        <year>2012</year>
        <volume>462</volume>
        <fpage>1</fpage>
        <lpage>11</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Domazet-Lošo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Haubold</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Efficient estimation of pairwise distances between genomes</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>3221</fpage>
        <lpage>3227</lpage>
        <pub-id pub-id-type="pmid">19825795</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Evolutionary trees from DNA sequences:a maximum likelihood approach</article-title>
        <source>J. Mol. Evol.</source>
        <year>1981</year>
        <volume>17</volume>
        <fpage>368</fpage>
        <lpage>376</lpage>
        <pub-id pub-id-type="pmid">7288891</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>PHYLIP - Phylogeny Inference Package (Version 3.2)</article-title>
        <source>Cladistics</source>
        <year>1989</year>
        <volume>5</volume>
        <fpage>164</fpage>
        <lpage>166</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B9">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fischer</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Inducing the LCP-array</article-title>
        <source>Proceedings of 12th Algorithms and Data Structures Symposium, Lecture Notes in Computer Science 6844</source>
        <year>2011</year>
        <fpage>374</fpage>
        <lpage>385</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B10">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fischer</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Heun</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>Theoretical and practical improvements on the RMQ-problem, with applications to LCA and LCE</article-title>
        <source>Proceedings of the 17th Annual Symposium on Combinatorial Pattern Matching, Lecture Notes in Computer Science 4009</source>
        <year>2006</year>
        <fpage>36</fpage>
        <lpage>48</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B11">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fischer</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Heun</surname>
            <given-names>V</given-names>
          </name>
        </person-group>
        <article-title>A new succinct representation of RMQ-information and improvements in the enhanced suffix array</article-title>
        <source>Proceedings of the International Symposium on Combinatorics, Algorithms, Probabilistic and Experimental Methodologies, Lecture Notes in Computer Science 4614</source>
        <year>2007</year>
        <fpage>459</fpage>
        <lpage>470</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Harel</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Tarjan</surname>
            <given-names>RE</given-names>
          </name>
        </person-group>
        <article-title>Fast algorithms for finding nearest common ancestor</article-title>
        <source>SIAM J. Comput.</source>
        <year>1984</year>
        <volume>13</volume>
        <fpage>338</fpage>
        <lpage>355</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Haubold</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Genome comparison without alignment using shortest unique substrings</article-title>
        <source>BMC Bioinformatics</source>
        <year>2005</year>
        <volume>6</volume>
        <fpage>123</fpage>
        <pub-id pub-id-type="pmid">15910684</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Haubold</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Estimating mutation distances from unaligned genomes</article-title>
        <source>J. Comput. Biol.</source>
        <year>2009</year>
        <volume>16</volume>
        <fpage>1487</fpage>
        <lpage>1500</lpage>
        <pub-id pub-id-type="pmid">19803738</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hauser</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>kclust: fast and sensitive clustering of large protein sequence databases</article-title>
        <source>BMC Bioinformatics</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>248</fpage>
        <pub-id pub-id-type="pmid">23945046</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Horwege</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title><italic>Spaced words</italic> and <italic>kmacs</italic>: fast alignment-free sequence comparison based on inexact word matches</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2014</year>
        <comment>[Epub ahead of print, doi:10.1093/nar/gku398]</comment>
      </element-citation>
    </ref>
    <ref id="btu331-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Leimeister</surname>
            <given-names>CA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fast alignment-free sequence comparison using spaced-word frequencies</article-title>
        <source>Bioinformatics</source>
        <year>2014</year>
        <volume>30</volume>
        <fpage>1991</fpage>
        <lpage>1999</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lin</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Divergence measures based on the shannon entropy</article-title>
        <source>IEEE Trans. Inf. Theory</source>
        <year>1991</year>
        <volume>37</volume>
        <fpage>145</fpage>
        <lpage>151</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lingner</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Meinicke</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Remote homology detection based on oligomer distances</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <fpage>2224</fpage>
        <lpage>2231</lpage>
        <pub-id pub-id-type="pmid">16837522</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B20">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Manber</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Myers</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Suffix arrays: a new method for on-line string searches</article-title>
        <source>Proceedings of the first annual ACM-SIAM symposium on Discrete algorithms, SODA’90</source>
        <year>1990</year>
        <fpage>319</fpage>
        <lpage>327</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Newton</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Genome characteristics of a generalist marine bacterial lineage</article-title>
        <source>ISME J</source>
        <year>2010</year>
        <volume>4</volume>
        <fpage>784</fpage>
        <lpage>798</lpage>
        <pub-id pub-id-type="pmid">20072162</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B22">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Nong</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Linear suffix array construction by almost pure induced-sorting</article-title>
        <source>Proceedings of 19th IEEE Data Compression Conference (IEEE DCC)</source>
        <year>2009</year>
        <fpage>193</fpage>
        <lpage>202</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Qi</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>CVTree: a phylogenetic tree reconstruction tool based on whole genomes</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2004</year>
        <volume>32</volume>
        <issue>Suppl. 2</issue>
        <fpage>W45</fpage>
        <lpage>W47</lpage>
        <pub-id pub-id-type="pmid">15215347</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Robinson</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Foulds</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Comparison of phylogenetic trees</article-title>
        <source>Math. Biosci.</source>
        <year>1981</year>
        <volume>53</volume>
        <fpage>131</fpage>
        <lpage>147</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B25">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Saitou</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Nei</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>1987</year>
        <volume>4</volume>
        <fpage>406</fpage>
        <lpage>425</lpage>
        <pub-id pub-id-type="pmid">3447015</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sievers</surname>
            <given-names>F</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Fast, scalable generation of high-quality protein multiple sequence alignments using Clustal Omega</article-title>
        <source>Mol. Syst. Biol.</source>
        <year>2011</year>
        <volume>7</volume>
        <fpage>539</fpage>
        <pub-id pub-id-type="pmid">21988835</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B27">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sims</surname>
            <given-names>GE</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Alignment-free genome comparison with feature frequency profiles (FFP) and optimal resolutions</article-title>
        <source>Proc. Natl Acad. Sci.</source>
        <year>2009</year>
        <volume>106</volume>
        <fpage>2677</fpage>
        <lpage>2682</lpage>
        <pub-id pub-id-type="pmid">19188606</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B28">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stoye</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Rose: generating sequence families</article-title>
        <source>Bioinformatics</source>
        <year>1998</year>
        <volume>14</volume>
        <fpage>157</fpage>
        <lpage>163</lpage>
        <pub-id pub-id-type="pmid">9545448</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B29">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>JD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1994</year>
        <volume>22</volume>
        <fpage>4673</fpage>
        <lpage>4680</lpage>
        <pub-id pub-id-type="pmid">7984417</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B30">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Thompson</surname>
            <given-names>JD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>BAliBASE 3.0: latest developments of the multiple sequence alignment benchmark</article-title>
        <source>Proteins</source>
        <year>2005</year>
        <volume>61</volume>
        <fpage>127</fpage>
        <lpage>136</lpage>
        <pub-id pub-id-type="pmid">16044462</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B31">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ukkonen</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>On-line construction of suffix trees</article-title>
        <source>Algorithmica</source>
        <year>1995</year>
        <volume>14</volume>
        <fpage>249</fpage>
        <lpage>260</lpage>
      </element-citation>
    </ref>
    <ref id="btu331-B32">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ulitsky</surname>
            <given-names>I</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The average common substring approach to phylogenomic reconstruction</article-title>
        <source>J. Comput. Biol.</source>
        <year>2006</year>
        <volume>13</volume>
        <fpage>336</fpage>
        <lpage>350</lpage>
        <pub-id pub-id-type="pmid">16597244</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B33">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vinga</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Almeida</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Alignment-free sequence comparison—a review</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>4</issue>
        <fpage>513</fpage>
        <lpage>523</lpage>
        <pub-id pub-id-type="pmid">12611807</pub-id>
      </element-citation>
    </ref>
    <ref id="btu331-B34">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Weiner</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Linear pattern matching algorithms</article-title>
        <source>Proceedings of the 14th IEEE Symposium on Switching and Automata Theory</source>
        <year>1973</year>
        <fpage>1</fpage>
        <lpage>11</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
