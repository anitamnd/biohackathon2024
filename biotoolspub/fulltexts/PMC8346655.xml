<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">8346655</article-id>
    <article-id pub-id-type="pmid">34252940</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btab330</article-id>
    <article-id pub-id-type="publisher-id">btab330</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Topology-based sparsification of graph annotations</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Danciu</surname>
          <given-names>Daniel</given-names>
        </name>
        <aff><institution>Department of Computer Science, Biomedical Informatics Group, ETH Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Biomedical Informatics Research, University Hospital Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <xref rid="btab330-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Karasikov</surname>
          <given-names>Mikhail</given-names>
        </name>
        <aff><institution>Department of Computer Science, Biomedical Informatics Group, ETH Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Biomedical Informatics Research, University Hospital Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Swiss Institute of Bioinformatics</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <xref rid="btab330-FM1" ref-type="author-notes"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Mustafa</surname>
          <given-names>Harun</given-names>
        </name>
        <aff><institution>Department of Computer Science, Biomedical Informatics Group, ETH Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Biomedical Informatics Research, University Hospital Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Swiss Institute of Bioinformatics</institution>, Zurich, <country country="CH">Switzerland</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Kahles</surname>
          <given-names>André</given-names>
        </name>
        <aff><institution>Department of Computer Science, Biomedical Informatics Group, ETH Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Biomedical Informatics Research, University Hospital Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Swiss Institute of Bioinformatics</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <xref rid="btab330-cor1" ref-type="corresp"/>
        <!--andre.kahles@inf.ethz.ch-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Rätsch</surname>
          <given-names>Gunnar</given-names>
        </name>
        <aff><institution>Department of Computer Science, Biomedical Informatics Group, ETH Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Biomedical Informatics Research, University Hospital Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Swiss Institute of Bioinformatics</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <aff><institution>Department of Biology, ETH Zurich</institution>, Zurich, <country country="CH">Switzerland</country></aff>
        <xref rid="btab330-cor1" ref-type="corresp"/>
        <!--raetsch@inf.ethz.ch-->
      </contrib>
    </contrib-group>
    <author-notes>
      <fn id="btab330-FM1">
        <p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint Authors.</p>
      </fn>
      <corresp id="btab330-cor1">To whom correspondence should be addressed. <email>raetsch@inf.ethz.ch</email> or <email>andre.kahles@inf.ethz.ch</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2021-07-12">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>12</day>
      <month>7</month>
      <year>2021</year>
    </pub-date>
    <volume>37</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2021 Proceedings</issue-title>
    <fpage>i169</fpage>
    <lpage>i176</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2021. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2021</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btab330.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Since the amount of published biological sequencing data is growing exponentially, efficient methods for storing and indexing this data are more needed than ever to truly benefit from this invaluable resource for biomedical research. Labeled de Bruijn graphs are a frequently-used approach for representing large sets of sequencing data. While significant progress has been made to succinctly represent the graph itself, efficient methods for storing labels on such graphs are still rapidly evolving.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>In this article, we present RowDiff, a new technique for compacting graph labels by leveraging expected similarities in annotations of vertices adjacent in the graph. RowDiff can be constructed in linear time relative to the number of vertices and labels in the graph, and in space proportional to the graph size. In addition, construction can be efficiently parallelized and distributed, making the technique applicable to graphs with trillions of nodes. RowDiff can be viewed as an intermediary sparsification step of the original annotation matrix and can thus naturally be combined with existing generic schemes for compressed binary matrices. Experiments on 10 000 RNA-seq datasets show that RowDiff combined with multi-BRWT results in a 30% reduction in annotation footprint over Mantis-MST, the previously known most compact annotation representation. Experiments on the sparser Fungi subset of the RefSeq collection show that applying RowDiff sparsification reduces the size of individual annotation columns stored as compressed bit vectors by an average factor of 42. When combining RowDiff with a multi-BRWT representation, the resulting annotation is 26 times smaller than Mantis-MST.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>RowDiff is implemented in C++ within the MetaGraph framework. The source code and the data used in the experiments are publicly available at <ext-link xlink:href="https://github.com/ratschlab/row_diff" ext-link-type="uri">https://github.com/ratschlab/row_diff</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Swiss National Science Foundation</institution>
            <institution-id institution-id-type="DOI">10.13039/501100001711</institution-id>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
        <award-id>407540_167331</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>ETH core funding</institution>
          </institution-wrap>
          <!-- oupReleaseDelayRemoved from OA Article (00|0) -->
        </funding-source>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>The exponential increase in global sequencing capacity (<xref rid="btab330-B25" ref-type="bibr">Stephens <italic toggle="yes">et al.</italic>, 2015</xref>) and the resulting growth of public sequence repositories have created an urgent need for the development of compact representation schemes of biological sequences. Such schemes should not only maintain all relevant biological sequence variation but also provide fast access for sequence search and extraction. After initial attempts focused on the lossless compression of full sequences, e.g. using the Burrows–Wheeler transform (<xref rid="btab330-B9" ref-type="bibr">Cox <italic toggle="yes">et al.</italic>, 2012</xref>), the field soon turned toward representing a proxy of the input sequences instead: the sets of all <italic toggle="yes">k</italic>-mers contained in them. For this, any recurrent occurrence of a substring of length <italic toggle="yes">k</italic> in the input is represented by a unique <italic toggle="yes">k</italic>-mer, forming a <italic toggle="yes">k</italic>-mer set. A query of a given sequence against the input text can then be replaced by exact <italic toggle="yes">k</italic>-mer matching against the set. Longer strings are queried as a succession of <italic toggle="yes">k</italic>-mers. Although it is a loss representation of the input (as, e.g. repeats longer than <italic toggle="yes">k</italic> are collapsed), constructing <italic toggle="yes">k</italic>-mer sets has proved highly useful in practice (<xref rid="btab330-B6" ref-type="bibr">Bradley <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab330-B7" ref-type="bibr">Breitwieser <italic toggle="yes">et al.</italic>, 2018</xref>; <xref rid="btab330-B15" ref-type="bibr">Karasikov <italic toggle="yes">et al.</italic>, 2020a</xref>; <xref rid="btab330-B22" ref-type="bibr">Ondov <italic toggle="yes">et al.</italic>, 2016</xref>).</p>
    <sec>
      <title>1.1 Representation of <italic toggle="yes">k</italic>-mer sets</title>
      <p>Various representations have been developed to balance the trade-off between the space taken by the <italic toggle="yes">k</italic>-mer set and query time or representation accuracy. Conceptually, the <italic toggle="yes">k</italic>-mer set fully defines a vertex-centric de Bruijn graph, where each <italic toggle="yes">k</italic>-mer forms a vertex and arcs are represented implicitly, based on whether any two vertices share a <italic toggle="yes">k—</italic>1 overlap. The simplest representations are bitmaps or (perfect) hash-tables that indicate the presence or absence of any possible <italic toggle="yes">k</italic>-mer over the input alphabet in the input text. While non-optimal in space, they offer constant-time query of <italic toggle="yes">k</italic>-mers. More compact representations use approximate membership query data structures to probabilistically represent a de Bruijn graph (<xref rid="btab330-B3" ref-type="bibr">Benoit <italic toggle="yes">et al.</italic>, 2015</xref>; <xref rid="btab330-B8" ref-type="bibr">Chikhi and Rizk, 2013</xref>) or utilize succinct de Bruijn graphs (a generalization of the Burrows–Wheeler transform) (<xref rid="btab330-B5" ref-type="bibr">Bowe <italic toggle="yes">et al.</italic>, 2012</xref>), which usually require &lt;1 byte per input <italic toggle="yes">k</italic>-mer over the nucleotide alphabet <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>1.2 de Bruijn graph annotation</title>
      <p>A major limitation of the above representations is that the identities of any sequence labels contained in the input text set are lost. To alleviate this, the concept of colored de Bruijn graphs emerged (<xref rid="btab330-B14" ref-type="bibr">Iqbal <italic toggle="yes">et al.</italic>, 2012</xref>) (otherwise known as annotated or labeled de Bruijn graphs), allowing for the representation of additional annotations per <italic toggle="yes">k</italic>-mer. These annotations can either be stored in conjunction with the <italic toggle="yes">k</italic>-mers or be organized in a separate data structure, using the <italic toggle="yes">k</italic>-mer representation only as an index space. Although the first option is used by a number of conceptually interesting methods, such as Mantis (<xref rid="btab330-B23" ref-type="bibr">Pandey <italic toggle="yes">et al.</italic>, 2018</xref>) that uses counting quotient filters to represent the <italic toggle="yes">k</italic>-mers linked to an annotation identifier, here we will only focus on the second option, as it allows for the connection of arbitrary annotations to the <italic toggle="yes">k</italic>-mer set, without re-processing the <italic toggle="yes">k</italic>-mer index.</p>
      <p>Conceptually, the set of annotations is a relation between <italic toggle="yes">k</italic>-mers and labels that can be represented as a binary matrix, where the <italic toggle="yes">k</italic>-mer set indexes the rows and each annotation label specifies a column. Any entry (<italic toggle="yes">i</italic>, <italic toggle="yes">j</italic>) in the matrix represents the relation of <italic toggle="yes">k</italic>-mer <italic toggle="yes">i</italic> and annotation <italic toggle="yes">j</italic>. Different methods have been suggested to compress this annotation matrix in a way that still allows for efficient query. VARI (<xref rid="btab330-B18" ref-type="bibr">Muggli <italic toggle="yes">et al.</italic>, 2017</xref>, <xref rid="btab330-B19" ref-type="bibr">2019</xref>) concatenates the rows of the annotation matrix and compresses the result using either an RRR (<xref rid="btab330-B24" ref-type="bibr">Raman <italic toggle="yes">et al.</italic>, 2007</xref>) or Elias–Fano coding (<xref rid="btab330-B10" ref-type="bibr">Elias, 1974</xref>; <xref rid="btab330-B11" ref-type="bibr">Fano, 1971</xref>).</p>
      <p>Rainbowfish (<xref rid="btab330-B1" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2017</xref>) takes advantage of high redundancy in matrix rows by computing a frequency code for the unique rows, compressing the unique rows in a matrix ordered by these codes and then representing the original matrix as a variable-length code vector. However, this method and other frequency coding-based approaches become less effective for datasets with greater levels of noise or inter-sample variability. Multi-BRWT (<xref rid="btab330-B16" ref-type="bibr">Karasikov <italic toggle="yes">et al.</italic>, 2020b</xref>) compresses the matrix in a hierarchical tree structure exploiting column similarity, but leaving the possible row redundancy unexploited. Alongside these methods, there is a rich literature of different compressors for graph annotations developed over the years, each improving on the compression performance of previous methods (<xref rid="btab330-B4" ref-type="bibr">Bingmann <italic toggle="yes">et al.</italic>, 2019</xref>; <xref rid="btab330-B13" ref-type="bibr">Harris and Medvedev, 2020</xref>; <xref rid="btab330-B17" ref-type="bibr">Marchet <italic toggle="yes">et al.</italic>, 2021</xref>). All of these methods share the common property that they act as general purpose binary matrix compressors, and thus, they do not take into account any particular domain knowledge in their construction.</p>
    </sec>
    <sec>
      <title>1.3 Leveraging graph topology to improve annotation compression</title>
      <p>While the methods mentioned above rely solely on similarities between annotation matrix elements to achieve their compression, a few have additionally leveraged graph topology to increase their compression potential. The Bloom filter correction method introduced by (<xref rid="btab330-B20" ref-type="bibr">Mustafa <italic toggle="yes">et al.</italic>, 2019</xref>) encodes the columns of the annotation matrix in Bloom filters with high false positive rate. Assuming that all vertices within a graph unitig (a path in which all vertices except for the first and last have in- and out-degree 1) share identical annotations, a row in the annotation matrix (corresponding to all vertices from the same unitig in the graph) is computed as the bit-wise AND of the rows stored for every vertex of that unitig. While achieving high accuracy in decoding row annotations, the corrected Bloom filters are not able to losslessly decode the rows of the encoded annotation matrix. In addition, the authors introduce a lossless approach based on wavelet tries which leverages graph backbone paths to improve compression performance. However, these paths must be provided by the user and cannot be computed automatically by the method.</p>
      <p>The more recently introduced Mantis-MST method (<xref rid="btab330-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>) constructs an annotation graph with nodes representing the unique rows of the annotation matrix. In this annotation graph, a weighted edge between two nodes <italic toggle="yes">v</italic><sub>1</sub> and <italic toggle="yes">v</italic><sub>2</sub> is created if there exist adjacent vertices <italic toggle="yes">s</italic><sub>1</sub> and <italic toggle="yes">s</italic><sub>2</sub> in the underlying de Bruijn graph whose annotations are represented by <italic toggle="yes">v</italic><sub>1</sub> and <italic toggle="yes">v</italic><sub>2</sub>, respectively. The weight of this edge (<italic toggle="yes">v</italic><sub>1</sub>, <italic toggle="yes">v</italic><sub>2</sub>) is then set to the Hamming distance of the unique rows <italic toggle="yes">v</italic><sub>1</sub> and <italic toggle="yes">v</italic><sub>2</sub>. Mantis-MST computes the minimal spanning tree of the annotation graph and represents the annotation of a node as it is bit-wise XOR with the annotation of its parent node in the spanning tree, while only the annotation of the root node is represented explicitly.</p>
    </sec>
    <sec>
      <title>1.4 Our contribution</title>
      <p>Despite the wide range of approaches summarized above that address the label-compression-problem for colored de Bruijn graphs, further improvements are needed to allow for applications in a multi-cohort, multi-metagenome (<xref rid="btab330-B26" ref-type="bibr">Tully <italic toggle="yes">et al.</italic>, 2018</xref>) or population-scale context (<xref rid="btab330-B6" ref-type="bibr">Bradley <italic toggle="yes">et al.</italic>, 2019</xref>). A key factor for reducing representation size is to leverage local similarities arising from evolutionary relationships of the input sequences. We present a new scheme for representing graph annotations, RowDiff, which takes advantage of similarities between the annotations of neighboring vertices to compress annotation matrices. RowDiff can be constructed using <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> bits of memory, where <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the compressed size of the largest column in the annotation matrix and <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the size of the memory representation of the graph and in this case is &lt;<inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mn>4</mml:mn><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> bits (<xref rid="btab330-B5" ref-type="bibr">Bowe <italic toggle="yes">et al.</italic>, 2012</xref>), where <italic toggle="yes">m</italic> is the number of <italic toggle="yes">k</italic>-mers, thus making it suitable for annotating virtually arbitrarily large graphs. Since RowDiff is a transformation of the input annotation matrix attempting to increase its sparsity, RowDiff can be naturally chained with any generic scheme for compressed binary matrix representation to achieve further improvements in compression performance. We demonstrate the compression performance of RowDiff relative to the state-of-the-art lossless Rainbow-MST and multi-BRWT methods on datasets representing different annotation matrix densities.</p>
      <p>In the next sections, we define the underlying concepts (Sections 2.1 and 2.2) and detail this methods for construction (Sections 2.3 to 2.4) and querying (Section 2.5) of the RowDiff data structures. We then describe the test datasets (Section 3.1) and study the representation sizes (Sections 3.2, 3.3 and 3.4), construction time (Section 3.5) and query time (Section 3.6) of RowDiff-compressed annotations. Finally, we discuss limitations and directions for future work (Section 4).</p>
    </sec>
  </sec>
  <sec>
    <title>2 Materials and method</title>
    <sec>
      <title>2.1 Notation</title>
      <p>We will operate in the following setting. Let <italic toggle="yes">k</italic> be a positive integer. The order <italic toggle="yes">k</italic> de Bruijn graph over a set of sequences <italic toggle="yes">S</italic>, denoted by <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, is a directed graph <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, whose vertices <italic toggle="yes">V<sub>k</sub></italic> are the set of all distinct sub-strings of length <italic toggle="yes">k</italic> of sequences in <italic toggle="yes">S</italic> (<italic toggle="yes">k</italic>-mers), and an arc links <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, if <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>:</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>:</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> denotes the sub-sequence of <italic toggle="yes">s</italic> from position <italic toggle="yes">i</italic> up to and including position <italic toggle="yes">j</italic>. We denote with <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> the in- and out-degree of a vertex, respectively. Vertices <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> are called <italic toggle="yes">source vertices</italic> and vertices <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> are called <italic toggle="yes">sink vertices</italic>.</p>
      <p>Given an arbitrary set of labels <italic toggle="yes">L</italic>, an <italic toggle="yes">annotation</italic> for a de Bruijn graph <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a relation <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">A</mml:mi><mml:mo>⊂</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>×</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>, which assigns to each vertex <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> a set of labels, <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>⊂</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>. We will trivially represent <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mi mathvariant="script">A</mml:mi></mml:math></inline-formula> using a binary matrix <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, denote with <italic toggle="yes">A<sub>i</sub></italic> the <italic toggle="yes">i</italic>-th row of <italic toggle="yes">A</italic> and with <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>⊕</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> the element-wise XOR of rows <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>.</p>
    </sec>
    <sec>
      <title>2.2 RowDiff-transformation</title>
      <p>RowDiff relies on the observation that adjacent vertices in the graph are likely similarly annotated, and thus, their respective rows in the annotation matrix <italic toggle="yes">A</italic> are similar as well. This implies that if <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, storing the difference between <italic toggle="yes">A<sub>u</sub></italic> and <italic toggle="yes">A<sub>v</sub></italic> may be more space efficient than storing <italic toggle="yes">A<sub>u</sub></italic>, i.e. <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>⊕</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&lt;</mml:mo><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> represents the number of set bits in row <italic toggle="yes">x</italic>.</p>
      <p>RowDiff is defined as a transformation that converts an annotation matrix <italic toggle="yes">A</italic> of a de Bruijn graph into a new, sparser, annotation matrix <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> of the same size and an additional anchor vector <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi><mml:mo>∈</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>, that is, <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>rd</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:mo> </mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msup><mml:mo>→</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula>. The anchor vector <bold><italic toggle="yes">a</italic></bold> stores which rows remain unchanged. We show that the original annotation matrix <italic toggle="yes">A</italic> can be reconstructed from the RowDiff-transformed matrix <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> and the anchor vector <bold><italic toggle="yes">a</italic></bold>. Empirically, the RowDiff-transformed matrix is significantly better compressible in the typical case where neighboring vertices have similar annotations. We develop an efficient algorithm for defining anchors and for computing the RowDiff-transform <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>rd</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and its inverse.</p>
      <p>For each vertex <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> we arbitrarily define its RowDiff successor as its lexicographically largest outgoing vertex <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, such that <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mi>v</mml:mi><mml:mo> </mml:mo><mml:mo>∀</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, if such <italic toggle="yes">u</italic> exists. RowDiff replaces each row <italic toggle="yes">A<sub>u</sub></italic> with the (likely sparser) delta relative to its RowDiff successor. For binary rows, the delta is simply the element-wise XOR, <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>u</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>⊕</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, while for non-binary rows, the delta could store the difference between the row and its successor. In this work, we focus on binary matrices. The previous equation implies that <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>u</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>u</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>⊕</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, which gives us a simple formula for recursively reconstructing the original row. In order to be able to reconstruct the original annotation <italic toggle="yes">A</italic> from <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>, some rows are left unchanged. A vertex <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for which the annotation is stored unchanged is called an <italic toggle="yes">anchor</italic> and its corresponding value in the anchor bit vector will be set to 1, <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Sink vertices do not have a RowDiff successor, and must thus be anchors.</p>
      <p><xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref> shows the implementation of the <italic toggle="yes">inverse</italic> transformation <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mtext>rd</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></inline-formula>, which reconstructs the original row <italic toggle="yes">A<sub>i</sub></italic> from the RowDiff representation <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.<boxed-text id="btab330-BOX1" position="float"><p><bold>Algorithm 1</bold> Row annotation reconstruction
</p><list list-type="order"><list-item><p><bold>function</bold> ReconstructAnnotation(i)</p></list-item><list-item><p>  row <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mo>←</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>  <bold>while</bold>  <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> = 0 <bold>do</bold>  ▹ current vertex is not an anchor</p></list-item><list-item><p>    i <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> succ(i)</p></list-item><list-item><p>    row <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> row ⊕ <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>  <bold>end while</bold></p></list-item><list-item><p>  <bold>return</bold> row</p></list-item><list-item><p><bold>end function</bold></p></list-item></list></boxed-text>Starting from any vertex in the de Bruijn graph, <xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref> defines a traversal leading to an anchor vertex, for which the annotation was not transformed. Since de Bruijn graphs may have cycles, additional anchor vertices might have to be assigned in order to break RowDiff cycles (those cycles where <italic toggle="yes">every</italic> vertex is a RowDiff successor relative to its predecessor in the cycle).<statement id="mthst1"><p><sc>Proposition</sc> 1. <italic toggle="yes"><xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref> finishes for every starting vertex, if and only if every sink vertex in the graph is an anchor and every RowDiff cycle contains at least one anchor vertex.</italic></p><p><sc>Proof</sc>. Assume the algorithm does not finish for a starting vertex <italic toggle="yes">i</italic>. This implies that <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">suc</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">succ<sup>k</sup></italic> is the <italic toggle="yes">k</italic>-th iterate of <italic toggle="yes">succ</italic>. Since the number of vertices in the graph is finite, there must exist <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="double-struck">N</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>≠</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, s.t. <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">suc</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>l</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">suc</mml:mi><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mi>m</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>l</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>m</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is a cycle and must therefore contain at least one anchor vertex, which contradicts the initial assumption. Proof of necessity is equally trivial. □</p></statement><statement id="mthst2"><p><sc>Proposition</sc> 2. <italic toggle="yes"><xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref> correctly reconstructs the original annotation row A<sub>i</sub> for every vertex</italic> <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p><p><sc>Proof</sc>. The algorithm computes <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo>⊕</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>⊕</mml:mo><mml:mo>⋯</mml:mo><mml:mo>⊕</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and thus, <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. By repeatedly reducing the last 2 terms using <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>⊕</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mi>p</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, the original equation is reduced to <italic toggle="yes">A<sub>i</sub></italic>, which is the desired value. □</p><p>Once the set of anchor vertices <bold><italic toggle="yes">a</italic></bold> satisfies Proposition 1, the RowDiff-transformed matrix <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> together with the anchor indicator bitmap <bold><italic toggle="yes">a</italic></bold> encode the original annotation matrix.</p></statement></p>
    </sec>
    <sec>
      <title>2.3 Anchor assignment</title>
      <p>In addition to the small set of anchors described in Proposition 1, we seek to cap the maximum RowDiff path length (i.e. a path taken by <xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref>) to a certain value <italic toggle="yes">M</italic> (typically between 10 and 100) by ensuring that at least every <italic toggle="yes">M</italic>-th vertex in a RowDiff path is an anchor, as described below. This guarantees that the number of iterations in <xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref> is bounded by a constant, and thus the average time complexity of reconstructing a single row is <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>l</mml:mi><mml:mo>·</mml:mo><mml:mi>M</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>l</mml:mi><mml:mo>≪</mml:mo><mml:mo>|</mml:mo><mml:mi>L</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the average number of set bits (labels) per row. At the same time, since anchor vertices require storing the original, less sparse annotation row, it is desirable to minimize the total number of anchor vertices in order to keep the popcount (and thus the compressed size) of the RowDiff annotation <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> small.</p>
      <p>The following anchor assignment algorithm allocates anchor vertices near-optimally in four steps as follows (<xref rid="btab330-BOX2" ref-type="boxed-text">Algorithm 2</xref>). First, we traverse RowDiff paths backwards (in parallel) starting from <italic toggle="yes">sink vertices</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S1</xref>). The backward traversal stops either when we reach a source vertex or when we reach a vertex <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, s.t. <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>u</mml:mi></mml:mrow></mml:math></inline-formula> for the previously traversed vertex <italic toggle="yes">u</italic> (<xref rid="btab330-F1" ref-type="fig">Fig. 1</xref>, top). Note, the traversal is not terminated when reaching a vertex with multiple incoming arcs, but explores each of them and continues to further traverse these RowDiff paths backwards. When the distance from the current vertex to the next assigned anchor in the current RowDiff path reaches <italic toggle="yes">M</italic>, the vertex is marked as an anchor. In practice, once the backward traversal is finished, the vast majority of the vertices has been traversed, and the anchor assignment is optimal, in the sense that no anchors are closer than <italic toggle="yes">M</italic> to each other. In the second step, we start at <italic toggle="yes">source vertices</italic> and traverse RowDiff paths forwards, i.e. paths of the form <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mtext>succ</mml:mtext></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>…</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S2</xref>). The traversal stops when we reach an already visited vertex. In the third step, we start traversing forward at all forks with unvisited vertices. After the third step, the only vertices that were not traversed must belong to a simple cycle (a cycle where all vertices have <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>+</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>v</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>). The fourth step traverses these cycles (in parallel). Each of these traversals sets an anchor every <italic toggle="yes">M</italic> vertices during the traversal. Since we visit each vertex only once, the time complexity of anchor assignment is <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <fig position="float" id="btab330-F1">
        <label>Fig. 1.</label>
        <caption>
          <p>Top: RowDiff traversal. When traversing backward to assign anchor vertices, the traversal stops at vertex <italic toggle="yes">u</italic>, because <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≠</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:math></inline-formula>. When traversing forward, the last outgoing vertex is selected. <bold>Bottom:</bold> Chained merge. Dark gray vertices are marked as nearAnchor. When traversing the light gray vertices, we merge into <italic toggle="yes">m</italic><sub>1</sub>, marked as nearAnchor, thus, no anchor is set. When traversing the blue vertices, an anchor must be set at <italic toggle="yes">m</italic><sub>2</sub>, as <italic toggle="yes">m</italic><sub>2</sub> is not marked as nearAnchor</p>
        </caption>
        <graphic xlink:href="btab330f1" position="float"/>
      </fig>
      <p>
        <boxed-text id="btab330-BOX2" position="float">
          <p><bold>Algorithm 2</bold> Anchor assignment
</p>
          <list list-type="order">
            <list-item>
              <p><bold>function</bold> AssignAnchors(<italic toggle="yes">M</italic>)</p>
            </list-item>
            <list-item>
              <p>  visited[] <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> {False} ▹ initialize mask of visited vertices</p>
            </list-item>
            <list-item>
              <p>  anchor[] <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> {False} ▹ initialize mask of anchor vertices</p>
            </list-item>
            <list-item>
              <p>  <bold>for all</bold>  <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mtext>Sinks</mml:mtext><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>parallel do</bold></p>
            </list-item>
            <list-item>
              <p>    anchor <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> TraverseBwd(<italic toggle="yes">s</italic>, visited, anchor, <italic toggle="yes">M</italic>)</p>
            </list-item>
            <list-item>
              <p>  <bold>for all</bold>  <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mtext>Sources</mml:mtext><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>parallel do</bold></p>
            </list-item>
            <list-item>
              <p>    anchor <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> TraverseFwd(<italic toggle="yes">s</italic>, visited, anchor, <italic toggle="yes">M</italic>)</p>
            </list-item>
            <list-item>
              <p>  <bold>for all</bold>  <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mtext>Forks</mml:mtext><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>parallel do</bold></p>
            </list-item>
            <list-item>
              <p>    anchor <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> TraverseFwd(<italic toggle="yes">s</italic>, visited, anchor, <italic toggle="yes">M</italic>)</p>
            </list-item>
            <list-item>
              <p>  <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mo>▹</mml:mo></mml:math></inline-formula> only vertices in simple cycles (no forks) left unvisited at this point</p>
            </list-item>
            <list-item>
              <p>  <bold>for all</bold>  <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mtext>Nodes</mml:mtext><mml:mo>(</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>parallel do</bold></p>
            </list-item>
            <list-item>
              <p>    anchor <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mo>←</mml:mo></mml:math></inline-formula> TraverseFwd(<italic toggle="yes">s</italic>, visited, anchor, <italic toggle="yes">M</italic>)</p>
            </list-item>
            <list-item>
              <p>  <bold>return</bold> anchor</p>
            </list-item>
            <list-item>
              <p>
                <bold>end function</bold>
              </p>
            </list-item>
          </list>
        </boxed-text>
      </p>
      <statement id="mthst3">
        <p><sc>Proposition</sc> 3. <italic toggle="yes">The anchors assigned by Algorithm 2 guarantee successful termination of <xref rid="btab330-BOX1" ref-type="boxed-text">Algorithm 1</xref> for any input vertex</italic> <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>.</p>
        <p><sc>Proof</sc>. Step 1 of the algorithm trivially guarantees that all sink vertices are anchor vertices. Steps 3 and 4 guarantee that all RowDiff cycles in the graph are traversed and at least one anchor vertex is set in each cycle. The conditions in Proposition 1 are thereby satisfied and Algorithm 1 finishes and successfully reconstructs <italic toggle="yes">A</italic> from <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula>.</p>
        <p>One important detail in the forward traversal step is handling the situation when the traversal stops due to merging into a visited vertex. Not setting an anchor in such cases may result in arbitrarily long paths with no anchors (when such merges are chained). Always setting an anchor at a merge will introduce unnecessary anchors and increase the annotation density. We handle merges with the following simple heuristic: use an additional bit vector, nearAnchor, to mark all vertices that are known to be at a distance smaller than <italic toggle="yes">M</italic> to an anchor vertex. During forward traversal, when hitting a visited merge vertex that is marked in nearAnchor, no anchor is set (<xref rid="btab330-F1" ref-type="fig">Fig. 1</xref>, bottom). A more optimal algorithm for deciding if a merge vertex should create an anchor would require labeling each vertex with the distance to its nearest anchor. In this implementation, we preferred the heuristic algorithm due to its significantly reduced space complexity.</p>
      </statement>
      <sec>
        <title>2.3.1 Anchor optimization</title>
        <p>To guarantee that none of the rows <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> in <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> have more set bits than the corresponding row <italic toggle="yes">A<sub>v</sub></italic> in the original annotation, we perform the following anchor optimization procedure. For each <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mi>v</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, s.t. <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo><mml:mo>&gt;</mml:mo><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we make such vertex an anchor, <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi></mml:mrow><mml:mi>v</mml:mi></mml:msub><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and replace <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mi>v</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> with <italic toggle="yes">A<sub>v</sub></italic>. This ensures that all rows in the RowDiff-transformed annotation matrix are at least as sparse as the corresponding rows in the original annotation matrix.<statement id="mthst4"><p><sc>Proposition</sc> 4<italic toggle="yes">. Each row in a RowDiff-transformed annotation matrix has the same or fewer set bits than its corresponding row in the original annotation matrix.</italic></p><p>The anchor optimization procedure is implemented similarly to the initial construction of RowDiff (Section 2.4). Thus, it has the same time and space complexity.</p></statement></p>
      </sec>
    </sec>
    <sec>
      <title>2.4 Rowdiff construction</title>
      <p>A naïve implementation of the RowDiff construction would be to load the matrix <italic toggle="yes">A</italic> in memory, and gradually replace its rows with their sparsified counterpart, while traversing the graph. Although fast and simple, this method requires to keep the entire annotation matrix <italic toggle="yes">A</italic> and the graph in memory. Unfortunately, this is often not realistic, as even the annotation matrix <italic toggle="yes">A</italic> alone can easily reach several terabytes in size. For this reason, we developed a distributed parallel construction algorithm that only loads a few columns of <italic toggle="yes">A</italic> at a time, and therefore needs only a limited amount of memory.</p>
      <p>In the first stage, we load the graph and for each vertex pre-compute the indices of the unique RowDiff successor and the (possibly multiple) RowDiff predecessors, stored in vectors pred and succ, respectively. The pred and succ vectors are used to build <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> in the second stage without the need to query the graph itself and load it in memory. To make the algorithm scale to de Bruijn graphs with trillions of vertices, vectors pred and succ are built and traversed in a streaming manner. They are loaded in small blocks, as described in <xref rid="btab330-BOX3" ref-type="boxed-text">Algorithm 3</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S3</xref>, and never kept in memory in full. Thus, pre-computing the pred and succ vectors essentially makes it possible to query the graph topology during the second stage while only using <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> additional space. After the RowDiff annotation <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> has been generated, the pred and succ vectors are not required for querying and, thus, can be discarded.<boxed-text id="btab330-BOX3" position="float"><p><bold>Algorithm 3</bold> RowDiff-transform
</p><list list-type="order"><list-item><p><bold>function</bold> Sparsify(<inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mtext>columns</mml:mtext></mml:mrow></mml:math></inline-formula>)    ▹ sparsifies a batch loaded in memory</p></list-item><list-item><p>  <bold>for</bold>  <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mtext>block</mml:mtext><mml:mo>←</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mtext>numRows</mml:mtext><mml:mo>,</mml:mo><mml:mtext>BlockSize</mml:mtext></mml:mrow></mml:math></inline-formula>  <bold>do</bold>        ▹ Process by blocks</p></list-item><list-item><p>    <bold>load</bold> pred[block.block+BlockSize]</p></list-item><list-item><p>    <bold>load</bold> succ[block.block+BlockSize]</p></list-item><list-item><p>    <bold>for all</bold>  <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo>∈</mml:mo><mml:mtext>columns</mml:mtext></mml:mrow></mml:math></inline-formula>  <bold>parallel do</bold></p></list-item><list-item><p>      <bold>for all</bold>  <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mtext>block</mml:mtext><mml:mn>..</mml:mn><mml:mtext>block</mml:mtext><mml:mo>+</mml:mo><mml:mtext>BlockSize</mml:mtext><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>       <bold>do</bold>   ▹ Iterate only set bits</p></list-item><list-item><p>          <bold>if not</bold>  <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>then</bold></p></list-item><list-item><p>            <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mo>▹</mml:mo></mml:math></inline-formula> The bits at <italic toggle="yes">i</italic> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mtext>succ</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> are different, hence, diff <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>            <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="monospace">True</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>        <bold>end if</bold></p></list-item><list-item><p>        <bold>for all</bold>  <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>∈</mml:mo><mml:mtext>pred</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>do</bold></p></list-item><list-item><p>          <bold>if not</bold>  <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>  <bold>then</bold></p></list-item><list-item><p>            <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mo>▹</mml:mo></mml:math></inline-formula> The bits at <italic toggle="yes">p</italic> and <italic toggle="yes">i</italic> are different, hence, diff <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mrow><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>            <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">[</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi mathvariant="monospace">True</mml:mi></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>        <bold>end if</bold></p></list-item><list-item><p>      <bold>end for</bold></p></list-item><list-item><p>    <bold>end for</bold></p></list-item><list-item><p>  <bold>end for</bold></p></list-item><list-item><p><bold>end function</bold></p></list-item></list></boxed-text>The second stage of the construction algorithm (the sparsification workflow) is schematically described in <xref rid="btab330-F2" ref-type="fig">Figure 2</xref>. The initial sparsification of <italic toggle="yes">A</italic> can be trivially distributed by dividing the columns of <italic toggle="yes">A</italic> into groups and processing each group on a different machine. Each machine processes its assigned columns in batches. The size of each batch is determined dynamically by loading columns into memory until a desired upper limit is reached. This upper limit must be greater than the largest column being processed in compressed bit-vector format, but otherwise not restricted. For each column in the batch, we iterate only the set bits (only those rows corresponding to vertices annotated with the label represented by that column) and compare them with the bits at positions pred and succ in the same column to compute the RowDiff-transformed row, as shown in <xref rid="btab330-F2" ref-type="fig">Figure 2</xref>.</p>
      <fig position="float" id="btab330-F2">
        <label>Fig. 2.</label>
        <caption>
          <p>RowDiff-transform algorithm—Schematic overview of sparsification on a single machine. <bold>Top:</bold> Columns are loaded into memory in batches (until memory is exhausted) and each batch is fully transformed to RowDiff. The result is serialized and the process moves on to the next batch. <bold>Bottom:</bold> Each batch is transformed to RowDiff as follows. The algorithm iteratively loads into memory blocks of the pre-computed vectors pred and succ. Then, all columns of the batch are processed in parallel. The algorithm iterates only through set bits of each column in the active block and computes the elements of the RowDiff-transformed matrix <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:math></inline-formula> (see Algorithm 3 for a more detailed description)</p>
        </caption>
        <graphic xlink:href="btab330f2" position="float"/>
      </fig>
      <sec>
        <title>2.4.1 Scalability and complexity</title>
        <p>Algorithm 3 only traverses set bits in <italic toggle="yes">A</italic>, and for each set bit in row <italic toggle="yes">i</italic> it performs <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mi>deg</mml:mi></mml:mrow></mml:mrow><mml:mo>−</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> operations, hence the total time complexity is <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">α</italic> is the average in-degree of the graph. For de Bruijn graphs, <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo>≤</mml:mo><mml:mo>|</mml:mo><mml:mo>Σ</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, and hence the time complexity is linear in the number of set bits of the original annotation matrix, i.e. <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S3</xref>, for constructing pred and succ, traverses each vertex exactly once, hence its time complexity is <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Since the buffer used by <xref rid="sup1" ref-type="supplementary-material">Supplementary Algorithm S3</xref> has a constant size, the space complexity is <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> denotes the memory footprint of the graph, which, for instance, in the case of the BOSS representation (<xref rid="btab330-B5" ref-type="bibr">Bowe <italic toggle="yes">et al.</italic>, 2012</xref>) typically does not exceed <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mn>4</mml:mn><mml:mi>m</mml:mi><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>m</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> bits, where <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. After taking into account Algorithm 2 for anchor assignment, which requires three additional bits per vertex to indicate anchors and the traversal state, and putting it all together, we get that the RowDiff-transform can be performed in <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>popcount</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>A</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time and in <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="sans-serif">DB</mml:mi><mml:msub><mml:mrow><mml:mi mathvariant="sans-serif">G</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> space, where <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="bold-italic">c</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> is the memory footprint of the largest (densest) column of <italic toggle="yes">A</italic> in a compressed bit-vector format. Note that the first term in each of the sums is usually the dominant.</p>
        <p>In terms of temporary disk space, the succ array takes <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mrow><mml:mo>⌈</mml:mo><mml:mrow><mml:mo> </mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo>|</mml:mo></mml:mrow><mml:mo>⌉</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> bits and the pred array has similar size (in practice smaller). In addition, the anchor optimization algorithm needs 32 bits per vertex to count the number of bits per row. Thus, RowDiff construction needs in total &lt;20 bytes per vertex of temporary disk storage.</p>
        <p>In conclusion, we mention again that RowDiff construction can be easily distributed on multiple machines with modest hardware requirements and run in parallel on each machine, which makes the method very attractive for practical use on very large datasets.</p>
      </sec>
    </sec>
    <sec>
      <title>2.5 Querying annotations for paths</title>
      <p>We now note that, when querying annotations for paths in the graph or sets of rows corresponding to vertices from a local neighborhood in the graph, Algorithm 1 leads to redundant reconstruction work, as many of the queried rows belong to the same RowDiff paths. To alleviate this, we perform the traversal first and pre-compute all RowDiff paths from the rows queried. Then, we query all diff rows in one batch and reconstruct annotations for each row from the query. This ensures that no arc in these paths is traversed more than once. Moreover, querying all rows in one batch often allows making the query of the underlying representation of the sparsified binary matrix faster by exploiting its potential intrinsic features (e.g. jointly querying <italic toggle="yes">n</italic> bits in <italic toggle="yes">m</italic> columns is more cache-efficient and faster than <italic toggle="yes">n</italic> queries of single bits in each of the <italic toggle="yes">m</italic> columns).</p>
    </sec>
    <sec>
      <title>2.6 Implementation details</title>
      <p>We implemented RowDiff as part of the MetaGraph framework (<xref rid="btab330-B15" ref-type="bibr">Karasikov <italic toggle="yes">et al.</italic>, 2020a</xref>). The code for reproducing results of the experiments is available at <ext-link xlink:href="https://github.com/ratschlab/row_diff" ext-link-type="uri">https://github.com/ratschlab/row_diff</ext-link><monospace>.</monospace> For storing original columns of the annotation matrix as well as the indicator bitmap with anchor vertices, we used the SD vectors from the sdsl-lite library (<xref rid="btab330-B12" ref-type="bibr">Gog <italic toggle="yes">et al.</italic>, 2014</xref>) for compressed representation of bitmaps. For compression of the transformed annotation matrix, we used the multi-BRWT representation scheme proposed in (<xref rid="btab330-B16" ref-type="bibr">Karasikov <italic toggle="yes">et al.</italic>, 2020b</xref>), with its improved and scaled up implementation from MetaGraph.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Results and discussion</title>
    <p>In this section, we evaluate the performance of the methods described above both in terms of their final representation sizes and their construction time. In addition, we also study the effect of the maximum RowDiff path length on the final RowDiff representation size of the compressed annotations. Finally, we evaluate the degree of compression that RowDiff provides on a per-column basis.</p>
    <sec>
      <title>3.1 Datasets</title>
      <p>We evaluated the compression performance of RowDiff on three datasets with different levels of sequence variability and thus graph density. This first dataset consists of all Fungi sequences from RefSeq release 97 (<xref rid="btab330-B21" ref-type="bibr">O’Leary <italic toggle="yes">et al.</italic>, 2016</xref>), with annotations derived from the taxonomic IDs of the sequences’ respective organisms. This second and third datasets are derived from the cohort of 10 000 publicly available human RNA-seq experiments used in (<xref rid="btab330-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>). We constructed annotated de Bruijn graphs from the RNA-seq dataset in the same manner as in (<xref rid="btab330-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>), using a <italic toggle="yes">k</italic> value of 23, albeit with two samples discarded due to their withdrawal from the Sequence Read Archive. We will refer to this dataset as RNA-seq (<italic toggle="yes">k</italic> = 23). The third dataset is constructed using the graph cleaning approach originally developed by <xref rid="btab330-B27" ref-type="bibr">Turner <italic toggle="yes">et al.</italic> (2018)</xref> and scaled up in MetaGraph (<xref rid="btab330-B15" ref-type="bibr">Karasikov <italic toggle="yes">et al.</italic>, 2020a</xref>), using a <italic toggle="yes">k</italic> value of 31. We will refer to this dataset as RNA-seq (<italic toggle="yes">k</italic> = 31). For evaluating construction time and representation size, we shuffled the samples in each dataset and generated subsets of increasing size.</p>
      <p>We evaluated RowDiff against MST (<xref rid="btab330-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>), used in Mantis (<xref rid="btab330-B23" ref-type="bibr">Pandey <italic toggle="yes">et al.</italic>, 2018</xref>), which, to the best of our knowledge, is the most compact annotation representation method to date. Similarly to Rainbowfish (<xref rid="btab330-B1" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2017</xref>), MST reduces the original annotation matrix to a set of unique rows and consists of two components: a vector, mapping indexes of rows of the annotation matrix to its unique rows (color classes) and the unique rows compressed in a minimum spanning tree. In Mantis, this mapping vector is included into a hash table storing the <italic toggle="yes">k</italic>-mers of the de Bruijn graph, which is usually at least an order of magnitude larger than the compressed annotation. Thus, to make a fair comparison, we exclude the large contribution of Mantis’ graph representation and only consider the mapping vector, using the same representation as in Rainbowfish (<xref rid="btab330-B1" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2017</xref>). Thus, we refer to the MST annotation representation as Rainbow-MST. Note that Rainbow-MST forms a graph annotation representation which, similarly to RowDiff, can be used with any de Bruijn graph representation with indexed <italic toggle="yes">k</italic>-mers.</p>
    </sec>
    <sec>
      <title>3.2 Representation size</title>
      <p>We now compare the representation size for RowDiff and other state-of-the-art graph annotation compression methods. We additionally consider two binary matrix representation schemes: Multi-BRWT (<xref rid="btab330-B16" ref-type="bibr">Karasikov <italic toggle="yes">et al.</italic>, 2020b</xref>) and RowSparse for encoding the RowDiff-transformed annotation matrices. The RowSparse format stores the indices of set bits in each row in a compressed integer vector. This representation is faster to query than multi-BRWT, but its memory footprint is significantly larger.</p>
      <p><xref rid="btab330-F3" ref-type="fig">Figure 3</xref> shows the representation size for the RNA-seq (<italic toggle="yes">k</italic> = 23), RNA-seq (<italic toggle="yes">k</italic> = 31) and RefSeq (Fungi) datasets. On the RNA-seq (<italic toggle="yes">k</italic> = 31) dataset, RowDiff-multi-BRWT effectively takes advantage of the topology of the graph annotation and the similarity of rows of the annotation matrix and achieves a nearly 4-fold size reduction compared to multi-BRWT applied on non-sparsified columns. Compared to the Rainbow-MST method, RowDiff-multi-BRWT achieves a 2-fold size reduction. Rainbow-MST computation on the subsets with more than 4000 samples could not be computed because Mantis did not complete within the 10 days limit of this compute cluster. For this reason, we also plotted the size of the Rainbowfish mapping vector, which, being a subset of the Rainbow-MST annotation data, represents a lower bound for Rainbow-MST.</p>
      <fig position="float" id="btab330-F3">
        <label>Fig. 3.</label>
        <caption>
          <p>Representation size. The green line represents the size of the non-sparsified annotation matrix encoded with multi-BRWT. The purple and the red lines represent the size of the RowDiff annotation encoded with Multi-BRWT and RowSparse matrix representations, respectively. The blue line indicates the size of the Rainbow-MST annotation. The orange line represents the size of the Rainbow-MST mapping vector and represents a lower bound on the Rainbow-MST representation size. Rainbow-MST computation on the RNA-seq (<italic toggle="yes">k</italic> = 31) dataset with &gt;4000 samples did not complete within the 10 days limit of this compute cluster. (<bold>a</bold>) RNA-seq (<italic toggle="yes">k</italic> = 23) dataset, (<bold>b</bold>) RNA-seq (<italic toggle="yes">k</italic> = 31) dataset and (<bold>c</bold>) RefSeq (Fungi) dataset</p>
        </caption>
        <graphic xlink:href="btab330f3" position="float"/>
      </fig>
      <p>On the RNA-seq (<italic toggle="yes">k</italic> = 23) dataset, RowDiff-multi-BRWT achieves a 2.5-fold size reduction relative to multi-BRWT and a 1.5-fold reduction relative to Rainbow-MST.</p>
      <p>On the RefSeq (Fungi) dataset, RowDiff takes advantage of the longer stretches of vertices with identical annotations and achieves a 26-fold size reduction relative to Rainbow-MST (the detailed tabular data for this experiment are available in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). Notably, this significant difference is caused mainly by the large size of the mapping vector on this dataset.</p>
    </sec>
    <sec>
      <title>3.3 Effects of graph density on compression</title>
      <p>In this section, we analyze how the density of the annotated graph affects RowDiff compression. In a first experiment, we take a random subset of 1570 entries from the RefSeq (Fungi) dataset and build graphs and corresponding annotations for <italic toggle="yes">k</italic>-mer sizes ranging from 15 to 31. <xref rid="btab330-T1" ref-type="table">Table 1</xref> shows how the compression ratio <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> increases with higher sparsity of the graph (lower average out-degree for increasing <italic toggle="yes">k</italic>-mer length).</p>
      <table-wrap position="float" id="btab330-T1">
        <label>Table 1.</label>
        <caption>
          <p>Compression ratio versus graph density on a random subset of 1570 RefSeq (Fungi) annotation columns</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1"><italic toggle="yes">k</italic>-mer size</th>
              <th rowspan="1" colspan="1">Average out-degree</th>
              <th rowspan="1" colspan="1"><bold>Compression ratio</bold>  <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">15</td>
              <td rowspan="1" colspan="1">1.98</td>
              <td rowspan="1" colspan="1">1.30</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">17</td>
              <td rowspan="1" colspan="1">1.10</td>
              <td rowspan="1" colspan="1">4.79</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">19</td>
              <td rowspan="1" colspan="1">1.01</td>
              <td rowspan="1" colspan="1">18.89</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">23</td>
              <td rowspan="1" colspan="1">1.003</td>
              <td rowspan="1" colspan="1">31.66</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">31</td>
              <td rowspan="1" colspan="1">1.0017</td>
              <td rowspan="1" colspan="1">34.53</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <p><italic toggle="yes">Note</italic>: The sparser the graph the higher the compression ratio.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>In the second experiment, we test how the maximum RowDiff path length <italic toggle="yes">M</italic> affects the annotation size for graphs of various densities. <xref rid="btab330-T2" ref-type="table">Table 2</xref> shows the annotation size on the RNA-seq (<italic toggle="yes">k</italic> = 23), RNA-seq (<italic toggle="yes">k</italic> = 31) and RefSeq (Fungi) datasets for various values of <italic toggle="yes">M</italic>, where the column <italic toggle="yes">M</italic> = 0 corresponds to the size of the original annotation matrix without applying RowDiff. While increasing the maximum path length has negligible effect on the denser RNA-seq graphs (with average node degrees of 1.08 and 1.04, respectively), it reduces the annotation size by a factor of up to 5.7 (from 1.52 GB to 265 MB) on the much sparser RefSeq (Fungi) graph (with an average node degree of 1.003). This phenomenon can be explained by the observation that in sparser graphs the majority of the anchor nodes are set to restrict the maximum RowDiff path length, while in denser graphs the majority of the anchor nodes are set during the anchor optimization stage.</p>
      <table-wrap position="float" id="btab330-T2">
        <label>Table 2.</label>
        <caption>
          <p>Annotation size (in GB) versus maximum RowDiff path length <italic toggle="yes">M</italic> for RNA-seq (<italic toggle="yes">k</italic> = 23 and 31) and Refseq Fungi (<italic toggle="yes">k</italic> = 31)</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Dataset</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">M</italic> = 0</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">M</italic> = 10</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">M</italic> = 25</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">M</italic> = 50</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">M</italic> = 75</th>
              <th rowspan="1" colspan="1"><italic toggle="yes">M</italic> = 100</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">RNA-seq (<italic toggle="yes">k</italic> = 23)</td>
              <td rowspan="1" colspan="1">214</td>
              <td rowspan="1" colspan="1">125.1</td>
              <td rowspan="1" colspan="1">119.8</td>
              <td rowspan="1" colspan="1">118.3</td>
              <td rowspan="1" colspan="1">118.0</td>
              <td rowspan="1" colspan="1">117.8</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RNA-seq (<italic toggle="yes">k</italic> = 31)</td>
              <td rowspan="1" colspan="1">151</td>
              <td rowspan="1" colspan="1">70.7</td>
              <td rowspan="1" colspan="1">64.9</td>
              <td rowspan="1" colspan="1">63.2</td>
              <td rowspan="1" colspan="1">62.6</td>
              <td rowspan="1" colspan="1">62.2</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">RefSeq (Fungi)</td>
              <td rowspan="1" colspan="1">11.2</td>
              <td rowspan="1" colspan="1">1.52</td>
              <td rowspan="1" colspan="1">0.713</td>
              <td rowspan="1" colspan="1">0.419</td>
              <td rowspan="1" colspan="1">0.317</td>
              <td rowspan="1" colspan="1">0.265</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <p><italic toggle="yes">Note</italic>: Column <italic toggle="yes">M</italic> = 0 shows the size of the original columns not transformed with RowDiff.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>3.4 Compression of single columns</title>
      <p>In this experiment, we measure how RowDiff compresses individual columns of the annotation matrix. <xref rid="btab330-F4" ref-type="fig">Figure 4</xref> shows the compression ratio <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> achieved by RowDiff on two datasets representing two different extreme cases of sequence variability.</p>
      <fig position="float" id="btab330-F4">
        <label>Fig. 4.</label>
        <caption>
          <p>Histogram of the compression ratio per column <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msubsup><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mo>·</mml:mo><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, weighted by the original column size. On the denser RNA-seq (<italic toggle="yes">k</italic> = 31) graph, the compression ratio peaks at around <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>, while on RefSeq (Fungi) the compression ratio peaks at <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mo>≈</mml:mo><mml:mn>60</mml:mn><mml:mo>×</mml:mo></mml:mrow></mml:math></inline-formula>. The size of columns is measured by the memory footprint of their SD compressed representations. (<bold>a</bold>) RNA-seq (<italic toggle="yes">k</italic> = 31) dataset and (<bold>b</bold>) RefSeq (Fungi) dataset</p>
        </caption>
        <graphic xlink:href="btab330f4" position="float"/>
      </fig>
      <p>The de Bruijn graph constructed from assembled genomes RefSeq (Fungi) contains significantly fewer branches and bubbles than the graph constructed from reads RNA-seq (<italic toggle="yes">k</italic> = 31), thus its annotation is significantly better compressed by RowDiff, with an average compression ratio of 42 (from 11.2 GB to 265 MB).</p>
    </sec>
    <sec>
      <title>3.5 Construction time</title>
      <p>In <xref rid="btab330-F5" ref-type="fig">Figure 5</xref>, we compare the construction times for RowDiff and MST (<xref rid="btab330-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic>, 2019</xref>). The construction time for RowDiff-multi-BRWT includes everything from the RowDiff-transform of the original columns (with <italic toggle="yes">M </italic>=<italic toggle="yes"> </italic>100) to the conversion of the transformed RowDiff columns to the multi-BRWT binary matrix representation. For MST, we only measure the time taken for compression of the unique annotation rows and do not include the time taken to construct the mapping vector (which is done by Mantis at the same time as constructing the graph and usually takes orders of magnitude longer to than construction of the MST part itself). Thus, this makes up a lower bound on the total construction time for the MST method. Note that the construction time for RowDiff-multi-BRWT grows linearly in the number of columns of the annotation matrix, and superlinearly for MST, which makes RowDiff a more favorable approach on a larger scale.</p>
      <fig position="float" id="btab330-F5">
        <label>Fig. 5.</label>
        <caption>
          <p>Construction time for the RowDiff and MST annotation representations on the RNA-seq (<italic toggle="yes">k</italic> = 23) dataset with 72 threads</p>
        </caption>
        <graphic xlink:href="btab330f5" position="float"/>
      </fig>
    </sec>
    <sec>
      <title>3.6 Query performance</title>
      <p>In this experiment, we measured the time needed to query human transcripts against the RNA-seq (<italic toggle="yes">k</italic> = 23) annotation.</p>
      <p><xref rid="btab330-T3" ref-type="table">Table 3</xref> shows the time taken to query 100 and 1000 random human transcripts for the baseline multi-BRWT matrix representation method, the Mantis-MST method and the proposed RowDiff method (with the RowDiff matrix encoded using multi-BRWT or RowSparse).</p>
      <table-wrap position="float" id="btab330-T3">
        <label>Table 3.</label>
        <caption>
          <p>Time for querying 100 and 1000 random human transcripts with multi-BRWT, Mantis-MST and RowDiff methods</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="3" colspan="1">Query data</th>
              <th rowspan="3" colspan="1">
                <bold># rows</bold>
                <break/>
                <bold>queried</bold>
              </th>
              <th colspan="4" rowspan="1">Query time<hr/></th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">Multi</th>
              <th rowspan="1" colspan="1">Mantis</th>
              <th rowspan="1" colspan="1">RowDiff</th>
              <th rowspan="1" colspan="1">RowDiff</th>
            </tr>
            <tr>
              <th rowspan="1" colspan="1">BRWT (s)</th>
              <th rowspan="1" colspan="1">MST (s)</th>
              <th rowspan="1" colspan="1">RowSparse (s)</th>
              <th rowspan="1" colspan="1">Multi-BRWT (s)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">100 trans.</td>
              <td rowspan="1" colspan="1">44 995</td>
              <td rowspan="1" colspan="1">51</td>
              <td rowspan="1" colspan="1">4.5</td>
              <td rowspan="1" colspan="1">8.3</td>
              <td rowspan="1" colspan="1">40</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">1000 trans.</td>
              <td rowspan="1" colspan="1">553 280</td>
              <td rowspan="1" colspan="1">226</td>
              <td rowspan="1" colspan="1">68</td>
              <td rowspan="1" colspan="1">54</td>
              <td rowspan="1" colspan="1">197</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn3">
            <p><italic toggle="yes">Note</italic>: The second column shows the total number of annotation rows queried. All benchmarks were performed with a single thread on Intel(R) Xeon(R) Gold 6140 CPU @ 2.30 GHz.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
      <p>We queried RowDiff annotations using the algorithm optimized for long paths (Section 2.5). First, we construct a list of annotation rows that have to be reconstructed from the RowDiff format and a list of all diff rows for querying in the RowDiff matrix. Then, all these rows are queried at once and the original annotation rows are reconstructed. Since RowDiff additionally requires traversing the de Bruijn graph to get RowDiff paths, the query time for RowDiff depends on the traversal performance of the underlying representation of the de Bruijn graph. In this experiment, we used the succinct de Bruijn graph representation available in the MetaGraph library.</p>
      <p>For Mantis-MST, the total time reported by Mantis was measured, excluding the loading time. This also includes the time taken to map the <italic toggle="yes">k</italic>-mers from the query to rows of the annotation matrix, which could not be subtracted because Mantis only reports the total query time. However, as querying the annotation matrix is the bottleneck of the query algorithm, this makes up a relatively small fraction of the total time.</p>
      <p>Finally, we study the influence of the maximum RowDiff path length parameter <italic toggle="yes">M</italic> on the query performance of RowDiff (<xref rid="btab330-F6" ref-type="fig">Fig. 6</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs. S1 and S2</xref>). Notably, setting a larger value of <italic toggle="yes">M</italic> not only increases the compression ratio but also makes queries on RowDiff-multi-BRWT faster (in the range of studied values from <italic toggle="yes">M </italic>=<italic toggle="yes"> </italic>10 to 100), which can be explained by the higher performance of multi-BRWT on sparser matrices. In contrast, RowDiff-RowSparse does not show any noticeable dependence of the query time on <italic toggle="yes">M</italic>. As mentioned above, the query time for RowDiff depends on the graph traversal speed because of the required traversal of RowDiff paths to their anchors. However, <xref rid="btab330-F6" ref-type="fig">Figure 6</xref> shows that the traversal actually takes a relatively small part of the total time. Hence, further improvements of RowDiff increasing the sparsity of the annotation matrix will likely make queries faster.</p>
      <fig position="float" id="btab330-F6">
        <label>Fig. 6.</label>
        <caption>
          <p>Query time for different values of the maximum RowDiff path length <italic toggle="yes">M</italic>. The first point <italic toggle="yes">M </italic>=<italic toggle="yes"> </italic>0 corresponds to the baseline multi-BRWT encoding the original annotation matrix without RowDiff</p>
        </caption>
        <graphic xlink:href="btab330f6" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Conclusions</title>
    <p>In this article, we introduced RowDiff, a new technique for compacting graph labels by leveraging the likely similarities in annotations of nodes adjacent in the graph. We designed a parallel construction algorithm with linear time complexity in the number of node-label pairs and small memory footprint. In addition, the algorithm can efficiently be distributed and parallelized, making it applicable virtually on arbitrarily large graphs. RowDiff reduced the size of graph annotations by 2- to 26-fold when used in combination with multi-BRWT relative to Mantis-MST, the smallest state-of-the-art representation.</p>
    <p>Although the row reconstruction method inevitably leads to an increase in <italic toggle="yes">ad hoc</italic> row query time due to the larger number of required annotation matrix queries, this limitation is alleviated in practice due to the tendency of real-world sequences to feature <italic toggle="yes">k</italic>-mers which co-occur on matching RowDiff paths, which results in overall smaller query times.</p>
    <p>The optimization of anchor assignment is a clear direction for future development of these methods. The anchor assignment method we have presented is designed to reduce the row reconstruction time by setting an upper bound on the traversal length. However, given that there is a trade-off between the size and the query time of the final representation, designing an objective function and a corresponding algorithm to best optimize these measures is a non-trivial task.</p>
    <p>Moving beyond the representation of binary relations, a simple extension of the RowDiff method can be used as an efficient way to represent genomic coordinates for indexes of reference genomes. By representing a coordinate at each anchor node, the coordinates of all other nodes in that anchor’s corresponding RowDiff path can be computed via their traversal distance to the anchor.</p>
    <p>Each improvement in the compression of sequence graphs and their associated annotations opens up further opportunities for their real-world applicability. When handling large annotations, even a 2-fold difference in the representation size can make a previously unapproachable annotation accessible to the available hardware. With RowDiff, we have demonstrated that there still is great potential for improving the representation of annotations on sequence graphs.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by the Swiss National Science Foundation [407540_167331 to G.R. for M.K. and H.M.] and ETH core funding to G.R. (for A.K. and D.D.).</p>
    <p><italic toggle="yes">Conflict of Interest</italic>: none declared.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btab330_Supplementary_Data</label>
      <media xlink:href="btab330_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btab330-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <part-title>Rainbowfish: a succinct colored de Bruijn graph representation</part-title>. In: <person-group person-group-type="editor"><string-name><surname>Schwartz</surname><given-names>R.</given-names></string-name>, <string-name><surname>Reinert</surname><given-names>K.</given-names></string-name></person-group> (eds.) <source>17th International Workshop on Algorithms in Bioinformatics (WABI 2017), Volume 88 of Leibniz International Proceedings in Informatics (LIPIcs)</source>. <publisher-name>Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik</publisher-name>, <publisher-loc>Dagstuhl, Germany</publisher-loc>, pp. <fpage>18:1</fpage>–<lpage>18:15</lpage>.</mixed-citation>
    </ref>
    <ref id="btab330-B2">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <part-title>An efficient, scalable and exact representation of high-dimensional color information enabled via de Bruijn graph search</part-title>. In: Cowen L. (eds) <source>Research in Computational Molecular Biology. RECOMB 2019. <italic toggle="yes">Lecture Notes in Computer Science, vol 11467</italic>.</source>  <publisher-name>Springer</publisher-name>, Cham.</mixed-citation>
    </ref>
    <ref id="btab330-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Benoit</surname><given-names>G.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>Reference-free compression of high throughput sequencing data with a probabilistic de Bruijn graph</article-title>. <source>BMC Bioinformatics</source>, <volume>16</volume>, <fpage>288</fpage>.<pub-id pub-id-type="pmid">26370285</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B4">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Bingmann</surname><given-names>T.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <part-title>Cobs: a compact bit-sliced signature index</part-title>. In: Brisaboa N., Puglisi S. (eds) <source>String Processing and Information Retrieval. SPIRE 2019.</source> Lecture Notes in Computer Science, vol 11811. <publisher-name>Springer</publisher-name>, Cham.</mixed-citation>
    </ref>
    <ref id="btab330-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Bowe</surname><given-names>A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <part-title>Succinct de Bruijn graphs</part-title>. In: Raphael B., Tang J. (eds) Algorithms in Bioinformatics. WABI 2012. <source><italic toggle="yes">Lecture Notes in Computer Science, vol 7534. Springer, Berlin, Heidelberg</italic></source>.</mixed-citation>
    </ref>
    <ref id="btab330-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bradley</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Ultrafast search of all deposited bacterial and viral genomic data</article-title>. <source>Nat. Biotechnol</source>., <volume>37</volume>, <fpage>152</fpage>.<pub-id pub-id-type="pmid">30718882</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Breitwieser</surname><given-names>F.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Krakenuniq: confident and fast metagenomics classification using unique k-mer counts</article-title>. <source>Genome Biol</source>., <volume>19</volume>, <fpage>198</fpage>.<pub-id pub-id-type="pmid">30445993</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R.</given-names></string-name>, <string-name><surname>Rizk</surname><given-names>G.</given-names></string-name></person-group> (<year>2013</year>) <article-title>Space-efficient and exact de Bruijn graph representation based on a bloom filter</article-title>. <source>Algorith. Mol. Biol</source>., <volume>8</volume>, <fpage>22</fpage>.</mixed-citation>
    </ref>
    <ref id="btab330-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cox</surname><given-names>A.J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <article-title>Large-scale compression of genomic sequence databases with the burrows–wheeler transform</article-title>. <source>Bioinformatics</source>, <volume>28</volume>, <fpage>1415</fpage>–<lpage>1419</lpage>.<pub-id pub-id-type="pmid">22556365</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Elias</surname><given-names>P.</given-names></string-name></person-group> (<year>1974</year>) <article-title>Efficient storage and retrieval by content and address of static files</article-title>. <source>JACM</source>, <volume>21</volume>, <fpage>246</fpage>–<lpage>260</lpage>.</mixed-citation>
    </ref>
    <ref id="btab330-B11">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Fano</surname><given-names>R.M.</given-names></string-name></person-group> (<year>1971</year>) <source>On the Number of Bits Required to Implement an Associative Memory</source>. Computational Structures Group, Memo 61. Project MAC, <publisher-name>Massachusetts Institute of Technology</publisher-name>.</mixed-citation>
    </ref>
    <ref id="btab330-B12">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Gog</surname><given-names>S.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2014</year>) <part-title>From theory to practice: plug and play with succinct data structures</part-title>. In: Gudmundsson J., Katajainen J. (eds) Experimental Algorithms. SEA 2014. <source><italic toggle="yes">Lecture Notes in Computer Science, vol 8504</italic></source>. Springer, Cham.</mixed-citation>
    </ref>
    <ref id="btab330-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Harris</surname><given-names>R.S.</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group> (<year>2020</year>) <article-title>Improved representation of sequence bloom trees</article-title>. <source>Bioinformatics</source>, <volume>36</volume>, <fpage>721</fpage>–<lpage>727</lpage>.<pub-id pub-id-type="pmid">31504157</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Iqbal</surname><given-names>Z.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2012</year>) <article-title>De novo assembly and genotyping of variants using colored de Bruijn graphs</article-title>. <source>Nat. Genet</source>., <volume>44</volume>, <fpage>226</fpage>–<lpage>232</lpage>.<pub-id pub-id-type="pmid">22231483</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karasikov</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020a</year>) <article-title>Metagraph: indexing and analysing nucleotide archives at petabase-scale</article-title>. <source><italic toggle="yes">bioRxiv, 10.1101/2020.10.01.322164</italic></source>.</mixed-citation>
    </ref>
    <ref id="btab330-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Karasikov</surname><given-names>M.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2020b</year>) <article-title>Sparse binary relation representations for genome graph annotation</article-title>. <source>J. Comput. Biol</source>., <volume>27</volume>, <fpage>626</fpage>–<lpage>639</lpage>.<pub-id pub-id-type="pmid">31891531</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2021</year>) <article-title>Data structures based on k-mers for querying large collections of sequencing datasets</article-title>. <source>Genome Res</source>., <volume>31</volume>, <fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">33328168</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muggli</surname><given-names>M.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2017</year>) <article-title>Succinct colored de Bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>33</volume>, <fpage>3181</fpage>–<lpage>3187</lpage>.<pub-id pub-id-type="pmid">28200001</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muggli</surname><given-names>M.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Building large updatable colored de Bruijn graphs via merging</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>i51</fpage>–<lpage>i60</lpage>.<pub-id pub-id-type="pmid">31510647</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mustafa</surname><given-names>H.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2019</year>) <article-title>Dynamic compression schemes for graph coloring</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>407</fpage>–<lpage>414</lpage>.<pub-id pub-id-type="pmid">30020403</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>O’Leary</surname><given-names>N.A.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Reference sequence (RefSeq) database at NCBI: current status, taxonomic expansion, and functional annotation</article-title>. <source>Nucleic Acids Res</source>., <volume>44</volume>, <fpage>D733</fpage>–<lpage>D745</lpage>.<pub-id pub-id-type="pmid">26553804</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ondov</surname><given-names>B.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2016</year>) <article-title>Mash: fast genome and metagenome distance estimation using minhash</article-title>. <source>Genome Biol</source>., <volume>17</volume>, <fpage>132</fpage>.<pub-id pub-id-type="pmid">27323842</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pandey</surname><given-names>P.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Mantis: a fast, small, and exact large-scale sequence-search index</article-title>. <source>Cell Syst</source>., <volume>7</volume>, <fpage>201</fpage>–<lpage>207.e4</lpage>.<pub-id pub-id-type="pmid">29936185</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Raman</surname><given-names>R.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2007</year>) <article-title>Succinct indexable dictionaries with applications to encoding k-ary trees, prefix sums and multisets</article-title>. <source>ACM Trans. Algorithms (TALG)</source>, <volume>3</volume>, <fpage>43</fpage>–<lpage>es</lpage>.</mixed-citation>
    </ref>
    <ref id="btab330-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Stephens</surname><given-names>Z.D.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2015</year>) <article-title>Big data: astronomical or genomical?</article-title>  <source>PLoS Biol</source>., <volume>13</volume>, <fpage>e1002195</fpage>.<pub-id pub-id-type="pmid">26151137</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tully</surname><given-names>B.J.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>The reconstruction of 2,631 draft metagenome-assembled genomes from the global oceans</article-title>. <source>Sci. Data</source>, <volume>5</volume>, <fpage>1</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">30482902</pub-id></mixed-citation>
    </ref>
    <ref id="btab330-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Turner</surname><given-names>I.</given-names></string-name></person-group>  <etal>et al</etal> (<year>2018</year>) <article-title>Integrating long-range connectivity information into de Bruijn graphs</article-title>. <source>Bioinformatics</source>, <volume>34</volume>, <fpage>2556</fpage>–<lpage>2565</lpage>.<pub-id pub-id-type="pmid">29554215</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
