<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311332</article-id>
    <article-id pub-id-type="pmid">37387170</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad225</article-id>
    <article-id pub-id-type="publisher-id">btad225</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Scalable sequence database search using partitioned aggregated Bloom comb trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Marchet</surname>
          <given-names>Camille</given-names>
        </name>
        <aff><institution>University of Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL</institution>, F-59000 Lille, <country country="FR">France</country></aff>
        <xref rid="btad225-cor1" ref-type="corresp"/>
        <!--camille.marchet@univ-lille.fr-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Limasset</surname>
          <given-names>Antoine</given-names>
        </name>
        <aff><institution>University of Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL</institution>, F-59000 Lille, <country country="FR">France</country></aff>
        <xref rid="btad225-cor1" ref-type="corresp"/>
        <!--antoine.limasset@univ-lille.fr-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad225-cor1">Corresponding authors. UMR CRIStAL Université de Lille - Campus scientifique, Bâtiment ESPRIT Avenue Henri Poincaré, 59655 Villeneuve d'Ascq, France. E-mails: <email>antoine.limasset@univ-lille.fr</email> (A.L.) and <email>camille.marchet@univ-lille.fr</email> (C.M.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i252</fpage>
    <lpage>i259</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad225.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The Sequence Read Archive public database has reached 45 petabytes of raw sequences and doubles its nucleotide content every 2 years. Although BLAST-like methods can routinely search for a sequence in a small collection of genomes, making searchable immense public resources accessible is beyond the reach of alignment-based strategies. In recent years, abundant literature tackled the task of finding a sequence in extensive sequence collections using <italic toggle="yes">k</italic>-mer-based strategies. At present, the most scalable methods are approximate membership query data structures that combine the ability to query small signatures or variants while being scalable to collections up to 10 000 eukaryotic samples. <bold>Results.</bold> Here, we present PAC, a novel approximate membership query data structure for querying collections of sequence datasets. PAC index construction works in a streaming fashion without any disk footprint besides the index itself. It shows a 3–6 fold improvement in construction time compared to other compressed methods for comparable index size. A PAC query can need single random access and be performed in constant time in favorable instances. Using limited computation resources, we built PAC for very large collections. They include 32 000 human RNA-seq samples in 5 days, the entire GenBank bacterial genome collection in a single day for an index size of 3.5 TB. The latter is, to our knowledge, the largest sequence collection ever indexed using an approximate membership query structure. We also showed that PAC’s ability to query 500 000 transcript sequences in less than an hour.</p>
      </sec>
      <sec id="s2">
        <title>Availability and implementation</title>
        <p>PAC’s open-source software is available at <ext-link xlink:href="https://github.com/Malfoy/PAC" ext-link-type="uri">https://github.com/Malfoy/PAC</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Agence Nationale de la recherche</institution>
            <institution-id institution-id-type="DOI">10.13039/501100001665</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>ANR-22-CE45-0007</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Public databases, such as the Sequence Read Archive (SRA) or European Nucleotide Archive overflow with sequencing data. The vast amount of sequences, experiments, and species allows, in principle, ubiquitous applications for biologists and clinicians. Such databases are becoming a fundamental shared resource for daily sequence analysis. But concretely, we only witness the onset of their exploitation, while their exponential growth poses serious scalability challenges [for instance, SRA has reached 45 petabytes of raw reads and roughly doubles every 3 years (ena)].</p>
    <p>Today, searching for a query sequence in a single genome/dataset or a restricted collection of genomes is considered routine through alignment-based tools, such as BLAST (<xref rid="btad225-B3" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic> 1990</xref>) and others (<xref rid="btad225-B9" ref-type="bibr">Camacho <italic toggle="yes">et al.</italic> 2009</xref>, <xref rid="btad225-B20" ref-type="bibr">Li and Durbin 2009</xref>, <xref rid="btad225-B18" ref-type="bibr">Janin <italic toggle="yes">et al.</italic> 2014</xref>, <xref rid="btad225-B13" ref-type="bibr">Dolle <italic toggle="yes">et al.</italic> 2017</xref>). In contrast, the scale of databases, such as SRA makes BLAST and any alignment-based method ill-suited due to the prohibitive cost of the alignment phase. Broader usages of such resources necessitate algorithms allowing hyper-scalable membership queries as a foundation. In particular, they must be able to quickly discard a sequence that is absent from a substantial dataset collection. They must also identify the datasets where the query is present. Therefore, recent literature has tackled these problems using alignment-free <italic toggle="yes">k</italic> -mer-based strategies.</p>
    <p>The known most scalable solutions are sketching methods, which reduce the datasets to a small set of signatures based on the principle of locality-sensitive hashing. However, the loss of resolution implied by these methods narrows the query possibilities to large queries of the order of magnitude of genomes or larger. Numerous applications rely on significantly smaller query size, e.g. variant calling of SNP/small indels, finding alternative splicing sites, or other small genomic signatures.</p>
    <p>Recent alignment-free literature has described novel methodologies to fill a dual need: small queries in vast dataset collections. Mostly, two paradigms (<xref rid="btad225-B22" ref-type="bibr">Marchet <italic toggle="yes">et al.</italic> 2021a</xref>) cover this question, both considering each dataset and the query itself as <italic toggle="yes">k</italic>-mer sets. The first type of approach relies on exact <italic toggle="yes">k</italic>-mer set representations. These methods build an associative index [using hash tables (<xref rid="btad225-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad225-B16" ref-type="bibr">Holley and Melsted 2020</xref>, <xref rid="btad225-B23" ref-type="bibr">Marchet <italic toggle="yes">et al.</italic> 2021b</xref>, <xref rid="btad225-B27" ref-type="bibr">Pibiri 2022</xref>) or FM-indexes (<xref rid="btad225-B10" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad225-B26" ref-type="bibr">Muggli <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad225-B4" ref-type="bibr">Belazzougui <italic toggle="yes">et al.</italic> 2018</xref>)] where the key set corresponds to all <italic toggle="yes">k</italic>-mers of the collection. Such static structure hardly scale to extensive instances with large <italic toggle="yes">k</italic>-mer cardinality but can be used for queries with high precision or to build de Bruijn graphs. Some indexing implement some kind of dynamicity either via merging or using dynamic bit vectors (<xref rid="btad225-B17" ref-type="bibr">Holley <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad225-B25" ref-type="bibr">Muggli <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad225-B1" ref-type="bibr">Alipanahi <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>The second family of methods relies on probabilistic set representations (<xref rid="btad225-B30" ref-type="bibr">Solomon and Kingsford 2016</xref>, <xref rid="btad225-B5" ref-type="bibr">Bingmann <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad225-B8" ref-type="bibr">Bradley <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad225-B15" ref-type="bibr">Harris and Medvedev 2020</xref>). These approximate membership query (AMQ) structures trade false positives during the query for improved speed and memory performance compared to the previous category.</p>
    <p>AMQ approaches allowed the indexing of hundreds of thousands of microbial datasets (<xref rid="btad225-B6" ref-type="bibr">Blackwell <italic toggle="yes">et al.</italic> 2021</xref>). For mammalian datasets, scaling to more samples is a timely challenge since the increase in the content of <italic toggle="yes">k</italic>-mer/datasets poses serious issues for the construction/footprint of current methods. Thus, to our knowledge, no published method has yet overcome the barrier set by SeqOthello (<xref rid="btad225-B32" ref-type="bibr">Yu <italic toggle="yes">et al.</italic> 2018</xref>) of indexing over 10 000 mammalian RNA samples.</p>
    <p>This manuscript proposes a novel AMQ method to query biological sequences in collections of datasets dubbed Partitioned Aggregative Bloom Comb Trees (PAC). In our application case, queries are typically alternative splicing events or a short genomic context around a small variant or mutation, for both eukaryotic and microbial species. Our structure is designed to be highly scalable with the number of indexed samples and requires moderate resources.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>In this section, we present our PAC. We kept PAC as an acronym that covers the three keywords, including the main novelties compared to previous tree structures. PAC is available at <ext-link xlink:href="https://github.com/Malfoy/PAC" ext-link-type="uri">https://github.com/Malfoy/PAC</ext-link>.</p>
    <sec>
      <title>2.1 Prerequisites</title>
      <p>A <italic toggle="yes">set of sequences R</italic> (also called “dataset”) is a set of finite strings on the alphabet <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. In practice, sets of sequences can be read sets or genome sets. An input “database” <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is a set of “datasets.” Similarly to the datasets, a “query sequence” is a finite string from which all distinct <italic toggle="yes">k</italic>-mers are extracted (typically, a gene, a transcript, or some genomic context around a base mutation).</p>
      <p>In the following, we suppose that broadly used concepts in the context of computational genomics are known [namely, <italic toggle="yes">k</italic>-mers, Bloom filters (<xref rid="btad225-B7" ref-type="bibr">Bloom 1970</xref>), and minimizers (<xref rid="btad225-B28" ref-type="bibr">Roberts <italic toggle="yes">et al.</italic> 2004</xref>, <xref rid="btad225-B10" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic> 2015</xref>)]. However, their definitions are recalled in the online supplementary appendix if needed.</p>
      <p><italic toggle="yes">Problem statement</italic>: The structures described hereafter estimate the cardinality of the intersection of dataset’s <italic toggle="yes">k</italic>-mers with the query’s <italic toggle="yes">k</italic>-mers. Then, according to a threshold parameter <italic toggle="yes">τ</italic>, the query is said to be <italic toggle="yes">in</italic> a dataset if its intersection is larger or equal to <italic toggle="yes">τ</italic>.</p>
      <p><italic toggle="yes">A sequence Bloom tree (SBT)</italic> is an AMQ structure introduced in <xref rid="btad225-B30" ref-type="bibr">Solomon and Kingsford (2016)</xref>. SBTs use a set of <italic toggle="yes">n</italic> Bloom filters, each representing the distinct <italic toggle="yes">k</italic>-mers of the <italic toggle="yes">n</italic> datasets in an input database. A SBT is a balanced binary tree that represents separately each Bloom filter in its leaves and the union of all Bloom filters in its root. Therefore, it allows fast membership queries in the whole database using recursive queries along the tree. We call a “sequence Bloom matrix” the matrix of Bloom filters introduced in BIGSI (<xref rid="btad225-B8" ref-type="bibr">Bradley <italic toggle="yes">et al.</italic> 2019</xref>). For SBTs, a Bloom filter is built for each of the <italic toggle="yes">n</italic> datasets in an input database. Then, these filters are stacked to become a matrix in which each Bloom filter is a column. By accessing a row, one can directly know whether an element is present or absent in all Bloom filters. A <italic toggle="yes">SeqOthello</italic> is an AMQ structure that relies on a different paradigm. It operates as a hash table where pairs of (<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mi>k</mml:mi></mml:math></inline-formula>-mer, presence/absence bitvector) are associated using a static hashing strategy and can efficiently be interrogated for <italic toggle="yes">k</italic>-mer’s presence in bit vectors. In the following section, we will define the necessary concepts to detail our novel structure.</p>
    </sec>
    <sec>
      <title>2.2 PAC construction</title>
      <sec>
        <title>2.2.1 Aggregated Bloom filters</title>
        <p>PAC, as most AMQ structures, relies on Bloom filters to represent <italic toggle="yes">k</italic>-mers presence. For fixed parameters (<italic toggle="yes">k</italic>, <italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>) (respectively, <italic toggle="yes">k</italic>-mer size, Bloom filter size, and number of hash functions), for each <italic toggle="yes">R<sub>i</sub></italic> <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">D</italic>, we build a Bloom filter BF<sub><italic toggle="yes">i</italic></sub> and populate BF<sub><italic toggle="yes">i</italic></sub> with <italic toggle="yes">R<sub>i’</sub></italic>s <italic toggle="yes">k</italic>-mers. Thus, each Bloom filter represents the <italic toggle="yes">k</italic>-mers of a dataset from <italic toggle="yes">D</italic>. As SBT, we organize our Bloom filters in a tree whose inner nodes result from a merge operation on Bloom filters:<statement id="mthst1"><label>Definition 1</label><p>(<bold>Bloom filter merge</bold>) Let two Bloom filters BF<sub>1</sub> and BF<sub>2</sub> with the same set of parameters (<italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>). We define the <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula> operation as a bitwise OR:
</p></statement><statement id="mthst2"><label>Definition 2</label><p>(<bold>union Bloom filter</bold>) A union Bloom filter is the Bloom filter result of a <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula> operation, with conserved parameters (<italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>).</p></statement></p>
        <disp-formula id="E1">
          <mml:math id="M1" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>b</mml:mi>
              <mml:mi>f</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi mathvariant="italic">merge</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:msub>
              <mml:mo>,</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>2</mml:mn>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:msub>
              <mml:mo>|</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>2</mml:mn>
              </mml:msub>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>The tree is then built by “merging” filters from bottom to top. The tree root represents the union Bloom filters of all distinct <italic toggle="yes">k</italic>-mers in <italic toggle="yes">D</italic>. PAC involves a novel tree topology in comparison to other SBTs that are balanced binary trees, which will be detailed in the following.<statement id="mthst3"><label>Definition 3</label><p>(<bold>Aggregated Bloom filter</bold>) We define a series of Bloom filters <italic toggle="yes">BF</italic><sub>1</sub>, <italic toggle="yes">BF</italic><sub>2</sub>, …<italic toggle="yes">BF</italic><sub><italic toggle="yes">t</italic></sub> built using common (<italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>) parameters. They represent <italic toggle="yes">k</italic>-mer sets <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. We encode this particular series of <italic toggle="yes">t</italic> filters of size <italic toggle="yes">b</italic> as a matrix <italic toggle="yes">M</italic> of size <italic toggle="yes">t </italic>×<italic toggle="yes"> b</italic>. Let <italic toggle="yes">V</italic> be an integer array of size <italic toggle="yes">b</italic>. For <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the length of the run of 1 in the row <italic toggle="yes">i</italic> of <italic toggle="yes">M</italic>. <italic toggle="yes">V</italic> can effectively encode such a series of <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>S</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> Bloom filters of size <italic toggle="yes">b</italic> using <italic toggle="yes">b</italic> integers of size <italic toggle="yes">S</italic>. In this way, we can encode <italic toggle="yes">t</italic> of such Bloom filters of size <italic toggle="yes">b</italic> using <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>×</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> bits. We call such an integer array <italic toggle="yes">V</italic> encoding for the series of Bloom filters <italic toggle="yes">BF</italic><sub>1</sub>, <italic toggle="yes">BF</italic><sub>2</sub>, …<italic toggle="yes">BF<sub>t</sub></italic> an “Aggregated Bloom filter.”</p></statement><statement id="mthst4"><label>Observation 1</label><p>One can notice that any branch of a SBT could be represented by an Aggregated Bloom filters, with <italic toggle="yes">BF<sub>t</sub></italic> being the leaf node in the branch, and <italic toggle="yes">BF</italic><sub>1</sub> the root node.</p></statement></p>
      </sec>
      <sec>
        <title>2.2.2 Aggregated Bloom comb trees</title>
        <statement id="mthst5">
          <label>Definition 4</label>
          <p>(<bold>Comb tree</bold>) We call a comb tree a binary tree whose each internal node has at least one leaf as a child. When considering an order on the leaves, a “left-comb tree” (respectively, “a right-comb tree”) has its root connected to the rightmost leaf (respectively, the leftmost leaf).</p>
        </statement>
        <p>PAC relies on Bloom comb trees to organize the set of Bloom filters representing each dataset.<statement id="mthst6"><label>Definition 5</label><p>(<bold>Bloom comb tree</bold>) We call a Bloom comb tree a comb tree built using the <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula> operation. First, given a list of Bloom filters <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> representing datasets, the leaves of the comb tree are built. Each leaf contains a Bloom filter as in SBTs. A Bloom left-comb tree is such that the leftmost inner node <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The right-comb tree can be defined by symmetry.</p></statement><statement id="mthst7"><p><bold>Property 1</bold> In a Bloom left-comb tree built from a list of Bloom filters <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we have <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⊆</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⊆</mml:mo><mml:mo>…</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">height</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (with “height” being the height of the comb) due to the union operation performed in <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>See <xref rid="btad225-F1" ref-type="fig">Fig. 1</xref> for an example of the difference between a tree used by SBTs and a Bloom comb tree.</p>
        <fig position="float" id="btad225-F1">
          <label>Figure 1.</label>
          <caption>
            <p>Left: A SBT structure. Right: A Bloom left-comb tree for the same database. Four datasets of a database are represented using grey shapes. Toy example Bloom filters are represented as bit vectors associated with shapes, and the content of each node is recalled. In the case of the Bloom comb tree, the inner nodes’ Bloom filters (highlighted zone in grey) are not explicitly represented but are encoded using an Aggregated Bloom filter instead (integer vector). Runs of 1’s corresponding to the integers are colored. For instance, the leftmost 1 is found at Levels 1 and 2, therefore a run of length two in the vector.</p>
          </caption>
          <graphic xlink:href="btad225f1" position="float"/>
        </fig>
        <statement id="mthst8">
          <label>Observation 2</label>
          <p>Similarly to the previous observation, one can notice that the longest branch of the comb is a series of Aggregated Bloom filters.</p>
        </statement>
        <p>Following Observation 2, we propose using an Aggregated Bloom filter to encode the longest branch of the Bloom comb tree.<statement id="mthst9"><label>Definition 6</label><p>(<bold>Aggregated Bloom Comb Tree</bold>) Unless otherwise specified, we denote by “Aggregated Bloom Comb Tree” a structure composed of a pair of Bloom left and right-comb trees built on the same list of leaves. They are represented using two components. First, two Aggregated Bloom filters <italic toggle="yes">V <sub>l</sub></italic>, <italic toggle="yes">V <sub>r</sub></italic> (see Definition 3) of size <italic toggle="yes">b</italic>, representing the branch going through all internal nodes down to the deepest leaf in both left and right-comb tree. Second, <italic toggle="yes">n</italic> Bloom filters are the leaves of both combs.</p></statement></p>
        <p><xref rid="btad225-F2" ref-type="fig">Figure 2A</xref> shows an example of two Bloom comb trees and the Aggregated Bloom filters that represent them. An Aggregated Bloom filter represents a run of 1’s in an inclusion series of Bloom filters. Thus, <italic toggle="yes">V<sub>l</sub></italic> (and symmetrically, <italic toggle="yes">V<sub>r</sub></italic>) defines the maximal depth at which 1’s can be encountered at a given position in Bloom filters of the combs, i.e. the search space for a hit. Therefore, intersecting the two <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>′</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> intervals refines the bounds for the search space at each position (see <xref rid="btad225-F2" ref-type="fig">Fig. 2B</xref> for an example).</p>
        <fig position="float" id="btad225-F2">
          <label>Figure 2.</label>
          <caption>
            <p>(A) Two Bloom comb trees and their Aggregated Bloom filters. The leaves Bloom filters are in the middle, colored in grey. They are the Bloom filters representing the input datasets. The left-comb tree (top) and right-comb tree (bottom) are built by aggregating the Bloom filter’s <italic toggle="yes">k</italic>-mers. The Aggregated Bloom filter <italic toggle="yes">V<sub>l</sub></italic> represents the leftmost path of the top comb. Respectively, <italic toggle="yes">V<sub>r</sub></italic> represents the rightmost path of the bottom comb. We colored in green the second bit of leaves in order to show its encoding in the Aggregated Bloom filters. In the left comb, this bit is set to 1 only in the root for the longest branch; therefore, the value is 1 (green) in <italic toggle="yes">V<sub>l</sub></italic>. Conversely, the longest branch of the right tree has a run of five 1’s on the second position, hence, a 5 in <italic toggle="yes">V<sub>r</sub></italic>. (B) Using <italic toggle="yes">V<sub>l</sub></italic> and <italic toggle="yes">V<sub>r</sub></italic> from (A), we show how Aggregated Bloom filters define restrained search spaces in the leaves. Again, the leaves’ Bloom filters are grey, and the values of the vectors are printed vertically. Arrows represent the intervals given by each <italic toggle="yes">V</italic>, and the final search space at each position is the dotted grey area.</p>
          </caption>
          <graphic xlink:href="btad225f2" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>2.2.3 Structure partitioning</title>
        <p>In PAC, we build a distinct “Aggregated Bloom comb tree” for each minimizer associated with a non-empty <italic toggle="yes">k</italic>-mer set.<statement id="mthst10"><label>Definition 7</label><p><bold>[super-<italic toggle="yes">k</italic>-mer</bold> (<xref rid="btad225-B12" ref-type="bibr">Deorowicz <italic toggle="yes">et al.</italic> 2013</xref><bold>)]</bold> From an input string, a super-<italic toggle="yes">k</italic>-mer is a substring containing all consecutive <italic toggle="yes">k</italic>-mers that share a minimizer of size <italic toggle="yes">m</italic>.</p></statement></p>
        <p>As consecutive <italic toggle="yes">k</italic>-mers in a sequence largely overlap, blocks of <italic toggle="yes">k</italic>-mers tend to share their minimizer and yield super-<italic toggle="yes">k</italic>-mers. By associating super-<italic toggle="yes">k</italic>-mers to their minimizers (and therefore the <italic toggle="yes">k</italic>-mers they come from) one can divide a <italic toggle="yes">k</italic>-mer set into up to <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> partitions (<xref rid="btad225-B12" ref-type="bibr">Deorowicz <italic toggle="yes">et al.</italic> 2013</xref>). See the <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref> in the Appendix for an example.</p>
        <p><xref rid="btad225-F3" ref-type="fig">Figure 3A</xref> shows which information is stored in a partition to represent a PAC. The combined <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> “Aggregated Bloom comb trees” stored in <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> partitions represent the complete PAC structure.</p>
        <fig position="float" id="btad225-F3">
          <label>Figure 3.</label>
          <caption>
            <p>(A) The content of one partition in PAC. The Aggregated Bloom comb trees constructed for a given partition are represented using Bloom filter leaves (in gray) and two Aggregated Bloom filters <italic toggle="yes">V<sub>l</sub></italic> and <italic toggle="yes">V<sub>r</sub></italic>. (B) A single query in the same partition as (A). The index has been inverted. A <italic toggle="yes">k</italic>-mer enters a PAC by finding the partition corresponding to its minimizer. <italic toggle="yes">V<sub>l</sub></italic> and <italic toggle="yes">V<sub>r</sub></italic> are loaded, and a search space (here <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> only) is defined given the position obtained by hashing the <italic toggle="yes">k</italic>-mer (here the <italic toggle="yes">k</italic>-mer’s hash value is 2). Then, a slice is extracted from the inverted index at the given position, and bits are checked to find 1’s. Here, there is a single position, so necessarily an 1.</p>
          </caption>
          <graphic xlink:href="btad225f3" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>2.2.4 Query</title>
        <statement id="mthst11">
          <label>Definition 8</label>
          <p>(<bold>Single query</bold>) We call a single query the query of a single <italic toggle="yes">k</italic>-mer to an AMQ data structure. The single query outputs a bit vector of size <italic toggle="yes">n</italic> indicating the presence/absence of a <italic toggle="yes">k</italic>-mer in each dataset.</p>
        </statement>
        <statement id="mthst12">
          <label>Definition 9</label>
          <p>(<bold>Multiple query</bold>) Let <italic toggle="yes">s</italic> be a string of size <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. We call a multiple query the query of consecutive <italic toggle="yes">k</italic>-mers in <italic toggle="yes">s</italic> through single queries to an AMQ data structure. The results scores are reported in an integer vector of size <italic toggle="yes">n</italic>.</p>
        </statement>
        <p>For all AMQ structures studied in this article, the worst-case time complexity for single queries is in <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, the number of random access impacts is critical for runtimes in practice.<statement id="mthst13"><label>Definition 10</label><p>(<bold>Inverted Bloom filter index</bold>) In this framework, we call an inverted Bloom filter index an index that maps each possible hash value <italic toggle="yes">h</italic> to a bit vector of size <italic toggle="yes">n</italic> that represents which filters have one at position <italic toggle="yes">h</italic>.</p></statement></p>
        <p>To minimize the amount of random access, we rely on Inverted Bloom indexes during query time.</p>
        <p>For each <italic toggle="yes">k</italic>-mer, its hash value <italic toggle="yes">h</italic> is computed, and the bit slice <italic toggle="yes">h</italic> is searched to find which Bloom filters include it. To further increase data locality, we construct one Inverted Bloom filter index per partition. In this way, querying successive <italic toggle="yes">k</italic>-mers from a super-<italic toggle="yes">k</italic>-mer is done on the same small data structure, reducing the amount of cache misses. Such partition indexes are only constructed if needed and kept to avoid redundant operations following a lazy strategy. An example is presented in <xref rid="btad225-F3" ref-type="fig">Fig. 3B</xref> (super-<italic toggle="yes">k</italic>-mers are omitted). Finally, we maintain and return a score vector of size <italic toggle="yes">n</italic>. It is incremented by one at a position <italic toggle="yes">j</italic> each time a <italic toggle="yes">k</italic>-mer appears in leaf <italic toggle="yes">j</italic>. Therefore, PAC is also related to Sequence Bloom matrices because queries are handled using a matrix of Bloom filters.</p>
      </sec>
      <sec>
        <title>2.2.5 Update PAC by inserting new datasets</title>
        <p>Adding new datasets does not require changing the index structure. New datasets can be added by constructing their Bloom filters and updating the values of the Aggregated Bloom filters when needed. We implemented this functionality to allow the user to insert a dataset collection into an existing index. This insertion presents a very similar cost to building an index from the said collection, as both the construction and update algorithms consist of successive insertions. It avoids the need to rebuild the index from scratch due to novel datasets.</p>
      </sec>
      <sec>
        <title>2.2.6 Implementation details</title>
        <sec>
          <title>2.2.6.1 Memory usage and parallelization</title>
          <p>Bloom filters are constructed in RAM and serialized on disk to avoid heavy memory usage. In this way, only one Bloom filter is stored in RAM at a given time (<italic toggle="yes">C</italic> if <italic toggle="yes">C</italic> threads are used to treat the datasets in parallel). A PAC index is distributed into <italic toggle="yes">P</italic> sections serialized in <italic toggle="yes">P</italic> different files. Such sections can be handled separately, being mutually exclusive. This strategy provides inherent coarse-grained parallelism, as different threads can operate on different sections without mutual exclusion mechanisms during construction. It also grants low memory usage as only small sections (i.e. a fraction of the total index) have to be stored in memory at a given time.</p>
          <p>Similarly, the query also benefits from partitioning. All <italic toggle="yes">k</italic>-mer associated with a given partition are queried at once in a sequential way to limit memory usage. Each Bloom filter is loaded separately in RAM and freed after the inverted index is constructed to be queried (<italic toggle="yes">C</italic> Bloom filters can be loaded simultaneously in RAM if <italic toggle="yes">C</italic> threads are used). This behavior guarantees that each partition will only be read from the disk once and that only one partition will be stored in RAM at a given time. Furthermore, partitions not associated with any query <italic toggle="yes">k</italic>-mer can be skipped. Both construction and query benefit from improved cache coherence as several successive <italic toggle="yes">k</italic>-mers are located in the same small structure, generating cache misses for groups of <italic toggle="yes">k</italic>-mers instead of doing so for nearly each <italic toggle="yes">k</italic>-mer.</p>
        </sec>
        <sec>
          <title>2.2.6.2 Inverted index</title>
          <p>Bloom filters are represented as sparse bit vectors (using the BitMagic library (<ext-link xlink:href="https://github.com/Malfoy/PAC/blob/main/listpacpaper.txt.gz" ext-link-type="uri">https://github.com/Malfoy/PAC/blob/main/listpacpaper.txt.gz</ext-link> )] in order to optimize memory usage.</p>
        </sec>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>All experiments were performed on a single cluster node running with Intel(R) Xeon(R) Gold 6130 CPU @ 2.10 GHz with 128 GB of RAM and Ubuntu 22.04.</p>
    <sec>
      <title>3.1 Indexing 2500 human datasets and comparison to other AMQ structures</title>
      <p>We compared PAC against the latest methods of the AMQ paradigm, i.e. HowDeSBT (<xref rid="btad225-B15" ref-type="bibr">Harris and Medvedev 2020</xref>) for SBTs and SeqOthello (<xref rid="btad225-B32" ref-type="bibr">Yu <italic toggle="yes">et al.</italic> 2018</xref>). We also tested COBS (<xref rid="btad225-B5" ref-type="bibr">Bingmann <italic toggle="yes">et al.</italic> 2019</xref>), the most recent sequence Bloom matrix, although it is not designed to work with sequencing data, but rather genomes. We used kmtricks (<xref rid="btad225-B19" ref-type="bibr">Lemane <italic toggle="yes">et al.</italic> 2022</xref>) for an optimized construction of HowDeSBT and its Bloom filters (commit number <monospace>532d545</monospace>). SeqOthello (commit 68d47e0) uses Jellyfish (<xref rid="btad225-B21" ref-type="bibr">Marçais and Kingsford 2011</xref>) for its preprocessing, we worked with version 2.3.0. COBS’s version was v0.1.2, and PAC’s commit was <monospace>cee1b5c</monospace>. We used the classic mode of COBS that does not rely on folding to ensure a fair comparison of Bloom filter size and practical false-positive rate across tools.</p>
      <p>The dataset first used in the initial SBT contribution (<xref rid="btad225-B30" ref-type="bibr">Solomon and Kingsford 2016</xref>) has become a <italic toggle="yes">de facto</italic> benchmark in almost any subsequent article that describes a related method. We make no exception, and benchmarked PAC and other AMQ structures on this dataset. It contains 2585 human RNA-seq datasets, with low-frequency <italic toggle="yes">k</italic>-mers filtered according to previous works (<xref rid="btad225-B31" ref-type="bibr">Solomon and Kingsford 2018</xref>) (<ext-link xlink:href="https://www.cs.cmu.edu/ckingsf/software/bloomtree/srr-list.txt" ext-link-type="uri">https://www.cs.cmu.edu/ ckingsf/software/bloomtree/srr-list.txt</ext-link>), resulting in a total of <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>3.8</mml:mn></mml:mrow></mml:math></inline-formula> billion of distinct <italic toggle="yes">k</italic>-mers. The input files are represented as compacted de Bruijn graphs generated by Bcalm2 (<xref rid="btad225-B11" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic> 2016</xref>) in gzipped FASTA files. We also kept the settings used in previous benchmarks and used a <italic toggle="yes">k</italic> value of 21. We chose COBS, PAC, and HowDeSBT’s settings to have an average 0.5% false-positive rate. Notably, SeqOthello’s false-positive rate cannot be controlled.</p>
      <p>In <xref rid="btad225-T1" ref-type="table">Table 1</xref>, we present the costs of indexing this database with the different tools. Several observations can be made. First, PAC does not generate any temporary disk footprint; only the final index is written on disk, while HowDeSBT, SeqOthello, and COBS generate many temporary files that are an order of magnitude larger than the index itself. Another observation is that PAC and COBS’s preprocessing and index construction steps are comparable and faster than the other tools, showing at least a 2-fold improvement of required CPU time. The total computational cost of a PAC index is improved three times over SeqOthello and six times over HowDeSBT. Memory-wise, the memory footprint of HowDeSBT and PAC are both low, while SeqOthello and COBS are somewhat higher without being prohibitively high. Finally, excluding COBS, the different produced indexes are of the same order of magnitude, even if PAC presents the heaviest index, slightly larger than SeqOthello, while HowDeSBT is the smallest. This can be explained by the fact that tree-based tools (as HowDeSBT) spend a lot of time to choose how to group and merge files to optimize the index compressibility resulting in a hard to construct but smaller indexes tradeoff. Computing an efficient file ordering to boost compression is an interesting problem that would benefit any matrix-based index. Being compression-free, COBS’ index is two orders of magnitude larger than the other tools and produces even larger temporary files. COBS’ CPU time is similar to PAC’s, but its heavy disk usage presents a higher wall-clock time on our hard-disk drives.</p>
      <table-wrap position="float" id="btad225-T1">
        <label>Table 1.</label>
        <caption>
          <p>Index construction resource requirements on 2585 RNA-seq<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">Max temporary</th>
              <th align="center" rowspan="1" colspan="1">Preprocessing</th>
              <th align="center" rowspan="1" colspan="1">Index construction</th>
              <th align="center" rowspan="1" colspan="1">Peak RAM</th>
              <th align="center" rowspan="1" colspan="1">Final index size</th>
            </tr>
            <tr>
              <th align="center" rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">disk (GB)</th>
              <th align="center" rowspan="1" colspan="1">time (CPU, h)</th>
              <th align="center" rowspan="1" colspan="1">time (CPU, h)</th>
              <th align="center" rowspan="1" colspan="1">(GB)</th>
              <th align="center" rowspan="1" colspan="1">(GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">COBS</td>
              <td rowspan="1" colspan="1">4914</td>
              <td rowspan="1" colspan="1">
                <bold>7</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1</bold>
              </td>
              <td rowspan="1" colspan="1">111</td>
              <td rowspan="1" colspan="1">2458</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">HowDeSBT</td>
              <td rowspan="1" colspan="1">650</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">44</td>
              <td rowspan="1" colspan="1">
                <bold>4.2</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>15</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SeqOthello</td>
              <td rowspan="1" colspan="1">1000</td>
              <td rowspan="1" colspan="1">19</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">43</td>
              <td rowspan="1" colspan="1">25</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PAC</td>
              <td rowspan="1" colspan="1">
                <bold>0</bold>
              </td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">
                <bold>1</bold>
              </td>
              <td rowspan="1" colspan="1">9.6</td>
              <td rowspan="1" colspan="1">28</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <label>a</label>
            <p>The column “Max temporary disk” reports the maximal external space taken by the method (usually during preprocessing). The “Final Index Size” indicates the final index size when stored on disk. Bold values indicate the best result in each column. The execution times of the methods are reported in CPU hours. All methods were run with 12 threads.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>3.2 Indexing over 32 000 human datasets and scalability regarding the number of datasets</title>
      <p>We downloaded 32 768 RNA-seq samples from SRA [accession list in available on the github repository (<ext-link xlink:href="https://github.com/tlk00/BitMagic" ext-link-type="uri">https://github.com/tlk00/BitMagic</ext-link>)] for a total of 30 TB of uncompressed FASTQ data. We created incremental batches of 2<sup>8</sup>, 2<sup>9</sup>, …, up to 2<sup>15</sup> datasets to document the scalability of methods according to the number of datasets. In this second experiment, the indexes are built directly on sequencing datasets in raw FASTA format, containing redundant <italic toggle="yes">k</italic>-mers and sequencing errors. Each tool was configured to filter unique <italic toggle="yes">k</italic>-mers before indexing to remove most sequencing errors (we used <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>31). Since COBS does not provide such an option and produces huge index files, we did not include it in this benchmark. To approximate the order of magnitude of the amount of (non-unique) distinct <italic toggle="yes">k</italic>-mers, we used ntcard (<xref rid="btad225-B24" ref-type="bibr">Mohamadi <italic toggle="yes">et al.</italic> 2017</xref>). For example, the batch of 2<sup>11</sup> datasets contains ∼3 billion <italic toggle="yes">k</italic>-mers to index, while the 2<sup>14</sup> dataset contains more than 40 billion <italic toggle="yes">k</italic>-mers.</p>
      <p>In <xref rid="btad225-F4" ref-type="fig">Fig. 4</xref>, we report the CPU time required for index construction (including preprocessing) to display their evolution on databases of increasing size. In <xref rid="btad225-F5" ref-type="fig">Fig. 5</xref>, we report temporary disk usage during index construction and the final index sizes on the disk after compression.</p>
      <fig position="float" id="btad225-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Results on increasing human dataset sizes. We report total CPU hours for constructing the different indexes, including the Bloom filter construction and index constructions. <italic toggle="yes">X</italic>-axis is in <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> scale and <italic toggle="yes">Y</italic>-axis is in <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> scale. All methods were run with 12 threads.</p>
        </caption>
        <graphic xlink:href="btad225f4" position="float"/>
      </fig>
      <fig position="float" id="btad225-F5">
        <label>Figure 5.</label>
        <caption>
          <p>Results on increasing human dataset sizes. We report disk footprints, both temporary and final, for constructing the different indexes. Note that PAC does not use temporary disk. <italic toggle="yes">X</italic>-axis is in <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> scale and <italic toggle="yes">Y</italic>-axis is in <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> scale. All methods were run with 12 threads.</p>
        </caption>
        <graphic xlink:href="btad225f5" position="float"/>
      </fig>
      <p>We can make observations similar to those in the first experiments. PAC is the only tool that managed to build an index of the 32 000 human RNA-seq samples, in ∼5 days (∼60 CPU days), using 22 GB of RAM and for a total index size of 1.1 TB. PAC’s construction is faster than the state-of-the-art for the whole construction process. It produces slightly bigger indexes, but requires much less external memory. SeqOthello crashed during index construction in the experiment with 2<sup>12</sup> datasets, and HowDeSBT failed to end before our ten-day timeout in the experiment with 2<sup>11</sup> datasets. PAC was the only tool to build an index on the 2<sup>13</sup>, 2<sup>14</sup>, and 2<sup>15</sup> datasets.</p>
    </sec>
    <sec>
      <title>3.3 Indexing microbial datasets</title>
      <p>Besides indexing RNA-seq data, AMQ indexes were also used to index large collections of bacterial genomes. To further highlight the scalability of PAC, we built it on two massive bacterial collections. In a first experiment, we fetched the 661 000 bacterial genomes representing more than three terabases, which were previously collected in a database (<xref rid="btad225-B6" ref-type="bibr">Blackwell <italic toggle="yes">et al.</italic> 2021</xref>) and built two indexes on this collection. A first index featuring large Bloom filters (2<sup>29</sup> bits) for low <italic toggle="yes">k</italic>-mer query false-positive rates (below 1% for five megabases genomes) and a second index with smaller Bloom filters (2<sup>27</sup> bits) when higher false-positive rates can be allowed (below 7% for five megabases genomes). Both indexes were constructed within 24 h using 21 and 6 GB of RAM, respectively, for a total size of 2.4 and 1.4 TB, respectively.</p>
      <p>In a second experiment, we downloaded all bacterial assemblies available on GenBank (counting 1 200 575 genomes at the time of the experiment and representing more than five terabases) and built an index with a Bloom filter size of 2<sup>27</sup> bits that corresponds to a false-positive rate around 4% for five megabases genomes. The construction lasted 24 h for a total of 410 CPU hours using less than 5 GB of RAM for a total index size of 3.5 TB. This is to our knowledge the largest collection ever indexed by an AMQ.</p>
    </sec>
    <sec>
      <title>3.4 Query results on human RefSeq</title>
      <p>We designed a similar experiment to the one presented in HowDeSBT’s paper, with sequence batches of increasing sizes. We repetitively selected random transcripts from human RefSeq [using seqkit (<xref rid="btad225-B29" ref-type="bibr">Shen <italic toggle="yes">et al.</italic> 2016</xref>)], and gathered 10, 10, 5, 3, and 3 batches of sizes 1, 10, 100, 1000, and 10 000 transcripts. We report HowDeSBT, SeqOthello, and PAC’s CPU time on each batch size in <xref rid="btad225-F6" ref-type="fig">Fig. 6</xref>. We warmed the cache before profiling the queries. In accordance with the literature (<xref rid="btad225-B15" ref-type="bibr">Harris and Medvedev 2020</xref>), we observe that SBT structures perform the best on small query sets. In larger instances, other methods can be preferred. SeqOthello shows the best performance and keeps a relatively constant query time over the input size. PAC has the same behavior, while being slightly more CPU time than SeqOthello. We also note that no method required more than 10 GB of RAM to perform the queries. PAC had the lowest RAM footprint, with up to 2 GB for 10 000 transcripts. COBS CPU time usages are not representative of its actual queries’ performance, as it incurs almost no CPU times (typically &lt;1 CPU second per transcript), so we chose not to plot it along with its competitors.</p>
      <fig position="float" id="btad225-F6">
        <label>Figure 6.</label>
        <caption>
          <p>Results on query batches. We present query CPU times computed on batches of 1 to 10k transcript sequences. The <italic toggle="yes">Y</italic>-axis is on a <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> scale. The queries were computed using 12 threads.</p>
        </caption>
        <graphic xlink:href="btad225f6" position="float"/>
      </fig>
      <p>We performed a separate benchmark to assess the queries wall-clock times. On a batch of 100 transcripts, HowDeSBT lasted 1 h 30 min, COBS lasted 30 min, SeqOthello lasted 10 min, and PAC lasted 5 min. Interestingly, on a larger batch of 10 000 transcripts, SeqOthello and PAC presented very similar results (10 and 5 min, respectively). These results indicate that the query time of these two tools is dominated by index loading. To assess when query time became predominant, we queried a large batch of 100 000 transcripts for which PAC lasted 11 min (two CPU hours) and an even larger batch of 500 000 transcripts handled by PAC in 40 min (6.5 CPU hours).</p>
    </sec>
    <sec>
      <title>3.5 Impact of comb structure on query for collections entailing high <italic toggle="yes">k</italic>-mer diversity</title>
      <p>One novelty of PAC is the use of lightweight Aggregated Bloom filters to accelerate the queries by skipping subsections of the bit-slices. To assess the efficiency of this strategy, we report in <xref rid="btad225-T2" ref-type="table">Table 2</xref> the query times of several query batches on an index composed of all complete <italic toggle="yes">Salmonella enterica</italic> genomes from RefSeq (counting 11 993 genomes at the time of the experiment). We report three different query times for each batch, using, respectively, two Aggregated Bloom Comb trees (according to Definition 6), a single one and none (i.e. the structure is a Bloom matrix). Without the use of Aggregated Bloom filters PAC index is conceptually identical to a matrix approach, such as COBS while using one or two Aggregated Bloom filters allow to skip some bitslice of the index. The number of bits that can be skipped depends in practice on the similarity shared between the query and the indexed documents. To highlight this effect, a batch is made up of <italic toggle="yes">S.enterica</italic> that are highly similar to the indexed genomes, a batch is made up of <italic toggle="yes">Escherichia coli</italic> that are very dissimilar to the indexed genomes, and a batch is made up of random sequence to show an extreme example of dissimilarity. The first observation is that Aggregated Bloom filters hardly improve the query time of the <italic toggle="yes">S.enterica</italic> batch. This result is expected because most query <italic toggle="yes">k</italic>-mers should be found in many indexed genomes and the amount of zeros that could be skipped in such slices should be very low. However, we see that using one Aggregated Bloom filter greatly accelerates the query on the two dissimilar batches, increasing the throughput by several fold. Furthermore, using a second Aggregated Bloom filter accelerates the query time even more but is not as beneficial as the first one.</p>
      <table-wrap position="float" id="btad225-T2">
        <label>Table 2.</label>
        <caption>
          <p>Results on query times in CPU hours according to the PAC mode used along with the speedup obtained compared to the classical matrix approach (No ABF column)<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Query dataset</th>
              <th align="center" rowspan="1" colspan="1">Double ABF filter</th>
              <th align="center" rowspan="1" colspan="1">Single ABF filter</th>
              <th align="center" rowspan="1" colspan="1">No ABF</th>
              <th align="center" rowspan="1" colspan="1">Overhead</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">200 Random genomes</td>
              <td rowspan="1" colspan="1">0.7 (13.6×)</td>
              <td rowspan="1" colspan="1">1.3 (7.3×)</td>
              <td rowspan="1" colspan="1">9.5</td>
              <td rowspan="1" colspan="1">1.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">200 <italic toggle="yes">E.coli</italic> genomes</td>
              <td rowspan="1" colspan="1">1.2 (7×)</td>
              <td rowspan="1" colspan="1">2.2 (3.8×)</td>
              <td rowspan="1" colspan="1">8.4</td>
              <td rowspan="1" colspan="1">1.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">200 <italic toggle="yes">S.enterica</italic> genomes</td>
              <td rowspan="1" colspan="1">10.4 (1.2×)</td>
              <td rowspan="1" colspan="1">11.6 (1×)</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">1.0</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <label>a</label>
            <p>Double, Single, No ABF denotes the number of combs used in the structure. We present query CPU times computed along with the overhead constant across modes that include parsing the query file and loading the index. The random genomes are random nucleotide sequences of length five megabases. <italic toggle="yes">E.coli</italic> and <italic toggle="yes">S.enterica</italic> genomes were randomly selected among the RefSeq genomes.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>To our knowledge, PAC is the first AMQ <italic toggle="yes">k</italic>-mer set structure to index the entire GenBank bacterial genome collection and reach 32k human RNA-seq datasets.</p>
    <p>PAC combines the simplicity and efficiency of inverted index matrix approaches, such as COBS or BIGSI with a lightweight tree structure.</p>
    <p>The novel tree structure has a minimal resource footprint, yet greatly improves the query time when a query is dissimilar to the index content, a scenario possibly met with microbial databases. As <italic toggle="yes">k</italic>-mer sets are designed to efficiently skip unrelevant documents, our Aggregated Bloom filters allow us to efficiently prune our query space.</p>
    <p>Using several real datasets, we demonstrate that PAC is practically scalable for its construction. In contrast to other approaches, PAC is simultaneously frugal in RAM, disk, and time requirements for building an index.</p>
    <p>We showed PAC’s ability to query 500 000 human transcripts in less than an hour, being the fastest in wall-clock time, and comparable to SeqOthello in CPU time. The worst-case query complexity remains the same for all methods, <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a <italic toggle="yes">k</italic>-mer present in all <italic toggle="yes">n</italic> datasets.</p>
    <p>We reviewed that inverted indexes methods perform <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>Θ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> random accesses, but still need to read bit-slices of size <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Using Aggregated Bloom filters, PAC improves these indexes, as in favorable cases (<italic toggle="yes">k</italic>-mers present in a single dataset with no collision or absent everywhere), PAC can answer in <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad225_Supplementary_Data</label>
      <media xlink:href="btad225_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors would like to thank Léonid and Zora for a renewed sense of what tiredness, teamwork and joy are. They also thank Daniel Gautheret for providing us with tips on the SRA API, RECOMB-Seq reviewers, and Anatoliy Kuznetsov for his outstanding Bitmagic library and sustained support.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by grants from the Agence Nationale de la recherche for the project “full-RNA” [ANR-22-CE45-0007]; and “AGATE” [ANR-21-CE45-0012].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad225-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alipanahi</surname><given-names>B</given-names></string-name>, <string-name><surname>Kuhnle</surname><given-names>A</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name></person-group><etal>et al</etal><article-title>Succinct dynamic de Bruijn graphs</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>1946</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">32462192</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F</given-names></string-name>, <string-name><surname>Sarkar</surname><given-names>H</given-names></string-name>, <string-name><surname>Srivastava</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>A space and time-efficient index for the compacted colored de Bruijn graph</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>i169</fpage>–<lpage>77</lpage>.<pub-id pub-id-type="pmid">29949982</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Gish</surname><given-names>W</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Basic local alignment search tool</article-title>. <source>J Mol Biol</source><year>1990</year>;<volume>215</volume>:<fpage>403</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Belazzougui</surname><given-names>D</given-names></string-name>, <string-name><surname>Gagie</surname><given-names>T</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V</given-names></string-name></person-group><etal>et al</etal><article-title>Bidirectional variable-order de Bruijn graphs</article-title>. <source>Int J Found Comput Sci</source><year>2018</year>;<volume>29</volume>:<fpage>1279</fpage>–<lpage>95</lpage>.</mixed-citation>
    </ref>
    <ref id="btad225-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bingmann</surname><given-names>T</given-names></string-name>, <string-name><surname>Bradley</surname><given-names>P</given-names></string-name>, <string-name><surname>Gauger</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal> COBS: a compact bit-sliced signature index. In: <italic toggle="yes">SPIRE</italic>. <year>2019</year>. doi: 1905.09624.</mixed-citation>
    </ref>
    <ref id="btad225-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blackwell</surname><given-names>GA</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>M</given-names></string-name>, <string-name><surname>Malone</surname><given-names>KM</given-names></string-name></person-group><etal>et al</etal><article-title>Exploring bacterial diversity via a curated and searchable snapshot of archived DNA sequences</article-title>. <source>PLoS Biol</source><year>2021</year>;<volume>19</volume>:<fpage>e3001421</fpage>.<pub-id pub-id-type="pmid">34752446</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bloom</surname><given-names>BH.</given-names></string-name></person-group><article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun ACM</source><year>1970</year>;<volume>13</volume>:<fpage>422</fpage>–<lpage>6</lpage>.</mixed-citation>
    </ref>
    <ref id="btad225-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bradley</surname><given-names>P</given-names></string-name>, <string-name><surname>den Bakker</surname><given-names>HC</given-names></string-name>, <string-name><surname>Rocha</surname><given-names>EPC</given-names></string-name></person-group><etal>et al</etal><article-title>Ultrafast search of all deposited bacterial and viral genomic data</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>152</fpage>–<lpage>9</lpage>. <pub-id pub-id-type="doi">10.1038/s41587-018-0010-1</pub-id>.<pub-id pub-id-type="pmid">30718882</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Camacho</surname><given-names>C</given-names></string-name>, <string-name><surname>Coulouris</surname><given-names>G</given-names></string-name>, <string-name><surname>Avagyan</surname><given-names>V</given-names></string-name></person-group><etal>et al</etal><article-title>BLAST+: architecture and applications</article-title>. <source>BMC Bioinformatics</source><year>2009</year>;<volume>10</volume>:<fpage>1</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">19118496</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Jackman</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>On the representation of de Bruijn graphs</article-title>. <source>J Comput Biol</source><year>2015</year>;<volume>22</volume>:<fpage>336</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">25629448</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>i201</fpage>–<lpage>8</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw279</pub-id>.<pub-id pub-id-type="pmid">27307618</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>, <string-name><surname>Debudaj-Grabysz</surname><given-names>A</given-names></string-name>, <string-name><surname>Grabowski</surname><given-names>S.</given-names></string-name></person-group><article-title>Disk-based k-mer counting on a PC</article-title>. <source>BMC Bioinformatics</source><year>2013</year>;<volume>14</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">23323762</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dolle</surname><given-names>DD</given-names></string-name>, <string-name><surname>Liu</surname><given-names>Z</given-names></string-name>, <string-name><surname>Cotten</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Using reference-free compressed data structures to analyze sequencing reads from thousands of human genomes</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>300</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">27986821</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B14">
      <mixed-citation publication-type="other"><collab>European Nucleotide Archive</collab>. <italic toggle="yes">ENA Statistics — Reads Growth - Reads Doubling Time</italic>. <ext-link xlink:href="https://www.ebi.ac.uk/ena/about/statistics" ext-link-type="uri">https://www.ebi.ac.uk/ena/about/statistics</ext-link> (18 January 2023, date last accessed).</mixed-citation>
    </ref>
    <ref id="btad225-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Harris</surname><given-names>RS</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Improved representation of sequence bloom trees</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>721</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">31504157</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Melsted</surname><given-names>P.</given-names></string-name></person-group><article-title>Bifrost: highly parallel construction and indexing of colored and compacted de Bruijn graphs</article-title>. <source>Genome Biol</source><year>2020</year>;<volume>21</volume>:<fpage>1</fpage>–<lpage>20</lpage>.</mixed-citation>
    </ref>
    <ref id="btad225-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Wittler</surname><given-names>R</given-names></string-name>, <string-name><surname>Stoye</surname><given-names>J.</given-names></string-name></person-group><article-title>Bloom Filter Trie: an alignment-free and reference-free data structure for pan-genome storage</article-title>. <source>Algorithms Mol Biol</source><year>2016</year>;<volume>11</volume>:<fpage>1</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">26913054</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Janin</surname><given-names>L</given-names></string-name>, <string-name><surname>Schulz-Trieglaff</surname><given-names>O</given-names></string-name>, <string-name><surname>Cox</surname><given-names>AJ.</given-names></string-name></person-group><article-title>BEETL-fastq: a searchable compressed archive for DNA reads</article-title>. <source>Bioinformatics</source><year>2014</year>;<volume>30</volume>:<fpage>2796</fpage>–<lpage>801</lpage>.<pub-id pub-id-type="pmid">24950811</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lemane</surname><given-names>T</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>kmtricks: efficient and flexible construction of Bloom filters for large sequencing data collections</article-title>. <source>Bioinform Adv</source><year>2022</year>;<volume>2</volume>:<fpage>vbac029</fpage>.<pub-id pub-id-type="pmid">36699393</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>. <source>Bioinformatics</source><year>2009</year>;<volume>25</volume>:<fpage>1754</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>764</fpage>–<lpage>70</lpage>.<pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name></person-group><etal>et al</etal><article-title>Data structures based on k-mers for querying large collections of sequencing data sets</article-title>. <source>Genome Res</source><year>2021a</year>;<volume>31</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">33328168</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C</given-names></string-name>, <string-name><surname>Kerbiriou</surname><given-names>M</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A.</given-names></string-name></person-group><article-title>BLight: efficient exact associative structure for k-mers</article-title>. <source>Bioinformatics</source><year>2021b</year>;<volume>37</volume>:<fpage>2858</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">33821954</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mohamadi</surname><given-names>H</given-names></string-name>, <string-name><surname>Khan</surname><given-names>H</given-names></string-name>, <string-name><surname>Birol</surname><given-names>I.</given-names></string-name></person-group><article-title>ntCard: a streaming algorithm for cardinality estimation in genomics data</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>1324</fpage>–<lpage>30</lpage>.<pub-id pub-id-type="pmid">28453674</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muggli</surname><given-names>MD</given-names></string-name>, <string-name><surname>Alipanahi</surname><given-names>B</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C.</given-names></string-name></person-group><article-title>Building large updatable colored de Bruijn graphs via merging</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>i51</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">31510647</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muggli</surname><given-names>MD</given-names></string-name>, <string-name><surname>Bowe</surname><given-names>A</given-names></string-name>, <string-name><surname>Noyes</surname><given-names>NR</given-names></string-name></person-group><etal>et al</etal><article-title>Succinct colored de Bruijn graphs</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>3181</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">28200001</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pibiri</surname><given-names>GE.</given-names></string-name></person-group><article-title>Sparse and skew hashing of k-mers</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>i185</fpage>–<lpage>94</lpage>.<pub-id pub-id-type="pmid">35758794</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shen</surname><given-names>W</given-names></string-name>, <string-name><surname>Le</surname><given-names>S</given-names></string-name>, <string-name><surname>Li</surname><given-names>Y</given-names></string-name></person-group><etal>et al</etal><article-title>SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation</article-title>. <source>PLoS One</source><year>2016</year>;<volume>11</volume>:<fpage>e0163962</fpage>.<pub-id pub-id-type="pmid">27706213</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Solomon</surname><given-names>B</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Fast search of thousands of short-read sequencing experiments</article-title>. <source>Nat Biotechnol</source><year>2016</year>;<volume>34</volume>:<fpage>300</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">26854477</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Solomon</surname><given-names>B</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Improved search of large transcriptomic sequencing databases using split sequence bloom trees</article-title>. <source>J Comput Biol</source><year>2018</year>;<volume>25</volume>:<fpage>755</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">29641248</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Liu</surname><given-names>J</given-names></string-name>, <string-name><surname>Liu</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>SeqOthello: querying RNA-seq experiments at scale</article-title>. <source>Genome Biol</source><year>2018</year>;<volume>19</volume>:<fpage>167</fpage>.<pub-id pub-id-type="pmid">30340508</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10311332</article-id>
    <article-id pub-id-type="pmid">37387170</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad225</article-id>
    <article-id pub-id-type="publisher-id">btad225</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Genome Sequence Analysis</subject>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Scalable sequence database search using partitioned aggregated Bloom comb trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Marchet</surname>
          <given-names>Camille</given-names>
        </name>
        <aff><institution>University of Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL</institution>, F-59000 Lille, <country country="FR">France</country></aff>
        <xref rid="btad225-cor1" ref-type="corresp"/>
        <!--camille.marchet@univ-lille.fr-->
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Limasset</surname>
          <given-names>Antoine</given-names>
        </name>
        <aff><institution>University of Lille, CNRS, Centrale Lille, UMR 9189 CRIStAL</institution>, F-59000 Lille, <country country="FR">France</country></aff>
        <xref rid="btad225-cor1" ref-type="corresp"/>
        <!--antoine.limasset@univ-lille.fr-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad225-cor1">Corresponding authors. UMR CRIStAL Université de Lille - Campus scientifique, Bâtiment ESPRIT Avenue Henri Poincaré, 59655 Villeneuve d'Ascq, France. E-mails: <email>antoine.limasset@univ-lille.fr</email> (A.L.) and <email>camille.marchet@univ-lille.fr</email> (C.M.)</corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-06-30">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>30</day>
      <month>6</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>Suppl 1</issue>
    <issue-title>ISMB/ECCB 2023 Proceedings</issue-title>
    <fpage>i252</fpage>
    <lpage>i259</lpage>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad225.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>The Sequence Read Archive public database has reached 45 petabytes of raw sequences and doubles its nucleotide content every 2 years. Although BLAST-like methods can routinely search for a sequence in a small collection of genomes, making searchable immense public resources accessible is beyond the reach of alignment-based strategies. In recent years, abundant literature tackled the task of finding a sequence in extensive sequence collections using <italic toggle="yes">k</italic>-mer-based strategies. At present, the most scalable methods are approximate membership query data structures that combine the ability to query small signatures or variants while being scalable to collections up to 10 000 eukaryotic samples. <bold>Results.</bold> Here, we present PAC, a novel approximate membership query data structure for querying collections of sequence datasets. PAC index construction works in a streaming fashion without any disk footprint besides the index itself. It shows a 3–6 fold improvement in construction time compared to other compressed methods for comparable index size. A PAC query can need single random access and be performed in constant time in favorable instances. Using limited computation resources, we built PAC for very large collections. They include 32 000 human RNA-seq samples in 5 days, the entire GenBank bacterial genome collection in a single day for an index size of 3.5 TB. The latter is, to our knowledge, the largest sequence collection ever indexed using an approximate membership query structure. We also showed that PAC’s ability to query 500 000 transcript sequences in less than an hour.</p>
      </sec>
      <sec id="s2">
        <title>Availability and implementation</title>
        <p>PAC’s open-source software is available at <ext-link xlink:href="https://github.com/Malfoy/PAC" ext-link-type="uri">https://github.com/Malfoy/PAC</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Agence Nationale de la recherche</institution>
            <institution-id institution-id-type="DOI">10.13039/501100001665</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>ANR-22-CE45-0007</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="8"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Public databases, such as the Sequence Read Archive (SRA) or European Nucleotide Archive overflow with sequencing data. The vast amount of sequences, experiments, and species allows, in principle, ubiquitous applications for biologists and clinicians. Such databases are becoming a fundamental shared resource for daily sequence analysis. But concretely, we only witness the onset of their exploitation, while their exponential growth poses serious scalability challenges [for instance, SRA has reached 45 petabytes of raw reads and roughly doubles every 3 years (ena)].</p>
    <p>Today, searching for a query sequence in a single genome/dataset or a restricted collection of genomes is considered routine through alignment-based tools, such as BLAST (<xref rid="btad225-B3" ref-type="bibr">Altschul <italic toggle="yes">et al.</italic> 1990</xref>) and others (<xref rid="btad225-B9" ref-type="bibr">Camacho <italic toggle="yes">et al.</italic> 2009</xref>, <xref rid="btad225-B20" ref-type="bibr">Li and Durbin 2009</xref>, <xref rid="btad225-B18" ref-type="bibr">Janin <italic toggle="yes">et al.</italic> 2014</xref>, <xref rid="btad225-B13" ref-type="bibr">Dolle <italic toggle="yes">et al.</italic> 2017</xref>). In contrast, the scale of databases, such as SRA makes BLAST and any alignment-based method ill-suited due to the prohibitive cost of the alignment phase. Broader usages of such resources necessitate algorithms allowing hyper-scalable membership queries as a foundation. In particular, they must be able to quickly discard a sequence that is absent from a substantial dataset collection. They must also identify the datasets where the query is present. Therefore, recent literature has tackled these problems using alignment-free <italic toggle="yes">k</italic> -mer-based strategies.</p>
    <p>The known most scalable solutions are sketching methods, which reduce the datasets to a small set of signatures based on the principle of locality-sensitive hashing. However, the loss of resolution implied by these methods narrows the query possibilities to large queries of the order of magnitude of genomes or larger. Numerous applications rely on significantly smaller query size, e.g. variant calling of SNP/small indels, finding alternative splicing sites, or other small genomic signatures.</p>
    <p>Recent alignment-free literature has described novel methodologies to fill a dual need: small queries in vast dataset collections. Mostly, two paradigms (<xref rid="btad225-B22" ref-type="bibr">Marchet <italic toggle="yes">et al.</italic> 2021a</xref>) cover this question, both considering each dataset and the query itself as <italic toggle="yes">k</italic>-mer sets. The first type of approach relies on exact <italic toggle="yes">k</italic>-mer set representations. These methods build an associative index [using hash tables (<xref rid="btad225-B2" ref-type="bibr">Almodaresi <italic toggle="yes">et al.</italic> 2018</xref>, <xref rid="btad225-B16" ref-type="bibr">Holley and Melsted 2020</xref>, <xref rid="btad225-B23" ref-type="bibr">Marchet <italic toggle="yes">et al.</italic> 2021b</xref>, <xref rid="btad225-B27" ref-type="bibr">Pibiri 2022</xref>) or FM-indexes (<xref rid="btad225-B10" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic> 2015</xref>, <xref rid="btad225-B26" ref-type="bibr">Muggli <italic toggle="yes">et al.</italic> 2017</xref>, <xref rid="btad225-B4" ref-type="bibr">Belazzougui <italic toggle="yes">et al.</italic> 2018</xref>)] where the key set corresponds to all <italic toggle="yes">k</italic>-mers of the collection. Such static structure hardly scale to extensive instances with large <italic toggle="yes">k</italic>-mer cardinality but can be used for queries with high precision or to build de Bruijn graphs. Some indexing implement some kind of dynamicity either via merging or using dynamic bit vectors (<xref rid="btad225-B17" ref-type="bibr">Holley <italic toggle="yes">et al.</italic> 2016</xref>, <xref rid="btad225-B25" ref-type="bibr">Muggli <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad225-B1" ref-type="bibr">Alipanahi <italic toggle="yes">et al.</italic> 2021</xref>).</p>
    <p>The second family of methods relies on probabilistic set representations (<xref rid="btad225-B30" ref-type="bibr">Solomon and Kingsford 2016</xref>, <xref rid="btad225-B5" ref-type="bibr">Bingmann <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad225-B8" ref-type="bibr">Bradley <italic toggle="yes">et al.</italic> 2019</xref>, <xref rid="btad225-B15" ref-type="bibr">Harris and Medvedev 2020</xref>). These approximate membership query (AMQ) structures trade false positives during the query for improved speed and memory performance compared to the previous category.</p>
    <p>AMQ approaches allowed the indexing of hundreds of thousands of microbial datasets (<xref rid="btad225-B6" ref-type="bibr">Blackwell <italic toggle="yes">et al.</italic> 2021</xref>). For mammalian datasets, scaling to more samples is a timely challenge since the increase in the content of <italic toggle="yes">k</italic>-mer/datasets poses serious issues for the construction/footprint of current methods. Thus, to our knowledge, no published method has yet overcome the barrier set by SeqOthello (<xref rid="btad225-B32" ref-type="bibr">Yu <italic toggle="yes">et al.</italic> 2018</xref>) of indexing over 10 000 mammalian RNA samples.</p>
    <p>This manuscript proposes a novel AMQ method to query biological sequences in collections of datasets dubbed Partitioned Aggregative Bloom Comb Trees (PAC). In our application case, queries are typically alternative splicing events or a short genomic context around a small variant or mutation, for both eukaryotic and microbial species. Our structure is designed to be highly scalable with the number of indexed samples and requires moderate resources.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <p>In this section, we present our PAC. We kept PAC as an acronym that covers the three keywords, including the main novelties compared to previous tree structures. PAC is available at <ext-link xlink:href="https://github.com/Malfoy/PAC" ext-link-type="uri">https://github.com/Malfoy/PAC</ext-link>.</p>
    <sec>
      <title>2.1 Prerequisites</title>
      <p>A <italic toggle="yes">set of sequences R</italic> (also called “dataset”) is a set of finite strings on the alphabet <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo>Σ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. In practice, sets of sequences can be read sets or genome sets. An input “database” <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> is a set of “datasets.” Similarly to the datasets, a “query sequence” is a finite string from which all distinct <italic toggle="yes">k</italic>-mers are extracted (typically, a gene, a transcript, or some genomic context around a base mutation).</p>
      <p>In the following, we suppose that broadly used concepts in the context of computational genomics are known [namely, <italic toggle="yes">k</italic>-mers, Bloom filters (<xref rid="btad225-B7" ref-type="bibr">Bloom 1970</xref>), and minimizers (<xref rid="btad225-B28" ref-type="bibr">Roberts <italic toggle="yes">et al.</italic> 2004</xref>, <xref rid="btad225-B10" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic> 2015</xref>)]. However, their definitions are recalled in the online supplementary appendix if needed.</p>
      <p><italic toggle="yes">Problem statement</italic>: The structures described hereafter estimate the cardinality of the intersection of dataset’s <italic toggle="yes">k</italic>-mers with the query’s <italic toggle="yes">k</italic>-mers. Then, according to a threshold parameter <italic toggle="yes">τ</italic>, the query is said to be <italic toggle="yes">in</italic> a dataset if its intersection is larger or equal to <italic toggle="yes">τ</italic>.</p>
      <p><italic toggle="yes">A sequence Bloom tree (SBT)</italic> is an AMQ structure introduced in <xref rid="btad225-B30" ref-type="bibr">Solomon and Kingsford (2016)</xref>. SBTs use a set of <italic toggle="yes">n</italic> Bloom filters, each representing the distinct <italic toggle="yes">k</italic>-mers of the <italic toggle="yes">n</italic> datasets in an input database. A SBT is a balanced binary tree that represents separately each Bloom filter in its leaves and the union of all Bloom filters in its root. Therefore, it allows fast membership queries in the whole database using recursive queries along the tree. We call a “sequence Bloom matrix” the matrix of Bloom filters introduced in BIGSI (<xref rid="btad225-B8" ref-type="bibr">Bradley <italic toggle="yes">et al.</italic> 2019</xref>). For SBTs, a Bloom filter is built for each of the <italic toggle="yes">n</italic> datasets in an input database. Then, these filters are stacked to become a matrix in which each Bloom filter is a column. By accessing a row, one can directly know whether an element is present or absent in all Bloom filters. A <italic toggle="yes">SeqOthello</italic> is an AMQ structure that relies on a different paradigm. It operates as a hash table where pairs of (<inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mi>k</mml:mi></mml:math></inline-formula>-mer, presence/absence bitvector) are associated using a static hashing strategy and can efficiently be interrogated for <italic toggle="yes">k</italic>-mer’s presence in bit vectors. In the following section, we will define the necessary concepts to detail our novel structure.</p>
    </sec>
    <sec>
      <title>2.2 PAC construction</title>
      <sec>
        <title>2.2.1 Aggregated Bloom filters</title>
        <p>PAC, as most AMQ structures, relies on Bloom filters to represent <italic toggle="yes">k</italic>-mers presence. For fixed parameters (<italic toggle="yes">k</italic>, <italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>) (respectively, <italic toggle="yes">k</italic>-mer size, Bloom filter size, and number of hash functions), for each <italic toggle="yes">R<sub>i</sub></italic> <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>&lt;</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">D</italic>, we build a Bloom filter BF<sub><italic toggle="yes">i</italic></sub> and populate BF<sub><italic toggle="yes">i</italic></sub> with <italic toggle="yes">R<sub>i’</sub></italic>s <italic toggle="yes">k</italic>-mers. Thus, each Bloom filter represents the <italic toggle="yes">k</italic>-mers of a dataset from <italic toggle="yes">D</italic>. As SBT, we organize our Bloom filters in a tree whose inner nodes result from a merge operation on Bloom filters:<statement id="mthst1"><label>Definition 1</label><p>(<bold>Bloom filter merge</bold>) Let two Bloom filters BF<sub>1</sub> and BF<sub>2</sub> with the same set of parameters (<italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>). We define the <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula> operation as a bitwise OR:
</p></statement><statement id="mthst2"><label>Definition 2</label><p>(<bold>union Bloom filter</bold>) A union Bloom filter is the Bloom filter result of a <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula> operation, with conserved parameters (<italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>).</p></statement></p>
        <disp-formula id="E1">
          <mml:math id="M1" display="block" overflow="scroll">
            <mml:mrow>
              <mml:mi>b</mml:mi>
              <mml:mi>f</mml:mi>
              <mml:mo>_</mml:mo>
              <mml:mi mathvariant="italic">merge</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:msub>
              <mml:mo>,</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>2</mml:mn>
              </mml:msub>
              <mml:mo stretchy="false">)</mml:mo>
              <mml:mo>=</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>1</mml:mn>
              </mml:msub>
              <mml:mo>|</mml:mo>
              <mml:mi>B</mml:mi>
              <mml:msub>
                <mml:mrow>
                  <mml:mi>F</mml:mi>
                </mml:mrow>
                <mml:mn>2</mml:mn>
              </mml:msub>
              <mml:mo>.</mml:mo>
            </mml:mrow>
          </mml:math>
        </disp-formula>
        <p>The tree is then built by “merging” filters from bottom to top. The tree root represents the union Bloom filters of all distinct <italic toggle="yes">k</italic>-mers in <italic toggle="yes">D</italic>. PAC involves a novel tree topology in comparison to other SBTs that are balanced binary trees, which will be detailed in the following.<statement id="mthst3"><label>Definition 3</label><p>(<bold>Aggregated Bloom filter</bold>) We define a series of Bloom filters <italic toggle="yes">BF</italic><sub>1</sub>, <italic toggle="yes">BF</italic><sub>2</sub>, …<italic toggle="yes">BF</italic><sub><italic toggle="yes">t</italic></sub> built using common (<italic toggle="yes">b</italic>, <italic toggle="yes">h</italic>) parameters. They represent <italic toggle="yes">k</italic>-mer sets <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>t</mml:mi></mml:msub><mml:mo>⊆</mml:mo><mml:mo>…</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>⊆</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula>. We encode this particular series of <italic toggle="yes">t</italic> filters of size <italic toggle="yes">b</italic> as a matrix <italic toggle="yes">M</italic> of size <italic toggle="yes">t </italic>×<italic toggle="yes"> b</italic>. Let <italic toggle="yes">V</italic> be an integer array of size <italic toggle="yes">b</italic>. For <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>≤</mml:mo><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the length of the run of 1 in the row <italic toggle="yes">i</italic> of <italic toggle="yes">M</italic>. <italic toggle="yes">V</italic> can effectively encode such a series of <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mi>S</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> Bloom filters of size <italic toggle="yes">b</italic> using <italic toggle="yes">b</italic> integers of size <italic toggle="yes">S</italic>. In this way, we can encode <italic toggle="yes">t</italic> of such Bloom filters of size <italic toggle="yes">b</italic> using <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mo>×</mml:mo><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> bits. We call such an integer array <italic toggle="yes">V</italic> encoding for the series of Bloom filters <italic toggle="yes">BF</italic><sub>1</sub>, <italic toggle="yes">BF</italic><sub>2</sub>, …<italic toggle="yes">BF<sub>t</sub></italic> an “Aggregated Bloom filter.”</p></statement><statement id="mthst4"><label>Observation 1</label><p>One can notice that any branch of a SBT could be represented by an Aggregated Bloom filters, with <italic toggle="yes">BF<sub>t</sub></italic> being the leaf node in the branch, and <italic toggle="yes">BF</italic><sub>1</sub> the root node.</p></statement></p>
      </sec>
      <sec>
        <title>2.2.2 Aggregated Bloom comb trees</title>
        <statement id="mthst5">
          <label>Definition 4</label>
          <p>(<bold>Comb tree</bold>) We call a comb tree a binary tree whose each internal node has at least one leaf as a child. When considering an order on the leaves, a “left-comb tree” (respectively, “a right-comb tree”) has its root connected to the rightmost leaf (respectively, the leftmost leaf).</p>
        </statement>
        <p>PAC relies on Bloom comb trees to organize the set of Bloom filters representing each dataset.<statement id="mthst6"><label>Definition 5</label><p>(<bold>Bloom comb tree</bold>) We call a Bloom comb tree a comb tree built using the <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula> operation. First, given a list of Bloom filters <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> representing datasets, the leaves of the comb tree are built. Each leaf contains a Bloom filter as in SBTs. A Bloom left-comb tree is such that the leftmost inner node <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. The right-comb tree can be defined by symmetry.</p></statement><statement id="mthst7"><p><bold>Property 1</bold> In a Bloom left-comb tree built from a list of Bloom filters <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we have <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>⊆</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>⊆</mml:mo><mml:mo>…</mml:mo><mml:mi>B</mml:mi><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="italic">height</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (with “height” being the height of the comb) due to the union operation performed in <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mi>b</mml:mi><mml:mi>f</mml:mi><mml:mo>_</mml:mo><mml:mi mathvariant="italic">merge</mml:mi></mml:mrow></mml:math></inline-formula>.</p></statement></p>
        <p>See <xref rid="btad225-F1" ref-type="fig">Fig. 1</xref> for an example of the difference between a tree used by SBTs and a Bloom comb tree.</p>
        <fig position="float" id="btad225-F1">
          <label>Figure 1.</label>
          <caption>
            <p>Left: A SBT structure. Right: A Bloom left-comb tree for the same database. Four datasets of a database are represented using grey shapes. Toy example Bloom filters are represented as bit vectors associated with shapes, and the content of each node is recalled. In the case of the Bloom comb tree, the inner nodes’ Bloom filters (highlighted zone in grey) are not explicitly represented but are encoded using an Aggregated Bloom filter instead (integer vector). Runs of 1’s corresponding to the integers are colored. For instance, the leftmost 1 is found at Levels 1 and 2, therefore a run of length two in the vector.</p>
          </caption>
          <graphic xlink:href="btad225f1" position="float"/>
        </fig>
        <statement id="mthst8">
          <label>Observation 2</label>
          <p>Similarly to the previous observation, one can notice that the longest branch of the comb is a series of Aggregated Bloom filters.</p>
        </statement>
        <p>Following Observation 2, we propose using an Aggregated Bloom filter to encode the longest branch of the Bloom comb tree.<statement id="mthst9"><label>Definition 6</label><p>(<bold>Aggregated Bloom Comb Tree</bold>) Unless otherwise specified, we denote by “Aggregated Bloom Comb Tree” a structure composed of a pair of Bloom left and right-comb trees built on the same list of leaves. They are represented using two components. First, two Aggregated Bloom filters <italic toggle="yes">V <sub>l</sub></italic>, <italic toggle="yes">V <sub>r</sub></italic> (see Definition 3) of size <italic toggle="yes">b</italic>, representing the branch going through all internal nodes down to the deepest leaf in both left and right-comb tree. Second, <italic toggle="yes">n</italic> Bloom filters are the leaves of both combs.</p></statement></p>
        <p><xref rid="btad225-F2" ref-type="fig">Figure 2A</xref> shows an example of two Bloom comb trees and the Aggregated Bloom filters that represent them. An Aggregated Bloom filter represents a run of 1’s in an inclusion series of Bloom filters. Thus, <italic toggle="yes">V<sub>l</sub></italic> (and symmetrically, <italic toggle="yes">V<sub>r</sub></italic>) defines the maximal depth at which 1’s can be encountered at a given position in Bloom filters of the combs, i.e. the search space for a hit. Therefore, intersecting the two <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>′</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> intervals refines the bounds for the search space at each position (see <xref rid="btad225-F2" ref-type="fig">Fig. 2B</xref> for an example).</p>
        <fig position="float" id="btad225-F2">
          <label>Figure 2.</label>
          <caption>
            <p>(A) Two Bloom comb trees and their Aggregated Bloom filters. The leaves Bloom filters are in the middle, colored in grey. They are the Bloom filters representing the input datasets. The left-comb tree (top) and right-comb tree (bottom) are built by aggregating the Bloom filter’s <italic toggle="yes">k</italic>-mers. The Aggregated Bloom filter <italic toggle="yes">V<sub>l</sub></italic> represents the leftmost path of the top comb. Respectively, <italic toggle="yes">V<sub>r</sub></italic> represents the rightmost path of the bottom comb. We colored in green the second bit of leaves in order to show its encoding in the Aggregated Bloom filters. In the left comb, this bit is set to 1 only in the root for the longest branch; therefore, the value is 1 (green) in <italic toggle="yes">V<sub>l</sub></italic>. Conversely, the longest branch of the right tree has a run of five 1’s on the second position, hence, a 5 in <italic toggle="yes">V<sub>r</sub></italic>. (B) Using <italic toggle="yes">V<sub>l</sub></italic> and <italic toggle="yes">V<sub>r</sub></italic> from (A), we show how Aggregated Bloom filters define restrained search spaces in the leaves. Again, the leaves’ Bloom filters are grey, and the values of the vectors are printed vertically. Arrows represent the intervals given by each <italic toggle="yes">V</italic>, and the final search space at each position is the dotted grey area.</p>
          </caption>
          <graphic xlink:href="btad225f2" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>2.2.3 Structure partitioning</title>
        <p>In PAC, we build a distinct “Aggregated Bloom comb tree” for each minimizer associated with a non-empty <italic toggle="yes">k</italic>-mer set.<statement id="mthst10"><label>Definition 7</label><p><bold>[super-<italic toggle="yes">k</italic>-mer</bold> (<xref rid="btad225-B12" ref-type="bibr">Deorowicz <italic toggle="yes">et al.</italic> 2013</xref><bold>)]</bold> From an input string, a super-<italic toggle="yes">k</italic>-mer is a substring containing all consecutive <italic toggle="yes">k</italic>-mers that share a minimizer of size <italic toggle="yes">m</italic>.</p></statement></p>
        <p>As consecutive <italic toggle="yes">k</italic>-mers in a sequence largely overlap, blocks of <italic toggle="yes">k</italic>-mers tend to share their minimizer and yield super-<italic toggle="yes">k</italic>-mers. By associating super-<italic toggle="yes">k</italic>-mers to their minimizers (and therefore the <italic toggle="yes">k</italic>-mers they come from) one can divide a <italic toggle="yes">k</italic>-mer set into up to <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> partitions (<xref rid="btad225-B12" ref-type="bibr">Deorowicz <italic toggle="yes">et al.</italic> 2013</xref>). See the <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref> in the Appendix for an example.</p>
        <p><xref rid="btad225-F3" ref-type="fig">Figure 3A</xref> shows which information is stored in a partition to represent a PAC. The combined <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> “Aggregated Bloom comb trees” stored in <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mn>4</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> partitions represent the complete PAC structure.</p>
        <fig position="float" id="btad225-F3">
          <label>Figure 3.</label>
          <caption>
            <p>(A) The content of one partition in PAC. The Aggregated Bloom comb trees constructed for a given partition are represented using Bloom filter leaves (in gray) and two Aggregated Bloom filters <italic toggle="yes">V<sub>l</sub></italic> and <italic toggle="yes">V<sub>r</sub></italic>. (B) A single query in the same partition as (A). The index has been inverted. A <italic toggle="yes">k</italic>-mer enters a PAC by finding the partition corresponding to its minimizer. <italic toggle="yes">V<sub>l</sub></italic> and <italic toggle="yes">V<sub>r</sub></italic> are loaded, and a search space (here <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> only) is defined given the position obtained by hashing the <italic toggle="yes">k</italic>-mer (here the <italic toggle="yes">k</italic>-mer’s hash value is 2). Then, a slice is extracted from the inverted index at the given position, and bits are checked to find 1’s. Here, there is a single position, so necessarily an 1.</p>
          </caption>
          <graphic xlink:href="btad225f3" position="float"/>
        </fig>
      </sec>
      <sec>
        <title>2.2.4 Query</title>
        <statement id="mthst11">
          <label>Definition 8</label>
          <p>(<bold>Single query</bold>) We call a single query the query of a single <italic toggle="yes">k</italic>-mer to an AMQ data structure. The single query outputs a bit vector of size <italic toggle="yes">n</italic> indicating the presence/absence of a <italic toggle="yes">k</italic>-mer in each dataset.</p>
        </statement>
        <statement id="mthst12">
          <label>Definition 9</label>
          <p>(<bold>Multiple query</bold>) Let <italic toggle="yes">s</italic> be a string of size <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. We call a multiple query the query of consecutive <italic toggle="yes">k</italic>-mers in <italic toggle="yes">s</italic> through single queries to an AMQ data structure. The results scores are reported in an integer vector of size <italic toggle="yes">n</italic>.</p>
        </statement>
        <p>For all AMQ structures studied in this article, the worst-case time complexity for single queries is in <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Thus, the number of random access impacts is critical for runtimes in practice.<statement id="mthst13"><label>Definition 10</label><p>(<bold>Inverted Bloom filter index</bold>) In this framework, we call an inverted Bloom filter index an index that maps each possible hash value <italic toggle="yes">h</italic> to a bit vector of size <italic toggle="yes">n</italic> that represents which filters have one at position <italic toggle="yes">h</italic>.</p></statement></p>
        <p>To minimize the amount of random access, we rely on Inverted Bloom indexes during query time.</p>
        <p>For each <italic toggle="yes">k</italic>-mer, its hash value <italic toggle="yes">h</italic> is computed, and the bit slice <italic toggle="yes">h</italic> is searched to find which Bloom filters include it. To further increase data locality, we construct one Inverted Bloom filter index per partition. In this way, querying successive <italic toggle="yes">k</italic>-mers from a super-<italic toggle="yes">k</italic>-mer is done on the same small data structure, reducing the amount of cache misses. Such partition indexes are only constructed if needed and kept to avoid redundant operations following a lazy strategy. An example is presented in <xref rid="btad225-F3" ref-type="fig">Fig. 3B</xref> (super-<italic toggle="yes">k</italic>-mers are omitted). Finally, we maintain and return a score vector of size <italic toggle="yes">n</italic>. It is incremented by one at a position <italic toggle="yes">j</italic> each time a <italic toggle="yes">k</italic>-mer appears in leaf <italic toggle="yes">j</italic>. Therefore, PAC is also related to Sequence Bloom matrices because queries are handled using a matrix of Bloom filters.</p>
      </sec>
      <sec>
        <title>2.2.5 Update PAC by inserting new datasets</title>
        <p>Adding new datasets does not require changing the index structure. New datasets can be added by constructing their Bloom filters and updating the values of the Aggregated Bloom filters when needed. We implemented this functionality to allow the user to insert a dataset collection into an existing index. This insertion presents a very similar cost to building an index from the said collection, as both the construction and update algorithms consist of successive insertions. It avoids the need to rebuild the index from scratch due to novel datasets.</p>
      </sec>
      <sec>
        <title>2.2.6 Implementation details</title>
        <sec>
          <title>2.2.6.1 Memory usage and parallelization</title>
          <p>Bloom filters are constructed in RAM and serialized on disk to avoid heavy memory usage. In this way, only one Bloom filter is stored in RAM at a given time (<italic toggle="yes">C</italic> if <italic toggle="yes">C</italic> threads are used to treat the datasets in parallel). A PAC index is distributed into <italic toggle="yes">P</italic> sections serialized in <italic toggle="yes">P</italic> different files. Such sections can be handled separately, being mutually exclusive. This strategy provides inherent coarse-grained parallelism, as different threads can operate on different sections without mutual exclusion mechanisms during construction. It also grants low memory usage as only small sections (i.e. a fraction of the total index) have to be stored in memory at a given time.</p>
          <p>Similarly, the query also benefits from partitioning. All <italic toggle="yes">k</italic>-mer associated with a given partition are queried at once in a sequential way to limit memory usage. Each Bloom filter is loaded separately in RAM and freed after the inverted index is constructed to be queried (<italic toggle="yes">C</italic> Bloom filters can be loaded simultaneously in RAM if <italic toggle="yes">C</italic> threads are used). This behavior guarantees that each partition will only be read from the disk once and that only one partition will be stored in RAM at a given time. Furthermore, partitions not associated with any query <italic toggle="yes">k</italic>-mer can be skipped. Both construction and query benefit from improved cache coherence as several successive <italic toggle="yes">k</italic>-mers are located in the same small structure, generating cache misses for groups of <italic toggle="yes">k</italic>-mers instead of doing so for nearly each <italic toggle="yes">k</italic>-mer.</p>
        </sec>
        <sec>
          <title>2.2.6.2 Inverted index</title>
          <p>Bloom filters are represented as sparse bit vectors (using the BitMagic library (<ext-link xlink:href="https://github.com/Malfoy/PAC/blob/main/listpacpaper.txt.gz" ext-link-type="uri">https://github.com/Malfoy/PAC/blob/main/listpacpaper.txt.gz</ext-link> )] in order to optimize memory usage.</p>
        </sec>
      </sec>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <p>All experiments were performed on a single cluster node running with Intel(R) Xeon(R) Gold 6130 CPU @ 2.10 GHz with 128 GB of RAM and Ubuntu 22.04.</p>
    <sec>
      <title>3.1 Indexing 2500 human datasets and comparison to other AMQ structures</title>
      <p>We compared PAC against the latest methods of the AMQ paradigm, i.e. HowDeSBT (<xref rid="btad225-B15" ref-type="bibr">Harris and Medvedev 2020</xref>) for SBTs and SeqOthello (<xref rid="btad225-B32" ref-type="bibr">Yu <italic toggle="yes">et al.</italic> 2018</xref>). We also tested COBS (<xref rid="btad225-B5" ref-type="bibr">Bingmann <italic toggle="yes">et al.</italic> 2019</xref>), the most recent sequence Bloom matrix, although it is not designed to work with sequencing data, but rather genomes. We used kmtricks (<xref rid="btad225-B19" ref-type="bibr">Lemane <italic toggle="yes">et al.</italic> 2022</xref>) for an optimized construction of HowDeSBT and its Bloom filters (commit number <monospace>532d545</monospace>). SeqOthello (commit 68d47e0) uses Jellyfish (<xref rid="btad225-B21" ref-type="bibr">Marçais and Kingsford 2011</xref>) for its preprocessing, we worked with version 2.3.0. COBS’s version was v0.1.2, and PAC’s commit was <monospace>cee1b5c</monospace>. We used the classic mode of COBS that does not rely on folding to ensure a fair comparison of Bloom filter size and practical false-positive rate across tools.</p>
      <p>The dataset first used in the initial SBT contribution (<xref rid="btad225-B30" ref-type="bibr">Solomon and Kingsford 2016</xref>) has become a <italic toggle="yes">de facto</italic> benchmark in almost any subsequent article that describes a related method. We make no exception, and benchmarked PAC and other AMQ structures on this dataset. It contains 2585 human RNA-seq datasets, with low-frequency <italic toggle="yes">k</italic>-mers filtered according to previous works (<xref rid="btad225-B31" ref-type="bibr">Solomon and Kingsford 2018</xref>) (<ext-link xlink:href="https://www.cs.cmu.edu/ckingsf/software/bloomtree/srr-list.txt" ext-link-type="uri">https://www.cs.cmu.edu/ ckingsf/software/bloomtree/srr-list.txt</ext-link>), resulting in a total of <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo>∼</mml:mo><mml:mn>3.8</mml:mn></mml:mrow></mml:math></inline-formula> billion of distinct <italic toggle="yes">k</italic>-mers. The input files are represented as compacted de Bruijn graphs generated by Bcalm2 (<xref rid="btad225-B11" ref-type="bibr">Chikhi <italic toggle="yes">et al.</italic> 2016</xref>) in gzipped FASTA files. We also kept the settings used in previous benchmarks and used a <italic toggle="yes">k</italic> value of 21. We chose COBS, PAC, and HowDeSBT’s settings to have an average 0.5% false-positive rate. Notably, SeqOthello’s false-positive rate cannot be controlled.</p>
      <p>In <xref rid="btad225-T1" ref-type="table">Table 1</xref>, we present the costs of indexing this database with the different tools. Several observations can be made. First, PAC does not generate any temporary disk footprint; only the final index is written on disk, while HowDeSBT, SeqOthello, and COBS generate many temporary files that are an order of magnitude larger than the index itself. Another observation is that PAC and COBS’s preprocessing and index construction steps are comparable and faster than the other tools, showing at least a 2-fold improvement of required CPU time. The total computational cost of a PAC index is improved three times over SeqOthello and six times over HowDeSBT. Memory-wise, the memory footprint of HowDeSBT and PAC are both low, while SeqOthello and COBS are somewhat higher without being prohibitively high. Finally, excluding COBS, the different produced indexes are of the same order of magnitude, even if PAC presents the heaviest index, slightly larger than SeqOthello, while HowDeSBT is the smallest. This can be explained by the fact that tree-based tools (as HowDeSBT) spend a lot of time to choose how to group and merge files to optimize the index compressibility resulting in a hard to construct but smaller indexes tradeoff. Computing an efficient file ordering to boost compression is an interesting problem that would benefit any matrix-based index. Being compression-free, COBS’ index is two orders of magnitude larger than the other tools and produces even larger temporary files. COBS’ CPU time is similar to PAC’s, but its heavy disk usage presents a higher wall-clock time on our hard-disk drives.</p>
      <table-wrap position="float" id="btad225-T1">
        <label>Table 1.</label>
        <caption>
          <p>Index construction resource requirements on 2585 RNA-seq<xref rid="tblfn1" ref-type="table-fn"><sup>a</sup></xref>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Tool</th>
              <th align="center" rowspan="1" colspan="1">Max temporary</th>
              <th align="center" rowspan="1" colspan="1">Preprocessing</th>
              <th align="center" rowspan="1" colspan="1">Index construction</th>
              <th align="center" rowspan="1" colspan="1">Peak RAM</th>
              <th align="center" rowspan="1" colspan="1">Final index size</th>
            </tr>
            <tr>
              <th align="center" rowspan="1" colspan="1"/>
              <th align="center" rowspan="1" colspan="1">disk (GB)</th>
              <th align="center" rowspan="1" colspan="1">time (CPU, h)</th>
              <th align="center" rowspan="1" colspan="1">time (CPU, h)</th>
              <th align="center" rowspan="1" colspan="1">(GB)</th>
              <th align="center" rowspan="1" colspan="1">(GB)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">COBS</td>
              <td rowspan="1" colspan="1">4914</td>
              <td rowspan="1" colspan="1">
                <bold>7</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>1</bold>
              </td>
              <td rowspan="1" colspan="1">111</td>
              <td rowspan="1" colspan="1">2458</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">HowDeSBT</td>
              <td rowspan="1" colspan="1">650</td>
              <td rowspan="1" colspan="1">16</td>
              <td rowspan="1" colspan="1">44</td>
              <td rowspan="1" colspan="1">
                <bold>4.2</bold>
              </td>
              <td rowspan="1" colspan="1">
                <bold>15</bold>
              </td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">SeqOthello</td>
              <td rowspan="1" colspan="1">1000</td>
              <td rowspan="1" colspan="1">19</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">43</td>
              <td rowspan="1" colspan="1">25</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">PAC</td>
              <td rowspan="1" colspan="1">
                <bold>0</bold>
              </td>
              <td rowspan="1" colspan="1">8</td>
              <td rowspan="1" colspan="1">
                <bold>1</bold>
              </td>
              <td rowspan="1" colspan="1">9.6</td>
              <td rowspan="1" colspan="1">28</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn1">
            <label>a</label>
            <p>The column “Max temporary disk” reports the maximal external space taken by the method (usually during preprocessing). The “Final Index Size” indicates the final index size when stored on disk. Bold values indicate the best result in each column. The execution times of the methods are reported in CPU hours. All methods were run with 12 threads.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>3.2 Indexing over 32 000 human datasets and scalability regarding the number of datasets</title>
      <p>We downloaded 32 768 RNA-seq samples from SRA [accession list in available on the github repository (<ext-link xlink:href="https://github.com/tlk00/BitMagic" ext-link-type="uri">https://github.com/tlk00/BitMagic</ext-link>)] for a total of 30 TB of uncompressed FASTQ data. We created incremental batches of 2<sup>8</sup>, 2<sup>9</sup>, …, up to 2<sup>15</sup> datasets to document the scalability of methods according to the number of datasets. In this second experiment, the indexes are built directly on sequencing datasets in raw FASTA format, containing redundant <italic toggle="yes">k</italic>-mers and sequencing errors. Each tool was configured to filter unique <italic toggle="yes">k</italic>-mers before indexing to remove most sequencing errors (we used <italic toggle="yes">k </italic>=<italic toggle="yes"> </italic>31). Since COBS does not provide such an option and produces huge index files, we did not include it in this benchmark. To approximate the order of magnitude of the amount of (non-unique) distinct <italic toggle="yes">k</italic>-mers, we used ntcard (<xref rid="btad225-B24" ref-type="bibr">Mohamadi <italic toggle="yes">et al.</italic> 2017</xref>). For example, the batch of 2<sup>11</sup> datasets contains ∼3 billion <italic toggle="yes">k</italic>-mers to index, while the 2<sup>14</sup> dataset contains more than 40 billion <italic toggle="yes">k</italic>-mers.</p>
      <p>In <xref rid="btad225-F4" ref-type="fig">Fig. 4</xref>, we report the CPU time required for index construction (including preprocessing) to display their evolution on databases of increasing size. In <xref rid="btad225-F5" ref-type="fig">Fig. 5</xref>, we report temporary disk usage during index construction and the final index sizes on the disk after compression.</p>
      <fig position="float" id="btad225-F4">
        <label>Figure 4.</label>
        <caption>
          <p>Results on increasing human dataset sizes. We report total CPU hours for constructing the different indexes, including the Bloom filter construction and index constructions. <italic toggle="yes">X</italic>-axis is in <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> scale and <italic toggle="yes">Y</italic>-axis is in <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> scale. All methods were run with 12 threads.</p>
        </caption>
        <graphic xlink:href="btad225f4" position="float"/>
      </fig>
      <fig position="float" id="btad225-F5">
        <label>Figure 5.</label>
        <caption>
          <p>Results on increasing human dataset sizes. We report disk footprints, both temporary and final, for constructing the different indexes. Note that PAC does not use temporary disk. <italic toggle="yes">X</italic>-axis is in <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> scale and <italic toggle="yes">Y</italic>-axis is in <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> scale. All methods were run with 12 threads.</p>
        </caption>
        <graphic xlink:href="btad225f5" position="float"/>
      </fig>
      <p>We can make observations similar to those in the first experiments. PAC is the only tool that managed to build an index of the 32 000 human RNA-seq samples, in ∼5 days (∼60 CPU days), using 22 GB of RAM and for a total index size of 1.1 TB. PAC’s construction is faster than the state-of-the-art for the whole construction process. It produces slightly bigger indexes, but requires much less external memory. SeqOthello crashed during index construction in the experiment with 2<sup>12</sup> datasets, and HowDeSBT failed to end before our ten-day timeout in the experiment with 2<sup>11</sup> datasets. PAC was the only tool to build an index on the 2<sup>13</sup>, 2<sup>14</sup>, and 2<sup>15</sup> datasets.</p>
    </sec>
    <sec>
      <title>3.3 Indexing microbial datasets</title>
      <p>Besides indexing RNA-seq data, AMQ indexes were also used to index large collections of bacterial genomes. To further highlight the scalability of PAC, we built it on two massive bacterial collections. In a first experiment, we fetched the 661 000 bacterial genomes representing more than three terabases, which were previously collected in a database (<xref rid="btad225-B6" ref-type="bibr">Blackwell <italic toggle="yes">et al.</italic> 2021</xref>) and built two indexes on this collection. A first index featuring large Bloom filters (2<sup>29</sup> bits) for low <italic toggle="yes">k</italic>-mer query false-positive rates (below 1% for five megabases genomes) and a second index with smaller Bloom filters (2<sup>27</sup> bits) when higher false-positive rates can be allowed (below 7% for five megabases genomes). Both indexes were constructed within 24 h using 21 and 6 GB of RAM, respectively, for a total size of 2.4 and 1.4 TB, respectively.</p>
      <p>In a second experiment, we downloaded all bacterial assemblies available on GenBank (counting 1 200 575 genomes at the time of the experiment and representing more than five terabases) and built an index with a Bloom filter size of 2<sup>27</sup> bits that corresponds to a false-positive rate around 4% for five megabases genomes. The construction lasted 24 h for a total of 410 CPU hours using less than 5 GB of RAM for a total index size of 3.5 TB. This is to our knowledge the largest collection ever indexed by an AMQ.</p>
    </sec>
    <sec>
      <title>3.4 Query results on human RefSeq</title>
      <p>We designed a similar experiment to the one presented in HowDeSBT’s paper, with sequence batches of increasing sizes. We repetitively selected random transcripts from human RefSeq [using seqkit (<xref rid="btad225-B29" ref-type="bibr">Shen <italic toggle="yes">et al.</italic> 2016</xref>)], and gathered 10, 10, 5, 3, and 3 batches of sizes 1, 10, 100, 1000, and 10 000 transcripts. We report HowDeSBT, SeqOthello, and PAC’s CPU time on each batch size in <xref rid="btad225-F6" ref-type="fig">Fig. 6</xref>. We warmed the cache before profiling the queries. In accordance with the literature (<xref rid="btad225-B15" ref-type="bibr">Harris and Medvedev 2020</xref>), we observe that SBT structures perform the best on small query sets. In larger instances, other methods can be preferred. SeqOthello shows the best performance and keeps a relatively constant query time over the input size. PAC has the same behavior, while being slightly more CPU time than SeqOthello. We also note that no method required more than 10 GB of RAM to perform the queries. PAC had the lowest RAM footprint, with up to 2 GB for 10 000 transcripts. COBS CPU time usages are not representative of its actual queries’ performance, as it incurs almost no CPU times (typically &lt;1 CPU second per transcript), so we chose not to plot it along with its competitors.</p>
      <fig position="float" id="btad225-F6">
        <label>Figure 6.</label>
        <caption>
          <p>Results on query batches. We present query CPU times computed on batches of 1 to 10k transcript sequences. The <italic toggle="yes">Y</italic>-axis is on a <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mtext>log</mml:mtext><mml:mo> </mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> scale. The queries were computed using 12 threads.</p>
        </caption>
        <graphic xlink:href="btad225f6" position="float"/>
      </fig>
      <p>We performed a separate benchmark to assess the queries wall-clock times. On a batch of 100 transcripts, HowDeSBT lasted 1 h 30 min, COBS lasted 30 min, SeqOthello lasted 10 min, and PAC lasted 5 min. Interestingly, on a larger batch of 10 000 transcripts, SeqOthello and PAC presented very similar results (10 and 5 min, respectively). These results indicate that the query time of these two tools is dominated by index loading. To assess when query time became predominant, we queried a large batch of 100 000 transcripts for which PAC lasted 11 min (two CPU hours) and an even larger batch of 500 000 transcripts handled by PAC in 40 min (6.5 CPU hours).</p>
    </sec>
    <sec>
      <title>3.5 Impact of comb structure on query for collections entailing high <italic toggle="yes">k</italic>-mer diversity</title>
      <p>One novelty of PAC is the use of lightweight Aggregated Bloom filters to accelerate the queries by skipping subsections of the bit-slices. To assess the efficiency of this strategy, we report in <xref rid="btad225-T2" ref-type="table">Table 2</xref> the query times of several query batches on an index composed of all complete <italic toggle="yes">Salmonella enterica</italic> genomes from RefSeq (counting 11 993 genomes at the time of the experiment). We report three different query times for each batch, using, respectively, two Aggregated Bloom Comb trees (according to Definition 6), a single one and none (i.e. the structure is a Bloom matrix). Without the use of Aggregated Bloom filters PAC index is conceptually identical to a matrix approach, such as COBS while using one or two Aggregated Bloom filters allow to skip some bitslice of the index. The number of bits that can be skipped depends in practice on the similarity shared between the query and the indexed documents. To highlight this effect, a batch is made up of <italic toggle="yes">S.enterica</italic> that are highly similar to the indexed genomes, a batch is made up of <italic toggle="yes">Escherichia coli</italic> that are very dissimilar to the indexed genomes, and a batch is made up of random sequence to show an extreme example of dissimilarity. The first observation is that Aggregated Bloom filters hardly improve the query time of the <italic toggle="yes">S.enterica</italic> batch. This result is expected because most query <italic toggle="yes">k</italic>-mers should be found in many indexed genomes and the amount of zeros that could be skipped in such slices should be very low. However, we see that using one Aggregated Bloom filter greatly accelerates the query on the two dissimilar batches, increasing the throughput by several fold. Furthermore, using a second Aggregated Bloom filter accelerates the query time even more but is not as beneficial as the first one.</p>
      <table-wrap position="float" id="btad225-T2">
        <label>Table 2.</label>
        <caption>
          <p>Results on query times in CPU hours according to the PAC mode used along with the speedup obtained compared to the classical matrix approach (No ABF column)<xref rid="tblfn2" ref-type="table-fn"><sup>a</sup></xref>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
            <col valign="top" align="char" char="." span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Query dataset</th>
              <th align="center" rowspan="1" colspan="1">Double ABF filter</th>
              <th align="center" rowspan="1" colspan="1">Single ABF filter</th>
              <th align="center" rowspan="1" colspan="1">No ABF</th>
              <th align="center" rowspan="1" colspan="1">Overhead</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">200 Random genomes</td>
              <td rowspan="1" colspan="1">0.7 (13.6×)</td>
              <td rowspan="1" colspan="1">1.3 (7.3×)</td>
              <td rowspan="1" colspan="1">9.5</td>
              <td rowspan="1" colspan="1">1.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">200 <italic toggle="yes">E.coli</italic> genomes</td>
              <td rowspan="1" colspan="1">1.2 (7×)</td>
              <td rowspan="1" colspan="1">2.2 (3.8×)</td>
              <td rowspan="1" colspan="1">8.4</td>
              <td rowspan="1" colspan="1">1.0</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">200 <italic toggle="yes">S.enterica</italic> genomes</td>
              <td rowspan="1" colspan="1">10.4 (1.2×)</td>
              <td rowspan="1" colspan="1">11.6 (1×)</td>
              <td rowspan="1" colspan="1">12</td>
              <td rowspan="1" colspan="1">1.0</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <fn id="tblfn2">
            <label>a</label>
            <p>Double, Single, No ABF denotes the number of combs used in the structure. We present query CPU times computed along with the overhead constant across modes that include parsing the query file and loading the index. The random genomes are random nucleotide sequences of length five megabases. <italic toggle="yes">E.coli</italic> and <italic toggle="yes">S.enterica</italic> genomes were randomly selected among the RefSeq genomes.</p>
          </fn>
        </table-wrap-foot>
      </table-wrap>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>To our knowledge, PAC is the first AMQ <italic toggle="yes">k</italic>-mer set structure to index the entire GenBank bacterial genome collection and reach 32k human RNA-seq datasets.</p>
    <p>PAC combines the simplicity and efficiency of inverted index matrix approaches, such as COBS or BIGSI with a lightweight tree structure.</p>
    <p>The novel tree structure has a minimal resource footprint, yet greatly improves the query time when a query is dissimilar to the index content, a scenario possibly met with microbial databases. As <italic toggle="yes">k</italic>-mer sets are designed to efficiently skip unrelevant documents, our Aggregated Bloom filters allow us to efficiently prune our query space.</p>
    <p>Using several real datasets, we demonstrate that PAC is practically scalable for its construction. In contrast to other approaches, PAC is simultaneously frugal in RAM, disk, and time requirements for building an index.</p>
    <p>We showed PAC’s ability to query 500 000 human transcripts in less than an hour, being the fastest in wall-clock time, and comparable to SeqOthello in CPU time. The worst-case query complexity remains the same for all methods, <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for a <italic toggle="yes">k</italic>-mer present in all <italic toggle="yes">n</italic> datasets.</p>
    <p>We reviewed that inverted indexes methods perform <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mo>Θ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> random accesses, but still need to read bit-slices of size <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. Using Aggregated Bloom filters, PAC improves these indexes, as in favorable cases (<italic toggle="yes">k</italic>-mers present in a single dataset with no collision or absent everywhere), PAC can answer in <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad225_Supplementary_Data</label>
      <media xlink:href="btad225_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>The authors would like to thank Léonid and Zora for a renewed sense of what tiredness, teamwork and joy are. They also thank Daniel Gautheret for providing us with tips on the SRA API, RECOMB-Seq reviewers, and Anatoliy Kuznetsov for his outstanding Bitmagic library and sustained support.</p>
  </ack>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported by grants from the Agence Nationale de la recherche for the project “full-RNA” [ANR-22-CE45-0007]; and “AGATE” [ANR-21-CE45-0012].</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad225-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alipanahi</surname><given-names>B</given-names></string-name>, <string-name><surname>Kuhnle</surname><given-names>A</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name></person-group><etal>et al</etal><article-title>Succinct dynamic de Bruijn graphs</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>1946</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">32462192</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Almodaresi</surname><given-names>F</given-names></string-name>, <string-name><surname>Sarkar</surname><given-names>H</given-names></string-name>, <string-name><surname>Srivastava</surname><given-names>A</given-names></string-name></person-group><etal>et al</etal><article-title>A space and time-efficient index for the compacted colored de Bruijn graph</article-title>. <source>Bioinformatics</source><year>2018</year>;<volume>34</volume>:<fpage>i169</fpage>–<lpage>77</lpage>.<pub-id pub-id-type="pmid">29949982</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Altschul</surname><given-names>SF</given-names></string-name>, <string-name><surname>Gish</surname><given-names>W</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W</given-names></string-name></person-group><etal>et al</etal><article-title>Basic local alignment search tool</article-title>. <source>J Mol Biol</source><year>1990</year>;<volume>215</volume>:<fpage>403</fpage>–<lpage>10</lpage>.<pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Belazzougui</surname><given-names>D</given-names></string-name>, <string-name><surname>Gagie</surname><given-names>T</given-names></string-name>, <string-name><surname>Mäkinen</surname><given-names>V</given-names></string-name></person-group><etal>et al</etal><article-title>Bidirectional variable-order de Bruijn graphs</article-title>. <source>Int J Found Comput Sci</source><year>2018</year>;<volume>29</volume>:<fpage>1279</fpage>–<lpage>95</lpage>.</mixed-citation>
    </ref>
    <ref id="btad225-B5">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Bingmann</surname><given-names>T</given-names></string-name>, <string-name><surname>Bradley</surname><given-names>P</given-names></string-name>, <string-name><surname>Gauger</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal> COBS: a compact bit-sliced signature index. In: <italic toggle="yes">SPIRE</italic>. <year>2019</year>. doi: 1905.09624.</mixed-citation>
    </ref>
    <ref id="btad225-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blackwell</surname><given-names>GA</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>M</given-names></string-name>, <string-name><surname>Malone</surname><given-names>KM</given-names></string-name></person-group><etal>et al</etal><article-title>Exploring bacterial diversity via a curated and searchable snapshot of archived DNA sequences</article-title>. <source>PLoS Biol</source><year>2021</year>;<volume>19</volume>:<fpage>e3001421</fpage>.<pub-id pub-id-type="pmid">34752446</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bloom</surname><given-names>BH.</given-names></string-name></person-group><article-title>Space/time trade-offs in hash coding with allowable errors</article-title>. <source>Commun ACM</source><year>1970</year>;<volume>13</volume>:<fpage>422</fpage>–<lpage>6</lpage>.</mixed-citation>
    </ref>
    <ref id="btad225-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bradley</surname><given-names>P</given-names></string-name>, <string-name><surname>den Bakker</surname><given-names>HC</given-names></string-name>, <string-name><surname>Rocha</surname><given-names>EPC</given-names></string-name></person-group><etal>et al</etal><article-title>Ultrafast search of all deposited bacterial and viral genomic data</article-title>. <source>Nat Biotechnol</source><year>2019</year>;<volume>37</volume>:<fpage>152</fpage>–<lpage>9</lpage>. <pub-id pub-id-type="doi">10.1038/s41587-018-0010-1</pub-id>.<pub-id pub-id-type="pmid">30718882</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Camacho</surname><given-names>C</given-names></string-name>, <string-name><surname>Coulouris</surname><given-names>G</given-names></string-name>, <string-name><surname>Avagyan</surname><given-names>V</given-names></string-name></person-group><etal>et al</etal><article-title>BLAST+: architecture and applications</article-title>. <source>BMC Bioinformatics</source><year>2009</year>;<volume>10</volume>:<fpage>1</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">19118496</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Jackman</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>On the representation of de Bruijn graphs</article-title>. <source>J Comput Biol</source><year>2015</year>;<volume>22</volume>:<fpage>336</fpage>–<lpage>52</lpage>.<pub-id pub-id-type="pmid">25629448</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Chikhi</surname><given-names>R</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Compacting de Bruijn graphs from sequencing data quickly and in low memory</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>i201</fpage>–<lpage>8</lpage>. <pub-id pub-id-type="doi">10.1093/bioinformatics/btw279</pub-id>.<pub-id pub-id-type="pmid">27307618</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Deorowicz</surname><given-names>S</given-names></string-name>, <string-name><surname>Debudaj-Grabysz</surname><given-names>A</given-names></string-name>, <string-name><surname>Grabowski</surname><given-names>S.</given-names></string-name></person-group><article-title>Disk-based k-mer counting on a PC</article-title>. <source>BMC Bioinformatics</source><year>2013</year>;<volume>14</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">23323762</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dolle</surname><given-names>DD</given-names></string-name>, <string-name><surname>Liu</surname><given-names>Z</given-names></string-name>, <string-name><surname>Cotten</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Using reference-free compressed data structures to analyze sequencing reads from thousands of human genomes</article-title>. <source>Genome Res</source><year>2017</year>;<volume>27</volume>:<fpage>300</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">27986821</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B14">
      <mixed-citation publication-type="other"><collab>European Nucleotide Archive</collab>. <italic toggle="yes">ENA Statistics — Reads Growth - Reads Doubling Time</italic>. <ext-link xlink:href="https://www.ebi.ac.uk/ena/about/statistics" ext-link-type="uri">https://www.ebi.ac.uk/ena/about/statistics</ext-link> (18 January 2023, date last accessed).</mixed-citation>
    </ref>
    <ref id="btad225-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Harris</surname><given-names>RS</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P.</given-names></string-name></person-group><article-title>Improved representation of sequence bloom trees</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>721</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">31504157</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Melsted</surname><given-names>P.</given-names></string-name></person-group><article-title>Bifrost: highly parallel construction and indexing of colored and compacted de Bruijn graphs</article-title>. <source>Genome Biol</source><year>2020</year>;<volume>21</volume>:<fpage>1</fpage>–<lpage>20</lpage>.</mixed-citation>
    </ref>
    <ref id="btad225-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Holley</surname><given-names>G</given-names></string-name>, <string-name><surname>Wittler</surname><given-names>R</given-names></string-name>, <string-name><surname>Stoye</surname><given-names>J.</given-names></string-name></person-group><article-title>Bloom Filter Trie: an alignment-free and reference-free data structure for pan-genome storage</article-title>. <source>Algorithms Mol Biol</source><year>2016</year>;<volume>11</volume>:<fpage>1</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">26913054</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Janin</surname><given-names>L</given-names></string-name>, <string-name><surname>Schulz-Trieglaff</surname><given-names>O</given-names></string-name>, <string-name><surname>Cox</surname><given-names>AJ.</given-names></string-name></person-group><article-title>BEETL-fastq: a searchable compressed archive for DNA reads</article-title>. <source>Bioinformatics</source><year>2014</year>;<volume>30</volume>:<fpage>2796</fpage>–<lpage>801</lpage>.<pub-id pub-id-type="pmid">24950811</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B19">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Lemane</surname><given-names>T</given-names></string-name>, <string-name><surname>Medvedev</surname><given-names>P</given-names></string-name>, <string-name><surname>Chikhi</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>kmtricks: efficient and flexible construction of Bloom filters for large sequencing data collections</article-title>. <source>Bioinform Adv</source><year>2022</year>;<volume>2</volume>:<fpage>vbac029</fpage>.<pub-id pub-id-type="pmid">36699393</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Li</surname><given-names>H</given-names></string-name>, <string-name><surname>Durbin</surname><given-names>R.</given-names></string-name></person-group><article-title>Fast and accurate short read alignment with Burrows–Wheeler transform</article-title>. <source>Bioinformatics</source><year>2009</year>;<volume>25</volume>:<fpage>1754</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">19451168</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marçais</surname><given-names>G</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>. <source>Bioinformatics</source><year>2011</year>;<volume>27</volume>:<fpage>764</fpage>–<lpage>70</lpage>.<pub-id pub-id-type="pmid">21217122</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C</given-names></string-name>, <string-name><surname>Puglisi</surname><given-names>SJ</given-names></string-name></person-group><etal>et al</etal><article-title>Data structures based on k-mers for querying large collections of sequencing data sets</article-title>. <source>Genome Res</source><year>2021a</year>;<volume>31</volume>:<fpage>1</fpage>–<lpage>12</lpage>.<pub-id pub-id-type="pmid">33328168</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Marchet</surname><given-names>C</given-names></string-name>, <string-name><surname>Kerbiriou</surname><given-names>M</given-names></string-name>, <string-name><surname>Limasset</surname><given-names>A.</given-names></string-name></person-group><article-title>BLight: efficient exact associative structure for k-mers</article-title>. <source>Bioinformatics</source><year>2021b</year>;<volume>37</volume>:<fpage>2858</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">33821954</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mohamadi</surname><given-names>H</given-names></string-name>, <string-name><surname>Khan</surname><given-names>H</given-names></string-name>, <string-name><surname>Birol</surname><given-names>I.</given-names></string-name></person-group><article-title>ntCard: a streaming algorithm for cardinality estimation in genomics data</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>1324</fpage>–<lpage>30</lpage>.<pub-id pub-id-type="pmid">28453674</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muggli</surname><given-names>MD</given-names></string-name>, <string-name><surname>Alipanahi</surname><given-names>B</given-names></string-name>, <string-name><surname>Boucher</surname><given-names>C.</given-names></string-name></person-group><article-title>Building large updatable colored de Bruijn graphs via merging</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>i51</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">31510647</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B26">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Muggli</surname><given-names>MD</given-names></string-name>, <string-name><surname>Bowe</surname><given-names>A</given-names></string-name>, <string-name><surname>Noyes</surname><given-names>NR</given-names></string-name></person-group><etal>et al</etal><article-title>Succinct colored de Bruijn graphs</article-title>. <source>Bioinformatics</source><year>2017</year>;<volume>33</volume>:<fpage>3181</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">28200001</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pibiri</surname><given-names>GE.</given-names></string-name></person-group><article-title>Sparse and skew hashing of k-mers</article-title>. <source>Bioinformatics</source><year>2022</year>;<volume>38</volume>:<fpage>i185</fpage>–<lpage>94</lpage>.<pub-id pub-id-type="pmid">35758794</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Roberts</surname><given-names>M</given-names></string-name>, <string-name><surname>Hayes</surname><given-names>W</given-names></string-name>, <string-name><surname>Hunt</surname><given-names>BR</given-names></string-name></person-group><etal>et al</etal><article-title>Reducing storage requirements for biological sequence comparison</article-title>. <source>Bioinformatics</source><year>2004</year>;<volume>20</volume>:<fpage>3363</fpage>–<lpage>9</lpage>.<pub-id pub-id-type="pmid">15256412</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Shen</surname><given-names>W</given-names></string-name>, <string-name><surname>Le</surname><given-names>S</given-names></string-name>, <string-name><surname>Li</surname><given-names>Y</given-names></string-name></person-group><etal>et al</etal><article-title>SeqKit: a cross-platform and ultrafast toolkit for FASTA/Q file manipulation</article-title>. <source>PLoS One</source><year>2016</year>;<volume>11</volume>:<fpage>e0163962</fpage>.<pub-id pub-id-type="pmid">27706213</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Solomon</surname><given-names>B</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Fast search of thousands of short-read sequencing experiments</article-title>. <source>Nat Biotechnol</source><year>2016</year>;<volume>34</volume>:<fpage>300</fpage>–<lpage>2</lpage>.<pub-id pub-id-type="pmid">26854477</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Solomon</surname><given-names>B</given-names></string-name>, <string-name><surname>Kingsford</surname><given-names>C.</given-names></string-name></person-group><article-title>Improved search of large transcriptomic sequencing databases using split sequence bloom trees</article-title>. <source>J Comput Biol</source><year>2018</year>;<volume>25</volume>:<fpage>755</fpage>–<lpage>65</lpage>.<pub-id pub-id-type="pmid">29641248</pub-id></mixed-citation>
    </ref>
    <ref id="btad225-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Yu</surname><given-names>Y</given-names></string-name>, <string-name><surname>Liu</surname><given-names>J</given-names></string-name>, <string-name><surname>Liu</surname><given-names>X</given-names></string-name></person-group><etal>et al</etal><article-title>SeqOthello: querying RNA-seq experiments at scale</article-title>. <source>Genome Biol</source><year>2018</year>;<volume>19</volume>:<fpage>167</fpage>.<pub-id pub-id-type="pmid">30340508</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
