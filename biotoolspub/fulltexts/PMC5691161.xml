<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Sci Rep</journal-id>
    <journal-id journal-id-type="iso-abbrev">Sci Rep</journal-id>
    <journal-title-group>
      <journal-title>Scientific Reports</journal-title>
    </journal-title-group>
    <issn pub-type="epub">2045-2322</issn>
    <publisher>
      <publisher-name>Nature Publishing Group UK</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">5691161</article-id>
    <article-id pub-id-type="pmid">29146965</article-id>
    <article-id pub-id-type="publisher-id">15313</article-id>
    <article-id pub-id-type="doi">10.1038/s41598-017-15313-9</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Article</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Gpufit: An open-source toolkit for GPU-accelerated curve fitting</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-7306-975X</contrib-id>
        <name>
          <surname>Przybylski</surname>
          <given-names>Adrian</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Thiel</surname>
          <given-names>Björn</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-2753-0848</contrib-id>
        <name>
          <surname>Keller-Findeisen</surname>
          <given-names>Jan</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stock</surname>
          <given-names>Bernd</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-0668-5277</contrib-id>
        <name>
          <surname>Bates</surname>
          <given-names>Mark</given-names>
        </name>
        <address>
          <email>mark.bates@mpibpc.mpg.de</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2104 4211</institution-id><institution-id institution-id-type="GRID">grid.418140.8</institution-id><institution>Department of NanoBiophotonics, </institution><institution>Max Planck Institute for Biophysical Chemistry, </institution></institution-wrap>Am Fassberg 11, Göttingen, 37077 Germany </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ISNI">0000 0000 8558 6741</institution-id><institution-id institution-id-type="GRID">grid.461644.5</institution-id><institution>Faculty of Natural Sciences and Technology, </institution><institution>University of Applied Sciences and Arts, </institution></institution-wrap>Von-Ossietzkystraße 99, Göttingen, 37085 Germany </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>16</day>
      <month>11</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>16</day>
      <month>11</month>
      <year>2017</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2017</year>
    </pub-date>
    <volume>7</volume>
    <elocation-id>15722</elocation-id>
    <history>
      <date date-type="received">
        <day>11</day>
        <month>8</month>
        <year>2017</year>
      </date>
      <date date-type="accepted">
        <day>25</day>
        <month>10</month>
        <year>2017</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2017</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">We present a general purpose, open-source software library for estimation of non-linear parameters by the Levenberg-Marquardt algorithm. The software, Gpufit, runs on a Graphics Processing Unit (GPU) and executes computations in parallel, resulting in a significant gain in performance. We measured a speed increase of up to 42 times when comparing Gpufit with an identical CPU-based algorithm, with no loss of precision or accuracy. Gpufit is designed such that it is easily incorporated into existing applications or adapted for new ones. Multiple software interfaces, including to C, Python, and Matlab, ensure that Gpufit is accessible from most programming environments. The full source code is published as an open source software repository, making its function transparent to the user and facilitating future improvements and extensions. As a demonstration, we used Gpufit to accelerate an existing scientific image analysis package, yielding significantly improved processing times for super-resolution fluorescence microscopy datasets.</p>
    </abstract>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2017</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1" sec-type="introduction">
    <title>Introduction</title>
    <p id="Par2">Optimization algorithms are widely used in science and engineering. In particular, when comparing data with a model function, numerical optimization methods may be applied to establish the suitability of the model and to determine the parameters which best describe the observations. One such method, which is generally applicable to models which depend non-linearly on a set of parameters, is the Levenberg-Marquardt algorithm (LMA)<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>, and this has become a standard approach for non-linear least squares curve fitting<sup><xref ref-type="bibr" rid="CR2">2</xref>,<xref ref-type="bibr" rid="CR3">3</xref></sup>.</p>
    <p id="Par3">Although the LMA is, in itself, an efficient algorithm, applications requiring many iterations of this procedure may encounter limitations due to the sheer number of calculations involved. The time required for the convergence of a fit, or a set of fits, can determine an application’s feasibility, e.g. in the context of real-time data processing and feedback systems. Alternatively, in the case of very large datasets, the time required to solve a particular optimization problem may prove impractical.</p>
    <p id="Par4">In recent years, advanced graphics processing units (GPUs) and the development of general purpose GPU programming have enabled fast and parallelized computing by shifting calculations from the CPU to the GPU<sup><xref ref-type="bibr" rid="CR4">4</xref></sup>. The large number of independent computing units available on modern GPUs enables the rapid execution of many instructions in parallel, with an overall computation power far exceeding that of a CPU. Languages such as CUDA C and OpenCL allow GPU-based programs to be developed in a manner similar to conventional software, but with an inherently parallelized structure. These developments have led to the creation of new GPU-accelerated tools, such as the MAGMA linear algebra library<sup><xref ref-type="bibr" rid="CR5">5</xref></sup>, for example.</p>
    <p id="Par5">Here, we present Gpufit: a GPU-accelerated implementation of the Levenberg-Marquardt algorithm. Gpufit was developed to meet the need for a high performance, general-purpose nonlinear curve fitting library which is publicly available and open source. As expected, this software exhibits significantly faster execution than the equivalent CPU-based code, with no loss of precision or accuracy. In this report we discuss the design of Gpufit, characterize its performance in comparison to other CPU-based and GPU-based algorithms, and demonstrate its use in a scientific data analysis application.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <p id="Par6">The Gpufit library was designed to meet several criteria: <italic>(i)</italic> the software should make efficient use of the GPU resources in order to maximize execution speed, <italic>(ii)</italic> the interface should not require detailed knowledge of the GPU hardware, <italic>(iii)</italic> the source code should be modular and extendable, and <italic>(iv)</italic> the software should be accessible from multiple programming environments.</p>
    <p id="Par7">Gpufit implements the LMA entirely on the GPU, minimizing data transfers between CPU and GPU memory. Copying memory between the CPU and the GPU is a slow operation, and it is most efficient to handle large blocks of data at once. Therefore, Gpufit was designed to process multiple fits simultaneously, each with the same model function and data size, but allowing for unique starting parameters for each fit. Large tasks (e.g. large numbers of fits) are divided into chunks, in order to balance processing and data transfer times. At the start of a calculation, a chunk of input data is copied to the GPU global memory, and upon completion the results are transferred back to CPU memory.</p>
    <p id="Par8">GPU architecture is based on a set of parallel multiprocessors, which divide computations between blocks of processing threads, as illustrated in Supplementary Fig. <xref rid="MOESM1" ref-type="media">S1</xref>. The efficiency of a GPU-based program depends on how these computing resources are used. While determining how best to parallelize the LMA, we found that different parts of the algorithm were most efficiently implemented with different parallelization strategies. For example, point-wise operations such as computation of the model function and its partial derivatives were more efficiently parallelized along the data coordinate index, meaning that each thread computes one model and derivative value at a particular coordinate. Other steps, such as the calculation of the Hessian matrix, were more efficiently parallelized along the index of the matrix element, i.e. with each thread assigned to calculate one element of the matrix. To accommodate the necessity for parallelizing different parts of the LMA in different ways, we structured Gpufit as a set of independent CUDA kernels, each responsible for a section of the algorithm. In this way, the blocks and threads of the GPU multiprocessors could be optimally allocated at each step. The details of the various parallelization schemes are documented in the Gpufit source code (see Code Availability).</p>
    <p id="Par9">Another design consideration was how to distribute fits across the thread blocks of the GPU. Initially, we considered calculating one fit per thread block, and one data point per thread. However, this approach yielded poor results for small fit data sizes, due to the limited numbers of threads executed on each multiprocessor. Hence, the software was modified to allow the calculation of multiple fits in each thread block or, if necessary, to spread the calculation of a single fit over multiple thread blocks. Thus, the number of threads per block was maximized, yielding improved processing speeds without imposing restrictions on the size of each fit. Finally, we note that GPU shared memory (see Fig. S1) was used for the calculation of intermediate values requiring many reads and writes (e.g. the summation of chi-square), in order to take advantage of the faster performance of shared memory blocks.</p>
    <p id="Par10">The computing resources of a GPU may vary significantly, depending on the details of the hardware. One of our aims was to avoid the necessity for any hardware-specific configuration parameters in the Gpufit interface. Therefore, Gpufit was designed to read the properties of the GPU at run-time, and automatically set parameters such as the number of blocks and threads available, and the number of fits to calculate simultaneously. This makes the use of a GPU transparent to the programmer, and allows the interface to be no different from that for a conventional curve fitting function. Moreover, it ensures that applications using Gpufit will perform optimally regardless of the machine on which they are running.</p>
    <p id="Par11">The Gpufit source code is modular, such that fit functions and goodness-of-fit estimators are separate from the core sections of the code, and new functions or estimators may be added simply (see Supplementary Information). In its initial release, Gpufit includes two different fit estimators: the standard weighted least-squares estimator (LSE), and a maximum likelihood estimator (MLE) which provides better fit results when the input data is characterized by Poisson statistics<sup><xref ref-type="bibr" rid="CR6">6</xref></sup>. The modular concept is illustrated schematically in Supplementary Fig. <xref rid="MOESM1" ref-type="media">S2</xref>. This modularity allows Gpufit to be quickly adapted to new applications, or modified to accommodate future developments.</p>
    <p id="Par12">Finally, Gpufit is written in C, CUDA C, and C++, and compiles to a Dynamic Link Library (DLL) providing a C interface, making it straightforward to call Gpufit from most programming environments. Furthermore, Gpufit bindings for Matlab and Python (e.g. the pyGpufit module) were implemented, forming part of the Gpufit distribution.</p>
    <sec id="Sec3">
      <title>Performance characterization</title>
      <p id="Par13">We tested Gpufit by using the software to process randomized simulated datasets. The precision and accuracy of the fit results, as well as the number of fit iterations and the execution time, were measured. The input data consisted of 2D Gaussian functions defined by five parameters (see Supporting Information). Random noise (Gaussian or Poisson) was added to each data point. Test data was generated in Matlab and passed to the fit routines via their Matlab interfaces.</p>
    </sec>
    <sec id="Sec4">
      <title>Algorithm validation</title>
      <p id="Par14">An initial step in characterizing Gpufit was to verify the correct operation of the algorithm. For this purpose, we tested Gpufit against the well-established MINPACK library<sup><xref ref-type="bibr" rid="CR7">7</xref></sup>, evaluating the precision and accuracy of the fit results, and the convergence of the fit. Gaussian noise was added to the input data such that the signal to noise ratio (SNR) could be defined. Upon testing, the two packages yielded almost identical fit precision over a wide range of SNR values, and converged in a similar number of steps (Supplementary Fig. <xref rid="MOESM1" ref-type="media">S3</xref>). At very high SNR, differences appear due to the limited numerical precision of floating point operations in CUDA (single precision) vs. MINPACK (double precision). Fit accuracy was checked by comparing the distributions of the fit parameters (Supplementary Fig. <xref rid="MOESM1" ref-type="media">S4</xref>), and no systematic deviation between the output of Gpufit and MINPACK was detected. Together, these measurements demonstrate that Gpufit yields precise and accurate fit results, and converges similarly when compared to existing optimization software.</p>
    </sec>
    <sec id="Sec5">
      <title>Execution speed and fit precision</title>
      <p id="Par15">The parallel architecture of the GPU enables significant speed improvements when a computation is amenable to being divided among multiple processors. To fairly evaluate the speed improvement obtained by shifting processing tasks from the CPU to the GPU, equivalent implementations of the LMA, running on both architectures, were required. We created a library called Cpufit to serve as the reference CPU-based fitting algorithm for testing purposes (see Methods). Cpufit implements precisely the same algorithm, section by section, as Gpufit. We verified that Cpufit and Gpufit returned numerically identical fit results given identical input data.</p>
      <p id="Par16">A comparison of execution speeds, plotted against the number of fits per function call (<italic>N</italic>), is shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. As expected, the fitting speed on the CPU remains constant as <italic>N</italic> changes, due to the sequential execution of each fit calculation. On the other hand, for Gpufit the speed increases with increasing <italic>N</italic>. The more fits that are calculated in one execution, the greater the benefit of parallelization. The crossover point at which use of the GPU becomes advantageous is, in this case, approximately <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$N=130$$\end{document}</tex-math><mml:math id="M2"><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>130</mml:mn></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq1.gif"/></alternatives></inline-formula> fits. For very large <italic>N</italic> the speed of GPU processing saturates, indicating that GPU resources are fully utilized. At <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$N={10}^{8}$$\end{document}</tex-math><mml:math id="M4"><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mn>8</mml:mn></mml:msup></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq2.gif"/></alternatives></inline-formula> fits per function call, we measured a processing speed of more than 4.5 million fits per second, approximately 42 times faster than the same algorithm executed on the CPU.<fig id="Fig1"><label>Figure 1</label><caption><p>Execution speed of the Levenberg-Marquardt algorithm on the CPU or the GPU, as a function of the number of fits processed. For small numbers of fits, GPU-based curve fitting is slower than CPU-based fitting, due to the extra time spent copying data between the CPU and the GPU. For larger numbers of fits, however, the GPU significantly out-performs the CPU, due to the GPU’s parallel architecture. In this example, the maximum speed achieved was 4.65 × 10<sup>6</sup> fits per second for GPU-based curve fitting (dependent on the specifics of the hardware, the fit function, and the fit data). The simulated data consisted of 2D Gaussian peaks with a size of 5 × 5 points. This data was fit to a symmetric 2D Gaussian function using the unweighted least squares estimator. All calculations were run using an NVIDIA GeForce GTX 1080 GPU and an Intel Core i7 5820 K CPU (3.3 GHz). For details of the simulated data and fit parameters, see the Supplementary Information.</p></caption><graphic xlink:href="41598_2017_15313_Fig1_HTML" id="d29e390"/></fig>
</p>
      <p id="Par17">Measurements of the execution time for each sub-section of the Cpufit and Gpufit code reveal the bottlenecks of the CPU-based algorithm, and how the computational workload is re-distributed on the GPU. For a set of <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$5\times {10}^{6}$$\end{document}</tex-math><mml:math id="M6"><mml:mn>5</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq3.gif"/></alternatives></inline-formula> fits we measured the time duration of each step of the fitting process, and these results are shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. For reference, program flowcharts for Cpufit and Gpufit, color coded according to processing time, are shown in Supplementary Fig. <xref rid="MOESM1" ref-type="media">S5</xref> and <xref rid="MOESM1" ref-type="media">S6</xref>. In our tests, the most time-consuming task for Cpufit was the calculation of the model function and its derivatives, requiring more than one third of the total execution time. Gpufit completed the same calculation more than 100 times faster, due to the parallelization of the work. Similarly, all other steps in the fit process ran 10–100 times faster on the GPU. Gpufit includes additional operations, such as data transfers between CPU and GPU memory, however these did not impact performance when sufficient numbers of fits were processed.<fig id="Fig2"><label>Figure 2</label><caption><p>Comparison of execution times for each section of the Cpufit and Gpufit programs. The horizontal bars represent the amount of time spent in each section of the algorithm while processing a dataset consisting of <inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$N=5.0\times {10}^{6}$$\end{document}</tex-math><mml:math id="M8"><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>5.0</mml:mn><mml:mo>×</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mn>6</mml:mn></mml:msup></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq4.gif"/></alternatives></inline-formula> 2D Gaussian fits. Four additional sections are required for Gpufit: GPU memory allocation, copying data to the GPU, copying results from the GPU, and GPU memory de-allocation. All sections of the fit algorithm required less time when executed on the GPU, with the largest differences corresponding to the computational bottlenecks of Cpufit. For details of the simulated data and fit parameters, see the Supplementary Information.</p></caption><graphic xlink:href="41598_2017_15313_Fig2_HTML" id="d29e451"/></fig>
</p>
      <p id="Par18">Given the parallel computing capability of the GPU, it was not surprising that Gpufit outperformed an equivalent algorithm running on the CPU. In order to verify that our code is efficiently implemented, we therefore tested Gpufit against another GPU-based fitting library: GPU-LMFit<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>. These tests were limited to smaller datasets because GPU-LMFit is available only as a closed-source, 32-bit binary package, restricting the size of the memory it can address. Figure <xref rid="Fig3" ref-type="fig">3a</xref> shows the speed of the Gpufit and GPU-LMFit libraries measured as a function of the number of fits per function call (<italic>N</italic>), with the speed of the MINPACK library shown for reference. Both packages exhibited similar scaling in speed as the number of fits and the data size varied, however, Gpufit showed faster performance for all conditions tested. As the data size per fit was increased (Fig. <xref rid="Fig3" ref-type="fig">3b</xref>), the speeds became more comparable, indicating that Gpufit makes more efficient use of GPU resources for smaller fits. The increased speed comes with no loss of precision, as it was also shown that the fit results returned by Gpufit and GPU-LMFit have virtually identical numerical precision (see Supplementary Fig. <xref rid="MOESM1" ref-type="media">S7</xref>).<fig id="Fig3"><label>Figure 3</label><caption><p>Processing speed comparison between three fitting libraries: Gpufit, MINPACK, and GPU-LMFit. (<bold>a</bold>) Execution speed vs. number of fits per function call (<italic>N</italic>). (<bold>b</bold>) Execution speed vs. number of data points per fit, where the size of the simulated 2D Gaussian peaks was varied from 5 × 5 up to 25 × 25 points. For smaller tasks (smaller numbers of fits per call or smaller data sizes) the Gpufit library makes more efficient use of GPU processing resources, outperforming GPU-LMFit by more than one order of magnitude. For larger tasks the results become more similar between the two GPU-based libraries. For details of the simulated data and fit parameters, see the Supplementary Information.</p></caption><graphic xlink:href="41598_2017_15313_Fig3_HTML" id="d29e489"/></fig>
</p>
      <p id="Par19">When data is subject to counting statistics (i.e. when the noise has a Poisson distribution), curve fitting using an alternative goodness-of-fit measure based on maximum likelihood estimation (MLE) has been reported to yield more accurate fit results, when compared with least-squares fitting<sup><xref ref-type="bibr" rid="CR9">9</xref>,<xref ref-type="bibr" rid="CR10">10</xref></sup>. We tested the performance of this estimator using input data with simulated Poisson noise. The precision of the fit results, using either the unweighted LSE, weighted LSE, or MLE estimators, is shown in Supplementary Fig. <xref rid="MOESM1" ref-type="media">S8</xref>. We found that the MLE estimator yielded better results than the LSE, particularly at small data values, although for larger values the two methods were approximately equivalent.</p>
    </sec>
    <sec id="Sec6">
      <title>Application to super-resolution microscopy</title>
      <p id="Par20">Gpufit is well suited for rapid processing of large datasets, and its interface allows it to serve as a direct replacement for existing CPU-based fit routines. To demonstrate these capabilities in a real application, we integrated Gpufit into the image analysis pipeline of a super-resolution fluorescence microscopy experiment.</p>
      <p id="Par21">Stochastic optical reconstruction microscopy (STORM) is a method for fluorescence imaging of biological samples, which obtains an image resolution significantly higher than the classical “diffraction limit” of far-field optical microscopy<sup><xref ref-type="bibr" rid="CR11">11</xref></sup>. This method relies heavily on image processing: the generation of a single STORM image requires thousands to millions of individual fitting operations, and this task may require minutes to hours of computation before the final image is obtained.</p>
      <p id="Par22">We integrated Gpufit into a recently published software package, Picasso<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>, which may be used to process raw STORM data into a super-resolved image of the sample. The Picasso software is written in Python, and is optimized to carry out the fit using a multi-threaded process running on all cores of the CPU. Moreover, Picasso uses “just in time” (JIT) compilation to optimize its execution speed. We modified this section of the Picasso source code, replacing the multi-core CPU-based fitting with a call to Gpufit, as illustrated schematically in Fig. <xref rid="Fig4" ref-type="fig">4a</xref>. Comparing the speed of Picasso before and after the modification demonstrates the benefit of Gpufit. When analyzing a raw STORM dataset (80000 images requiring 3.6 million fit operations), a fitting task which required 99.4 s with standard Picasso was completed in only 2.2 s after Gpufit was included, a 45-fold speed increase, with identical fit precision. The output STORM image is shown in Fig. <xref rid="Fig4" ref-type="fig">4b</xref>, and a comparison of the curve fitting time with and without Gpufit is shown in Fig. <xref rid="Fig4" ref-type="fig">4c</xref>.<fig id="Fig4"><label>Figure 4</label><caption><p>Accelerated STORM analysis in Picasso. (<bold>a</bold>) Schematic diagram comparing the multi-core CPU-based fitting of Picasso (left) vs. parallelized GPU-based fitting with Gpufit (right). Picasso uses multiple cores (“workers”) of the CPU to simultaneously compute the fits. We replaced this section of the Picasso source code with a call to Gpufit, which has a greater capacity for parallelization via the GPU. (<bold>b</bold>) Super-resolution (STORM) image of nuclear pore complexes in eukaryotic cells. The protein GP210 was labeled with a fluorescent marker (Alexa Fluor 647), and the sample was imaged on a STORM microscope (see Supplementary Information). The conventional epi-fluorescence image is shown in the top right corner, to provide a resolution comparison. Data processing was performed in Picasso, requiring 3.6 million individual curve fitting operations. (<bold>c</bold>) Execution time of the curve fitting process, comparing the original (published) Picasso software vs. the modified Picasso software which includes Gpufit. The processing time was reduced significantly, by a factor of 45, when Gpufit was used to handle curve fitting tasks within the Picasso application. For these measurements, the data was fit to a symmetric 2D Gaussian function (Picasso default) using the unweighted least squares estimator, and the fit size was 7 × 7 pixels. All calculations were run on an NVIDIA GeForce GTX 1080 GPU and an Intel Core i7 5820 K CPU (3.3 GHz). For detailed test conditions, see the Supplementary Information.</p></caption><graphic xlink:href="41598_2017_15313_Fig4_HTML" id="d29e547"/></fig>
</p>
    </sec>
  </sec>
  <sec id="Sec7" sec-type="discussion">
    <title>Discussion</title>
    <p id="Par23">General purpose GPU computing is a relatively new technology, which is making an impact in many fields of science and engineering. The software introduced here, Gpufit, represents the first general purpose, open source implementation of a non-linear curve fitting algorithm for the GPU. It is intended as a compact, high performance optimization tool, easily modified and adapted for new tasks, which can be rapidly implemented within existing data analysis applications.</p>
    <p id="Par24">In terms of performance, Gpufit exhibits similar precision and accuracy to other fitting libraries, but with significantly faster execution. In our measurements, curve fitting with Gpufit was approximately 42 times faster than the same algorithm running on the CPU. Gpufit also outperformed another GPU-based implementation of the LMA, GPU-LMFit, for all conditions tested. The absolute values of the timing results depend on the details of the fit and the computer hardware. Higher performance would be expected with a more powerful GPU (e.g. an Nvidia Tesla), or with multiple GPUs running in parallel. In addition to its speed, the principal advantages of Gpufit are its general purpose design, which may incorporate any model function or modified estimator, and the availability of the source code, which allows it to be compiled and run on multiple computing architectures.</p>
    <p id="Par25">Since Gpufit automatically distributes the curve fitting tasks over the blocks and threads of the GPU multiprocessors, the user is not required to know the specifications of the hardware, thereby allowing Gpufit to be used as a “drop-in” replacement for existing fit functions. To demonstrate this, we modified Picasso to make use of Gpufit rather than its own multi-core CPU fitting code. Despite the fact that curve fitting in Picasso was already parallelized (by virtue of its use of multi-threaded processing) we found that Gpufit outperformed the built-in Picasso curve fitting by a factor of 45 times (Fig. <xref rid="Fig4" ref-type="fig">4</xref>). The ease with which Gpufit was integrated into Picasso, and the gain in performance, show that our original design goals were met.</p>
    <p id="Par26">As of its initial release, the Gpufit package has several limitations. First, the fit model functions are built into the code at compilation time, and the addition or modification of a model function requires re-compilation of the source code. We also note that Gpufit requires the explicit calculation of the partial derivatives of the model, and expressions for these functions must be present in the code embodying the fit model function. However, as an open-source software project, we expect that Gpufit will continue to develop and improve, potentially removing these limitations in future versions. For example, runtime compilation of model functions written in CUDA would lift the requirement for re-building the source, and methods to approximate the derivatives numerically could also be introduced. Finally, there is the potential for porting Gpufit to other general-purpose GPU computing languages, such as OpenCL, thereby allowing the software to function on other GPU hardware platforms.</p>
    <p id="Par27">Using an inexpensive graphics card and a standard PC, we achieved speeds higher than 4.5 million fits per second for data that is typical of STORM experiments (Fig. <xref rid="Fig1" ref-type="fig">1</xref>). Considering recent developments in localization based super-resolution methods, in particular experiments in which &gt; 400 million individual fluorophore switching events were recorded<sup><xref ref-type="bibr" rid="CR13">13</xref></sup>, data processing speed has become highly relevant. A tool such as Gpufit could make the difference between a researcher waiting minutes (with Gpufit) or hours (without) before the image can be examined. This rapid feedback has a greater importance than simply reducing waiting time – it enables the quick screening of samples and test conditions, ultimately leading to higher quality image data. Furthermore, we expect that Gpufit will facilitate the adoption of new, computationally demanding data analysis approaches, such as cubic spline fitting<sup><xref ref-type="bibr" rid="CR14">14</xref></sup>, in order to further improve STORM image resolution.</p>
  </sec>
  <sec id="Sec8" sec-type="conclusion">
    <title>Conclusions</title>
    <p id="Par28">We have developed a GPU-accelerated implementation of the Levenberg Marquardt algorithm, with significantly faster performance as compared with traditional CPU-based software. Gpufit is designed to be general purpose, and as such we expect it to be useful for diverse applications in science and engineering which may depend critically on rapid data processing, e.g. high-speed feedback systems and the recently described MINFLUX method for particle tracking and nanoscale imaging<sup><xref ref-type="bibr" rid="CR15">15</xref></sup>. The Gpufit library is accessible from most programming environments, and the automatic configuration of GPU-specific parameters makes it simple to work with in practice. The modularity of Gpufit facilitates the addition of custom fit models or estimators, for example the mixed Gaussian/Poisson likelihood model required for accurately analyzing sCMOS camera data<sup><xref ref-type="bibr" rid="CR16">16</xref></sup>. Finally, Gpufit makes efficient use of GPU computing resources by exploiting simple parallelization schemes as well as distributing fit tasks evenly over the multiprocessors of the GPU to achieve high performance. Using Gpufit with our own hardware, we obtained a 42-fold improvement in execution time for batch-processing of curve fitting tasks, with no loss of precision or accuracy.</p>
    <p id="Par29">Gpufit is an open source software project, and the source code is available via the Github public software repository. Open source software development is advantageous from several standpoints: it enhances code integrity through review by users, and offers the possibility for users to fix bugs and add features<sup><xref ref-type="bibr" rid="CR17">17</xref></sup>. In addition, open source code makes the workings of an algorithm transparent to the user, which may be a crucial factor when a “black box” software tool is not sufficient, such as in scientific data analysis applications. Finally, we note that Marquardt’s original paper introducing his algorithm, published in 1963, concludes with the following sentence: “A FORTRAN program … embodying the algorithm described in this paper is available as IBM Share Program No. 1428”<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>. The SHARE software library referred to by Marquardt was, in fact, an early form of open source software<sup><xref ref-type="bibr" rid="CR18">18</xref></sup>, and we find it appropriate that Gpufit should be published in a similar manner.</p>
  </sec>
  <sec id="Sec9" sec-type="materials|methods">
    <title>Methods</title>
    <sec id="Sec10">
      <title>Levenberg-Marquardt algorithm</title>
      <p id="Par30">The LMA provides a general numerical procedure for fitting a non-linear model function to a set of data points. It may be considered as a combination of the method of steepest descent and Newton’s method, having a high probability of convergence even when the initial parameter estimates are poor, and fast convergence near the minimum. The standard algorithm, as described by Marquardt<sup><xref ref-type="bibr" rid="CR1">1</xref></sup>, minimizes iteratively the general least squares equation:<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }^{2}\,(\mathop{{a}}\limits^{{\rightharpoonup }})\,=\,\sum _{n=0}^{N-1}{({f}_{n}(\mathop{a}\limits^{\rightharpoonup })-{z}_{n})}^{2}$$\end{document}</tex-math><mml:math id="M10" display="block"><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi mathvariant="italic">a</mml:mi><mml:mo mathvariant="italic">⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mspace width=".25em"/><mml:mo>=</mml:mo><mml:mspace width=".25em"/><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mspace width="-.25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>where <inline-formula id="IEq5"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${f}_{n}$$\end{document}</tex-math><mml:math id="M12"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq5.gif"/></alternatives></inline-formula> are the model function values, <inline-formula id="IEq6"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\mathop{a}\limits^{\rightharpoonup }$$\end{document}</tex-math><mml:math id="M14"><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq6.gif"/></alternatives></inline-formula> is the vector of model parameters, and <inline-formula id="IEq7"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${z}_{n}$$\end{document}</tex-math><mml:math id="M16"><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq7.gif"/></alternatives></inline-formula> are the set of <italic>N</italic> data points. To find the minimum of <inline-formula id="IEq8"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }^{2}\,(\mathop{a}\limits^{\rightharpoonup })$$\end{document}</tex-math><mml:math id="M18"><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq8.gif"/></alternatives></inline-formula> (chi-square), the algorithm performs an iterative search of the parameter space for a coordinate where the gradient of the function equals zero, i.e. <inline-formula id="IEq9"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\nabla {\chi }^{2}\,(\mathop{a}\limits^{\rightharpoonup })=0$$\end{document}</tex-math><mml:math id="M20"><mml:mo>∇</mml:mo><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq9.gif"/></alternatives></inline-formula>. The gradient is approximated by a Taylor expansion:<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$0\,=\,\nabla {\chi }^{2}\,({\mathop{a}\limits^{\rightharpoonup }}_{i}+{\mathop{\delta }\limits^{\rightharpoonup }}_{i})\,\approx \,\nabla {\chi }^{2}\,({\mathop{a}\limits^{\rightharpoonup }}_{i})\,+\,{H}_{{\chi }^{2}}\,({\mathop{a}\limits^{\rightharpoonup }}_{i})\,{\mathop{\delta }\limits^{\rightharpoonup }}_{i}$$\end{document}</tex-math><mml:math id="M22" display="block"><mml:mn>0</mml:mn><mml:mspace width=".25em"/><mml:mo>=</mml:mo><mml:mspace width=".25em"/><mml:mo>∇</mml:mo><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mspace width=".25em"/><mml:mo>≈</mml:mo><mml:mspace width=".25em"/><mml:mo>∇</mml:mo><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mspace width=".25em"/><mml:mo>+</mml:mo><mml:mspace width=".25em"/><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mspace width=".25em"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>where <inline-formula id="IEq10"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{{\chi }^{2}}\,({\mathop{a}\limits^{\rightharpoonup }}_{i})$$\end{document}</tex-math><mml:math id="M24"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq10.gif"/></alternatives></inline-formula> is the Hessian matrix of <inline-formula id="IEq11"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }^{2}({\mathop{a}\limits^{\rightharpoonup }}_{i})$$\end{document}</tex-math><mml:math id="M26"><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width="-.25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq11.gif"/></alternatives></inline-formula>, and <inline-formula id="IEq12"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{\delta }\limits^{\rightharpoonup }}_{i}$$\end{document}</tex-math><mml:math id="M28"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq12.gif"/></alternatives></inline-formula> is a small correction to <inline-formula id="IEq13"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{a}\limits^{\rightharpoonup }}_{i}$$\end{document}</tex-math><mml:math id="M30"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq13.gif"/></alternatives></inline-formula> (the index <italic>i</italic> corresponds to the iteration number). The expression for the Hessian includes the first and the second partial derivatives of <inline-formula id="IEq14"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }^{2}\,(\mathop{a}\limits^{\rightharpoonup })$$\end{document}</tex-math><mml:math id="M32"><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq14.gif"/></alternatives></inline-formula>, however terms containing the second derivatives are assumed negligible and ignored. Solving (<xref rid="Equ2" ref-type="">2</xref>) for <inline-formula id="IEq15"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{\delta }\limits^{\rightharpoonup }}_{i}$$\end{document}</tex-math><mml:math id="M34"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq15.gif"/></alternatives></inline-formula> yields the Newton step for the minimization of <inline-formula id="IEq16"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }^{2}\,(\mathop{a}\limits^{\rightharpoonup })$$\end{document}</tex-math><mml:math id="M36"><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq16.gif"/></alternatives></inline-formula>. Up to this point, the LMA is equivalent to Newton’s Method.</p>
      <p id="Par31">A special characteristic of the LMA is the damping factor <italic>λ</italic> which controls the step size of each iteration by modifying the diagonal elements of the Hessian:<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H^{\prime} }_{{\chi }^{2},kl}\,(\mathop{a}\limits^{\rightharpoonup })\,=\,\{\begin{array}{lc}{H}_{{\chi }^{2},kl}\,(\mathop{a}\limits^{\rightharpoonup }), &amp; {\rm{for}}\,k\ne l\\ {H}_{{\chi }^{2},kl}\,(\mathop{a}\limits^{\rightharpoonup })\cdot (1+\lambda ), &amp; {\rm{for}}\,k=l\end{array}$$\end{document}</tex-math><mml:math id="M38" display="block"><mml:msub><mml:mrow><mml:mi>H</mml:mi><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width="-.25em"/><mml:mo>,</mml:mo><mml:mspace width=".25em"/><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mspace width=".25em"/><mml:mo>=</mml:mo><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width="-.25em"/><mml:mo>,</mml:mo><mml:mspace width=".25em"/><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="normal">for</mml:mi><mml:mspace width="0.25em"/><mml:mi>k</mml:mi><mml:mo>≠</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width="-.25em"/><mml:mo>,</mml:mo><mml:mspace width=".25em"/><mml:mi>k</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>λ</mml:mi></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="normal">for</mml:mi><mml:mspace width="0.25em"/><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>l</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>where <italic>k</italic> and <italic>l</italic> are the matrix indices. The positive factor <italic>λ</italic> is initialized with a small value, and thus initially the algorithm behaves like Newton’s method. As the algorithm iterates, if the value of chi-square in the latest iteration is smaller than in the previous step, <italic>λ</italic> is decreased by a constant factor <italic>v</italic>. Otherwise, <italic>λ</italic> is increased by the same factor. Increasing <italic>λ</italic> causes the LMA to tend towards the behavior of the method of steepest descent. In this manner, the LMA adjusts between the two methods, as the minimum is approached.</p>
      <p id="Par32">By transposing equation (<xref rid="Equ2" ref-type="">2</xref>) and applying the damping factor (<xref rid="Equ3" ref-type="">3</xref>), a system of linear equations is obtained which may be solved for <inline-formula id="IEq17"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{\delta }\limits^{\rightharpoonup }}_{i}$$\end{document}</tex-math><mml:math id="M40"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq17.gif"/></alternatives></inline-formula>, e.g. by the Gauss-Jordan method<sup><xref ref-type="bibr" rid="CR3">3</xref></sup>:<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{\delta }\limits^{\rightharpoonup }}_{i}\,=\,-H{{^{\prime} }_{{\chi }^{2}}}^{-1}\,({\mathop{a}\limits^{\rightharpoonup }}_{i})\cdot \nabla {\chi }^{2}\,({\mathop{a}\limits^{\rightharpoonup }}_{i}).$$\end{document}</tex-math><mml:math id="M42" display="block"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mo>=</mml:mo><mml:mspace width=".25em"/><mml:mo>−</mml:mo><mml:mi>H</mml:mi><mml:msup><mml:msub><mml:mrow><mml:mo>′</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msub><mml:mrow><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>⋅</mml:mo><mml:mo>∇</mml:mo><mml:msup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p id="Par33">If the iteration is successful (chi-square decreased), the difference <inline-formula id="IEq18"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{\delta }\limits^{\rightharpoonup }}_{i}$$\end{document}</tex-math><mml:math id="M44"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq18.gif"/></alternatives></inline-formula> is added to the previous parameter values:<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\mathop{a}\limits^{\rightharpoonup }}_{i+1}\,=\,{\mathop{a}\limits^{\rightharpoonup }}_{i}\,+\,{\mathop{\delta }\limits^{\rightharpoonup }}_{i}.$$\end{document}</tex-math><mml:math id="M46" display="block"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mo>=</mml:mo><mml:mspace width=".25em"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mspace width=".25em"/><mml:mo>+</mml:mo><mml:mspace width=".25em"/><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>δ</mml:mi><mml:mo>⇀</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>.</mml:mo></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p id="Par34">The damping factor <italic>λ</italic> is updated after each iteration, and convergence is tested. Any convenient convergence criterion may be used, but in general the overall convergence of the LMA depends on the relative size of the parameter adjustment in each iteration. As originally set out by Marquardt, with a reasonable choice of <italic>r</italic> and <inline-formula id="IEq19"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\varepsilon $$\end{document}</tex-math><mml:math id="M48"><mml:mi>ε</mml:mi></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq19.gif"/></alternatives></inline-formula> (e.g. <inline-formula id="IEq20"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$r={10}^{-3}$$\end{document}</tex-math><mml:math id="M50"><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq20.gif"/></alternatives></inline-formula> and <inline-formula id="IEq21"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\varepsilon ={10}^{-5}$$\end{document}</tex-math><mml:math id="M52"><mml:mi>ε</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq21.gif"/></alternatives></inline-formula>), the algorithm has converged when<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\frac{|{\delta }_{i,j}|}{r+|{a}_{i,j}|}\, &lt; \,\varepsilon $$\end{document}</tex-math><mml:math id="M54" display="block"><mml:mfrac><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>δ</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow></mml:mrow></mml:mfrac><mml:mspace width=".25em"/><mml:mo>&lt;</mml:mo><mml:mspace width=".25em"/><mml:mi>ε</mml:mi></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula>is satisfied for all parameters, where <italic>r</italic> is a small positive constant (to avoid division by zero), <italic>i</italic> is the iteration number, and <italic>j</italic> is the parameter index.</p>
    </sec>
    <sec id="Sec11">
      <title>Estimators of best fit</title>
      <p id="Par35">Least squares estimation (LSE) is a common method for finding the parameters which yield the minimal deviation between observed data and a model function. The standard LMA minimizes the general LSE formula given by equation (<xref rid="Equ1" ref-type="">1</xref>). However, it is also possible to include weighting factors in the calculation of chi-square, for example:<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }_{{\rm{LSE}}\,}^{2}(\mathop{a}\limits^{\rightharpoonup })\,=\,{\sum _{n=0}^{N-1}(\frac{{f}_{n}(\mathop{a}\limits^{\rightharpoonup })-{z}_{n}}{{\sigma }_{n}})}^{2}$$\end{document}</tex-math><mml:math id="M56" display="block"><mml:msubsup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">LSE</mml:mi><mml:mspace width="0.25em"/></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mspace width="-.25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mspace width=".25em"/><mml:mo>=</mml:mo><mml:mspace width=".25em"/><mml:msup><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mspace width=".25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mspace width="-.25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula>where <inline-formula id="IEq22"><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\sigma }_{n}$$\end{document}</tex-math><mml:math id="M58"><mml:msub><mml:mrow><mml:mi>σ</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq22.gif"/></alternatives></inline-formula> represents the uncertainty (standard deviation) of the data. This allows the precision of each data point to be taken into account.</p>
      <p id="Par36">In cases where the uncertainties of the data points are Poisson distributed, a maximum likelihood estimator (MLE) yields more precise parameter estimates than the LSE<sup><xref ref-type="bibr" rid="CR9">9</xref>,<xref ref-type="bibr" rid="CR10">10</xref></sup>. In this situation it is beneficial to use an alternative estimator with the LMA. A procedure has been described<sup><xref ref-type="bibr" rid="CR6">6</xref></sup> in which the LSE formula (<xref rid="Equ1" ref-type="">1</xref>) is replaced by the MLE equation for Poisson deviates, as follows:<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }_{{\rm{M}}{\rm{L}}{\rm{E}}\,}^{2}(\mathop{a}\limits^{\rightharpoonup })\,=\,2[\sum _{n=0}^{N-1}({f}_{n}(\mathop{a}\limits^{\rightharpoonup })-{z}_{n})\,-\,\sum _{n=0,\,{z}_{n}\ne 0}^{N-1}{z}_{n}\,{\rm{l}}{\rm{n}}(\frac{{f}_{n}(\mathop{a}\limits^{\rightharpoonup })}{{z}_{n}})].$$\end{document}</tex-math><mml:math id="M60" display="block"><mml:msubsup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mi mathvariant="normal">E</mml:mi></mml:mrow></mml:mrow><mml:mspace width="thinmathspace"/></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mrow class="MJX-TeXAtom-OP"><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">⇀</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>=</mml:mo><mml:mspace width="thinmathspace"/><mml:mn>2</mml:mn><mml:mo stretchy="true">[</mml:mo><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mrow class="MJX-TeXAtom-OP"><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">⇀</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="thinmathspace"/><mml:mo>−</mml:mo><mml:mspace width="thinmathspace"/><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mspace width="thinmathspace"/><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>≠</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mspace width="thinmathspace"/><mml:mrow><mml:mi mathvariant="normal">l</mml:mi><mml:mi mathvariant="normal">n</mml:mi></mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mrow class="MJX-TeXAtom-OP"><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">⇀</mml:mo></mml:mrow></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mfrac><mml:mo stretchy="true">)</mml:mo><mml:mo stretchy="true">]</mml:mo><mml:mo>.</mml:mo></mml:math><graphic xlink:href="41598_2017_15313_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p id="Par37">Using this estimator within the context of the LMA is relatively simple to implement, requiring only the calculation of the gradient and Hessian matrix of <inline-formula id="IEq23"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }_{{\rm{MLE}}\,}^{2}(\mathop{a}\limits^{\rightharpoonup })$$\end{document}</tex-math><mml:math id="M62"><mml:msubsup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">MLE</mml:mi><mml:mspace width="0.25em"/></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mspace width="-.25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq23.gif"/></alternatives></inline-formula>, and the calculation of <inline-formula id="IEq24"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\chi }_{{\rm{MLE}}\,}^{2}(\mathop{a}\limits^{\rightharpoonup })$$\end{document}</tex-math><mml:math id="M64"><mml:msubsup><mml:mrow><mml:mi>χ</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">MLE</mml:mi><mml:mspace width="0.25em"/></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mspace width="-.25em"/><mml:mrow><mml:mo stretchy="true">(</mml:mo><mml:mover accent="true"><mml:mi>a</mml:mi><mml:mo>⇀</mml:mo></mml:mover><mml:mo stretchy="true">)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41598_2017_15313_Article_IEq24.gif"/></alternatives></inline-formula> itself. As before, in the calculation of the Hessian matrix, terms containing second partial derivatives are ignored.</p>
    </sec>
    <sec id="Sec12">
      <title>Gauss-Jordan elimination</title>
      <p id="Par38">Gauss-Jordan elimination was used to solve the system of equations (<xref rid="Equ4" ref-type="">4</xref>) in the LMA, and a parallelized Gauss-Jordan algorithm was developed for this purpose. The algorithm was parallelized according to the elements of the augmented matrix, with each thread responsible for one element of the matrix as the left side is transformed to reduced row echelon form. Partial pivoting (row swapping) was used to ensure precise and numerically stable calculations<sup><xref ref-type="bibr" rid="CR3">3</xref></sup>. The sorting step in the pivot operation was accomplished on the GPU by means of a parallel bitonic merge sort<sup><xref ref-type="bibr" rid="CR19">19</xref></sup>. The details of this algorithm are fully documented in the Gpufit source code.</p>
    </sec>
    <sec id="Sec13">
      <title>Software for comparison tests</title>
      <p id="Par39">To evaluate its performance, Gpufit was compared against an equivalent CPU-based algorithm (Cpufit) and two other curve fitting libraries: MINPACK<sup><xref ref-type="bibr" rid="CR7">7</xref></sup> and GPU-LMFit<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>. Cpufit is a standard implementation of the LMA based on published examples<sup><xref ref-type="bibr" rid="CR1">1</xref>,<xref ref-type="bibr" rid="CR3">3</xref></sup>, which we wrote in C++ for execution on the CPU. C++ Minpack is an open-source C/C++ implementation of MINPACK which runs on the CPU (we used the function lmder() from this library)<sup><xref ref-type="bibr" rid="CR7">7</xref>,<xref ref-type="bibr" rid="CR20">20</xref></sup>. Both C++ Minpack and Cpufit were run in single CPU threads. GPU-LMFit is a closed-source implementation of the LMA (32-bit binary files are publicly available) which runs on the GPU and provides the option of using LSE or MLE as the estimator<sup><xref ref-type="bibr" rid="CR8">8</xref></sup>.</p>
    </sec>
    <sec id="Sec14">
      <title>Computer hardware</title>
      <p id="Par40">All tests were executed on a PC running the Windows 7 64-bit operating system and CUDA toolkit version 8.0. The PC hardware included an Intel Core i7 5820 K CPU, running at 3.3 GHz, and 64 GB of RAM. The graphics card was an NVIDIA GeForce GTX 1080 GPU with 8 GB of GDDR5X memory. All source codes, including the Cpufit, Gpufit, and C/C++ Minpack libraries, were compiled using Microsoft Visual Studio 2013, with compiler optimizations enabled (release mode). Additional details of the test conditions and instructions for compiling the Cpufit and Gpufit software libraries are provided in the Supplementary Information and the Gpufit documentation.</p>
    </sec>
    <sec id="Sec15">
      <title>Source code availability</title>
      <p id="Par41">The source code for Gpufit, including external bindings, is available for download from a public software repository located at <ext-link ext-link-type="uri" xlink:href="http://www.github.com/gpufit/Gpufit">http://www.github.com/gpufit/Gpufit</ext-link>. The source code for the CPU-based reference algorithm, Cpufit, is also included in this repository. The Gpufit User’s Manual, describing how to use the software and containing instructions for building and modifying the source code, may be found online at <ext-link ext-link-type="uri" xlink:href="http://gpufit.readthedocs.io">http://gpufit.readthedocs.io</ext-link>.</p>
    </sec>
    <sec id="Sec16">
      <title>Data availability</title>
      <p id="Par42">The datasets generated during and/or analyzed during the current study are available from the corresponding author on reasonable request.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Electronic supplementary material</title>
    <sec id="Sec17">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="41598_2017_15313_MOESM1_ESM.doc">
            <caption>
              <p>Supplementary Information</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Electronic supplementary material</bold>
      </p>
      <p><bold>Supplementary information</bold> accompanies this paper at 10.1038/s41598-017-15313-9.</p>
    </fn>
    <fn>
      <p><bold>Publisher's note:</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <ack>
    <title>Acknowledgements</title>
    <p>We would like to thank Dr. C. Wurm and Dr. E. Rothermel for the preparation of the sample used for STORM imaging, and also Dr. V. Cordes for providing the primary antibody against GP210. We thank N. Warmbold for contributions to an early version of the Gauss-Jordan algorithm used in the Gpufit source code. We thank Dr. M. Roose for excellent IT support. We thank Prof. Dr. S. W. Hell for generous support in the form of funding and equipment. M.B. gratefully acknowledges funding from the European Molecular Biology Organization (ALTF 800–2010) and the Max Planck Society.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Author Contributions</title>
    <p>M.B., B.T., and B.S. conceived the project. A.P., B.T., J.K., and M.B. wrote the Cpufit and Gpufit source code. A.P. and M.B. carried out the quantitative evaluation of Gpufit. M.B. performed the STORM experiment. A.P. and J.K. wrote the external bindings for Gpufit. J.K. created the usage examples. J.K., A.P., M.B., and B.T. wrote the documentation. M.B., B.T., and B.S. supervised the research. M.B. wrote the manuscript.</p>
  </notes>
  <notes notes-type="COI-statement">
    <sec id="FPar1">
      <title>Competing Interests</title>
      <p id="Par43">The authors declare that they have no competing interests.</p>
    </sec>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marquardt</surname>
            <given-names>DW</given-names>
          </name>
        </person-group>
        <article-title>An Algorithm for Least-Squares Estimation of Nonlinear Parameters</article-title>
        <source>J. Soc. Ind. Appl. Math</source>
        <year>1963</year>
        <volume>11</volume>
        <fpage>431</fpage>
        <lpage>441</lpage>
        <pub-id pub-id-type="doi">10.1137/0111030</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">Moré, J. J. in <italic>Numerica</italic><italic>l</italic><italic>An</italic><italic>al</italic><italic>ysis</italic> Vol. 630 <italic>Lecture Notes in Mathematics</italic> (ed G. A. Watson) 105–116 (Springer Berlin, 1978).</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">Press, W. H., Teukolsky, S. A., Vetterling, W. T. &amp; Flannery, B. P. <italic>Numerical Recipes in FORTRAN; The Art of Scientific Computing</italic>. (Cambridge University Press, 1993).</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Du</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>From CUDA to OpenCL: Towards a performance-portable solution for multi-platform GPU programming</article-title>
        <source>Parallel Comput.</source>
        <year>2012</year>
        <volume>38</volume>
        <fpage>391</fpage>
        <lpage>407</lpage>
        <pub-id pub-id-type="doi">10.1016/j.parco.2011.10.002</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <mixed-citation publication-type="other">Dongarra, J. <italic>et al</italic>. in <italic>Numerical Computations with</italic><italic> GPUs</italic> (ed V. Kindratenko) 3–28 (Springer International Publishing, 2014).</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Laurence</surname>
            <given-names>TA</given-names>
          </name>
          <name>
            <surname>Chromy</surname>
            <given-names>BA</given-names>
          </name>
        </person-group>
        <article-title>Efficient maximum likelihood estimator fitting of histograms</article-title>
        <source>Nat. Methods</source>
        <year>2010</year>
        <volume>7</volume>
        <fpage>338</fpage>
        <lpage>339</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth0510-338</pub-id>
        <?supplied-pmid 20431544?>
        <pub-id pub-id-type="pmid">20431544</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <mixed-citation publication-type="other">Moré, J. J., Garbow, B. S. &amp; Hillstrom, K. E. User Guide for MINPACK-1. (Argonne National Laboratory, 1980).</mixed-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhu</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Zhang</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Efficient Parallel Levenberg-Marquardt Model Fitting towards Real-Time Automated Parametric Imaging Microscopy</article-title>
        <source>PLoS One</source>
        <year>2013</year>
        <volume>8</volume>
        <fpage>e76665</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pone.0076665</pub-id>
        <?supplied-pmid 24130785?>
        <pub-id pub-id-type="pmid">24130785</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abraham</surname>
            <given-names>AV</given-names>
          </name>
          <name>
            <surname>Ram</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chao</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Ward</surname>
            <given-names>ES</given-names>
          </name>
          <name>
            <surname>Ober</surname>
            <given-names>RJ</given-names>
          </name>
        </person-group>
        <article-title>Quantitative study of single molecule location estimation techniques</article-title>
        <source>Opt. Express</source>
        <year>2009</year>
        <volume>17</volume>
        <fpage>23352</fpage>
        <lpage>23373</lpage>
        <pub-id pub-id-type="doi">10.1364/OE.17.023352</pub-id>
        <?supplied-pmid 20052043?>
        <pub-id pub-id-type="pmid">20052043</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>CS</given-names>
          </name>
          <name>
            <surname>Joseph</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Rieger</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Lidke</surname>
            <given-names>KA</given-names>
          </name>
        </person-group>
        <article-title>Fast, single-molecule localization that achieves theoretically minimum uncertainty</article-title>
        <source>Nat. Methods</source>
        <year>2010</year>
        <volume>7</volume>
        <fpage>373</fpage>
        <lpage>375</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.1449</pub-id>
        <?supplied-pmid 20364146?>
        <pub-id pub-id-type="pmid">20364146</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bates</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Huang</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Zhuang</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Super-resolution microscopy by nanoscale localization of photo-switchable fluorescent probes</article-title>
        <source>Curr. Opin. Chem. Biol.</source>
        <year>2008</year>
        <volume>12</volume>
        <fpage>505</fpage>
        <lpage>514</lpage>
        <pub-id pub-id-type="doi">10.1016/j.cbpa.2008.08.008</pub-id>
        <?supplied-pmid 18809508?>
        <pub-id pub-id-type="pmid">18809508</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schnitzbauer</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Strauss</surname>
            <given-names>MT</given-names>
          </name>
          <name>
            <surname>Schlichthaerle</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Schueder</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Jungmann</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Super-resolution microscopy with DNA-PAINT</article-title>
        <source>Nat. Protocols</source>
        <year>2017</year>
        <volume>12</volume>
        <fpage>1198</fpage>
        <lpage>1228</lpage>
        <pub-id pub-id-type="doi">10.1038/nprot.2017.024</pub-id>
        <?supplied-pmid 28518172?>
        <pub-id pub-id-type="pmid">28518172</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Legant</surname>
            <given-names>WR</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>High-density three-dimensional localization microscopy across large volumes</article-title>
        <source>Nat. Methods</source>
        <year>2016</year>
        <volume>13</volume>
        <fpage>359</fpage>
        <lpage>365</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.3797</pub-id>
        <?supplied-pmid 26950745?>
        <pub-id pub-id-type="pmid">26950745</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Babcock</surname>
            <given-names>HP</given-names>
          </name>
          <name>
            <surname>Zhuang</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Analyzing Single Molecule Localization Microscopy Data Using Cubic Splines</article-title>
        <source>Sci. Rep.</source>
        <year>2017</year>
        <volume>7</volume>
        <fpage>552</fpage>
        <pub-id pub-id-type="doi">10.1038/s41598-017-00622-w</pub-id>
        <?supplied-pmid 28373678?>
        <pub-id pub-id-type="pmid">28373678</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">Balzarotti, F. <italic>et al</italic>. Nanometer resolution imaging and tracking of fluorescent molecules with minimal photon fluxes. <italic>Science</italic> (2016).</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huang</surname>
            <given-names>F</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Video-rate nanoscopy using sCMOS camera-specific single-molecule localization algorithms</article-title>
        <source>Nat. Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <fpage>653</fpage>
        <lpage>658</lpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.2488</pub-id>
        <?supplied-pmid 23708387?>
        <pub-id pub-id-type="pmid">23708387</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Urban</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Sliz</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>A Quick Guide to Software Licensing for the Scientist-Programmer</article-title>
        <source>PLoS Comp. Biol.</source>
        <year>2012</year>
        <volume>8</volume>
        <fpage>e1002598</fpage>
        <pub-id pub-id-type="doi">10.1371/journal.pcbi.1002598</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <mixed-citation publication-type="other">Jones, C. <italic>The Technical and Social History of Software Engineering</italic>. (Pearson Education, 2013).</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <mixed-citation publication-type="other">Buck, I. &amp; Purcell, T. in <italic>GPU Gems</italic> Vol. 1 (ed R. Fernando) 621–636 (Addison Wesley, 2004).</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <mixed-citation publication-type="other">Devernay, F. <italic>C/C</italic>++ <italic>Minpack</italic>, <ext-link ext-link-type="uri" xlink:href="http://devernay.free.fr/hacks/cminpack/">http://devernay.free.fr/hacks/cminpack/</ext-link> (2007).</mixed-citation>
    </ref>
  </ref-list>
</back>
