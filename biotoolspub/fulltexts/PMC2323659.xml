<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id>
    <journal-title>BMC Bioinformatics</journal-title>
    <issn pub-type="epub">1471-2105</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2323659</article-id>
    <article-id pub-id-type="publisher-id">1471-2105-9-S2-S10</article-id>
    <article-id pub-id-type="pmid">18387198</article-id>
    <article-id pub-id-type="doi">10.1186/1471-2105-9-S2-S10</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment</article-title>
    </title-group>
    <contrib-group>
      <contrib id="A1" corresp="yes" contrib-type="author">
        <name>
          <surname>Manavski</surname>
          <given-names>Svetlin A</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <xref ref-type="aff" rid="I2">2</xref>
        <email>svetlin.manavski@cribi.unipd.it</email>
      </contrib>
      <contrib id="A2" contrib-type="author">
        <name>
          <surname>Valle</surname>
          <given-names>Giorgio</given-names>
        </name>
        <xref ref-type="aff" rid="I1">1</xref>
        <email>giorgio.valle@unipd.it</email>
      </contrib>
    </contrib-group>
    <aff id="I1"><label>1</label>CRIBI, University of Padova, Padova, Italy</aff>
    <aff id="I2"><label>2</label>Elaide, Srl, Padova, Italy</aff>
    <pub-date pub-type="collection">
      <year>2008</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>26</day>
      <month>3</month>
      <year>2008</year>
    </pub-date>
    <volume>9</volume>
    <issue>Suppl 2</issue>
    <supplement>
      <named-content content-type="supplement-title">Italian Society of Bioinformatics (BITS): Annual Meeting 2007</named-content>
      <named-content content-type="supplement-editor">Graziano Pesole</named-content>
    </supplement>
    <fpage>S10</fpage>
    <lpage>S10</lpage>
    <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/9/S2/S10"/>
    <permissions>
      <copyright-statement>Copyright © 2008 Manavski and Valle; licensee BioMed Central Ltd.</copyright-statement>
      <copyright-year>2008</copyright-year>
      <copyright-holder>Manavski and Valle; licensee BioMed Central Ltd.</copyright-holder>
      <license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0">
        <p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p>
        <!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Manavski
               A
               Svetlin
               
               
               svetlin.manavski@cribi.unipd.it
            </dc:author><dc:title>
            CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment
         </dc:title><dc:date>2008</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 9(Suppl 2): S10-. (2008)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2008)9:Suppl 2&#x0003c;S10&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>-->
      </license>
    </permissions>
    <abstract>
      <sec>
        <title>Background</title>
        <p>Searching for similarities in protein and DNA databases has become a routine procedure in Molecular Biology. The Smith-Waterman algorithm has been available for more than 25 years. It is based on a dynamic programming approach that explores all the possible alignments between two sequences; as a result it returns the optimal local alignment. Unfortunately, the computational cost is very high, requiring a number of operations proportional to the product of the length of two sequences. Furthermore, the exponential growth of protein and DNA databases makes the Smith-Waterman algorithm unrealistic for searching similarities in large sets of sequences. For these reasons heuristic approaches such as those implemented in FASTA and BLAST tend to be preferred, allowing faster execution times at the cost of reduced sensitivity. The main motivation of our work is to exploit the huge computational power of commonly available graphic cards, to develop high performance solutions for sequence alignment.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>In this paper we present what we believe is the fastest solution of the exact Smith-Waterman algorithm running on commodity hardware. It is implemented in the recently released CUDA programming environment by NVidia. CUDA allows direct access to the hardware primitives of the last-generation Graphics Processing Units (GPU) G80. Speeds of more than 3.5 GCUPS (Giga Cell Updates Per Second) are achieved on a workstation running two GeForce 8800 GTX. Exhaustive tests have been done to compare our implementation to SSEARCH and BLAST, running on a 3 GHz Intel Pentium IV processor. Our solution was also compared to a recently published GPU implementation and to a Single Instruction Multiple Data (SIMD) solution. These tests show that our implementation performs from 2 to 30 times faster than any other previous attempt available on commodity hardware.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>The results show that graphic cards are now sufficiently advanced to be used as efficient hardware accelerators for sequence alignment. Their performance is better than any alternative available on commodity hardware platforms. The solution presented in this paper allows large scale alignments to be performed at low cost, using the exact Smith-Waterman algorithm instead of the largely adopted heuristic approaches.</p>
      </sec>
    </abstract>
    <conference>
      <conf-date>26–28 April 2007</conf-date>
      <conf-name>Italian Society of Bioinformatics (BITS): Annual Meeting 2007</conf-name>
      <conf-loc>Naples, Italy</conf-loc>
    </conference>
  </article-meta>
</front>
<body>
  <sec>
    <title>Background</title>
    <sec>
      <title>Related works</title>
      <p>Searching databases of DNA and protein sequences is one of the fundamental tasks in bioinformatics. The Smith-Waterman algorithm guarantees the maximal sensitivity for local sequence alignments, but it is slow. It should be further considered that biological databases are growing at a very fast exponential rate, which is greater than the rate of improvement of microprocessors. This trend results in longer time and/or more expensive hardware to manage the problem. Special-purpose hardware implementations, as for instance super-computers or field-programmable gate arrays (FPGAs) are certainly interesting options, but they tend to be very expensive and not suitable for many users.</p>
      <p>For the above reasons, many widespread solutions running on common microprocessors now use some heuristic approaches to reduce the computational cost of sequence alignment. Thus a reduced execution time is reached at the expense of sensitivity. FASTA (Pearson and Lipman, 1988) [<xref ref-type="bibr" rid="B1">1</xref>] and BLAST (Altschul et al., 1997) [<xref ref-type="bibr" rid="B2">2</xref>] are up to 40 times faster than the best known straight forward CPU implementation of Smith-Waterman.</p>
      <p>A number of efforts have also been made to obtain faster implementations of the Smith-Waterman algorithm on commodity hardware. Farrar [<xref ref-type="bibr" rid="B3">3</xref>] exploits Intel SSE2, which is the multimedia extension of the CPU. Its implementation is up to 13 times faster than SSEARCH [<xref ref-type="bibr" rid="B14">14</xref>] (a quasi-standard implementation of Smith-Waterman).</p>
      <p>To our knowledge, the only previous attempt to implement Smith-Waterman on a GPU was done by W. Liu et al. (2006) [<xref ref-type="bibr" rid="B4">4</xref>]. Their solution relies on OpenGL that has some intrinsic limits as it is based on the graphics pipeline. Thus, a conversion of the problem to the graphical domain is needed, as well as a reverse procedure to convert back the results. Although that approach is up to 5 times faster than SSEARCH, it is considerably slower than BLAST.</p>
      <p>In this paper we present the first solution based on commodity hardware that efficiently computes the exact Smith-Waterman alignment. It runs from 2 to 30 times faster than any previous implementation on general-purpose hardware.</p>
    </sec>
    <sec>
      <title>The Smith-Waterman algorithm</title>
      <p>The Smith-Waterman algorithm is designed to find the optimal local alignment between two sequences. It was proposed by Smith and Waterman (1981) [<xref ref-type="bibr" rid="B5">5</xref>] and enhanced by Gotoh (1982) [<xref ref-type="bibr" rid="B6">6</xref>]. The alignment of two sequences is based on the computation of an alignment matrix. The number of its columns and rows is given by the number of the residues in the query and database sequences respectively. The computation is based on a substitution matrix and on a gap-penalty function.</p>
      <p>Definitions:</p>
      <p>• <italic>A: a<sub>1</sub>a<sub>2</sub>a<sub>3</sub>….a<sub>n</sub></italic> is the first sequence,</p>
      <p>• <italic>B: b<sub>1</sub>b<sub>2</sub>b<sub>3</sub>….b<sub>m</sub></italic> is the second sequence,</p>
      <p>• <italic>W(a<sub>i</sub>, b<sub>j</sub>)</italic> is the substitution matrix,</p>
      <p>• <italic>G<sub>init</sub></italic> and <italic>G<sub>ext</sub></italic> are the penalties for starting and continuing a gap,</p>
      <p>the alignment scores ending with a gap along A and B are</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1" name="1471-2105-9-S2-S10-i1" overflow="scroll">
            <mml:semantics>
              <mml:mtable columnalign="left">
                <mml:mtr>
                  <mml:mtd>
                    <mml:msub>
                      <mml:mi>E</mml:mi>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mi>m</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>x</mml:mi>
                    <mml:mrow>
                      <mml:mo>{</mml:mo>
                      <mml:mtable columnalign="left">
                        <mml:mtr>
                          <mml:mtd>
                            <mml:msub>
                              <mml:mi>E</mml:mi>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>−</mml:mo>
                            <mml:msub>
                              <mml:mi>G</mml:mi>
                              <mml:mrow>
                                <mml:mi>e</mml:mi>
                                <mml:mi>x</mml:mi>
                                <mml:mi>t</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:msub>
                              <mml:mi>H</mml:mi>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mo>,</mml:mo>
                                <mml:mi>j</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>−</mml:mo>
                            <mml:msub>
                              <mml:mi>G</mml:mi>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mi>n</mml:mi>
                                <mml:mi>i</mml:mi>
                                <mml:mi>t</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                      <mml:mo>}</mml:mo>
                    </mml:mrow>
                  </mml:mtd>
                </mml:mtr>
                <mml:mtr>
                  <mml:mtd>
                    <mml:msub>
                      <mml:mi>F</mml:mi>
                      <mml:mrow>
                        <mml:mi>i</mml:mi>
                        <mml:mo>,</mml:mo>
                        <mml:mi>j</mml:mi>
                      </mml:mrow>
                    </mml:msub>
                    <mml:mo>=</mml:mo>
                    <mml:mi>m</mml:mi>
                    <mml:mi>a</mml:mi>
                    <mml:mi>x</mml:mi>
                    <mml:mrow>
                      <mml:mo>{</mml:mo>
                      <mml:mtable columnalign="left">
                        <mml:mtr>
                          <mml:mtd>
                            <mml:msub>
                              <mml:mi>F</mml:mi>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo>,</mml:mo>
                                <mml:mi>j</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>−</mml:mo>
                            <mml:msub>
                              <mml:mi>G</mml:mi>
                              <mml:mrow>
                                <mml:mi>e</mml:mi>
                                <mml:mi>x</mml:mi>
                                <mml:mi>t</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mtd>
                        </mml:mtr>
                        <mml:mtr>
                          <mml:mtd>
                            <mml:msub>
                              <mml:mi>H</mml:mi>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mo>−</mml:mo>
                                <mml:mn>1</mml:mn>
                                <mml:mo>,</mml:mo>
                                <mml:mi>j</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                            <mml:mo>−</mml:mo>
                            <mml:msub>
                              <mml:mi>G</mml:mi>
                              <mml:mrow>
                                <mml:mi>i</mml:mi>
                                <mml:mi>n</mml:mi>
                                <mml:mi>i</mml:mi>
                                <mml:mi>t</mml:mi>
                              </mml:mrow>
                            </mml:msub>
                          </mml:mtd>
                        </mml:mtr>
                      </mml:mtable>
                      <mml:mo>}</mml:mo>
                    </mml:mrow>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>Finally the alignment scores of the sub-sequences <italic>A<sub>i</sub></italic>, <italic>B<sub>j</sub></italic> are:</p>
      <p>
        <disp-formula>
          <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2" name="1471-2105-9-S2-S10-i2" overflow="scroll">
            <mml:semantics>
              <mml:mrow>
                <mml:msub>
                  <mml:mi>H</mml:mi>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>=</mml:mo>
                <mml:mtext> </mml:mtext>
                <mml:mtext> </mml:mtext>
                <mml:mi>m</mml:mi>
                <mml:mi>a</mml:mi>
                <mml:mi>x</mml:mi>
                <mml:mtext> </mml:mtext>
                <mml:mtext> </mml:mtext>
                <mml:mrow>
                  <mml:mo>{</mml:mo>
                  <mml:mtable columnalign="left">
                    <mml:mtr>
                      <mml:mtd>
                        <mml:mn>0</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msub>
                          <mml:mi>E</mml:mi>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msub>
                          <mml:mi>F</mml:mi>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                          </mml:mrow>
                        </mml:msub>
                      </mml:mtd>
                    </mml:mtr>
                    <mml:mtr>
                      <mml:mtd>
                        <mml:msub>
                          <mml:mi>H</mml:mi>
                          <mml:mrow>
                            <mml:mi>i</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>,</mml:mo>
                            <mml:mi>j</mml:mi>
                            <mml:mo>−</mml:mo>
                            <mml:mn>1</mml:mn>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>−</mml:mo>
                        <mml:mi>W</mml:mi>
                        <mml:mrow>
                          <mml:mo>(</mml:mo>
                          <mml:mrow>
                            <mml:msub>
                              <mml:mi>a</mml:mi>
                              <mml:mi>i</mml:mi>
                            </mml:msub>
                            <mml:mo>,</mml:mo>
                            <mml:msub>
                              <mml:mi>b</mml:mi>
                              <mml:mi>j</mml:mi>
                            </mml:msub>
                          </mml:mrow>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                  <mml:mo>}</mml:mo>
                </mml:mrow>
              </mml:mrow>
            </mml:semantics>
          </mml:math>
        </disp-formula>
      </p>
      <p>where 1≤<italic>i</italic>≤<italic>n</italic> and 1≤<italic>j</italic>≤<italic>m</italic>. The values for E, F and H are 0 when <italic>i</italic>&lt;1 and <italic>j</italic>&lt;1. The maximum value of the alignment matrix gives the degree of similarity between <italic>A</italic> and <italic>B</italic>.</p>
      <p>An important point to be considered is that any cell of the alignment matrix can be computed only after the values of the left and above cells are known, as shown in Figure <xref ref-type="fig" rid="F1">1</xref>. Different cells can be simultaneously processed only if they are on the same anti-diagonal.</p>
      <fig position="float" id="F1">
        <label>Figure 1</label>
        <caption>
          <p><bold>Smith-Waterman data dependencies.</bold> Each cell of the alignment matrix depends on the cells on the left and above it. Independent data can be found only on the same anti-diagonal.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-1"/>
      </fig>
    </sec>
    <sec>
      <title>CUDA programming model</title>
      <p>The two major GPU vendors, NVidia and AMD, recently announced their new developing platforms, respectively CUDA [<xref ref-type="bibr" rid="B7">7</xref>] and CTM [<xref ref-type="bibr" rid="B8">8</xref>]. Unlike previous GPU programming models, these are proprietary approaches designed to allow a direct access to their specific graphics hardware. Therefore, there is no compatibility between the two platforms. CUDA is an extension of the C programming language; CTM is a virtual machine running proprietary assembler code. However, both platforms overcome some important restrictions on previous GPGPU approaches, in particular those set by the traditional graphics pipeline and the relative programming interfaces like OpenGL and Direct3D.</p>
      <p>We selected NVidia GeForce 8800 and its CUDA platform to design our Smith-Waterman implementation because it is the first available GPU on the market capable of an internal integer representation of data.</p>
      <p>In CUDA, the GPU is viewed as a compute device suitable for parallel data applications. It has its own device random access memory and may run a very high number of threads in parallel (Figure <xref ref-type="fig" rid="F2">2</xref>). Threads are grouped in <italic>blocks</italic> and many <italic>blocks</italic> may run in a <italic>grid</italic> of <italic>blocks</italic>. Such structured sets of threads may be launched on a <italic>kernel</italic> of code, processesing the data stored in the device memory. Threads of the same <italic>block</italic> share data through fast shared on-chip memory and can be synchronized through synchronization points. An important aspect of CUDA programming is the management of the memory spaces that have different characteristics and performances:</p>
      <fig position="float" id="F2">
        <label>Figure 2</label>
        <caption>
          <p><bold>CUDA architecture.</bold> New CUDA compatible GPUs are implemented as a set of multiprocessors. Each multiprocessor has several ALUs (Arithmetic Logic Unit) that, at any given clock cycle, execute the same instructions but on different data. Each ALU can access (read and write) the multiprocessor <italic>shared memory</italic> and the device RAM.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-2"/>
      </fig>
      <p>• Read-write per-thread <italic>registers</italic> (fast, very limited size)</p>
      <p>• Read-write per-thread <italic>local memory</italic> (slow, not cached, limited size)</p>
      <p>• Read-write per-<italic>block shared memory</italic> (fast, very limited size)</p>
      <p>• Read-write per-<italic>grid global memory</italic> (slow, not cached, large size)</p>
      <p>• Read-only per-<italic>grid constant memory</italic> (slow but cached, limited size)</p>
      <p>• Read-only per-<italic>grid texture memory</italic> (slow but cached, large size)</p>
      <p>The proper choice of the memory to be used in each <italic>kernel</italic> depends on many factors such as the speed, the amount needed, and the operations to be performed on the stored data. An important restriction is the limited size of <italic>shared memory</italic>, which is the only available read-write cache. Unlike the CPU programming model, here the programmer needs to explicitly copy data from the <italic>global memory</italic> to the cache (<italic>shared memory</italic>) and backwards. But this new architecture allows the access to memory in a really general way, so both <italic>scatter</italic> and <italic>gather</italic> operations are available. <italic>Gather</italic> is the ability to read any memory cell during the run of the <italic>kernel</italic> code. <italic>Scatter</italic> is the ability to randomly access any memory cell for writing. The unavailability of <italic>scatter</italic> was one of the major limitations of OpenGL when applied to GPGPU applications. The main point in approaching CUDA is that the overall performance of the applications dramatically depends on the management of the memory, which is much more complex than in the CPUs.</p>
    </sec>
  </sec>
  <sec>
    <title>Results and discussion</title>
    <p>Exhaustive tests have been performed to compare the implementation of Smith-Waterman in CUDA with:</p>
    <p>• the results of W. Liu as reported in his paper [<xref ref-type="bibr" rid="B4">4</xref>]. His solution was implemented in OpenGL and was tested on a NVidia GeForce 7900 GPU</p>
    <p>• BLAST [<xref ref-type="bibr" rid="B1">1</xref>] and SSEARCH [<xref ref-type="bibr" rid="B14">14</xref>], running on a 3 GHz Intel Pentium IV processor</p>
    <p>• the results of the SIMD implementation by Farrar as reported in his paper [<xref ref-type="bibr" rid="B3">3</xref>]. His tests were run on a 2.4 GHz Xeon Core 2 Duo processor.</p>
    <p>We have tested our solution on a workstation, having the 2.4 GHz Intel Q6600 processor and two NVidia GeForce 8800 GTX graphic cards. We have measured the performance by running the application both on single and on double GPU configurations. By doubling the computing resources we observed that the overall performance of the application also doubles. This shows that the solution can benefit from a nearly linear speed improvement when adding more graphic boards to the system. It must be mentioned that the Nvidia SLI option, available for multi-GPU systems, is designed for OpenGL. Therefore, SLI must be disabled for CUDA, which requires direct programming of every installed GPU.</p>
    <sec>
      <title>Smith-Waterman in CUDA vs. Liu's implementation</title>
      <p>For this test five protein sequences of different length (from 63 to 511 residues) were run against the SwissProt database (Dec. 2006 – 250,296 proteins and 91,694,534 amino acids). The substitution matrix BLOSUM50 with a gap-open penalty of 10 and a gap-extension penalty of 2 were used. The resulting MCUPS for each of the 5 query sequences are shown in Table <xref ref-type="table" rid="T1">1</xref>.</p>
      <table-wrap position="float" id="T1">
        <label>Table 1</label>
        <caption>
          <p>Smith-Waterman in CUDA running on single and double GPU vs. Liu's solution implemented in OpenGL</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center" colspan="2">
                <bold>
                  <italic>Sequence</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>SW-Cuda*</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>SW-Cuda**</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Weiguo Liu</italic>
                </bold>
              </td>
            </tr>
            <tr>
              <td>
                <bold>
                  <italic>Name</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Length</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <italic>O29181</italic>
              </td>
              <td>63</td>
              <td>1849</td>
              <td>3561</td>
              <td>197</td>
            </tr>
            <tr>
              <td>
                <italic>P03630</italic>
              </td>
              <td>127</td>
              <td>1889</td>
              <td>3612</td>
              <td>317</td>
            </tr>
            <tr>
              <td>
                <italic>P53765</italic>
              </td>
              <td>255</td>
              <td>1811</td>
              <td>3428</td>
              <td>428</td>
            </tr>
            <tr>
              <td>
                <italic>Q8ZGB4</italic>
              </td>
              <td>361</td>
              <td>1810</td>
              <td>3446</td>
              <td>486</td>
            </tr>
            <tr>
              <td>
                <italic>P58229</italic>
              </td>
              <td>511</td>
              <td>1795</td>
              <td>3353</td>
              <td>533</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Substitution matrix used: BLOSUM50. Gap-open penalty: 10. Gap-extension penalty: 2.</p>
          <p>Database used: SwissProt (Dec. 2006 – 250,296 proteins and 91,694,534 amino acids).</p>
          <p>* Smith-Waterman in CUDA running on an NVidia GeForce 8800 GTX</p>
          <p>** Smith-Waterman in CUDA running on two NVidia GeForce 8800 GTX</p>
        </table-wrap-foot>
      </table-wrap>
      <p>Liu obtained on the same sequences an average of 392.2 MCUPS and a peak of 533 MCUPS. Our solution on a single GPU was completed in a time of 63.5 sec with an average of 1830 MCUPS and a peak of 1889 MCUPS. Our implementation on two GPUs achieved a search time of 33.63 sec with an average of 3480 MCUPS and a peak of 3612 MCUPS. These results indicate that our implementation of Smith-Waterman is up to 18 times faster than that of Liu.</p>
    </sec>
    <sec>
      <title>Smith-Waterman in CUDA vs. BLAST and SSEARCH</title>
      <p>For this test we used the same sequences, database and substitution matrix described in the previous paragraph. SSEARCH completed the search in 960 sec with an average of 119.2 MCUPS and a peak of 123 MCUPS. BLAST completed the search in 53.3 sec with an average of 2018 MCUPS and a peak of 2691 MCUPS.</p>
      <p>The execution times of our CUDA implementation were up to 30 times faster than SSEARCH and up to 2.4 times faster than BLAST, as shown in Figure <xref ref-type="fig" rid="F3">3</xref> and Table <xref ref-type="table" rid="T2">2</xref>.</p>
      <fig position="float" id="F3">
        <label>Figure 3</label>
        <caption>
          <p><bold>Smith-Waterman in CUDA running on single and double GPU vs. BLAST and SSEARCH.</bold> Substitution matrix used: BLOSUM50. Gap-open penalty: 10. Gap-extension penalty: 2.</p>
          <p>Database used: SwissProt (Dec. 2006 – 250,296 proteins and 91,694,534 amino acids).</p>
          <p>* Smith-Waterman in CUDA running on an NVidia GeForce 8800 GTX</p>
          <p>** Smith-Waterman in CUDA running on two NVidia GeForce 8800 GTX</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-3"/>
      </fig>
      <table-wrap position="float" id="T2">
        <label>Table 2</label>
        <caption>
          <p>Smith-Waterman in CUDA running on single and double GPU vs. BLAST and SSEARCH</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td colspan="2">
                <bold>
                  <italic>Sequence</italic>
                </bold>
              </td>
              <td colspan="2">
                <bold>
                  <italic>SW-Cuda*</italic>
                </bold>
              </td>
              <td colspan="2">
                <bold>
                  <italic>SW-Cuda**</italic>
                </bold>
              </td>
              <td colspan="2">
                <bold>
                  <italic>Ssearch(Fasta)</italic>
                </bold>
              </td>
              <td colspan="2">
                <bold>
                  <italic>Blast</italic>
                </bold>
              </td>
            </tr>
            <tr>
              <td>
                <bold>
                  <italic>Name</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Length</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <italic>O29181</italic>
              </td>
              <td>63</td>
              <td>2.98</td>
              <td>1849</td>
              <td>1.547</td>
              <td>3561</td>
              <td>46</td>
              <td>119</td>
              <td>3.7</td>
              <td>1488</td>
            </tr>
            <tr>
              <td>
                <italic>P03630</italic>
              </td>
              <td>127</td>
              <td>5.88</td>
              <td>1889</td>
              <td>3.075</td>
              <td>3612</td>
              <td>93</td>
              <td>119</td>
              <td>5.7</td>
              <td>1948</td>
            </tr>
            <tr>
              <td>
                <italic>P53765</italic>
              </td>
              <td>255</td>
              <td>12.31</td>
              <td>1811</td>
              <td>6.505</td>
              <td>3428</td>
              <td>184</td>
              <td>121</td>
              <td>11</td>
              <td>2027</td>
            </tr>
            <tr>
              <td>
                <italic>Q8ZGB4</italic>
              </td>
              <td>361</td>
              <td>17.44</td>
              <td>1810</td>
              <td>9.162</td>
              <td>3446</td>
              <td>275</td>
              <td>114</td>
              <td>16.3</td>
              <td>1936</td>
            </tr>
            <tr>
              <td>
                <italic>P58229</italic>
              </td>
              <td>511</td>
              <td>24.89</td>
              <td>1795</td>
              <td>13.326</td>
              <td>3353</td>
              <td>362</td>
              <td>123</td>
              <td>16.6</td>
              <td>2691</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Substitution matrix used: BLOSUM50. Gap-open penalty: 10. Gap-extension penalty: 2.</p>
          <p>Database used: SwissProt (Dec. 2006 – 250,296 proteins and 91,694,534 amino acids).</p>
          <p>* Smith-Waterman in CUDA running on an NVidia GeForce 8800 GTX</p>
          <p>** Smith-Waterman in CUDA running on two NVidia GeForce 8800 GTX</p>
        </table-wrap-foot>
      </table-wrap>
    </sec>
    <sec>
      <title>Smith-Waterman in CUDA vs. Farrar's implementation</title>
      <p>This last test was done running 11 sequences of different length (from 143 to 567 residues) against the SwissProt database (Rel. 49.1 – 208,005 proteins and 75,841,138 amino acids). The substitution matrix is the BLOSUM50 with a gap-open penalty of 10 and a gap-extension penalty of 2.</p>
      <p>The Farrar's approach is based on the following consideration: for most cells in the alignment matrix, F remains at zero and does not contribute to the value of H. Only when H is greater than <italic>G<sub>init</sub></italic> + <italic>G<sub>ext</sub></italic> will F start to influence the value of H. So firstly F is not considered. Then, if required, a second step tries to correct the introduced errors. Farrar's solution completed the search in 161 sec with an average of 1630 MCUPS and a peak of 2045 MCUPS. Our solution running on a single GPU turned in a slightly better time of 154.95 sec with an average of 1783.3 MCUPS and a peak of 1845 MCUPS. On two GPU devices the search was completed in 79.65 sec with an average of 3792.2 MCUPS and a peak of 3575 MCUPS. The search times and resulting MCUPS are shown in Figure <xref ref-type="fig" rid="F4">4</xref> and Table <xref ref-type="table" rid="T3">3</xref>.</p>
      <fig position="float" id="F4">
        <label>Figure 4</label>
        <caption>
          <p><bold>Smith-Waterman in CUDA running on single and double GPU vs. Farrar's solution</bold>. Substitution matrix used: BLOSUM50. Gap-open penalty: 10. Gap-extension penalty: 2.</p>
          <p>Database used: SwissProt (Rel. 49.1 – 208,005 proteins and 75,841,138 amino acids).</p>
          <p>* Smith-Waterman in CUDA running on an NVidia GeForce 8800 GTX</p>
          <p>** Smith-Waterman in CUDA running on two NVidia GeForce 8800 GTX</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-4"/>
      </fig>
      <table-wrap position="float" id="T3">
        <label>Table 3</label>
        <caption>
          <p>Smith-Waterman in CUDA running on single and double GPU vs. Farrar's solution</p>
        </caption>
        <table frame="hsides" rules="groups">
          <thead>
            <tr>
              <td align="center" colspan="2">
                <bold>
                  <italic>Sequence</italic>
                </bold>
              </td>
              <td align="center" colspan="2">
                <bold>
                  <italic>SW-Cuda*</italic>
                </bold>
              </td>
              <td align="center" colspan="2">
                <bold>
                  <italic>SW-Cuda**</italic>
                </bold>
              </td>
              <td align="center" colspan="2">
                <bold>
                  <italic>Farrar</italic>
                </bold>
              </td>
            </tr>
            <tr>
              <td>
                <bold>
                  <italic>Name</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Length</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>Time (s)</italic>
                </bold>
              </td>
              <td>
                <bold>
                  <italic>MCUPS</italic>
                </bold>
              </td>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <italic>P02232</italic>
              </td>
              <td>143</td>
              <td>5.59</td>
              <td>1845</td>
              <td>2.95</td>
              <td>3497</td>
              <td>9</td>
              <td>1149</td>
            </tr>
            <tr>
              <td>
                <italic>P01111</italic>
              </td>
              <td>189</td>
              <td>7.59</td>
              <td>1796</td>
              <td>3.84</td>
              <td>3551</td>
              <td>10</td>
              <td>1367</td>
            </tr>
            <tr>
              <td>
                <italic>P05013</italic>
              </td>
              <td>189</td>
              <td>7.59</td>
              <td>1796</td>
              <td>3.84</td>
              <td>3551</td>
              <td>10</td>
              <td>1367</td>
            </tr>
            <tr>
              <td>
                <italic>P14942</italic>
              </td>
              <td>222</td>
              <td>8.84</td>
              <td>1812</td>
              <td>4.48</td>
              <td>3575</td>
              <td>12</td>
              <td>1338</td>
            </tr>
            <tr>
              <td>
                <italic>P00762</italic>
              </td>
              <td>246</td>
              <td>9.85</td>
              <td>1802</td>
              <td>5.01</td>
              <td>3542</td>
              <td>13</td>
              <td>1369</td>
            </tr>
            <tr>
              <td>
                <italic>P10318</italic>
              </td>
              <td>362</td>
              <td>14.71</td>
              <td>1775</td>
              <td>7.57</td>
              <td>3450</td>
              <td>15</td>
              <td>1746</td>
            </tr>
            <tr>
              <td>
                <italic>P07327</italic>
              </td>
              <td>374</td>
              <td>15.28</td>
              <td>1766</td>
              <td>7.86</td>
              <td>3433</td>
              <td>16</td>
              <td>1691</td>
            </tr>
            <tr>
              <td>
                <italic>P01008</italic>
              </td>
              <td>464</td>
              <td>18.96</td>
              <td>1765</td>
              <td>9.83</td>
              <td>3405</td>
              <td>18</td>
              <td>1864</td>
            </tr>
            <tr>
              <td>
                <italic>P10635</italic>
              </td>
              <td>497</td>
              <td>20.39</td>
              <td>1758</td>
              <td>10.43</td>
              <td>3438</td>
              <td>19</td>
              <td>1892</td>
            </tr>
            <tr>
              <td>
                <italic>P25705</italic>
              </td>
              <td>553</td>
              <td>22.83</td>
              <td>1747</td>
              <td>11.88</td>
              <td>3358</td>
              <td>19</td>
              <td>2105</td>
            </tr>
            <tr>
              <td>
                <italic>P03435</italic>
              </td>
              <td>567</td>
              <td>23.32</td>
              <td>1754</td>
              <td>11.96</td>
              <td>3420</td>
              <td>20</td>
              <td>2045</td>
            </tr>
          </tbody>
        </table>
        <table-wrap-foot>
          <p>Substitution matrix used: BLOSUM50. Gap-open penalty: 10. Gap-extension penalty: 2.</p>
          <p>Database used: SwissProt (Rel. 49.1 – 208,005 proteins and 75,841,138 amino acids).</p>
          <p>* Smith-Waterman in CUDA running on an NVidia GeForce 8800 GTX</p>
          <p>** Smith-Waterman in CUDA running on two NVidia GeForce 8800 GTX</p>
        </table-wrap-foot>
      </table-wrap>
      <p>Farrar's solution improves its performances on the longer sequences, but on the average, it takes longer than our solution running even on a single GPU. So Smith-Waterman in CUDA is up to 3 times faster than Farrar's implementation.</p>
    </sec>
  </sec>
  <sec>
    <title>Conclusions</title>
    <p>Up to now the huge computational power of the GPUs was hampered by the limited programming model of OpenGL which is unsuitable for efficient general-purpose computing.</p>
    <p>The results of this work show that the new CUDA compatible graphic cards are now advanced enough to be considered as efficient hardware accelerators for the Smith-Waterman algorithm. High speed can be obtained with the greatest sensitivity. But this work also opens interesting perspectives as similar strategies of acceleration could be applied to a number widely used algorithms in bioinformatics. Thus equal investments in terms of hardware may lead to much better performances. Future work of our team is planned in the direction of accelerating BLAST.</p>
    <p>The source files of our Smith-Waterman implementation are available at <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.cribi.unipd.it/cuda/"/>.</p>
  </sec>
  <sec sec-type="methods">
    <title>Methods</title>
    <sec>
      <title>Query-profile</title>
      <p>When calculating <italic>H<sub>ij</sub></italic> the value from the substitution matrix <italic>W(q<sub>i</sub>, d<sub>j</sub>)</italic> is added to <italic>H<sub>i−1</sub></italic>, <italic><sub>j−1</sub></italic>. As suggested by Rognes and Seeberg [<xref ref-type="bibr" rid="B9">9</xref>], to avoid the lookup of <italic>W(q<sub>i</sub>, d<sub>j</sub>)</italic> in the internal cycle of the algorithm, we pre-compute a query profile parallel to the query sequence for each possible residue.</p>
      <p>The query profile, shown in Figure <xref ref-type="fig" rid="F5">5</xref>, can be considered as a query-specific substitution matrix computed only once for the entire database. The score for matching symbol A (for alanine) in the database sequence with each of the symbols in the query sequence is stored sequentially in the first matrix row. The scores for matching symbol B are stored in the next row, and so on.</p>
      <fig position="float" id="F5">
        <label>Figure 5</label>
        <caption>
          <p><bold>Query-profile.</bold> Example of query profile for the protein 029181. For each amino acid, a profile row is filled with the scores obtained matching that amino acid with the query residues, based on the given substitution matrix.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-5"/>
      </fig>
      <p>In this way we replace random accesses to the substitution matrix with sequential ones to the query profile. This solution exploits the cache of the GPU <italic>texture memory</italic> space where the query profile is stored.</p>
    </sec>
    <sec>
      <title>Smith-Waterman in CUDA</title>
      <p>A great number of parallel threads have to be launched simultaneously to fully exploit the huge computational power of the GPU. The strategy adopted in our implementation in CUDA was to make each GPU thread compute the whole alignment of the query sequence with one database sequence. As explained in the section about the CUDA programming model, the threads are grouped in a <italic>grid</italic> of <italic>blocks</italic> when running on the graphics card. In order to make the most efficient use of the GPU resources the computing time of all the threads in the same <italic>grid</italic> must be as near as possible. For this reason we found it was important to pre-order the sequences of the database in function of their length. So when running, the adjacent threads will need to align the query sequence with two database queries having the nearest possible sizes.</p>
      <p>Following is the optimal configuration of threads allowing for the best performance:</p>
      <p>• number of threads per <italic>block</italic>: 64</p>
      <p>• number of <italic>blocks</italic>: 450</p>
      <p>• total number of threads per <italic>grid</italic>: 28800</p>
      <p>The ordered database is stored in the <italic>global</italic> GPU memory, while the query-profile is saved into a <italic>texture</italic>. For each alignment the matrix is computed column by column in order parallel to the query sequence. To compute a column we need all the H and E values from the previous one. We store them in the <italic>local memory</italic> of the thread. More precisely, we use two buffers: one for the previous values and one for the newly computed ones. At the end of each column we swap them and so on. <italic>Local memory</italic> is not cached, so it is very important to choose the right access pattern to this space. The GPU is able to read and write up to 128 bits of the <italic>local memory</italic> with a single instruction. So each thread reads at once four H and four E values (16 bits long) from the loading buffer plus the respective four values from the profile. It computes the four results for the new column, then it stores them in the storing buffer. To fully take advantage of the memory bandwidth of the graphics card we package the profile in the <italic>texture</italic>, saving four successive values (always minor than 255) into the four bytes of a single unsigned integer. Thus, each thread can gather all the data needed to compute four cells of the alignment matrix with only two read instructions (one from the local buffer and one from the <italic>texture</italic>).</p>
      <p>Figure <xref ref-type="fig" rid="F6">6</xref> has the pseudo code of the <italic>kernel</italic> executed by each thread, while Figure <xref ref-type="fig" rid="F7">7</xref> shows the interactions between the <italic>local memory</italic> buffers and the query-profile to compute the alignment matrix.</p>
      <fig position="float" id="F6">
        <label>Figure 6</label>
        <caption>
          <p><bold><italic>Kernel</italic> pseudo code</bold>. Each thread executes this code on a different database sequence. The pseudo-code for the Smith-Waterman implementation is made up of the outer loop, which cycles on the database sequence characters, followed by the inner loop, which does the basic dynamic programming calculations.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-6"/>
      </fig>
      <fig position="float" id="F7">
        <label>Figure 7</label>
        <caption>
          <p><bold>Smith-Waterman in CUDA functioning.</bold> Each thread gathers four E and H values from the load buffer (first read operation) and four values from the profile (second read operation: the four values are packaged in a single unsigned integer of the query-profile). The Smith-Waterman algorithm is then applied to these data and the results are saved in the storing buffer (a single write operation). The alignment also requires two supplementary values: an f_north and an h_north. In this case, there is no need to save an entire column, but only two temporary numbers updated at each cell computation.</p>
        </caption>
        <graphic xlink:href="1471-2105-9-S2-S10-7"/>
      </fig>
      <p>Before running Smith-Waterman, the implementation automatically detects the number of computational resources available. A dynamic load balancing is achieved according to the number of devices and their computational power. The database is split in the same number of segments as the number of GPUs. Each GPU then computes the alignment of the query with one database segment. The size of the segment depends upon the power of that GPU. The speed of each device is computed after every alignment. A new partitioning of the database is done for the successive query on the base of a weighted average of the performances detected during previous runs. Pre-fixed weights are used for the first run.</p>
    </sec>
  </sec>
  <sec>
    <title>List of abbreviations used</title>
    <p>CTM – Close To Metal</p>
    <p>CUDA – Compute Unified Device Architecture</p>
    <p>SIMD – Single Instruction, Multiple Data</p>
    <p>GPU – Graphics Processing Unit</p>
    <p>GPGPU – General Purpose computing on Graphics Processing Unit</p>
    <p>CPU – Central Processing Unit</p>
    <p>CUPS – Cells Updates Per Second</p>
    <p>SSE – Streaming SIMD Extensions</p>
  </sec>
  <sec>
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </sec>
  <sec>
    <title>Authors' contributions</title>
    <p>SAM coordinated the study, designed the strategies of parallelization and the architecture of the solution and contributed to writing the manuscript. GV provided the idea for the study, contributed to discussions, analysed the results and contributed to revising of the manuscript. Both authors read and approved the final manuscript.</p>
  </sec>
</body>
<back>
  <ack>
    <sec>
      <title>Acknowledgements</title>
      <p>The authors wish to thank Antonio Mariano for helping in the implementation of the algorithm. This work was supported by PRIN2005 to GV.</p>
      <p>This article has been published as part of <italic>BMC Bioinformatics</italic> Volume 9 Supplement 2, 2008: Italian Society of Bioinformatics (BITS): Annual Meeting 2007. The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/9?issue=S2"/></p>
    </sec>
  </ack>
  <ref-list>
    <ref id="B1">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pearson</surname>
            <given-names>WR</given-names>
          </name>
          <name>
            <surname>Lipman</surname>
            <given-names>DJ</given-names>
          </name>
        </person-group>
        <article-title>Improved tools for biological sequence comparison</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>1988</year>
        <volume>85</volume>
        <fpage>2444</fpage>
        <lpage>2448</lpage>
        <pub-id pub-id-type="pmid">3162770</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.85.8.2444</pub-id>
      </citation>
    </ref>
    <ref id="B2">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Altschul</surname>
            <given-names>SF</given-names>
          </name>
        </person-group>
        <article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title>
        <source>Nucleic Acids Res</source>
        <year>1997</year>
        <volume>25</volume>
        <fpage>3389</fpage>
        <lpage>3402</lpage>
        <pub-id pub-id-type="pmid">9254694</pub-id>
        <pub-id pub-id-type="doi">10.1093/nar/25.17.3389</pub-id>
      </citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Farrar</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Striped Smith-Waterman speeds database searches six times over other SIMD implementations</article-title>
        <source>Bioinformatics</source>
        <year>2007</year>
        <volume>23</volume>
        <fpage>156</fpage>
        <lpage>161</lpage>
        <pub-id pub-id-type="pmid">17110365</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl582</pub-id>
      </citation>
    </ref>
    <ref id="B4">
      <citation citation-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Liu</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Voss</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Schroeder</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Muller-Wittig</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Bio-Sequence Database Scanning On GPU</article-title>
        <source>Proceeding of the 20th IEEE International Parallel &amp; Distributed Processing Symposium: 2006(IPDSP 2006) (HICOMB Workshop</source>
        <year>2006</year>
        <publisher-name>Rhode Island, Greece</publisher-name>
      </citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J Mol Biol</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
        <pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id>
      </citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>J Mol Biol</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>705</fpage>
        <lpage>708</lpage>
        <pub-id pub-id-type="pmid">7166760</pub-id>
        <pub-id pub-id-type="doi">10.1016/0022-2836(82)90398-9</pub-id>
      </citation>
    </ref>
    <ref id="B7">
      <citation citation-type="other">
        <article-title>NVidia CUDA</article-title>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://developer.NVidia.com/object/cuda.html"/>]</comment>
      </citation>
    </ref>
    <ref id="B8">
      <citation citation-type="other">
        <article-title>AMD CTM</article-title>
        <comment>[<ext-link ext-link-type="uri" xlink:href="http://ati.amd.com/products/streamprocessor/index.html"/>]</comment>
      </citation>
    </ref>
    <ref id="B9">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rognes</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Seeberg</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Six-fold speed-up of Smith-waterman sequence database searches using parallel processing on common microprocessors</article-title>
        <source>Bioinformatics</source>
        <year>2000</year>
        <volume>16</volume>
        <fpage>699</fpage>
        <lpage>706</lpage>
        <pub-id pub-id-type="pmid">11099256</pub-id>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/16.8.699</pub-id>
      </citation>
    </ref>
    <ref id="B10">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chao</surname>
            <given-names>KM</given-names>
          </name>
          <name>
            <surname>Hardison</surname>
            <given-names>RC</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Recent developments in linear-space alignment methods: a survey</article-title>
        <source>J Comput Biol</source>
        <year>1994</year>
        <volume>4</volume>
        <fpage>271</fpage>
        <lpage>291</lpage>
        <pub-id pub-id-type="pmid">8790471</pub-id>
      </citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gribskov</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>McLachlan</surname>
            <given-names>AD</given-names>
          </name>
          <name>
            <surname>Eisenberg</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Profile analysis: detection of distantly related proteins</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>1987</year>
        <volume>84</volume>
        <fpage>4355</fpage>
        <lpage>4358</lpage>
        <pub-id pub-id-type="pmid">3474607</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.84.13.4355</pub-id>
      </citation>
    </ref>
    <ref id="B12">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Henikoff</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Henikoff</surname>
            <given-names>JG</given-names>
          </name>
        </person-group>
        <article-title>Amino acid substitution matrices from protein blocks</article-title>
        <source>Proc Natl Acad Sci U S A</source>
        <year>1992</year>
        <volume>89</volume>
        <fpage>10915</fpage>
        <lpage>10919</lpage>
        <pub-id pub-id-type="pmid">1438297</pub-id>
        <pub-id pub-id-type="doi">10.1073/pnas.89.22.10915</pub-id>
      </citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J Mol Biol</source>
        <year>1970</year>
        <volume>48</volume>
        <fpage>443</fpage>
        <lpage>453</lpage>
        <pub-id pub-id-type="pmid">5420325</pub-id>
        <pub-id pub-id-type="doi">10.1016/0022-2836(70)90057-4</pub-id>
      </citation>
    </ref>
    <ref id="B14">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pearson</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Searching protein sequence libraries: comparison of the sensitivity and selectivity of the Smith-Waterman and FASTA algorithms</article-title>
        <source>Genomics</source>
        <year>1991</year>
        <volume>11</volume>
        <fpage>635</fpage>
        <lpage>650</lpage>
        <pub-id pub-id-type="pmid">1774068</pub-id>
        <pub-id pub-id-type="doi">10.1016/0888-7543(91)90071-L</pub-id>
      </citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pearson</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Rapid and sensitive sequence comparison with FASTP and FASTA</article-title>
        <source>Methods Enzymol</source>
        <year>1990</year>
        <volume>183</volume>
        <fpage>63</fpage>
        <lpage>98</lpage>
        <pub-id pub-id-type="pmid">2156132</pub-id>
      </citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bairoch</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Apweiler</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>The SWISS-PROT protein sequence database and its supplement TrEMBL in 2000</article-title>
        <source>Nucleic Acids Res</source>
        <year>2000</year>
        <volume>28</volume>
        <fpage>45</fpage>
        <lpage>48</lpage>
        <pub-id pub-id-type="pmid">10592178</pub-id>
        <pub-id pub-id-type="doi">10.1093/nar/28.1.45</pub-id>
      </citation>
    </ref>
  </ref-list>
</back>
