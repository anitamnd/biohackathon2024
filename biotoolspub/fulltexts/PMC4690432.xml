<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BMC Syst Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">BMC Syst Biol</journal-id>
    <journal-title-group>
      <journal-title>BMC Systems Biology</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1752-0509</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4690432</article-id>
    <article-id pub-id-type="publisher-id">237</article-id>
    <article-id pub-id-type="doi">10.1186/s12918-015-0237-0</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>JigCell Run Manager (JC-RM): a tool for managing large sets of biochemical model parametrizations</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-1859-3719</contrib-id>
        <name>
          <surname>Palmisano</surname>
          <given-names>Alida</given-names>
        </name>
        <address>
          <email>alida.palmisano@gmail.com</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
        <xref ref-type="aff" rid="Aff2"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hoops</surname>
          <given-names>Stefan</given-names>
        </name>
        <address>
          <email>shoops@vbi.vt.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff3"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Watson</surname>
          <given-names>Layne T.</given-names>
        </name>
        <address>
          <email>ltw@vt.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
        <xref ref-type="aff" rid="Aff4"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Jones</surname>
          <given-names>Thomas C.</given-names>
          <suffix>Jr</suffix>
        </name>
        <address>
          <email>tjones21@vt.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Tyson</surname>
          <given-names>John J.</given-names>
        </name>
        <address>
          <email>tyson@vt.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff2"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Shaffer</surname>
          <given-names>Clifford A.</given-names>
        </name>
        <address>
          <email>shaffer@cs.vt.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><label/>Department of Computer Science, Virginia Tech, 2202 Kraft Drive, Blacksburg, 24060 VA USA </aff>
      <aff id="Aff2"><label/>Department of Biological Sciences, Virginia Tech, 1405 Perry Street, Blacksburg, 24061 VA USA </aff>
      <aff id="Aff3"><label/>Virginia Bioinformatics Institute, 1015 Life Science Circle, Blacksburg, 24061 VA USA </aff>
      <aff id="Aff4"><label/>Department of Mathematics, Virginia Tech, 225 Stanger Street, Blacksburg, 24061 VA USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>24</day>
      <month>12</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>24</day>
      <month>12</month>
      <year>2015</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2015</year>
    </pub-date>
    <volume>9</volume>
    <elocation-id>95</elocation-id>
    <history>
      <date date-type="received">
        <day>1</day>
        <month>6</month>
        <year>2015</year>
      </date>
      <date date-type="accepted">
        <day>26</day>
        <month>11</month>
        <year>2015</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© Palmisano et al. 2015</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p>Most biomolecular reaction modeling tools allow users to build models with a single list of parameter values. However, a common scenario involves different parameterizations of the model to account for the results of related experiments, for example, to define the phenotypes for a variety of mutations (gene knockout, over expression, etc.) of a specific biochemical network. This scenario is not well supported by existing model editors, forcing the user to manually generate, store, and maintain many variations of the same model.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p>We developed an extension to our modeling editor called the JigCell Run Manager (JC-RM). JC-RM allows the modeler to define a hierarchy of parameter values, simulations, and plot settings, and to save them together with the initial model. JC-RM supports generation of simulation plots, as well as export to COPASI and SBML (L3V1) for further analysis.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p>Developing a model with its initial list of parameter values is just the first step in modeling a biological system. Models are often parameterized in many different ways to account for mutations of the organism and/or for sets of related experiments performed on the organism. JC-RM offers two critical features: it supports the everyday management of a large model, complete with its parameterizations, and it facilitates sharing this information before and after publication. JC-RM allows the modeler to define a hierarchy of parameter values, simulation, and plot settings, and to maintain a relationship between this hierarchy and the initial model. JC-RM is implemented in Java and uses the COPASI API. JC-RM runs on all major operating systems, with minimal system requirements. Installers, source code, user manual, and examples can be found at the COPASI website (<ext-link ext-link-type="uri" xlink:href="http://www.copasi.org/Projects">http://www.copasi.org/Projects</ext-link>).</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Systems biology</kwd>
      <kwd>Biological networks</kwd>
      <kwd>Mathematical modeling</kwd>
      <kwd>Chemical reaction systems</kwd>
      <kwd>COPASI</kwd>
      <kwd>SBML</kwd>
      <kwd>Software</kwd>
      <kwd>Model editor</kwd>
      <kwd>Parameter hierarchy</kwd>
      <kwd>Mutants</kwd>
    </kwd-group>
    <funding-group>
      <award-group>
        <funding-source>
          <institution-wrap>
            <institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/100000002</institution-id>
            <institution>National Institutes of Health</institution>
          </institution-wrap>
        </funding-source>
        <award-id>R01-GM078989</award-id>
        <principal-award-recipient>
          <name>
            <surname>Tyson</surname>
            <given-names>John J.</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
      <award-group>
        <funding-source>
          <institution>National Institutes of Health</institution>
        </funding-source>
        <award-id>R01–GM080219</award-id>
        <principal-award-recipient>
          <name>
            <surname>Hoops</surname>
            <given-names>Stefan</given-names>
          </name>
        </principal-award-recipient>
      </award-group>
    </funding-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2015</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Developing a model with its initial list of parameter values to reproduce a specific behavior is just the first step in the process of modeling biochemical systems. Often a model must be parameterized in many different ways to account for a set of related experiments carried out on an organism, and the results simulated and plotted for every situation. For example, a budding yeast cell cycle model [<xref ref-type="bibr" rid="CR1">1</xref>] accounts for more than 120 different mutants, which are listed as changes of specific parameter values on the model website [<ext-link ext-link-type="uri" xlink:href="http://mpf.biol.vt.edu/research/budding_yeast_model/pp/">http://mpf.biol.vt.edu/research/budding_yeast_model/pp/</ext-link>]. The published model is available on Biomodels [<xref ref-type="bibr" rid="CR2">2</xref>] as a single SBML file, parameterized for simulating wild-type cells [<ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/biomodels-main/BIOMD0000000056">https://www.ebi.ac.uk/biomodels-main/BIOMD0000000056</ext-link>]. Each mutation can be simulated by manually changing specific parameters and saving the model to a new SBML file. This approach creates a large collection of files that is hard to maintain, use, and almost impossible to share. Any scientist interested in reproducing the results of the original paper must dedicate a significant amount of time to recreate each variant of the model, starting from the initial model file. This process is both time-consuming and error-prone, because each file is an independent and separate entity. Discovering a mistake in any file may compromise the entire batch of files, since it is very likely that different files were created by a copy-paste approach that spreads the error.</p>
    <p>An important observation is that for many modeling scenarios, parameter changes between different mutants are minimal and often connected to each other. A single gene knockout mutant, for example, may just set the values of a few kinetic rate constants to zero. A double mutant, where both gene A and B have been knocked out, might contain the union of changes made in the single gene knockout mutant A and single gene knockout mutant B. While describing these mutants using natural language is straightforward, encoding them in formal languages (like SBML) is hard, due to the lack of tools that deal with more than one model/parameterization at the same time.</p>
    <p>The need for better tools and approaches to tackle higher-order modeling issues in systems biology and systems medicine has been recognized by Wolkenhauer, et al. [<xref ref-type="bibr" rid="CR3">3</xref>], who identified a need to develop “workflows for modeling, including computational tools that support data management, model construction and analysis” and “dedicated modeling workflows for the integration of data and models”. To address this need to develop a model in synergy with its parameterizations, we created a new version of the JigCell Run Manager tool [<xref ref-type="bibr" rid="CR4">4</xref>] that allows modelers to organize, maintain, simulate, plot, and export hierarchical parameterizations of biochemical models.</p>
    <sec id="Sec2">
      <title>Related work</title>
      <p>The importance of linking a model with its parameterizations is acknowledged by the SBML community through the ongoing effort of the Simulation Experiment Description Markup Language (SED-ML) [<xref ref-type="bibr" rid="CR5">5</xref>]. Instructions for simulation, analysis, and visualization can be encoded in SED-ML and stored together with the model definition. However SED-ML does not provide means to hierarchically encode modifications nor it provides ways to detect/resolve conflicts that may arise when a parameterization inherits its values from multiple sources (see Section ‘<xref rid="Sec8" ref-type="sec">Detecting and resolving conflicts</xref>’).</p>
      <p>Currently there are many tools that can create, edit, and simulate SBML biochemical reaction models (e.g., COPASI [<xref ref-type="bibr" rid="CR6">6</xref>], CellDesigner [<xref ref-type="bibr" rid="CR7">7</xref>], Virtual Cell [<xref ref-type="bibr" rid="CR8">8</xref>]). None of these collect hierarchical groups of parameterizations for a single model.</p>
      <p>COPASI defines a “parameter sets” option to collect different parameter values together with the model. Unfortunately, each configuration is independent of the others, and parameterizations are not related to simulation or plotting configurations. These limitations make it cumbersome to work with parameterizations, since some mutants have special simulation or plotting requirements that need to be changed manually each time that particular mutant is to be simulated. Moreover, the lack of hierarchical relations among parameter sets makes it hard to see the relationships among simulations, such as simulations of single, double and triple mutants.</p>
      <p>Snoopy [<xref ref-type="bibr" rid="CR9">9</xref>], a Petri net editing and simulation tool, has limited support for parameter sets, similar to COPASI. Snoopy can store multiple configurations for a model, but parameter value inheritance between configurations is not supported. This approach offers little help in situations where the number of simulations is large (e.g., hundreds of mutants), because each configuration has to be manipulated independently.</p>
      <p>The present work is based on a previous version of a run-manager tool [<xref ref-type="bibr" rid="CR4">4</xref>]. Major additions and changes have been implemented, including a flexible way to inherit parameter values, conflict detection, the use of the COPASI API to seamlessly provide import/export capabilities, and integration with COPASI simulation tools. Additionally, JC-RM’s hierarchical visualization of experiments simplifies the management of collections of model parameterizations by enabling the modeler to visualize and simulate only the relevant parts of configuration ensembles.</p>
    </sec>
  </sec>
  <sec id="Sec3">
    <title>Results and discussion</title>
    <p>JC-RM is an extension to our modeling editor (MSMB) [<xref ref-type="bibr" rid="CR10">10</xref>] that allows the modeler to define hierarchies for parameter values, simulations, and plot settings, and to save them together with the initial model.</p>
    <p>Key features of this tool include the following. 
<list list-type="bullet"><list-item><p><bold>Visual representation of configuration hierarchies</bold>: JC-RM guides the user in creating a hierarchy of parameter configurations for a model. These configurations are displayed as a directed acyclic graph (DAG). Use of a DAG is motivated by the notion of inheriting a small number of changes from an existing configuration. For each node, the values of chosen parameters can be changed to new numerical values or to algebraic expressions involving values from ancestors. This makes it easy to define and maintain big collections of parameter configurations. New values can be assigned to global quantities, initial amounts of species and compartment sizes. JC-RM supports separate DAGs for a model’s parameter values, for the associated simulation settings, and for multiple plot settings for various output requirements.</p></list-item><list-item><p><bold>Algebraic expressions involving ancestors’ values</bold>: Any node in the hierarchy can refer to values of ancestor nodes to determine its local values. For example, the user can assign the parameter k1 in one node as two times the same parameter in the parent plus four times the same parameter in the grandparent (k1 = 2*k1@parent + 4*k2@grandparent). In this way if a change is made to the value of k1 in the parent or grandparent, this would be carried out seamlessly through the descendant nodes, simplifying the management of large, complex hierarchical structures.</p></list-item><list-item><p><bold>Conflict detection</bold>: Defining a configuration as a child of multiple parent nodes might result in conflicts if parents redefine a parameter to different values. JC-RM detects and communicates these conflicts to the modeler, who can resolve them either by assigning a new local value to the parameter or by choosing the value from one specific parent. Graphs with conflicts can be stored in the JC-RM internal format; however, the conflicts must be resolved before the graphs can be used for simulation or exported.</p></list-item><list-item><p><bold>Preset graph layouts and other visual customizations:</bold>JC-RM offers many automatic graph layout options. The look of the graph can be manually customized by moving the nodes on the screen and by assigning different colors to nodes and edges, with the resulting layout stored. Multiple views can be saved internally and/or exported to JPEG for publication purposes.</p></list-item><list-item><p><bold>Running simulations internally or export to COPASI</bold>: Once the settings for model parameter values, simulation conditions, and plotting instructions are consistent (i.e., without conflicting definitions), JC-RM allows the user to run simulations and see the results (e.g., time series or phase planes). Alternatively, the hierarchy of parameter values coupled with the basal simulation and plotting settings can be exported to COPASI and SBML (L3V1) for further analysis.</p></list-item></list></p>
    <sec id="Sec4">
      <title>JC-RM primary features</title>
      <p>In this section we outline how JC-RM can be used in the everyday task of managing a model of a complex biochemical system. As a working example, we use a published model of the budding yeast cell cycle [<xref ref-type="bibr" rid="CR1">1</xref>], available in SBML format in the Biomodel database (model 56, [<xref ref-type="bibr" rid="CR2">2</xref>]). The SBML version in the Biomodel database is parameterized for simulation of the cell division cycle in wild-type budding yeast cells. However, the published model accounts for more than 100 different mutant strains of budding yeast. The collection of the parameter variations needed to model these different strains is listed at <ext-link ext-link-type="uri" xlink:href="http://mpf.biol.vt.edu/research/budding_yeast_model/pp/">http://mpf.biol.vt.edu/research/budding_yeast_model/pp/</ext-link>.</p>
      <p>The code for this example is available for download from the JC-RM website. For our example, we show how to start from the initial SBML model and add mutant parameterizations, along with simulation and plotting configurations. Repeating the same steps for each mutant will generate the final file available for download in the software package (depicted in Fig. <xref rid="Fig1" ref-type="fig">1</xref>). This file contains the 131 mutant configurations of the budding yeast cell cycle model by Chen, et al. [<xref ref-type="bibr" rid="CR1">1</xref>].
<fig id="Fig1"><label>Fig. 1</label><caption><p><bold>a</bold> The collection of parameter values is displayed in a DAG and in a list in the left portion of the main window. Edges in the graph point from children to parents. Green, orange, blue nodes are wild type, single mutant, double mutant configurations, respectively. <bold>b</bold> The content for one parameter value configuration. The origin of the value is presented in the <italic>Notes</italic> column (i.e., some values belong to the <italic>Base set</italic>, some are inherited from ancestor nodes denoted with @<italic>ancestorName</italic>, while others are local redefinitions). <bold>c</bold> Time series plots generated and presented by JC-RM. As shown in the context menu, many options are available to customize the look of a plot</p></caption><graphic xlink:href="12918_2015_237_Fig1_HTML" id="MO1"/></fig></p>
    </sec>
    <sec id="Sec5">
      <title>The parameters graph</title>
      <p>The following steps are used to create the Parameter Lists graph. 
<list list-type="order"><list-item><p>The SBML model file (from <ext-link ext-link-type="uri" xlink:href="https://www.ebi.ac.uk/biomodels-main/BIOMD0000000056">https://www.ebi.ac.uk/biomodels-main/BIOMD0000000056</ext-link>) is loaded into the JC-MSMB editor, where the Reactions, Species, etc. that compose the original model are displayed. This is the base model used to build the hierarchy of parameterizations.</p></list-item><list-item><p>Opening JC-RM displays the main window. It contains independent but connected graphs, each representing a different aspect of the model parameterization (Model values, Time course, Plotting,...). The first time the window is opened, each tab will be empty. Once graphs have been added to the model, the user can save the model with the parameterization through the “Save to.msmb" option. At any future time, the user can open the saved.msmb file and continue working on either the model or its parameterization.</p></list-item><list-item><p>To create the first node of the DAG, from the “Parameter lists” tab the user clicks the “Create mutant from current model values” button. JC-RM will ask to give this configuration a name. Since the current model holds the parameters for the wild type in glucose, in our example we call the node WT_glucose. The newly created node will appear both in the graph view and in the alphabetically ordered list of defined configurations (in the left portion of the window). As imported from Biomodels, the model already contains the right numerical values for modeling the wild type in glucose, we don’t need to customize the content for this node. So we can move to defining new nodes in the Parameter list graph.</p></list-item><list-item><p>A new mutant can be defined as a child of any node in the graph. This allows the child configuration to inherit all the values of the parent (or parents), possibly redefining some specific values in the local configuration. More complete examples where multiple parents are used for the mutant definition (and any resulting conflicts are detected) are presented in section ‘<xref rid="Sec8" ref-type="sec">Detecting and resolving conflicts</xref>’. To create a child configuration, select the root node in the graph (WT_glucose) and then click the “Create child configuration” button. The user will be asked to give this new configuration a name (the name must be unique within the graph). We will call the new node WT_galactose. The newly created node will appear both in the graph view (as a node connected to its parent) and in the list of all defined lists.</p></list-item><list-item><p>To make some parameter values for WT_galactose different from WT_glucose, the new configuration needs to be changed (Fig. <xref rid="Fig2" ref-type="fig">2</xref>). To do so, the user can edit the node s/he wants to change by either double clicking on the node or by clicking the “Edit mutant configuration” button. This will open a pop-up window in which the various tables defining the models are shown. The WT_galactose configuration differs from the WT_glucose in the value of the “mdt" global quantity (150 instead of 80). The user can find the mdt element in the proper tab, double click on the “Initial Value” cell of mdt and assign the new value. Once the change has been made, the fact that the value coming from the parent has been overwritten by the new value is visually identified by the color of mdt’s row, as well as through a new label shown in the “Notes” column (i.e., “Local change"). This label helps the user to keep track of the changes. The “Notes” column can be used as a filter with the search/filter box.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Steps to create a parameter list graph from an initial model file. <bold>a</bold> The SBML model is loaded in the editor and all its component are displayed in the tables. <bold>b</bold> The JC-RM interface contains two nodes representing mutant configurations of the initial model setup. For details on how to create those nodes, refer to the text. To edit specific parameter values, the modeler can use the filtering capabilities of the editor. A new value can be assigned in 3 different ways: more details on this can be found in the text. <bold>c</bold> A more complex DAG connects different parameter configurations. <bold>d</bold> Of particular interest, the node called ‘GAL_CLB2_Cdh1’: it inherits from two parents and the specific values inherited from each parent are clearly marked in the tabular view</p></caption><graphic xlink:href="12918_2015_237_Fig2_HTML" id="MO2"/></fig></p></list-item><list-item><p>Repeating these steps, the user can add all mutant configurations. To define a “double mutant" configuration, the user selects multiple nodes from which the child configuration will inherit, and then clicks the “Create new configuration" button. This new mutant will contain the union of the changes of all the parents. (See ‘<xref rid="Sec8" ref-type="sec">Detecting and resolving conflicts</xref>’ for a discussion on resolving any conflicts that might result).</p></list-item></list></p>
      <p>In all graphs, newly created nodes are automatically positioned on the screen. Users can reposition nodes manually with the mouse, or they can use one of the alternative automatic graph layout options provided. Node and edge colors can be changed to suit the needs of the modeler. Colors may be useful to visually group mutants of similar nature, or to quickly identify configurations of interest that are incomplete or need attention.</p>
      <p>Any node in the hierarchy can be deleted and a warning is displayed to the user before the action is completed. The warning displays the names of all the nodes that may be affected by this deletion (i.e., the descendants that inherit values from the deleted node). The recommended practice is to take note of this list and make sure that no undesired effect is propagated. There are different possible scenarios: 
<list list-type="order"><list-item><p>The child inherits the parameter values of ancestor nodes without local changes. If one of the ancestors is removed, the parameter values of the child will be determined by either other ancestors node still connected, or by the “base set”, which is the parameter value of the initial model from the JC-MSMB interface.</p></list-item><list-item><p>The child overwrites the value of a parameter, making explicit reference to the deleted parent. In this case a “inconsistency” warning is displayed for the node, and the user won’t be allowed to run simulations of this set until the inconsistency is resolved.</p></list-item></list></p>
      <p>Deletion of single parameters within a node configuration is not currently supported in JC-RM because this represents a structural change in the model which may have hard to handle consequences in terms of model management (e.g., leaving dangling references in rate laws, assignments, etc.). The effect of deleting a parameter, however, can be easily achieved by setting its value to zero. This corresponds to knocking out a specific pathway or reaction, without disrupting the structure of the entire hierarchy of parameter configurations.</p>
    </sec>
    <sec id="Sec6">
      <title>The time course settings graph</title>
      <p>The idea of defining changes in a hierarchical way can be applied not just to model parameters but also to simulation settings. A given mutant might need to be simulated with runtime parameters different from the others. For example, the budding yeast cell cycle model has mutants that represent the organism when grown in different media. This is modeled by slowing the cell cycle machinery. Hence in a fixed time period, fewer complete cycles can be observed. The modeler might therefore wish to set a different total time period in the simulation settings for these slow mutants, so that the overall number of cycles is comparable to the fast mutants, without slowing down the entire process by increasing the simulation time for all of the mutants. In principle, this process is similar to describing changes in model parameters, because again only one element in the simulation settings (the end time in this case) needs to change.</p>
      <p>JC-RM allows the user to define a DAG for simulation settings under the “Time course” tab. The layout of the tab and the process for building the graph is similar to the “Parameter lists” tab. When editing a simulation graph node, the user sees a window that shows relevant information that a simulation may need to customize. Each defined simulation configuration can be applied to specific mutants defined in the Parameter Lists tab.</p>
      <p>In Fig. <xref rid="Fig3" ref-type="fig">3</xref>, two simulation settings are shown. One is called “short” (with duration parameter of 500) and another “long” (with duration parameter 1000). In the example, the long configuration is applied only to the WT_galactose node, while the short one is applied to both.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Initializing time course settings. (<italic>left</italic>) A graph containing two Time course nodes (called short and long). The node called ‘long’ inherits the settings from its parent, redefining some quantities with new values (local changes). (<italic>right top</italic>) ‘Short’ simulation configuration details. Duration and interval size are changed with respect to the basic default configuration determined by JC-RM. Other values, like the kind of simulation engine with its internal parameters, are left unchanged. (<italic>right bottom</italic>) ‘Long’ simulation configuration details. Duration and interval size are changed with respect to the inherited values. Since the two nodes are connected, the descendant values can be expressed in terms of any ascendant parameter, making the expression of the duration in this node highly flexible. Each Time Course node applies to a specific list of ‘Parameter sets’ as shown in the left portion of each window: in this case the short configuration is applied to both WT and WT_galactose while the long configuration is applied only to the WT_galactose node</p></caption><graphic xlink:href="12918_2015_237_Fig3_HTML" id="MO3"/></fig></p>
    </sec>
    <sec id="Sec7">
      <title>The plot settings graph</title>
      <p>The user might wish to present specific mutants in plots with different criteria. For example, in a mutant where the gene for the Cdh1 protein has been knocked out, the time course of the protein Cdh1 could be omitted (since it should be constantly zero). Of course, the collection of mutants that need a specific configuration for plot settings is not necessarily related to the hierarchy defined for parameter settings or simulation settings. So JC-RM provides the “Plotting” tab for specifying the relationships between various plotting configurations. This tab follows the same process for defining relationships as is used for model parameters and simulation settings. Double clicking on a node in the plot settings graph opens a pop-up window where the user can select specific values for the current plotting settings. The user will choose any of the model variables (or time) as the X axis, and one or more of the other variables for the Y axis. It is also possible to customize the appearance for each line in the plot (i.e., color, thickness, symbol and plotting interval), and customize other general layout options for the XY plot (e.g., font and color of the title, x/y labels, plot background color, etc.).</p>
      <p>While JC-RM offers the opportunity to define hierarchies for simulation and plot settings, it is not mandatory to do so. The default is to have a single group of settings for all mutants.</p>
    </sec>
    <sec id="Sec8">
      <title>Detecting and resolving conflicts</title>
      <p>The hierarchical representation for values in graph nodes allows for setting a mutant’s parameter values to numerical values or to algebraic expressions involving values from ancestor nodes. Defining a configuration as a child of multiple parent nodes may result in conflicts, if multiple parents redefine a given parameter to different values. JC-RM detects and communicates these conflicts to the modeler, who is expected to resolve the conflict either by assigning a new local value to the parameter, or by choosing the value from one specific parent. Graphs with conflicts cannot be used to initiate simulations, nor can they be exported to COPASI or SBML. They may, however, be stored in JC-RM’s internal format so that the user does not lose work.</p>
      <p>A scenario with conflicts is depicted in Fig. <xref rid="Fig4" ref-type="fig">4</xref>, where two separate configurations are defined (WT1 and WT2). Each has a local assignment for parameter k1, with values 2 and 4, respectively. When creating a third configuration named “M” as the child of WT1 and WT2, JC-RM detects a conflict in the value of k1. This issue is presented to the user through the use of dashed edges. Double clicking on the node displaying the conflict (M) will show to the user the specific parameter for which the conflict exists. At this point, the user must decide how to resolve the conflict. Three options are available. 
<list list-type="order"><list-item><p>Pick a value from a specific parent, selected using a drop down menu.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Conflict detection and resolution. (<italic>top</italic>) two nodes are created to generate a conflict. The two nodes locally assign a different value to the same parameter k1. (bottom left) Once the third node M is created as child of both WT1 and WT2 JC-RM detects the conflict in assigning a value to k1 in M and displays the problem as dashed connecting arrows in the graph. (<italic>bottom right</italic>) Checking the content of the M node, the conflict in the specific value of k1 is clearly marked. Three options are presented for resolving the conflict: <bold>a</bold> pick a value from a specific parent, <bold>b</bold> pick the value from the base set or <bold>c</bold> assign a new value from a typed expression. The algebraic expression can contain references to ancestor nodes</p></caption><graphic xlink:href="12918_2015_237_Fig4_HTML" id="MO4"/></fig></p></list-item><list-item><p>Pick the value from the original base set.</p></list-item><list-item><p>Assign a new value, which can be either a number or an algebraic expression that involves values from the parents. Such an expression will use the syntax “parameter_name@parent_name”. In the example from Fig. <xref rid="Fig4" ref-type="fig">4</xref>(<xref rid="Fig4" ref-type="fig">c</xref>), M the sum of the value for k1 in WT1 and k1 in WT2.</p></list-item></list></p>
      <p>Once the conflict has been resolved, the corresponding graph will display the edge between the node and its parents as a regular line.</p>
    </sec>
    <sec id="Sec9">
      <title>Running a simulation and visualizing the results</title>
      <p>Once the settings for model parameter values, simulation conditions, and plotting options are consistent (i.e., without conflicting definitions), JC-RM allows the user to run simulations and see the results (e.g., time series or phase planes). When simulations are run within JC-RM, the user can choose which mutant(s) to simulate. Alternatively, the model can be exported to COPASI and SBML (L3V1) for further analysis. Note that while SBML Level 3 supports multiple parameter sets (so all of the various mutants can be represented), SBML only supports a single specification for simulation and plot settings. The user can select which to export.</p>
      <p>If the simulations are run within JC-RM, the results can be viewed, as in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. Each plot can be separately customized, using options accessible from the right-click menu (zoom, change line colors, save it as an image, add/remove variables, etc.). The plots are embedded in the main window, but for easy comparison, the option “Open plots to separate windows” is available. This causes each plot to be displayed in a separate window that can be repositioned or maximized on the user screen. Closing each plot window will cause that plot to go back to its embedded state. The “Window" menu helps the user to bring to the front a selected plot.
<fig id="Fig5"><label>Fig. 5</label><caption><p>Running a simulation and visualizing the results. (<italic>left</italic>) When the user decides to run the simulation within JC-RM, a popup provides the modeler the choice to run specific nodes (shown as alphabetically sorted root nodes in the tree structure) or specific mutant configurations within each configuration. This option is useful when some mutants require longer simulation time and the modeler wants to check the behaviour of specific mutants. Colors identify nodes where all the mutant configurations are selected (green), some are omitted (cyan) or none is selected (white background, not shown). (<italic>right</italic>) Time course plots are displayed in the Results tab. Each plot is the result of running a selected Time Course node, with a specific parameter set configuration and the X/Y plot created according to the specification in the Plot graph. Each plot can be further customized, printed and saved using a contextual menu</p></caption><graphic xlink:href="12918_2015_237_Fig5_HTML" id="MO5"/></fig></p>
    </sec>
  </sec>
  <sec id="Sec10" sec-type="conclusion">
    <title>Conclusions</title>
    <p>Developing a model with its initial list of parameter values is just the first step in modeling a biological system. Models are often parameterized in many different ways to account for mutations of the organism or sets of related experiments performed on the organism. During the life cycle of a modeling project, the model may need frequent changes, values need to be updated, specific mutants need adjustment, etc. If these operations must be performed in a context where each parameterization is a separate and independent file, the modeling process becomes difficult, cumbersome and error-prone. Since modeling efforts are typically carried out by a team of researchers, coordinating the exchange and updates of hundreds of model files among team members is even more chaotic. If the research team follows the traditional practice of sharing only one model file when the work is finalized and published, then any scientist interested in the model must start almost from scratch and expend considerable effort to reproduce the simulations in the publication.</p>
    <p>By allowing modelers to define a hierarchy of parameter values, simulation settings, and plot settings, and to couple these hierarchies with the initial model, JC-RM enables computational modeling in two critical ways: 
<list list-type="order"><list-item><p>By supporting everyday management of a large model, complete with its parameterizations.</p></list-item><list-item><p>By facilitating the sharing of this information before and after publication.</p></list-item></list></p>
    <p>Future developments for JC-RM include the addition of analysis tools for data other than time course simulations (e.g., parameter estimation tasks) that require different experimental data to be associated with different lists of parameter values. Another valuable future addition would be the implementation of direct export capabilities to SED-ML [<xref ref-type="bibr" rid="CR5">5</xref>]. SED-ML is a language developed by the SBML community to standardize the coupling of model parameterization and simulation settings. Its purpose is to support exchange of models with reproducible results. The current SED-ML specification includes elements like “List of Models”, “Changes” and “Simulations” that quite nicely map to concepts implemented in JC-RM. While the concepts are similar, they are not used in the same way in our software, so investigating the direct import/export capabilities is beyond the scope of this work and it has been deferred for a follow-up version of JC-RM. As active members of the SBML community, we hope to contribute to further developments of this standard.</p>
  </sec>
  <sec id="Sec11">
    <title>Availability and requirements</title>
    <p>
      <list list-type="order">
        <list-item>
          <p>Project name: JC-RM</p>
        </list-item>
        <list-item>
          <p>Project home page: <ext-link ext-link-type="uri" xlink:href="http://www.copasi.org/Projects">http://www.copasi.org/Projects</ext-link></p>
        </list-item>
        <list-item>
          <p>Operating system(s): Platform independent</p>
        </list-item>
        <list-item>
          <p>Programming language: Java</p>
        </list-item>
        <list-item>
          <p>Other requirements: Java 6.0 or higher</p>
        </list-item>
        <list-item>
          <p>License: Artistic License 2.0</p>
        </list-item>
      </list>
    </p>
  </sec>
  <sec id="Sec12">
    <title>Implementation</title>
    <p>JC-RM is implemented in Java and uses the COPASI API [<xref ref-type="bibr" rid="CR6">6</xref>]. JC-RM runs on all major operating systems, with minimal system requirements. Installer, source code, user manual, and examples can be found at the COPASI website (<ext-link ext-link-type="uri" xlink:href="http://copasi.org/Projects/">http://copasi.org/Projects/</ext-link>).</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Competing interests</bold>
      </p>
      <p>The authors declare that they have no competing interests.</p>
    </fn>
    <fn>
      <p>
        <bold>Authors’ contributions</bold>
      </p>
      <p>AP implemented the software and drafted the manuscript. CAS, LTW, SH, TCJ, and JJT participated in extensive discussions to iteratively define the software functionality. JJT initiated and coordinated the project. All authors participated in and approved the final manuscript’s preparation.</p>
    </fn>
  </fn-group>
  <ack>
    <p>We would like to thank Dr. Kathy Chen for important feedback on the tool and Dr. Frank T. Bergmann for supportive feedback in dealing with the COPASI API. Research reported in this publication was supported by the National Institute of General Medical Sciences of the National Institutes of Health under Award Number R01GM078989 and and R01GM080219. The content is the sole responsibility of the authors and does not necessarily represent the views of the National Institutes of Health.</p>
  </ack>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chen</surname>
            <given-names>KC</given-names>
          </name>
          <name>
            <surname>Calzone</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Csikasz-Nagy</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cross</surname>
            <given-names>FR</given-names>
          </name>
          <name>
            <surname>Novak</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Tyson</surname>
            <given-names>JJ</given-names>
          </name>
        </person-group>
        <article-title>Integrative analysis of cell cycle control in budding yeast</article-title>
        <source>Mol Biol Cell</source>
        <year>2004</year>
        <volume>15</volume>
        <issue>8</issue>
        <fpage>3841</fpage>
        <lpage>62</lpage>
        <pub-id pub-id-type="doi">10.1091/mbc.E03-11-0794</pub-id>
        <?supplied-pmid 15169868?>
        <pub-id pub-id-type="pmid">15169868</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Donizelli</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rodriguez</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Dharuri</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Endler</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Chelliah</surname>
            <given-names>V</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>BioModels Database: An enhanced, curated and annotated resource for published quantitative kinetic models</article-title>
        <source>BMC Syst Biol</source>
        <year>2010</year>
        <volume>4</volume>
        <fpage>92</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-4-92</pub-id>
        <?supplied-pmid 20587024?>
        <pub-id pub-id-type="pmid">20587024</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wolkenhauer</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Auffray</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Brass</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Clairambault</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Deutsch</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Drasdo</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Enabling multiscale modeling in systems medicine</article-title>
        <source>Genome Med</source>
        <year>2014</year>
        <volume>6</volume>
        <fpage>21</fpage>
        <pub-id pub-id-type="doi">10.1186/gm538</pub-id>
        <?supplied-pmid 25031615?>
        <pub-id pub-id-type="pmid">25031615</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Vass</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Allen</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Shaffer</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Ramakrishnan</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Watson</surname>
            <given-names>LT</given-names>
          </name>
          <name>
            <surname>Tyson</surname>
            <given-names>JJ</given-names>
          </name>
        </person-group>
        <article-title>The JigCell model builder and run manager</article-title>
        <source>Bioinformatics</source>
        <year>2004</year>
        <volume>20</volume>
        <issue>18</issue>
        <fpage>3680</fpage>
        <lpage>1</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/bth422</pub-id>
        <?supplied-pmid 15273159?>
        <pub-id pub-id-type="pmid">15273159</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Waltemath</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Adams</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Bergmann</surname>
            <given-names>FT</given-names>
          </name>
          <name>
            <surname>Hucka</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kolpakov</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>AK</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Reproducible computational biology experiments with SED-ML-the simulation experiment description markup language</article-title>
        <source>BMC Syst Biol</source>
        <year>2011</year>
        <volume>5</volume>
        <issue>1</issue>
        <fpage>198</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-5-198</pub-id>
        <?supplied-pmid 22172142?>
        <pub-id pub-id-type="pmid">22172142</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hoops</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Sahle</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gauges</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Pahle</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Simus</surname>
            <given-names>N</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>COPASI – a COmplex PAthway SImulator</article-title>
        <source>Bioinformatics</source>
        <year>2006</year>
        <volume>22</volume>
        <fpage>3067</fpage>
        <lpage>74</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btl485</pub-id>
        <?supplied-pmid 17032683?>
        <pub-id pub-id-type="pmid">17032683</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Funahashi</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Matsuoka</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Jouraku</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Morohashi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kikuchi</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Kitano</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Celldesigner 3.5: A versatile modeling tool for biochemical networks</article-title>
        <source>Proc IEEE</source>
        <year>2008</year>
        <volume>96</volume>
        <issue>8</issue>
        <fpage>1254</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="doi">10.1109/JPROC.2008.925458</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Moraru</surname>
            <given-names>II</given-names>
          </name>
          <name>
            <surname>Schaff</surname>
            <given-names>JC</given-names>
          </name>
          <name>
            <surname>Slepchenko</surname>
            <given-names>BM</given-names>
          </name>
          <name>
            <surname>Blinov</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Morgan</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Lakshminarayana</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Virtual cell modelling and simulation software environment</article-title>
        <source>Syst Biol IET</source>
        <year>2008</year>
        <volume>2</volume>
        <issue>5</issue>
        <fpage>352</fpage>
        <lpage>62</lpage>
        <pub-id pub-id-type="doi">10.1049/iet-syb:20080102</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rohr</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Marwan</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Heiner</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Snoopy–a unifying Petri net framework to investigate biomolecular networks</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>7</issue>
        <fpage>974</fpage>
        <lpage>5</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq050</pub-id>
        <?supplied-pmid 20139470?>
        <pub-id pub-id-type="pmid">20139470</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Palmisano</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Hoops</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Watson</surname>
            <given-names>LT</given-names>
          </name>
          <name>
            <surname>Jones Jr</surname>
            <given-names>TC</given-names>
          </name>
          <name>
            <surname>Tyson</surname>
            <given-names>JJ</given-names>
          </name>
          <name>
            <surname>Shaffer</surname>
            <given-names>CA</given-names>
          </name>
        </person-group>
        <article-title>Multistate Model Builder (MSMB): a flexible editor for compact biochemical models</article-title>
        <source>BMC Syst Biol</source>
        <year>2014</year>
        <volume>8</volume>
        <issue>1</issue>
        <fpage>42</fpage>
        <pub-id pub-id-type="doi">10.1186/1752-0509-8-42</pub-id>
        <?supplied-pmid 24708852?>
        <pub-id pub-id-type="pmid">24708852</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
