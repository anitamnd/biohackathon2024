<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">BioData Min</journal-id>
    <journal-id journal-id-type="iso-abbrev">BioData Min</journal-id>
    <journal-title-group>
      <journal-title>BioData Mining</journal-title>
    </journal-title-group>
    <issn pub-type="epub">1756-0381</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7466824</article-id>
    <article-id pub-id-type="publisher-id">219</article-id>
    <article-id pub-id-type="doi">10.1186/s13040-020-00219-6</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Research</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Finding semantic patterns in omics data using concept rule learning with an ontology-based refinement operator</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-9681-4716</contrib-id>
        <name>
          <surname>Malinka</surname>
          <given-names>František</given-names>
        </name>
        <address>
          <email>malinfr1@fel.cvut.cz</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>železný</surname>
          <given-names>Filip</given-names>
        </name>
        <address>
          <email>zelezny@fel.cvut.cz</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kléma</surname>
          <given-names>Jiří</given-names>
        </name>
        <address>
          <email>klema@fel.cvut.cz</email>
        </address>
        <xref ref-type="aff" rid="Aff1">1</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.6652.7</institution-id><institution-id institution-id-type="ISNI">0000000121738213</institution-id><institution>Department of Computer Science, Czech Technical University in Prague, </institution></institution-wrap>Karlovo náměstí 13, Prague, 121 35 Czech Republic </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.418095.1</institution-id><institution-id institution-id-type="ISNI">0000 0001 1015 3316</institution-id><institution>Czech Centre for Phenogenomics, Institute of Molecular Genetics of the Czech Academy of Sciences, </institution></institution-wrap>Prague, Czech Republic </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>1</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>1</day>
      <month>9</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>13</volume>
    <elocation-id>13</elocation-id>
    <history>
      <date date-type="received">
        <day>6</day>
        <month>4</month>
        <year>2020</year>
      </date>
      <date date-type="accepted">
        <day>1</day>
        <month>7</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <sec>
        <title>Background</title>
        <p id="Par1">Identification of non-trivial and meaningful patterns in omics data is one of the most important biological tasks. The patterns help to better understand biological systems and interpret experimental outcomes. A well-established method serving to explain such biological data is Gene Set Enrichment Analysis. However, this type of analysis is restricted to a specific type of evaluation. Abstracting from details, the analyst provides a sorted list of genes and ontological annotations of the individual genes; the method outputs a subset of ontological terms enriched in the gene list. Here, in contrary to enrichment analysis, we introduce a new tool/framework that allows for the induction of more complex patterns of 2-dimensional binary omics data. This extension allows to discover and describe semantically coherent biclusters.</p>
      </sec>
      <sec>
        <title>Results</title>
        <p id="Par2">We present a new rapid method called sem1R that reveals interpretable hidden rules in omics data. These rules capture semantic differences between two classes: a target class as a collection of positive examples and a non-target class containing negative examples. The method is inspired by the CN2 rule learner and introduces a new refinement operator that exploits prior knowledge in the form of ontologies. In our work this knowledge serves to create accurate and interpretable rules. The novel refinement operator uses two reduction procedures: Redundant Generalization and Redundant Non-potential, both of which help to dramatically prune the rule space and consequently, speed-up the entire process of rule induction in comparison with the traditional refinement operator as is presented in CN2.</p>
      </sec>
      <sec>
        <title>Conclusions</title>
        <p id="Par3">Efficiency and effectivity of the novel refinement operator were tested on three real different gene expression datasets. Concretely, the Dresden Ovary Dataset, DISC, and m2816 were employed. The experiments show that the ontology-based refinement operator speeds-up the pattern induction drastically. The algorithm is written in C++ and is published as an R package available at <ext-link ext-link-type="uri" xlink:href="http://github.com/fmalinka/sem1r">http://github.com/fmalinka/sem1r</ext-link>.</p>
      </sec>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Symbolic machine learning</kwd>
      <kwd>Enrichment analysis</kwd>
      <kwd>Ontology</kwd>
      <kwd>Taxonomy</kwd>
      <kwd>Gene expression</kwd>
      <kwd>Biclustering</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Nowadays, omics data analysis that integrates semantics in the form of external prior knowledge with raw measurements is becoming more and more popular in computational biology [<xref ref-type="bibr" rid="CR1">1</xref>–<xref ref-type="bibr" rid="CR3">3</xref>]. A typical example of integrative gene expression data analysis may deliver a direct link between a phenotype and existing annotation terms at different levels of generality. The integration helps scientists to interpret gene expression data easier because it can reveal gene sets that share common biological properties. Semantic data are stored in databases, oftentimes in an ontology format. In this area, an important role is played by The Open Biological and Biomedical Ontology (OBO) Foundry [<xref ref-type="bibr" rid="CR4">4</xref>], which provides validation and assessment of ontologies to ensure their interoperability. Dozens of ontologies from various biological domains can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://www.obofoundry.org/">http://www.obofoundry.org/</ext-link>.</p>
    <sec id="Sec2">
      <title>Gene set enrichment analysis</title>
      <p>One of the most popular methods that uses this type of semantics utilizing a connection between ontologies or gene set databases and genes is <italic>enrichment analysis</italic>, <italic>Gene Set Enrichment Analysis</italic> (GSEA) [<xref ref-type="bibr" rid="CR5">5</xref>] represents one of its most frequently used implementations. The enrichment analysis identifies a list of significantly enriched ontological terms from a provided list of differentially expressed genes that is sorted according by some ranking metric (p-value, log fold change, etc.). To discover a certain molecular function or biological process that is shared over the set of differentially expressed genes, Gene Ontology [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>] is an appropriate and often used annotation database. GSEA overcomes certain limitations of the statistical enrichment assessment based on hypergeometric, <italic>χ</italic><sup>2</sup>, or Fisher exact test, namely the information loss caused by selection of significant genes before the enrichment analysis. An example of GSEA outcome that is induced from data over the KEGG database can be the following:</p>
      <p>
        <graphic position="anchor" xlink:href="13040_2020_219_Figa_HTML" id="MO1"/>
      </p>
      <p>In our view, this GSEA outcome corresponds to a hypothesis that can be seen as a collection of three simple rules where each rule has length one and says, independent of the other rules, that the corresponding term in the rule is significantly enriched in the reported set of genes against a background/control gene set. Unfortunately, GSEA in particular, and enrichment analysis in general, cannot produce more complex hypotheses. For example, the hypothesis above does not say that <italic>KEGG_WNT_SIGNALING_PATHWAY</italic> and <italic>KEGG_CELL_CYCLE</italic> are enriched simultaneously, in conjunction. The form of hypothesis only says that these terms are enriched individually. On the other hand, let <italic>R</italic> be the following rule:</p>
      <p>
        <graphic position="anchor" xlink:href="13040_2020_219_Figb_HTML" id="MO2"/>
      </p>
      <p><italic>R</italic> says that simultaneous occurrence of the terms <italic>KEGG_WNT_SIGNALING_PATHWAY</italic> and <italic>KEGG_CELL_CYCLE</italic> in the annotation of a gene (frequently) leads to its upregulation. The upregulation score for the rule <italic>R</italic> is computed from a gene set where each gene has to be associated with both terms simultaneously. In our framework, and unlike the traditional enrichment analysis, we will be able to cope with these conjunctive rules.</p>
      <p>Moreover, the dimension of biological samples/conditions is disregarded in the enrichment analysis, only the dimension of genes is taken into consideration when constructing annotations. The enrichment analysis supposes a gene set of interest (e.g. genes that are differentially expressed) to be a part of the input. Consequently, these methods can only be applied in such biological experiments, where samples are split into two groups, treatments and controls. However, the treatment and control labels are often not available. In most cases, the split into groups is unclear, the sample groups may overlap or form complex taxonomies. Under these conditions, any set of differentially expressed genes cannot easily be determined. For this reason, we suppose that samples are described with a rich ontology of annotation terms (locations, conditions, complex treatments, etc.) and bring an opportunity to further generalize the rules with extra terms from this ontology that can be added into the rules. This allows for inducing a rule that self-defines the semantically coherent joint groups of genes and samples; the genes tend to be upregulated in the sample group. The induction is fully automated and driven by the context provided in the measurements and annotation ontologies. In other words, GSEA uses a 1-dimensional space of genes to induce a list of significantly enriched annotation terms. In this work, we expand onto 2-dimensional expression space and consequently allow for generation of hypotheses that represent a set of genes upregulated in a specific set of samples/biological conditions. An example of the hypothesis could be the following rule:</p>
      <p>
        <graphic position="anchor" xlink:href="13040_2020_219_Figc_HTML" id="MO3"/>
      </p>
      <p>This hypothetical example shows the case where genes belonging to <italic>KEGG_WNT_SIGNALING</italic> and <italic>KEGG_CELL_CYCLE</italic> pathways are frequently upregulated in samples from <italic>WING_VEIN_SEGMENT</italic>, which makes a specific body part of Drosophila melanogaster.</p>
    </sec>
    <sec id="Sec3">
      <title>Rule learning with ontological background knowledge</title>
      <p>We use rule learning [<xref ref-type="bibr" rid="CR8">8</xref>, <xref ref-type="bibr" rid="CR9">9</xref>] to construct the above-outlined hypotheses. Rule learning refers to a class of supervised machine learning methods that induce a set of classification rules from a given set of training examples. For a binary task, training examples are assigned to two disjoint sets of positive and negative examples. The rule is an if-then statement where the antecedent is in the form of a conjunction of positive or negative logical terms, and the consequent is a class label. The final decision regarding an unseen example is provided by a set of rules or their ordered list. The rules are widely used in the fields of medicine and biology for their easy and clear interpretation [<xref ref-type="bibr" rid="CR10">10</xref>–<xref ref-type="bibr" rid="CR12">12</xref>] contrary to neural networks, for instance.</p>
      <p>As previously mentioned, one of the things that can help scientists interpret their data in a more natural way is background knowledge. Bioinformatics frequently deals with Gene Ontology [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>] and there are other types of structured databases, such as KEGG [<xref ref-type="bibr" rid="CR13">13</xref>–<xref ref-type="bibr" rid="CR15">15</xref>], which can also be interpreted as an ontology or a taxonomy. Medicine employs Disease Ontology [<xref ref-type="bibr" rid="CR16">16</xref>, <xref ref-type="bibr" rid="CR17">17</xref>] or SNOMED-CT, natural language processing makes use of WordNet [<xref ref-type="bibr" rid="CR18">18</xref>] or YAGO [<xref ref-type="bibr" rid="CR19">19</xref>], dedicated ontologies are often encountered in industry too.</p>
      <p>In our work, these two concepts, rule learning and ontologies or taxonomies, are combined. We observed that the ontologies reasonably increase accuracy and robustness of induced rules. However, they also reasonably raise the number of logical terms available for rule construction, which consequently leads to prohibitive growth of hypothesis space and inefficiency of rule learning. This inefficiency can reasonably be reduced with consistent utilization of the known hierarchical relationships between the ontology terms that cannot be handled with the traditional rule learning methods [<xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR21">21</xref>]. In this paper, we will focus on the binary task (positive and negative examples, two classes only) and multiple rule models (the output of the learning algorithm is multiple rules).</p>
      <p>The main motivation for this paper was our work published in [<xref ref-type="bibr" rid="CR22">22</xref>], in which we introduced a technique called <italic>semantic biclustering</italic>. This type of biclustering infers a human easily readable form of hypothesis describing only a single target class (also known as the target concept). This technique is applied to a gene expression data where highly expressed genes in corresponding samples are considered as the target class. One of the proposed methods solves the problem of semantic biclustering by linearizing a two-dimensional binary data matrix and a set of ontologies to an attribute-value representation that can be figured out using one of the well-known rule learning algorithms such as CN2 [<xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR23">23</xref>], RIPPER [<xref ref-type="bibr" rid="CR21">21</xref>], or PRIM [<xref ref-type="bibr" rid="CR24">24</xref>]. However, current ontologies, such as Gene Ontology, contain tens of thousands of hierarchically ordered terms. As a result, building a classification model without a preprocessing step is time and memory consuming. For this reason, we introduce a new refinement operator for a rule learning algorithm that examines properties between given data, ontologies, and its mutual relations to speed-up and improve the process of learning.</p>
      <p>One of the related subfields of machine learning that can exploit formalized prior knowledge such as ontologies or taxonomies is Inductive Logic Programming (ILP) [<xref ref-type="bibr" rid="CR25">25</xref>] where a key challenge is to prune the search space of (first-order logic) rules. For its ability to work with this form of prior knowledge, we were inspired by this subfield. In [<xref ref-type="bibr" rid="CR26">26</xref>], the authors proposed a refinement operator to construct conjunctive relational features. This algorithm uses taxonomies to exclude conjunction from the exploration process if the conjunction contains a feature together with any of its subsumees. In [<xref ref-type="bibr" rid="CR27">27</xref>], the authors find and prune such hypotheses that are equivalent to a previously considered hypothesis. To test such equivalency in given domain theory, they proposed a saturation method for a first-order logic clause with the property that two clauses are equivalent whenever their saturations are isomorphic.</p>
      <p>However, the highly expressive first-order logic setting of ILP is traded off by high computational demands and high complexity of resulting patterns. The latter presents a challenge when interpreting and validating the outputs. For the analysis task addressed here, the expressiveness and complexity of ILP is unnecessary. We thus seek to design an efficient rule-refinement operator in the simpler setting of IF-THEN rules corresponding to propositional-logic formulas.</p>
    </sec>
    <sec id="Sec4">
      <title>Propositional rule learning</title>
      <p>We base our approach on the classical rule learning algorithm CN2 [<xref ref-type="bibr" rid="CR20">20</xref>]. The input to CN2 is an attribute-value description of a set of examples along with the class labels of the examples, i.e. the <italic>training set</italic>. The output is a set of rules predicting class labels from the attribute values. Each rule has the form
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ a_{1} = v_{1} \wedge a_{2}=v_{2} \wedge \ldots \rightarrow {class}  $$ \end{document}</tex-math><mml:math id="M2"><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>∧</mml:mo><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>∧</mml:mo><mml:mo>…</mml:mo><mml:mo>→</mml:mo><mml:mtext mathvariant="italic">class</mml:mtext></mml:math><graphic xlink:href="13040_2020_219_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where <italic>a</italic><sub><italic>i</italic></sub> denote attributes as defined in the example set, <italic>v</italic><sub><italic>i</italic></sub> are values assumed for the prediciton, and <italic>c</italic><italic>l</italic><italic>a</italic><italic>s</italic><italic>s</italic> is the predicted class. For each <italic>c</italic><italic>l</italic><italic>a</italic><italic>s</italic><italic>s</italic>, the algorithm first considers an empty set of conditions on the left-hand side. Such a rule will trivially predict <italic>c</italic><italic>l</italic><italic>a</italic><italic>s</italic><italic>s</italic> for all examples, which will typically be incorrect. The set of conditions thus needs to be iteratively extended until the rule has sufficient quality, i.e., it avoids enough out-of-class examples while retaining the class prediction for sufficiently many in-class examples. The addition of a condition into a rule is called rule refinement. An applied refinement may turn out unsuitable even with additional refinements, a high-quality rule is not found. Thus the algorithm can backtrack and search an alternative refinement. The exact succession of these operations is prescribed by the Beam search heuristic [<xref ref-type="bibr" rid="CR28">28</xref>]. When a rule is accepted and the training set still contains <italic>c</italic><italic>l</italic><italic>a</italic><italic>s</italic><italic>s</italic> examples not predicted by it, a new rule is searched. The loop terminates when each positive example is predicted positive by at least one of the accepted rules.</p>
    </sec>
  </sec>
  <sec id="Sec5">
    <title>Methods</title>
    <p>We aim to learn rules similar in form to (<xref rid="Equ1" ref-type="">1</xref>), except each condition on the left-hand side will correspond to an assumed ontological term. Thus the logical conjunction will simply correspond to a set of terms. Rules will be searched only for the positive class, as any example not classified as positive is deemed negative by default (we work in the binary classification setting). Thus the <italic>c</italic><italic>l</italic><italic>a</italic><italic>s</italic><italic>s</italic> symbol in all rules will indicate the positive class, and we can drop the right-hand side of rules. Therefore, a rule in our context is simply a set of terms.</p>
    <p>Our goal is to find a set of rules which fit well a supplied training set as described above in the context of the CN2 algorithm. To this end, we introduce a special refinement operator that, due to the taxonomic nature of the assumed conditions, significantly reduces the search space of rules and consequently reduces run times of the rule learner in comparison to the traditional refinement operator without a loss of accuracy. For example, if term <italic>t</italic>1 is in the rule and the ontology prescribes that <italic>t</italic>2 is more general than <italic>t</italic>1 then adding <italic>t</italic>2 to the rule is obviously useless. We can thus safely prune from the search space all rules combining <italic>t</italic>1 and <italic>t</italic>2.</p>
    <p>Technically, the proposed ontology-based refinement operator uses two reduction procedures: a <italic>Redundant Generalization</italic> that omits candidate rules based on a relation generalization-specialization and a <italic>Redundant Non-potential</italic> that omits the candidate rules which cannot improve classification accuracy.</p>
    <sec id="Sec6">
      <title>Problem formalization</title>
      <p>To describe our rule-learning algorithm in detail, we first define a few formal concepts. We are given
<list list-type="bullet"><list-item><p>Two sets <italic>E</italic><sup>+</sup>,<italic>E</italic><sup>−</sup> of positive and negative (respectively) examples.</p></list-item><list-item><p>A set <italic>T</italic> of ontological terms with a partial order ≽ which encodes the “more general than" relation. For example, with <italic>t</italic>1=<italic>biological process</italic> and <italic>t</italic>2=<italic>developmental process</italic>, we have <italic>t</italic>1≽<italic>t</italic>2.</p></list-item><list-item><p>An annotation function <italic>M</italic> which maps each example to a subset of <italic>T</italic>, i.e. <italic>M</italic>:<italic>E</italic><sup>+</sup>∪<italic>E</italic><sup>−</sup>→2<sup><italic>T</italic></sup>.</p></list-item></list></p>
      <p>From <italic>M</italic>, we can derive a reverse mapping <italic>M</italic><sup>′</sup>:<italic>T</italic>→2<sup><italic>E</italic></sup> producing the set of examples annotated with a given term, i.e. <italic>M</italic><sup>′</sup>(<italic>t</italic>)={<italic>e</italic>∈<italic>E</italic>:<italic>t</italic>⊆<italic>M</italic>(<italic>e</italic>)}. It is also useful to define the transitive closure <italic>S</italic>(<italic>t</italic>) of <italic>M</italic><sup>′</sup>(<italic>t</italic>) as the set of all examples annotated by <italic>t</italic> or any term less general than <italic>t</italic>, i.e.
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ S(t) = \bigcup_{t' \in T, t \succeq t'} M(t')  $$ \end{document}</tex-math><mml:math id="M4"><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⋃</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:mi>T</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mo>≽</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:munder><mml:mi>M</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math><graphic xlink:href="13040_2020_219_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>If <italic>t</italic> is the only term in a rule, then <italic>S</italic>(<italic>t</italic>) is the set of all examples for which the rule predicts the positive class. <italic>S</italic>(<italic>t</italic>) is also called the <italic>cover</italic> of the rule. More generally, for a rule conjoining an arbitrary set <italic>R</italic>⊆<italic>T</italic> of terms, we define the <italic>cover function</italic> as
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \Theta(R) = \bigcap_{t \in R} S(t)  $$ \end{document}</tex-math><mml:math id="M6"><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>⋂</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mi>R</mml:mi></mml:mrow></mml:munder><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:math><graphic xlink:href="13040_2020_219_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>Finally, we define a generality relation ≽<sub><italic>r</italic></sub> on rules. Let <italic>R</italic>1,<italic>R</italic>2⊆<italic>T</italic>, then <italic>R</italic>1≽<sub><italic>r</italic></sub><italic>R</italic>2 if and only if <italic>Θ</italic>(<italic>R</italic>1)⊇<italic>Θ</italic>(<italic>R</italic>2).</p>
      <sec id="d30e912">
        <title>
          <bold>Example 1</bold>
        </title>
        <p>Consider 3 hypothetical examples and 7 actual ontology terms as shown in Fig. <xref rid="Fig1" ref-type="fig">1</xref>. The term generality relation ≽ corresponds to the direction of edges from more to less general. Here we have <italic>M</italic>(<italic>e</italic><sub>1</sub>)={<italic>t</italic>4},<italic>M</italic>(<italic>e</italic><sub>2</sub>)={<italic>t</italic>5,<italic>t</italic>6},<italic>M</italic>(<italic>e</italic><sub>3</sub>)={<italic>t</italic>2}. <italic>M</italic><sup>′</sup>(<italic>t</italic>) is shown above each <italic>t</italic> box. Finally, <italic>S</italic>(<italic>t</italic>)=<italic>M</italic><sup>′</sup>(<italic>t</italic>) for <italic>t</italic>∈{<italic>t</italic>4,<italic>t</italic>5,<italic>t</italic>6} but e.g. <italic>S</italic>(<italic>t</italic>1)=<italic>M</italic><sup>′</sup>(<italic>t</italic>1)∪<italic>M</italic><sup>′</sup>(<italic>t</italic>4)={<italic>e</italic>1}.
<fig id="Fig1"><label>Fig. 1</label><caption><p>An example of partial-order binary relation ≽ over a set of terms <italic>T</italic>. The partial-ordered set is depicted in the form of a Hasse diagram. The terms and relations come from Gene Ontology. Elements in curly brackets represent examples that are associated with the individual terms according to the mapping <italic>S</italic>. In other words, the information about associations between examples and terms captured in the mapping <italic>M</italic><sup>′</sup>(<italic>t</italic>) has already been hierarchically spread over the whole ontology</p></caption><graphic xlink:href="13040_2020_219_Fig1_HTML" id="MO4"/></fig></p>
      </sec>
    </sec>
    <sec id="Sec7">
      <title>Proposed algorithm</title>
      <p>The algorithm proposed in this work induces a hypothesis from data in the form of a set of rules. To induce a hypothesis consisting of more rules we apply a covering algorithm that has its origin in the AQ family of algorithms [<xref ref-type="bibr" rid="CR29">29</xref>] and it is also used in CN2. The covering algorithm consists of two steps: (1) induce a single rule from the current set of examples, (2) exclude the examples that are covered by this single rule from the current set of examples; these two steps are iteratively applied starting with the set of all examples until all positive examples are covered or a certain number of induced rules is reached. This process is described in Algorithm 1 and that algorithm we refer to as <italic>sem1R</italic>. As an input, the following data are required: a set of positive <italic>E</italic><sup>+</sup> and negative <italic>E</italic><sup>−</sup> examples, a set of ontologies <inline-formula id="IEq1"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}$\end{document}</tex-math><mml:math id="M8"><mml:mi mathvariant="script">O</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq1.gif"/></alternatives></inline-formula>, and a maximal size of the set of induced rules <italic>k</italic>. An output is a set of induced rules. An <italic>induceSingleRule</italic> function returns the best rule based on selected evaluation function. The function <italic>induceSingleRule</italic> is described in Algorithm 2, all evaluation functions can be found in the “<xref rid="Sec11" ref-type="sec">Evaluation criteria</xref>” section.</p>
      <p>Contrary to CN2, the <italic>sem1R</italic> algorithm has the relations over terms that are explicitly specified in provided ontologies. Intuitively, if this kind of knowledge were exploited then we would expect some benefits during the process of inducing rules because the structure of terms is known. In this case, the main benefit is speeding up the process of inducing rules and removing obvious redundancy between the terms in rules. This was the main motivation for the following reduction procedures.
<graphic position="anchor" xlink:href="13040_2020_219_Figd_HTML" id="MO5"/></p>
      <sec id="Sec8">
        <title>Reduction procedures</title>
        <p>In this section, we formulate two procedures that significantly reduce a rule space in comparison with the traditional rule learning methods such as CN2.</p>
      </sec>
      <sec id="Sec9">
        <title>Redundant generalization</title>
        <p>This reduction method eliminates such terms occurring in a rule which are more general than any other term of the rule. Such terms in the rule do not affect a set of examples covered by the rule and consequently do not change its impact. Evidently, the set of covered examples is only affected by the most stringent sets of examples according to the mapping <italic>S</italic>.</p>
        <sec id="d30e1111">
          <title>
            <bold>Theorem 1</bold>
          </title>
          <p>Let <italic>R</italic>1 be a rule and suppose that term <italic>t</italic>1∈<italic>R</italic>1 and a term <italic>t</italic>2∈<italic>R</italic>1 where <italic>t</italic>1 is more general than <italic>t</italic>2. Then, the rule <italic>R</italic>1 covers an equal set of examples as a rule <inline-formula id="IEq2"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1} = R1 \backslash \{t1\}$\end{document}</tex-math><mml:math id="M10"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>R</mml:mi><mml:mn>1</mml:mn><mml:mo>∖</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq2.gif"/></alternatives></inline-formula> that does not contain <italic>t</italic>1:
<disp-formula id="Equa"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\Theta(\overline{R1}) = \Theta(R1)$$ \end{document}</tex-math><mml:math id="M12"><mml:mrow><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equa.gif" position="anchor"/></alternatives></disp-formula> and the rule <italic>R</italic>1 is called a <italic>redundant generalization</italic> of <inline-formula id="IEq3"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1}$\end{document}</tex-math><mml:math id="M14"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq3.gif"/></alternatives></inline-formula>.</p>
        </sec>
        <sec id="d30e1235">
          <title>
            <italic>Proof</italic>
          </title>
          <p>
            <graphic position="anchor" xlink:href="13040_2020_219_Fige_HTML" id="MO6"/>
          </p>
          <p>For simplicity, we take into consideration only rules with cardinality 1. Given this, mapping <italic>S</italic> can be seen as a cover operator <italic>Θ</italic> because it only makes an intersection over all sets of examples according to <italic>S</italic>. Also, a rule of cardinality 1 will be denoted as a term because we do not want to distinguish the relations over the set of terms and the set of rules. In this case, the ≽ relation over terms is equivalent to ≽<sub><italic>r</italic></sub> relation over rules. This simplification does not lose generality.</p>
          <p>A term cannot be associated with a higher number of examples than its more general counterpart. Concurrently, examples associated with a more specific term make a subset of examples associated with a more general term, written as <italic>t</italic>1≽<italic>t</italic>2⇒<italic>S</italic>(<italic>t</italic>2)⊆<italic>S</italic>(<italic>t</italic>1) where <italic>t</italic>1,<italic>t</italic>2∈<italic>T</italic>. Now, let rule <italic>R</italic>1={<italic>t</italic>1,<italic>t</italic>2} consist of two terms such that <italic>t</italic>1≽<italic>t</italic>2 and rule <inline-formula id="IEq4"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1} = \{t2\}$\end{document}</tex-math><mml:math id="M16"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq4.gif"/></alternatives></inline-formula> consists of only term <italic>t</italic>2. Then <italic>R</italic>1 covers an equal set of examples as <inline-formula id="IEq5"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1}$\end{document}</tex-math><mml:math id="M18"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq5.gif"/></alternatives></inline-formula>. This equality is proven below.
<disp-formula id="Equb"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\Theta(R1) = \Theta(\overline{R1})$$ \end{document}</tex-math><mml:math id="M20"><mml:mrow><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equb.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equc"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$S(t1) \cap S(t2) = S(t2)$$ \end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>∩</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equc.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equd"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\{e \in E: S(t2) \subseteq S(t1)\} = S(t2)$$ \end{document}</tex-math><mml:math id="M24"><mml:mrow><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mo>∈</mml:mo><mml:mi>E</mml:mi><mml:mo>:</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>⊆</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equd.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Eque"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$S(t2) = S(t2).$$ \end{document}</tex-math><mml:math id="M26"><mml:mrow><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mi>.</mml:mi></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Eque.gif" position="anchor"/></alternatives></disp-formula> □</p>
        </sec>
        <sec id="d30e1519">
          <title>
            <bold>Example 2</bold>
          </title>
          <p>Consider the ontology <italic>O</italic> and mappings <italic>M</italic>,<italic>M</italic><sup>′</sup>,<italic>S</italic> from Example 1. Let rule <italic>R</italic>1={<italic>t</italic>0,<italic>t</italic>2}, term <italic>t</italic>0 is more general than <italic>t</italic>2 (<italic>t</italic>0≽<italic>t</italic>2) and this rule covers examples <italic>e</italic>1,<italic>e</italic>2,<italic>e</italic>3 because <italic>Θ</italic>(<italic>R</italic>1)=<italic>Θ</italic>({<italic>t</italic>0,<italic>t</italic>2})=<italic>S</italic>(<italic>t</italic>0)∩<italic>S</italic>(<italic>t</italic>2)={<italic>e</italic>1,<italic>e</italic>2,<italic>e</italic>3}. Now, consider a rule <inline-formula id="IEq6"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1} = \{t2\}$\end{document}</tex-math><mml:math id="M28"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>}</mml:mo></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq6.gif"/></alternatives></inline-formula> that also covers examples <italic>e</italic>1,<italic>e</italic>2,<italic>e</italic>3 since <inline-formula id="IEq7"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\Theta (\overline {R1}) = S(t2) = \{e1, e2, e3\}$\end{document}</tex-math><mml:math id="M30"><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>S</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq7.gif"/></alternatives></inline-formula> and as we can see, term <italic>t</italic>0 occurring in the rule <italic>R</italic>1 does not influence a set of covered examples. Given this, rule <italic>R</italic>1 covers the same set of examples as rule <inline-formula id="IEq8"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1}$\end{document}</tex-math><mml:math id="M32"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq8.gif"/></alternatives></inline-formula>. For this reason, rule <italic>R</italic>1 is Redundant Generalization and rule <inline-formula id="IEq9"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {R1}$\end{document}</tex-math><mml:math id="M34"><mml:mover accent="false"><mml:mrow><mml:mi>R</mml:mi><mml:mn>1</mml:mn></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq9.gif"/></alternatives></inline-formula> is not Redundant Generalization.</p>
          <p>To achieve a non-Redundant Generalization rule, i.e. the rule where the relation ≽ does not exist between any terms in the rule, we have to apply Redundant Generalization procedure until the relation ≽ between terms in the rule has not been found. As we can see in Example <xref rid="Sec9" ref-type="sec">2</xref>, this reduction procedure decreases the cardinality (length) of the rules.</p>
        </sec>
      </sec>
      <sec id="Sec10">
        <title>Redundant non-potential</title>
        <p>In the previous case, the Redundant Generalization method reduces a rule space as a result of its ability to decrease the cardinality of rules. Specifically, this reduction capability is applied to the refinement operator that gradually extends rules by adding new terms into them. Redundant Generalization method can generate fewer candidate rules because terms that are in a relation with another term are not appended to the refined rule.</p>
        <p>Contrary to the previous method, the Redundant Non-potential method does not utilize relations among terms to reduce a rule space but compares rules with each other and removes such rules that cannot reach a higher quality value than the current best rule has. The ability to recognize non-potential rules can be used for a direct reduction of rules in a rule space and also for eliminating a number of candidate rules in a process of rules refining. Firstly, we define two types of evaluation function: <italic>Q</italic> evaluating a quality of rule based on the number of covered/uncovered examples, and <italic>Q</italic><sub><italic>p</italic></sub> that evaluates a potentially maximum quality of rule that could possibly be achieved over its future refinements. Examples of <italic>Q</italic> functions are depicted in Eqs. <xref rid="Equ11" ref-type="">11</xref>, <xref rid="Equ13" ref-type="">13</xref>, and <xref rid="Equ15" ref-type="">15</xref>. Corresponding <italic>Q</italic><sub><italic>p</italic></sub> functions are depicted in Eqs. <xref rid="Equ12" ref-type="">12</xref>, <xref rid="Equ14" ref-type="">14</xref>, and <xref rid="Equ17" ref-type="">17</xref>. For the moment, we can say that <italic>Q</italic><sub><italic>p</italic></sub> function expresses an upper boundary of a rule quality. This upper bound can be reached when we know that rule refinements can only reduce the set of examples the rule covers. Then, the best potential refinement does not lose any positive examples from the current cover while ceasing to cover all the current negative examples. A Redundant Non-potential rule and all its more specific rules can be safely disregarded in the single rule induction process because there is a guarantee that these rules cannot exceed an upper boundary of the rule quality represented by <italic>Q</italic><sub><italic>p</italic></sub>.</p>
        <p>To illustrate, consider an arbitrary rule <italic>R</italic>1 and its more specific rule <italic>R</italic>2 (<italic>R</italic>1≽<sub><italic>r</italic></sub><italic>R</italic>2) which was created by refinement operator application. <italic>R</italic>2 covers a subset of examples covered by <italic>R</italic>1 (<italic>Θ</italic>(<italic>R</italic>2)⊆<italic>Θ</italic>(<italic>R</italic>1)). Unfortunately, ACC or F1-score are not monotone functions, meaning that it is not guaranteed that <italic>R</italic>2 must always have a higher ACC or F1-score than <italic>R</italic>1. For this reason, <italic>R</italic>2 cannot be safely pruned from a rule space because it is not obvious whether other refinements of <italic>R</italic>2, which are more specific than <italic>R</italic>2, can potentially achieve a higher score than <italic>R</italic>1 even though <italic>R</italic>2 could have a worse score than <italic>R</italic>1. To prune the rule space safely, we maintain the upper bound of rule quality <italic>Q</italic><sub><italic>p</italic></sub>. Given this, if rule <italic>R</italic>2 (refinement of <italic>R</italic>1) has a lower <italic>Q</italic><sub><italic>p</italic></sub> value than <italic>R</italic>1’s value of <italic>Q</italic> then <italic>R</italic>2 is a <italic>Redundant Non-potential</italic> and this rule, along with all its more specific extensions/refinements, can be safely pruned from a rule space.</p>
        <sec id="d30e1902">
          <title>
            <bold>Theorem 2</bold>
          </title>
          <p>Let <inline-formula id="IEq10"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {R} = &lt;R, \succeq _{r}&gt;$\end{document}</tex-math><mml:math id="M36"><mml:mi mathvariant="script">R</mml:mi><mml:mo>=</mml:mo><mml:mo>&lt;</mml:mo><mml:mi>R</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mo>≽</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>&gt;</mml:mo></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq10.gif"/></alternatives></inline-formula> be a quasi-ordered set representing a rule space, where <italic>R</italic>={<italic>R</italic>1,<italic>R</italic>2,<italic>R</italic><sub><italic>best</italic></sub>}. Binary relation ≽<sub><italic>r</italic></sub> is defined on <italic>R</italic>1 and <italic>R</italic>2 as ≽<sub><italic>r</italic></sub>={(<italic>R</italic>1,<italic>R</italic>2)} meaning that <italic>R</italic>2 is more specific than <italic>R</italic>1; relation of <italic>R</italic><sub><italic>best</italic></sub> is disregarded - may be arbitrary. If potential quality (<italic>Q</italic><sub><italic>p</italic></sub>) of the rule <italic>R</italic>1 is smaller than the quality <italic>Q</italic> of rule <italic>R</italic><sub><italic>best</italic></sub> then the rule <italic>R</italic>1 and all its potential more specific rules, i.e. <italic>R</italic>2, can be pruned from the set of rules <italic>R</italic> thus from the rule space <inline-formula id="IEq11"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {R}$\end{document}</tex-math><mml:math id="M38"><mml:mi mathvariant="script">R</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq11.gif"/></alternatives></inline-formula>. Then the rules <italic>R</italic>1 and <italic>R</italic>2 are called <italic>Redundant Non-potentials</italic>.</p>
        </sec>
        <sec id="d30e2032">
          <title>
            <italic>Proof</italic>
          </title>
          <p>First of all, suppose that a target class is represented by positive examples. Secondly, suppose an evaluation function whose highest value is returned when all positive examples and none of the negative examples are covered. An example of this function can be ACC or F1-score. Note, that ACC is given by equation <italic>T</italic><italic>P</italic>+<italic>T</italic><italic>N</italic>/(<italic>T</italic><italic>P</italic>+<italic>T</italic><italic>N</italic>+<italic>F</italic><italic>P</italic>+<italic>F</italic><italic>N</italic>) (see the “<xref rid="Sec11" ref-type="sec">Evaluation criteria</xref>” section) and the reason, why we affect only <italic>TP</italic> and not <italic>TN</italic>, is simple. An example that is classified as <italic>TP</italic> has to be covered by a rule. On the other hand, an example classified as <italic>TN</italic> does not have to be covered by a rule. Since we focus on the target class, an arbitrary rule reaches a higher score if a new rule covers the same set of positive examples as a rule and does not cover any other negative example. □</p>
        </sec>
        <sec id="d30e2085">
          <title>
            <bold>Example 3</bold>
          </title>
          <p>Consider the ontology <italic>O</italic> and mappings <italic>M</italic>,<italic>M</italic><sup>′</sup>,<italic>S</italic> from Example 1, and two rules <italic>R</italic>1={<italic>t</italic>2} and <italic>R</italic>2={<italic>t</italic>3}. Further, we define a set of positive examples <italic>E</italic><sup>+</sup>={<italic>e</italic>1,<italic>e</italic>3} and a set of negative examples <italic>E</italic><sup>−</sup>={<italic>e</italic>2}. Firstly, we evaluate the quality of the rules according to ACC measure (see Eq. <xref rid="Equ11" ref-type="">11</xref>)
<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  {Q_{ACC}(R1) = \frac{TP + TN}{TP + TN + FP + FN} = \frac{2 + 0}{2 + 0 + 1 + 0} = \frac{2}{3}} \end{array} $$ \end{document}</tex-math><mml:math id="M40"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ACC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula></p>
          <p>
            <disp-formula id="Equ5">
              <label>5</label>
              <alternatives>
                <tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}} Q_{ACC}(R2) = \frac{TP + TN}{TP + TN + FP + FN} = \frac{0 + 0}{0 + 0 + 1 + 2} = 0 \end{array} $$ \end{document}</tex-math>
                <mml:math id="M42">
                  <mml:mtable class="eqnarray" columnalign="left center right">
                    <mml:mtr>
                      <mml:mtd class="eqnarray-1">
                        <mml:msub>
                          <mml:mrow>
                            <mml:mi>Q</mml:mi>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mtext mathvariant="italic">ACC</mml:mtext>
                          </mml:mrow>
                        </mml:msub>
                        <mml:mo>(</mml:mo>
                        <mml:mi>R</mml:mi>
                        <mml:mn>2</mml:mn>
                        <mml:mo>)</mml:mo>
                        <mml:mo>=</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mtext mathvariant="italic">TP</mml:mtext>
                            <mml:mo>+</mml:mo>
                            <mml:mtext mathvariant="italic">TN</mml:mtext>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mtext mathvariant="italic">TP</mml:mtext>
                            <mml:mo>+</mml:mo>
                            <mml:mtext mathvariant="italic">TN</mml:mtext>
                            <mml:mo>+</mml:mo>
                            <mml:mtext mathvariant="italic">FP</mml:mtext>
                            <mml:mo>+</mml:mo>
                            <mml:mtext mathvariant="italic">FN</mml:mtext>
                          </mml:mrow>
                        </mml:mfrac>
                        <mml:mo>=</mml:mo>
                        <mml:mfrac>
                          <mml:mrow>
                            <mml:mn>0</mml:mn>
                            <mml:mo>+</mml:mo>
                            <mml:mn>0</mml:mn>
                          </mml:mrow>
                          <mml:mrow>
                            <mml:mn>0</mml:mn>
                            <mml:mo>+</mml:mo>
                            <mml:mn>0</mml:mn>
                            <mml:mo>+</mml:mo>
                            <mml:mn>1</mml:mn>
                            <mml:mo>+</mml:mo>
                            <mml:mn>2</mml:mn>
                          </mml:mrow>
                        </mml:mfrac>
                        <mml:mo>=</mml:mo>
                        <mml:mn>0</mml:mn>
                      </mml:mtd>
                    </mml:mtr>
                  </mml:mtable>
                </mml:math>
                <graphic xlink:href="13040_2020_219_Article_Equ5.gif" position="anchor"/>
              </alternatives>
            </disp-formula>
          </p>
          <p>Now, we compute a potential quality score of <italic>R</italic>2 (see Eq. <xref rid="Equ12" ref-type="">12</xref>):
<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{p\_ACC}(R2) = \frac{TP + TN + FP}{TP + TN + FP + FN}= \frac{0 + 0 + 1}{0 + 0 + 1 + 2} = \frac{1}{3} \end{array} $$ \end{document}</tex-math><mml:math id="M44"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_ACC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mn>2</mml:mn><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula></p>
          <p>Evidently, the potential quality of <italic>R</italic>2 is smaller than the quality of <italic>R</italic>1 so we can exclude the rule <italic>R</italic>2 and all its more specific rules (e.g. {<italic>t</italic>5,<italic>t</italic>6}) from the rule space. Note that an example of how to compute evaluation measures can be found in the next section.</p>
          <p>To achieve the most effective pruning of rule space, we store a value of the highest quality rule that has been discovered during the learning process in <inline-formula id="IEq12"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST\_SCORE}$\end{document}</tex-math><mml:math id="M46"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST_SCORE</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq12.gif"/></alternatives></inline-formula> variable, see Algorithm 2. If the potential quality (<italic>Q</italic><sub><italic>p</italic></sub>(<italic>R</italic>)) of currently examined rule <italic>R</italic> is less than the <inline-formula id="IEq13"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST\_SCORE}$\end{document}</tex-math><mml:math id="M48"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST_SCORE</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq13.gif"/></alternatives></inline-formula>, then the rule <italic>R</italic> and all its more specifics rules are <italic>Redundant Non-potential</italic> and can be excluded from a rule space.</p>
        </sec>
      </sec>
    </sec>
    <sec id="Sec11">
      <title>Evaluation criteria</title>
      <p>It is necessary to know the quality of each rule because the rule with the highest value is needed for the final hypothesis. In this case, we define three evaluation functions: accuracy (ACC), F1-score (F1), area under the ROC curve (AUC), and their adjusted versions for evaluating the potentially best results that the current rule can achieve after refinements in future evaluations. Accuracy works well for balanced problems (the number of positive examples is similar to the number of negative ones) and both classes are equally important. F1 and AUC help when dealing with imbalanced classes, F1 puts more emphasis on the positive class.</p>
      <p>First of all, we define four elements of confusion matrix: number of true positives (TP), number of false positives (FP), number of false negatives (FN), and number of true negatives (TN) examples that are covered by an arbitrary rule <italic>R</italic>, see Fig. <xref rid="Fig2" ref-type="fig">2</xref>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>A graph representing a set of positive examples <italic>P</italic> and negative examples <italic>N</italic> and the way they are covered by a rule <italic>R</italic> assuming that <italic>R</italic> is focused on the classification of positive examples. Subspaces corresponding to TP, FP, FN and TN examples are also depicted</p></caption><graphic xlink:href="13040_2020_219_Fig2_HTML" id="MO7"/></fig></p>
      <p>TP is given as a cardinality of the intersection of two sets, a set of examples that are covered by the rule <italic>R</italic> and a set of positive examples <italic>E</italic><sup>+</sup>. FP is given as a cardinality of the intersection of two sets, a set of examples that are covered by the rule <italic>R</italic> and a set of negative examples <italic>E</italic><sup>−</sup>. TN is given as a cardinality of the subtraction of two set, a set of negative examples <italic>E</italic><sup>−</sup> and a set of examples that are covered by the rule <italic>R</italic>. Finally, FN is given as a cardinality of subtraction of two sets, a set of positive examples <italic>E</italic><sup>+</sup> and a set of examples that are covered by the rule <italic>R</italic>. All equations are shown below.
<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  TP = |\Theta(R) \cap E^{+}| \end{array} $$ \end{document}</tex-math><mml:math id="M50"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>∩</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mo>|</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>
        <disp-formula id="Equ8">
          <label>8</label>
          <alternatives>
            <tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}} FP = |\Theta(R) \cap E^{-}| \end{array} $$ \end{document}</tex-math>
            <mml:math id="M52">
              <mml:mtable class="eqnarray" columnalign="left center right">
                <mml:mtr>
                  <mml:mtd class="eqnarray-1">
                    <mml:mtext mathvariant="italic">FP</mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:mi>Θ</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>R</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mo>∩</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>E</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>−</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
            <graphic xlink:href="13040_2020_219_Article_Equ8.gif" position="anchor"/>
          </alternatives>
        </disp-formula>
      </p>
      <p>
        <disp-formula id="Equ9">
          <label>9</label>
          <alternatives>
            <tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}} TN = |E^{-} \backslash \Theta(R)| \end{array} $$ \end{document}</tex-math>
            <mml:math id="M54">
              <mml:mtable class="eqnarray" columnalign="left center right">
                <mml:mtr>
                  <mml:mtd class="eqnarray-1">
                    <mml:mtext mathvariant="italic">TN</mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>E</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>−</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>∖</mml:mo>
                    <mml:mi>Θ</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>R</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
            <graphic xlink:href="13040_2020_219_Article_Equ9.gif" position="anchor"/>
          </alternatives>
        </disp-formula>
      </p>
      <p>
        <disp-formula id="Equ10">
          <label>10</label>
          <alternatives>
            <tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}} FN = |E^{+} \backslash \Theta(R)| \end{array} $$ \end{document}</tex-math>
            <mml:math id="M56">
              <mml:mtable class="eqnarray" columnalign="left center right">
                <mml:mtr>
                  <mml:mtd class="eqnarray-1">
                    <mml:mtext mathvariant="italic">FN</mml:mtext>
                    <mml:mo>=</mml:mo>
                    <mml:mo>|</mml:mo>
                    <mml:msup>
                      <mml:mrow>
                        <mml:mi>E</mml:mi>
                      </mml:mrow>
                      <mml:mrow>
                        <mml:mo>+</mml:mo>
                      </mml:mrow>
                    </mml:msup>
                    <mml:mo>∖</mml:mo>
                    <mml:mi>Θ</mml:mi>
                    <mml:mo>(</mml:mo>
                    <mml:mi>R</mml:mi>
                    <mml:mo>)</mml:mo>
                    <mml:mo>|</mml:mo>
                  </mml:mtd>
                </mml:mtr>
              </mml:mtable>
            </mml:math>
            <graphic xlink:href="13040_2020_219_Article_Equ10.gif" position="anchor"/>
          </alternatives>
        </disp-formula>
      </p>
      <p>Corresponding accuracy (ACC) of an arbitrary rule <italic>R</italic> can be computed by the widely known equation below:
<disp-formula id="Equ11"><label>11</label><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{ACC}(R) = \frac{TP + TN}{TP + TN + FP + FN} \end{array} $$ \end{document}</tex-math><mml:math id="M58"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ACC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ11.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>However, the potentially highest accuracy of rule refined from <italic>R</italic> is computed differently. In Eq. <xref rid="Equ11" ref-type="">11</xref>, we see that the eventual accuracy is given by the numerator (TP and TN) whereas the denominator has the normalization function. The refinement may improve the rule quality in such a way that the examples that are classified as FP will be re-classified to TN, i.e. the numerator of <inline-formula id="IEq14"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$Q_{p\_ACC}$\end{document}</tex-math><mml:math id="M60"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_ACC</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq14.gif"/></alternatives></inline-formula> may at best be given by the sum of TN, TP, and FP. The equation for the potentially highest quality reached through refinement follows:
<disp-formula id="Equ12"><label>12</label><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{p\_ACC}(R) = \frac{TP + TN + FP}{TP + TN + FP + FN} \end{array} $$ \end{document}</tex-math><mml:math id="M62"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_ACC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ12.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>The computation of <inline-formula id="IEq15"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$Q_{p\_ACC}$\end{document}</tex-math><mml:math id="M64"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_ACC</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq15.gif"/></alternatives></inline-formula> in Eq. <xref rid="Equ12" ref-type="">12</xref> assumes that the rule <italic>R</italic> aims to cover positive examples rather than negative ones. In other words, examples that are covered by the rule <italic>R</italic> are classified as positive. Secondly, we propose another evaluation measure that is based on <italic>F</italic>1-score that implicitly does not take into account the number of TNs. Its common form is depicted in Eq. <xref rid="Equ13" ref-type="">13</xref>.
<disp-formula id="Equ13"><label>13</label><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{F1}(R) = \frac{2 \times TP}{2 \times TP + FP + FN} \end{array} $$ \end{document}</tex-math><mml:math id="M66"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ13.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>The corresponding version of potentially best accurate rule created by applying refinement operator to rule <italic>R</italic> that is based on the <italic>F</italic>1 measure takes the following form:
<disp-formula id="Equ14"><label>14</label><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{p\_F1}(R) = \frac{2 \times TP}{2 \times TP + FN} \end{array} $$ \end{document}</tex-math><mml:math id="M68"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_</mml:mtext><mml:mi>F</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ14.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where all negative examples covered by rule <italic>R</italic> (FP) are excluded from the denominator in comparison with Eq. <xref rid="Equ13" ref-type="">13</xref>. Since there is still the possibility of finding such a rule which covers all examples determined as TP and none of the FPs.</p>
      <sec id="d30e2997">
        <title>
          <bold>Example 4</bold>
        </title>
        <p>Consider the ontology <italic>O</italic> and mappings <italic>M</italic>,<italic>M</italic><sup>′</sup>,<italic>S</italic> from Example 1, and a set of positive (<italic>E</italic><sup>+</sup>) and negative (<italic>E</italic><sup>−</sup>) examples from Example 3. Further, we define a rule <italic>R</italic>={<italic>t</italic>2}. First of all, we find examples that are covered by the rule using <italic>Θ</italic> operator, i.e. <italic>Θ</italic>({<italic>t</italic>2})=<italic>S</italic>(<italic>t</italic>2)={<italic>e</italic>1,<italic>e</italic>2,<italic>e</italic>3}. Secondly, we compute TP, FP, FN and TN:
<disp-formula id="Equf"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$TP = |\Theta(r) \cap E^{+}| = |\{e1, e2, e3\} \cap \{e1, e3\}| = 2$$ \end{document}</tex-math><mml:math id="M70"><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo><mml:mo>∩</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>∩</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equf.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equg"><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$FP = |\Theta(r) \cap E^{-}| = |\{e1, e2, e3\} \cap \{e2\}| = 1$$ \end{document}</tex-math><mml:math id="M72"><mml:mrow><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo><mml:mo>∩</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo></mml:mrow></mml:msup><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>∩</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equg.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equh"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$TN = |E^{-} \backslash \Theta(r)| = |\{e2\} \cap \{e1, e2, e3\}| = 0$$ \end{document}</tex-math><mml:math id="M74"><mml:mrow><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mo>−</mml:mo></mml:mrow></mml:msup><mml:mo>∖</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>}</mml:mo><mml:mo>∩</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equh.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equi"><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$FN = |E^{+} \backslash \Theta(r)| = |\{e1, e3\} \cap \{e1, e2, e3\}| = 0$$ \end{document}</tex-math><mml:math id="M76"><mml:mrow><mml:mtext mathvariant="italic">FN</mml:mtext><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup><mml:mo>∖</mml:mo><mml:mi>Θ</mml:mi><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>∩</mml:mo><mml:mo>{</mml:mo><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mi>e</mml:mi><mml:mn>3</mml:mn><mml:mo>}</mml:mo><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equi.gif" position="anchor"/></alternatives></disp-formula> Finally, we substitute these numbers in Eqs. <xref rid="Equ11" ref-type="">11</xref> and <xref rid="Equ12" ref-type="">12</xref>:
<disp-formula id="Equj"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$Q_{ACC}(R) = \frac{TP + TN}{TP + TN + FP + FN} = \frac{2 + 0}{2 + 0 + 1 + 0} = \frac{2}{3}$$ \end{document}</tex-math><mml:math id="M78"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">ACC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equj.gif" position="anchor"/></alternatives></disp-formula><disp-formula id="Equk"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$Q_{p\_ACC}(R) = \frac{TP + TN + FP}{TP + TN + FP + FN}= \frac{0 + 0 + 1}{0 + 0 + 1 + 2} = \frac{1}{3}$$ \end{document}</tex-math><mml:math id="M80"><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_ACC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>0</mml:mn><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equk.gif" position="anchor"/></alternatives></disp-formula> The final ACC of rule <italic>R</italic> over the set of positive and negative examples is <inline-formula id="IEq16"><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {2}{3}$\end{document}</tex-math><mml:math id="M82"><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq16.gif"/></alternatives></inline-formula> and the potential best ACC for the set rule and the set of examples is <inline-formula id="IEq17"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {1}{3}$\end{document}</tex-math><mml:math id="M84"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq17.gif"/></alternatives></inline-formula>.</p>
        <p>Finally, let us give the rule quality in terms of AUC. The area under the curve can be computed easily. Since only the single rule is taken into consideration, its quality is determined by a single point in the ROC plot and it can be computed as a sum of areas of two triangles and one rectangle using an Eq. <xref rid="Equ15" ref-type="">15</xref>.
<disp-formula id="Equ15"><label>15</label><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{AUC}(R) = FPR \times TPR + (1-FPR) \times TPR + \frac{(1-FPR) \times (1-TPR)}{2} \end{array} $$ \end{document}</tex-math><mml:math id="M86"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">AUC</mml:mtext></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>R</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">FPR</mml:mtext><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">TPR</mml:mtext><mml:mo>+</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext mathvariant="italic">FPR</mml:mtext><mml:mo>)</mml:mo><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">TPR</mml:mtext><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext mathvariant="italic">FPR</mml:mtext><mml:mo>)</mml:mo><mml:mo>×</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mtext mathvariant="italic">TPR</mml:mtext><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ15.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>TPR (true positive rate) and FPR (false positive rate) are calculated as follows:
<disp-formula id="Equ16"><label>16</label><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  TPR=\frac{TP}{TP+FN}, FPR=\frac{FP}{FP+TN} \end{array} $$ \end{document}</tex-math><mml:math id="M88"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:mtext mathvariant="italic">TPR</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mtext mathvariant="italic">FPR</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">FP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ16.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>
          <disp-formula id="Equ17">
            <label>17</label>
            <alternatives>
              <tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}}  Q_{p\_AUC}(R) = TPR + \frac{(1-TPR)}{2} \end{array} $$ \end{document}</tex-math>
              <mml:math id="M90">
                <mml:mtable class="eqnarray" columnalign="left center right">
                  <mml:mtr>
                    <mml:mtd class="eqnarray-1">
                      <mml:msub>
                        <mml:mrow>
                          <mml:mi>Q</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>p</mml:mi>
                          <mml:mtext>_AUC</mml:mtext>
                        </mml:mrow>
                      </mml:msub>
                      <mml:mo>(</mml:mo>
                      <mml:mi>R</mml:mi>
                      <mml:mo>)</mml:mo>
                      <mml:mo>=</mml:mo>
                      <mml:mtext mathvariant="italic">TPR</mml:mtext>
                      <mml:mo>+</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mo>(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:mtext mathvariant="italic">TPR</mml:mtext>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                      </mml:mfrac>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:math>
              <graphic xlink:href="13040_2020_219_Article_Equ17.gif" position="anchor"/>
            </alternatives>
          </disp-formula>
        </p>
        <p>The adjusted version of AUC computing a potentially best AUC that a rule can achieve is shown in Eq. <xref rid="Equ17" ref-type="">17</xref>. In contrast to Eq. <xref rid="Equ15" ref-type="">15</xref>, <inline-formula id="IEq18"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$Q_{p\_AUC}$\end{document}</tex-math><mml:math id="M92"><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mtext>_AUC</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq18.gif"/></alternatives></inline-formula> supposes that FPR goes to zero.</p>
      </sec>
    </sec>
    <sec id="Sec12">
      <title>Feature construction</title>
      <p>In the Problem definition section, we defined the rule space <inline-formula id="IEq19"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {R}$\end{document}</tex-math><mml:math id="M94"><mml:mi mathvariant="script">R</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq19.gif"/></alternatives></inline-formula> as a quasi-ordered set that is expressed as a pair of a set of rules and the relation ≽<sub><italic>r</italic></sub> between rules. In addition, the form of rules is determined by propositional logic; more precisely, the rule is restricted to a conjunction of positive terms, i.e.
<disp-formula id="Equl"><alternatives><tex-math id="M95">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$R=t1 \wedge t2 = \{t1,t2\}, t1,t2 \in O.$$ \end{document}</tex-math><mml:math id="M96"><mml:mrow><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mo>∧</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>t</mml:mi><mml:mn>2</mml:mn><mml:mo>∈</mml:mo><mml:mi>O.</mml:mi></mml:mrow></mml:math><graphic xlink:href="13040_2020_219_Article_Equl.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>The first step in the rule learning process is feature construction because rule learning employs features as their basic building blocks. In this work, features are constructed trivially from a set of terms <italic>T</italic> which comes from the ontology <italic>O</italic> where each ontology term corresponds to one feature.</p>
    </sec>
    <sec id="Sec13">
      <title>Feature selection</title>
      <p>Oftentimes, a constructed feature set is extremely large and also redundant since it contains many features that are not associated with any example. For this reason, a feature selection method is highly recommended. Given this, we propose three various feature selection methods.</p>
      <sec id="Sec14">
        <title>FS_atLeastOne</title>
        <p>The first feature selection method excludes such terms from a constructed feature set which are not associated with at least one example from a set <italic>E</italic><sup>+</sup>∪<italic>E</italic><sup>−</sup>. In other words, this feature selection method removes such terms that are highly specific or do not cover any example. This method guarantees that removed terms cannot positively affect the final evaluation score of a rule because these terms cover an empty set of examples. For this reason, if such terms appeared in a rule then the rule would cover an empty set of examples.</p>
      </sec>
      <sec id="Sec15">
        <title>FS_onlySig</title>
        <p>The second feature selection method preserves only features whose terms are significant. P-values are calculated using a Likelihood Ratio Statistic (LRS) as is presented in [<xref ref-type="bibr" rid="CR20">20</xref>]. The LRS for the two-class problem measures differences between two distributions: the positive and negative class probability distribution within the set of covered examples and the distribution over the whole example set. It is computed as follows:
<disp-formula id="Equ18"><label>18</label><alternatives><tex-math id="M97">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{@{}rcl@{}} LRS(r) = 2 \times \left(TP \times log_{2} \frac{\frac{TP}{TP+TN}}{\frac{TP+FN}{|E|}} + TN \times log_{2} \frac{\frac{TN}{TP+TN}}{\frac{FP+TN}{|E|}} \right) \end{array} $$ \end{document}</tex-math><mml:math id="M98"><mml:mtable class="eqnarray" columnalign="left center right"><mml:mtr><mml:mtd class="eqnarray-1"><mml:mtext mathvariant="italic">LRS</mml:mtext><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">lo</mml:mtext><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">FN</mml:mtext></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext><mml:mo>×</mml:mo><mml:mtext mathvariant="italic">lo</mml:mtext><mml:msub><mml:mrow><mml:mi>g</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">TP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">FP</mml:mtext><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">TN</mml:mtext></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>E</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mfrac></mml:mrow></mml:mfenced></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13040_2020_219_Article_Equ18.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>This measure is distributed approximately as <italic>χ</italic><sup>2</sup> distribution with 1 degree of freedom for two classes. If the LRS is above the specific significance threshold then the term is considered to be significant.</p>
      </sec>
      <sec id="Sec16">
        <title>FS_sigAtLeastOne</title>
        <p>The third feature selection method combines the two previous feature selection methods. A term that belongs to the feature set has to satisfy two conditions: 1) that term covers at least one example, and 2) the term is significant which is calculated by the LRS or the term is a generalization of some significant term. This method combines requirements from the previous two selection methods, its selectivity will be experimentally verified later.</p>
      </sec>
    </sec>
    <sec id="Sec17">
      <title>Rule construction</title>
      <p>Rule construction is the second step which aims to find a rule that optimizes a given quality criterion in the search space of rules.</p>
      <p>The description of the algorithm for single rule learning is depicted in Algorithm 2 where input is a set of positive examples <italic>E</italic><sup>+</sup>, a set of negative examples <italic>E</italic><sup>−</sup>, a set of ontologies <inline-formula id="IEq20"><alternatives><tex-math id="M99">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}$\end{document}</tex-math><mml:math id="M100"><mml:mi mathvariant="script">O</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq20.gif"/></alternatives></inline-formula>, a function <italic>buildMapping</italic> that creates a link between the ontology and the set of examples <italic>E</italic> (<italic>E</italic>=<italic>E</italic><sup>+</sup>∪<italic>E</italic><sup>−</sup>), and a parameter <italic>k</italic> that represents the maximal length of induced rules. Note that this function is defined manually by a user. The first step in Algorithm 2 is to find all features. This operation is represented by the function <italic>featureConstruction</italic> at line 4 that assigns all terms from the set of ontologies <inline-formula id="IEq21"><alternatives><tex-math id="M101">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}$\end{document}</tex-math><mml:math id="M102"><mml:mi mathvariant="script">O</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq21.gif"/></alternatives></inline-formula> to a set of features <inline-formula id="IEq22"><alternatives><tex-math id="M103">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {F}$\end{document}</tex-math><mml:math id="M104"><mml:mi>F</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq22.gif"/></alternatives></inline-formula>. To remove irrelevant features from the set of features <inline-formula id="IEq23"><alternatives><tex-math id="M105">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {F}$\end{document}</tex-math><mml:math id="M106"><mml:mi>F</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq23.gif"/></alternatives></inline-formula>, we propose a function <italic>featureSelection</italic> at line 5. Here, three various feature selection methods are provided as we mentioned in the “<xref rid="Sec13" ref-type="sec">Feature selection</xref>” section, i.e. <italic>FS_atLeastOne</italic>, <italic>FS_onlySig</italic>, and <italic>FS_sigAtLeastOne</italic>.</p>
      <p>The main part of this algorithm is presented in lines 8-24. In this while loop, candidate rules are gradually refined until the maximal length of the rule is reached (<italic>l</italic> variable represents the current length of rule) or there is nothing to refine, i.e. the algorithm did not create any new rule in the previous iteration. In the for loop (lines 11-21), new candidate rules are generated using the application of the refinement operator on the corresponding parental rules. The algorithm iterates over each rule that is presented in the set of rules <inline-formula id="IEq24"><alternatives><tex-math id="M107">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}$\end{document}</tex-math><mml:math id="M108"><mml:mi>R</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq24.gif"/></alternatives></inline-formula>. To this rule, we apply a new ontology-based refinement operator which is represented at line 12 by the function <italic>refineRule</italic> that uses the Redundant Generalization and Redundant Non-potential reduction procedures. Similar to the traditional CN2 refinement operator, the ontology-based refinement operator appends a feature to the refined rule. For example, in the case of a conjuction of terms <italic>R</italic>={<italic>t</italic>1,<italic>t</italic>2,<italic>t</italic>3}, a new rule is created as the union of term <italic>t</italic>4 and terms in rule <italic>R</italic>, i.e. <italic>R</italic>_<italic>n</italic><italic>e</italic><italic>w</italic>={<italic>t</italic>1,<italic>t</italic>2,<italic>t</italic>3}∪{<italic>t</italic>4}. A new refinement operator requires the following inputs: rule <italic>r</italic> to refine, a set of features <inline-formula id="IEq25"><alternatives><tex-math id="M109">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {F}$\end{document}</tex-math><mml:math id="M110"><mml:mi>F</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq25.gif"/></alternatives></inline-formula>, an ontology <inline-formula id="IEq26"><alternatives><tex-math id="M111">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}$\end{document}</tex-math><mml:math id="M112"><mml:mi mathvariant="script">O</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq26.gif"/></alternatives></inline-formula> for information about relationships, a score of the best rule <inline-formula id="IEq27"><alternatives><tex-math id="M113">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST\_SCORE}$\end{document}</tex-math><mml:math id="M114"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST_SCORE</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq27.gif"/></alternatives></inline-formula> that has been discovered, a set of positive and negative examples <italic>E</italic>, and a mapping <italic>M</italic><sup>′</sup> that represents a connection between ontologies and examples. The operator returns a set of all refined rules that are not Redundant Generalizations nor Redundant Non-potentials and assigns them to <italic>newCandidates</italic> set.</p>
      <p>The <italic>refineRule</italic> function that is described in Algorithm 3 starts with an empty set <inline-formula id="IEq28"><alternatives><tex-math id="M115">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {S}$\end{document}</tex-math><mml:math id="M116"><mml:mi>S</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq28.gif"/></alternatives></inline-formula> where a content of this set will be returned at the end of the function at line 10. The cycle from lines 3 to 6 appends every feature to the rule that should be refined. Up to this part, the algorithm is similar to the traditional refinement operator. However, all rules that are not <italic>Redundant Generalization</italic> are excluded from the set <inline-formula id="IEq29"><alternatives><tex-math id="M117">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {S}$\end{document}</tex-math><mml:math id="M118"><mml:mi>S</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq29.gif"/></alternatives></inline-formula> using the ontology <inline-formula id="IEq30"><alternatives><tex-math id="M119">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}$\end{document}</tex-math><mml:math id="M120"><mml:mi mathvariant="script">O</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq30.gif"/></alternatives></inline-formula> that provides relationships among terms. This is done by calling a function <italic>removeRedundGeneralizations</italic> at line 8. The function <italic>removeRedundNonPotentials</italic> removes such rules that satisfy the definition of <italic>Redundant Non-potential</italic> rules. In this case, the function continuously checks the following: 1) <inline-formula id="IEq31"><alternatives><tex-math id="M121">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$R \succeq _{r} \forall s \in \mathbbm {S} \cup R$\end{document}</tex-math><mml:math id="M122"><mml:mi>R</mml:mi><mml:msub><mml:mrow><mml:mo>≽</mml:mo></mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo>∪</mml:mo><mml:mi>R</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq31.gif"/></alternatives></inline-formula>. This is true since each element <italic>s</italic> represents a rule that is created as a refinement of rule <italic>R</italic>. 2) For each <italic>s</italic>, if its potential quality <italic>Q</italic><sub><italic>p</italic></sub>(<italic>s</italic>) is less than the quality <inline-formula id="IEq32"><alternatives><tex-math id="M123">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$Q(\mathbbm {R}_{BEST})$\end{document}</tex-math><mml:math id="M124"><mml:mi>Q</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST</mml:mtext></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq32.gif"/></alternatives></inline-formula> then remove <italic>s</italic> and all its more specific rules from the set <inline-formula id="IEq33"><alternatives><tex-math id="M125">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {S}$\end{document}</tex-math><mml:math id="M126"><mml:mi>S</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq33.gif"/></alternatives></inline-formula>. In other words, all rules in <inline-formula id="IEq34"><alternatives><tex-math id="M127">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {S}$\end{document}</tex-math><mml:math id="M128"><mml:mi>S</mml:mi></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq34.gif"/></alternatives></inline-formula> whose potential quality can be greater than the rule with the greatest quality <inline-formula id="IEq35"><alternatives><tex-math id="M129">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST}$\end{document}</tex-math><mml:math id="M130"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq35.gif"/></alternatives></inline-formula> are preserved.</p>
      <p>All candidate rules that were generated in <italic>refineRule</italic> function are assigned to the set of new rules <inline-formula id="IEq36"><alternatives><tex-math id="M131">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{new}$\end{document}</tex-math><mml:math id="M132"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">new</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq36.gif"/></alternatives></inline-formula>. In addition, all <italic>newCandidates</italic> are evaluated by the function <italic>evaluateCandidate</italic> and its corresponding quality score is compared to the rule with the highest quality stored in a <inline-formula id="IEq37"><alternatives><tex-math id="M133">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST\_SCORE}$\end{document}</tex-math><mml:math id="M134"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST_SCORE</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq37.gif"/></alternatives></inline-formula>. If such a compared rule has a better quality then this rule is assigned to the <inline-formula id="IEq38"><alternatives><tex-math id="M135">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST}$\end{document}</tex-math><mml:math id="M136"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq38.gif"/></alternatives></inline-formula> variable and the score is stored in the <inline-formula id="IEq39"><alternatives><tex-math id="M137">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathbbm {R}_{BEST\_SCORE}$\end{document}</tex-math><mml:math id="M138"><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">BEST_SCORE</mml:mtext></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13040_2020_219_Article_IEq39.gif"/></alternatives></inline-formula> variable. Simultaneously, the rule has to be significant. To compute this significance, we use LRS as we did in feature selection.</p>
      <p>At the end of the algorithm, the best rule of the all rules that have been discovered is returned. If the function <italic>filterRules</italic> at line 22 is omitted then the Algorithm 2 is called a <italic>brute-force exhaustive search</italic> that explores the whole search space and leads to a combinatorial explosion. For this reason, an appropriate heuristics should be provided for reducing the search space. In this work, we use Beam search that expands only the most promising rules based on the evaluation function. Other rules are disregarded.
<graphic position="anchor" xlink:href="13040_2020_219_Figf_HTML" id="MO8"/></p>
    </sec>
  </sec>
  <sec id="Sec18">
    <title>Results and discussion</title>
    <p>In this section, we propose an evaluation procedure that experimentally confirms the efficiency of the new ontology-based refinement operator using two reduction procedures: the <italic>Redundant Generalization</italic> and the <italic>Redundant Non-potential</italic>. The algorithm with the ontology-based operator is called <italic>sem1R</italic> and it is compared against the traditional refinement operator used in CN2, which does not exploit any external knowledge during the rule refining process. Here, it is called <italic>exhaustive refinement</italic>. The ability to reduce a search space is tested on three different datasets with three feature selection methods (<italic>FS_atLeastOne</italic>, <italic>FS_onlySig</italic>, and <italic>FS_sigAtLeastOne</italic>) and with three different evaluation functions (ACC, AUC, and F1-score). Observed parameters as a total number of explored rules, which must be refined to find the best rule, and also run times, were measured for the <italic>sem1R</italic> and <italic>exhaustive refinement</italic>. All presented algorithms are implemented in C++ and work with the Open Biological and Biomedical Ontology (OBO) format. Note that the algorithms require at least one ontology.</p>
    <p>Because the proposed algorithm requires three inputs, we define their format as it is used in our R package. The datasets are represented as a two-dimensional binary matrix <italic>D</italic> with <italic>i</italic> rows, <italic>j</italic> columns, a set of row ontologies <italic>R</italic>, and a set of column ontologies <italic>C</italic>. The mapping <italic>M</italic><sup>′</sup> is constructed such that each row and column is associated with a subset of ontology terms. This construction step has to be done manually by a user based on expert knowledge. In practice, it is necessary to have specific identifiers for rows and columns and these identifiers are associated with corresponding ontology terms. In gene expression analysis, such an identifier can be gene ID (e.g. FBgn for Drosophila melanogaster, ENSB for human or mouse musculus) for rows and sample ID (e.g. FBbt for anatomy compartments of Drosophila melanogaster or Experimental Factor Ontology for experiment metadata) for columns.</p>
    <p>To transform a dataset from a two-dimensional binary matrix to the set of positive and negative examples, we design the following procedure. First of all, we suppose that each element of the matrix <italic>D</italic> represents one example. Then all matrix elements containing 1s are assigned to the set of positive examples <italic>E</italic><sup>+</sup> and elements with 0s are assigned to the set of negative examples <italic>E</italic><sup>−</sup>. For a non-binary matrix <italic>D</italic>, binarization is necessary.</p>
    <p>The first tested dataset comes from [<xref ref-type="bibr" rid="CR30">30</xref>] and describes the gene expression of imaginal discs of Drosophila melanogaster (DISC) where rows of the dataset correspond to genes and columns correspond to samples. Note that this format is used for all tested datasets. Rows (genes) of DISC dataset are described by Gene ontology [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>] and KEGG BRITE database. Columns (samples) are described by Drosophila anatomy ontology (DAO) [<xref ref-type="bibr" rid="CR31">31</xref>]. The second dataset called Dresden Ovary Table (DOT) [<xref ref-type="bibr" rid="CR32">32</xref>, <xref ref-type="bibr" rid="CR33">33</xref>] describes gene expression and RNA localization in fly ovaries using Gene ontology, KEGG BRITE database, and an ontology provided by the authors is freely available at [<xref ref-type="bibr" rid="CR33">33</xref>], respectively. Note that DOT and DISC are originally formed as a binary matrix. Last but not least, the third dataset was downloaded via Expression Atlas [<xref ref-type="bibr" rid="CR34">34</xref>] where it is called <italic>Strand-specific RNA-seq of nine mouse tissues</italic>[<xref ref-type="bibr" rid="CR35">35</xref>] (m2801) and using Gene ontology and Experimental Factor Ontology (EFO) [<xref ref-type="bibr" rid="CR36">36</xref>]. For binarization, we set up cutoff to 0.5 TPM (Transcripts Per Kilobase Million) because it is presented as a default value in Expression Atlas and it maintains comparable numbers of positive and negative examples. If a value in the matrix is higher than 0.5 TPM then the value is set to 1 and the element is assigned as a positive example otherwise the value is 0 and the element goes to the set of negative examples <italic>E</italic><sup>−</sup>.</p>
    <p>Also, it may be desirable to find descriptive rules only for pre-defined rows (genes) or columns (samples) that are relevant to specific research. Specifically, it can be significantly expressed genes in a treatment group against the control group. In this case, the matrix <italic>D</italic> has only <italic>i</italic><sub><italic>s</italic></sub> rows corresponding to significantly expressed genes and <italic>j</italic><sub><italic>t</italic></sub> columns corresponding to samples belonging to the treatment group and <italic>j</italic><sub><italic>c</italic></sub> columns belong the control group. Here, each of the elements belonging to the treatment group is set up to 1 and is considered to be positive, others are 0 which means negatives. The total number of examples is <italic>i</italic><sub><italic>s</italic></sub>×<italic>j</italic><sub><italic>t</italic></sub> and <italic>i</italic><sub><italic>s</italic></sub>×<italic>j</italic><sub><italic>c</italic></sub> for positive and negative examples, respectively.</p>
    <p>Basic statistics of tested datasets, as a number of rows and columns, a number of positive and negative examples, and a number of ontology terms for given ontologies, are depicted in Table <xref rid="Tab1" ref-type="table">1</xref>. Because there are some terms that do not associate with any example and such terms are not good candidates to be a feature since they do not cover any example, the final feature sets can be given by one of the three feature selection methods mentioned in the “<xref rid="Sec13" ref-type="sec">Feature selection</xref>” section. The numbers of features that were used for each rule induction step are shown in Fig <xref rid="Fig3" ref-type="fig">3</xref>.
<fig id="Fig3"><label>Fig. 3</label><caption><p>An average number of features across DISC, DOT, and m2801 datasets for three various feature selection methods <italic>FS_atLeastOne</italic>, <italic>FS_onlySig</italic>, and <italic>FS_sigAtLeastOne</italic>. These results were computed using three evaluation functions ACC, AUC, and F1-score</p></caption><graphic xlink:href="13040_2020_219_Fig3_HTML" id="MO9"/></fig><table-wrap id="Tab1"><label>Table 1</label><caption><p>Statistics for DOT, DISC, and m2801 dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"><bold>Dataset</bold></th><th align="left"><bold>Size</bold></th><th align="left"><bold># of pos/neg examples</bold></th><th align="left"><bold># of ontology terms</bold></th></tr></thead><tbody><tr><td align="left">DOT</td><td align="left">6,510 ×100</td><td align="left">309,593/341,407</td><td align="left">42,964 (GO)/32,488 (BRITE)/140 (DOT)</td></tr><tr><td align="left">DISC</td><td align="left">1,207 ×72</td><td align="left">65,537/21,367</td><td align="left">42,964 (GO)/32,488 (BRITE)/9,255 (DAO)</td></tr><tr><td align="left">m2801</td><td align="left">12,225 ×26</td><td align="left">124,032/193,818</td><td align="left">42,964 (GO)/18,786 (EFO)</td></tr></tbody></table></table-wrap></p>
    <p>These experiments clearly confirm our presumptions, defined in the “<xref rid="Sec13" ref-type="sec">Feature selection</xref>” section, where we assumed that the most reducing feature selection method is <italic>FS_onlySig</italic>. On the other hand, the most benevolent or conservative method is <italic>FS_atLeastOne</italic>, which guarantees that any of the relevant features possibly positively affecting the quality score of the hypothesis will not be discarded from the feature set. The <italic>FS_sigAtLeastOne</italic> demonstrates a similar behavior to <italic>FS_atLeastOne</italic>. Concretely, the <italic>FS_sigAtLeastOne</italic> method produces a smaller feature set than <italic>FS_atLeastOne</italic>. However, the differences are not huge.</p>
    <p>To avoid a combinatorial explosion problem in exploring the rule space, we use a Beam search which is represented by <italic>filterRules</italic> function in Algorithm 2. The width of the beam was set no higher than the 100 best rules, the rules are sorted according to their quality score calculated with one of the given evaluation functions. We decided to use this threshold, because greater beam widths result in huge run times in <italic>exhaustive refinement</italic>. Higher beam widths also increase memory requirements. At the same time, the ability of <italic>sem1R</italic> to reduce the search space and consequently reduce run time is obvious even below the beam width of 100. Theoretically, it is anticipated that the ability to reduce a search space grows with the beam width since there are potentially more rules to prune especially for <italic>Redundant Non-potential</italic> procedure.</p>
    <p>Total run time and total number of explored rules were observed for rules with the maximum length of 10 because longer rules can be more difficult to interpret in real problems, especially in a biology domain. The total number of induced rules for each dataset was set to 10, for the same reason as previously mentioned. The final results of experiments as total run time in seconds and total number of explored rules are depicted in Table <xref rid="Tab2" ref-type="table">2</xref> for <italic>sem1R</italic> and in Table <xref rid="Tab3" ref-type="table">3</xref> for <italic>exhaustive refinement</italic>.
<table-wrap id="Tab2"><label>Table 2</label><caption><p>Total runtime [s] and a total number of explored rules of sem1R algorithm for DOT, DISC, and m2801 dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"><bold>Dataset</bold></th><th align="left"><bold>Feature selection</bold></th><th align="left" colspan="2"><bold>ACC score</bold></th><th align="left" colspan="2"><bold>F1 score</bold></th><th align="left" colspan="2"><bold>AUC score</bold></th></tr><tr><th align="left"/><th align="left"/><th align="left"><bold>Total time</bold></th><th align="left"><bold># of rules</bold></th><th align="left"><bold>Total time</bold></th><th align="left"><bold># of rules</bold></th><th align="left"><bold>Total time</bold></th><th align="left"><bold># ofrules</bold></th></tr></thead><tbody><tr><td align="left">DOT</td><td align="left"><italic>FS_atLeastOne</italic></td><td align="left">303.636</td><td align="left">107,964</td><td align="left">22.381</td><td align="left">26,460</td><td align="left">142.302</td><td align="left">52,638</td></tr><tr><td align="left"/><td align="left"><italic>FS_onlySig</italic></td><td align="left">235.947</td><td align="left">54,167</td><td align="left">11.427</td><td align="left">9,780</td><td align="left">102.760</td><td align="left">25,817</td></tr><tr><td align="left"/><td align="left"><italic>FS_sigAtLeastOne</italic></td><td align="left">250.633</td><td align="left">107,535</td><td align="left">19.813</td><td align="left">25,756</td><td align="left">115.994</td><td align="left">52,136</td></tr><tr><td align="left">DISC</td><td align="left"><italic>FS_atLeastOne</italic></td><td align="left">10.737</td><td align="left">102,219</td><td align="left">8.059</td><td align="left">178,346</td><td align="left">60.780</td><td align="left">609,937</td></tr><tr><td align="left"/><td align="left"><italic>FS_onlySig</italic></td><td align="left">1.777</td><td align="left">87,671</td><td align="left">1.109</td><td align="left">7,223</td><td align="left">33.304</td><td align="left">67,558</td></tr><tr><td align="left"/><td align="left"><italic>FS_sigAtLeastOne</italic></td><td align="left">1.955</td><td align="left">13,041</td><td align="left">1.330</td><td align="left">11,270</td><td align="left">25.861</td><td align="left">91,003</td></tr><tr><td align="left">m2801</td><td align="left"><italic>FS_atLeastOne</italic></td><td align="left">699.273</td><td align="left">461,745</td><td align="left">28.087</td><td align="left">80,079</td><td align="left">168.210</td><td align="left">225,081</td></tr><tr><td align="left"/><td align="left"><italic>FS_onlySig</italic></td><td align="left">914.283</td><td align="left">340,039</td><td align="left">21.594</td><td align="left">18,787</td><td align="left">148.992</td><td align="left">82,456</td></tr><tr><td align="left"/><td align="left"><italic>FS_sigAtLeastOne</italic></td><td align="left">802.176</td><td align="left">433,393</td><td align="left">18.939</td><td align="left">32,054</td><td align="left">123.561</td><td align="left">124,002</td></tr></tbody></table></table-wrap><table-wrap id="Tab3"><label>Table 3</label><caption><p>Total runtime [s] and the total number of explored rules of exhaustive refinement for DOT, DISC, and m2801 dataset</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"><bold>Dataset</bold></th><th align="left"><bold>Feature selection</bold></th><th align="left" colspan="2"><bold>ACC score</bold></th><th align="left" colspan="2"><bold>F1 score</bold></th><th align="left" colspan="2"><bold>AUC score</bold></th></tr><tr><th align="left"/><th align="left"/><th align="left"><bold>total time</bold></th><th align="left"><bold># of rules</bold></th><th align="left"><bold>total time</bold></th><th align="left"><bold># of rules</bold></th><th align="left"><bold>total time</bold></th><th align="left"><bold># of rules</bold></th></tr></thead><tbody><tr><td align="left">DOT</td><td align="left"><italic>FS_atLeastOne</italic></td><td align="left">33,800.529</td><td align="left">62,192,307</td><td align="left">12,807.090</td><td align="left">21,977,679</td><td align="left">22,814.993</td><td align="left">37,604,456</td></tr><tr><td align="left"/><td align="left"><italic>FS_onlySig</italic></td><td align="left">15,849.761</td><td align="left">30,991,466</td><td align="left">5,049.444</td><td align="left">8,075,976</td><td align="left">9,042.203</td><td align="left">15,672,577</td></tr><tr><td align="left"/><td align="left"><italic>FS_sigAtLeastOne</italic></td><td align="left">33,638.549</td><td align="left">61,912,986</td><td align="left">12,743.265</td><td align="left">21,674,132</td><td align="left">22,726.459</td><td align="left">37,176,099</td></tr><tr><td align="left">DISC</td><td align="left"><italic>FS_atLeastOne</italic></td><td align="left">996.587</td><td align="left">10,681,537</td><td align="left">881.007</td><td align="left">11,017,701</td><td align="left">2,214.819</td><td align="left">38,874,717</td></tr><tr><td align="left"/><td align="left"><italic>FS_onlySig</italic></td><td align="left">623.078</td><td align="left">6,125,970</td><td align="left">524.412</td><td align="left">6,041,883</td><td align="left">1,323.920</td><td align="left">21,618,242</td></tr><tr><td align="left"/><td align="left"><italic>FS_sigAtLeastOne</italic></td><td align="left">963.291</td><td align="left">9,406,704</td><td align="left">817.055</td><td align="left">9,484,372</td><td align="left">2,145.880</td><td align="left">37,172,305</td></tr><tr><td align="left">m2801</td><td align="left"><italic>FS_atLeastOne</italic></td><td align="left">53,163.030</td><td align="left">153,778,914</td><td align="left">6,573.700</td><td align="left">26,766,658</td><td align="left">12,766.542</td><td align="left">64,329,543</td></tr><tr><td align="left"/><td align="left"><italic>FS_onlySig</italic></td><td align="left">29,641.080</td><td align="left">86,150,004</td><td align="left">3,873.421</td><td align="left">14,168,195</td><td align="left">6,741.368</td><td align="left">29,298,233</td></tr><tr><td align="left"/><td align="left"><italic>FS_sigAtLeastOne</italic></td><td align="left">53,019.570</td><td align="left">153,255,327</td><td align="left">6,431.049</td><td align="left">25,255,830</td><td align="left">12,391.710</td><td align="left">59,322,805</td></tr></tbody></table></table-wrap></p>
    <p>A graphical representation is shown in Figs. <xref rid="Fig4" ref-type="fig">4</xref> and <xref rid="Fig5" ref-type="fig">5</xref>. The first one shows run times in logarithmic scale depending on the number of induced rules for <italic>sem1R</italic> (dashed line) and <italic>exhaustive refinement</italic> (full line). Run time was measured for three datasets with three different evaluation functions and with three different feature selection methods. Evidently, in all cases, the run time of <italic>sem1R</italic> is significantly lower. Figure <xref rid="Fig5" ref-type="fig">5</xref> shows the total number of rules that have been evaluated in a logarithmic scale that depends on the number of rules. As in the previous figure, the number of rules was measured for three datasets with three different evaluation functions and with three different feature selection methods. But even in this case, <italic>sem1R</italic> with its <italic>Redundant Generalization</italic> and <italic>Redundant Non-potential</italic> procedures prunes the rule space more rapidly in comparison with the traditional <italic>exhaustive refinement</italic>. Note that using <italic>FS_onlySig</italic> method, the smallest number of rules is evaluated. This corresponds to the results in Fig. <xref rid="Fig3" ref-type="fig">3</xref>.
<fig id="Fig4"><label>Fig. 4</label><caption><p>Total run time in logarithmic scale scale depending on the number of induced rules for three datasets (DISC, DOT, and m2801). ACC, AUC, and F1-score were used for evaluating the quality of rules and three feature selection methods (<italic>FS_atLeastOne</italic>, <italic>FS_onlySig</italic>, and <italic>FS_sigAtLeastOne</italic>) were applied before rule induction. Dashed line represents <italic>sem1R</italic>, full line represents <italic>exhaustive refinement</italic></p></caption><graphic xlink:href="13040_2020_219_Fig4_HTML" id="MO10"/></fig><fig id="Fig5"><label>Fig. 5</label><caption><p>Total number of candidate rules in logarithmic scale depending on the number of induced rules for three datasets (DISC, DOT, and m2801). ACC, AUC, and F1-score were used for evaluating the quality of rules and three feature selection methods (<italic>FS_atLeastOne</italic>, <italic>FS_onlySig</italic>, and <italic>FS_sigAtLeastOne</italic>) were applied before rule induction. Dashed line represents <italic>sem1R</italic>, full line represents <italic>exhaustive refinement</italic></p></caption><graphic xlink:href="13040_2020_219_Fig5_HTML" id="MO11"/></fig></p>
    <p>In all various experimental settings, both <italic>exhaustive refinement</italic> and <italic>sem1R</italic> induce rules with the same quality score across corresponding experiments. The level of significance was set to 99% for feature selection method <italic>FS_onlySig</italic> and <italic>FS_sigAtLeastOne</italic> and also the same significance level for finding the best rule in <italic>induceSingleRule</italic> function. From Figs. <xref rid="Fig4" ref-type="fig">4</xref> and <xref rid="Fig5" ref-type="fig">5</xref> it is obvious that F1-score prunes the search space most and the run of the algorithm is fastest. One of the reasons is that only TP, FP, and FN must be calculated here. On the other hand, AUC is less strict in the pruning of the search space and it is also the slowest, because Eqs. <xref rid="Equ15" ref-type="">15</xref>, <xref rid="Equ16" ref-type="">16</xref> and <xref rid="Equ17" ref-type="">17</xref> have to be calculated for every candidate solution and the algorithm has to evaluate the highest number of candidate rules. There is a clear trade-off between the efficiency and complexity of evaluation that stands behind AUC. All results of the experiments are appended to Additional file <xref rid="MOESM1" ref-type="media">1</xref>.</p>
    <p>For illustration and better understanding, we present an example of 2-terms long rule induced from the DISC dataset, where each term comes from a different ontology. The rule is following: GO:0002181 AND FBbt:00000015. This reported rule is enriched (it covers far more positive examples than expected by random). The FBbt identifier refers to a term from Drosophila anatomy ontology and the GO identifier refers to a term from Gene ontology. In this particular case, the rule says that all genes that are associated with a cytoplasmic translation process (the chemical reactions and pathways resulting in the formation of a protein in the cytoplasm) tend to be over-represented in thorax segment of Drosophila melanogaster.</p>
  </sec>
  <sec id="Sec19" sec-type="conclusion">
    <title>Conclusion</title>
    <p>We proposed and implemented a new rule learning algorithm that induces a set of rules related to ontologies or taxonomies. Using two novel reduction procedures <italic>Redundant Generalization</italic> and <italic>Redundant Non-potential</italic>, which are part of the proposed ontology-based refinement operator, we dramatically reduce the search space. Consequently, runtime of the algorithm is decreased rapidly as well. These procedures guarantee that any removed rule cannot positively affect the quality of the final hypothesis. Also, three various feature selection methods that help to increase the efficiency of the algorithm were proposed. The algorithm is implemented in C++ and it is available at <ext-link ext-link-type="uri" xlink:href="http://github.com/fmalinka/sem1r">http://github.com/fmalinka/sem1r</ext-link> as R package. We demonstrated our algorithm on three real gene expression datasets, however, it is generally applicable to any learning task that combines measurements and ontologies, including metabolomics, etc.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec20">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="13040_2020_219_MOESM1_ESM.xlsx">
            <caption>
              <p><bold>Additional file 1</bold> All experiment measurements. Excel file contains all presented measurements for DISC, DOT, and m2801 dataset.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s13040-020-00219-6.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>Supported by grant NU20-03-00412 from the Ministry of Health of the Czech Republic, SGS17/189/OHK3/3T/13, and Research Center for Informatics CZ.02.1.01/0.0/0.0/16_019/0000765.</p>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>FM proposed, implemented, tested the algorithms, and drafted the manuscript. JK and FZ reviewed and edited the manuscript. JK and FZ motivated the research problem and JK led the project. All authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>Supported by grant NU20-03-00412 from the Ministry of Health of the Czech Republic, SGS17/189/OHK3/3T/13, and Research Center for Informatics CZ.02.1.01/0.0/0.0/16_019/0000765.</p>
  </notes>
  <notes notes-type="data-availability">
    <title>Availability of data and materials</title>
    <p>The datasets generated during and/or analysed during the current study are available at the GitHub repository, [<ext-link ext-link-type="uri" xlink:href="http://github.com/fmalinka/sem1r">http://github.com/fmalinka/sem1r</ext-link>]</p>
  </notes>
  <notes id="FPar1">
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar2">
    <title>Consent for publication</title>
    <p>Not applicable.</p>
  </notes>
  <notes id="FPar3" notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stevens</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Goble</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Bechhofer</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Ontology-based knowledge representation for bioinformatics</article-title>
        <source>Brief Bioinform</source>
        <year>2000</year>
        <volume>1</volume>
        <issue>4</issue>
        <fpage>398</fpage>
        <lpage>414</lpage>
        <pub-id pub-id-type="doi">10.1093/bib/1.4.398</pub-id>
        <pub-id pub-id-type="pmid">11465057</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Österlund</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Cvijovic</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kristiansson</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Integrative analysis of omics data</article-title>
        <source>Syst Biol</source>
        <year>2017</year>
        <volume>6</volume>
        <fpage>1</fpage>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rajasundaram</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Selbig</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>More effort—more results: recent advances in integrative ’omics’ data analysis</article-title>
        <source>Curr Opin Plant Biol</source>
        <year>2016</year>
        <volume>30</volume>
        <fpage>57</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1016/j.pbi.2015.12.010</pub-id>
        <pub-id pub-id-type="pmid">26890084</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ashburner</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Rosse</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Bard</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Bug</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Ceusters</surname>
            <given-names>W</given-names>
          </name>
          <name>
            <surname>Goldberg</surname>
            <given-names>LJ</given-names>
          </name>
          <name>
            <surname>Eilbeck</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Ireland</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Mungall</surname>
            <given-names>CJ</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The obo foundry: coordinated evolution of ontologies to support biomedical data integration</article-title>
        <source>Nat Biotechnol</source>
        <year>2007</year>
        <volume>25</volume>
        <issue>11</issue>
        <fpage>1251</fpage>
        <pub-id pub-id-type="doi">10.1038/nbt1346</pub-id>
        <pub-id pub-id-type="pmid">17989687</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Subramanian</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Tamayo</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Mootha</surname>
            <given-names>VK</given-names>
          </name>
          <name>
            <surname>Mukherjee</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ebert</surname>
            <given-names>BL</given-names>
          </name>
          <name>
            <surname>Gillette</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Paulovich</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pomeroy</surname>
            <given-names>SL</given-names>
          </name>
          <name>
            <surname>Golub</surname>
            <given-names>TR</given-names>
          </name>
          <name>
            <surname>Lander</surname>
            <given-names>ES</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Gene set enrichment analysis: a knowledge-based approach for interpreting genome-wide expression profiles</article-title>
        <source>Proc Nat Acad Sci</source>
        <year>2005</year>
        <volume>102</volume>
        <issue>43</issue>
        <fpage>15545</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.0506580102</pub-id>
        <pub-id pub-id-type="pmid">16199517</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ashburner</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Ball</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Blake</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Botstein</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Butler</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Cherry</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>AP</given-names>
          </name>
          <name>
            <surname>Dolinski</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Dwight</surname>
            <given-names>SS</given-names>
          </name>
          <name>
            <surname>Eppig</surname>
            <given-names>JT</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Gene ontology: tool for the unification of biology</article-title>
        <source>Nat Genet</source>
        <year>2000</year>
        <volume>25</volume>
        <issue>1</issue>
        <fpage>25</fpage>
        <pub-id pub-id-type="doi">10.1038/75556</pub-id>
        <pub-id pub-id-type="pmid">10802651</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Consortium</surname>
            <given-names>GO</given-names>
          </name>
        </person-group>
        <article-title>Expansion of the gene ontology knowledgebase and resources</article-title>
        <source>Nucleic Acids Res</source>
        <year>2016</year>
        <volume>45</volume>
        <issue>D1</issue>
        <fpage>331</fpage>
        <lpage>8</lpage>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fuerkranz</surname>
            <given-names>J.</given-names>
          </name>
          <name>
            <surname>Gamberger</surname>
            <given-names>D.</given-names>
          </name>
          <name>
            <surname>Lavrac</surname>
            <given-names>N.</given-names>
          </name>
        </person-group>
        <source>Foundations of Rule Learning</source>
        <year>2012</year>
        <publisher-loc>Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kotsiantis</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Zaharakis</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Pintelas</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Supervised machine learning: A review of classification techniques</article-title>
        <source>Emerg Artif Intell Appl Comput Eng</source>
        <year>2007</year>
        <volume>160</volume>
        <fpage>3</fpage>
        <lpage>24</lpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hvidsten</surname>
            <given-names>TR</given-names>
          </name>
          <name>
            <surname>Lægreid</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Komorowski</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Learning rule-based models of biological process from gene expression time profiles using gene ontology</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>9</issue>
        <fpage>1116</fpage>
        <lpage>23</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btg047</pub-id>
        <pub-id pub-id-type="pmid">12801872</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Calzone</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Chabrier-Rivier</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Fages</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Soliman</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Machine learning biochemical networks from temporal logic properties</article-title>
        <source>Transactions on Computational Systems Biology VI</source>
        <year>2006</year>
        <publisher-loc>Berlin</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bellazzi</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Zupan</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Predictive data mining in clinical medicine: current issues and guidelines</article-title>
        <source>Int J Med Inform</source>
        <year>2008</year>
        <volume>77</volume>
        <issue>2</issue>
        <fpage>81</fpage>
        <lpage>97</lpage>
        <pub-id pub-id-type="doi">10.1016/j.ijmedinf.2006.11.006</pub-id>
        <pub-id pub-id-type="pmid">17188928</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kanehisa</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Furumichi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tanabe</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sato</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Morishima</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Kegg: new perspectives on genomes, pathways, diseases and drugs</article-title>
        <source>Nucleic Acids Res</source>
        <year>2016</year>
        <volume>45</volume>
        <issue>D1</issue>
        <fpage>353</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkw1092</pub-id>
        <pub-id pub-id-type="pmid">27899587</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kanehisa</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Sato</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Kawashima</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Furumichi</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tanabe</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Kegg as a reference resource for gene and protein annotation</article-title>
        <source>Nucleic Acids Res</source>
        <year>2015</year>
        <volume>44</volume>
        <issue>D1</issue>
        <fpage>457</fpage>
        <lpage>62</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkv1070</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kanehisa</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Goto</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Kegg: kyoto encyclopedia of genes and genomes</article-title>
        <source>Nucleic Acids Res</source>
        <year>2000</year>
        <volume>28</volume>
        <issue>1</issue>
        <fpage>27</fpage>
        <lpage>30</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/28.1.27</pub-id>
        <pub-id pub-id-type="pmid">10592173</pub-id>
      </element-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schriml</surname>
            <given-names>LM</given-names>
          </name>
          <name>
            <surname>Arze</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Nadendla</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chang</surname>
            <given-names>Y-WW</given-names>
          </name>
          <name>
            <surname>Mazaitis</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Felix</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Feng</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kibbe</surname>
            <given-names>WA</given-names>
          </name>
        </person-group>
        <article-title>Disease ontology: a backbone for disease semantic integration</article-title>
        <source>Nucleic Acids Res</source>
        <year>2011</year>
        <volume>40</volume>
        <issue>D1</issue>
        <fpage>940</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkr972</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kibbe</surname>
            <given-names>WA</given-names>
          </name>
          <name>
            <surname>Arze</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Felix</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Mitraka</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Bolton</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Fu</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Mungall</surname>
            <given-names>CJ</given-names>
          </name>
          <name>
            <surname>Binder</surname>
            <given-names>JX</given-names>
          </name>
          <name>
            <surname>Malone</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Vasant</surname>
            <given-names>D</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Disease ontology 2015 update: an expanded and updated database of human diseases for linking biomedical knowledge through disease data</article-title>
        <source>Nucleic Acids Res</source>
        <year>2014</year>
        <volume>43</volume>
        <issue>D1</issue>
        <fpage>1071</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gku1011</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Miller</surname>
            <given-names>GA</given-names>
          </name>
        </person-group>
        <article-title>Wordnet: a lexical database for english</article-title>
        <source>Commun ACM</source>
        <year>1995</year>
        <volume>38</volume>
        <issue>11</issue>
        <fpage>39</fpage>
        <lpage>41</lpage>
        <pub-id pub-id-type="doi">10.1145/219717.219748</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Suchanek</surname>
            <given-names>FM</given-names>
          </name>
          <name>
            <surname>Kasneci</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Weikum</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Yago: a core of semantic knowledge</article-title>
        <source>Proceedings of the 16th International Conference on World Wide Web</source>
        <year>2007</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Clark</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Niblett</surname>
            <given-names>T</given-names>
          </name>
        </person-group>
        <article-title>The cn2 induction algorithm</article-title>
        <source>Mach Learn</source>
        <year>1989</year>
        <volume>3</volume>
        <issue>4</issue>
        <fpage>261</fpage>
        <lpage>83</lpage>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Cohen</surname>
            <given-names>WW</given-names>
          </name>
        </person-group>
        <article-title>Fast effective rule induction</article-title>
        <source>Machine Learning Proceedings 1995</source>
        <year>1995</year>
        <publisher-loc>San Francisco</publisher-loc>
        <publisher-name>Morgan Kaufmann</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kléma</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Malinka</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>železný</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Semantic biclustering for finding local, interpretable and predictive expression patterns</article-title>
        <source>BMC Genomics</source>
        <year>2017</year>
        <volume>18</volume>
        <issue>7</issue>
        <fpage>41</fpage>
        <pub-id pub-id-type="pmid">28061804</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <mixed-citation publication-type="other">Clark P, Boswell R. Rule induction with cn2: Some recent improvements. In: European Working Session on Learning. Springer: 1991. p. 151–63. 10.1007/bfb0017011.</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Friedman</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Fisher</surname>
            <given-names>NI</given-names>
          </name>
        </person-group>
        <article-title>Bump hunting in high-dimensional data</article-title>
        <source>Stat Comput</source>
        <year>1999</year>
        <volume>9</volume>
        <issue>2</issue>
        <fpage>123</fpage>
        <lpage>43</lpage>
        <pub-id pub-id-type="doi">10.1023/A:1008894516817</pub-id>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>De Raedt</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <source>Statistical Relational Artificial Intelligence: Logic, Probability, and Computation</source>
        <year>2016</year>
        <publisher-loc>San Rafael</publisher-loc>
        <publisher-name>Morgan &amp; Claypool Publishers</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <mixed-citation publication-type="other">žáková M, železný F. Exploiting term, predicate, and feature taxonomies in propositionalization and propositional rule learning. In: Machine Learning: ECML 2007. Springer: 2007. p. 798–805. 10.1007/978-3-540-74958-5_82.</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Svatoš</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Šourek</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>železnỳ</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Schockaert</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kuželka</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>Pruning hypothesis spaces using learned domain theories</article-title>
        <source>International Conference on Inductive Logic Programming</source>
        <year>2017</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Russell</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Norvig</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <source>Artificial Intelligence: A Modern Approach (2nd Edition)</source>
        <year>2002</year>
        <publisher-loc>Upper Saddle River</publisher-loc>
        <publisher-name>Prentice Hall</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Michalski</surname>
            <given-names>RS</given-names>
          </name>
        </person-group>
        <article-title>On the quasi-minimal solution of the general covering problem</article-title>
        <source>Proceedings of the 5th International Symposium on Information Processing (FCIP-69)</source>
        <year>1969</year>
        <publisher-loc>Bled</publisher-loc>
        <publisher-name>Vol. A3 (Switching Circuits)</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Borovec</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kybic</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Binary pattern dictionary learning for gene expression representation in drosophila imaginal discs</article-title>
        <source>Asian Conference on Computer Vision</source>
        <year>2016</year>
        <publisher-loc>Cham</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Costa</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Reeve</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Grumbling</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Osumi-Sutherland</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>The drosophila anatomy ontology</article-title>
        <source>J Biomed Semant</source>
        <year>2013</year>
        <volume>4</volume>
        <issue>1</issue>
        <fpage>32</fpage>
        <pub-id pub-id-type="doi">10.1186/2041-1480-4-32</pub-id>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <mixed-citation publication-type="other">Jambor H, Surendranath V, Kalinka AT, Mejstrik P, Saalfeld S, Tomancak P. Systematic imaging reveals features and changing localization of mrnas in drosophila development. Elife. 2015; 4. 10.7554/elife.05003.</mixed-citation>
    </ref>
    <ref id="CR33">
      <label>33</label>
      <mixed-citation publication-type="other">Dresden Ovary Table. <ext-link ext-link-type="uri" xlink:href="http://tomancak-srv1.mpi-cbg.de/DOT/main">http://tomancak-srv1.mpi-cbg.de/DOT/main</ext-link>. Accessed 15 Feb 2016.</mixed-citation>
    </ref>
    <ref id="CR34">
      <label>34</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Petryszak</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Keays</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>YA</given-names>
          </name>
          <name>
            <surname>Fonseca</surname>
            <given-names>NA</given-names>
          </name>
          <name>
            <surname>Barrera</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Burdett</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Füllgrabe</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Fuentes</surname>
            <given-names>AM-P</given-names>
          </name>
          <name>
            <surname>Jupp</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Koskinen</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Expression atlas update—an integrated database of gene and protein expression in humans, animals and plants</article-title>
        <source>Nucleic Acids Res</source>
        <year>2015</year>
        <volume>44</volume>
        <issue>D1</issue>
        <fpage>746</fpage>
        <lpage>52</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkv1045</pub-id>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Merkin</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Russell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Burge</surname>
            <given-names>CB</given-names>
          </name>
        </person-group>
        <article-title>Evolutionary dynamics of gene and isoform regulation in mammalian tissues</article-title>
        <source>Science</source>
        <year>2012</year>
        <volume>338</volume>
        <issue>6114</issue>
        <fpage>1593</fpage>
        <lpage>9</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1228186</pub-id>
        <pub-id pub-id-type="pmid">23258891</pub-id>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Malone</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Holloway</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Adamusiak</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Kapushesky</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Zheng</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Kolesnikov</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Zhukova</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Brazma</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Parkinson</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Modeling sample variables with an experimental factor ontology</article-title>
        <source>Bioinformatics</source>
        <year>2010</year>
        <volume>26</volume>
        <issue>8</issue>
        <fpage>1112</fpage>
        <lpage>8</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btq099</pub-id>
        <pub-id pub-id-type="pmid">20200009</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
