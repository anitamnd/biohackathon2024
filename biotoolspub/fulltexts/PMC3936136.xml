<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">J Mol Model</journal-id>
    <journal-id journal-id-type="iso-abbrev">J Mol Model</journal-id>
    <journal-title-group>
      <journal-title>Journal of Molecular Modeling</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1610-2940</issn>
    <issn pub-type="epub">0948-5023</issn>
    <publisher>
      <publisher-name>Springer Berlin Heidelberg</publisher-name>
      <publisher-loc>Berlin/Heidelberg</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3936136</article-id>
    <article-id pub-id-type="pmid">24481593</article-id>
    <article-id pub-id-type="publisher-id">2067</article-id>
    <article-id pub-id-type="doi">10.1007/s00894-014-2067-1</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Parallel implementation of 3D protein structure similarity searches using a GPU and the CUDA</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Mrozek</surname>
          <given-names>Dariusz</given-names>
        </name>
        <address>
          <email>dariusz.mrozek@polsl.pl</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Brożek</surname>
          <given-names>Miłosz</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Małysiak-Mrozek</surname>
          <given-names>Bożena</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1">Institute of Informatics, Silesian University of Technology, Gliwice, Poland </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>31</day>
      <month>1</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>31</day>
      <month>1</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="ppub">
      <year>2014</year>
    </pub-date>
    <volume>20</volume>
    <issue>2</issue>
    <elocation-id>2067</elocation-id>
    <history>
      <date date-type="received">
        <day>7</day>
        <month>8</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>11</day>
        <month>10</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2014</copyright-statement>
      <license license-type="OpenAccess" xlink:href="https://creativecommons.org/licenses/by/2.0/">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution License which permits any use, distribution, and reproduction in any medium, provided the original author(s) and the source are credited.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p>Searching for similar 3D protein structures is one of the primary processes employed in the field of structural bioinformatics. However, the computational complexity of this process means that it is constantly necessary to search for new methods that can perform such a process faster and more efficiently. Finding molecular substructures that complex protein structures have in common is still a challenging task, especially when entire databases containing tens or even hundreds of thousands of protein structures must be scanned. Graphics processing units (GPUs) and general purpose graphics processing units (GPGPUs) can perform many time-consuming and computationally demanding processes much more quickly than a classical CPU can. In this paper, we describe the GPU-based implementation of the CASSERT algorithm for 3D protein structure similarity searching. This algorithm is based on the two-phase alignment of protein structures when matching fragments of the compared proteins. The GPU (GeForce GTX 560Ti: 384 cores, 2GB RAM) implementation of CASSERT (“GPU-CASSERT”) parallelizes both alignment phases and yields an average 180-fold increase in speed over its CPU-based, single-core implementation on an Intel Xeon E5620 (2.40GHz, 4 cores). In this paper, we show that massive parallelization of the 3D structure similarity search process on many-core GPU devices can reduce the execution time of the process, allowing it to be performed in real time. GPU-CASSERT is available at: <ext-link ext-link-type="uri" xlink:href="http://zti.polsl.pl/dmrozek/science/gpucassert/cassert.htm">http://zti.polsl.pl/dmrozek/science/gpucassert/cassert.htm</ext-link>.</p>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>3D protein structure</kwd>
      <kwd>Similarity searching</kwd>
      <kwd>Structure comparison</kwd>
      <kwd>GPU</kwd>
      <kwd>CUDA</kwd>
      <kwd>Parallel programming</kwd>
      <kwd>Structure matching</kwd>
      <kwd>Structure alignment</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© Springer-Verlag Berlin Heidelberg 2014</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1" sec-type="introduction">
    <title>Introduction</title>
    <p>Protein 3D structure similarity searching is a process in which a given protein structure is compared to another protein structure or a set of protein structures collected in a database. The aim of the process is to find fragments in common among compared protein structures, i.e., matching fragments. Based on the similarities found during this process, scientists can draw useful conclusions about the common ancestry of the proteins, and thus the organisms (that the proteins came from), their evolutionary relationships, functional similarities, the existence of common functional regions, and many other things [<xref ref-type="bibr" rid="CR1">1</xref>]. This process is especially important in situations where sequence similarity searches fail or deliver too few clues [<xref ref-type="bibr" rid="CR2">2</xref>]. There are also other processes in which protein structure similarity searching plays a supportive role, such as in the validation of predicted protein models [<xref ref-type="bibr" rid="CR3">3</xref>]. Finally, we believe that in the very near future, scientists will have the opportunity to study beautiful structures of proteins taken from a patient in a regular diagnostic procedure that will utilize comparison methods to highlight areas of the proteins that are inadequately constructed, leading to dysfunctions of the body and serious diseases. This goal is currently motivating work leading to the development of similarity searching methods that return results in real time.</p>
    <p>Although protein structure similarity searching is one of the primary tasks performed in structural bioinformatics, it is still a very difficult and time-consuming process, mainly because: (1) the 3D structures of proteins are highly complex, (2) the similarity searching process is computationally complex, and (3) the number of 3D structures stored in macromolecular data repositories such as the Protein Data Bank (PDB) [<xref ref-type="bibr" rid="CR4">4</xref>] is growing exponentially.</p>
    <p>Among these three problems, bioinformaticians can attempt to ease the second one by developing new, more efficient algorithms, and to—at least partially—help with the first one by selecting appropriately representative features of protein 3D structures that can then be fed into their algorithms. The collection of algorithms that have been developed for protein structure similarity searching over the last two decades is large, and includes methods such as VAST [<xref ref-type="bibr" rid="CR5">5</xref>], DALI [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>], LOCK2 [<xref ref-type="bibr" rid="CR8">8</xref>], FATCAT [<xref ref-type="bibr" rid="CR9">9</xref>], CTSS [<xref ref-type="bibr" rid="CR10">10</xref>], CE [<xref ref-type="bibr" rid="CR11">11</xref>], FAST [<xref ref-type="bibr" rid="CR12">12</xref>], and others [<xref ref-type="bibr" rid="CR13">13</xref>, <xref ref-type="bibr" rid="CR14">14</xref>]. These methods use various representative features when performing protein structure similarity searches in order to reduce the huge search space. For example, local geometric features and selected biological characteristics are used in the CTSS [<xref ref-type="bibr" rid="CR10">10</xref>] algorithm. Shape signatures that include information on C<sub>α</sub> atom positions, torsional angles, and types of secondary structure present are calculated for each residue in a protein structure. The DALI algorithm [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>], which is well established, compares proteins based on distance matrices built for each of the compared proteins. Each cell of a distance matrix contains the distance between the C<sub>α</sub> atoms of every pair of residues in the same structure (inter-residue distances). Fragments of 6×6 elements of the matrix are called <italic>contact patterns</italic>, which are compared between two proteins to find the best match. On the other hand, the VAST algorithm [<xref ref-type="bibr" rid="CR5">5</xref>], which is available through the website of the National Center for Biotechnology Information (NCBI), uses secondary structure elements (SSEs: α-helices and β-sheets), which form the cores of the compared proteins. These SSEs are then mapped to representative vectors, which simplifies the analysis and comparison process. During the comparison, the algorithm attempts to match vectors of pairs of protein structures. Other methods, such as LOCK2 [<xref ref-type="bibr" rid="CR8">8</xref>], also utilize the SSE representation of protein structure in the comparison process. The CE [<xref ref-type="bibr" rid="CR11">11</xref>] algorithm uses the combinatorial extension of the alignment path formed by aligned fragment pairs (AFPs). AFPs are fragments of both structures that show clear structural similarity and are described by local geometrical features, including the positions of C<sub>α</sub> atoms. The idea of AFPs is also used in FATCAT [<xref ref-type="bibr" rid="CR9">9</xref>].</p>
    <p>Even though better methods are developed every year, performing a protein structure similarity search against a whole database of protein 3D structures is still a challenge. As we showed in our previous works [<xref ref-type="bibr" rid="CR15">15</xref>, <xref ref-type="bibr" rid="CR16">16</xref>] on the effectiveness and scalability of the process, performing a search with the FATCAT algorithm for a sample query protein structure using twenty alignment agents working in parallel took 25 hours (without applying any additional acceleration techniques). Tests were carried out using a database containing 3D structures of 106,858 protein chains. This shows how time-consuming the process is, and it is one of the main motivations for designing and developing the new methods that are reported every year, such as RAPIDO [<xref ref-type="bibr" rid="CR17">17</xref>], DEDAL [<xref ref-type="bibr" rid="CR18">18</xref>], MICAN [<xref ref-type="bibr" rid="CR19">19</xref>], CASSERT [<xref ref-type="bibr" rid="CR13">13</xref>], ClusCo [<xref ref-type="bibr" rid="CR20">20</xref>], and others [<xref ref-type="bibr" rid="CR21">21</xref>, <xref ref-type="bibr" rid="CR22">22</xref>].</p>
    <p>On the other hand, the evolution of computer science and computer architectures has led to (and will continue to lead to) new hardware solutions that can be used to accelerate the 3D structure similarity searches. Recent years have shown that promising results in terms of upscaling the process and accelerating it can be obtained by using graphics processing units (GPUs) and general purpose graphics processing units (GPGPUs). GPU devices, which were originally conceived as a means to render increasingly complex computer graphics, can now be used to perform computations that are required in completely different domains. For this reason, GPU devices, especially those utilizing the NVidia Compute Unified Device Architecture (CUDA) [<xref ref-type="bibr" rid="CR23">23</xref>, <xref ref-type="bibr" rid="CR24">24</xref>], are now widely used to solve computationally intensive problems, including those encountered in bioinformatics. Given the successful applications of GPUs in the fields of sequence similarity [<xref ref-type="bibr" rid="CR25">25</xref>–<xref ref-type="bibr" rid="CR31">31</xref>], phylogenetics [<xref ref-type="bibr" rid="CR32">32</xref>], molecular dynamics [<xref ref-type="bibr" rid="CR33">33</xref>, <xref ref-type="bibr" rid="CR34">34</xref>], and microarray data analysis [<xref ref-type="bibr" rid="CR35">35</xref>], it is clear that GPU devices are beginning to play a significant role in 3D protein structure similarity searching.</p>
    <p>It is worth mentioning two GPU-based implementations of the process. These methods use different representations of protein structures and different computational procedures, but demonstrate a clear improvement in performance over CPU-based implementations. The first one, <italic>SA Tableau Search</italic>, which was first presented in [<xref ref-type="bibr" rid="CR36">36</xref>], uses simulated annealing for tableau-based protein structure similarity searching. Tableaux are based on orientations of secondary structure elements and distance matrices. The GPU-based implementation of the algorithm parallelizes two areas: multiple iterations of the simulated annealing procedure and multiple comparisons of the query protein structure to many database structures. The second one, called <italic>pssAlign</italic> [<xref ref-type="bibr" rid="CR37">37</xref>], consists of two alignment phases: <italic>fragment-level alignment</italic> and <italic>residue-level alignment</italic>. Both phases use dynamic programming. In the fragment-level alignment phase, so-called seeds between the target protein and each database protein are used to generate initial alignments. These seeds are represented by the locations of the C<sub>α</sub> atoms. The initial alignments are then refined in the residue-level alignment phase. pssAlign parallelizes both alignment phases.</p>
    <p>In the present paper, we report the GPU-based implementation of the CASSERT algorithm [<xref ref-type="bibr" rid="CR13">13</xref>] for 3D protein structure similarity searching. Like <italic>pssAlign</italic>, CASSERT is based on two-phase alignment. However, it uses an extended set of structural features to describe protein structures, and the computational procedure differs too. Both the representation of structures and the computational procedure employed by the CASSERT algorithm are presented in the next few subsections. Originally, CASSERT was designed and implemented as a CPU-based procedure, and its effectiveness is reported in [<xref ref-type="bibr" rid="CR13">13</xref>]. Its GPU-based implementation is presented in the “<xref rid="Sec7" ref-type="sec">Methods</xref>” section, and this implementation will be referred as “GPU-CASSERT” throughout the paper. Before we start to explain GPU-CASSERT, we will provide a short overview of how to perform computations using GPU devices and the CUDA architecture. Finally, in the “<xref rid="Sec13" ref-type="sec">Results</xref>” and “<xref rid="Sec14" ref-type="sec">Discussion</xref>” sections, we show that the algorithm performs fast comparisons of protein structures and that it can be used to scan protein databases in order to find similar biological molecules.</p>
    <sec id="Sec2">
      <title>Representation of protein structures in the comparison process</title>
      <p>3D protein structure similarity searching is typically realized by performing pairwise comparisons of the query protein (Q) specified by the user with successive proteins (D) from the database of protein structures. In this section, we show how protein structures are represented in both phases of the comparison process performed by the CASSERT.</p>
      <p>Let us assume that<italic> Q</italic> represents the structure of the query protein that is <italic>q</italic> residues (amino acids) long, and<italic> D</italic> is the structure of a candidate protein in the database that is <italic>d</italic> residues (amino acids) long.</p>
      <p>In the first phase of the alignment algorithm, protein structures<italic> Q</italic> and<italic> D</italic> are compared by aligning their <italic>reduced chains of secondary structures</italic> consisting of the secondary structure elements <italic>SE</italic>
<sub><italic>i</italic></sub>:<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ Q=\left(S{E}_1^Q,S{E}_2^Q,\dots, S{E}_n^Q\right), $$\end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mi>S</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mn>1</mml:mn><mml:mi>Q</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mn>2</mml:mn><mml:mi>Q</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mi>n</mml:mi><mml:mi>Q</mml:mi></mml:msubsup></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula>where <italic>n</italic> ≤ <italic>q</italic> is the number of secondary structures in the chain of the query protein<italic> Q</italic>, and<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ D=\left(S{E}_1^D,S{E}_2^D,\dots, S{E}_m^D\right), $$\end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:mi>S</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:msubsup><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mi>m</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula>where <italic>m</italic> ≤ <italic>d</italic> is the number of secondary structures in the chain of the database protein<italic> D</italic>.</p>
      <p>Each element <italic>SE</italic>
<sub><italic>i</italic></sub>, which is a part of the chain that has been selected on the basis of its secondary structure, is characterized by two values, i.e.,<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ S{E}_i=\left[ SS{E}_i,{L}_i\right], $$\end{document}</tex-math><mml:math id="M6"><mml:mrow><mml:mi>S</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfenced close="]" open="["><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>L</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>where <italic>SSE</italic>
<sub><italic>i</italic></sub> describes the type of the secondary structure selected, and <italic>L</italic>
<sub><italic>i</italic></sub> is the length of the <italic>i</italic>
<sup>th</sup> element <italic>SE</italic>
<sub><italic>i</italic></sub> (measured in residues). In the alignment method, we distinguish between three basic types of secondary structure (Fig. <xref rid="Fig1" ref-type="fig">1</xref>):<fig id="Fig1"><label>Fig. 1</label><caption><p>Secondary structure elements: (<italic>left</italic>) four α-helices in a sample structure [PDBID: 1CE9]; (<italic>right</italic>) two β-strands joined by a loop in a sample structure [PDB ID: 1E0Q]; visualized by MViewer [<xref ref-type="bibr" rid="CR38">38</xref>]. Full and reduced chains of secondary structure elements for the marked subunit (<italic>left</italic>) and the whole structure (<italic>right</italic>) are visible below</p></caption><graphic xlink:href="894_2014_2067_Fig1_HTML" id="MO1"/></fig>
<list list-type="bullet"><list-item><p>α-Helix (H)</p></list-item><list-item><p>β-Sheet or β-strand (E)</p></list-item><list-item><p>Loop, turn, coil, or undetermined structure (L)</p></list-item></list>
</p>
      <p>Elements <italic>SE</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>SE</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup>, hereafter referred to as <italic>SE</italic> regions or <italic>SE</italic> fragments, are built from groups of adjacent amino acids that form the same type of secondary structure. For example, six successive residues folded into an α-helix form one <italic>SE</italic> region. Hence, the overall protein structures are, at this stage, represented by the reduced chains of secondary structures.</p>
      <p>In the second phase of the alignment algorithm, protein structures<italic> Q</italic> and<italic> D</italic> are represented in more detail. At the residue level, successive residues are described by so-called <italic>molecular residue descriptors s</italic>
<sub><italic>i</italic></sub>. Proteins are represented as chains of descriptors <italic>s</italic>
<sub><italic>i</italic></sub>:<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ Q=\left({s}_1^Q,{s}_2^Q,\dots, {s}_q^Q\right), $$\end{document}</tex-math><mml:math id="M8"><mml:mrow><mml:mi>Q</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="(" separators=",,,"><mml:msubsup><mml:mi>s</mml:mi><mml:mn>1</mml:mn><mml:mi>Q</mml:mi></mml:msubsup><mml:msubsup><mml:mi>s</mml:mi><mml:mn>2</mml:mn><mml:mi>Q</mml:mi></mml:msubsup><mml:mo>…</mml:mo><mml:msubsup><mml:mi>s</mml:mi><mml:mi>q</mml:mi><mml:mi>Q</mml:mi></mml:msubsup></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula>where <italic>q</italic> is the length of the query protein<italic> Q</italic> (i.e., the number of residues it contains), and each <italic>s</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> corresponds to the <italic>i</italic>
<sup>th</sup> residue in the chain of protein<italic> Q</italic>,<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ D=\left({s}_1^D,{s}_2^D,\dots, {s}_d^D\right), $$\end{document}</tex-math><mml:math id="M10"><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mfenced close=")" open="(" separators=",,,"><mml:msubsup><mml:mi>s</mml:mi><mml:mn>1</mml:mn><mml:mi>D</mml:mi></mml:msubsup><mml:msubsup><mml:mi>s</mml:mi><mml:mn>2</mml:mn><mml:mi>D</mml:mi></mml:msubsup><mml:mo>…</mml:mo><mml:msubsup><mml:mi>s</mml:mi><mml:mi>d</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>where <italic>d</italic> is the length of the database protein<italic> D</italic>, and each <italic>s</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic> D</italic></sup> corresponds to the <italic>i</italic>
<sup>th</sup> residue in the chain of protein<italic> D</italic>.</p>
      <p>Each descriptor <italic>s</italic>
<sub><italic>i</italic></sub> is defined by the following vector of features:<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {s}_i=&lt;\left|{C}_i\right|,{\gamma}_i, SS{E}_i,{r}_i&gt;, $$\end{document}</tex-math><mml:math id="M12"><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>&lt;</mml:mo><mml:mfenced close="|" open="|"><mml:msub><mml:mi>C</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mfenced><mml:mo>,</mml:mo><mml:msub><mml:mi>γ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>r</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&gt;</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula>where |<italic>C</italic>
<sub><italic>i</italic></sub>| is the length of the vector between the C<sub>α</sub> atoms of the <italic>i</italic>
<sup>th</sup> and (<italic>i</italic> + 1)<sup>th</sup> amino acids in a protein chain, <italic>γ</italic>
<sub><italic>i</italic></sub> is the angle between the successive vectors <italic>C</italic>
<sub><italic>i</italic></sub> and <italic>C</italic>
<sub><italic>i</italic> + 1</sub>, <italic>SSE</italic>
<sub><italic>i</italic></sub> is the type of secondary structure formed by the <italic>i</italic>
<sup>th</sup> residue, and <italic>r</italic>
<sub><italic>i</italic></sub> is the type of amino acid represented by this residue (Fig. <xref rid="Fig2" ref-type="fig">2</xref>).<fig id="Fig2"><label>Fig. 2</label><caption><p>Structural features included in molecular residue descriptors marked on part of a sample protein structure: residue type (Met, Gln, Ile, Phe), secondary structure type (β-strand in this case), length of the vector between the C<sub>α</sub> atoms (|<italic>C</italic>
<sub><italic>i</italic></sub>|), and the <italic>γ</italic> angle</p></caption><graphic xlink:href="894_2014_2067_Fig2_HTML" id="MO2"/></fig>
</p>
    </sec>
    <sec id="Sec3">
      <title>General course of the matching method</title>
      <p>Pairwise comparisons of protein 3D structures are performed using the matching method, which consists of two phases (Fig. <xref rid="Fig3" ref-type="fig">3</xref>):<fig id="Fig3"><label>Fig. 3</label><caption><p>Overview of the two-phase alignment algorithm. In phase 1, low-resolution alignment is performed: protein structures are represented as reduced chains of secondary structures; the similarity matrix<italic> SSE</italic> used in the alignment is small—proportional to the number of secondary structures in both proteins. In phase 2, high-resolution alignment is performed: protein structures are represented as chains of molecular residue descriptors; the similarity matrix<italic> S </italic>used in the alignment is therefore large—proportional to the length of both proteins</p></caption><graphic xlink:href="894_2014_2067_Fig3_HTML" id="MO3"/></fig>
<list list-type="order"><list-item><p>The first phase involves the coarse alignment of spatial structures represented by secondary structure elements (SSEs). This is the <italic>low-resolution alignment</italic> phase, because groups of amino acids occurring in each structure are grouped into one representative element (the <italic>SE</italic> region). This phase allows us to run fast alignments in which small similarity matrices are constructed. This eliminates the need for computationally costly alignments of proteins that are entirely dissimilar. Proteins that exhibit secondary structure similarity are subjected to a more thorough analysis in the second phase.</p></list-item><list-item><p>The second phase involvs the detailed alignment of spatial structures represented by the molecular residue descriptors. This alignment is performed based on the results of the coarse alignment realized in the first phase. The second phase is the <italic>high-resolution alignment</italic> phase, because amino acids are not grouped in it. Instead, each amino acid found in the structure is represented by the corresponding molecular residue descriptor <italic>s</italic>
<sub><italic>i</italic></sub>. Therefore, we align sequences of molecular residue descriptors using much larger similarity matrices than were utilized in the first phase. In the second phase, the algorithm analyzes more features describing protein structures, and the protein itself is represented in more detail.</p></list-item></list>
</p>
      <p>In both phases, the alignments are carried out using dynamic programming procedures that are specifically adapted to the molecular descriptions of protein structures employed in each phase. The detailed courses of both alignment phases are shown in the following subsections.</p>
    </sec>
    <sec id="Sec4">
      <title>First phase: low-resolution alignment</title>
      <p>The low-resolution alignment phase is performed in order to filter out molecules that do not show secondary structural similarity. Originally, this phase was also used to establish initial alignments that were projected onto the similarity matrix in the second phase. However, since both phases are executed independently in the GPU-based implementation, we do not transfer alignment paths between alignment phases in the GPU-based approach.</p>
      <p>In order to match the structures of proteins<italic> Q</italic> and<italic> D</italic> that are represented as reduced chains of secondary structures, we build a similarity matrix<italic> SSE</italic> of size <italic>n</italic> × <italic>m</italic>, where <italic>n</italic> and <italic>m</italic> describe the number of secondary structures in the compared chains of proteins<italic> Q </italic>and<italic> D</italic>. Successive cells of the SSE matrix are filled according to the following rules:</p>
      <p>For 0 ≤ <italic>i</italic> ≤ <italic>n</italic> and 0 ≤ <italic>j</italic> ≤ <italic>m</italic>:<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ SS{E}_{i,0}= SS{E}_{0,j}=0, $$\end{document}</tex-math><mml:math id="M14"><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:malignmark/><mml:mo>=</mml:mo><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula>
<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ SS{E}_{i,j}^{(1)}= SS{E}_{i-1,j-1}+{\delta}_{ij}, $$\end{document}</tex-math><mml:math id="M16"><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mfenced close=")" open="("><mml:mn>1</mml:mn></mml:mfenced></mml:msubsup><mml:mo>=</mml:mo><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>δ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula>
<disp-formula id="Equ9"><label>9</label><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ SS{E}_{i,j}^{(2)}={E}_{i,j}, $$\end{document}</tex-math><mml:math id="M18"><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mfenced close=")" open="("><mml:mn>2</mml:mn></mml:mfenced></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ9.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>
        <disp-formula id="Equ10">
          <label>10</label>
          <alternatives>
            <tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ SS{E}_{i,j}^{(3)}={F}_{i,j}, $$\end{document}</tex-math>
            <mml:math id="M20">
              <mml:mrow>
                <mml:mi mathvariant="italic">SS</mml:mi>
                <mml:msubsup>
                  <mml:mi>E</mml:mi>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                  <mml:mfenced close=")" open="(">
                    <mml:mn>3</mml:mn>
                  </mml:mfenced>
                </mml:msubsup>
                <mml:mo>=</mml:mo>
                <mml:msub>
                  <mml:mi>F</mml:mi>
                  <mml:mrow>
                    <mml:mi>i</mml:mi>
                    <mml:mo>,</mml:mo>
                    <mml:mi>j</mml:mi>
                  </mml:mrow>
                </mml:msub>
                <mml:mo>,</mml:mo>
              </mml:mrow>
            </mml:math>
            <graphic xlink:href="894_2014_2067_Article_Equ10.gif" position="anchor"/>
          </alternatives>
        </disp-formula>
      </p>
      <p><disp-formula id="Equ11"><label>11</label><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ SS{E}_{i,j}=\underset{v=1..3}{ \max}\left\{ SS{E}_{i,j}^{(v)},0\right\}. $$\end{document}</tex-math><mml:math id="M22"><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:munder><mml:mi mathvariant="normal">max</mml:mi><mml:mrow><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>.</mml:mo><mml:mn>.3</mml:mn></mml:mrow></mml:munder><mml:mfenced close="}" open="{"><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msubsup><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mfenced close=")" open="("><mml:mi>v</mml:mi></mml:mfenced></mml:msubsup><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ11.gif" position="anchor"/></alternatives></disp-formula>where <italic>δ</italic><sub><italic>ij</italic></sub> is the similarity reward, which reflects the degree of similarity between two regions <italic>SE</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>SE</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup> of proteins<italic> Q</italic> and<italic> D</italic>, respectively, and vectors<italic> E</italic> and<italic> F</italic> are possible horizontal and vertical penalties for inserting a gap.</p>
      <p>The similarity reward <italic>δ</italic>
<sub><italic>ij</italic></sub> takes values in the interval [0,1], where 0 means no similarity and 1 means that the regions are identical. The degree of similarity is calculated using the formula<disp-formula id="Equ12"><label>12</label><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\delta}_{ij}={\sigma}_{ij}-\left({\sigma}_{ij}\frac{\left|{L}_j^D-{L}_i^Q\right|}{\left({L}_j^D+{L}_i^Q\right)}\right), $$\end{document}</tex-math><mml:math id="M24"><mml:mrow><mml:msub><mml:mi>δ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mfrac><mml:mfenced close="|" open="|"><mml:mrow><mml:msubsup><mml:mi>L</mml:mi><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>L</mml:mi><mml:mi>i</mml:mi><mml:mi>Q</mml:mi></mml:msubsup></mml:mrow></mml:mfenced><mml:mfenced close=")" open="("><mml:mrow><mml:msubsup><mml:mi>L</mml:mi><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msubsup><mml:mi>L</mml:mi><mml:mi>i</mml:mi><mml:mi>Q</mml:mi></mml:msubsup></mml:mrow></mml:mfenced></mml:mfrac></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ12.gif" position="anchor"/></alternatives></disp-formula>where <italic>L</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup>, <italic>L</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup> are the lengths of the compared regions <italic>SE</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>SE</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup>, while <italic>σ</italic>
<sub><italic>ij</italic></sub> describes the degree of similarity of the secondary structures for the <italic>i</italic> 
<sup>th</sup> and <italic>j</italic> 
<sup>th</sup>
<italic>SE</italic> regions of the compared proteins<italic> Q</italic> and<italic> D</italic>. This parameter can take three possible values, according to the following rules:<list list-type="simple"><list-item><label>(i)</label><p><italic>σ</italic><sub><italic>ij</italic></sub> = 1 when both <italic>SE</italic> regions have the same α-helix or β-strand structure</p></list-item><list-item><label>(ii)</label><p><italic>σ</italic><sub><italic>ij</italic></sub> = 0.5 when at least one of the regions is a loop, turn, coil, or its secondary structure is undefined</p></list-item><list-item><label>(iii)</label><p><italic>σ</italic><sub><italic>ij</italic></sub> = 0 when one of the regions is an α-helix and the second is a β-strand</p></list-item></list>
</p>
      <p>Values of gap penalty vectors are calculated as follows:<disp-formula id="Equ13"><label>13</label><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {E}_{i,j}= \max \left\{\begin{array}{c}\hfill {E}_{i,j-1}-{g}_E\hfill \\ {}\hfill SS{E}_{i,j-1}-{g}_O\hfill \end{array}\right., $$\end{document}</tex-math><mml:math id="M26"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">max</mml:mi><mml:mfenced close="" open="{"><mml:mtable columnalign="center"><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>O</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ13.gif" position="anchor"/></alternatives></disp-formula>
<disp-formula id="Equ14"><label>14</label><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {F}_{i,j}= \max \left\{\begin{array}{c}\hfill {F}_{i-1,j}-{g}_E\hfill \\ {}\hfill SS{E}_{i-1,j}-{g}_O\hfill \end{array}\right.. $$\end{document}</tex-math><mml:math id="M28"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">max</mml:mi><mml:mfenced close="" open="{"><mml:mtable columnalign="center"><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:msub><mml:mi>F</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>E</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr columnalign="center"><mml:mtd columnalign="center"><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mi>O</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced><mml:mo>.</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ14.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>In order to assess the similarity between two reduced chains of secondary structures, we use the <italic>Score</italic> measure, which is equal to the highest value in the similarity matrix SSE:<disp-formula id="Equ15"><label>15</label><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ Score= \max \left\{ SS{E}_{i,j}\right\}. $$\end{document}</tex-math><mml:math id="M30"><mml:mrow><mml:mi mathvariant="italic">Score</mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">max</mml:mi><mml:mfenced close="}" open="{"><mml:mrow><mml:mi mathvariant="italic">SS</mml:mi><mml:msub><mml:mi>E</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ15.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>Auxiliary vectors<italic> E</italic> and<italic> F</italic> allow us to perform the alignment procedure and to calculate the <italic>Score</italic> similarity measure in linear space, because the value of cell <italic>SSE</italic>
<sub><italic>i</italic>,<italic>j</italic></sub> depends only on the value of cell <italic>SSE</italic>
<sub><italic>i</italic> − 1,<italic>j</italic> − 1</sub>, <italic>SSE</italic>
<sub><italic>i</italic> − 1,<italic>j</italic></sub>, and <italic>SSE</italic>
<sub><italic>i</italic>,<italic>j</italic> − 1</sub>. During the calculation of the similarity matrix<italic> SSE</italic>, we must store the position of the maximum value of the <italic>Score</italic> in the matrix as well as the value itself.</p>
    </sec>
    <sec id="Sec5">
      <title>Second phase: high-resolution alignment</title>
      <p>Molecules that pass the first phase (based on the user-defined cutoff value) are further aligned in the second phase. A database protein structure qualifies for the second phase if the following condition is satisfied:<disp-formula id="Equ16"><label>16</label><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ \frac{ Scor{e}^{QD}}{ Scor{e}^{QQ}}\ge {Q}_t, $$\end{document}</tex-math><mml:math id="M32"><mml:mrow><mml:mfrac><mml:mrow><mml:mi mathvariant="italic">Scor</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mi mathvariant="italic">QD</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:mi mathvariant="italic">Scor</mml:mi><mml:msup><mml:mi>e</mml:mi><mml:mi mathvariant="italic">QQ</mml:mi></mml:msup></mml:mrow></mml:mfrac><mml:mo>≥</mml:mo><mml:msub><mml:mi>Q</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ16.gif" position="anchor"/></alternatives></disp-formula>where <italic>Score</italic>
<sup><italic>QD</italic></sup> is a similarity measure employed when matching the query protein structure to the database protein structure, <italic>Score</italic>
<sup><italic>QQ</italic></sup> is the similarity measure obtained when matching the query protein structure to itself (i.e., the maximum <italic>Score</italic> that the compared chain can achieve), and <italic>Q</italic>
<sub><italic>t</italic></sub> ∈ [0,1] is a user-defined qualification threshold for structural similarity.</p>
      <p>The second phase is carried out similarly to the first phase, except that the alignment is carried out at the residue level, where aligned molecules<italic> Q</italic> and<italic> D</italic> are represented by chains of molecular residue descriptors. However, the way that GPU-CASSERT calculates the similarity reward for the two compared residue molecular descriptors <italic>s</italic>
<sub><italic>i</italic></sub> and <italic>s</italic>
<sub><italic>j</italic></sub> is different. The similarity reward <italic>ss</italic>
<sub><italic>ij</italic></sub> is calculated according to the following formula:<disp-formula id="Equ17"><label>17</label><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ s{s}_{ij}={w}_C{\sigma}_{ij}^C+{w}_{\gamma }{\sigma}_{ij}^{\gamma }+{w}_{SSE}{\sigma}_{ij}^{SSE}+{w}_{\mathrm{r}}{\sigma}_{ij}^{\mathrm{r}}, $$\end{document}</tex-math><mml:math id="M34"><mml:mrow><mml:mi>s</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi mathvariant="italic">ij</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi>C</mml:mi></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mi mathvariant="italic">w</mml:mi><mml:mi>γ</mml:mi></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi><mml:mi>γ</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi mathvariant="italic">SSE</mml:mi></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi><mml:mi mathvariant="italic">SSE</mml:mi></mml:msubsup><mml:mo>+</mml:mo><mml:msub><mml:mi>w</mml:mi><mml:mi mathvariant="normal">r</mml:mi></mml:msub><mml:msubsup><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi><mml:mi mathvariant="normal">r</mml:mi></mml:msubsup><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ17.gif" position="anchor"/></alternatives></disp-formula>where <italic>σ</italic>
<sub arrange="stack"><italic>ij</italic></sub><sup arrange="stack"><italic>C</italic></sup> is the degree of similarity of a pair of vectors <italic>C</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>C</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup> in proteins<italic> Q</italic> and<italic> D</italic>, respectively, <italic>σ</italic>
<sub arrange="stack"><italic>ij</italic></sub><sup arrange="stack"><italic>γ</italic></sup> is the similarity of angles <italic>γ</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>γ</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup> in proteins<italic> Q</italic> and<italic> D</italic>, <italic>σ</italic>
<sub arrange="stack"><italic>ij</italic></sub><sup arrange="stack"><italic>SSE</italic></sup> is the degree of similarity of the secondary structures of residues <italic>i</italic> and <italic>j</italic> (calculated according to rules (i)–(iii) listed for the first phase), <italic>σ</italic>
<sub arrange="stack"><italic>ij</italic></sub><sup arrange="stack">r</sup> is the degree of similarity of the residues defined by means of the BLOSUM62 substitution matrix normalized to the range [0,1], and <italic>w</italic>
<sub><italic>C</italic></sub>, <italic>w</italic>
<sub><italic>γ</italic></sub>, <italic>w</italic>
<sub><italic>SSE</italic></sub>, and <italic>w</italic>
<sub>r</sub> are the weights of all of the components (with default values of 1).</p>
      <p>The similarity of vectors <italic>C</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>C</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup> is defined according to the formula:<disp-formula id="Equ18"><label>18</label><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\sigma}_{ij}^C={\mathrm{e}}^{-{\displaystyle {\left(\left|{C}_i^Q\left|-\right|{C}_j^D\right|\right)}^2}}, $$\end{document}</tex-math><mml:math id="M36"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi><mml:mi>C</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="normal">e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:msup><mml:mfenced close=")" open="("><mml:mfenced close="|" open="|"><mml:mrow><mml:msubsup><mml:mi>C</mml:mi><mml:mi>i</mml:mi><mml:mi>Q</mml:mi></mml:msubsup><mml:mo stretchy="true">|</mml:mo><mml:mo>−</mml:mo><mml:mo stretchy="true">|</mml:mo><mml:msubsup><mml:mi>C</mml:mi><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mrow></mml:mfenced></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mstyle></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ18.gif" position="anchor"/></alternatives></disp-formula>where |<italic>C</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup>| and |<italic>C</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup>| are the lengths of vectors <italic>C</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>C</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup>, respectively, and the similarity of the angles <italic>γ</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>Q</italic></sup> and <italic>γ</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>D</italic></sup> is defined as follows:<disp-formula id="Equ19"><label>19</label><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ {\sigma}_{ij}^{\gamma }={\mathrm{e}}^{-{\displaystyle {\left({\gamma}_i^Q-{\gamma}_j^D\right)}^2}}. $$\end{document}</tex-math><mml:math id="M38"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi><mml:mi mathvariant="italic">ij</mml:mi><mml:mi>γ</mml:mi></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="normal">e</mml:mi><mml:mrow><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:msup><mml:mfenced close=")" open="("><mml:mrow><mml:msubsup><mml:mi>γ</mml:mi><mml:mi>i</mml:mi><mml:mi>Q</mml:mi></mml:msubsup><mml:mo>−</mml:mo><mml:msubsup><mml:mi>γ</mml:mi><mml:mi>j</mml:mi><mml:mi>D</mml:mi></mml:msubsup></mml:mrow></mml:mfenced><mml:mn>2</mml:mn></mml:msup></mml:mstyle></mml:mrow></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ19.gif" position="anchor"/></alternatives></disp-formula>
</p>
      <p>In high-resolution alignment, the value of the degree of similarity of molecular residue descriptors <italic>ss</italic>
<sub><italic>ij</italic></sub> (Eq. <xref rid="Equ17" ref-type="">17</xref>) replaces the similarity reward <italic>δ</italic>
<sub><italic>ij</italic></sub> (Eq. <xref rid="Equ8" ref-type="">8</xref>).</p>
      <p>The relative strength of each component in the similarity search (Eq. <xref rid="Equ17" ref-type="">17</xref>) can be controlled using participation weights. The default value for each is 1, but this can be changed by the user. For example, researchers who are looking for surprising structural similarities but no sequence similarity can disable the component for the primary structure by setting the value of <italic>w</italic>
<sub><italic>r</italic></sub> = 0.</p>
      <p>The <italic>Score</italic> similarity measure, a basic measure of the similarity of protein structures, is calculated in this phase. This value incorporates all possible rewards for a match, mismatch penalties, and penalties for inserting gaps into the alignment. The <italic>Score</italic> is also used to rank highly similar proteins that are returned by the GPU-CASSERT.</p>
    </sec>
    <sec id="Sec6">
      <title>Third phase: structural superposition and alignment visualization</title>
      <p>In the third phase, we perform superposition of protein structures on the basis of aligned chains of molecular residue descriptors. The purpose of this step is to match two protein structures by performing a set of rotation and translation operations that minimize the RMSD:<disp-formula id="Equ20"><label>20</label><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$ RMSD=\sqrt{\frac{1}{N}{\displaystyle \sum_{i=1}^N{d}_i^2}}, $$\end{document}</tex-math><mml:math id="M40"><mml:mrow><mml:mi mathvariant="italic">RMSD</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mstyle></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math><graphic xlink:href="894_2014_2067_Article_Equ20.gif" position="anchor"/></alternatives></disp-formula>where <italic>N</italic> is the number of aligned C<sub>α</sub> atoms in the protein backbones, and <italic>d</italic>
<sub><italic>i</italic></sub> is the distance between the <italic>i</italic>
<sup>th</sup> pair of atoms. We use the Kabsch algorithm [<xref ref-type="bibr" rid="CR39">39</xref>] to complete this step. However, the calculation is performed on the CPU of the host workstation.</p>
      <p>In this phase, we also calculate the full similarity matrix<italic> S</italic> in order to allow backtracking from the maximum value and full visualization of the structural alignment at the residue level. This step is performed on the CPU of the host and only for a limited number (<italic>M</italic>, which is configured by the user) of the most similar molecules.</p>
    </sec>
  </sec>
  <sec id="Sec7">
    <title>Methods</title>
    <p>Greatly accelerated calculation speeds are possible with GPUs, but this also necessitates the application of an appropriate programming model. Before we begin describing the GPU-based implementation of the CASSERT algorithm, we now describe some operational details of GPU devices and the CUDA architecture. These details are an important aid to understanding our implementation.</p>
    <sec id="Sec8">
      <title>The CUDA architecture and the construction of GPU devices</title>
      <p>In GPU devices that support the CUDA architecture, high scalability is achieved by the hierarchical organization of <italic>threads</italic>, which are basic execution units. Threads execute, in parallel, user-defined procedures called <italic>kernels</italic>, which implement some computational logic that is applied to data. Each thread has its own index, the vector of the coordinates corresponding to its location in the one-, two-, or three-dimensional organizational structure called a <italic>block</italic>. Thread blocks form a one- or two-dimensional structure called a <italic>grid</italic>. Each thread block is processed by a streaming multiprocessor (SM), which has many scalar processor cores (SP). The number of multiprocessors and processor cores available depends on the type of GPU device used. The GPU device has also two special function units, a multithreaded instruction unit (IU), a set of registers available for each thread block, and several types of memory (Fig. <xref rid="Fig4" ref-type="fig">4</xref>).<fig id="Fig4"><label>Fig. 4</label><caption><p>Architecture of the GPU computing device, showing streaming multiprocessors, scalar processor cores, registers, and global, shared, constant, and texture memories</p></caption><graphic xlink:href="894_2014_2067_Fig4_HTML" id="MO4"/></fig>
</p>
      <p>Threads can access global memory, which is the off-chip memory that has a relatively low bandwidth but provides a high storage capacity. Each thread also has access to the on-chip read–write shared memory as well as the read-only constant memory and texture memory, both of which are cached on-chip. Access to these three types of memories is much faster than that to the global memory, but they all provide limited storage space and are used in specific situations.</p>
      <p>Multiprocessors employ a new architecture, called SIMT (single instruction, multiple thread). In this architecture, a multiprocessor maps each thread to a scalar processor core, where each thread executes independently with its own instruction address and register state. The multiprocessor SIMT unit creates, manages, schedules, and executes threads in groups of 32 parallel threads called <italic>warps</italic>. Threads in the warp perform the same instructions, but operate on different data, as in the SIMD (single instruction multiple data) architecture. Therefore, appropriate preparation and arrangement of data is highly desirable before the kernel execution begins, and this is one of the factors that influence the efficiency of any GPU-based implementation [<xref ref-type="bibr" rid="CR23">23</xref>].</p>
    </sec>
    <sec id="Sec9">
      <title>Data preparation</title>
      <p>Early tests of the first implementations of the CASSERT algorithm on GPU devices showed that read operations from the database system storing structural data were too slow. Therefore, the present implementation of the GPU-CASSERT does not read data directly from the database, because single execution of the searching procedure would take too long. We have introduced binary files instead. These files contain data packages that are ready to be sent to the GPU device. The only data that are read directly from the database are those that describe the query protein structure<italic> Q</italic>. But, even in this situation, the data are stored in a appropriate way in binary files. Using binary files with data packages allows the initialization time of the GPU device to be reduced severalfold. This is necessary to ensure that GPU-CASSERT has a fast response time.</p>
      <p>Binary files must be refreshed in two cases:<list list-type="bullet"><list-item><p>Changes in the content of a database</p></list-item><list-item><p>Changes in parameters affecting the construction of data packages</p></list-item></list>
</p>
      <p>Data packages that are sent to the GPU device have the same general structure, regardless of what is stored inside.</p>
      <p>Due to the size of the data packages utilized by the CASSERT algorithm, these packages are placed in the global memory of the GPU device. As we know from the “The CUDA architecture and the construction of GPU devices,” when discussed GPUs and the CUDA, global memory is the slowest type of memory available. For this reason, it is worth minimizing the number of accesses made of this type of memory.</p>
      <p>Access operations are carried out in 32-, 64-, or 128-byte transactions. When the warp (which is composed of 32 threads) reaches the read/write operation, the GPU device attempts to perform this operation using a minimum number of transactions. Basically, the greater the number of transactions needed, the greater the amount of unnecessary data transmitted. This unnecessary overhead can be minimized for CUDA 2.x if memory cells that are read by all warp threads are located within a single 128-byte memory segment. In order to satisfy this condition, the address of this area must be aligned to 128 bytes and the threads need to read data from adjacent memory cells. For devices with compute capabilities of 1.0 or 1.1, upon which GPU-CASSERT can also run, there is the additional restriction that warp threads must be in the same order as the memory cells being read [<xref ref-type="bibr" rid="CR23">23</xref>]. If these conditions are met, we can get 4 bytes of data for each of the threads in a single 128-byte transaction. These 4 bytes correspond to a single number of type <italic>int</italic> or <italic>float</italic>. The preferred distribution method for the first 8 bytes of the transaction among threads is presented in Fig. <xref rid="Fig5" ref-type="fig">5</xref>. The remaining bytes of the transaction should be distributed in the same way.<fig id="Fig5"><label>Fig. 5</label><caption><p>Preferred distribution method for the first 8 bytes of the transaction among threads. Thread 0 takes the first 4 bytes of the transaction, thread 1 takes the next 4 bytes, etc.</p></caption><graphic xlink:href="894_2014_2067_Fig5_HTML" id="MO5"/></fig>
</p>
      <p>Data are transmitted to the GPU device in the form of a two-dimensional array of unsigned integers (Fig. <xref rid="Fig6" ref-type="fig">6</xref>). The array is organized in row-major order. This means that the cells in adjacent columns are located next to each other in the memory. This has an important influence on performance when processing an array, because contiguous array cells can usually be accessed more quickly than cells that are not contiguous. Each column of the array is assigned to a single block thread. A single chain of structural descriptors is stored in a single column of the array (Fig. <xref rid="Fig6" ref-type="fig">6</xref>). Such a solution satisfies the condition that contiguous addresses must be read, because block threads will always read adjacent cells, moving from the beginning to the end of the chain (from top to bottom). Every cell in the array is 4 bytes in size, so the transfer of data to a wrap’s 32 threads will be made in one 128-byte read transaction. This allows us to take a full advantage of data transfer from the memory to the registers of the GPU device. This way of organizing data in memory is used and described in [<xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR29">29</xref>].<fig id="Fig6"><label>Fig. 6</label><caption><p>Arrangement of chains of structural descriptors in a memory array. Block threads are assigned to particular columns. Each cell contains 4 bytes of data (structural descriptors). All block threads read contiguous memory areas</p></caption><graphic xlink:href="894_2014_2067_Fig6_HTML" id="MO6"/></fig>
</p>
      <p>Another factor affecting the performance is the density at which the data are packed in memory cells. The distribution of data in memory cells depends on the phase of the algorithm and the type of structural descriptors that are used in the phase. There are five types of data that are sent to the memory of the GPU device:<list list-type="bullet"><list-item><p>Reduced chains of secondary structures formed by secondary structure elements <italic>SE</italic>
<sub><italic>i</italic></sub> (phase 1)</p></list-item><list-item><p>Secondary structure elements <italic>SSE</italic>
<sub><italic>i</italic></sub> that are components of nonreduced chains of molecular residue descriptors (phase 2)</p></list-item><list-item><p>Amino acid residue types <italic>r</italic>
<sub><italic>i</italic></sub> that are components of nonreduced chains of molecular residue descriptors (phase 2)</p></list-item><list-item><p>Lengths of the vectors between C<sub>α</sub> atoms of subsequent residues that are components of nonreduced chains of molecular residue descriptors (phase 2)</p></list-item><list-item><p><italic>γ</italic><sub><italic>i</italic></sub> angles between successive vectors <italic>C</italic>
<sub><italic>i</italic></sub> and <italic>C</italic>
<sub><italic>i</italic> + 1</sub> that are components of nonreduced chains of molecular residue descriptors (phase 2)</p></list-item></list>
</p>
      <p>Regardless of the type of data present in the memory cells, the chains included in the package may be of various lengths. For this reason, all chains of structural descriptors are aligned to the length of the longest chain. Empty cells are filled with zeros. In principle, comparing these zeros during the course of the algorithm does not affect the scoring system assumed and the final results.</p>
      <p>Chains of structural descriptors contained in a data package are sorted by their lengths in ascending order. In this way, we minimize differences in processing time for individual block threads and their idle times (threads that have already completed their work must wait for the other threads to finish processing). A similar method is used in the work presented in [<xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR29">29</xref>].</p>
      <p>Data packages are divided into subpackages. Each subpackage consists of 32 chains of structural descriptors. This is exactly the same as the number of warp threads.</p>
    </sec>
    <sec id="Sec10">
      <title>Implementation of two-phase structural alignment in a GPU</title>
      <p>Implementation of the two-phase structural alignment algorithm in a GPU with the CUDA requires a dedicated approach. GPU-CASSERT operates according to the following scheme:<list list-type="order"><list-item><p>Read data packages describing database protein structures from binary files</p></list-item><list-item><p>Read query protein structure (<italic>Q</italic>) from database and create appropriate data packages</p></list-item><list-item><p>Perform the first phase of the structural alignment on the GPU device for all query protein (<italic>Q</italic>) vs. database protein (<italic>D</italic>) pairs</p></list-item><list-item><p>Perform the second phase of the pairwise structural alignment for the molecules that passed the first phase (based on the given threshold) on the GPU device</p></list-item><list-item><p>Return a list of the top <italic>M</italic> database molecules that are most similar to the query molecule, together with similarity measures</p></list-item><list-item><p>If the user wants to visualize the alignment, perform the second phase on the CPU of the host computer for molecules from the list of the most similar ones to the query molecule returned by the GPU device</p></list-item><list-item><p>Return alignment visualization to the user</p></list-item></list>
</p>
      <p>In both alignment phases, the vector of penalties for a gap and the similarity matrix are stored in the global memory of the GPU device as arrays of type <italic>float</italic>. This means that a read/write of a single element requires just one transaction. It is also worth noting that, due to memory restrictions, each thread remembers only the last row of the similarity matrix. This is sufficient to determine the maximum element of the similarity matrix, which also provides a value for the <italic>Score</italic> similarity measure, which is needed to check whether a database structure qualifies for the second phase. The similarity measure alone is sufficient to assess the quality of the alignment before the second phase. On the other hand, the second phase is performed on the GPU device for all qualified structures, and once again on the CPU of the host for the database proteins that are most similar to the query molecule in order to get alignment paths and to perform structural superposition. As a result, we obtain a list of the structures that match most closely to the query structure and a visualization of the local alignments of these structures at the residue level.</p>
    </sec>
    <sec id="Sec11">
      <title>First phase of structural alignment in the GPU</title>
      <p>The first phase requires data to be delivered in the form of data packages containing reduced chains of secondary structures (<italic>SE</italic> regions). Separate data packages are built for the query protein and candidate protein structures from the database. For the purpose of processing, <italic>SE</italic> regions are encoded using two bytes: one byte for the type of secondary structure and one byte for its length. Types of secondary structures are mapped to integers. In the “<xref rid="Sec9" ref-type="sec">Data preparation</xref>,” where we described the overall structure of a data package, we also mentioned that the data in memory are arranged in 4-byte cells. In such a 4-byte cell we can store two encoded <italic>SE</italic> regions. This is illustrated in Fig. <xref rid="Fig7" ref-type="fig">7</xref>.<fig id="Fig7"><label>Fig. 7</label><caption><p>Encoding of a reduced chain of secondary structure in a data package. The secondary structure of the protein is first translated into a reduced chain of<italic> SE</italic> regions. Subsequently, every two<italic> SE </italic>regions are placed in a data package in the manner shown, taking up 4 bytes, and in such a way that they are loaded into the global memory of the GPU device</p></caption><graphic xlink:href="894_2014_2067_Fig7_HTML" id="MO7"/></fig>
</p>
      <p>The data package for the query chain of secondary structures is built on the basis of a slightly different principle. If it was created in the same way as the data packages for database structures, then in order to extract the similarity coefficient of secondary structures <italic>σ</italic>
<sub><italic>i</italic>,<italic>j</italic></sub> we would have to read the cell (<italic>SSE</italic>
<sub arrange="stack"><italic>i</italic></sub><sup arrange="stack"><italic>A</italic></sup>, <italic>SSE</italic>
<sub arrange="stack"><italic>j</italic></sub><sup arrange="stack"><italic>B</italic></sup>) from a predefined matrix of coefficients (a kind of substitution matrix constructed based on rules (i)–(iii) in the “<xref rid="Sec1" ref-type="sec">Introduction</xref>” section), which would affect performance negatively. We can avoid this by pre-computing and writing all possible similarity coefficients directly into the data package of the query protein, creating something like the query-specific substitution matrix proposed in [<xref ref-type="bibr" rid="CR40">40</xref>] and called a <italic>query profile</italic> in the GPU-based alignment algorithm for sequence similarity presented in [<xref ref-type="bibr" rid="CR28">28</xref>]. Therefore, the data package for the query protein passes through an additional preparation step. For each <italic>SE</italic> region, four versions of the similarity coefficient are created, one for each of the secondary structure types and one for the neutral element 0 (as shown in Fig. <xref rid="Fig8" ref-type="fig">8</xref>). In the query profile created, the row index is defined by the index of the structural region<italic> SE</italic> divided by 2, and the column index is defined by the type of secondary structure present (with the additional neutral element 0). The coefficients are converted to integers in order to fit them into 1 byte, according to the following rules:<fig id="Fig8"><label>Fig. 8</label><caption><p>Encoding the reduced chain of secondary structure for query protein<italic> Q</italic> (<italic>left</italic>) and constructing the query profile (<italic>right</italic>). The query profile shows all possible (encoded) scores when comparing the reduced query chain of secondary structure to<italic> SE</italic> regions from candidate protein structures from the database</p></caption><graphic xlink:href="894_2014_2067_Fig8_HTML" id="MO8"/></fig>
<list list-type="bullet"><list-item><p>If coefficient <italic>σ</italic>
<sub><italic>i</italic>,<italic>j</italic></sub> = 0, it is encoded as 0</p></list-item><list-item><p>If coefficient <italic>σ</italic>
<sub><italic>i</italic>,<italic>j</italic></sub> = 1, it is encoded as 1</p></list-item><list-item><p>If coefficient <italic>σ</italic>
<sub><italic>i</italic>,<italic>j</italic></sub> = 0.5, it is encoded as 2</p></list-item></list>
</p>
      <p>The lengths of <italic>SE</italic> regions do not change. This process is illustrated in Fig. <xref rid="Fig8" ref-type="fig">8</xref>.</p>
      <p>Once the data packages are loaded into the host memory and a data package for the reduced query chain is created, the program transfers data to the GPU device. To do this, it uses four streams. Each stream has its own memory buffers on the GPU device side and in the page-locked memory on the host side. The host loads data into the page-locked memory and then initiates asynchronous data transfer to GPU device for each of the streams. This allows transmission to take place in parallel with the ongoing calculations, again improving performance. Results are received prior to the transfer of the next data package or after all available packages have been processed.</p>
      <p>Block threads perform parallel alignments of reduced chains of secondary structures. Each block thread performs a pairwise alignment of the query protein vs. one candidate database protein. In order to limit the number of accesses of the global memory of the GPU device, the similarity matrix<italic> SSE</italic> is not calculated cell by cell but is divided into rectangular <italic>areas</italic> of size 2×4. Calculations are performed area by area, and row by row in each area, from left to right, as shown in Fig. <xref rid="Fig9" ref-type="fig">9</xref>.<fig id="Fig9"><label>Fig. 9</label><caption><p>Calculation of the similarity matrix<italic> SSE</italic>. Structural elements (<italic>SE</italic> regions) of the candidate database structure are (virtually) located along the vertical edge of the matrix and<italic> SE</italic> regions of the query protein structure along the horizontal edge of the matrix. Calculations are performed in areas 2×4 in size. Values of the cells in these areas are calculated according to the given order.<italic> Colors </italic>reflect the type of read/write operation required and the memory resources that are affected</p></caption><graphic xlink:href="894_2014_2067_Fig9_HTML" id="MO9"/></fig>
</p>
      <p>Structural elements (<italic>SE</italic> regions) of the candidate database structure are (virtually) located along the vertical edge of the matrix, and <italic>SE</italic> regions of the query protein structure are located along the horizontal edge of the matrix. During the calculation of each 2×4 area, the values of the four elements of the vector<italic> E</italic> representing the vertical gap penalty and structural data for the four elements of the database chain are stored in GPU registers. Calculation of a 2×4 area requires two reads and two writes to the global memory for the vector<italic> F</italic> representing the horizontal gap penalty, and two reads and two writes for the similarity matrix<italic> SSE</italic>. It also requires four reads for the query profile placed in the texture memory. In total, the calculation of 8 cells of an area of the similarity matrix<italic> SSE</italic> requires eight read/write transactions to the global memory of the GPU device and four reads from the texture memory. The order of calculation of cells and the read/write operations performed are shown in Fig. <xref rid="Fig9" ref-type="fig">9</xref>.</p>
      <p>After filtering candidate database proteins based on the qualification threshold <italic>Q</italic>
<sub>T</sub>, the program creates new, smaller data packages that are needed in the second phase.</p>
    </sec>
    <sec id="Sec12">
      <title>Second phase of structural alignment in the GPU</title>
      <p>In the second phase, separate data packages are built for each of the features included in the molecular residue descriptors. In data packages for amino acid types and secondary structure types, we can store elements for four successive molecular residue descriptors in every 4 bytes (and then in every 4-byte memory cell). The arrangement of bytes and cells in memory is similar to that used in the first phase. Vector lengths and angles occupy 4 bytes each, which is one cell of the prepared array in memory.</p>
      <p>For the query protein structure, data packages for amino acid types and secondary structures are generated in a similar manner to how this is done in the first phase. The program creates separate query profiles for secondary structures and for residue types. The query profile for secondary structures is formed from the secondary structure similarity coefficients <italic>σ</italic>
<sub><italic>i</italic>,<italic>j</italic></sub> in such a way that the row index is the index of the current element from the query chain divided by 4, and the column index is the type of the secondary structure of the element from the compared database protein (Fig. <xref rid="Fig8" ref-type="fig">8</xref>). The query profile for residue types is derived from the normalized BLOSUM substitution matrix in such a way that the row index is the index of the current element from the query chain divided by 4, and the column index is the type of the residue from the compared database chain. Data packages containing vector lengths and angles between these vectors, for the query protein structure, are created by rewriting these values to separate packages.</p>
      <p>Transfer of data packages to the device is performed in the same manner as in the first phase. Four streams are used for this purpose. After the first part of the data has been transferred to the GPU device, the high-resolution alignment procedure is initiated. Block threads perform parallel alignments of chains of molecular residue descriptors. Each block thread performs a pairwise alignment of the query protein vs. one candidate database protein. In order to limit the number of accesses to the global memory of the GPU device, the similarity matrix<italic> S</italic> is divided into rectangular areas of size 4 × 4. Calculations are performed area by-area, and row by row inside each area, from left to right, as shown in Fig. <xref rid="Fig10" ref-type="fig">10</xref>.<fig id="Fig10"><label>Fig. 10</label><caption><p>Calculation of the similarity matrix<italic> S</italic> in the second phase of alignment. Molecular residue descriptors of the candidate database structure are (virtually) located along the vertical edge of the matrix and molecular residue descriptors of the query protein structure are located along the horizontal edge of the matrix. Calculations are performed in areas of size 4×4. Values of the cells in these areas are calculated according to the given order.<italic> Colors</italic> reflect the type of read/write operation that are required and the memory resources that are affected</p></caption><graphic xlink:href="894_2014_2067_Fig10_HTML" id="MO10"/></fig>
</p>
      <p>Molecular residue descriptors of the candidate database structure are (virtually) located along the left vertical edge of the matrix<italic> S</italic>, and molecular residue descriptors of the query protein structure are located along the top horizontal edge of the matrix. During the calculation of each 4 × 4 area, the values of the four elements of the vector<italic> E</italic> representing the vertical gap penalty and the molecular residue descriptors for four successive elements of the database chain are stored in GPU registers. Calculation of a 4×4 area requires four reads and four writes to the global memory for the vector<italic> F</italic> representing the horizontal gap penalty, and four reads and four writes for the similarity matrix<italic> S</italic>. It is also necessary to perform four reads for the query profile for secondary structures, four reads for the query profile for residue types, four reads for vector lengths, and four reads for angles between vectors. These reads are performed from the texture memory, where these structural features are placed and arranged in an appropriate manner. In total, the calculation of the 16 cells in each area of the similarity matrix<italic> S</italic> requires 16 read/write transactions to the global memory of the GPU device and 16 reads from the texture memory. The order of calculation of cells and the read/write operations performed are shown in Fig. <xref rid="Fig10" ref-type="fig">10</xref>.</p>
    </sec>
  </sec>
  <sec id="Sec13">
    <title>Results</title>
    <p>We have tested the efficiency of the GPU-CASSERT algorithm and compared it with the CPU-based implementation that was published in [<xref ref-type="bibr" rid="CR13">13</xref>]. Both implementations, i.e., the GPU-based and the CPU-based implementations, were tested on a Lenovo ThinkStation D20 with two Intel Xeon CPU E5620 2.4 GHz processors, 16 GB of RAM, and a GeForce GTX 560 Ti graphics card with 2GB of GDDR5 memory. The workstation had the Microsoft Windows Server 2008 R2 Datacenter 64-bit operating system installed, together with the CUDA SDK version 4.2. The CUDA compute capability supported by the graphics card was 2.1. The graphics card had the following features:<list list-type="bullet"><list-item><p>8 streaming multiprocessors (384 processing cores)</p></list-item><list-item><p>48 KB of shared memory per block</p></list-item><list-item><p>64 KB of total constant memory</p></list-item><list-item><p>32,768 registers per block</p></list-item><list-item><p>2 GB of total global memory</p></list-item></list>
</p>
    <p>Tests were conducted using the DALI database (the same as that used by the DALI algorithm [<xref ref-type="bibr" rid="CR6">6</xref>, <xref ref-type="bibr" rid="CR7">7</xref>]), which contained the structures for 105,580 protein chains. While testing performance, we used 14 selected query protein structures with lengths between 29 and 2005 amino acids. These were randomly selected molecules that represent different classes according to the SCOP classification [<xref ref-type="bibr" rid="CR41">41</xref>], i.e., all α, all β, α + β, α/β, α and β, coiled coil proteins, and others. The list of query protein structures used in the tests performed in the present work is shown in Table <xref rid="Tab1" ref-type="table">1</xref>.<table-wrap id="Tab1"><label>Table 1</label><caption><p>Query protein structures used in the performance tests</p></caption><table frame="hsides" rules="groups"><thead><tr><th>PDB ID</th><th>Chain</th><th>Length</th><th>PDB ID</th><th>Chain</th><th>Length</th></tr></thead><tbody><tr><td>2CCE</td><td>A</td><td>29</td><td>1AYE</td><td>_</td><td>400</td></tr><tr><td>2A2B</td><td>A</td><td>40</td><td>2EPO</td><td>B</td><td>600</td></tr><tr><td>1BE3</td><td>G</td><td>80</td><td>1KK7</td><td>A</td><td>802</td></tr><tr><td>1A1A</td><td>B</td><td>101</td><td>1URJ</td><td>A</td><td>1027</td></tr><tr><td>1AYY</td><td>B</td><td>142</td><td>2PDA</td><td>A</td><td>1230</td></tr><tr><td>2RAS</td><td>A</td><td>199</td><td>2R93</td><td>A</td><td>1421</td></tr><tr><td>1TA3</td><td>B</td><td>300</td><td>2PFF</td><td>B</td><td>2005</td></tr></tbody></table></table-wrap>
</p>
    <p>Tests were performed using different qualification thresholds (<italic>Q</italic>
<sub>T</sub> = 0.01, 0.2, 0.4, 0.6, 0.8) that the structures had to attain for them to pass from the first phase to the second phase of CASSERT. CASSERT execution times for <italic>Q</italic>
<sub>T</sub> = 0.01 and <italic>Q</italic>
<sub>T</sub> = 0.2 are shown in Fig. <xref rid="Fig11" ref-type="fig">11</xref>. The thresholds used were not chosen randomly. <italic>Q</italic>
<sub>T</sub> = 0.2 is an experimentally determined threshold that filters out a reasonable number of structures based on secondary structure similarity but still allows short local similarities to be found. This will be discussed further later in the section. <italic>Q</italic>
<sub>T</sub> = 0.01 means that almost no filtering is done based on the secondary structure similarity, and almost all structures in the database qualify for the second phase.<fig id="Fig11"><label>Fig. 11</label><caption><p>Total execution time for the first phase (<italic>top</italic>) and average execution time of both phases per protein that qualified for the second phase (<italic>bottom</italic>) for qualification thresholds of 0.01 (<italic>left</italic>) and 0.2 (<italic>right</italic>) as a function of the length of the query protein structure<italic> Q</italic>. Time is plotted on a log<sub>10</sub> scale. Comparison of two implementations of the CASSERT algorithm: CPU-based (<italic>red</italic>) and GPU-based (CUDA,<italic> blue</italic>). Results for 14 selected query protein structures between 29 and 2005 amino acids long. Searches were performed against the DALI database, containing 105,580 structures</p></caption><graphic xlink:href="894_2014_2067_Fig11_HTML" id="MO11"/></fig>
</p>
    <p>The results of the efficiency tests presented in Fig. <xref rid="Fig11" ref-type="fig">11</xref> prove that GPU-CASSERT scans the database much faster than the CPU-based implementation. Upon analyzing execution times for the first phase of the CASSERT algorithm (Fig. <xref rid="Fig11" ref-type="fig">11</xref> top) for both qualification thresholds (top left and top right), we can see that increasing the query protein’s length causes the execution time for the algorithm to increase too. This is expected, since a longer query protein chain implies a longer alignment time for every pair of compared proteins. Small fluctuations that are visible for short chains when using the GPU-based implementation and <italic>Q</italic>
<sub>T</sub> = 0.01 (top left, blue) are caused by variations in the number of secondary structures identified in the investigated proteins, which affect the alignment time. We observe a similar (expected) dependency between the length of the query protein and the execution time while analyzing the measured execution times after both phases of the CASSERT algorithm for both qualification thresholds (Fig. <xref rid="Fig11" ref-type="fig">11</xref>, bottom left and bottom right). However, since the number of proteins that qualify for the second phase varies and depends on the length and complexity of the query structure, we show average execution times per qualified protein in Fig. <xref rid="Fig11" ref-type="fig">11</xref> (bottom). We noticed that, in some cases, more database protein structures qualified for the second phase for shorter rather than longer (between 1000 and 2000 residues) query protein structures.</p>
    <p>Using the execution time measurements that we have obtained during the performance tests, we also calculated acceleration ratios for GPU-CASSERT with respect to CPU-CASSERT. Figure <xref rid="Fig12" ref-type="fig">12</xref> shows how the acceleration ratio changes as a function of query protein length for the first phase and both phases for <italic>Q</italic>
<sub>T</sub> = 0.01 (top) and <italic>Q</italic>
<sub><italic>T</italic></sub> = 0.2 (bottom).<fig id="Fig12"><label>Fig. 12</label><caption><p>Acceleration achieved by GPU-CASSERT with respect to CPU-CASSERT as a function of query protein length after the first phase (<italic>blue</italic>) and both alignment phases (<italic>red</italic>) with qualification thresholds of 0.01 (<italic>top</italic>) and 0.2 (<italic>bottom</italic>)</p></caption><graphic xlink:href="894_2014_2067_Fig12_HTML" id="MO12"/></fig>
</p>
    <p>We can see that the acceleration ratio for the first phase remains stable. In this phase, GPU-CASSERT is on average 120 times faster than CPU-CASSERT. However, for the whole alignment, i.e., after the first and second phases, the acceleration ratio greatly depends on the length of the query protein structure, its construction and complexity. The whole alignment process when performed on the GPU is 30–300 times faster than the same process performed on the CPU.</p>
    <p>Actually, for qualification thresholds <italic>Q</italic>
<sub>T</sub> ≥ 0.1, we observed a kind of compensation effect. For longer query protein chains, which also have more complicated constructions in terms of secondary structure, the number of candidate structures from the database that qualified for the second phase decreases with the length of the query protein. This causes a situation in which fewer database proteins need to be aligned during the entire process. But, at the same time, the length of the query protein grows, causing the alignment time to increase. This growth is compensated for by the smaller number of database structures that need to be aligned.</p>
    <p>Figure <xref rid="Fig13" ref-type="fig">13</xref> shows the relationship between query protein length and the number of structures that qualified for the second phase when various values of the qualification threshold <italic>Q</italic>
<sub>T</sub> were applied. For example, for <italic>Q</italic>
<sub>T</sub> = 0.01 (yellow line), we can see that almost all of the database structures qualified for the second phase, regardless of query protein length. In this cases, there is practically no filtering based on the secondary structures identified in the query protein. On the other hand, for <italic>Q</italic>
<sub>T</sub> = 0.8 (red line), we noticed that for query proteins over 150 residues in length, only single database structures are eligible for further processing.<fig id="Fig13"><label>Fig. 13</label><caption><p>Number of structures from the database that qualified for the second phase as a function of query protein length for various values of the qualification threshold</p></caption><graphic xlink:href="894_2014_2067_Fig13_HTML" id="MO13"/></fig>
</p>
    <p>In many situations, such a high value of the qualification threshold will filter out too many molecules. However, this depends on the situation for which the entire process of similarity searching is carried out. For example, in homology modeling, we may want to find referential protein structures that are very similar to the given query protein structure. For functional annotation and while searching for homologous structures, <italic>Q</italic>
<sub>T</sub> = 0.2 could be a reasonable threshold, since it filters out many candidate molecules and, even for very long query proteins, it allows several thousands of structures at least to pass through to the second phase.</p>
    <p>We should also remember that the first alignment phase can be turned off completely by specifying <italic>Q</italic>
<sub>T</sub> = 0.0. Then, all of the database molecules pass through to the second phase, which prolongs the similarity searching process.</p>
  </sec>
  <sec id="Sec14">
    <title>Discussion</title>
    <p>The results of the efficiency tests we performed have confirmed our expectations. Using a graphics card with a CUDA compute capability is one of the most efficient approaches to use when performing protein structure similarity searching. Upon comparing execution times, we can see that the GPU-based implementation is several dozen to several hundred times faster (an average of 180 times faster for <italic>Q</italic>
<sub>T</sub> = 0.2) than the CPU-based implementation. This is very important, since the number of protein structures in macromolecular databases, such as the Protein Data Bank, is growing very quickly, and the dynamics of this growth is also increasing. The use of GPU-based implementations is particularly convenient for such processes because GPU devices are reasonably inexpensive compared to, say, big computer clusters. Our experiments were performed on a middle-class GPU device, which was set up on a small PC workstation with two processors. For this reason, GPU devices can be usefully applied in the implementation of many algorithms in the field of bioinformatics.</p>
    <p>The novelty of CPU-CASSSERT lies mainly in the fast preselection phase based on secondary structures (the low-resolution alignment phase), which precedes the phase of detailed alignment (the high-resolution alignment phase). This allows the number of structures that will be processed in the second, costly phase to be limited, which, in turn, significantly accelerates the method itself. A comparison of CPU-CASSERT with the popular DALI and FATCAT algorithms is presented in [<xref ref-type="bibr" rid="CR13">13</xref>].</p>
    <p>GPU-CASSERT provides additional acceleration over its CPU-based version by executing the computational procedure in parallel threads on multiple cores of the GPU device. The resulting increase in speed is even greater than those achieved with the methods mentioned in the “<xref rid="Sec1" ref-type="sec">Introduction</xref>” of this paper. SA Tableau Search provides a 33-fold increase in speed when using a GTX 285 graphics card and a 24-fold increase when using a C1060 GPU device rather than the CPU implementation. However, the optimization procedure is based on simulated annealing, which is run in parallel CUDA threads. Individual thread blocks perform the optimization procedure for different candidate protein structures from a database. Protein structures are represented as tableaux containing the orientations of secondary structure elements and distance matrices. However, one of the problems with this algorithm is encountered when comparing big protein structures that generate big tableaux and distance matrices, as they cannot be stored inside the constant and shared memory during computations. This makes it necessary to use a slower version of the GPU kernel which exploits the global memory rather than the faster constant and shared memory. GPU-CASSERT avoids this problem by using a different representation of protein structures: linear sequences of structural descriptors (where secondary structure elements are also included) are employed rather than two-dimensional representative structures.</p>
    <p>In terms of representation of protein structures and the implementation of the method, GPU-CASSERT is closer to pssAlign [<xref ref-type="bibr" rid="CR37">37</xref>], which shows up to a 35-fold increase in speed with the NVIDIA Tesla C2050 GPU over its CPU-based implementation. Both algorithms consists of two alignment phases. The fragment-level alignment phase of pssAlign uses an index-based matched fragment set (MFS) in order to find so-called seeds between the target protein and each database protein. These seeds, which are represented by the locations of the C<sub>α</sub> atoms, are used to generate initial alignments which are then refined in the residue-level alignment phase. Just like GPU-CASSERT, both phases utilize dynamic programming. However, in GPU-CASSERT, the low-resolution alignment phase is treated as a preselection phase for detailed alignment. In contrast to pssAlign, both phases are executed independently in GPU-CASSERT. We do not store alignment paths after the first phase of the algorithm, which was done in the original CASSERT published in [<xref ref-type="bibr" rid="CR13">13</xref>]. Consequently, we also do not perform backtracking in the kernel of the first phase, since GPU-CASSERT only needs the <italic>Score</italic> measure to calculate the qualification threshold <italic>Q</italic>
<sub>T</sub> for the next phase. The <italic>Score</italic> is calculated in a linear space, which also influences the effectiveness. Backtracking is also not performed in the GPU after the high-resolution alignment phase. It is executed on the host instead, and only for the highest-scoring database molecules that are returned for the user to visualize. This allows computational time to be saved.</p>
    <p>Additional savings can be achieved when working with small query structures. After filtering candidate database proteins based on the qualification threshold, the program creates new, smaller data packages that are needed in the second phase. This usually takes some time. For this reason, for shorter query proteins (less than 100 amino acids in length), it is reasonable to omit the first phase by setting the qualification threshold to 0.0. The probability that such a small protein structure (after it has been reduced to a chain of <italic>SE</italic> regions) will be similar to many of the database proteins is very high. This means that all or almost all of the proteins qualify for the next phase (this is visible in Fig. <xref rid="Fig13" ref-type="fig">13</xref>), which makes the first preselection phase almost useless.</p>
    <p>GPU-CASSERT also provides additional unique features. Following research into GPU-based sequence alignments [<xref ref-type="bibr" rid="CR25">25</xref>, <xref ref-type="bibr" rid="CR26">26</xref>, <xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR29">29</xref>], we arrange the data in an appropriate manner before sending them to the global memory of the GPU device. Chains of structural descriptors representing protein structures are stored in a prepared memory array that guarantees coalesced access to the global memory in a single transaction. Structural descriptors are not transferred to the global memory of the GPU device directly from a database, but they are stored in binary files, which enables faster transfer, and they are sorted by their lengths in order to reduce thread idle time once they are processed. We also encoded secondary structure descriptors of query protein structures (in both phases) as query profiles—appropriate matrices of all possible scores. During the computations performed on the GPU device, the query profile and substitution matrix (needed in the second phase) are located in the texture memory. The texture memory is cached on the chip of the graphics card and provides a higher effective bandwidth, reducing the number of requests made to off-chip global memory. Streaming is also applied in GPU-CASSERT in order to alternate kernel launches and memory copies, resulting in further acceleration. Finally, we optimized the kernel code to avoid introducing branching via conditional statements.</p>
    <p>GPU-CASSERT is available at: <ext-link ext-link-type="uri" xlink:href="http://zti.polsl.pl/dmrozek/science/gpucassert/cassert.htm">http://zti.polsl.pl/dmrozek/science/gpucassert/cassert.htm</ext-link>
</p>
  </sec>
  <sec id="Sec15">
    <title>Summary</title>
    <p>Efficient methods of 3D protein structure similarity searching are required, as well as their new, efficient implementations, in order to generate results in a reasonable time, considering the exponentially growing numbers of protein structures in macromolecular repositories. In this paper, we have presented GPU-CASSERT, a GPU-based implementation of the CASSERT algorithm for efficiently scanning a database of protein structures in order to identify structural similarities.</p>
    <p>As noted in this paper and the papers of other researchers, at the current stage of development of computer science, GPU devices provide an excellent alternative to very expensive computer infrastructures, as they allow large increases in speed over CPU-based implementations for the same computational methods. Moreover, taking into account that the number of processing cores and the amount of memory in modern GPU devices are constantly growing, the computational capabilities of GPU devices are also growing at the same time. Although, implementing computational methods requires some additional effort by the user, including the need to get familiar with the completely new CUDA architecture and programming model, and to refactor the code of existing procedures into GPU kernels, in return we can achieve much faster processing. This is very important because, for many processes such as 3D protein structure similarity searching, reducing computational complexity is a very difficult, if not impossible, task. GPU-based implementations like that presented in the present paper do not reduce the complexity, but they can speed up the process by implementing massive parallelization, thus reducing the overall time required for process execution.</p>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>This work was supported by the European Union through the European Social Fund (grant agreement number: UDA-POKL.04.01.01-00-106/09).</p>
    </fn>
  </fn-group>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1.</label>
      <mixed-citation publication-type="other">Burkowski F (2008) Structural bioinformatics: an algorithmic approach, 1st edn. Chapman and Hall/CRC, Boca Raton</mixed-citation>
    </ref>
    <ref id="CR2">
      <label>2.</label>
      <mixed-citation publication-type="other">Gu J, Bourne PE (2009) Structural bioinformatics, 2nd edn. Methods of Biochemical Analysis, vol 44. Wiley-Blackwell, Chichester</mixed-citation>
    </ref>
    <ref id="CR3">
      <label>3.</label>
      <mixed-citation publication-type="other">Lesk AM (2010) Introduction to protein science: architecture, function, and genomics, 2nd edn. Oxford University Press, New York</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4.</label>
      <mixed-citation publication-type="other">Berman HM, Westbrook J, Feng Z, Gilliland G, Bhat TN, Weissig H, Shindyalov IN, Bourne PE (2000) The Protein Data Bank. Nucleic Acids Res 28:235–242</mixed-citation>
    </ref>
    <ref id="CR5">
      <label>5.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gibrat</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Madej</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Bryant</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Surprising similarities in structure comparison</article-title>
        <source>Curr Opin Struct Biol</source>
        <year>1996</year>
        <volume>6</volume>
        <issue>3</issue>
        <fpage>377</fpage>
        <lpage>385</lpage>
        <pub-id pub-id-type="doi">10.1016/S0959-440X(96)80058-3</pub-id>
        <pub-id pub-id-type="pmid">8804824</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6.</label>
      <mixed-citation publication-type="other">Holm L, Kaariainen S, Rosenstrom P, Schenkel A (2008) Searching protein structure databases with DaliLite v.3. Bioinformatics 24:2780–2781</mixed-citation>
    </ref>
    <ref id="CR7">
      <label>7.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Holm</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Sander</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Protein structure comparison by alignment of distance matrices</article-title>
        <source>J Mol Biol</source>
        <year>1993</year>
        <volume>233</volume>
        <issue>1</issue>
        <fpage>123</fpage>
        <lpage>138</lpage>
        <pub-id pub-id-type="doi">10.1006/jmbi.1993.1489</pub-id>
        <pub-id pub-id-type="pmid">8377180</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shapiro</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Brutlag</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>FoldMiner and LOCK2: protein structure comparison and motif discovery on the web</article-title>
        <source>Nucleic Acids Res</source>
        <year>2004</year>
        <volume>32</volume>
        <fpage>536</fpage>
        <lpage>541</lpage>
        <pub-id pub-id-type="doi">10.1093/nar/gkh389</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ye</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Godzik</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Flexible structure alignment by chaining aligned fragment pairs allowing twists</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <issue>2</issue>
        <fpage>246</fpage>
        <lpage>255</lpage>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10.</label>
      <mixed-citation publication-type="other">Can T, Wang Y (2003) CTSS: a robust and efficient method for protein structure alignment based on local geometrical and biological features. In: Proceedings of the 2003 I.E. Bioinformatics Conference: CSB 2003, 11–14 August, 2003, Stanford, California, USA. IEEE, New York, pp 169–179</mixed-citation>
    </ref>
    <ref id="CR11">
      <label>11.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Shindyalov</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Bourne</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Protein structure alignment by incremental combinatorial extension (CE) of the optimal path</article-title>
        <source>Protein Eng</source>
        <year>1998</year>
        <volume>11</volume>
        <issue>9</issue>
        <fpage>739</fpage>
        <lpage>747</lpage>
        <pub-id pub-id-type="doi">10.1093/protein/11.9.739</pub-id>
        <pub-id pub-id-type="pmid">9796821</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhu</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Weng</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>FAST: a novel protein structure algorithm</article-title>
        <source>Proteins</source>
        <year>2005</year>
        <volume>58</volume>
        <fpage>618</fpage>
        <lpage>627</lpage>
        <pub-id pub-id-type="doi">10.1002/prot.20331</pub-id>
        <pub-id pub-id-type="pmid">15609341</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13.</label>
      <mixed-citation publication-type="other">Mrozek D, Małysiak-Mrozek B (2013) CASSERT: a two-phase alignment algorithm for matching 3D structures of proteins. In: Kwiecieñ A, Gaj P, Stera P (eds) Computer Networks: 20th International Conference, CN 2013, Lwówek Śląski, Poland, June 17–21, 2013. Proceedings. Springer, Berlin, pp 334–343</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14.</label>
      <mixed-citation publication-type="other">Sam V, Tai CH, Garnier J, Gibrat JF, Lee B, Munson PJ (2008) Towards an automatic classification of protein structural domains based on structural similarity. BMC Bioinforma 9:74</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15.</label>
      <mixed-citation publication-type="other">Małysiak-Mrozek B, Momot A, Mrozek D, Hera Ł, Kozielski S, Momot M (2011) Scalable system for protein structure similarity searching. In: P. Jedrzejowicz et al. (Eds) ICCCI 2011 Proceedings of the Third International Conference on Computational Collective Intelligence: Technologies and Applications, Part II, LNCS 6923, Springer, Berlin, pp 271–280</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16.</label>
      <mixed-citation publication-type="other">Momot A, Małysiak-Mrozek B, Kozielski S, Mrozek D, Hera Ł, Górczyńska-Kosiorz S, Momot M (2010) Improving performance of protein structure similarity searching by distributing computations in hierarchical multi-agent system. In: Pan J-S, Chen S-M, Nguyen NT (eds) ICCC’10 Proceedings of the Second International Conference on Computational Collective Intelligence: Technologies and Applications, Pt I. Springer, Berlin, pp 320–329</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mosca</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Brannetti</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Schneider</surname>
            <given-names>TR</given-names>
          </name>
        </person-group>
        <article-title>Alignment of protein structures in the presence of domain motions</article-title>
        <source>BMC Bioinforma</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>352</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-9-352</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Daniluk</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Lesyng</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>A novel method to compare protein structures using local descriptors</article-title>
        <source>BMC Bioinforma</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>344</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-12-344</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19.</label>
      <mixed-citation publication-type="other">Minami S, Sawada K, Chikenji G (2013) MICAN: a protein structure alignment algorithm that can handle multiple-chains, inverse alignments, C<sub>α</sub> only models, alternative alignments, and non-sequential alignments. BMC Bioinforma 14:24</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jamroz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kolinski</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>ClusCo: clustering and comparison of protein models</article-title>
        <source>BMC Bioinforma</source>
        <year>2013</year>
        <volume>14</volume>
        <fpage>62</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-14-62</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yuan</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Kihara</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Effective inter-residue contact definitions for accurate protein fold recognition</article-title>
        <source>BMC Bioinforma</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>292</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-13-292</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22.</label>
      <mixed-citation publication-type="other">Mrozek D., Małysiak-Mrozek B (2011) An improved method for protein similarity searching by alignment of fuzzy energy signatures. Int J Comput Intell Syst 4(1):75–88</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23.</label>
      <mixed-citation publication-type="other">NVIDIA (2013) CUDA C programming guide. <ext-link ext-link-type="uri" xlink:href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html</ext-link>. Accessed on 1 Aug 2013</mixed-citation>
    </ref>
    <ref id="CR24">
      <label>24.</label>
      <mixed-citation publication-type="other">Sanders J, Kandrot E (2010) CUDA by example: an introduction to general-purpose GPU programming, 1st edn. Addison-Wesley, Reading</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25.</label>
      <mixed-citation publication-type="other">Liu Y, Maskell D, Schmidt B (2009) CUDASW++: optimizing Smith–Waterman sequence database searches for CUDA-enabled graphics processing units. BMC Res Notes 2:73</mixed-citation>
    </ref>
    <ref id="CR26">
      <label>26.</label>
      <mixed-citation publication-type="other">Liu Y, Maskell D, Schmidt B (2010) CUDASW++2.0: enhanced Smith–Waterman protein database search on CUDA-enabled GPUs based on SIMT and virtualized SIMD abstractions. BMC Res Notes 3:93</mixed-citation>
    </ref>
    <ref id="CR27">
      <label>27.</label>
      <mixed-citation publication-type="other">Liu Y, Wirawan A, Schmidt B (2013) CUDASW++ 3.0: accelerating Smith–Waterman protein database search by coupling CPU and GPU SIMD instructions. BMC Bioinforma 14:117</mixed-citation>
    </ref>
    <ref id="CR28">
      <label>28.</label>
      <mixed-citation publication-type="other">Manavski SA, Valle G (2008) CUDA compatible GPU cards as efficient hardware accelerators for Smith–Waterman sequence alignment. BMC Bioinforma 9:1–9</mixed-citation>
    </ref>
    <ref id="CR29">
      <label>29.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pawłowski</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Małysiak-Mrozek</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Kozielski</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Mrozek</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate similarity searching of biopolymer sequences with GPU and CUDA</article-title>
        <source>Algorithm Archit Parallel Process Lect Notes Comput Sci</source>
        <year>2011</year>
        <volume>7016</volume>
        <fpage>230</fpage>
        <lpage>243</lpage>
        <pub-id pub-id-type="doi">10.1007/978-3-642-24650-0_20</pub-id>
      </element-citation>
    </ref>
    <ref id="CR30">
      <label>30.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schatz</surname>
            <given-names>MC</given-names>
          </name>
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Delcher</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Varshney</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>High-throughput sequence alignment using graphics processing units</article-title>
        <source>BMC Bioinforma</source>
        <year>2007</year>
        <volume>8</volume>
        <fpage>474</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-8-474</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31.</label>
      <mixed-citation publication-type="other">Striemer GM, Akoglu A (2009) Sequence alignment with GPU: performance and design challenges. In: IEEE (eds) IPDPS ’09: Proceedings of the 2009 I.E. International Symposium on Parallel &amp; Distributed Processing. IEEE, New York</mixed-citation>
    </ref>
    <ref id="CR32">
      <label>32.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Suchard</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Rambaut</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Many-core algorithms for statistical phylogenetics</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <issue>11</issue>
        <fpage>1370</fpage>
        <lpage>1376</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/btp244</pub-id>
        <pub-id pub-id-type="pmid">19369496</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Friedrichs</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Eastman</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Vaidynathan</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Houston</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Legrand</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Beberg</surname>
            <given-names>AL</given-names>
          </name>
          <name>
            <surname>Ensign</surname>
            <given-names>DL</given-names>
          </name>
          <name>
            <surname>Bruns</surname>
            <given-names>CM</given-names>
          </name>
          <name>
            <surname>Pande</surname>
            <given-names>VS</given-names>
          </name>
        </person-group>
        <article-title>Accelerating molecular dynamic simulation on graphics processing units</article-title>
        <source>J Comput Chem</source>
        <year>2009</year>
        <volume>30</volume>
        <issue>6</issue>
        <fpage>864</fpage>
        <lpage>872</lpage>
        <pub-id pub-id-type="doi">10.1002/jcc.21209</pub-id>
        <pub-id pub-id-type="pmid">19191337</pub-id>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34.</label>
      <mixed-citation publication-type="other">Roberts E, Stone JE, Sepúlveda L, Hwu WMW, Luthey-Schulten Z (2009) Long time-scale simulations of in vivo diffusion using GPU hardware.In: IEEE (eds) IPDPS ’09: Proceedings of the 2009 I.E. International Symposium on Parallel &amp; Distributed Processing. IEEE, New York</mixed-citation>
    </ref>
    <ref id="CR35">
      <label>35.</label>
      <mixed-citation publication-type="other">Buckner J, Wilson J, Seligman M, Athey B, Watson S, Meng F (2010) The gputools package enables GPU computing in R. Bioinformatics 26:134–135</mixed-citation>
    </ref>
    <ref id="CR36">
      <label>36.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stivala</surname>
            <given-names>AD</given-names>
          </name>
          <name>
            <surname>Stuckey</surname>
            <given-names>PJ</given-names>
          </name>
          <name>
            <surname>Wirth</surname>
            <given-names>AI</given-names>
          </name>
        </person-group>
        <article-title>Fast and accurate protein substructure searching with simulated annealing and GPUs</article-title>
        <source>BMC Bioinforma</source>
        <year>2010</year>
        <volume>11</volume>
        <fpage>446</fpage>
        <pub-id pub-id-type="doi">10.1186/1471-2105-11-446</pub-id>
      </element-citation>
    </ref>
    <ref id="CR37">
      <label>37.</label>
      <mixed-citation publication-type="other">Pang B, Zhao N, Becchi M, Korkin D, Shyu C-R (2012) Accelerating large-scale protein structure alignments with graphics processing units. BMC Res Notes 5:116</mixed-citation>
    </ref>
    <ref id="CR38">
      <label>38.</label>
      <mixed-citation publication-type="other">Stanek D, Mrozek D, Malysiak-Mrozek B (2013) MViewer: visualization of protein molecular structures stored in the PDB, mmCIF and PDBML data formats. In: Kwiecieñ A, Gaj P, Stera P (eds) Computer Networks: 20th International Conference, CN 2013, Lwówek Śląski, Poland, June 17–21, 2013. Proceedings. Springer, Berlin, pp 323–333</mixed-citation>
    </ref>
    <ref id="CR39">
      <label>39.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kabsch</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>A solution for the best rotation to relate two sets of vectors</article-title>
        <source>Acta Crystallogr A</source>
        <year>1976</year>
        <volume>32</volume>
        <issue>5</issue>
        <fpage>922</fpage>
        <lpage>923</lpage>
        <pub-id pub-id-type="doi">10.1107/S0567739476001873</pub-id>
      </element-citation>
    </ref>
    <ref id="CR40">
      <label>40.</label>
      <mixed-citation publication-type="other">Rognes T, Seeberg E (2000) Six-fold speed-up of Smith–Waterman sequence database searches using parallel processing on common microprocessors. Bioinformatics 16:699–706</mixed-citation>
    </ref>
    <ref id="CR41">
      <label>41.</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Murzin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Brenner</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Hubbard</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Chothia</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>SCOP: a structural classification of proteins database for the investigation of sequences and structures</article-title>
        <source>J Mol Biol</source>
        <year>1995</year>
        <volume>247</volume>
        <fpage>536</fpage>
        <lpage>540</lpage>
        <pub-id pub-id-type="pmid">7723011</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
