<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Biol</journal-id>
    <journal-title-group>
      <journal-title>Genome Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1474-7596</issn>
    <issn pub-type="epub">1474-760X</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">6892282</article-id>
    <article-id pub-id-type="publisher-id">1875</article-id>
    <article-id pub-id-type="doi">10.1186/s13059-019-1875-0</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Software</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Dashing: fast and accurate genomic distances with HyperLogLog</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Baker</surname>
          <given-names>Daniel N.</given-names>
        </name>
        <address>
          <email>dnb@cs.jhu.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0003-2437-1976</contrib-id>
        <name>
          <surname>Langmead</surname>
          <given-names>Ben</given-names>
        </name>
        <address>
          <email>langmea@cs.jhu.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff1"/>
      </contrib>
      <aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 2171 9311</institution-id><institution-id institution-id-type="GRID">grid.21107.35</institution-id><institution>Department of Computer Science, Johns Hopkins University, </institution></institution-wrap>3400 N Charles St, Baltimore, 21218 USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>4</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>4</day>
      <month>12</month>
      <year>2019</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2019</year>
    </pub-date>
    <volume>20</volume>
    <elocation-id>265</elocation-id>
    <history>
      <date date-type="received">
        <day>5</day>
        <month>2</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>1</day>
        <month>11</month>
        <year>2019</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2019</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver(<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">Dashing is a fast and accurate software tool for estimating similarities of genomes or sequencing datasets. It uses the HyperLogLog sketch together with cardinality estimation methods that are specialized for set unions and intersections. Dashing summarizes genomes more rapidly than previous MinHash-based methods while providing greater accuracy across a wide range of input sizes and sketch sizes. It can sketch and calculate pairwise distances for over 87K genomes in 6 minutes. Dashing is open source and available at <ext-link ext-link-type="uri" xlink:href="https://github.com/dnbaker/dashing">https://github.com/dnbaker/dashing</ext-link>.</p>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>Sketch data structures</kwd>
      <kwd>Hyperloglog</kwd>
      <kwd>Metagenomics</kwd>
      <kwd>Alignment</kwd>
      <kwd>Sequencing</kwd>
      <kwd>Genomic distance</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2019</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <sec id="Sec1">
    <title>Background</title>
    <p>Since the release of the seminal Mash tool [<xref ref-type="bibr" rid="CR1">1</xref>], data sketches such as MinHash have become instrumental in comparative genomics. They are used to cluster genomes from large databases [<xref ref-type="bibr" rid="CR1">1</xref>], search for datasets with certain sequence content [<xref ref-type="bibr" rid="CR2">2</xref>], accelerate the overlapping step in genome assemblers [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR4">4</xref>], map sequencing reads [<xref ref-type="bibr" rid="CR5">5</xref>], and find similarity thresholds characterizing species-level distinctions [<xref ref-type="bibr" rid="CR6">6</xref>]. Whereas MinHash was originally developed to find similar web pages [<xref ref-type="bibr" rid="CR7">7</xref>], here it is being used to summarize large genomic sequence collections such as reference genomes or sequencing datasets. A collection is reduced to a set of representative <italic>k</italic>-mers and ultimately stored as a list of integers. The summary is much smaller than the original data but can be used to estimate relevant set cardinalities such as the size of the union or the intersection between the <italic>k</italic>-mer contents of two genomes. From these cardinalities one can obtain a Jaccard coefficient (<italic>J</italic>) or a “Mash distance,” which is a proxy for Average Nucleotide Identity (ANI) [<xref ref-type="bibr" rid="CR1">1</xref>]. These make it possible to cluster sequences and otherwise solve massive genomic nearest-neighbor problems.</p>
    <p>MinHash is related to other core methods in bioinformatics. Minimizers, which can be thought of as a special case of MinHash, are widely used in metagenomics classification [<xref ref-type="bibr" rid="CR8">8</xref>] and alignment and assembly [<xref ref-type="bibr" rid="CR9">9</xref>]. More generally, MinHash can be seen as a kind of Locality-Sensitive Hashing (LSH), which involves hash functions designed to map similar inputs the same value. LSH has also been used in bioinformatics, including in homology search [<xref ref-type="bibr" rid="CR10">10</xref>] and metagenomics classification [<xref ref-type="bibr" rid="CR11">11</xref>].</p>
    <p>Spurred by MinHash’s utility, other groups have proposed alternatives using new ideas from search and data mining. BinDash [<xref ref-type="bibr" rid="CR12">12</xref>] uses a <italic>b</italic>-bit one-permutation rolling MinHash to achieve greater accuracy and speed compared to Mash at a smaller memory footprint. Other theoretical improvements are proposed in the HyperMinHash [<xref ref-type="bibr" rid="CR13">13</xref>] and SuperMinHash [<xref ref-type="bibr" rid="CR14">14</xref>] studies.</p>
    <p>Some studies have pointed out shortcomings of MinHash. Koslicki and Zabeti argue that MinHash cardinality estimates suffer when the sets are very different sizes [<xref ref-type="bibr" rid="CR15">15</xref>]. This is not an uncommon scenario, e.g., when finding the distance between two genomes of very different lengths or when finding the similarity between a short sequence (say, a bacterial genome) and a large collection (say, deep-coverage metagenomics datasets).</p>
    <p>Here we use the HyperLogLog (HLL) sketch [<xref ref-type="bibr" rid="CR16">16</xref>] as an alternative to MinHash that exhibits excellent accuracy and speed across a range of scenarios, including when the input sets are very different sizes and when the sketch data structures are quite small. HLL has been applied in other areas of bioinformatics, e.g., to count the number of distinct <italic>k</italic>-mers in a genome or data collection [<xref ref-type="bibr" rid="CR17">17</xref>–<xref ref-type="bibr" rid="CR19">19</xref>]. We additionally use recent theoretical improvements in cardinality estimation for set unions and intersections [<xref ref-type="bibr" rid="CR20">20</xref>], the components needed to estimate <italic>J</italic> and other similarity measures.</p>
    <p>We implemented the HLL in the Dashing software tool [<xref ref-type="bibr" rid="CR21">21</xref>] (<ext-link ext-link-type="uri" xlink:href="https://github.com/dnbaker/dashing">https://github.com/dnbaker/dashing</ext-link>), which is free and open source under the GPLv3 license. Dashing supports the functions available in similar tools like Mash [<xref ref-type="bibr" rid="CR1">1</xref>], BinDash [<xref ref-type="bibr" rid="CR12">12</xref>], and Sourmash [<xref ref-type="bibr" rid="CR22">22</xref>]. Dashing can build a sketch of an input sequence set (dashing sketch), including FASTA files (for assembled genomes) or FASTQ files (for sequencing datasets). Dashing has a sketch-based facility for removing <italic>k</italic>-mers that likely contain sequencing errors prior to sketching. The dashing dist function performs all-pairwise distance comparisons between pairs of datasets in a large collection, e.g., all the complete genomes from the RefSeq database. Since Dashing’s sketch function is extremely fast, Dashing can perform both sketching and all-pairs distance calculations in the same command, obviating the need to store sketches on disk between steps. Dashing is parallelized, and we show that it scales efficiently to 100 threads. Dashing also uses Single Instruction Multiple Data (SIMD) instructions on modern general-purpose computer processors to exploit the finer-grained parallelism inherent in HLL computations.</p>
  </sec>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <p>Here we discuss Dashing’s design, then present simulation results demonstrating HLL’s accuracy relative to other data structures. We then describe experiments demonstrating Dashing’s accuracy and computational efficiency relative to Mash and BinDash in a range of scenarios.</p>
    <p>Unless otherwise noted, experiments were performed on a Lenovo x3650 M5 system with 4 2.2 Ghz Intel E5-2650 CPUs with 12 cores each and 512 GB of DDR4 RAM. Input genomes and sketches were stored on a SAS-attached Lenovo Storage E1000 disk array with 12 8TB 7,200-RPM disks combined using RAID5. All experiments were conducted using scripts available in the dashing-experiments repository at <ext-link ext-link-type="uri" xlink:href="https://github.com/langmead-lab/dashing-experiments">https://github.com/langmead-lab/dashing-experiments</ext-link>.</p>
    <sec id="Sec3">
      <title>Design</title>
      <p>Dashing uses the HyperLogLog (HLL) sketch to solve genomic distance problems. Dashing takes one or more sequence collections as input. These could be assembled genomes in FASTA format or sequencing datasets in FASTQ format. It then builds an HLL sketch for each input collection based on its <italic>k</italic>-mer content. The sketch can be written to disk or simply forwarded to the next phase, which performs a distance comparison between one or more pairs of sketches. Dashing prints a set of similarity estimates, including estimates for Jaccard coefficient and ANI. It can operate on a given pair of datasets, or can perform all-pairs comparisons across many datasets in a single invocation of the tool.</p>
      <p>Dashing is written in C++14. It uses OpenMP for multithreading, with both the sketching and distance phases readily scaling to 100 simultaneous threads. It also uses data-parallel SIMD instructions, including the recent AVX512-BW extensions that have been effective at accelerating other bioinformatics software [<xref ref-type="bibr" rid="CR23">23</xref>]. Dashing has Python bindings that enable other developers to use the HLL implementation.</p>
    </sec>
    <sec id="Sec4">
      <title>Sketch accuracy</title>
      <p>To assess HLL’s accuracy, we measured Jaccard-coefficient estimation error across a range of set and sketch sizes. We implemented both the HLL [<xref ref-type="bibr" rid="CR16">16</xref>] and MinHash [<xref ref-type="bibr" rid="CR7">7</xref>] structures in Dashing v0.1.2. For HLL, we used Ertl’s Maximum Likelihood Estimator (MLE) to estimate set cardinalities [<xref ref-type="bibr" rid="CR20">20</xref>], though we explore alternate methods in later sections. For MinHash, we used a <italic>k</italic>-bottom sketch with a single hash function, following Mash’s strategy [<xref ref-type="bibr" rid="CR1">1</xref>]. In both cases, we used Thomas Wang’s 64-bit reversible hash function [<xref ref-type="bibr" rid="CR24">24</xref>]. In both cases, the tools used canonicalized <italic>k</italic>-mers, so that a <italic>k</italic>-mer and its reverse complement are treated as equal when sketching. For details on the commands used to obtain the results, see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S1.</p>
      <p>We performed several experiments varying (a) the sizes of the two input sets, (b) the degree of overlap between the sets (to achieve a target <italic>J</italic>), and (c) the size of the sketch data structures. Though the structures differ in character, with the HLL storing an array of narrow integers and the MinHash storing an array of wider integers, we can parameterize them to use the same number of bytes of storage. We populated each structure using its natural insert operation; for the HLL, this involves hashing the item and using the resulting value to identify the target register and possibly update it according to the leading zero count of the remainder bits (detailed below in the “Methods” section). For the bottom-<italic>k</italic> MinHash, inserting involves hashing the item and updating the sketch if the hash is less than the current greatest sketch element. We populated the input sets with random numbers, thereby simulating an ideal hash function with uniformly distributed outputs. Sets were constructed to have target Jaccard coefficients ranging from 0.00022 to 0.818. Many set-size pairs were evaluated ranging from equal-size sets to sets with sizes differing by a factor of 2<sup>12</sup>. In total, we evaluated 36 combinations of set size and <italic>J</italic> were evaluated, with full results presented in Additional file <xref rid="MOESM2" ref-type="media">2</xref>. Note that set size and jaccard coefficient are dependent; if set <italic>A</italic> has cardinality <italic>c</italic> times greater than set <italic>B</italic>, <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$J(A, B) \leq \frac {1}{c}$\end{document}</tex-math><mml:math id="M2"><mml:mi>J</mml:mi><mml:mo>(</mml:mo><mml:mi>A</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>)</mml:mo><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2019_1875_Article_IEq1.gif"/></alternatives></inline-formula>.</p>
      <p>Figure <xref rid="Fig1" ref-type="fig">1</xref> shows Jaccard-coefficient estimation accuracy results for two values of the true Jaccard coefficient (0.0465 and 0.111) and five pairs of unequal-cardinality input sets. HLL exhibited lower absolute error than MinHash in all cases. We also plotted accuracy for input sets of equal size and for Jaccard coefficients of 0.33, 0.6, and 0.82 (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S1). There, HLL exhibited lower absolute error in most but not all scenarios, with HLL’s greatest advantage coming at smaller sketch sizes.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Jaccard-coefficient estimation error using HLL and MinHash. Left column shows experiments with the true Jaccard coefficient fixed at 0.111. Right column shows the same for a coefficient of 0.0465. <italic>x</italic> axis shows the log2 of the size of the sketch data structure in bytes. <italic>y</italic> axis shows the absolute error of the JACCARD-COEFFICIENT estimate. The second row zooms further in with respect to the <italic>y</italic>-axis. Colors indicate the input set sizes, and each pair of inputs differs in size by a factor of 2<sup>3</sup>=8</p></caption><graphic xlink:href="13059_2019_1875_Fig1_HTML" id="MO1"/></fig></p>
      <p>We also compared HLL- and MinHash-based sketches to a Bloom-filter-based approach [<xref ref-type="bibr" rid="CR25">25</xref>]. Like HLL and MinHash, a Bloom filter can represent an approximate set, and filters can be compared to estimate union and intersection cardinalities. We implemented and evaluated both a naive (collision-agnostic) and a collision-aware method [<xref ref-type="bibr" rid="CR26">26</xref>] for estimating set cardinalities via Bloom filters in Dashing v0.1.2. Results are plotted for unequal-cardinality input sets (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S2) and equal-cardinality sets (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figure S3). Details on our Bloom filter implementation are presented in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S2. Bloom-based methods achieved slightly lower absolute error than HLL when the number of bits in the filter approached and exceeded the set cardinality, reflecting the fact that a Bloom-based method eventually converges on error-free “linear counting” given a large enough filter. But HLL exhibited lower error in most circumstances, especially for smaller sketches and larger input sets.</p>
      <p>A complete table of results, including all data structures and reporting both absolute and squared errors, can be found in Additional file <xref rid="MOESM3" ref-type="media">3</xref>. There we observed that even in adverse scenarios (small data structures and very different set sizes) HLL’s absolute error never exceeded 3% (compared to 8% for MinHash). Overall, the results recommend HLL as an accurate and memory-economical sketch requiring no major assumptions about input set sizes.</p>
    </sec>
    <sec id="Sec5">
      <title>Accuracy for complete genomes</title>
      <p>Encouraged by HLL’s accuracy, we measured the accuracy of Dashing v0.1.2’s HLL-based Jaccard-coefficient estimates versus those of Mash v2.1 [<xref ref-type="bibr" rid="CR1">1</xref>] and BinDash v0.2.1 [<xref ref-type="bibr" rid="CR12">12</xref>]. We repeated the HLL experiments for three HLL cardinality estimation methods: Flajolet’s canonical method using harmonic mean [<xref ref-type="bibr" rid="CR16">16</xref>], and two maximum-likelihood-based methods (MLE and JMLE) proposed by Ertl [<xref ref-type="bibr" rid="CR20">20</xref>]. We selected 400 pairs of bacterial genomes from RefSeq [<xref ref-type="bibr" rid="CR27">27</xref>] covering a range of Jaccard-coefficient values. To select the pairs, we first used dashing dist with <italic>s</italic>=16, <italic>k</italic>=31 and the MLE estimation method on the full set of complete bacterial RefSeq assemblies (latest versions). We then selected a subset such that we kept 4 distinct genome pairs per Jaccard-coefficient percentile. Our goal was to test an even spread of Jaccard-coefficient values, though some unevenness emerged later due to differences between data structures and different selections of <italic>k</italic>. Of the genomes included in these pairs, the maximum, minimum, and mean lengths were 11.7 Mbp, 308 kbp, and 4.00 Mbp, respectively. For details on exact commands used to obtain and compare the genome pairs, see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S3.</p>
      <p>We ran the three tools to obtain Jaccard-coefficient estimates for the 400 pairs and plotted the results versus true <italic>J</italic>, as determined using a full hash-table-based <italic>k</italic>-mer counter. Results for <italic>k</italic>=16 and <italic>k</italic>=21 and for sketches of size 2<sup>10</sup> and 2<sup>14</sup> bytes are shown in Fig. <xref rid="Fig2" ref-type="fig">2</xref>. The horizontal axis is divided into 10 <italic>J</italic> partitions, each containing about 40 pairs (see Additional file <xref rid="MOESM3" ref-type="media">3</xref> for number of pairs per partition). The vertical axis shows the difference between tool-estimated and true Jaccard coefficient. For Dashing, we used the MLE estimation method. We made a minor change to the Mash software to allow it to output estimated Jaccard coefficient, as it typically emits only Mash distance.
<fig id="Fig2"><label>Fig. 2</label><caption><p>Estimated versus true Jaccard coefficients (<italic>J</italic>s) for various methods across a range of true <italic>J</italic>. Each point is one pair from an overall set of 400 pairs of genomes, selected to evenly cover the range of true <italic>J</italic>s</p></caption><graphic xlink:href="13059_2019_1875_Fig2_HTML" id="MO2"/></fig></p>
      <p>Dashing’s estimates were consistently near the true <italic>J</italic>. Mash shows a pattern of bias whereby its estimates are somewhat too low at low Jaccard-coefficients then too high at higher coefficients. This is sometimes combined with an overall bias shifting estimates too high (in the case of <italic>k</italic>=16, sketch size = 2<sup>14</sup>) or low (in the case of <italic>k</italic>=21, sketch size = 2<sup>14</sup>). BinDash and Dashing exhibit less <italic>J</italic>-specific bias.</p>
      <p>Additional file <xref rid="MOESM3" ref-type="media">3</xref> shows mean squared Jaccard-coefficient estimation error (meanSE) for a range of sketch sizes and for <italic>k</italic>∈{16,21,31}, also including the two alternate cardinality estimation methods for Dashing (Original and JMLE). In short, BinDash and Dashing consistently achieve lower meanSE than Mash, with BinDash achieving the lowest meanSE at smaller <italic>J</italic>’s and both BinDash and Dashing achieving similar meanSE at intermediate and larger <italic>J</italic>’s. Among the Dashing estimation methods, JMLE consistently achieves the lowest meanSE. For computational efficiency reasons (discussed later), Dashing’s default estimation method is the MLE, which had only slightly higher error than JMLE.</p>
    </sec>
    <sec id="Sec6">
      <title>Computational efficiency</title>
      <p>To assess computational efficiency and scalability in a realistic context, we used Dashing v0.1.2, Mash v2.1 and BinDash v0.2.1 to sketch and perform all-pairs distance calculations for 87,113 complete genome assemblies. We obtained the assemblies from Refseq, filtering to include only assemblies marked “latest” and “Complete genome” and without “contig” in the name. The set included genomes from various taxa, spanning viral, archaeal, bacterial and eukaryotic. Genome lengths varied from 288 bases to 4,502,951,408 bases with mean and median lengths of 9.8 Mb and 3.8 Mb, respectively. The total number of genome-pair distance calculations required for 87,113 assemblies was over 3.79 billion. We repeated the experiment for a range of sketch sizes and <italic>k</italic>-mer lengths. All experiments were performed on a Lenovo x3850 X6 system with 4 2.0 Ghz Intel E7-4830 CPUs, each with 14 processor cores. After hyperthreading, the system supports up to 112 simultaneous hardware threads. The system had 1 TB of DDR4 RAM and ran CentOS 7.5 Linux, kernel v3.10.0. The system was located at and maintained by the Maryland Advanced Research Computing Center (MARCC).</p>
      <p>For Dashing, we used dashing sketch for sketching and dashing dist for pairwise distance calculations. For Mash, we used mash sketch and mash triangle for the two stages respectively. For BinDash, we used bindash sketch and bindash dist. We also ran each tool in a way that performed sketching immediately followed by all-pairs distance calculations. For Mash, this involves running its dist and triangle commands but specifying the sequence files (rather than their sketches) as input. In the case of dashing dist, this combined invocation avoids writing any sketches to disk. Mash provides support for this functionality as well, but we were unable to run it successfully for our large experiment.</p>
      <p>All tools were configured to use up to 100 simultaneous threads of execution (Dashing: -p 100, Mash: -p 100, BinDash: –nthreads=100). Since the system supports a maximum of 112 simultaneous threads, 100 was chosen to achieve high utilization while avoiding excessive contention. We used the GNU time utility to measure the average number of CPUs utilized, wall time, and peak memory footprint for each tool invocation. For details on the exact commands used, see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S4.</p>
      <p>For Dashing, we repeated the experiment for each of its three cardinality estimation methods: Flajolet’s canonical method (“Original”), Ertl’s Maximum Likelihood Estimator (“Ertl-MLE”), and Ertl’s joint MLE (“Ertl-JMLE”).</p>
      <p>Results for <italic>k</italic>=21 and <italic>k</italic>=31 are summarized in Fig. <xref rid="Fig3" ref-type="fig">3</xref>, and a tabular version of the results for <italic>k</italic>=31 is shown in Table <xref rid="Tab1" ref-type="table">1</xref>. Full tabular results including CPU utilization measurements are shown in Additional file <xref rid="MOESM4" ref-type="media">4</xref>.
<fig id="Fig3"><label>Fig. 3</label><caption><p>Computational efficiency of Mash, BinDash and Dashing. Results for <italic>k</italic>=21, <italic>k</italic>=31 and sketches of size 2<sup>10</sup> (1 kb), 2<sup>12</sup> (4 kb), 2<sup>14</sup> (16 kb), and 2<sup>16</sup> (64 kb). “Both” results obtained either by using a combined Sketch+Distance mode (for Dashing) or by combining results from separate sketching and distance-calculation invocations (for Mash and BinDash). Dashing was assessed using three estimation methods: Flajolet’s method using the harmonic mean (“Orig”) and Ertl’s MLE and JMLE methods</p></caption><graphic xlink:href="13059_2019_1875_Fig3_HTML" id="MO3"/></fig>
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Comparison of computational efficiency of Mash, BinDash, and Dashing at <italic>k</italic>=31 and various sketch sizes</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left"/><th align="left">Dashing</th><th align="left">Dashing</th><th align="left">Dashing</th></tr><tr><th align="left">Phase</th><th align="left">Measure</th><th align="left">k</th><th align="left">log2(<italic>s</italic><italic>i</italic><italic>z</italic><italic>e</italic>)</th><th align="left">Mash</th><th align="left">BinDash</th><th align="left">Original</th><th align="left">Ertl-MLE</th><th align="left">Ertl-JMLE</th></tr></thead><tbody><tr><td align="left">Sketch</td><td align="left">Wall clock (s)</td><td align="left">31</td><td align="left">10</td><td align="left">1345</td><td align="left">1157</td><td align="left">273</td><td align="left"><italic>271</italic></td><td align="left">277</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">12</td><td align="left">1349</td><td align="left">1157</td><td align="left">273</td><td align="left">274</td><td align="left"><italic>270</italic></td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">14</td><td align="left">1356</td><td align="left">1159</td><td align="left">286</td><td align="left">289</td><td align="left"><italic>278</italic></td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">16</td><td align="left">1400</td><td align="left">1226</td><td align="left">359</td><td align="left">367</td><td align="left"><italic>299</italic></td></tr><tr><td align="left"/><td align="left">Peak mem (MB)</td><td align="left">31</td><td align="left">10</td><td align="left">17,720</td><td align="left"><italic>141</italic></td><td align="left">12,683</td><td align="left">12,721</td><td align="left">12,644</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">12</td><td align="left">18,296</td><td align="left"><italic>399</italic></td><td align="left">12,723</td><td align="left">12,430</td><td align="left">12,726</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">14</td><td align="left">19,706</td><td align="left"><italic>1426</italic></td><td align="left">12,630</td><td align="left">12,877</td><td align="left">12,853</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">16</td><td align="left">25,127</td><td align="left"><italic>5542</italic></td><td align="left">12,888</td><td align="left">12,412</td><td align="left">12,933</td></tr><tr><td align="left">Distance</td><td align="left">Wall clock (s)</td><td align="left">31</td><td align="left">10</td><td align="left">1901</td><td align="left"><italic>74</italic></td><td align="left">80</td><td align="left">100</td><td align="left">601</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">12</td><td align="left">2368</td><td align="left"><italic>188</italic></td><td align="left">286</td><td align="left">308</td><td align="left">2139</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">14</td><td align="left">3446</td><td align="left"><italic>672</italic></td><td align="left">1113</td><td align="left">1137</td><td align="left">8308</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">16</td><td align="left">8777</td><td align="left"><italic>3603</italic></td><td align="left">6172</td><td align="left">4251</td><td align="left">30,506</td></tr><tr><td align="left"/><td align="left">Peak mem (MB)</td><td align="left">31</td><td align="left">10</td><td align="left">1120</td><td align="left">409</td><td align="left"><italic>116</italic></td><td align="left"><italic>116</italic></td><td align="left"><italic>116</italic></td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">12</td><td align="left">1380</td><td align="left">673</td><td align="left"><italic>371</italic></td><td align="left"><italic>371</italic></td><td align="left">372</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">14</td><td align="left">2785</td><td align="left">1,709</td><td align="left"><italic>1392</italic></td><td align="left"><italic>1392</italic></td><td align="left"><italic>1392</italic></td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">16</td><td align="left">10,776</td><td align="left">5,816</td><td align="left"><italic>5476</italic></td><td align="left"><italic>5476</italic></td><td align="left"><italic>5476</italic></td></tr><tr><td align="left">Both</td><td align="left">Wall clock (s)</td><td align="left">31</td><td align="left">10</td><td align="left">3246</td><td align="left">1,231</td><td align="left"><italic>345</italic></td><td align="left">365</td><td align="left">870</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">12</td><td align="left">3717</td><td align="left">1,345</td><td align="left"><italic>557</italic></td><td align="left">579</td><td align="left">2407</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">14</td><td align="left">4801</td><td align="left">1,831</td><td align="left"><italic>1390</italic></td><td align="left">1,408</td><td align="left">8574</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">16</td><td align="left">10,177</td><td align="left">4,829</td><td align="left"><italic>4394</italic></td><td align="left">4,453</td><td align="left">30,433</td></tr><tr><td align="left"/><td align="left">Peak mem (MB)</td><td align="left">31</td><td align="left">10</td><td align="left">17,720</td><td align="left"><italic>409</italic></td><td align="left">12,468</td><td align="left">12,950</td><td align="left">12,988</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">12</td><td align="left">18,296</td><td align="left"><italic>673</italic></td><td align="left">12,958</td><td align="left">13,042</td><td align="left">13,020</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">14</td><td align="left">19,706</td><td align="left"><italic>1709</italic></td><td align="left">13,951</td><td align="left">13,782</td><td align="left">14,205</td></tr><tr><td align="left"/><td align="left"/><td align="left"/><td align="left">16</td><td align="left">25,127</td><td align="left"><italic>5816</italic></td><td align="left">18,320</td><td align="left">18,081</td><td align="left">18,011</td></tr></tbody></table><table-wrap-foot><p>The log2(<italic>s</italic><italic>i</italic><italic>z</italic><italic>e</italic>) column reports the log2 of the sketch size in bytes. “Both” results obtained either by using a combined Sketch+Distance mode (for Dashing) or by combining results from separate sketching and distance-calculation invocations (for Mash and BinDash). Dashing was assessed using three estimation methods: Flajolet’s method using the harmonic mean (“Original”) and Ertl’s MLE and JMLE methods. Italicized entries indicate the lowest space or time for a given experiment</p></table-wrap-foot></table-wrap></p>
      <p>We observed that Dashing is the fastest tool in the Sketch phase, running 3.3–4.3 times faster than BinDash and 3.8–5.0 times faster than Mash. As shown in Additional file <xref rid="MOESM4" ref-type="media">4</xref>, Dashing also achieves excellent CPU utilization in the Sketch phase.</p>
      <p>BinDash achieves the lowest memory footprint among the tools in the Sketch phase, requiring 140 Mb for the 1-kb sketch and 5.5 GB for the 64-kb sketch. By contrast, Dashing required about 12 GB across all sketch sizes. This is largely because of how Dashing is parallelized; Dashing threads simultaneously work on separate sequence collections, each filling a buffer of size sufficient to hold the largest sequence yet parsed by that thread. Mash had the highest memory footprint, ranging from 17–25 GB.</p>
      <p>In the distance phase, we noted that the estimation method had a major effect on Dashing’s speed, with JMLE performing 5.9–7.4 times slower than MLE. This is because the JMLE performs significantly more calculations, as described in the “Methods” section. This result, together with the relatively small accuracy difference noted earlier, led us to chose the Ertl-MLE method as Dashing’s default. (In a separate experiment, we found that the JMLE inner loop could be made about 20% faster using AVX512BW instructions, as discussed later and detailed in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S5 and Table S1.)</p>
      <p>BinDash was the fastest tool in the distance phase, running 25–70% faster than Dashing’s MLE mode. But Dashing is 2–19 times faster than Mash, with the largest speed gap observed at the smallest (1 kb) sketch size.</p>
      <p>When we compared tools based on combined performance in both the sketch and distance phases, BinDash again had the lowest memory footprint (always below 6 GB), with Dashing’s footprint at 12–18 GB and Mash’s at 17–25 GB. Dashing was the fastest among the three tools at all sketch sizes, though BinDash achieves similar speed at the largest (64 kb) sketch size. Mash was the slowest of the tools in all cases. Since small sketch sizes tend to be used in practice (Mash’s default is 4 kb or 2<sup>12</sup> bytes), we expect Dashing to be the fastest overall tool—certainly for sketching, but also combined sketching and distance calculations—in typical situations.</p>
    </sec>
    <sec id="Sec7">
      <title>Thread scaling</title>
      <p>We also compared the tools’ speed and memory footprint when run with 4, 8, and 16 threads. We found that all three tools achieved excellent thread scaling in the sketching phase, where Dashing achieves the highest throughput. We also found that, for the distance estimation phase, Dashing exhibited better thread scaling compared to Mash and BinDash. See Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S6 and Figure S4 for details.</p>
    </sec>
  </sec>
  <sec id="Sec8" sec-type="discussion">
    <title>Discussion</title>
    <p>Genomics methods increasingly use MinHash and other locality-sensitive hashing approaches as their computational engines. We showed that the HyperLogLog sketch, combined with recent advances in cardinality estimation, offers a superior combination of efficiency and accuracy compared to MinHash. This is true even for small sketches and for the challenging case where the input sets have very different sizes. While HLL has been used in bioinformatics tools before [<xref ref-type="bibr" rid="CR17">17</xref>–<xref ref-type="bibr" rid="CR19">19</xref>], this is the first application to the problem of estimating genomic distances, the first implementation of the highly accurate MLE and Joint-MLE estimators [<xref ref-type="bibr" rid="CR20">20</xref>], and the first comprehensive comparison to MinHash and similar methods. The combination of HLL and JMLE is also notable since it directly estimates the cardinality of an intersection, a meaningful quantity independent of its use in the Jaccard coefficient.</p>
    <p>We implemented HLL-based sketching and distance calculations in the Dashing software tool. Dashing can sketch and calculate pairwise distances for over 87K Refseq [<xref ref-type="bibr" rid="CR27">27</xref>] genomes in around 6 min using its MLE estimation method, 1 kb sketch size, and 100 simultaneous threads of execution (Table <xref rid="Tab1" ref-type="table">1</xref>).</p>
    <p>Dashing’s speed advantage is clearest in the sketching step. Notably, re-sketching from scratch is not much slower than loading pre-made sketches from disk. Thus, Dashing users can forgo the typical practice of saving sketches to disk between steps. Dashing’s accuracy with smaller sketches (Fig. <xref rid="Fig1" ref-type="fig">1</xref>) justifies a lower default sketch size (1 kb) compared to Mash’s default of 4 kb (or 8 kb for long <italic>k</italic>-mers).</p>
    <p>It is interesting to observe that Dashing’s accuracy is comparable to that of BinDash across the Jaccard-index deciles in Table <xref rid="Tab1" ref-type="table">1</xref>. Though Dashing is faster—both at sketching and at combined sketching-and-distance—BinDash’s speed approaches that of Dashing at the highest sketch size tested. As we continue to investigate the HyperLogLog sketch, the b-Bit Minwise Hashing technique underlying BinDash is clearly a close competitor, and it will be important to continue to study it as well. In particular, b-Bit Minwise Hashing is also more amenable to SIMD acceleration, providing a trade-off between resolution as runtime as vector size grows.</p>
    <p>Because the HLL can be used to estimate intersections and unions directly, it can be applied to readily estimate not just Jaccard coefficient but containment (|<italic>A</italic>∩<italic>B</italic>|/|<italic>A</italic>|) or overlap (|<italic>A</italic>∩<italic>B</italic>|/ min(|<italic>A</italic>|,|<italic>B</italic>|)) coefficients.</p>
    <p>The Dashing software also supports several features not supported by Mash or BinDash, including spaced seeds, PHYLIP-based output format, TSV, binary output, asymmetric distances, and a hash-set-based mode that can calculate exact Jaccard coefficients (as we did in one of our experiments) at the cost of memory footprint. Further, Dashing contains its own implementation of MinHash and b-Bit and so is a flexible tool for future situations where a combination of approaches is warranted.</p>
    <p>HLL also comes with drawbacks. As shown in Fig. <xref rid="Fig3" ref-type="fig">3</xref> and Table <xref rid="Tab1" ref-type="table">1</xref>, Dashing is slower than BinDash at distance calculations. This is expected; the b-bit Minwise Hashing approach consists primarily of comparisons of bit-packed suffixes of minimizers, which can be effectively vectorized. By contrast, the distance calculation between two HLL sketches is relatively expensive, requiring exponentiations, divisions, harmonic means, and—for the MLE-based methods—iterative procedures for finding roots of functions. The trade-off between accuracy and computational cost is underlined by Ertl’s Joint MLE [<xref ref-type="bibr" rid="CR20">20</xref>] method, which is both the slowest (even compared to MinHash) but the most accurate of the HLL-based methods. It will be important to continue to refine and accelerate the cardinality-estimation algorithms at the core of dashing dist.</p>
    <p>HLL lacks another advantage of MinHash; when MinHash is used in conjunction with a reversible hash function, it can be used not only to calculate the relevant set cardinalities but also to report the <italic>k</italic>-mers common between the sets. This can provide crucial hints when the eventual goal is to map a read to (or near) its point of origin with respect to the reference, as is the goal for tools like MashMap [<xref ref-type="bibr" rid="CR5">5</xref>].</p>
    <p>Past efforts have considered how to extend MinHash to include information about multiplicities, essentially allowing it to sketch a multiset rather than a set. This can improve accuracy of genomic distance measurements, especially in the presence of repetitive DNA. Finch [<xref ref-type="bibr" rid="CR28">28</xref>] works by capturing more sketch items than strictly needed for the <italic>k</italic>-bottom sketch, then tallying them into a multiset. More theoretical studies have proposed ways to store multiplicities, including BagMinHash [<xref ref-type="bibr" rid="CR29">29</xref>], and SuperMinHash [<xref ref-type="bibr" rid="CR14">14</xref>]. In the future, it will be important to seek similar multiplicity-preserving extensions—and related extensions like <italic>tf-idf</italic> weighting [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR30">30</xref>]—for HLL as well.</p>
    <p>As we consider how HLL can be extended to improve accuracy and handle multiplicities, an asset is that our current design uses only 6 out of the 8 bits that make up each HLL register. (The LZC of our hash cannot exceed 63 and therefore fits in 6 bits.) Thus, 25% of the structure is waiting for an appropriate use. One idea would be to use the bits to store a kind of striped, auxiliary Bloom filter. This would add an alternate sketch whose strength lies in estimating low-cardinality sets. Since we observed that Bloom filters have superior accuracy when the bitvector is large enough to simulate linear counting (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Figures S2 and S3), we could potentially populate the auxiliary filter with the input items (or a sample thereof) and recover some of the accuracy advantage enjoyed by Bloom filters.</p>
    <p>While HLL was used by the KrakenUniq [<xref ref-type="bibr" rid="CR17">17</xref>] tool for metagenomics read classification, KrakenUniq’s implementation allows for a sparse representation of the registers, with 0-count registers omitted and non-0-count registers stored in a sparse array. Sparsity is a reasonable assumption in KrakenUniq, since some taxa have few associated <italic>k</italic>-mers due to relatedness of the genomes at the leaves. The sparsity assumption is less valid in Dashing’s typical usage scenarios, though it can be valid if one input set has few elements compared to the number of HLL registers. In the future, it will be important to investigate whether Dashing can be extended to exploit sparsity where it exists.</p>
    <p>Though we compared to Mash and BinDash here, an alternative approach is used by the Kmer-db software [<xref ref-type="bibr" rid="CR31">31</xref>]. Kmer-db’s data structure captures the <italic>k</italic>-mer content of many input datasets at once. The underlying data structure is a compressed bit matrix with bits indicating membership relationships between <italic>k</italic>-mers (rows) and input datasets (columns). Once a matrix is built, a second phase can perform individual or all-pairwise distance calculations over the samples. Since distinct <italic>k</italic>-mers are represented explicitly—which can take considerable space—the tool gives the option of subsampling the input <italic>k</italic>-mers using a MinHash-based method.</p>
    <p>HLL’s accuracy even when using a small sketch makes it appropriate for search and indexing. It can be seen as performing a similar function as the Sequence Bloom Tree [<xref ref-type="bibr" rid="CR32">32</xref>]. Additionally, because any items which can be hashed can be inserted in a HyperLogLog, dashing could be generalized or extended to other applications, such as comparing text documents by their <italic>n</italic>-grams, or images by extracted features.</p>
  </sec>
  <sec id="Sec9">
    <title>Methods</title>
    <sec id="Sec10">
      <title>HyperLogLog</title>
      <p>The HyperLogLog sketch builds on prior work on approximate counting in <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(\log _{2} \log _{2} (n))$\end{document}</tex-math><mml:math id="M4"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="13059_2019_1875_Article_IEq2.gif"/></alternatives></inline-formula> space. Originally proposed by Morris [<xref ref-type="bibr" rid="CR33">33</xref>] and analyzed by Flajolet [<xref ref-type="bibr" rid="CR34">34</xref>], this method estimates a count by possibly incrementing a counter with exponentially decaying probability. The probability is typically halved after each increment, so the counter approximates the log2 of the true count. While the estimator is unbiased, it has high variance. The hope is that needing only log2 log2(<italic>n</italic>) bits to store a summary—compared to the log2(<italic>n</italic>) needed for a MinHash—allows us to store more summaries total and, after averaging, achieve a better estimate.</p>
      <p>The HLL combines many such counters into one sketch using stochastic averaging [<xref ref-type="bibr" rid="CR35">35</xref>]. Given a stream of data items, we partition them according to the most significant bits (“prefix”) of their hash values. That is, if <italic>o</italic> is an input item and <italic>h</italic> is the hash function, the value <italic>h</italic>(<italic>o</italic>) is partitioned so that <italic>h</italic>(<italic>o</italic>)=<italic>p</italic>⊕<italic>q</italic> for bit-string prefix <italic>p</italic> and suffix <italic>q</italic>. To insert the item, we use <italic>p</italic> as an offset into an array of 8-bit “registers.” We update the register to equal either its current value or the leading zero count (LZC) of suffix <italic>q</italic>, whichever is greater (Fig. <xref rid="Fig4" ref-type="fig">4</xref>a). Note that the LZC of a bit string <italic>x</italic> of length <italic>q</italic> is related to log2(<italic>x</italic>):
<disp-formula id="Equa"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\text{LZC}(x) = \left\{\begin{array}{ll} q, &amp; x = 0 \\ q - 1 - \lfloor \log_{2}(x) \rfloor &amp; x &gt; 0 \end{array}\right. $$ \end{document}</tex-math><mml:math id="M6"><mml:mrow><mml:mtext>LZC</mml:mtext><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfenced close="" open="{" separators=""><mml:mrow><mml:mtable class="array" columnalign="left"><mml:mtr><mml:mtd><mml:mi>q</mml:mi><mml:mo>,</mml:mo></mml:mtd><mml:mtd><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>q</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mo>⌊</mml:mo><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo><mml:mo>⌋</mml:mo></mml:mtd><mml:mtd><mml:mi>x</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:math><graphic xlink:href="13059_2019_1875_Article_Equa.gif" position="anchor"/></alternatives></disp-formula>
<fig id="Fig4"><label>Fig. 4</label><caption><p><bold>a</bold> Relationship between maximum leading zero count (Max LZC) and set size for three randomly-generated sets of 8-bit numbers. The Max LZC roughly estimates the log2 of the set size, though with high variance; here, two of three estimates are off by 2-fold. <bold>b</bold> Schematic of HyperLogLog sketch. Input items are hashed and hash value is partitioned into prefix <italic>p</italic> and suffix <italic>q</italic>. <italic>p</italic> indexes into the array of HLL registers. A register contains the maximum leading zero count among all suffixes <italic>q</italic> that mapped there. Register-level estimates are then combined to obtain an overall cardinality estimate. <bold>c</bold> Estimating cardinalities of sets A and B, and <bold>d</bold> estimating the cardinality of their union. For intersection cardinalities using inclusion-exclusion principle, estimated set and union cardinalities are combined. <bold>e</bold> Direct estimation of intersection cardinality with Ertl’s JMLE</p></caption><graphic xlink:href="13059_2019_1875_Fig4_HTML" id="MO4"/></fig></p>
      <p>Each register ultimately stores a value related to min<italic>q</italic>∈<italic>Q</italic> log2(<italic>q</italic>) where <italic>Q</italic> is the set of suffixes mapping to the register (Fig. <xref rid="Fig4" ref-type="fig">4</xref>b). We can combine estimates across registers by taking their harmonic mean and applying a correction factor, as detailed below. The estimator has a standard error of <inline-formula id="IEq3"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {1.03896}{\sqrt {m}}$\end{document}</tex-math><mml:math id="M8"><mml:mfrac><mml:mrow><mml:mn>1.03896</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2019_1875_Article_IEq3.gif"/></alternatives></inline-formula> [<xref ref-type="bibr" rid="CR16">16</xref>].</p>
      <p>While the HLL is conceptually distinct from MinHash sketches and Bloom filters, it is related to both. Informally, an HLL modified so that the summary stored in each register is a simple minimum (without the log2) is similar to a MinHash sketch. Similarly, a Bloom filter with a single hash function and 2<sup><italic>x</italic></sup> bits is essentially an HLL with an <italic>x</italic>-bit hash prefix and with registers consisting of a single bit each.</p>
    </sec>
    <sec id="Sec11">
      <title>Estimation methods</title>
      <p>The original HLL cardinality estimation method [<xref ref-type="bibr" rid="CR16">16</xref>] combines the register-level estimates by taking a corrected harmonic mean:
<disp-formula id="Equ1"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ E = \frac{\alpha_{m} m^{2}}{\sum\limits_{j=1}^{m} 2^{-M_{j}} }   $$ \end{document}</tex-math><mml:math id="M10"><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>α</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:math><graphic xlink:href="13059_2019_1875_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
      <p>where <italic>α</italic><sub><italic>m</italic></sub> is a correction factor equal to <inline-formula id="IEq4"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {1}{2 \ln 2}$\end{document}</tex-math><mml:math id="M12"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>ln</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2019_1875_Article_IEq4.gif"/></alternatives></inline-formula> and <italic>M</italic><sub><italic>j</italic></sub> is 1 + the maximum LZC stored in register <italic>j</italic>. But the estimator’s accuracy suffers at low and high extremes of cardinality. This has spurred various refinements starting with the original HLL publication [<xref ref-type="bibr" rid="CR16">16</xref>], where linear counting is used to improve estimates for low cardinalities and careful treatment of saturated counters improves high-cardinality estimates.</p>
      <p>Ertl proposed further refinements [<xref ref-type="bibr" rid="CR20">20</xref>]. The “improved estimator” uses the assumptions that (a) the hash function produces uniformly distributed outputs and (b) register values are independent. It then models register count as a Poisson random variable. Estimating the Poisson parameter yields an estimate for the cardinality.</p>
      <p>Ertl’s MLE method again uses the uniformity and Poisson assumptions of the improved method, but the MLE method proceeds by finding the roots—e.g., using Newton’s method or the secant method—of the derivative of the log-likelihood of the Poisson parameter given the register values. Ertl shows that the estimate is lower- and upper-bounded by harmonic means of the per-register estimates. Ertl suggests using the secant method, which uses inexpensive instructions and avoids derivative calculations. We follow this suggestion in Dashing. Ertl also argues that the MLE generally converges in a small number of steps; we confirm that our implementation converges in at most 3 steps in every case we have tested.</p>
      <p>Ertl’s Joint MLE method, unlike those described so far, can directly estimate the cardinality of set intersections. We say “directly” to contrast it with methods that use the inclusion-exclusion principle to estimate intersection cardinality indirectly via cardinalities of sets (Fig. <xref rid="Fig4" ref-type="fig">4</xref>c) and their unions (Fig. <xref rid="Fig4" ref-type="fig">4</xref>d). The JMLE method again adopts the Poisson model, but two sketches, <italic>A</italic> and <italic>B</italic>, are modeled as a mixture of three components, one with elements unique to <italic>A</italic>, another with elements unique to <italic>B</italic> and a third with elements in their intersection <italic>A</italic>∩<italic>B</italic>. The method then jointly estimates the Poisson parameters for the three components. The procedure operates on a set of tallies of how often registers having a certain value in <italic>A</italic> are less than, equal to, or greater than their counterparts in <italic>B</italic> (and vice versa) (Fig. <xref rid="Fig4" ref-type="fig">4</xref>e).</p>
      <p>As discussed in the “Results” section, the JMLE as implemented in Dashing is substantially slower than MLE. This is partly because of the increased complexity of the numerical optimization, as there are more optimization problems and each requires roughly twice as many iterations as for MLE. However, our profiling indicates the added time is chiefly spent on tallying the &lt;, =, &gt; relationships between the sketch registers. This tallying work grows linearly with the sketch size. This highlights the importance of efficient, SIMD-ized inner loops for comparing HLLs.</p>
      <p>We considered but did not include Ertl’s Improved Estimator or the HyperLogLog++ estimator [<xref ref-type="bibr" rid="CR36">36</xref>] in this study as they performed worse than Ertl’s MLE in preliminary comparisons.</p>
    </sec>
    <sec id="Sec12">
      <title>Optimizing speed</title>
      <p>Dashing takes advantage of the fine-grained parallelism inherent in HLLs. Union and intersection cardinalities are the key components of similarity measures like the Jaccard coefficient. For two HLLs having the same number of registers and the same hash function, a sketch of their union is simply the element-wise maximum of their registers. Thus, one fundamental need is to perform element-wise maximum over long vectors of 8-bit registers. Finding the cardinality of an individual set—or of the intersection of two sets using the JMLE—requires tallying statistics over the register array. Thus, another need is to perform tallies (e.g., counting the registers having a particular value) over long vectors of 8-bit registers.</p>
      <p>For set unions, Dashing’s inner loops use Single-Instruction Multiple Data (SIMD) instructions, which are capable of performing fast arithmetic and bitwise operations on vectors of many adjacent operands. These vectors are substantially wider (up to 512 bits) than the typical 32-bit or 64-bit machine words used to store scalar operands. Speedups can be attained by converting important loops to use only or mostly SIMD instructions and to avoid loops with scalar instructions. The more operands per SIMD vector, the greater the potential benefit [<xref ref-type="bibr" rid="CR23">23</xref>]. The ideal would be to use vectors consisting of 8-bit operands, since this matches the HLL register width. While past iterations of the SIMD instruction set operated on 128- and 256-bit vectors of 8-bit operands, only with the recent introduction of Intel’s AVX-512BW instruction set did it become possible to operate on 512-bit vectors of 8-bit operands. We created AVX-512BW versions of inner set-union loops and confirmed that these deliver the greatest distance-estimation throughput, providing 20% speed boost compared to loops based on the older SSE2 SIMD instruction set (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Note S5 and Table S1). For compatibility with older systems, Dashing supports older SIMD instruction sets back to SSE2.</p>
      <p>The process of tallying statistics for set cardinalities and set intersection cardinalities is harder to SIMD-ize in this way. Dashing uses manual loop unrolling to speed up these inner loops, but no SIMD instructions. A question for future work is whether these loops can be rewritten using, for example, a combination of SIMD gather, increment, and scatter operations.</p>
      <p>Dashing also supports use of many simultaneous threads of execution using the OpenMP v4.5 library. The dashing sketch function is parallelized across input files, with distinct threads reading, sketching, and writing sketches for distinct inputs. In dashing dist, threads work in parallel on elements in a row of the upper-triangular matrix while a distinct thread writes out the results. To minimize the overhead associated with global memory-allocation locks, each thread allocates from a private memory buffer. The all-pairs distance calculation uses multiple output buffers and asynchronous I/O to avoid blocking and output-lock contention.</p>
      <p>Another concern is load balance; having many simultaneous threads is beneficial only if we can avoid “straggler” threads that run long after the others have finished. We eliminated an important source of stragglers by performing an up-front large-to-small ordering of the inputs to be sketched. This minimizes the chance that the thread with the largest genome will still be working when others are finishing.</p>
    </sec>
    <sec id="Sec13">
      <title>Sketching sequencing data</title>
      <p>While Dashing supports both FASTA and FASTQ inputs, input data from sequencing experiments require special consideration due to the presence of sequencing errors. Following the strategy of Mash [<xref ref-type="bibr" rid="CR1">1</xref>], Dashing uses an auxiliary data structure at sketching time to remove infrequent <italic>k</italic>-mers that are likely to contain errors. Dashing does this in a single pass. Each <italic>k</italic>-mer in a sequencing experiment is added to a Count-min Sketch (CMS) [<xref ref-type="bibr" rid="CR37">37</xref>], and only if the estimated count for the <italic>k</italic>-mer is sufficiently high is it added to the HLL. The CMS can provide count estimates using an amount of space that grows sublinearly with the number of items.</p>
    </sec>
    <sec id="Sec14">
      <title>Hash function</title>
      <p>We compared clhash, Murmur3’s finalizer, and the Wang hash across a set of synthetic Jaccard index estimates and found that Wang’s had the lowest error (8.20×10<sup>−3</sup>) and bias (−2.14×10<sup>−4</sup>), compared to 8.27×10<sup>−3</sup> and 2.30×10<sup>−4</sup> for Murmur3 and 8.21×10<sup>−3</sup> and −2.66<italic>e</italic>×10<sup>−4</sup> for clhash. In addition to providing the best results, the Wang hash was also much faster than clhash, which is meant for string inputs rather than specialized for 64-bit integers.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec15">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="13059_2019_1875_MOESM1_ESM.pdf">
            <caption>
              <p><bold>Additional file 1</bold> Supplementary notes and figures. All supplementary notes and figures appear in this additional file.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="13059_2019_1875_MOESM2_ESM.xlsx">
            <caption>
              <p><bold>Additional file 2</bold> Full results for sketch accuracy. Full results from the experimental comparison of MinHash, Bloom, Bloom+, and HyperLogLog methods for Jaccard-coefficient estimation on synthetic data. Results are presented in a spreadsheet.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM3">
          <media xlink:href="13059_2019_1875_MOESM3_ESM.xlsx">
            <caption>
              <p><bold>Additional file 3</bold> Full results for accuracy for complete genomes. Jaccard coefficient estimation accuracy across a range of true Jaccard values for BinDash, Mash and 3 HyperLogLog estimation algorithms in tabular format. Experiments were repeated for all combinations of <italic>k</italic>∈{16,21,31} and log2 sketch size ∈{10,11,12,13,14,15}. Results are presented in a spreadsheet.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM4">
          <media xlink:href="13059_2019_1875_MOESM4_ESM.xlsx">
            <caption>
              <p><bold>Additional file 4</bold> Full results for computational efficiency. Space and time efficiency benchmark for all pairwise comparisons between 87,113 genomes for <italic>k</italic>∈{16,21,31} and log2 sketch size ∈{10,14,16} between BinDash, Mash, and 3 HyperLogLog estimation algorithms. Results are presented in a spreadsheet.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s13059-019-1875-0.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>We thank Florian Breitwieser for HLL implementation discussions and Nikita Ivkin for insights with regard to sketch data structure theory and implementation. This work used the Extreme Science and Engineering Discovery Environment (XSEDE), supported by National Science Foundation grant number ACI-1548562.</p>
  </ack>
  <notes notes-type="author-contribution">
    <sec id="FPar1">
      <title>Authors’ contributions</title>
      <p>DNB conceived the method and implemented the software. DNB and BL designed the experiments and wrote the paper. Both authors read and approved the final manuscript.</p>
    </sec>
    <sec id="FPar2">
      <title>Authors’ information</title>
      <p>Twitter handles: Daniel N. Baker @dnb_hopkins and Ben Langmead @BenLangmead.</p>
    </sec>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>BL and DNB were supported by National Science Foundation grant IIS-1349906 to BL and National Institutes of Health/National Institute of General Medical Sciences grant R01GM118568 to BL. Experiments on the Intel Skylake system used the XSEDE Stampede 2 resource at the Texas Advanced Computing Center (TACC), accessed using XSEDE allocation TG-CIE170020 to BL.</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ondov</surname>
            <given-names>BD</given-names>
          </name>
          <name>
            <surname>Treangen</surname>
            <given-names>TJ</given-names>
          </name>
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Mallonee</surname>
            <given-names>AB</given-names>
          </name>
          <name>
            <surname>Bergman</surname>
            <given-names>NH</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Mash: fast genome and metagenome distance estimation using MinHash</article-title>
        <source>Genome Biol</source>
        <year>2016</year>
        <volume>17</volume>
        <issue>1</issue>
        <fpage>132</fpage>
        <?supplied-pmid 27323842?>
        <pub-id pub-id-type="pmid">27323842</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schaeffer</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Pimentel</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Bray</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Pseudoalignment for metagenomic read assignment</article-title>
        <source>Bioinformatics</source>
        <year>2017</year>
        <volume>33</volume>
        <issue>14</issue>
        <fpage>2082</fpage>
        <lpage>8</lpage>
        <?supplied-pmid 28334086?>
        <pub-id pub-id-type="pmid">28334086</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Walenz</surname>
            <given-names>BP</given-names>
          </name>
          <name>
            <surname>Berlin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Miller</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Bergman</surname>
            <given-names>NH</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Canu: scalable and accurate long-read assembly via adaptive k-mer weighting and repeat separation</article-title>
        <source>Genome Res</source>
        <year>2017</year>
        <volume>27</volume>
        <issue>5</issue>
        <fpage>722</fpage>
        <lpage>36</lpage>
        <?supplied-pmid 28298431?>
        <pub-id pub-id-type="pmid">28298431</pub-id>
      </element-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Berlin</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Chin</surname>
            <given-names>CS</given-names>
          </name>
          <name>
            <surname>Drake</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Landolin</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Assembling large genomes with single-molecule sequencing and locality-sensitive hashing</article-title>
        <source>Nat Biotechnol</source>
        <year>2015</year>
        <volume>33</volume>
        <issue>6</issue>
        <fpage>623</fpage>
        <lpage>30</lpage>
        <?supplied-pmid 26006009?>
        <pub-id pub-id-type="pmid">26006009</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jain</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Koren</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Dilthey</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Aluru</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>A fast adaptive algorithm for computing whole-genome homology maps</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <issue>17</issue>
        <fpage>748</fpage>
        <lpage>56</lpage>
        <pub-id pub-id-type="pmid">29069314</pub-id>
      </element-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jain</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Rodriguez-R</surname>
            <given-names>LM</given-names>
          </name>
          <name>
            <surname>Phillippy</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Konstantinidis</surname>
            <given-names>KT</given-names>
          </name>
          <name>
            <surname>Aluru</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>High throughput ANI analysis of 90K prokaryotic genomes reveals clear species boundaries</article-title>
        <source>Nat Commun</source>
        <year>2018</year>
        <volume>9</volume>
        <issue>1</issue>
        <fpage>5114</fpage>
        <?supplied-pmid 30504855?>
        <pub-id pub-id-type="pmid">30504855</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Broder</surname>
            <given-names>AZ</given-names>
          </name>
        </person-group>
        <article-title>On the resemblance and containment of documents</article-title>
        <source>Compression and Complexity of Sequences 1997. Proceedings</source>
        <year>1997</year>
        <publisher-loc>Piscataway, NJ 08854-4141 USA</publisher-loc>
        <publisher-name>IEEE Operations Center</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wood</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>Kraken: ultrafast metagenomic sequence classification using exact alignments</article-title>
        <source>Genome Biol</source>
        <year>2014</year>
        <volume>15</volume>
        <issue>3</issue>
        <fpage>46</fpage>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</article-title>
        <source>Bioinformatics</source>
        <year>2016</year>
        <volume>32</volume>
        <issue>14</issue>
        <fpage>2103</fpage>
        <lpage>10</lpage>
        <?supplied-pmid 27153593?>
        <pub-id pub-id-type="pmid">27153593</pub-id>
      </element-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Buhler</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Efficient large-scale sequence comparison by locality-sensitive hashing</article-title>
        <source>Bioinformatics</source>
        <year>2001</year>
        <volume>17</volume>
        <issue>5</issue>
        <fpage>419</fpage>
        <lpage>28</lpage>
        <?supplied-pmid 11331236?>
        <pub-id pub-id-type="pmid">11331236</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Luo</surname>
            <given-names>Yunan</given-names>
          </name>
          <name>
            <surname>Yu</surname>
            <given-names>Yun William</given-names>
          </name>
          <name>
            <surname>Zeng</surname>
            <given-names>Jianyang</given-names>
          </name>
          <name>
            <surname>Berger</surname>
            <given-names>Bonnie</given-names>
          </name>
          <name>
            <surname>Peng</surname>
            <given-names>Jian</given-names>
          </name>
        </person-group>
        <article-title>Metagenomic binning through low-density hashing</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>35</volume>
        <issue>2</issue>
        <fpage>219</fpage>
        <lpage>226</lpage>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhao</surname>
            <given-names>X</given-names>
          </name>
        </person-group>
        <article-title>Bindash, software for fast genome distance estimation on a typical personal laptop</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>35</volume>
        <issue>4</issue>
        <fpage>651</fpage>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <mixed-citation publication-type="other">Yu YW, Weber G. Hyperminhash: Jaccard index sketching in loglog space. CoRR. 2017; abs/1710.08436. arXiv. http://arxiv.org/abs/1710.08436.</mixed-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <mixed-citation publication-type="other">Ertl O. Superminhash - A new minwise hashing algorithm for jaccard similarity estimation. CoRR. 2017; abs/1706.05698. arXiv. http://arxiv.org/abs/1706.05698.</mixed-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Koslicki D, Zabeti H. Improving min hash via the containment index with applications to metagenomic analysis. bioRxiv. 2017. 10.1101/184150.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <mixed-citation publication-type="other">Flajolet P, Fusy É., Gandouet O, Meunier F. HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm In: Jacquet P, editor. AofA: Analysis of Algorithms. DMTCS Proceedings. Juan les Pins, France: Discrete Mathematics and Theoretical Computer Science: 2007. p. 137–56. <ext-link ext-link-type="uri" xlink:href="https://hal.inria.fr/hal-00406166">https://hal.inria.fr/hal-00406166</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Breitwieser</surname>
            <given-names>FP</given-names>
          </name>
          <name>
            <surname>Baker</surname>
            <given-names>DN</given-names>
          </name>
          <name>
            <surname>Salzberg</surname>
            <given-names>SL</given-names>
          </name>
        </person-group>
        <article-title>KrakenUniq: confident and fast metagenomics classification using unique k-mer counts</article-title>
        <source>Genome Biol</source>
        <year>2018</year>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>198</fpage>
        <?supplied-pmid 30445993?>
        <pub-id pub-id-type="pmid">30445993</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Crusoe</surname>
            <given-names>MR</given-names>
          </name>
          <name>
            <surname>Alameldin</surname>
            <given-names>HF</given-names>
          </name>
          <name>
            <surname>Awad</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Boucher</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Caldwell</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cartwright</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Charbonneau</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Constantinides</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Edvenson</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Fay</surname>
            <given-names>Sea</given-names>
          </name>
        </person-group>
        <article-title>The khmer software package: enabling efficient nucleotide sequence analysis</article-title>
        <source>F1000Res</source>
        <year>2015</year>
        <volume>4</volume>
        <fpage>900</fpage>
        <?supplied-pmid 26535114?>
        <pub-id pub-id-type="pmid">26535114</pub-id>
      </element-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Georganas</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Buluç</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Chapman</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Oliker</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Rokhsar</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Yelick</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Parallel de bruijn graph construction and traversal for de novo genome assembly</article-title>
        <source>Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis. SC ’14</source>
        <year>2014</year>
        <publisher-loc>Piscataway</publisher-loc>
        <publisher-name>IEEE Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <mixed-citation publication-type="other">Ertl O. New cardinality estimation algorithms for hyperloglog sketches. CoRR. 2017; abs/1702.01284. arXiv. http://arxiv.org/abs/1702.01284.</mixed-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <mixed-citation publication-type="other">Baker DN. Dashing: fast and accurate genomic distances using HyperLogLog. 2019. <ext-link ext-link-type="uri" xlink:href="https://github.com/dnbaker/dashing">https://github.com/dnbaker/dashing</ext-link>. Accessed 18 Jan 2019.</mixed-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <mixed-citation publication-type="other">Brown CT, Irber L. sourmash: a library for MinHash sketching of DNA. J Open Source Softw. 2016; 1(5).</mixed-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rahn</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Budach</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Costanza</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Ehrhardt</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hancox</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Reinert</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <article-title>Generic accelerated sequence alignment in SeqAn using vectorization and multi-threading</article-title>
        <source>Bioinformatics</source>
        <year>2018</year>
        <volume>34</volume>
        <issue>20</issue>
        <fpage>3437</fpage>
        <lpage>45</lpage>
        <?supplied-pmid 29726911?>
        <pub-id pub-id-type="pmid">29726911</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <mixed-citation publication-type="other">Wang T. Integer Hash Function. 1997. http://web.archive.org/web/20071223173210/http://www.concentric.net/Ttwa%ng/tech/inthash.htm. Accessed 31 Jul 2017.</mixed-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bloom</surname>
            <given-names>BH</given-names>
          </name>
        </person-group>
        <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>
        <source>Commun ACM</source>
        <year>1970</year>
        <volume>13</volume>
        <issue>7</issue>
        <fpage>422</fpage>
        <lpage>6</lpage>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Swamidass</surname>
            <given-names>SJ</given-names>
          </name>
          <name>
            <surname>Baldi</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Mathematical correction for fingerprint similarity measures to improve chemical retrieval</article-title>
        <source>J Chem Inf Model</source>
        <year>2007</year>
        <volume>47</volume>
        <issue>3</issue>
        <fpage>952</fpage>
        <lpage>64</lpage>
        <?supplied-pmid 17444629?>
        <pub-id pub-id-type="pmid">17444629</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>O’Leary</surname>
            <given-names>NA</given-names>
          </name>
          <name>
            <surname>Wright</surname>
            <given-names>MW</given-names>
          </name>
          <name>
            <surname>Brister</surname>
            <given-names>JR</given-names>
          </name>
          <name>
            <surname>Ciufo</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Haddad</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>McVeigh</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Rajput</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Robbertse</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Smith-White</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ako-Adjei</surname>
            <given-names>Dea</given-names>
          </name>
        </person-group>
        <article-title>Reference sequence (RefSeq) database at NCBI: current status, taxonomic expansion, and functional annotation</article-title>
        <source>Nucleic Acids Res</source>
        <year>2016</year>
        <volume>44</volume>
        <issue>D1</issue>
        <fpage>733</fpage>
        <lpage>45</lpage>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bovee</surname>
            <given-names>Roderick</given-names>
          </name>
          <name>
            <surname>Greenfield</surname>
            <given-names>Nick</given-names>
          </name>
        </person-group>
        <article-title>Finch: a tool adding dynamic abundance filtering to genomic MinHashing</article-title>
        <source>The Journal of Open Source Software</source>
        <year>2018</year>
        <volume>3</volume>
        <issue>22</issue>
        <fpage>505</fpage>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <mixed-citation publication-type="other">Ertl O. Bagminhash - minwise hashing algorithm for weighted sets. arXiv. 2018. http://arxiv.org/abs/1802.03914.</mixed-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <mixed-citation publication-type="other">Chum O, Philbin J, Zisserman A, et al. Near duplicate image detection: min-hash and tf-idf weighting. In: BMVC: 2008. p. 812–5.</mixed-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deorowicz</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Gudys</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Dlugosz</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kokot</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Danek</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Kmer-db: instant evolutionary distance estimation</article-title>
        <source>Bioinformatics</source>
        <year>2019</year>
        <volume>35</volume>
        <issue>1</issue>
        <fpage>133</fpage>
        <lpage>6</lpage>
        <?supplied-pmid 29986074?>
        <pub-id pub-id-type="pmid">29986074</pub-id>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Solomon</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Fast search of thousands of short-read sequencing experiments</article-title>
        <source>Nat Biotechnol</source>
        <year>2016</year>
        <volume>34</volume>
        <issue>3</issue>
        <fpage>300</fpage>
        <lpage>2</lpage>
        <?supplied-pmid 26854477?>
        <pub-id pub-id-type="pmid">26854477</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Morris</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Counting large numbers of events in small registers</article-title>
        <source>Commun ACM</source>
        <year>1978</year>
        <volume>21</volume>
        <issue>10</issue>
        <fpage>840</fpage>
        <lpage>2</lpage>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flajolet</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Approximate counting: a detailed analysis</article-title>
        <source>BIT Num Math</source>
        <year>1985</year>
        <volume>25</volume>
        <issue>1</issue>
        <fpage>113</fpage>
        <lpage>34</lpage>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flajolet</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Martin</surname>
            <given-names>GN</given-names>
          </name>
        </person-group>
        <article-title>Probabilistic counting algorithms for data base applications</article-title>
        <source>J Comput Syst Sci</source>
        <year>1985</year>
        <volume>31</volume>
        <issue>2</issue>
        <fpage>182</fpage>
        <lpage>209</lpage>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Heule</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Nunkesser</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Hall</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Hyperloglog in practice: algorithmic engineering of a state of the art cardinality estimation algorithm</article-title>
        <source>Proceedings of the 16th International Conference on Extending Database Technology. EDBT ’13</source>
        <year>2013</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>ACM</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR37">
      <label>37</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cormode</surname>
            <given-names>Graham</given-names>
          </name>
          <name>
            <surname>Muthukrishnan</surname>
            <given-names>S.</given-names>
          </name>
        </person-group>
        <article-title>An improved data stream summary: the count-min sketch and its applications</article-title>
        <source>Journal of Algorithms</source>
        <year>2005</year>
        <volume>55</volume>
        <issue>1</issue>
        <fpage>58</fpage>
        <lpage>75</lpage>
      </element-citation>
    </ref>
    <ref id="CR38">
      <label>38</label>
      <mixed-citation publication-type="other">Baker DN, Langmead B. Dashing software used in manuscript experiments. 2019. 10.5281/zenodo.3402234. <ext-link ext-link-type="uri" xlink:href="https://zenodo.org/record/3402234">https://zenodo.org/record/3402234</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR39">
      <label>39</label>
      <mixed-citation publication-type="other">Baker DN, Langmead B. Dashing software used in manuscript experiments. 2019. <ext-link ext-link-type="uri" xlink:href="https://github.com/langmead-lab/dashing-experiments">https://github.com/langmead-lab/dashing-experiments</ext-link>.</mixed-citation>
    </ref>
  </ref-list>
</back>
