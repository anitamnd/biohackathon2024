<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName A++V2.4.dtd?>
<?SourceDTD.Version 2.4?>
<?ConverterInfo.XSLTName springer2nlmx2.xsl?>
<?ConverterInfo.Version 1?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Genome Biol</journal-id>
    <journal-id journal-id-type="iso-abbrev">Genome Biol</journal-id>
    <journal-title-group>
      <journal-title>Genome Biology</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1474-7596</issn>
    <issn pub-type="epub">1474-760X</issn>
    <publisher>
      <publisher-name>BioMed Central</publisher-name>
      <publisher-loc>London</publisher-loc>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">7155257</article-id>
    <article-id pub-id-type="publisher-id">2000</article-id>
    <article-id pub-id-type="doi">10.1186/s13059-020-02000-8</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Method</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Inference of single-cell phylogenies from lineage tracing data using Cassiopeia</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Jones</surname>
          <given-names>Matthew G</given-names>
        </name>
        <xref ref-type="aff" rid="Aff1">1</xref>
        <xref ref-type="aff" rid="Aff2">2</xref>
        <xref ref-type="aff" rid="Aff4">4</xref>
        <xref ref-type="aff" rid="Aff5">5</xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Khodaverdian</surname>
          <given-names>Alex</given-names>
        </name>
        <xref ref-type="aff" rid="Aff3">3</xref>
      </contrib>
      <contrib contrib-type="author" equal-contrib="yes">
        <name>
          <surname>Quinn</surname>
          <given-names>Jeffrey J</given-names>
        </name>
        <xref ref-type="aff" rid="Aff4">4</xref>
        <xref ref-type="aff" rid="Aff5">5</xref>
        <xref ref-type="aff" rid="Aff6">6</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Chan</surname>
          <given-names>Michelle M</given-names>
        </name>
        <xref ref-type="aff" rid="Aff4">4</xref>
        <xref ref-type="aff" rid="Aff5">5</xref>
        <xref ref-type="aff" rid="Aff6">6</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Hussmann</surname>
          <given-names>Jeffrey A</given-names>
        </name>
        <xref ref-type="aff" rid="Aff4">4</xref>
        <xref ref-type="aff" rid="Aff5">5</xref>
        <xref ref-type="aff" rid="Aff6">6</xref>
        <xref ref-type="aff" rid="Aff7">7</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Robert</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Xu</surname>
          <given-names>Chenling</given-names>
        </name>
        <xref ref-type="aff" rid="Aff2">2</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Weissman</surname>
          <given-names>Jonathan S</given-names>
        </name>
        <address>
          <email>jonathan.weissman@ucsf.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff4">4</xref>
        <xref ref-type="aff" rid="Aff5">5</xref>
        <xref ref-type="aff" rid="Aff6">6</xref>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Yosef</surname>
          <given-names>Nir</given-names>
        </name>
        <address>
          <email>niryosef@berkeley.edu</email>
        </address>
        <xref ref-type="aff" rid="Aff2">2</xref>
        <xref ref-type="aff" rid="Aff3">3</xref>
        <xref ref-type="aff" rid="Aff8">8</xref>
        <xref ref-type="aff" rid="Aff9">9</xref>
      </contrib>
      <aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="GRID">grid.266102.1</institution-id><institution-id institution-id-type="ISNI">0000 0001 2297 6811</institution-id><institution>Biological and Medical Informatics Graduate Program, </institution><institution>University of California San Francisco, </institution></institution-wrap>San Francisco, CA USA </aff>
      <aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="GRID">grid.47840.3f</institution-id><institution-id institution-id-type="ISNI">0000 0001 2181 7878</institution-id><institution>Center for Computational Biology, </institution><institution>University of California Berkeley, </institution></institution-wrap>Berkeley, CA USA </aff>
      <aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="GRID">grid.47840.3f</institution-id><institution-id institution-id-type="ISNI">0000 0001 2181 7878</institution-id><institution>Department of Electrical Engineering and Computer Science and Center for Computational Biology, </institution><institution>University of California Berkeley, </institution></institution-wrap>Berkeley, CA USA </aff>
      <aff id="Aff4"><label>4</label><institution-wrap><institution-id institution-id-type="GRID">grid.266102.1</institution-id><institution-id institution-id-type="ISNI">0000 0001 2297 6811</institution-id><institution>Howard Hughes Medical Institute, </institution><institution>University of California San Francisco, </institution></institution-wrap>San Francisco, CA USA </aff>
      <aff id="Aff5"><label>5</label><institution-wrap><institution-id institution-id-type="GRID">grid.266102.1</institution-id><institution-id institution-id-type="ISNI">0000 0001 2297 6811</institution-id><institution>Department of Cellular and Molecular Pharmacology, </institution><institution>University of California San Francisco, </institution></institution-wrap>San Francisco, CA USA </aff>
      <aff id="Aff6"><label>6</label><institution-wrap><institution-id institution-id-type="GRID">grid.266102.1</institution-id><institution-id institution-id-type="ISNI">0000 0001 2297 6811</institution-id><institution>Center for RNA Systems Biology, </institution><institution>University of California San Francisco, </institution></institution-wrap>San Francisco, CA USA </aff>
      <aff id="Aff7"><label>7</label><institution-wrap><institution-id institution-id-type="GRID">grid.266102.1</institution-id><institution-id institution-id-type="ISNI">0000 0001 2297 6811</institution-id><institution>University of California, San Francisco, </institution><institution>Department of Microbiology and Immunology, </institution></institution-wrap>San Francisco, California USA </aff>
      <aff id="Aff8"><label>8</label><institution-wrap><institution-id institution-id-type="GRID">grid.461656.6</institution-id><institution-id institution-id-type="ISNI">0000 0004 0489 3491</institution-id><institution>Ragon Institute of Massachusetts General Hospital - MIT and Harvard, </institution></institution-wrap>Cambridge, MA USA </aff>
      <aff id="Aff9"><label>9</label>Chan Zuckerberg Biohub Investigator, San Francisco, CA USA </aff>
    </contrib-group>
    <pub-date pub-type="epub">
      <day>14</day>
      <month>4</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>4</month>
      <year>2020</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2020</year>
    </pub-date>
    <volume>21</volume>
    <elocation-id>92</elocation-id>
    <history>
      <date date-type="received">
        <day>30</day>
        <month>10</month>
        <year>2019</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>3</month>
        <year>2020</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2020</copyright-statement>
      <license license-type="OpenAccess">
        <license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated in a credit line to the data.</license-p>
      </license>
    </permissions>
    <abstract id="Abs1">
      <p id="Par1">The pairing of CRISPR/Cas9-based gene editing with massively parallel single-cell readouts now enables large-scale lineage tracing. However, the rapid growth in complexity of data from these assays has outpaced our ability to accurately infer phylogenetic relationships. First, we introduce Cassiopeia—a suite of scalable maximum parsimony approaches for tree reconstruction. Second, we provide a simulation framework for evaluating algorithms and exploring lineage tracer design principles. Finally, we generate the most complex experimental lineage tracing dataset to date, 34,557 human cells continuously traced over 15 generations, and use it for benchmarking phylogenetic inference approaches. We show that Cassiopeia outperforms traditional methods by several metrics and under a wide variety of parameter regimes, and provide insight into the principles for the design of improved Cas9-enabled recorders. Together, these should broadly enable large-scale mammalian lineage tracing efforts. Cassiopeia and its benchmarking resources are publicly available at www.github.com/YosefLab/Cassiopeia.</p>
    </abstract>
    <kwd-group xml:lang="en">
      <title>Keywords</title>
      <kwd>scRNA-seq</kwd>
      <kwd>Single cell</kwd>
      <kwd>Lineage tracing</kwd>
      <kwd>CRISPR</kwd>
    </kwd-group>
    <custom-meta-group>
      <custom-meta>
        <meta-name>issue-copyright-statement</meta-name>
        <meta-value>© The Author(s) 2020</meta-value>
      </custom-meta>
    </custom-meta-group>
  </article-meta>
</front>
<body>
  <p>The ability to track fates of individual cells during the course of biological processes such as development is of fundamental biological importance, as exemplified by the ground-breaking work creating cell fate maps in <italic>Caenorhabditis elegans</italic> through meticulous visual observation [<xref ref-type="bibr" rid="CR1">1</xref>, <xref ref-type="bibr" rid="CR2">2</xref>]. More recently, CRISPR/Cas9 genome engineering has been coupled with high-throughput single-cell sequencing to enable lineage tracing technologies that can track the relationships between a large number of cells over many generations (Fig. <xref rid="Fig1" ref-type="fig">1</xref>a, [<xref ref-type="bibr" rid="CR3">3</xref>, <xref ref-type="bibr" rid="CR4">4</xref>]). Generally, these approaches begin with cells engineered with one or more recording “target sites” where Cas9-induced heritable insertions or deletions (“indels") accumulate and are subsequently read out by sequencing. A phylogenetic reconstruction algorithm is then used to infer cellular relationships from the pattern of indels. These technologies have enabled the unprecedented exploration of zebrafish [<xref ref-type="bibr" rid="CR5">5</xref>–<xref ref-type="bibr" rid="CR8">8</xref>] and mouse development [<xref ref-type="bibr" rid="CR9">9</xref>, <xref ref-type="bibr" rid="CR10">10</xref>].
<fig id="Fig1"><label>Fig. 1</label><caption><p>A generalized approach to lineage tracing and lineage reconstruction. <bold>a</bold> The workflow of a lineage tracing experiment. First, cells are engineered with lineage tracing machinery, namely Cas9 that cuts a genomic target site; the target site accrues heritable, Cas9-induced indels (“character states”). Next, the indels are read off from single cells (e.g., by scRNA-seq) and summarized in a “character matrix,” where rows represent cells, columns represent individual target sites (or “characters”), and values represent the observed indel (or “character state”). Finally, the character matrix is used to infer phylogenies by one of various methods. <bold>b</bold> The Cassiopeia processing pipeline. The Cassiopeia software includes modules for the processing of target-site sequencing data: first, identical reads are collapsed together and similar reads are error corrected; second, these reads are locally aligned to a reference sequence and indels are called from this alignment; third, unique molecules are aggregated per cell and intra-doublets are called from this information; finally, the cell population is segmented into clones (or lineage groups) and inter-doublets are called. These clones are then passed to Cassiopeia’s reconstruction module for phylogenetic inference. <bold>c</bold> The Cassiopeia reconstruction framework. Cassiopeia takes as input a “character matrix,” summarizing the mutations seen at heritable target sites across cells. Cassiopeia-Hybrid merges two novel algorithms: the “greedy” (Cassiopeia-Greedy) and “Steiner tree/integer linear programming” (Cassiopeia-ILP) approaches. First, the greedy phase identifies mutations that likely occurred early in the lineage and splits cells recursively into groups based on the presence or absence of these mutations. Next, when these groups reach a predefined threshold, we infer Steiner trees, finding the tree of minimum weight connecting all observed cell states across all possible evolutionary histories in a “potential graph,” using integer linear programming (ILP). Finally, these trees (corresponding to the maximum parsimony solutions for each group) are returned and merged into a complete phylogeny</p></caption><graphic xlink:href="13059_2020_2000_Fig1_HTML" id="MO1"/></fig></p>
  <p>However, the scale and complexity of the data produced by these methods are rapidly becoming a bottleneck for the accurate inference of phylogenies. Specifically, traditional algorithms for reconstructing phylogenies (such as neighbor joining [<xref ref-type="bibr" rid="CR11">11</xref>] or Camin-Sokal [<xref ref-type="bibr" rid="CR12">12</xref>]) have not been fully assessed with respect to lineage tracing data and may not be well suited for analyzing large-scale lineage tracing experiments for several reasons. First, traditional algorithms were developed for the cases of few samples (in this case cells), and thus, scalability is a major limitation (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S1). Second, these algorithms are not well suited to handle the amount of missing data that is typical of lineage tracing experiments, which can be “heritable” (resulting from either large Cas9-induced resections that remove target sites or transcriptional silencing) or “stochastic” (caused by incomplete capture of target sites). Third, these approaches do not explicitly take into consideration the design principles of lineage tracers, such as the irreversibility of mutations or the unedited state of the founder cell. Together, these reasons necessitate the development of an adaptable approach for reconstructing single-cell phylogenies and an appropriate benchmarking resource that can aid in the development of such algorithms.</p>
  <p>Ideally, an algorithm for phylogeny inference from lineage tracing data would be robust to experimental parameters (e.g., rate of mutagenesis, the number of Cas9 target sites), scalable to at least tens of thousands of cells, and resilient to missing data. In this study, we introduce Cassiopeia: a novel suite of three algorithms specifically aimed at reconstructing large phylogenies from lineage tracing experiments with special consideration for the Cas9-mutagenesis process and missing data. Cassiopeia’s framework consists of three modules: (1) a greedy algorithm (Cassiopeia-Greedy), which attempts to construct trees efficiently based on mutations that likely occurred earliest in the experiment; (2) a near-optimal algorithm that attempts to find the most parsimonious solution using a Steiner tree approach (Cassiopeia-ILP); and (3) a hybrid algorithm (Cassiopeia-Hybrid) that blends the scalability of the greedy algorithm and the exactness of the Steiner tree approach to support massive single-cell lineage tracing phylogeny reconstruction. To demonstrate the utility of these algorithms, we compare Cassiopeia to existing methods using two resources: first, we benchmark the algorithms using a custom simulation framework for generating synthetic lineage tracing datasets across varying experimental parameters. Second, enabled by a customizable target-site processing pipeline (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b), we assess these algorithms using a new reference in vitro lineage tracing dataset consisting of 34,557 cells over 11 clonal populations. Finally, we use Cassiopeia to explore experimental design principles that could improve the next generation of Cas9-enabled lineage tracing systems.</p>
  <sec id="Sec2" sec-type="results">
    <title>Results</title>
    <sec id="Sec3">
      <title>Cassiopeia: a scalable framework for single-cell lineage tracing phylogeny inference</title>
      <p>Typically, phylogenetic trees are constructed by attempting to optimize a predefined objective over characters (i.e., target sites) and their states (i.e., indels) [<xref ref-type="bibr" rid="CR13">13</xref>]. Distance-based methods (such as neighbor joining [<xref ref-type="bibr" rid="CR11">11</xref>, <xref ref-type="bibr" rid="CR14">14</xref>, <xref ref-type="bibr" rid="CR15">15</xref>] or phylogenetic least-squares [<xref ref-type="bibr" rid="CR16">16</xref>, <xref ref-type="bibr" rid="CR17">17</xref>]) aim to infer a weighted tree that best approximates the dissimilarity between nodes (i.e., the number of characters differentiating two cells should be similar to their distance in the tree). Alternatively, character-based methods aim to infer a tree of maximum parsimony [<xref ref-type="bibr" rid="CR18">18</xref>, <xref ref-type="bibr" rid="CR19">19</xref>]. Conventionally, in this approach, the returned object is a rooted tree (consisting of observed “leaves” and unobserved “ancestral” internal nodes) in which all nodes are associated with a set of character states such that the overall number of changes in character states (between ancestor and child nodes) is minimized. Finally, a third class of methods closely related to character-based ones takes a probabilistic approach over the characters using maximum likelihood [<xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR21">21</xref>] or posterior probability [<xref ref-type="bibr" rid="CR22">22</xref>] as an objective.</p>
      <p>We chose to focus our attention on maximum parsimony-based methods due to the early success of applying these methods to lineage tracing data [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR6">6</xref>] as well as the wealth of theory and applications of these approaches in domains outside of lineage tracing [<xref ref-type="bibr" rid="CR23">23</xref>]. Our framework, Cassiopeia, consists of three algorithms for solving phylogenies. In smaller datasets, we propose the use of a Steiner tree approach (Cassiopeia-ILP) [<xref ref-type="bibr" rid="CR24">24</xref>] for finding the maximum parsimony tree over observed cells. Steiner trees have been extensively used as a way of abstracting network connectivity problems in various settings, such as routing in circuit design [<xref ref-type="bibr" rid="CR25">25</xref>], and have previously been proposed as a general approach for finding maximum parsimony phylogenies [<xref ref-type="bibr" rid="CR26">26</xref>, <xref ref-type="bibr" rid="CR27">27</xref>]. To adapt Steiner trees to single-cell lineage tracing, we devised a method for inferring a large underlying “potential graph” where vertices represent unique cells (both observed and plausible ancestors) and edges represent possible evolutionary paths between cells. Importantly, we tailor this inference specifically to single-cell lineage tracing assays: we model the irreversibility of Cas9 mutations and impute missing data using an exhaustive approach, considering all possible indels in the respective target sites (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). After formulating the potential graph, we use integer linear programming (ILP) as a technique for finding near-optimal solutions to the Steiner tree problem. Because of the NP-Hard complexity of Steiner trees and the difficult approximation of the potential graph (whose effect on solution stability is assessed in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S2), the main limitation of this approach is that it cannot in practice scale to very large numbers of cells.</p>
      <p>To enable Cassiopeia to scale to tens of thousands of cells, we apply a heuristic-based greedy algorithm (Cassiopeia-Greedy) to group cells using mutations that likely occurred early in the lineage experiment. Our heuristic is inspired by the idea of “perfect phylogeny” [<xref ref-type="bibr" rid="CR28">28</xref>, <xref ref-type="bibr" rid="CR29">29</xref>]—a phylogenetic regime in which every mutation (here, Cas9-derived indels) is unique and occurred at most once. For the case of binary characters (i.e., mutated yes/no without accounting for the specific indel), there exists an efficient algorithm [<xref ref-type="bibr" rid="CR30">30</xref>] for deciding whether a perfect phylogeny exists and if so, to also reconstruct this phylogeny. However, two facets of the lineage tracing problem complicate the deduction of whether or not a perfect phylogeny exists: first, the “multi-state” nature of characters (i.e., each character is not binary, but rather can take on several different states, which makes the problem NP-Hard) [<xref ref-type="bibr" rid="CR31">31</xref>, <xref ref-type="bibr" rid="CR32">32</xref>]; and second, the existence of missing data [<xref ref-type="bibr" rid="CR33">33</xref>]. To address these issues, we first take a theoretical approach and prove that since the founder cell (root of the phylogeny) is unedited (i.e., includes only uncut target sites) and that the mutational process is irreversible (i.e., edited sites cannot be recut by Cas9), we are able to reduce the multi-state instance to a binary one so that it can be resolved using a perfect phylogeny-based greedy algorithm. Though Cassiopeia-Greedy does not require a perfect phylogeny, we also prove that if one does exist in the dataset, our proposed algorithm is guaranteed to find it (Theorem 1). Secondly, Cassiopeia-Greedy takes a data-driven approach to handle cells with missing data (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). Unlike Cassiopeia-ILP, Cassiopeia-Greedy is not by design robust to parallel evolution (i.e., “homoplasy,” where a given state independently arises more than once in a phylogeny in different parts of the tree). However, we demonstrate theoretically that in expectation, mutations observed in more cells are more likely to have occurred fewer times in the experiment for sufficiently small, but realistic, ranges of mutation rates (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section; Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S3), thus supporting the heuristic. Moreover, using simulations, we quantify the precision of this greedy heuristic for varying numbers of states and mutation rates, finding in general these splits are precise (especially in these regimes of realistic parameterizations; see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S4). Below, we further discuss simulation-based analyses that illustrate Cassiopeia-Greedy’s effectiveness with varying amounts of parallel evolution (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S5).</p>
      <p>While Cassiopeia-ILP and Cassiopeia-Greedy are suitable strategies depending on the dataset, we can combine these two methods into a hybrid approach (Cassiopeia-Hybrid) that covers a far broader scale of dataset sizes (Fig. <xref rid="Fig1" ref-type="fig">1</xref>c). In this use case, Cassiopeia-Hybrid balances the simplicity and scalability of the multi-state greedy algorithm with the exactness and generality of the Steiner tree approach. The method begins by splitting the cells into several major clades using Cassiopeia-Greedy and then separately reconstructing phylogenies for each clade with Cassiopeia-ILP. This parallel approach on reasonably sized sub-problems (∼ 300 cells in each clade) ensures practical run-times on large numbers of cells (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S1). After solving all sub-problems with the Steiner tree approach, we merge all clades together to form a complete phylogeny (Fig. <xref rid="Fig1" ref-type="fig">1</xref>c).</p>
    </sec>
    <sec id="Sec4">
      <title>A simulation engine enables a comprehensive benchmark of lineage reconstruction algorithms</title>
      <p>To provide a comprehensive benchmark for phylogeny reconstruction, we developed a framework for simulating lineage tracing experiments across a range of experimental parameters. In particular, the simulated lineages can vary in the number of characters (e.g., Cas9 target sites), the number of states (e.g., possible Cas9-induced indels), the probability distribution over these states, the mutation rate per character, the number of cell generations, and the amount of missing data. We started by estimating plausible “default” values for each simulation parameter using experimental data (discussed below and indicated in Fig. <xref rid="Fig2" ref-type="fig">2</xref>). In each simulation run, we varied one of the parameters while keeping the rest fixed to their default value. The probability of mutating to each state was found by interpolating the empirical distribution of indel outcomes (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S6, see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). Each parameter combination was tested using a maximum of 50 replicates or until convergence, each time sampling a set of 400 cells from the total 2<sup><italic>D</italic></sup> cells (where <italic>D</italic> is the depth of the simulated tree).
<fig id="Fig2"><label>Fig. 2</label><caption><p>Cassiopeia algorithms outperform other phylogenetic reconstruction methods on simulated lineages. Accuracy is compared between five algorithms (Cassiopeia-Greedy, Cassiopeia-ILP, and Cassiopeia-Hybrid algorithms as well as neighbor joining and Camin-Sokal) on 400 cells. Phylogeny reconstruction accuracy is assessed with the triplets correct statistic across several experimental regimes: <bold>a</bold> the number of characters, <bold>b</bold> the mutation rate (i.e., Cas9 cutting rate), <bold>c</bold> the depth of the tree (or length of the experiment), <bold>d</bold> the number of states per character (i.e., number of possible indel outcomes), and <bold>e</bold> the dropout rate. Dashed lines represent the default value for each stress test. Between 10 and 50 replicate trees were reconstructed, depending on the stability of triplets correct statistic and overall runtime. Standard error over replicates is represented by the shaded area</p></caption><graphic xlink:href="13059_2020_2000_Fig2_HTML" id="MO2"/></fig></p>
      <p>We compare the performance of our Cassiopeia algorithms (Cassiopeia-ILP, Cassiopeia-Greedy, and Cassiopeia-Hybrid) as well as an alternative maximum parsimony algorithm, Camin-Sokal (previously used in lineage tracing applications [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR6">6</xref>]), and the distance-based algorithm neighbor joining. We assess performance using a combinatoric metric, “triplets correct” (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S7, see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section), which compares the proportion of cell triplets that are ordered correctly in the tree. Importantly, this statistic is a weighted average of the triplets, stratified by the depth of the triplet (measured by the distance from the root to the latest common ancestor (LCA); see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). As opposed to other tree comparison metrics, such as Robinson-Foulds [<xref ref-type="bibr" rid="CR34">34</xref>], we reason that combinatoric metrics [<xref ref-type="bibr" rid="CR35">35</xref>] more explicitly address the needs of fundamental downstream analyses, namely determining evolutionary relationships between cells (though the triplets correct statistic largely agrees with distance-based metrics; see Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S7b).</p>
      <p>Overall, our simulations demonstrate the strong performance and efficiency of Cassiopeia. Specifically, we see that the Cassiopeia suite of algorithms consistently finds more accurate trees as compared to both Camin-Sokal and neighbor joining (Fig. <xref rid="Fig2" ref-type="fig">2</xref>a–e, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S8a-e). Furthermore, not only are trees produced with Cassiopeia more accurate than existing methods, but also more parsimonious across all parameter ranges—serving as an indication that the trees reach a more optimal objective solution (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S9). Importantly, we observe that Cassiopeia-Hybrid and Cassiopeia-Greedy are more effective than neighbor joining in moderately large sample regimes (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S10). Notably, Cassiopeia-Greedy and Cassiopeia-Hybrid both scale to especially large regimes (of up to 50,000 cells, a scale that includes the approximate upper limit of most current single-cell sequencing experiments) without substantial compromise in accuracy (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S11). In contrast, Camin-Sokal and Cassiopeia-ILP could not scale to such input sizes (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S1). Finally, we observe that under a bootstrapping analysis, Cassiopeia’s modules are robust to lineage tracing data (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S12a,b) as compared to neighbor joining for reference (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S12c, though neighbor joining’s stability may be improved with more sophisticated distance functions and feature selection).</p>
      <p>These simulations additionally grant insight into critical design parameters for lineage recording technology. Firstly, we observe that the “information capacity” (i.e., number of characters and possible indels, or states) of a recorder confers an increase in accuracy for Cassiopeia’s modules but not necessarily Camin-Sokal and neighbor joining (though they do perform moderately well in low information capacity simulations; Fig. <xref rid="Fig2" ref-type="fig">2</xref>a, d). This is likely because the greater size of the search space negatively affects the performance of these two algorithms (in other contexts referred to as the “curse of dimensionality” [<xref ref-type="bibr" rid="CR36">36</xref>]). In addition to the information capacity, we find that indel distributions that tend towards a uniform distribution (and thus higher entropy) allow for more accurate reconstructions especially when the number of states is small or the number of samples is large (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S13). Unsurprisingly, the proportion of missing data causes a precipitous decrease in performance (Fig. <xref rid="Fig2" ref-type="fig">2</xref>e). Furthermore, in longer experiments where the observed cell population is sampled from a larger pool of cells, we find that the problem tends to become more difficult (Fig. <xref rid="Fig2" ref-type="fig">2</xref>c).</p>
      <p>Furthermore, these results grant further insight into how Cassiopeia-Greedy is affected in regimes where parallel evolution is likely: such as in low information capacity regimes (e.g., where the number of possible indels is less than 10, Fig. <xref rid="Fig2" ref-type="fig">2</xref>d) or with high mutation rates (Fig. <xref rid="Fig2" ref-type="fig">2</xref>b). In both of these regimes, the proportion of parallel evolution mutations of all mutations increases (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S14). While Cassiopeia-ILP outperforms Cassiopeia-Greedy in these simulations, highlighting its utility to solve small, yet complex, datasets, we further explored Cassiopeia-Greedy’s effectiveness in these regimes. To strengthen our previous theoretical results suggesting that indels observed in more cells are more likely to occur fewer times and earlier in the phylogeny (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S3), we explored how parallel evolution affects Cassiopeia-Greedy empirically with simulation. Specifically, we simulated trees with varying numbers of parallel evolution events at various depths and find overall that while performance decreases with the number of these events, the closer these events occur to the leaves, the smaller thes effect (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S5). Furthermore, we find that under the “default” simulation parameters (as determined by the experimental data; Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S6 and <xref rid="Fig3" ref-type="fig">3</xref>), Cassiopeia-Greedy consistently makes accurate choices of the first indel event by which cells are divided into clades (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S4b). Of course in regimes where possible, Cassiopeia-ILP outperforms Cassiopeia-Greedy when there are few states (i.e., fewer than 10; Fig. <xref rid="Fig2" ref-type="fig">2</xref>d) or high mutation rates (i.e., greater than 10%; Fig. <xref rid="Fig2" ref-type="fig">2</xref>b).
<fig id="Fig3"><label>Fig. 3</label><caption><p>An in vitro reference experiment. <bold>a</bold> A reference lineage tracing dataset was generated using the technology proposed in Chan et al. [<xref ref-type="bibr" rid="CR10">10</xref>] to human cells cultured in vitro for ∼15 generations. A total of 34,557 cells were analyzed after filtering and error correction. Only the initial split (into two plates) is shown. Analysis of the subsequent split (into four plates) is provided in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S22. <bold>b</bold>–<bold>f</bold> Summary of relevant lineage tracing parameters for each clonal population in the experiment: <bold>b</bold> the number of characters per clone, <bold>c</bold> the number of states per target site, <bold>d</bold> the estimated mutation rate per target site, <bold>e</bold> the median dropout per target site, and <bold>f</bold> the proportion of uniquely marked cells. Gray shading denotes parameter regimes tested in simulations, and red-dashed lines denote the default values for each synthetic benchmarks</p></caption><graphic xlink:href="13059_2020_2000_Fig3_HTML" id="MO3"/></fig></p>
      <p>Practically, the issue of parallel evolution can be addressed to some extent by incorporating state priors (i.e., probabilities of Cas9-induced indel formation). Ideally, Cassiopeia-Greedy would use these priors to select mutations that are of low probability, but observed at high frequency. Theoretically, this would be advantageous as low-probability indels are expected to occur fewer times in the tree (<xref rid="Equ1" ref-type="">1</xref>); thus, if they appear at high frequency at the leaves, it is especially likely that these occurred earlier in the phylogeny. Furthermore, our precision analysis indicates that Cassiopeia-Greedy’s decisions are especially precise if it chooses an indel with a low prior (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S4). To incorporate these priors in practice, we selected a link function (i.e., one translating observed frequency and prior probability to priority) that maximized performance for Cassiopeia-Greedy (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S15; see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). After finding an effective approach for integrating prior probabilities, we performed the same benchmarks and found that in cases of likely parallel evolution the priors confer an increase in accuracy (e.g., with high mutation rates; Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S16), especially in larger regimes (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S11).</p>
      <p>Here, we have introduced a flexible simulator that is capable of fitting real data and thus can be used for future benchmarking of algorithms. Using this simulator and a wide range of parameters, we have demonstrated that Cassiopeia performs substantially better than traditional methods. Furthermore, these simulations grant insight into how Cassiopeia’s performance is modulated by various experimental parameters, suggesting design principles that can be optimized to bolster reconstruction accuracy. Specifically, these simulations suggest that these technologies would benefit most from increases in information capacity, via more target sites or more diverse indel outcomes, and mutation rates tuned appropriately as to ensure low rates of parallel evolution. We anticipate that this resource will continue to be of use in exploring design principles of recorders and the effectiveness of novel algorithms.</p>
    </sec>
    <sec id="Sec5">
      <title>An in vitro reference experiment allows evaluation of approaches on empirical data</title>
      <p>Existing experimental lineage tracing datasets lack a defined ground truth to test against, thus making it difficult to assess phylogenetic accuracy in practice. To address this, we performed an in vitro experiment tracking the clonal expansion of human cells (A549 lung adenocarcinoma cell line) engineered with a previously described lineage tracing technology [<xref ref-type="bibr" rid="CR10">10</xref>]. Here, we tracked the growth of 11 clones (each with non-overlapping target site sets for deconvolving clonal populations) over the course of 21 days (approx. 15 generations on average), randomly splitting the pool of cells into two plates every 7 days (Fig. <xref rid="Fig3" ref-type="fig">3</xref>a; see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). At the end of the experiment, we sampled approximately 10,000 cells from each of the four final plates. This randomized plate splitting strategy establishes a course-grained ground truth of how cells are related to each other. Here, cells within the same plate can be arbitrarily distant in their lineage; however, there is only a lower bound on lineage dissimilarity between cells in different plates (since they are by definition at least separated by the number of mutations that have occurred since the last split). Thus, overall, on average, we expect cells within the same plate to be closer to each other in the phylogeny than cells from different plates. However, due to the considerations discussed above, we also expect to see some cells more closely related across plates than within (Fig. <xref rid="Fig3" ref-type="fig">3</xref>a, right), and indels relating these cells across plates are likely to have occurred before the split.</p>
      <p>Our lineage recorder is based on a constitutively expressed target sequence consisting of three evenly spaced cut sites (each cut site corresponding to a character) and a unique integration barcode (“intBC”) which we use to distinguish between target sites and thus more accurately relate character states across cells (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b). The target sites are randomly integrated into the genomes of founder cells at high copy number (on average 10 targets per cell or a total of 30 independently evolving characters; Fig. <xref rid="Fig3" ref-type="fig">3</xref>b, S18c). We built upon the processing pipeline in our previous work [<xref ref-type="bibr" rid="CR10">10</xref>] to obtain confident indel information from scRNA-seq reads (Fig. <xref rid="Fig1" ref-type="fig">1</xref>b, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S17 &amp; Fig S18, see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section for pre-processing procedures and guidelines, especially the “<xref rid="Sec19" ref-type="sec">Guidelines for final quality control</xref>” section). In addition, we have added modules for the detection of cell doublets using the sets of intBCs in each clone and the indels detected within cells and have determined an effective detection strategy using simulations (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S19). Importantly, though not directly applicable here, this doublet detection can be supplemented by other approaches when transcriptional data [<xref ref-type="bibr" rid="CR37">37</xref>, <xref ref-type="bibr" rid="CR38">38</xref>] or multiplexing barcodes [<xref ref-type="bibr" rid="CR39">39</xref>] are available. Additionally, we rely on a data-driven approach for estimating the likelihoods of each indel (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section; Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S20) because other approaches for indel-likelihood prediction [<xref ref-type="bibr" rid="CR40">40</xref>–<xref ref-type="bibr" rid="CR42">42</xref>] may be biased by cell type or cell state.</p>
      <p>After quality control, error correction, and filtering, we proceeded with analyzing a total of 34,557 cells across 11 clones. This diverse set of clonal populations represent various levels of indel diversity (i.e., number of possible states, Fig. <xref rid="Fig3" ref-type="fig">3</xref>c), size of intBC sets (i.e., number of characters, Fig. <xref rid="Fig3" ref-type="fig">3</xref>b and Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S18c), character mutation rates (Fig. <xref rid="Fig3" ref-type="fig">3</xref>d, see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section), and proportion of missing data (Fig. <xref rid="Fig3" ref-type="fig">3</xref>e, see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). Most importantly, this dataset represents a significant improvement in lineage tracing experiments: it is the longest and most complex dataset to date in which the large majority of cells, over the entire cell population, have unique mutation states (71% after all quality control and filtering; percentages of unique cells per clone is presented in Fig. <xref rid="Fig3" ref-type="fig">3</xref>f), indicating a rich character state complexity for tree building.</p>
      <p>We next reconstructed trees for each clone (excluding two which were removed through quality-control filters; see “<xref rid="Sec8" ref-type="sec">Methods</xref>” section) with our suite of algorithms, as well as neighbor joining and Camin-Sokal (when computationally feasible). For both Cassiopeia-Greedy and Cassiopeia-Hybrid methods, we also compared tree reconstruction accuracy with or without prior probabilities. The tree for Clone 3, consisting of 7289 cells, along with its character matrix and first split annotations (i.e., whether cells were initially split into plate 0 or plate 1, denoted as the plate ID), is presented in Fig. <xref rid="Fig4" ref-type="fig">4</xref>. Interestingly, we find that certain indels indeed span the different plates, thus suggesting that Cassiopeia-Greedy chooses as early splits indels which likely occurred prior to the first separation of plates (though this could also be due to parallel events that occurred independently at each plate). Moreover, the character matrix and the nested dissection of the tree illustrate the abundant lineage information encoded in this clone (96% of the 7289 observed cells have unique mutation states) which allows Cassiopeia to infer a relatively deep tree (Fig. <xref rid="Fig4" ref-type="fig">4</xref>d). Despite this complexity, Cassiopeia infers a tree that largely agrees with the observed mutations: cells close to one another in the tree tend to have similar mutations (Fig. <xref rid="Fig4" ref-type="fig">4</xref>e).
<fig id="Fig4"><label>Fig. 4</label><caption><p>Cassiopeia can reconstruct high-resolution phylogenetic trees from empirical lineage tracing data. The full phylogenetic tree for Clone 3 (<bold>a</bold>), consisting of 7289 cells, was reconstructed using Cassiopeia-Hybrid (with priors) and is displayed. The phylogram represents cell-cell relationships, and each cell is colored by sample ID at the first split (plate 0 or 1). The character matrix is displayed with each unique character state (or “indel”) represented by distinct colors (light gray represents uncut sites; white represents missing values). Of these 7289 cells, 96% were uniquely tagged by their character states. <bold>b</bold>, <bold>c</bold> Nested, expanded views of the phylogram and character matrices. As expected, Cassiopeia correctly relates cells with similar character states, and closely related cells are found within the same culture plate. <bold>d</bold> A histogram of the tree depth of each leaf from the root (mean = 8.22, max = 15). <bold>e</bold> Concordance between normalized allelic distance and normalized phylogenetic distance (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section; Pearson’s correlation = 0.53)</p></caption><graphic xlink:href="13059_2020_2000_Fig4_HTML" id="MO4"/></fig></p>
      <p>By keeping track of which plate each cell came from, we are able to evaluate how well the distances in a computationally reconstructed tree reflect the distances in the experimental tree. Thus, we test the reconstruction ability of an algorithm using two metrics for measuring the association between plate ID and substructure: “meta purity” and “mean majority vote” (see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). Both are predicated on the assumption that, just as in the real experiment, as one descends the reconstructed tree, one would expect to find cells more closely related to one another. In this sense, we utilize these two metrics for testing homogeneous cell labels below a certain internal node in a tree, which we refer to as a “clade.”</p>
      <p>We use these statistics to evaluate reconstruction accuracy for Clone 3 with respect to the first split labels (i.e., plate 0 or 1, Fig. <xref rid="Fig5" ref-type="fig">5</xref>). In doing so, we find that Cassiopeia-Greedy and Cassiopeia-Hybrid consistently outperform neighbor joining. We find overall consistent results for the remainder of clones reconstructed (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S21, and additionally when considering the subsequent split into four plates—Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S21), although Cassiopeia’s modules have the greatest advantage in larger reconstructions. Specifically, Camin-Sokal and neighbor joining perform similarly to Cassiopeia’s modules on clones with few cells (e.g., Clone 11) or with low cell diversity (e.g., Clone 5, where target sites are “exhausted,” possibly due to too-fast cutting, (Fig. <xref rid="Fig3" ref-type="fig">3</xref>f, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S23). Both cases indicate that in smaller and less complex clones traditional algorithms may be sufficient for reconstruction. Additionally, many of the issues described previously—parallel evolution, missing data, and information content—contribute to inferential errors in this empirical dataset (for example, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S24).
<fig id="Fig5"><label>Fig. 5</label><caption><p>Cassiopeia builds highly accurate trees from large empirical datasets. The consistency between tree reconstructions is evaluated with respect to the first split. The mean majority vote (<bold>a</bold>) and the meta purity test (<bold>b</bold>) were used for Cassiopeia-Hybrid and Cassiopeia-Greedy (both with or without priors) and neighbor joining. The statistics are plotted as a function of the number of clades at the depth of the test (i.e., the number of clades created by a horizontal cut at a given depth). All Cassiopeia approaches consistently outperform neighbor joining by both metrics</p></caption><graphic xlink:href="13059_2020_2000_Fig5_HTML" id="MO5"/></fig></p>
      <p>Overall, we anticipate that this in vitro dataset will serve as a valuable empirical benchmark for future algorithm development. Specifically, we have demonstrated how this dataset can be used to evaluate the accuracy of inferred phylogenies and illustrate that Cassiopeia consistently outperforms neighbor joining for the purposes of reconstructing trees from single-cell lineage tracing technologies. Moreover, we demonstrate Cassiopeia’s scalability for reconstructing trees that are beyond the abilities of other maximum parsimony-based methods like Camin-Sokal as they currently have been implemented.</p>
    </sec>
    <sec id="Sec6">
      <title>Generalizing Cassiopeia to alternative and future technologies</title>
      <p>While previous single-cell lineage tracing applications have proposed methods for phylogenetic reconstruction, they have been custom-tailored to the experimental system, requiring one to filter out common indels [<xref ref-type="bibr" rid="CR7">7</xref>] or provide indel likelihoods [<xref ref-type="bibr" rid="CR10">10</xref>]. We thus investigated how well Cassiopeia generalizes to other technologies with reconstructions of data generated with the GESTALT technology applied to zebrafish development [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR6">6</xref>] (Fig. <xref rid="Fig6" ref-type="fig">6</xref>a, Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S25). Comparing Cassiopeia’s algorithms to neighbor joining and Camin-Sokal (as applied in these previous studies [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR6">6</xref>]), we find that Cassiopeia-ILP consistently finds the most parsimonious solution. Furthermore, the mean majority vote statistic also indicates that there is strong tissue-type enrichment as a function of tree depth, agreeing with Camin-Sokal’s reconstruction which was used in the original study [<xref ref-type="bibr" rid="CR6">6</xref>] (Fig. <xref rid="Fig6" ref-type="fig">6</xref>b). Together, these results clearly demonstrates Cassiopeia’s effectiveness for existing alternative lineage tracing technologies.
<fig id="Fig6"><label>Fig. 6</label><caption><p>Generalizing Cassiopeia and future design principles of CRISPR-enabled lineage tracers. <bold>a</bold> Cassiopeia generalizes to alternative lineage tracing methods, as illustrated with the analysis of data from GESTALT technology [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR6">6</xref>]). In a comparison of parsimony across Camin-Sokal, neighbor joining, and Cassiopeia’s methods, the Steiner tree approach consistently finds more parsimonious (i.e., more optimal) solutions. <italic>Z</italic>-scores for each dataset are annotated over each tile. <bold>b</bold> Biological integrity of trees for each zebrafish from Raj et al. [<xref ref-type="bibr" rid="CR6">6</xref>], inferred with Cassiopeia-ILP, was assessed using the mean membership statistic (the ”<xref rid="Sec8" ref-type="sec">Methods</xref>” section) with respect to tissue-type annotations from the original study. <bold>c</bold> Exploring information capacity of recorders with base editors. A theoretical base editor was simulated for 400 cells and reconstructions with Cassiopeia-Hybrid, with and without priors. We compared the accuracy of the reconstructions to the simulated tree using the triplets correct statistic. We describe the performance of Cassiopeia-Hybrid as the number of characters was increased (and consequently number of states was decreased)</p></caption><graphic xlink:href="13059_2020_2000_Fig6_HTML" id="MO6"/></fig></p>
      <p>After establishing Cassiopeia’s generalizability, we turned to investigating plausible next-generation lineage tracers. Recently, base-editing systems (Fig. <xref rid="Fig6" ref-type="fig">6</xref>c) have been proposed to precisely edit <italic>A</italic>&gt;<italic>G</italic> [<xref ref-type="bibr" rid="CR43">43</xref>], <italic>C</italic>&gt;<italic>T</italic> [<xref ref-type="bibr" rid="CR44">44</xref>, <xref ref-type="bibr" rid="CR45">45</xref>], or possibly <italic>C</italic>&gt;<italic>N</italic> (<italic>N</italic> being any base as in [<xref ref-type="bibr" rid="CR46">46</xref>]). The promise of base-editing lineage recorders is threefold: first, a base editor would increase the number of editable sites (as compared to the ones that rely on Cas9-induced double-strand breaks [<xref ref-type="bibr" rid="CR5">5</xref>, <xref ref-type="bibr" rid="CR7">7</xref>, <xref ref-type="bibr" rid="CR10">10</xref>]) although at the expense of the number of states (at best 4, corresponding to A, C, T, and G). Second, a base-editing system would theoretically result in less dropout, since target site resection via Cas9-induced double-strand breaks is far less likely [<xref ref-type="bibr" rid="CR44">44</xref>]. Third, it is hypothesized that base editors would be less cytotoxic as it does not depend on inducing double-strand breaks on DNA (although this relies on effective strategies for limiting off-target base editing of DNA and RNA [<xref ref-type="bibr" rid="CR47">47</xref>]). To evaluate the application of base editors for lineage tracing, we tested the performance of Cassiopeia in high-character, low-state regimes as would be the case in base editing (Fig. <xref rid="Fig6" ref-type="fig">6</xref>c, see the “<xref rid="Sec8" ref-type="sec">Methods</xref>” section). Using simulations with parameters deduced by a recent base editor application [<xref ref-type="bibr" rid="CR46">46</xref>], we demonstrate that there appears to be an advantage of having more characters than states (Fig. <xref rid="Fig6" ref-type="fig">6</xref>c). Of note, we did not observe any substantial deviation in these simulations from our initial scalability benchmarks in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S1. This suggests that base editors may be a promising future direction for lineage tracing from a theoretical perspective.</p>
      <p>Another potentially promising design consideration concerns the range of character mutation rates and their variability across different target sites—a parameter that can be precisely engineered [<xref ref-type="bibr" rid="CR48">48</xref>]. In this design, one would expect the variability to help distinguish between early and late branching points and consequently achieve better resolution of the underlying phylogeny [<xref ref-type="bibr" rid="CR9">9</xref>, <xref ref-type="bibr" rid="CR49">49</xref>, <xref ref-type="bibr" rid="CR50">50</xref>]. We simulated “Phased Recorders” (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S26) with varying levels of target-site cutting variability and observe that this design allows for better inference when the distributions of mutation probabilities are more dispersed (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S26b). This becomes particularly useful when one can integrate accurate indel priors into Cassiopeia.</p>
      <p>Overall, these results serve to illustrate how Cassiopeia and the simulation framework can be used to explore experimental designs. While there inevitably will be challenges in new implementations, these analyses demonstrate theoretically how design parameters can be optimized for downstream tree inference. In this way, the combination of our algorithms and simulations enables others to explore not only new algorithmic approaches to phylogenetic reconstruction but also new experimental approaches for recording lineage information.</p>
    </sec>
  </sec>
  <sec id="Sec7" sec-type="conclusion">
    <title>Conclusions</title>
    <p>In this study, we have presented three resources supporting future single-cell lineage tracing technology development and applications. Firstly, we described Cassiopeia, a scalable and accurate maximum parsimony framework for inferring high-resolution phylogenies in single-cell lineage tracing experiments. Next, we introduced a simulation approach for benchmarking reconstruction methods and investigating novel experimental designs. Finally, we generated the largest and most diverse empirical lineage tracing experiment to date, which we present as a reference for the systematic evaluation of phylogeny inference on real lineage tracing data. With the combination of these three resources, we have demonstrated the improved scalability and accuracy of Cassiopeia over traditional approaches for single-cell lineage tracing data and have explored design principles for more accurate tracing. To ensure broad use, we have made a complete software package, including the algorithms, the simulation framework, and a processing pipeline for raw data, all publicly available at www.github.com/YosefLab/Cassiopeia.</p>
    <p>The results highlighted in this manuscript demonstrate the variability in reconstruction accuracy for each of Cassiopeia’s modules depending on the parameters. As introduced here, we suggest using Cassiopeia-ILP for small regimes (fewer than 200 cells) especially where there is low information capacity, Cassiopeia-Greedy for extremely large regimes (10,000 cells and larger), and Cassiopeia-Hybrid for intermediate regimes. Ideally, Cassiopeia-Hybrid could be run in all situations and transition appropriately between Cassiopeia-Greedy and Cassiopeia-ILP depending on the complexity of the data. While here we use the number of cells as the criterion for transitioning, we anticipate there is a more consistent statistic (e.g., the entropy of a group of cells) for controlling the Cassiopeia-Hybrid transition that will make Cassiopeia more intuitive and effective with handling real data.</p>
    <p>Though we illustrate that Cassiopeia provides the computational foundation necessary for future large-scale lineage tracing experiments, there are several opportunities for future improvement. First, the inclusion of prior probabilities increases Cassiopeia’s performance only when parallel evolution is likely (e.g., with a high per-character mutation rate or in low character state regimes). While maximum parsimony methods are attractive due to their non-parametric nature, future studies may build on our work here by developing more powerful approaches for integrating prior mutation rates into maximum likelihood [<xref ref-type="bibr" rid="CR20">20</xref>, <xref ref-type="bibr" rid="CR21">21</xref>] or Bayesian inference [<xref ref-type="bibr" rid="CR51">51</xref>] frameworks, perhaps relying on recent literature that seeks to predict indel formation probabilities [<xref ref-type="bibr" rid="CR40">40</xref>–<xref ref-type="bibr" rid="CR42">42</xref>]. Future work in this space may also focus on using maximum parsimony solutions to further refine solutions in an effort to resolve branch length as with GAPML [<xref ref-type="bibr" rid="CR52">52</xref>] or with paired transcriptomic observations [<xref ref-type="bibr" rid="CR53">53</xref>]. Second, there exists a promising opportunity in developing new approaches for better handling of missing data. Determining a model which explicitly distinguishes between stochastic and heritable missing data may increase tree accuracy. Alternatively, adapting supertree methods (such as the Triple MaxCut algorithm [<xref ref-type="bibr" rid="CR54">54</xref>]) for lineage tracing data may be an interesting direction as they have been effective for dealing with missing data (but only when this missing data is randomly distributed [<xref ref-type="bibr" rid="CR55">55</xref>]). Aside from computational approaches for dealing with missing data, it is still unclear how much missing data is due to silencing, Cas9-resections, or stochastic dropout and experiments to elucidate the contributions of each will be helpful to the future design of lineage tracers. Third, while we provide theoretical and empirical evidence for our greedy heuristic, we note that there are opportunities for developing other heuristics—for example, by considering mutations in many characters rather than a single mutation as we do or using a distance-based heuristic.</p>
    <p>The ultimate goal of using single-cell lineage tracers to create precise and quantitative cell fate maps will require sampling tens of thousands of cells (or more), possibly tracing over several months, and effectively inferring the resulting phylogenies. While recent studies [<xref ref-type="bibr" rid="CR56">56</xref>] have highlighted the challenges in creating accurate CRISPR-recorders, our results suggest that with adequate technological components and computational approaches complex biological phenomena can be dissected with single-cell lineage tracing methods. Specifically, we show that Cassiopeia and the benchmarking resources presented here meet many of these challenges. Not only does Cassiopeia provide a scalable and accurate inference approach, but also our benchmarking resources enable the systematic exploration of more accurate algorithms as well as more robust single-cell lineage tracing technologies. Taken together, this work forms the foundation for future efforts in building detailed cell fate maps in a variety of biological applications.</p>
  </sec>
  <sec id="Sec8">
    <title>Methods</title>
    <sec id="Sec9">
      <title>In vitro lineage tracing experiment</title>
      <sec id="Sec10">
        <title>Plasmid design and cloning</title>
        <p>The Cas9-mCherry lentivector, pHR-UCOE-SFFV-Cas9-mCherry (to be added to Addgene), was designed for stable, constitutive expression of enzymatically active Cas9, driven by the viral SFFV promoter, insulated with a minimal universal chromatin opening element (minUCOE), and tagged with C-terminal, self-cleaving P2A-mCherry. pHR-UCOE-SFFV-Cas9-mCherry is derived from pMH0001 (Addgene Cat#85969, active Cas9) with the BFP tag exchanged with mCherry. The P2A-mCherry tag was PCR amplified from pHR-SFFV-KRAB-dCas9-P2A-mCherry (Addgene Cat #60954; forward: GAGCAACGGCAGCAGCGGATCCGGAG-CTACTAACTTCAG; reverse: ATATCAAGCTTGCATGCCTGCAGGTCGACTTACTACTTGTACAGCTCGTC-CATGC) and inserted using Gibson Assembly (NEB) into SbfI/BamHI-digested pMH0001 (active Cas9). Resulting plasmid was used for lentiviral production as described below.</p>
        <p>The Target Site lentivector, PCT48 (to be added to Addgene), was derived from the reverse lentivector PCT5 (to be added to Addgene) containing GFP driven by the EF1a promoter. The sequence of the 10X amplicon with most common polyA location is the following: AATCCAGCTAGCTGTGCAGCNNNNNNNNNNNNNNATTCAACTGCAGTAATGCTACCTCGTACTCACGCTTTCCAAGTGCTTGGCGTCGCATCTCGGTCCTTTGTACGCCGAAAAATGGCCTGACAACTAAGCTACGGCACGCTGCCATGTTGGGTCATAACGATATCTCTGGTTCATCCGTGACCGAACATGTCATGGAGTAGCAGGAGCTATTAATTCGCGGAGGACAATGCGGTTCGTAGTCACTGTCTTCCGCAATCGTCCATCGCTCCTGCAGGTGGCCTAGAGGGCCCGTTTAAACCCGCTGATCAGCCTCGACTGTGCCTTCTAGTTGCCAGCCATCTGTTGTTTGCCCCTCCCCCGTGCCTTCCTTGACCCTGGAAGGTGCCACTCCCACTGTCCTTTCCTAATAAAAAAAAAAAAAAAAAAAAAAA</p>
        <p>where <italic>N</italic> denotes our 14-bp random integration barcode. PCT5 was digested with SfiI and EcoRI within the 3 <sup>′</sup>UTR of GFP. The Target Site sequence was ordered as a DNA fragment (gBlock, IDT DNA) containing three Cas9 cut sites and a high diversity, 14-bp randomer (integration barcode, or intBC). The fragment was PCR amplified with primers containing Gibson assembly arms compatible with SfiI/EcoRI-digested PCT5 (forward: GATGAGCTCTACAAATAATTAATTAAGAATTCGTCACGAATCCAGCTAGCTGT;reverse:GGTTTAAACGGGCCCTCTAGGC CACCTGCAGGAGCGATGG). The amplified Target Site fragment was inserted into the digested PCT5 backbone using Gibson Assembly. The assembled lentivector library was transformed into MegaX competent bacterial cells (Thermo Fisher) and grown in 1L of LB with carbenicillin at 100 <italic>μ</italic>g/mL. Lentivector plasmid was recovered and purified by GigaPrep (Qiagen) and used for high-diversity lentiviral production as described below.</p>
        <p>The triple-sgRNA-BFP-PuroR lentivector, PCT61 (to be added to Addgene), is derived from pBA392 (to be added to Addgene) as previously described [<xref ref-type="bibr" rid="CR57">57</xref>, <xref ref-type="bibr" rid="CR58">58</xref>] containing three sgRNA cassettes driven by distinct U6 promoters and constitutive BFP and puromycin-resistance markers for selection. Importantly, the three PCT61 sgRNAs are complementary to the three cut sites in the PCT48 Target Site. To slow the cutting kinetics of the sgRNAs to best match the timescale involved in the in vitro lineage tracing experiments [<xref ref-type="bibr" rid="CR10">10</xref>], the sgRNAs contain precise single-basepair mismatches that decrease their avidity for the cognate cut sites [<xref ref-type="bibr" rid="CR59">59</xref>]. The triple-sgRNA lentivector was cloned using four-way Gibson assembly as described in [<xref ref-type="bibr" rid="CR58">58</xref>]. Resulting plasmid was used for lentiviral production as described below.</p>
      </sec>
      <sec id="Sec11">
        <title>Cell culture, DNA transfections, viral preparation, and cell line engineering</title>
        <p>A549 cells (human lung adenocarcinoma line, ATCC CCL-185) and HEK293T were maintained in Dulbecco’s modified Eagle medium (DMEM, Gibco) supplemented with 10% FBS (VWR Life Science Seradigm), 2 mM glutamine, 100 units/mL penicillin, and 100 <italic>μ</italic>g/mL streptomycin. Lentivirus was produced by transfecting HEK293T cells with standard packaging vectors and TransIT-LTI transfection reagent (Mirus) as described in ([<xref ref-type="bibr" rid="CR57">57</xref>]). Target Site (PCT48) lentiviral preparations were concentrated tenfold using Lenti-X Concentrator (Takara Bio). Viral preparations were frozen prior to infection. Triple-sgRNA lentiviral preparations were titered and diluted to a concentration to yield approximately 50% infection rate. To construct the lineage tracing-competent cell line, A549 cells were transduced by serial lentiviral infection with the three lineage tracing components: (1) Cas9, (2) Target Site, and (3) triple-sgRNAs. First, A549 cells were transduced by Cas9 (mCherry) lentivirus and mCherry+ cells were selected to purity by fluorescence-activated cell sorting on the BD FACS Aria II. Second, A549-Cas9 cells were transduced by concentrated Target Site (GFP) lentivirus and GFP+ cells were selected by FACS; after sorting, Target Site infection and sorting were repeated two more times for a total of three serial lentiviral transfections, sorting for cells with progressively higher GFP signal after each infection. This strategy of serial transfection with concentrated lentivirus yielded cells with high copy numbers of the Target Site, which were confirmed by quantitative PCR. Third, A549 cells with Cas9 and Target Site were transduced by titered triple-sgRNA (BFP-PuroR) lentivirus and selected as described below.</p>
      </sec>
      <sec id="Sec12">
        <title>In vitro lineage tracing experiment, single-cell RNA-seq library preparation, and sequencing</title>
        <p>One day following triple-sgRNA infection, cells were trypsinized to a single-cell suspension and counted using an Accuri cytometer (BD Biosciences). Approximately 25 cells were plated in a single well of a 96-well plate. Seven days post-infection, cells were trypsinized and split evenly into two wells of a 96-well plate. Cells stably transduced by triple-sgRNA lentivirus were selected by adding puromycin at 1.5 <italic>μ</italic>g/mL on days 9 and 11 post-infection; puromycin-killed cells were removed by washing the plate with a fresh medium. After 14 days, cells were trypsinized and split evenly for a second time into four wells of a 6-well plate. Finally, after 21 days in total, cells from the four wells were trypsinized to a single-cell suspension and collected.</p>
        <p>Cells were washed with PBS with 0.04% w/v bovine serum albumin (BSA, New England Biolabs), filtered through 40 <italic>μ</italic>m FlowMi filter tips filter tips (Bel-Art), and counted according to the 10x Genomics protocol. Approximately 14,000 cells per sample were loaded (expected yield: approximately 10,000 cells per sample) into the 10x Genomics Chromium Single Cell 3 <sup>′</sup> Library and Gel Bead Kit v2, and cDNA was reverse-transcribed, amplified, and purified according to the manufacturer’s protocol. Resulting cDNA libraries were quantified by BioAnalyzer, yielding the expected size distribution described in the manufacturer’s protocol.</p>
        <p>To prepare the Target Site amplicon sequencing library, resulting amplified cDNA libraries were further amplified with custom, Target Site-specific primers containing P5/P7 Illumina adapters and sample indices (forward:CAAGCAGAAGACGGCATACGAGATXXXXXXXXGTCTCGTGGGCTCGGAGATGTGTATAAGAGACAGAATCCAGCTAGCTGTGCAGC;reverse:CAAGCAGAAGACGGCATACGAGATXXXXXXXXGTCTCGTGGGCTCGGAGATGTGTATAAGAGACAGGCATGGACGAGCTGTACAAGT; “X” denotes sample indices). PCR amplification was performed using Kapa HiFi HotStart ReadyMix, as in [<xref ref-type="bibr" rid="CR57">57</xref>], according to the following program: melting at 95<sup>∘</sup>C for 3 min, then 14 cycles at 98 <sup>∘</sup>C for 15 s and 70 <sup>∘</sup>C for 20 s. Approximately 12 fmol of template cDNA were used per reaction; amplification was performed in quadruplicate to avoid PCR-induced library biases, such as jack-potting. PCR products were re-pooled and purified by SPRI bead selection at 0.9x ratio and quantified by BioAnalyzer.</p>
        <p>Target Site amplicon libraries were sequenced on the Illumina NovaSeq S2 platform. Due to the low sequence complexity for the Target Site library, a phiX genomic DNA library was spiked in at approximately 50% for increased sequence diversity. The 10x cell barcode and unique molecular identifier (UMI) sequences were read first (R1: 26 cycles) and the Target Site sequence was read second (R2: 300 cycles); sample identities were read as indices (I1 and I2: 8 cycles, each). Over 550M sequencing clusters passed filter and were processed as described below. All raw and processed data are available through GEO Series accession GSE146712 [<xref ref-type="bibr" rid="CR60">60</xref>].</p>
      </sec>
    </sec>
    <sec id="Sec13">
      <title>Processing pipeline</title>
      <sec id="Sec14">
        <title>Read processing</title>
        <p>Each target site was sequenced using the Illumina Nova-seq platform, producing 300-bp long-read sequences. The Fastq’s obtained were quantitated using 10x’s cellranger suite, which simultaneously corrects cell barcodes by comparing against a whitelist of 10x’s approved cell barcodes. For each cell, a consensus sequence for each unique molecule identifier (UMI) was produced by collapsing similar sequences, defined by those sequences differing by at most 1 Levenshtein distance. A directed graph is constructed, where sequences with identical UMIs are connected to one another if the sequences themselves differ by at most one Levenshtein distance. Then, UMIs in this network are collapsed onto UMIs that have greater than or equal number of reads. This produces a collection of sequences indexed by the cell barcode and UMI information (i.e., there is a unique sequence associated with each UMI).</p>
        <p>Before aligning all sequences to the reference, preliminary quality control is performed. Specifically, in cases where UMIs in a given cell still have not been assigned a consensus sequence, the sequence with the greatest number of reads is chosen. UMIs with fewer than 2 reads are filtered out, and cells with fewer than 10 UMIs are filtered out as well. Finally, a filtered file in Fastq format is returned.</p>
      </sec>
      <sec id="Sec15">
        <title>Allele calling</title>
        <p>Alignment is performed with Emboss’s Water local alignment algorithm. Optimal parameters were found by performing a grid search of gap open and gap extend parameters on a set of 1000 simulated sequences, comparing a global and local alignment strategy. We found a gap open penalty of 20.0 and a gap extension penalty of 1.0 produced optimal alignments. The “indels” (insertions and deletions resulting from the Cas9-induced double-strand break) at each cut site in the sequences are obtained by parsing the cigar string from the alignments. To resolve possible redundancies in indels resulting from Cas9 cutting, the 5 <sup>′</sup> and 3 <sup>′</sup> flanking 5-nucleotide context is reported for each indel.</p>
      </sec>
      <sec id="Sec16">
        <title>UMI error correction</title>
        <p>To correct errors in the UMI sequence either introduced during sequencing, PCR preparation, or data processing, we leverage the allele information. UMIs are corrected within groups of identical cell barcode-integration barcode pairs (i.e., we assume that only UMIs encoding for the same intBC in a given cell can be corrected). We reason that ideally, for a given integration barcodes, a cell will only report one sequence, or allele. Within these “equivalence classes,” UMIs that differ by at most 1 Levenshtein distance (although this number can be user-defined) are corrected towards the UMI with a greater number of reads.</p>
      </sec>
      <sec id="Sec17">
        <title>Cell-based filtering</title>
        <p>With the UMI corrected and indels calculated, the new “molecule table” is subjected to further quality control. Specifically, UMIs are filtered based on the number of reads (dynamically set to be the 99th percentile of the reads divided by 10), integration barcodes (denoting a particular integration site) can be error corrected based on a minimum hamming distance and identical indels (referred to as alleles), and in the case where multiple alleles are associated with a given integration barcode a single allele is chosen based on the number of UMIs associated with it.</p>
      </sec>
      <sec id="Sec18">
        <title>Calling independent clones</title>
        <p>Collections of cells that are part of the same clonal population are identified by the set of integration barcodes each cell contains. Because all cells in the same clone are clonal, we reasoned that cells in the same clone should all share the same set of integration barcodes that the progenitor cell contained. Because of both technical artifacts (e.g., sequencing errors, PCR amplification errors) and biological artifacts (e.g., bursty expression, silenced regions) however, rather than looking for sets of non-overlapping sets, we perform an iterative clustering procedure. We begin by selecting the intBC that is shared amongst the most cells and assign any cell that contains this barcode to a cluster and remove these cells from the pool of unassigned cells. We perform this iteratively until at most <italic>k</italic> percent (in our case defined as.5<italic>%</italic> of cells are unassigned, which we assign to a “junk” clone.</p>
        <p>Using the set of integration barcodes for each clone, we are able to identify doublets that consist of cells from different clones. Finally, after identifying doublets, to further filter out low-quality integration barcodes, for each clone integration barcodes that are not shared by at least 10% of cells in a given clone are filtered out, producing the final allele table.</p>
      </sec>
      <sec id="Sec19">
        <title>Guidelines for final quality control</title>
        <p>The thresholds discussed above are heuristic choices determined based on our hands-on experience with this type of target-site library processing. However, these thresholds will undoubtedly change depending on the sequencer used, the sequencing depth of the library, and the biological use case. For these reasons, we suggest that it is more effective to ensure that the final quality control numbers indicate that the library was processed sufficiently.</p>
        <p>We present distributions for the metrics we find to be the most useful in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S17: the UMIs per cellBC as a measure for how well sampled a cell is in (a), the reads per UMI as a measure for how confident one is of the UMI sequence in (b), UMIs per intBC as a measure for how confident one is of the called allele and intBC in (c), and a comparison of the number of UMIs versus the number of reads in (d), as a way of quickly assessing if there are any outlier UMIs.</p>
        <p>Because this library was sequenced quite deeply, we do not expect typical applications to afford this degree of certainty. Instead, we suggest that cells should have at least 10 target-site UMIs, the reads/UMI distribution should have a mean at around 100–200 reads, and each intBC should have at least 5–10 UMIs associated with it. Cassiopeia’s processing pipeline creates figures for each of these statistics after filtering and close attention should be paid to these figures during the processing of the target-site sequencing data.</p>
      </sec>
      <sec id="Sec20">
        <title>Filtering of clones for reconstruction</title>
        <p>We filtered out clones upon two criteria: firstly, we removed clone 1 as we deduced that it had two defective guides; secondly, we removed lineages that reported fewer than 10% unique cells (thus removing clone 7). The remainder of clones were reconstructed.</p>
      </sec>
      <sec id="Sec21">
        <title>Estimation of per-character mutation rates</title>
        <p>To estimate mutation rates per clone, we assume that every target site was mutated at the same rate and independently of one another across 15 generations. Assuming some mutation rate, <italic>p</italic>, per character, we know that the probability of not observing a mutation in <italic>d</italic> generations is (1−<italic>p</italic>)<sup><italic>d</italic></sup> in a given character and that the probability of observing at least 1 mutation in that character is 1−(1−<italic>p</italic>)<sup><italic>d</italic></sup>. Then, giving this probability 1−(1−<italic>p</italic>)<sup><italic>d</italic></sup>=<italic>m</italic> can be used as a probability of observing a mutated character in a cell and model the number of times a character appears mutated in a cell as a binomial distribution where the expectation is simply <italic>nm</italic> where <italic>n</italic> is the number of characters. Said simply, given this model, one would expect to see <italic>nm</italic> characters mutated in a cell. In this case, the empirical expectation is the mean number of times a given character appeared mutated in a cell (averaged across all cells), which we denote as <italic>K</italic> and propose that
<disp-formula id="Equa"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$K = nm = n * (1 - (1 - p)^{d}) $$ \end{document}</tex-math><mml:math id="M2"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">nm</mml:mtext><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>∗</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equa.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>and thus <italic>p</italic>, the mutation rate, is
<disp-formula id="Equb"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$p = 1 - (1 - K/n)^{d} $$ \end{document}</tex-math><mml:math id="M4"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:mo>/</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equb.gif" position="anchor"/></alternatives></disp-formula></p>
      </sec>
    </sec>
    <sec id="Sec22">
      <title>Bulk cutting experiment to determine prior probabilities of indel formation</title>
      <p>Two and 4 days following triple-sgRNA (PCT61) infection, infected cells were selected by adding puromycin at 1.5 <italic>μ</italic>g/mL; puromycin-killed cells were removed by washing the plate with fresh medium. Cells were split every other day, and 500k cells were collected on days 7, 14, and 28. Frozen cell pellets were lysed, and the genomic DNA was extracted and purified by ethanol precipitation. The PCT48 Target Site locus was PCR amplified from genomic DNA samples (forward: TCGTCGGCAGCGTCAGATGTGTATAAGAGACAGAATCCAGCTAGCTGTGCAGC; reverse:GTCTCGTGGGCTCGGAGATGTGTATAAGAGACAGTCGAGGCTGATCAGCG) and further amplified to incorporate Illumina adapters and sample indices(forward:AATGATACGGCGACCACCGAGATCTACACXXXXXXXXTCGTCGGCAGCGTCAG;reverse:CAAGCAGAAGACGGCATACGAGATXXXXXXXXGTCTCGTGGGCTCGGAG; “X” denotes sample indices). The subsequent amplicon libraries were sequenced on an Illumina MiSeq (paired end, 300 cycles each). Sequencing data was analyzed as described below.</p>
    </sec>
    <sec id="Sec23">
      <title>Determining prior probabilities of indel formation</title>
      <p>To determine the prior probabilities of edits, we leverage the fact that we have access to a large set of target sites (or intBCs) with a similar sequence (apart from the random barcode at the 5 <sup>′</sup> end); namely, a total of 117 intBC across the 11 clones. To compute the prior probability for a given indel, we compute the empirical frequency of observing this mutation out of all unique edits observed. Specifically, we compute the prior probability of a given indel <italic>s</italic>, <italic>q</italic><sub><italic>s</italic></sub> as the following:
<disp-formula id="Equc"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$q_{s} = \frac{f(s)}{|I|} $$ \end{document}</tex-math><mml:math id="M6"><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>s</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>I</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equc.gif" position="anchor"/></alternatives></disp-formula> where <italic>f</italic>(<italic>s</italic>) is the number of intBCs that had <italic>s</italic> in at least one cell and |<italic>I</italic>| is the number of intBCs that are present in the dataset.</p>
      <p>As further support for this method, we used the bulk experiment consisting of many separately engineered A549 cells, as described in the previous section. The advantage of the bulk experiment is that we have access to substantially more intBCs (&gt; 10k), thus providing a more robust estimation of <italic>q</italic><sub><italic>s</italic></sub>. We therefore employed the same approach to estimate indel formation rates from the bulk data and find that the resulting rates correlate well with the indel rates estimated from the single-cell lineage tracing experiment (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S20).</p>
    </sec>
    <sec id="Sec24">
      <title>Doublet detection</title>
      <sec id="Sec25">
        <title>Methods to detect doublets</title>
        <p>We hypothesized that doublets could come in two forms and that we could use various components of the intBC data structure to identify them. Namely, doublets could be of cells from the identical clone, here dubbed “intra-doublets,” or doublets could be of cells from separate clones, here dubbed “inter-doublets.” In the case of “intra-doublets,” we can utilize the fact that these cells will have a large overlap in their set of intBCs but will report “conflicting” alleles for each of these intBCs. Thus, to identify these doublets, we calculate the percentage of UMIs that are conflicting in each cell. Explicitly, for each cell, we iterate over all intBCs and sum up the number of UMIs that correspond to an allele that conflicts with the more abundant allele for a given intBC; we then use the percentage of these UMIs to identify doublets. We perform this after all UMI and intBC correction in hopes of calling legitimate conflicts.</p>
        <p>To deal with “inter-doublets,” we developed a classifier that leverages the fact that cells from different clones should have non-overlapping intBC sets. While this is the ideal scenario, often times intBCs are shared between clones for one of two reasons: (1) the clustering assignments are noisy or (2) the transfections of intBCs resulted in two cells receiving the same intBC, even though cells are supposed to be progenitors of separate clones. Our strategy is thus as follows: for each cell <italic>c</italic><sub><italic>i</italic></sub>∈<italic>C</italic> calculate a “membership statistic,” <italic>m</italic><sub><italic>i</italic>,<italic>k</italic></sub> for each clone <italic>l</italic><sub><italic>k</italic></sub>∈<italic>L</italic>. The membership statistic is defined as so:
<disp-formula id="Equd"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$m_{i,k} = \frac{\sum_{j \in I_{k}}\delta(i, j)p(j, k)}{\sum_{j \in I_{k}} (p(j, k))} $$ \end{document}</tex-math><mml:math id="M8"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mi>δ</mml:mi><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>)</mml:mo><mml:mi>p</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:munder><mml:mo>(</mml:mo><mml:mi>p</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equd.gif" position="anchor"/></alternatives></disp-formula> where <italic>I</italic><sub><italic>k</italic></sub> is the set of intBCs for the clone <italic>l</italic><sub><italic>k</italic></sub> and <italic>p</italic>(<italic>j</italic>,<italic>k</italic>) is the prevalence rate of the intBC <italic>j</italic> in <italic>l</italic><sub><italic>k</italic></sub>. We use <italic>δ</italic>(<italic>i</italic>,<italic>j</italic>) as an indicator function for whether or not we observed the intBC <italic>j</italic> in the cell <italic>c</italic><sub><italic>i</italic></sub>. Intuitively, this membership statistic is a weighted similarity for how well the cell fits into each clone, where we are weighting by how much we are able to trust the intBC that is observed in the cell. To put all on the same scale, we normalize by total membership per cell, resulting in our final statistic, <inline-formula id="IEq1"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$m^{\prime }_{i,k} = \frac {m_{i, k}}{\sum _{k'=0}^{k} m_{i, k'}}$\end{document}</tex-math><mml:math id="M10"><mml:msubsup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq1.gif"/></alternatives></inline-formula>. We then filter out doublets whose <italic>m</italic><sup>′</sup> for their classified clone falls below a certain threshold.</p>
      </sec>
      <sec id="Sec26">
        <title>Simulation of doublets</title>
        <p>We simulated two datasets to test our methods for identifying doublets and to find the optimal criterion on which to filter out doublets. To test this strategy, we took a single clone from our final Allele Table (the table relating all cells and their UMIs to clones) and formed 200 doublets by combining the UMIs from two cells. We generated 20 of these datasets and noted which cells were artificially introduced doublets.</p>
        <p>Contrary to the strategy for simulating doublets from the same clone, we created artificial “inter” doublets from the final Allele Table by combining doublets from two different clones. Similarly, we generated 20 synthetic datasets each with 200 of these artificial doublets.</p>
      </sec>
      <sec id="Sec27">
        <title>Identification of decision rule</title>
        <p>To identify the optimal decision rule for calling both types of doublets, we tested decision rules ranging from 0 to 1.0 at 0.05 intervals and calculated the precision and recall at each of these rules. Taking these results altogether, we provide an optimal decision rule where the F-measure (or the weighted harmonic mean of the precision and recall) of these tests is maximal.</p>
      </sec>
    </sec>
    <sec id="Sec28">
      <title>Algorithmic approaches for phylogenetic reconstruction</title>
      <p>One way to approach the phylogenetic inference problem is to view each target site as a “character” that can take on many different possible “states” (each state corresponding to an indel pattern induced by a CRISPR/Cas9 edit at the target site). Formally, these observations can be summarized in a “character matrix,” <italic>M</italic>∈<italic>R</italic><sup><italic>n</italic>,<italic>m</italic></sup>, which relates the <italic>n</italic> cells by a set of characters <italic>χ</italic>={ <italic>χ</italic><sub>1</sub>,..., <italic>χ</italic><sub><italic>m</italic></sub>} where each character <italic>χ</italic><sub><italic>i</italic></sub> can take on some <italic>k</italic><sub><italic>i</italic></sub> possible states. Here, each sample, or cell, can be described as a concatenation of all of their states over characters in a “character string.” From this character matrix, the goal is to infer a tree (or phylogeny), where leaf nodes represent the observed cells, internal nodes represent ancestral cells, and edges represent a mutation event.</p>
      <p>We first propose an adaption of a slow, but accurate, Steiner tree algorithm via integer lineage programming (ILP) to the lineage tracing phylogeny problem. Then, we propose a fast, heuristic-based greedy algorithm which simultaneously draws motivation from classical perfect phylogeny algorithms, and the fact that mutations can only occur unidirectionaly from the unmutated, or <italic>s</italic><sub>0</sub> state. Lastly, we combine these two methods and present a hybrid method, which presents better results than our greedy approach, yet remains feasible to run over tens of thousands of cells.</p>
      <sec id="Sec29">
        <title>Adaptation to Steiner tree problem</title>
        <p>Steiner trees are a general problem for solving for the minimum weight tree connecting a set of target nodes. For example, if given a graph <italic>G</italic>=(<italic>V</italic>,<italic>E</italic>) over some <italic>V</italic> vertices and <italic>E</italic> edges, finding the Steiner tree over all <italic>v</italic>∈<italic>V</italic> would amount to solving for the minimum spanning tree (MST) of <italic>G</italic>. While there exist polynomial time algorithms for the minimum spanning tree, the general Steiner tree problem, where the set of targets <italic>T</italic>⊆<italic>V</italic> is designated, is NP-hard.</p>
        <p>Previously, Steiner trees have been suggested to solve for the maximum parsimony solution to the phylogeny problem. Here, the graph would consist of all possible cells (both observed and unobserved) and each edge would consist of a possible evolutionary event connecting two states (e.g., a mutation). Generally, given a set of length-<italic>l</italic> binary “character-strings” (recall that these are the concatenation of all character states for a given sample), we can solve for the maximum parsimony solution by finding the optimal Steiner tree over the 2<sup><italic>l</italic></sup> hypercube (i.e., graph). As a result, by converting our multi-state characters to binary characters via one hot encoding, theoretically, we should be able to compute the most parsimonious tree which best explains the observed data. However, in practice, this method turns out to be infeasible, as we deal with hypercubes of size <italic>O</italic>(2<sup><italic>m</italic><italic>n</italic></sup>), where <italic>m</italic> is the number of characters and <italic>n</italic> is the number of states. In the following, we will propose a method for estimating the underlying search space, providing us with a feasible solvable instance and a formulation of an integer linear programming (ILP) problem to solve for the optimal Steiner tree.</p>
        <p><bold>Approximation of potential graph</bold> We first begin by constructing a directed acyclic graph (DAG) <italic>G</italic>, where nodes represent cells. We then take the source nodes, or nodes with in-degree 0, of <italic>G</italic>, and for each pair of source nodes, consider the latest common ancestor (LCA) they could have had. This LCA has an unmutated state for character <italic>χ</italic><sub><italic>i</italic></sub> if they disagree across two source nodes, and the same state as the two source nodes if they agree in value. If the edit distance between these two cells is below a certain threshold <italic>d</italic>, we add the LCA to <italic>G</italic>, along with directed edges to the two source nodes, weighted by the edit distance between the parent and the source. We repeat this process until only one node remains as a source: the root.</p>
        <p>One may think that this step explodes with <italic>O</italic>(<italic>n</italic><sup>2</sup>) complexity at each stage, where <italic>n</italic> is the number of source nodes in each prior stage, as we consider all pairs of source nodes. However, we note that the number of mutations per latest common ancestor is always less than both children, and therefore, we eventually converge to the root. Therefore, when dealing with several hundred cells, the potential graph is feasible to calculate.</p>
        <p>Furthermore, to add scalability to the approximation of the Potential Graph, we allow the user to provide a “maximum neighborhood size” which will be used to dynamically solve for the optimal LCA distance threshold <italic>d</italic> to use. One may think of this as the maximum memory or time allowed for optimizing a particular problem. Since the size of the Potential Graph can grow quite large in regard to the number of nodes, we iteratively create potential graphs for various threshold <italic>d</italic> and at each step ensure that the number of nodes in the network does not exceed the maximum neighborhood size provided. If at any point the number of nodes does exceed this maximum size, we return the potential graph inferred for an LCA threshold of <italic>d</italic>−1.</p>
        <p><bold>Formulation of integer linear programming problem</bold> Given our initial cells, <italic>S</italic>, the underlying potential graph drawn from such cells, <italic>G</italic>, and the final source node, or root, <italic>r</italic> from <italic>G</italic>, we are interested in solving for <inline-formula id="IEq2"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {T} = SteinerTree(r, S, G)$\end{document}</tex-math><mml:math id="M12"><mml:mi mathvariant="script">T</mml:mi><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">SteinerTree</mml:mtext><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>G</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq2.gif"/></alternatives></inline-formula>. We apply an integer linear programming (ILP) formulation of Steiner tree, formulated in terms of network flows, with each demand being met by a flow from source to target. Below, we present the integer linear programming formulation for Steiner tree. We use Gurobi [<xref ref-type="bibr" rid="CR61">61</xref>], a standard ILP solver package
<disp-formula id="Eque"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $${\begin{aligned} &amp; \text{minimize} &amp; \sum_{(u,v) \in E} d_{uv}^{b} \cdot w(u,v) \\ &amp; \text{subject to} &amp; \sum_{(u,v) \in E} d_{uv} - \sum_{(v,w) \in E} d_{vw} &amp;= 0 &amp;&amp; \forall v \!\notin\! S \cup \{r\} \\ &amp; &amp; \sum_{(r, w) \in E} d_{rw} &amp;= -|S| &amp;&amp; \\ \end{aligned}} $$ \end{document}</tex-math><mml:math id="M14"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mtext>minimize</mml:mtext></mml:mtd><mml:mtd><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msubsup><mml:mo>·</mml:mo><mml:mi>w</mml:mi><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>subject to</mml:mtext></mml:mtd><mml:mtd><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">vw</mml:mtext></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mo>∀</mml:mo><mml:mi>v</mml:mi><mml:mspace width="0.3em"/><mml:mo>∉</mml:mo><mml:mspace width="0.3em"/><mml:mi>S</mml:mi><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mi>r</mml:mi><mml:mo>}</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>r</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">rw</mml:mtext></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr/></mml:mtable></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Eque.gif" position="anchor"/></alternatives></disp-formula></p>
        <p><disp-formula id="Equf"><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $${\begin{aligned} &amp; &amp; \sum_{(u,s) \in E} d_{us} &amp;= 1 &amp;&amp; \forall s \in S \\ &amp; &amp; d_{uv}^{b} &amp;\geq \frac{d_{uv}}{|S|} &amp;&amp; \forall (u,v) \in E\\ &amp; &amp; d_{uv} &amp;\in \{0,..,|S|\} &amp;&amp; \forall (u,v) \in E\\ &amp; &amp; d_{uv}^{b} &amp;\in \{0,..,1\} &amp;&amp; \forall (u,v) \in E \end{aligned}} $$ \end{document}</tex-math><mml:math id="M16"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">us</mml:mtext></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mo>∀</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msubsup></mml:mtd><mml:mtd><mml:mo>≥</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mtd><mml:mtd><mml:mo>∀</mml:mo><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>..</mml:mi><mml:mo>,</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>}</mml:mo></mml:mtd><mml:mtd><mml:mo>∀</mml:mo><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msubsup></mml:mtd><mml:mtd><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>..</mml:mi><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mtd><mml:mtd><mml:mo>∀</mml:mo><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>E</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equf.gif" position="anchor"/></alternatives></disp-formula> Each variable <italic>d</italic><sub><italic>uv</italic></sub> denotes the flow through edge (<italic>u</italic>,<italic>v</italic>), if it exists; each variable <inline-formula id="IEq3"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$d_{uv}^{b}$\end{document}</tex-math><mml:math id="M18"><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">uv</mml:mtext></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq3.gif"/></alternatives></inline-formula> denotes whether (<italic>u</italic>,<italic>v</italic>) is ultimately in the chosen solution sub-graph. The first constraint enforces flow conservation, and hence that the demands are satisfied, at all nodes and all conditions. The second constraint requires |<italic>S</italic>| units of flow come out from the <italic>root</italic>. The third constraint requires that each target absorb exactly one unit of flow. The fourth constraint ensures that if an edge is used at any condition, it is chosen as part of the solution.</p>
        <p>Below, we explicitly define the algorithm in pseudocode.</p>
        <p>
          <graphic position="anchor" xlink:href="13059_2020_2000_Figa_HTML" id="MO7"/>
        </p>
      </sec>
      <sec id="Sec30">
        <title>Stability analysis of the maximum neighborhood size parameter</title>
        <p>To evaluate the stability of the user-defined maximum neighborhood size parameter, we assessed the accuracy of the reconstructions for parameters varying from 800 to 14,000. We used trees simulated under default conditions (400 samples, 40 characters, 40 states per character, 11 generations, 2.5<italic>%</italic> mutation rate per character, and a mean dropout rate of 17%). The accuracy of trees were compared to the tree generated with a parameter of 14,000 using the triplets correct statistic. We used 10 replicates to provide a sense for how stable a given accuracy is.</p>
        <p>In addition to providing measures of accuracy, we also provide the optimal LCA threshold <italic>d</italic> found for a given maximum neighborhood size during the inference of these potential graphs. Using these analysis, we found that a maximum neighborhood size of 10,000 nodes seemed to be an ideal tradeoff between scalability and accuracy (as it is in the regime where accuracy saturates) for our default simulations. This corresponded to a mean LCA threshold, <italic>d</italic>, of approximately 5.</p>
      </sec>
      <sec id="Sec31">
        <title>Heuristic-based greedy method</title>
        <p><bold>On perfect phylogeny and single-cell lineage tracing</bold> In the simplest case of phylogenetics, each character is binary (i.e., <italic>k</italic><sub><italic>i</italic></sub>=2,∀<italic>i</italic>∈<italic>m</italic>) and can mutate at most once. This case is known as “perfect phylogeny” and there exist algorithms (e.g., a greedy algorithm by Dan Gusfield [<xref ref-type="bibr" rid="CR30">30</xref>]) for identifying if a perfect phylogeny exists over such cells, and if so find one efficiently in time <italic>O</italic>(<italic>m</italic><italic>n</italic>), where <italic>m</italic> is the number of characters and <italic>n</italic> are the number of cells. However, several limitations exist with methods such as Gusfield’s algorithm. One potential problem in using existing greedy perfect phylogeny algorithms for lineage tracing is that they require the characters to be binary. Indeed, if the characters are allowed to take any arbitrary number of states, the perfect phylogeny problem becomes NP-hard. However, while the number of states (CRISPR/Cas9-induced indels at a certain target site) in lineage tracing data can be large, these data benefit from an additional restriction that makes it more amenable for analysis with a greedy algorithm. Below, we show that because the founder cell (root of the phylogeny) is unedited (i.e., includes only uncut target sites) and that the mutational process is irreversible, we are able to theoretically reduce the multi-state instance (as observed in lineage tracing) to a binary one so that it can be resolved using a greedy algorithm.</p>
        <p>A second remaining problem in using these perfect phylogeny approaches is that we cannot necessarily expect every mutation to occur exactly once. In theory, it may happen that the same indel pattern is induced in exactly the same target site on two separate occasions throughout a lineage tracing experiment, especially if a large number of cell cycles takes place. A final complicating factor is that these existing greedy algorithms often assume that all character states are known, whereas lineage tracing data is generated by single-cell sequencing, which often suffers from limited sensitivity and an abundance of “dropout” (stochastic missing data) events.</p>
        <p><bold>The greedy algorithm</bold> We suggest a simple heuristic for a greedy method to solve the maximum parsimony phylogeny problem, motivated by the classical solution to the perfect phylogeny problem and irreversibility of mutation. Namely, we consider the following method for building the phylogeny: Given a set of cells, build a tree top-down by splitting the cells into two subsets over the most frequent mutation. Repeat this process recursively on both subsets until only one sample remains.</p>
        <p>Formally, we choose to split the dataset into two subsets, <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> and <inline-formula id="IEq4"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M20"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq4.gif"/></alternatives></inline-formula>, such that <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> contains cells carrying mutation <italic>s</italic><sub><italic>j</italic></sub> in <italic>χ</italic><sub><italic>i</italic></sub>, and <inline-formula id="IEq5"><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M22"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq5.gif"/></alternatives></inline-formula> contains cells without <italic>s</italic><sub><italic>j</italic></sub> in <italic>χ</italic><sub><italic>i</italic></sub>. We choose <italic>i</italic>,<italic>j</italic> based on the following criteria:
<disp-formula id="Equg"><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$i,j = \underset{i,j}{\text{argmax}}\, n_{i,j} $$ \end{document}</tex-math><mml:math id="M24"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mtext>arg max</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equg.gif" position="anchor"/></alternatives></disp-formula> where <italic>n</italic><sub><italic>i</italic>,<italic>j</italic></sub> is the number of cells that carry mutation <italic>s</italic><sub><italic>j</italic></sub> in character <italic>χ</italic><sub><italic>i</italic></sub>. We continue this process recursively until only one sample exists in each subset. We note that this method operates over cells with non-binary states, solving the first of problems addressed earlier.</p>
        <p>A major caveat exists with methods such as the greedy method proposed by Gusfield, as well as the one proposed by us thus far: namely, they assume all character states are known (i.e., no dropout). However, in our practice, we often encounter dropout as a consequence of Cas9 cutting or stochastic, technical dropout due to the droplet-based scRNA-seq platform. To address this problem in our greedy approach, during the split stage, these cells are not initially assigned to either of the two subsets, <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> or <inline-formula id="IEq6"><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M26"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq6.gif"/></alternatives></inline-formula>. Instead, for each individual sample which contains a dropped out value for chosen split character <italic>χ</italic><sub><italic>i</italic></sub>, we calculate the average percentage of mutated states shared with all other cells in <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> and <inline-formula id="IEq7"><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M28"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq7.gif"/></alternatives></inline-formula> respectively, and assign the sample to the subset with greater average value.</p>
        <p>Appending the dropout resolution stage with the initial split stage, we present our greedy algorithm below in its entirety.</p>
        <p>
          <graphic position="anchor" xlink:href="13059_2020_2000_Figb_HTML" id="MO8"/>
        </p>
        <p>Overall, this method is very efficient and scales well into tens of thousands of cells. Below, we show via proof that this algorithm can find perfect phylogeny if one exists.</p>
        <p><bold>Cassiopeia-Greedy algorithm can solve multi-state perfect phylogeny</bold> Here we show that while not required, Cassiopeia can solve the multi-state perfect phylogeny problem optimally. Importantly, however, Cassiopeia’s effectiveness makes no assumption about perfect phylogeny existing in the dataset but rather leverages this concept to provide a heuristic for scaling into larger datasets.</p>
        <p>To show how Cassiopeia’s greedy method can solve perfect phylogeny optimally, we begin by introducing a few clarifying definitions prior to the main theorem. We define <italic>M</italic> as the original <italic>n</italic> cells by <italic>n</italic> character <italic>k</italic>-state matrix (i.e., entries <inline-formula id="IEq8"><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\in \{s_{0},\dots,s_{k-1}\}$\end{document}</tex-math><mml:math id="M30"><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq8.gif"/></alternatives></inline-formula>). We say <italic>M</italic> has a zero root perfect phylogeny if there exists a tree <inline-formula id="IEq9"><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {T}$\end{document}</tex-math><mml:math id="M32"><mml:mi mathvariant="script">T</mml:mi></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq9.gif"/></alternatives></inline-formula> over its elements and character extensions such that the state of the root is all zeros and every character state is mutated into at most once. In addition, we assume that all non-leaf nodes of <inline-formula id="IEq10"><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {T}$\end{document}</tex-math><mml:math id="M34"><mml:mi mathvariant="script">T</mml:mi></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq10.gif"/></alternatives></inline-formula> have at least two children (i.e., if they only have one child, collapse two nodes into one node). Finally, we offer a definition for <italic>character compatibility</italic>:</p>
        <sec id="d29e2833">
          <title>
            <bold>Definition 1</bold>
          </title>
          <p>(<italic>Character Compatibility</italic>). For a pair of binary characters, (<italic>χ</italic><sub>1</sub>, <italic>χ</italic><sub>2</sub>), where the sets (<italic>O</italic><sub>1</sub>,<italic>O</italic><sub>2</sub>) contain the sets of cells mutated for <italic>χ</italic><sub>1</sub> and <italic>χ</italic><sub>2</sub>, respectively, we say that they are compatible if one of the following is true:
<list list-type="bullet"><list-item><p><italic>O</italic><sub>1</sub>⊆<italic>O</italic><sub>2</sub></p></list-item><list-item><p><italic>O</italic><sub>2</sub>⊆<italic>O</italic><sub>1</sub></p></list-item><list-item><p><italic>O</italic><sub>1</sub>∩<italic>O</italic><sub>2</sub>=<italic>∅</italic></p></list-item></list></p>
          <p>This definition extends to multi-state characters as well, assuming they can be binarized.</p>
          <p>Before proving the main theorem, we first prove the following lemma:</p>
        </sec>
        <sec id="d29e2914">
          <title>
            <bold>Lemma 1</bold>
          </title>
          <p>If <italic>M</italic> has a perfect phylogeny, then the most frequent character, mutation pair appears on an edge from the root to a direct child node.</p>
        </sec>
        <sec id="d29e2923">
          <title>
            <italic>Proof</italic>
          </title>
          <p>WLOG let <inline-formula id="IEq11"><alternatives><tex-math id="M35">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\text {\Large \(\chi \)}_{i}: s_{0} \rightarrow s_{j}$\end{document}</tex-math><mml:math id="M36"><mml:msub><mml:mrow><mml:mtext/><mml:mspace width="1em"/><mml:mi>χ</mml:mi><mml:mtext/></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq11.gif"/></alternatives></inline-formula> denote the maximally occurring character, mutation pair within <italic>M</italic>. Suppose by contradiction that this mutation does not appear on an edge directly from root to a child, but rather on some edge (<italic>u</italic>,<italic>v</italic>) that is part of a sub-tree whose root <italic>r</italic><sup>∗</sup>, is a direct child of the root. As <italic>r</italic><sup>∗</sup> has at least two children, this implies that the mutation captured from the root to <italic>r</italic><sup>∗</sup> must be shared by strictly more cells than <inline-formula id="IEq12"><alternatives><tex-math id="M37">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\text {\Large \(\chi \)}_{i}: s_{0} \rightarrow s_{j}$\end{document}</tex-math><mml:math id="M38"><mml:msub><mml:mrow><mml:mtext/><mml:mspace width="1em"/><mml:mi>χ</mml:mi><mml:mtext/></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq12.gif"/></alternatives></inline-formula>, thereby reaching a contradiction on <inline-formula id="IEq13"><alternatives><tex-math id="M39">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\text {\Large \(\chi \)}_{i}: s_{0} \rightarrow s_{j}$\end{document}</tex-math><mml:math id="M40"><mml:msub><mml:mrow><mml:mtext/><mml:mspace width="1em"/><mml:mi>χ</mml:mi><mml:mtext/></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq13.gif"/></alternatives></inline-formula> being the maximally occurring mutation. □</p>
        </sec>
        <sec id="d29e3062">
          <title>
            <bold>Theorem 1</bold>
          </title>
          <p>The greedy algorithm accurately constructs a perfect phylogeny over <italic>M</italic> if one exists.</p>
        </sec>
        <sec id="d29e3071">
          <title>
            <italic>Proof</italic>
          </title>
          <p>We approach via proof by induction. As a base case, a single is trivially a perfect phylogeny over itself.</p>
          <p>Now suppose by induction that for up to <italic>n</italic>−1 cells, if there exists a perfect phylogeny <inline-formula id="IEq14"><alternatives><tex-math id="M41">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {T}$\end{document}</tex-math><mml:math id="M42"><mml:mi mathvariant="script">T</mml:mi></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq14.gif"/></alternatives></inline-formula> over such cells, then the greedy algorithm correctly returns the perfect phylogeny. Consider the case of <italic>n</italic> cells. By the above lemma, we know we can separate these <italic>n</italic> cells into two subsets based on the most frequent character, mutation pair <inline-formula id="IEq15"><alternatives><tex-math id="M43">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\text {\Large \(\chi \)}_{i}: s_{0} \rightarrow s_{j}$\end{document}</tex-math><mml:math id="M44"><mml:msub><mml:mrow><mml:mtext/><mml:mspace width="1em"/><mml:mi>χ</mml:mi><mml:mtext/></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>→</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq15.gif"/></alternatives></inline-formula>, <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> and <inline-formula id="IEq16"><alternatives><tex-math id="M45">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M46"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq16.gif"/></alternatives></inline-formula>, where <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> contains cells with mutation <italic>s</italic><sub><italic>j</italic></sub> over <italic>χ</italic><sub><italic>i</italic></sub>, and <inline-formula id="IEq17"><alternatives><tex-math id="M47">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M48"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq17.gif"/></alternatives></inline-formula> = <italic>M</italic>−<italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub>. By induction, the greedy algorithm correctly returns two perfect phylogenies over <italic>O</italic><sub><italic>i</italic>,<italic>j</italic></sub> and <inline-formula id="IEq18"><alternatives><tex-math id="M49">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\overline {O}_{i,j}$\end{document}</tex-math><mml:math id="M50"><mml:msub><mml:mrow><mml:mover accent="false"><mml:mrow><mml:mi>O</mml:mi></mml:mrow><mml:mo accent="true">¯</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq18.gif"/></alternatives></inline-formula>, which we can merge at the root, giving us a perfect phylogeny over <italic>n</italic> cells. □</p>
        </sec>
      </sec>
      <sec id="Sec32">
        <title>Accounting for prior probability of mutations</title>
        <p>In most situations, the probability of mutation to each distinct state may not be uniform (i.e., character <italic>χ</italic><sub>1</sub> mutating from the unmutated state <italic>s</italic><sub>0</sub> to state <italic>s</italic><sub>4</sub> may be twice as likely as mutating to state <italic>s</italic><sub>6</sub>). Therefore, we incorporate this information into choosing which character and mutation to split over based on the following criteria:
<disp-formula id="Equh"><alternatives><tex-math id="M51">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$i,j = \underset{i,j}{\text{argmin}}\, p_{i}(s_{0}, s_{j})^{f(n_{i,j})}$$ \end{document}</tex-math><mml:math id="M52"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mtext>arg min</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equh.gif" position="anchor"/></alternatives></disp-formula> where <italic>p</italic><sub><italic>i</italic></sub>(<italic>s</italic><sub>0</sub>,<italic>s</italic><sub><italic>j</italic></sub>) is the probability that character <italic>χ</italic><sub><italic>i</italic></sub> mutates from the unmutated state <italic>s</italic><sub>0</sub> to <italic>s</italic><sub><italic>j</italic></sub> and <italic>f</italic>(<italic>n</italic><sub><italic>i</italic>,<italic>j</italic></sub>) is some transformation of the number of cells that report mutation <italic>j</italic> in character <italic>i</italic> that is supposed to reflect the future penalty (number of independent mutations of character <italic>i</italic> to state <italic>j</italic>) we will have to include in the tree if we do not pick <italic>i</italic>,<italic>j</italic> as our next split. After a comparison of 5 different transformations (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S15), we find that <italic>f</italic>(<italic>n</italic><sub><italic>i</italic>,<italic>j</italic></sub>)=<italic>n</italic><sub><italic>i</italic>,<italic>j</italic></sub> gives the best performance, leaving us with the following criteria for splittings:
<disp-formula id="Equi"><alternatives><tex-math id="M53">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$i,j = \underset{i,j}{\text{argmin}}\, p_{i}(s_{0}, s_{j})^{n_{i,j}}$$ \end{document}</tex-math><mml:math id="M54"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mtext>arg min</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equi.gif" position="anchor"/></alternatives></disp-formula></p>
      </sec>
      <sec id="Sec33">
        <title>A hybrid method for solving single-cell lineage tracing phylogenies</title>
        <p>Due to the runtime constraints of the Steiner tree method, it is infeasible for such method to scale to tens of thousand of cells. Therefore, we build a simple hybrid method which takes advantage of the heuristic proposed in the greedy algorithm and the theoretical optimality of the Steiner tree method. Recall that in the greedy method, we continued to choose splits recursively until only one sample was left per subset. In this method, rather than follow the same process, we choose a cutoff for each subset (e.g., 200 cells). Once a subset has reached a size lower than the said cutoff, we feed each individual subset into the Potential Graph Builder and Steiner tree solver, which compute an optimal phylogeny for the subset of cells. After an optimal sub-tree is found, we merge it back into the greedy tree. Therefore, we build a graph whose initial mutations are chosen from the greedy method and whose latter mutations are chosen more precisely via the Steiner tree approach.</p>
        <p>Below, we present a pseudocode algorithm for the hybrid method. We note the slight difference in greedy from before. Namely, greedy additionally accepts a cutoff parameter and, in addition to returning a network built up to that cutoff, returns all subsets that are still needed to be solved.</p>
        <p>
          <graphic position="anchor" xlink:href="13059_2020_2000_Figc_HTML" id="MO9"/>
        </p>
        <p>This approach scales well when each instance of Steiner tree is ran on an individual thread, and thus often takes only a few hours to run on several thousand cells.</p>
      </sec>
    </sec>
    <sec id="Sec34">
      <title>Theoretical analysis of parallel evolution</title>
      <sec id="Sec35">
        <title>Estimating first and second moments of double mutations</title>
        <p><bold>Expected number of double mutations</bold> Under the framework of our simulation, we assume that each at each generation, every cell divides, and then each character of each cell undergoes random mutation independently. Let <italic>p</italic> be the probability that a particular character mutates and <italic>q</italic> be the probability the character took on a particular mutated state given that it mutated. Let <italic>T</italic> be the true phylogenetic tree over the samples. According to our model, <italic>T</italic> must be a full binary tree, and the samples are leaves of <italic>T</italic>. Let <italic>X</italic> be the total number of times a particular mutation occurred in the <italic>T</italic>. Let <italic>X</italic><sub><italic>u</italic>,<italic>v</italic></sub> be an indicator variable for edge (<italic>u</italic>,<italic>v</italic>) such that:
<disp-formula id="Equj"><alternatives><tex-math id="M55">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$X_{u,v} = \left\{ \begin{array}{ll} 1 &amp; \text{if a mutation occurs on edge }(u,v)\\ 0 &amp; \text{otherwise} \end{array}\right. $$ \end{document}</tex-math><mml:math id="M56"><mml:mrow><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="{"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mtext>if a mutation occurs on edge</mml:mtext><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equj.gif" position="anchor"/></alternatives></disp-formula> Let <italic>h</italic> be the height of the <italic>T</italic>, which is equalled to the number of generations. If <italic>v</italic> is at depth <italic>d</italic> in <italic>T</italic>, then the probability that a mutation occurs at (<italic>u</italic>,<italic>v</italic>) is <italic>p</italic><italic>q</italic>(1−<italic>p</italic>)<sup><italic>d</italic>−1</sup>. Since there are 2<sup><italic>d</italic></sup> nodes at depth <italic>d</italic>, we have:
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M57">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} E(X) &amp;= \sum_{(u,v)\in T}E(X_{u,v})\\ &amp;= \sum_{d = 1}^{h}2^{d}pq(1-p)^{d-1} \\ &amp;= \frac{2pq((2-2p)^{h}-1)}{1-2p} \end{aligned}  $$ \end{document}</tex-math><mml:math id="M58"><mml:mtable><mml:mtr><mml:mtd><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mtext mathvariant="italic">pq</mml:mtext><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mtext mathvariant="italic">pq</mml:mtext><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>Let <italic>n</italic>=2<sup><italic>h</italic></sup> be the number of cells in our sample. If <italic>p</italic>&gt;0.5, <italic>E</italic>(<italic>X</italic>)≤2<italic>p</italic><italic>q</italic>/(2<italic>p</italic>−1), if <italic>p</italic>=0.5, <italic>E</italic>(<italic>X</italic>)=2<italic>p</italic><italic>q</italic><italic>h</italic>=<italic>O</italic>(log<italic>n</italic>), and if <italic>p</italic>&lt;0.5, <inline-formula id="IEq19"><alternatives><tex-math id="M59">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$E(X) = O(n^{\frac {1}{\log _{2}{2-2p}}})$\end{document}</tex-math><mml:math id="M60"><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq19.gif"/></alternatives></inline-formula>. Moreover, for fixed <italic>h</italic>, <italic>E</italic>(<italic>X</italic>) has a single peak for <italic>p</italic>∈[0,1], meaning that it increases with <italic>p</italic> for sufficiently small values of <italic>p</italic>, and always increases with <italic>q</italic>. Intuitively, this is because <italic>E</italic>(<italic>X</italic>) is small if (1) <italic>p</italic> is small enough that the character never mutates much throughout the experiment or (2) <italic>p</italic> is large enough that most mutations occur near the top of the tree, resulting in the extinction of unmutated cells early in the experiment. While <italic>E</italic>(<italic>X</italic>) peaks for values of <italic>p</italic> in between, it is always directly proportional to <italic>q</italic> because <italic>X</italic> is simply equalled to <italic>q</italic> time the number of times the character mutated.</p>
        <p><bold>Variance of double mutations</bold> We can compute the variance as:
<disp-formula id="Equk"><alternatives><tex-math id="M61">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} Var(X) &amp;= E(X^{2}) - E(X)^{2}\\ &amp;= 2\sum_{(u,v)\neq(u',v')}E(X_{u,v}X_{u',v'}) + E(X) - E(X)^{2} \end{array} $$ \end{document}</tex-math><mml:math id="M62"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr><mml:mtr><mml:mtd class="align-1"/><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:munder><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equk.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>To compute <inline-formula id="IEq20"><alternatives><tex-math id="M63">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\phantom {\dot {i}\!}E(X_{u,v}X_{u',v'})$\end{document}</tex-math><mml:math id="M64"><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq20.gif"/></alternatives></inline-formula>, we note that for a given pair of edges (<italic>u</italic>,<italic>v</italic>) and (<italic>u</italic><sup>′</sup>,<italic>v</italic><sup>′</sup>), such that <italic>L</italic><italic>C</italic><italic>A</italic>(<italic>u</italic>,<italic>u</italic><sup>′</sup>) is at depth <italic>d</italic>, <italic>u</italic> is at depth <italic>d</italic>+<italic>l</italic>, and <italic>u</italic><sup>′</sup> is at depth <italic>l</italic>+<italic>k</italic>, the probability that a mutation occurred on both edges is <italic>p</italic><sup>2</sup><italic>q</italic><sup>2</sup>(1−<italic>p</italic>)<sup><italic>d</italic>+<italic>l</italic>+<italic>k</italic></sup>. Thus, we have:
<disp-formula id="Equl"><alternatives><tex-math id="M65">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $${\begin{aligned} \sum_{(u,v)\neq(u',v')}E(X_{u,v}X_{u',v'}) &amp;= \sum_{d=0}^{h-1}2^{d}\sum_{k=0}^{h-d-1}\sum_{l=0}^{h-d-1}2^{l+k}p^{2}q^{2}(1-p)^{d+l+k}\\ &amp;= p^{2}q^{2}\sum_{d=0}^{h-1}(2-2p)^{d}(\sum_{k=0}^{h-d-1}(2-2p)^{k})^{2}\\ &amp;= \frac{p^{2}q^{2}}{(2p-1)^{2}}\sum_{d=0}^{h-1}(2p-2)^{d}((2p-2)^{(h-d)}-1)^{2}\\ &amp;\leq \frac{p^{2}q^{2}}{(2p-1)^{2}}\sum_{d=0}^{h-1}(2p-2)^{2h-d}\\ &amp;= (2p-2)^{h+1}\frac{p^{2}q^{2}}{(2p-1)^{2}}\sum_{d=0}^{h-1}(2p-2)^{d}\\ &amp;\leq \frac{p^{2}q^{2}(2p-2)^{2h+1}}{(2p-1)^{3}} \end{aligned}} $$ \end{document}</tex-math><mml:math id="M66"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:munder><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equl.gif" position="anchor"/></alternatives></disp-formula> Thus, we can bound the variance as follows:
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M67">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {\begin{aligned} Var(X) &amp;\leq \frac{2p^{2}q^{2}(2p-2)^{2h+1}}{(2p-1)^{3}} + \frac{2pq\left(1-(2-2p)^{h}\right)}{2p-1} \\&amp;\quad- \frac{4p^{2}q^{2}(1-(2-2p)^{h})^{2}}{(2p-1)^{2}} \end{aligned}}  $$ \end{document}</tex-math><mml:math id="M68"><mml:mtable><mml:mtr><mml:mtd><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mtext mathvariant="italic">pq</mml:mtext><mml:mfenced close=")" open="("><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>4</mml:mn><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>This means that in the case that <italic>p</italic>&gt;0.5:
<disp-formula id="Equm"><alternatives><tex-math id="M69">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$Var(X) \leq \frac{2p^{2}q^{2}}{(2p-1)^{3}} + \frac{2pq}{2p-1} - \frac{4p^{2}q^{2}}{(2p-1)^{2}}$$ \end{document}</tex-math><mml:math id="M70"><mml:mrow><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo><mml:mo>≤</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mtext mathvariant="italic">pq</mml:mtext></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>4</mml:mn><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equm.gif" position="anchor"/></alternatives></disp-formula> In the case that <italic>p</italic>=0.5:
<disp-formula id="Equn"><alternatives><tex-math id="M71">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$Var(X) = O(h^{3}) = O(\log^{3}(n))$$ \end{document}</tex-math><mml:math id="M72"><mml:mrow><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:mover><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mover><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equn.gif" position="anchor"/></alternatives></disp-formula> In the case that <italic>p</italic>&lt;0.5:
<disp-formula id="Equo"><alternatives><tex-math id="M73">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$Var(X) = O(n^{\frac{2}{\log_{2}{2-2p}}})$$ \end{document}</tex-math><mml:math id="M74"><mml:mrow><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>O</mml:mi><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mo>log</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:munder><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equo.gif" position="anchor"/></alternatives></disp-formula></p>
      </sec>
      <sec id="Sec36">
        <title>Least squares linear estimate and negative correlation between frequency and the number of double mutations</title>
        <p>To justify the greedy, we must show that if a mutation occurs frequently, then it is likely to have occurred less times throughout the experiment. Let <italic>Y</italic> be the frequency of a particular mutation in the samples. We estimate <italic>X</italic> given <italic>Y</italic> using the least squares linear estimate (LLSE) as follows:
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M75">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ L(X|Y) = E(X) + \frac{CoV(X,Y)}{Var(Y)}(Y-E(Y))  $$ \end{document}</tex-math><mml:math id="M76"><mml:mi>L</mml:mi><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>|</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:mtext mathvariant="italic">CoV</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfrac><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math><graphic xlink:href="13059_2020_2000_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>Since <italic>C</italic><italic>o</italic><italic>V</italic>(<italic>X</italic>,<italic>Y</italic>)=<italic>E</italic>(<italic>X</italic><italic>Y</italic>)−<italic>E</italic>(<italic>X</italic>)<italic>E</italic>(<italic>Y</italic>), we need only to compute <italic>E</italic>(<italic>X</italic><italic>Y</italic>), which we do by expressing <italic>X</italic> and <italic>Y</italic> in terms of the same indicators:
<disp-formula id="Equp"><alternatives><tex-math id="M77">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$Y = \frac{1}{2^{h}}\sum_{(u,v) \in T} 2^{\text{depth}(v)}X_{u,v}$$ \end{document}</tex-math><mml:math id="M78"><mml:mrow><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:munder><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mtext>depth</mml:mtext><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equp.gif" position="anchor"/></alternatives></disp-formula> As a sanity check, it can easily be verified that <italic>E</italic>(<italic>Y</italic>)=<italic>q</italic>(1−(1−<italic>p</italic>)<sup><italic>h</italic></sup>) by computing <italic>E</italic>(<italic>Y</italic>) using these indicators:
<disp-formula id="Equq"><alternatives><tex-math id="M79">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} E(Y)&amp;=2^{-h}\sum_{d=1}^{h}2^{d}(1-p)^{d-1}pq*2^{h-d}\\ &amp;=pq\sum_{d=1}^{h}(1-p)^{d-1}\\ &amp;=q(1-(1-p)^{h})\\ \end{array} $$ \end{document}</tex-math><mml:math id="M80"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mtext mathvariant="italic">pq</mml:mtext><mml:mo>∗</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr><mml:mtr><mml:mtd class="align-1"/><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">pq</mml:mtext><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big">∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr><mml:mtr><mml:mtd class="align-1"/><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:mi>q</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr><mml:mtr><mml:mtd class="align-1"/></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equq.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>Thus, we can compute <italic>E</italic>(<italic>X</italic><italic>Y</italic>) similar to how we computed <italic>E</italic>(<italic>X</italic><sup>2</sup>) for variance.
<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M81">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {\begin{aligned} E(XY) &amp;= 2^{-h}E((\sum_{(u,v)\in T}X_{u,v})(\sum_{(u,v)\in T}2^{\text{depth}(v)}X_{u,v}))\\ &amp;=2^{-h}\Big(2\sum_{(u,v)\neq (u',v')}2^{\text{depth}(v)}E(X_{u,v}X_{u',v'})+\sum_{(u,v)\in T}2^{\text{depth}(v)}E(X_{u,v}^{2})\Big)\\ &amp;= 2*2^{-h}\sum_{d=0}^{h-1}2^{d}\sum_{k=0}^{h-1}\sum_{l=0}^{h-1}2^{l+k}p^{2}q^{2}(1-p)^{d+l+k}*2^{h-d-l-1} + E(Y)\\ &amp;= p^{2}q^{2}\sum_{d=0}^{h-1}\sum_{k=1}^{h-d-1}\sum_{l=0}^{h-d-1}(1-p)^{d}(2-2p)^{k}(1-p)^{l} + E(Y)\\ &amp;=\frac{pq^{2}}{1-2p}\sum_{d=0}^{h-1}(2-2p)^{h-d}-1)(1-(1-p)^{h-d})(1-p)^{d} + E(Y)\\ &amp;=\frac{pq^{2}}{1-2p}\Big(2(2-2p)^{h}(1-2^{-h})-\frac{(2-2p)(1-p)^{h}((2-2p)^{h}-1)}{1-2p} \\ &amp; \quad \quad \quad \quad - \frac{1-(1-p)^{h}}{p}+h(1-p)^{h}\Big) + E(Y)\\ \end{aligned}}  $$ \end{document}</tex-math><mml:math id="M82"><mml:mtable><mml:mtr><mml:mtd><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">XY</mml:mtext><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mo>(</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mtext>depth</mml:mtext><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mstyle mathsize="1.61em"><mml:mfenced open="("><mml:mrow/></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>≠</mml:mo><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mtext>depth</mml:mtext><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo><mml:mo>∈</mml:mo><mml:mi>T</mml:mi></mml:mrow></mml:munder><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mtext>depth</mml:mtext><mml:mo>(</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>X</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mstyle mathsize="1.61em"><mml:mfenced open=")"><mml:mrow/></mml:mfenced></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>∗</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mi>l</mml:mi><mml:mo>+</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>∗</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mi>l</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mstyle mathsize="1.61em"><mml:mfenced open="("><mml:mrow/></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mi>h</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mstyle mathsize="1.61em"><mml:mfenced open=")"><mml:mrow/></mml:mfenced></mml:mstyle><mml:mo>+</mml:mo><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd></mml:mtr><mml:mtr/></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>Assuming that is <inline-formula id="IEq21"><alternatives><tex-math id="M83">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$p &lt; 1-1/\sqrt {2} \approx 0.29$\end{document}</tex-math><mml:math id="M84"><mml:mi>p</mml:mi><mml:mo>&lt;</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msqrt><mml:mo>≈</mml:mo><mml:mn>0.29</mml:mn></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq21.gif"/></alternatives></inline-formula> (based on our estimation of Cas9-cutting rates, this seems to be a biologically relevant probability), we have:
<disp-formula id="Equr"><alternatives><tex-math id="M85">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} {\lim}_{h\rightarrow \infty}CoV(X,Y) &amp;= \Big(2-\frac{2-2p}{1-2p}\Big)\frac{pq^{2}(2(1-p)^{2})^{h}}{1-2p}\\ &amp;= -\infty \end{array} $$ \end{document}</tex-math><mml:math id="M86"><mml:mtable class="align" columnalign="left"><mml:mtr><mml:mtd class="align-1"><mml:msub><mml:mrow><mml:mo>lim</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>→</mml:mo><mml:mi>∞</mml:mi></mml:mrow></mml:msub><mml:mtext mathvariant="italic">CoV</mml:mtext><mml:mo>(</mml:mo><mml:mi>X</mml:mi><mml:mo>,</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:mstyle mathsize="1.61em"><mml:mfenced open="("><mml:mrow/></mml:mfenced></mml:mstyle><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mstyle mathsize="1.61em"><mml:mfenced open=")"><mml:mrow/></mml:mfenced></mml:mstyle><mml:mfrac><mml:mrow><mml:mi>p</mml:mi><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr><mml:mtr><mml:mtd class="align-1"/><mml:mtd class="align-2"><mml:mo>=</mml:mo><mml:mo>−</mml:mo><mml:mi>∞</mml:mi><mml:mspace width="2em"/></mml:mtd><mml:mtd><mml:mspace width="2em"/></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equr.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>since 2&lt;(2−2<italic>p</italic>)/(1−2<italic>p</italic>) when <italic>p</italic>&lt;0.5. <italic>V</italic><italic>a</italic><italic>r</italic>(<italic>Y</italic>) can be computed using the same indicators:
<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M87">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {\begin{aligned} Var(Y) &amp;= 2\sum_{i,j}E(Y_{i}Y_{j}) + \sum_{i}E(Y_{i}^{2}) - E(Y)^{2}\\ \sum_{i,j}E(Y_{i}Y_{j}) &amp;= 2^{-2h}\sum_{d=0}^{h-1}2^{d}(1-p)^{d}(\sum_{k=0}^{h-d-1}2^{k}(1-p)^{k}pq*2^{h-d-k-1})^{2}\\ &amp;=\frac{q^{2}}{4}\sum_{d=0}^{h-1}(\frac{1-p}{2})^{d}(\frac{1-(1-p)^{h-d}}{p})^{2}\\ &amp;=\frac{q^{2}}{4}\sum_{d=0}^{h-1}(\frac{1-p}{2})^{d} - \frac{2(1-p)^{h}}{2^{d}}+ \frac{(1-p)^{2h}}{(2-2p)^{d}}\\ &amp;= \frac{q^{2}}{4}\Big(\frac{2(1-(\frac{1-p}{2})^{h})}{1+p}-4(1-p)^{h}(1-2^{-h}) + \\ &amp; \quad \quad \quad \quad \quad \frac{(2-2p)(1-p)^{2h}(1-(\frac{1}{2-2p})^{h})}{1-2p}\Big) \end{aligned}}  $$ \end{document}</tex-math><mml:math id="M88"><mml:mtable><mml:mtr><mml:mtd><mml:mtext mathvariant="italic">Var</mml:mtext><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msubsup><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>)</mml:mo><mml:mo>−</mml:mo><mml:mi>E</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mi>Y</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mi>E</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>Y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mtext mathvariant="italic">pq</mml:mtext><mml:mo>∗</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi><mml:mo>−</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>−</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac><mml:mo>+</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:mfrac><mml:mstyle mathsize="1.61em"><mml:mfenced open="("><mml:mrow/></mml:mfenced></mml:mstyle><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mo>−</mml:mo><mml:mn>4</mml:mn><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo><mml:mo>+</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mfrac><mml:mrow><mml:mo>(</mml:mo><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi><mml:mo>)</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>p</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>2</mml:mn><mml:mi>p</mml:mi></mml:mrow></mml:mfrac><mml:mstyle mathsize="1.61em"><mml:mfenced open=")"><mml:mrow/></mml:mfenced></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="13059_2020_2000_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula></p>
        <p>
          <disp-formula id="Equs">
            <alternatives>
              <tex-math id="M89">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$\begin{array}{*{20}l} \sum_{i}E(Y_{i}^{2}) &amp;= 2^{-2h}\sum_{d=1}^{h}2^{d}(1-p)^{d-1}pq*2^{2(h-d)}\\ &amp;=\frac{pq}{2}\sum_{d=0}^{h-1}(\frac{(1-p)}{2})^{d}\\ &amp;=\frac{pq(1-(\frac{1-p}{2})^{h})}{1+p} \end{array} $$ \end{document}</tex-math>
              <mml:math id="M90">
                <mml:mtable class="align" columnalign="left">
                  <mml:mtr>
                    <mml:mtd class="align-1">
                      <mml:munder>
                        <mml:mrow>
                          <mml:mo mathsize="big">∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                      </mml:munder>
                      <mml:mi>E</mml:mi>
                      <mml:mo>(</mml:mo>
                      <mml:msubsup>
                        <mml:mrow>
                          <mml:mi>Y</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>i</mml:mi>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                      </mml:msubsup>
                      <mml:mo>)</mml:mo>
                    </mml:mtd>
                    <mml:mtd class="align-2">
                      <mml:mo>=</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mo>−</mml:mo>
                          <mml:mn>2</mml:mn>
                          <mml:mi>h</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:munderover accent="false" accentunder="false">
                        <mml:mrow>
                          <mml:mo mathsize="big">∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>h</mml:mi>
                        </mml:mrow>
                      </mml:munderover>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mo>(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:mi>p</mml:mi>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mtext mathvariant="italic">pq</mml:mtext>
                      <mml:mo>∗</mml:mo>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                          <mml:mo>(</mml:mo>
                          <mml:mi>h</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mi>d</mml:mi>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mspace width="2em"/>
                    </mml:mtd>
                    <mml:mtd>
                      <mml:mspace width="2em"/>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd class="align-1"/>
                    <mml:mtd class="align-2">
                      <mml:mo>=</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mtext mathvariant="italic">pq</mml:mtext>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>2</mml:mn>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:munderover accent="false" accentunder="false">
                        <mml:mrow>
                          <mml:mo mathsize="big">∑</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                          <mml:mo>=</mml:mo>
                          <mml:mn>0</mml:mn>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>h</mml:mi>
                          <mml:mo>−</mml:mo>
                          <mml:mn>1</mml:mn>
                        </mml:mrow>
                      </mml:munderover>
                      <mml:msup>
                        <mml:mrow>
                          <mml:mo>(</mml:mo>
                          <mml:mfrac>
                            <mml:mrow>
                              <mml:mo>(</mml:mo>
                              <mml:mn>1</mml:mn>
                              <mml:mo>−</mml:mo>
                              <mml:mi>p</mml:mi>
                              <mml:mo>)</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mn>2</mml:mn>
                            </mml:mrow>
                          </mml:mfrac>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mi>d</mml:mi>
                        </mml:mrow>
                      </mml:msup>
                      <mml:mspace width="2em"/>
                    </mml:mtd>
                    <mml:mtd>
                      <mml:mspace width="2em"/>
                    </mml:mtd>
                  </mml:mtr>
                  <mml:mtr>
                    <mml:mtd class="align-1"/>
                    <mml:mtd class="align-2">
                      <mml:mo>=</mml:mo>
                      <mml:mfrac>
                        <mml:mrow>
                          <mml:mtext mathvariant="italic">pq</mml:mtext>
                          <mml:mo>(</mml:mo>
                          <mml:mn>1</mml:mn>
                          <mml:mo>−</mml:mo>
                          <mml:msup>
                            <mml:mrow>
                              <mml:mo>(</mml:mo>
                              <mml:mfrac>
                                <mml:mrow>
                                  <mml:mn>1</mml:mn>
                                  <mml:mo>−</mml:mo>
                                  <mml:mi>p</mml:mi>
                                </mml:mrow>
                                <mml:mrow>
                                  <mml:mn>2</mml:mn>
                                </mml:mrow>
                              </mml:mfrac>
                              <mml:mo>)</mml:mo>
                            </mml:mrow>
                            <mml:mrow>
                              <mml:mi>h</mml:mi>
                            </mml:mrow>
                          </mml:msup>
                          <mml:mo>)</mml:mo>
                        </mml:mrow>
                        <mml:mrow>
                          <mml:mn>1</mml:mn>
                          <mml:mo>+</mml:mo>
                          <mml:mi>p</mml:mi>
                        </mml:mrow>
                      </mml:mfrac>
                      <mml:mspace width="2em"/>
                    </mml:mtd>
                    <mml:mtd>
                      <mml:mspace width="2em"/>
                    </mml:mtd>
                  </mml:mtr>
                </mml:mtable>
              </mml:math>
              <graphic xlink:href="13059_2020_2000_Article_Equs.gif" position="anchor"/>
            </alternatives>
          </disp-formula>
        </p>
        <p>Note that if <italic>p</italic>&lt;0.5, every term in <italic>V</italic><italic>a</italic><italic>r</italic>(<italic>Y</italic>) converges to a constant as <italic>h</italic>→<italic>∞</italic>. Thus, if (1−<italic>p</italic>)<sup>2</sup>&gt;0.5, then as the depth increases, <italic>X</italic> and <italic>Y</italic> become exponentially more negatively correlated. This means that for biologically relevant values of <italic>p</italic>, the frequency of a mutation in the samples is negatively correlated with the number of times the mutation occurred, thus justifying the rationale of splitting the sample on more frequently occurring mutations.</p>
      </sec>
      <sec id="Sec37">
        <title>Simulation for tracking the evolution of a particular mutation</title>
        <p>To more efficiently simulate the number of occurrences of a particular mutation, we define {<italic>N</italic><sub>1</sub>,<italic>N</italic><sub>2</sub>,...<italic>N</italic><sub><italic>h</italic></sub>} as a Markov chain, where <italic>N</italic><sub><italic>t</italic></sub> is the number of unmutated cells at generation <italic>t</italic>, and <italic>N</italic><sub>1</sub>=1. Let <italic>A</italic><sub><italic>t</italic></sub>∼<italic>B</italic><italic>i</italic><italic>n</italic>(2<italic>N</italic><sub><italic>t</italic></sub>,<italic>p</italic>) be the number of cells that mutates at generation <italic>t</italic> and <italic>B</italic><sub><italic>t</italic></sub>∼<italic>B</italic><italic>i</italic><italic>n</italic>(<italic>A</italic><sub><italic>t</italic></sub>,<italic>a</italic>) be the number of mutated cell that took on the particular state in question. The Markov chain evolves as <italic>N</italic><sub><italic>t</italic>+1</sub>=2<italic>N</italic><sub><italic>t</italic></sub>−<italic>A</italic><sub><italic>t</italic></sub>. Note that we assume, in this model, that mutation can only occur after cell division. Thus, we have <inline-formula id="IEq22"><alternatives><tex-math id="M91">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$X = \sum _{t=1}^{h}B_{t}$\end{document}</tex-math><mml:math id="M92"><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:munderover><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq22.gif"/></alternatives></inline-formula> and <inline-formula id="IEq23"><alternatives><tex-math id="M93">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$Y = \sum _{t=1}^{h}2^{t-h}B_{t}$\end{document}</tex-math><mml:math id="M94"><mml:mi>Y</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>h</mml:mi></mml:mrow></mml:munderover><mml:msup><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mi>h</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>B</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq23.gif"/></alternatives></inline-formula>.</p>
      </sec>
    </sec>
    <sec id="Sec38">
      <title>Assessing the precision of greedy splits</title>
      <p>To assess the precision of greedy splits, we first simulated 100 true phylogenies of 400 cells (without dropout) for all pairs of parameters in <italic>n</italic><italic>u</italic><italic>m</italic>_<italic>s</italic><italic>t</italic><italic>a</italic><italic>t</italic><italic>e</italic><italic>s</italic>={2,10,40} and <italic>p</italic><sub><italic>c</italic></sub><italic>u</italic><italic>t</italic>={0.025,0.1,0.4}. For each network, we assessed the precision of the greedy split as follows:
<list list-type="order"><list-item><p>We used the criteria <italic>i</italic>,<italic>j</italic>= arg max<sub><italic>i</italic>,<italic>j</italic></sub><italic>n</italic><sub><italic>i</italic>,<italic>j</italic></sub> to select the character <italic>χ</italic><sub><italic>i</italic></sub> and state <italic>j</italic> to split on (as Cassiopeia-Greedy would do). This group of cells that have a mutation <italic>j</italic> in character <italic>χ</italic><sub><italic>i</italic></sub> is called <italic>G</italic>.</p></list-item><list-item><p>For defining the a set of <italic>n</italic> subsets corresponding to cells that inherited the (character, state) pair (<italic>i</italic>,<italic>j</italic>) independently using the true phylogenies, and call this set <italic>S</italic>=(<italic>s</italic><sub>1</sub>,<italic>s</italic><sub>2</sub>,...,<italic>s</italic><sub><italic>n</italic></sub>) (this corresponds to there being <italic>n</italic> parallel evolution events for the (character, state) pair (<italic>i</italic>,<italic>j</italic>).</p></list-item><list-item><p>We presume that the largest group of cells in <italic>S</italic> is the “true positive” set (let this be defined as <italic>s</italic><sup>′</sup>= arg max<sub><italic>s</italic></sub>|<italic>s</italic><sub><italic>i</italic></sub>|). We then define the precision <italic>P</italic> as the proportion of true positives in the set <italic>G</italic>—i.e., <inline-formula id="IEq24"><alternatives><tex-math id="M95">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$P = \frac {|s'|}{|G|}$\end{document}</tex-math><mml:math id="M96"><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:msup><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>G</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq24.gif"/></alternatives></inline-formula>.</p></list-item></list></p>
    </sec>
    <sec id="Sec39">
      <title>Statistics for IVLT analysis</title>
      <sec id="Sec40">
        <title>Meta purity statistic</title>
        <p>To calculate the agreement between clades (i.e., the leaves below a certain internal node of the tree) and some meta value, such as the experimental plate from which a sample came from, we can employ a chi-squared test. Specifically, we can compute the following statistic: considering some <italic>M</italic> clades at an arbitrary depth <italic>d</italic>, we find the count of meta values associated with each leaf in each clade, resulting in a vector of values <italic>m</italic><sub><italic>i</italic></sub> comprised of these meta-counts for each clade <italic>i</italic>. We can form a contingency table summarizing these results, <italic>T</italic>, where each internal value is exactly <italic>m</italic><sub><italic>i</italic>,<italic>j</italic></sub>—the counts of the meta item <italic>j</italic> in clade <italic>i</italic>. A chi-squared test statistic can be computed from this table.</p>
        <p>To compare across different trees solved with different methods, we report the chi-squared test statistic as a function of the number of clades, or degrees of freedom of the test.</p>
      </sec>
      <sec id="Sec41">
        <title>Mean majority vote statistic</title>
        <p>The mean majority vote statistic seeks to quantify how coherent each clade is with respect to its majority vote sample at a give depth. For a given clade with leaves <italic>L</italic><sub><italic>i</italic></sub> where |<italic>L</italic><sub><italic>i</italic></sub>|=<italic>n</italic>, where every leaf <italic>l</italic><sub><italic>i</italic>,<italic>j</italic></sub> corresponds to cell <italic>j</italic> in clade <italic>i</italic> has some meta label <italic>m</italic><sub><italic>j</italic></sub>, the majority vote of the clade is <inline-formula id="IEq25"><alternatives><tex-math id="M97">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$v = argmax_{m' \in M} \sum _{j \in n} \delta (j, m')$\end{document}</tex-math><mml:math id="M98"><mml:mi>v</mml:mi><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">argma</mml:mtext><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>∈</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:msub><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mi>δ</mml:mi><mml:mo>(</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq25.gif"/></alternatives></inline-formula>. Here, <italic>M</italic> is the full set of possible meta values and <italic>δ</italic>(<italic>m</italic><sub><italic>j</italic></sub>,<italic>m</italic><sup>′</sup>) is an indicator function evaluating to 1 iff <italic>m</italic><sub><italic>j</italic></sub>=<italic>m</italic><sup>′</sup>. The membership of this clade is then simply <inline-formula id="IEq26"><alternatives><tex-math id="M99">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {\sum _{j \in n} \delta (m_{j}, v)}{n}$\end{document}</tex-math><mml:math id="M100"><mml:mfrac><mml:mrow><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:munder><mml:mi>δ</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq26.gif"/></alternatives></inline-formula>. Then, the mean membership is the mean of these membership statistics for all clades at a certain depth (i.e., if the tree was cut at a depth of <italic>d</italic>, the clades considered here are all the internal nodes at depth <italic>d</italic> from the root). By definition, this value ranges from <inline-formula id="IEq27"><alternatives><tex-math id="M101">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\frac {1}{|M|}$\end{document}</tex-math><mml:math id="M102"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi>M</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq27.gif"/></alternatives></inline-formula> to 1.0.</p>
        <p>As above, to compare across different trees solved with various methods, we report this mean membership statistic as a function of the number of clades.</p>
      </sec>
    </sec>
    <sec id="Sec42">
      <title>Triplets correct statistic</title>
      <p>To compare the similarity of simulated trees to reconstructed trees, we take an approach which compares the sub-trees formed between triplets of the terminal states across the two trees. To do this, we sample ∼10,000 triplets from our simulated tree and compare the relative orderings of each triplet to the reconstructed tree. We say a triplet is “correct” if the orderings of the three terminal states are conserved across both trees. This approach is different from other tree comparison statistics, such as Robinson-Foulds [<xref ref-type="bibr" rid="CR34">34</xref>], which measures the number of edges that are similar between two trees.</p>
      <p>To mitigate the effect of disproportionately sampling triplets relatively close to the root of the tree, we calculate the percentage of triplets correct across each depth within the tree independently (depth measured by the distance from the root to the latest common ancestor (LCA) of the triplet). We then take the <italic>average</italic> of the percentage triplets correct across all depths. To further reduce the bias towards the few triplets that are sampled at levels of the tree with very few cells (i.e., few possible triplets), we modify this statistic to only take into account depths where there at least 20 cells. We report these statistics without this depth threshold in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S8.</p>
    </sec>
    <sec id="Sec43">
      <title>Allelic and phylogenetic distances</title>
      <p>For the analysis in Fig. <xref rid="Fig4" ref-type="fig">4</xref>, we define two metrics to capture cell-to-cell similarity: a normalized allelic distance and normalized phylogenetic distance. The normalized allelic distance is calculated as follows: for all target sites <italic>χ</italic><sub><italic>m</italic></sub>∈{ <italic>χ</italic><sub>1</sub>,..., <italic>χ</italic><sub><italic>M</italic></sub>} in a pair of cells <italic>c</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>j</italic></sub>:
<list list-type="order"><list-item><p>if state in <italic>χ</italic><sub><italic>m</italic></sub> is the same in <italic>c</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>j</italic></sub>, continue</p></list-item><list-item><p>else if state in <italic>χ</italic><sub><italic>m</italic></sub> is 0 or missing in either <italic>c</italic><sub><italic>i</italic></sub> or <italic>c</italic><sub><italic>j</italic></sub> increment the allelic distance by 1</p></list-item><list-item><p>else increment the allelic distance by 2</p></list-item></list></p>
      <p>Finally, the allelic distance for a pair of cells is normalized by 2∗<italic>M</italic>, where <italic>M</italic> is the number of target sites.</p>
      <p>The phylogenetic distance is defined as simply the number of mutations separating the two cells <italic>c</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>j</italic></sub> as implied by the tree (i.e., the number of mutations along the branches for the shortest path separating <italic>c</italic><sub><italic>i</italic></sub> and <italic>c</italic><sub><italic>j</italic></sub>). The normalized phylogenetic distances is this distance, divided by the diameter (defined as the maximum phylogenetic distance between all pairs of cells) of the tree.</p>
    </sec>
    <sec id="Sec44">
      <title>Bootstrapping analysis</title>
      <p>Bootstrapping was done using a custom function for sampling <italic>M</italic> target sites (i.e., characters) from an <italic>N</italic>×<italic>M</italic> character matrix with replacement and reconstructing trees from these bootstrapped samples. After performing tree inference, we collapsed “singles” using the collapse.singles function in the R package “ape.” For the purposes of our robustness analysis, we sampled <italic>B</italic>=100 trees from <italic>N</italic>=10 simulated trees and used the Transfer Bootstrap Expectation (TBE) [<xref ref-type="bibr" rid="CR62">62</xref>] statistic for assessing branch support for each clade as implemented in Booster (available at <ext-link ext-link-type="uri" xlink:href="https://github.com/evolbioinfo/booster/">https://github.com/evolbioinfo/booster/</ext-link>).</p>
    </sec>
    <sec id="Sec45">
      <title>Application of Camin-Sokal</title>
      <p>We applied Camin-Sokal using the “mix” program in PHYLIP [<xref ref-type="bibr" rid="CR63">63</xref>] as done for reconstructions for McKenna et al. [<xref ref-type="bibr" rid="CR5">5</xref>] and Raj et al. [<xref ref-type="bibr" rid="CR6">6</xref>]. To use “mix,” we first factorized the characters into binary ones (thus ending up with <inline-formula id="IEq28"><alternatives><tex-math id="M103">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\sum _{i} s_{i}$\end{document}</tex-math><mml:math id="M104"><mml:munder><mml:mrow><mml:mo>∑</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq28.gif"/></alternatives></inline-formula> binary characters total, where <italic>s</italic><sub><italic>i</italic></sub> is the number of states that character <italic>i</italic> presented). Then, we one-hot encoded the states into this binary representation where every position in the binary string represented a unique state at that character. We thus encoded every cell as having a 1 in the position of each binary factorization corresponding to the state observed at that character. If the cell was missing a value for character <italic>i</italic>, the binary factorization of the character was a series of “?” values (which represent missing values in PHYLIP “mix”) of length <italic>s</italic><sub><italic>i</italic></sub>. Before performing tree inference, we weighted every character based on the frequency of non-zero (and non-missing values) observed in the character matrix. After PHYLIP “mix” found a series of candidate trees, we applied PHYLIP “consense” to calculate a consensus tree to then use downstream.</p>
    </sec>
    <sec id="Sec46">
      <title>Application of neighbor joining</title>
      <p>We used Biopython’s neighbor-joining procedure to perform all neighbor joining in this manuscript. We begun similarly to the Camin-Sokal workflow, first factorizing all of the characters into a binary representation. Then, we applied the neighbor-joining procedure using the “identity” option as our similarity map.</p>
    </sec>
    <sec id="Sec47">
      <title>Application of Cassiopeia</title>
      <sec id="Sec48">
        <title>Reconstruction of simulated data</title>
        <p>We used Cassiopeia-ILP with a maximum neighborhood size of 10,000 and time to converge of 12,600s. Cassiopeia-Hybrid used a greedy cutoff of 200, a maximum neighborhood size of 6000 and 5000 s to converge. Cassiopeia-Greedy required no additional hyperparameters. Simulations with priors applied the exact prior probabilities used to generate the simulated trees.</p>
      </sec>
      <sec id="Sec49">
        <title>Reconstruction of in vitro clones</title>
        <p>For both Cassiopeia-Hybrid with and without priors, we used a cutoff of 200 cells and each instance of Cassiopeia-ILP was allowed 12,600 s to converge on a maximum neighborhood size of 10,000. Cassiopeia-ILP was applied with a maximum neighborhood size of 10,000 and a time to converge of 12,600 s.</p>
      </sec>
      <sec id="Sec50">
        <title>Simulation of target-site sequences for alignment benchmarking</title>
        <p>To determine an optimal alignment strategy and parameters for our target-site sequence processing pipeline, we simulated sequences and performed a grid search using Emboss’s Water algorithm (a local alignment strategy). We simulated 5000 sequences. For each sequence, we begun with the reference sequence and subjected it to multiple rounds of mutagenesis determined by a Poisson distribution with <italic>λ</italic>=3, and a maximum of 5 cuts. During each “cutting” event, we determined the outcomes as follows:
<list list-type="order"><list-item><p>Determine the number of Cas9 proteins localizing to the target site in this iteration, where <italic>n</italic><sub><italic>c</italic><italic>a</italic><italic>s</italic>9</sub>∼min(3,<italic>P</italic><italic>o</italic><italic>i</italic><italic>s</italic>(<italic>λ</italic>=0.4)).</p></list-item><list-item><p>Determine the site(s) to be cut by choosing available sites randomly, where the probability of being chosen is <inline-formula id="IEq29"><alternatives><tex-math id="M105">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$p = \frac {1}{n_{\text {uncut}}}$\end{document}</tex-math><mml:math id="M106"><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mtext>uncut</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math><inline-graphic xlink:href="13059_2020_2000_Article_IEq29.gif"/></alternatives></inline-formula> and <italic>n</italic><sub>uncut</sub> is the number of sites uncut on that sequence.</p></list-item><list-item><p>If <italic>n</italic><sub><italic>c</italic><italic>a</italic><italic>s</italic>9</sub>=1, we determined the type of the indel by drawing from a Bernoulli distribution with a probability of success of 0.75 (in our case, a “success” meant a deletion and a “failure” meant an insertion). We then determined by drawing from a negative binomial distribution as so: <italic>s</italic>∼min(30,max(1, <italic>N</italic><italic>B</italic>(0.5,0.1))). In the case of an insertion, we added random nucleotides of size <italic>s</italic> to the cut site, else we removed <italic>s</italic> nucleotides.</p></list-item><list-item><p>In the case of <italic>n</italic><sub><italic>c</italic><italic>a</italic><italic>s</italic>9</sub>≥2, we performed a resection event where all nucleotides between the two cut sites selected were removed.</p></list-item><list-item><p>After a cut event, we appended the result of the Cas9 interaction to a corresponding CIGAR string</p></list-item></list></p>
        <p>Our Water simulations were exactly 300 bp, possibly extending past the Poly-A signal, as would be the case reading off a Nova-seq sequencer.</p>
        <p>Upon simulating our ground truth dataset, we performed our grid search by constructing alignments with Water with a combination of gap open and gap extension penalties. We varied the gap open penalties between 5 and 50 and gap extension penalties between 0.02 and 2.02.</p>
        <p>To score resulting alignments, we compared the resulting CIGAR string to our ground truth CIGAR string for each simulated sequence. To do so, we first split each cigar string into “chunks,” corresponding to the individual deletions or insertions called. For example, for some CIGAR string 40<italic>M</italic>2<italic>I</italic>3<italic>D</italic>10<italic>M</italic>, the chunks would be 40<italic>M</italic>, 2<italic>I</italic>, 3<italic>D</italic>, and 10<italic>M</italic>. Then, beginning with a max score of 1, we first deducted the difference between the number of chunks in the ground truth and the alignment. Then, in the case where the number of chunks were equal between ground truth and alignment, we deducted the percent nucleotides that differed between CIGARs. For example, if the ground truth was 100<italic>M</italic> and the alignment gave 95<italic>M</italic>, the penalty would be 0.05.</p>
        <p>To find the optimal set of parameters, we selected a parameter pair that not only scored very well, but also located in the parameter space where small perturbations in gap open and gap extension had little effect.</p>
      </sec>
      <sec id="Sec51">
        <title>Simulation of lineages for algorithm benchmarking</title>
        <p>We simulated lineages using the following parameters:
<list list-type="order"><list-item><p>The number of characters to consider, <italic>C</italic></p></list-item><list-item><p>The number of states per character, <italic>S</italic></p></list-item><list-item><p>The dropout per characters, <italic>d</italic><sub><italic>c</italic></sub> ∀<italic>c</italic>∈<italic>C</italic></p></list-item><list-item><p>The depth of the tree (i.e., the number of binary cell division), <italic>D</italic></p></list-item><list-item><p>The probability that a site can be mutated, <italic>p</italic>. This is a general probability of cutting</p></list-item><list-item><p>The rate at which to subsample the data at the end of the experiment, <italic>M</italic></p></list-item></list></p>
        <p>To simulate the tree, we begin by first generating the probability of each character mutating to a state, here represented as <italic>p</italic><sub><italic>c</italic></sub>(0,<italic>s</italic>),∀<italic>s</italic>∈<italic>S</italic>. In order to do this, we fit a spline function to the inferred prior probabilities from the lineage tracing experiment (refer to the section entitled “<xref rid="Sec23" ref-type="sec">Determining prior probabilities of indel formation</xref>” for information on how we infer prior probabilities). We then draw <italic>S</italic> values from this interpolated distribution. We then normalize these mutation rates to sum to <italic>p</italic>, therefore allowing in general a <italic>p</italic> probability of mutating a character and 1−<italic>p</italic> probability of remaining uncut. In the case of the “state distribution” simulations (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S13), we say that <italic>p</italic><sub><italic>c</italic></sub> is distributed as:
<disp-formula id="Equt"><alternatives><tex-math id="M107">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$p_{c} = \theta * Unif(0,1) + (1 - \theta) * F'(x) $$ \end{document}</tex-math><mml:math id="M108"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>θ</mml:mi><mml:mo>∗</mml:mo><mml:mtext mathvariant="italic">Unif</mml:mtext><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>+</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>θ</mml:mi><mml:mo>)</mml:mo><mml:mo>∗</mml:mo><mml:msup><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mo>′</mml:mo></mml:mrow></mml:msup><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equt.gif" position="anchor"/></alternatives></disp-formula> where <italic>F</italic><sup>′</sup>(<italic>x</italic>) is the interpolated empirical distribution and <italic>θ</italic> is the mixture component.</p>
        <p>Then, we simulate <italic>D</italic> cell divisions, where each cell division consists of allowing a mutation to take place at each character with probability <italic>p</italic>. In the case a mutation takes place, we choose a state to mutate to according to their respective probabilities. Importantly, once a character has been mutated in a cell, that character cannot mutate again.</p>
        <p>At the end of the experiment, we sample <italic>M</italic> percent of the cells resulting in 2<sup><italic>D</italic></sup>∗<italic>M</italic> cells in the final lineage.</p>
        <p>We find that this method for simulating lineages (in particular the method for generating a set of priors on how likely a given state is to form) is able to closely recapitulate observed lineages (Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S6).</p>
        <p><bold>Metrics for comparing simulations to empirical data</bold> We used three metrics of complexity to compare simulated clones to real clones:
<list list-type="bullet"><list-item><p><italic>Minimum compatibility distance</italic>: For every pair of character, we define the minimum compatibility distance as the minimum number of cells to be removed to obtain compatibility (Def. 1).</p></list-item><list-item><p><italic>Number of observable states per cell</italic>: The number of non-zero or non-missing values for each cell, across all characters (i.e., the amount of data that can be used for a reconstruction, per cell).</p></list-item><list-item><p><italic>Number of observable states per character</italic>: The number of non-zero or non-missing values across for each character, across all cells.</p></list-item></list></p>
      </sec>
      <sec id="Sec52">
        <title>Parallel evolution simulations for greedy benchmarking</title>
        <p>As shown above, our greedy approach should accurately reconstruct a lineage if a perfect phylogeny exists. In order to better quantify how much our greedy algorithm’s performance is affected by parallel mutations, we decided to simulate “near perfect phylogenies,” whereby we first began by simulating a perfect phylogeny, and afterwards introduced double mutated characters.</p>
        <p>Specifically, we begin by simulating perfect phylogenies with 40−<italic>k</italic> characters. We then fix a depth, <italic>d</italic>, and sample a node from said depth. We choose two grandchildren randomly from this node (one from each child) and introduce the same mutation on each of the edges from each child to grandchild, thereby violating the perfect phylogeny. We repeat this process <italic>k</italic> times. This thus creates an analysis, as presented in Additional file <xref rid="MOESM1" ref-type="media">1</xref>: Fig S5, whereby accuracy can be evaluated as a function of both depth of parallel evolution, <italic>d</italic>, and the number of events that occurred, <italic>k</italic>.</p>
      </sec>
      <sec id="Sec53">
        <title>Simulation of “base editor” technologies</title>
        <p>We used the simulation framework described above to simulate base editor technologies. To explore the trade off between the number of states and the number of characters, we simulated trees with 40,50,80, and 100 characters while maintaining the product of characters and states equal at 400 (thus, we had trees of 10,8,5, and 4 states per character, respectively). The dropout per character was set to 10%, the mutation rate per character was set to 1.04% (a previously observed mutation rate [<xref ref-type="bibr" rid="CR46">46</xref>]), and 400 cells were sampled from a tree of depth 10. For each character/state regime, we generated 10 trees for assessing the consistency of results. We use a negative binomial model (∼<italic>N</italic><italic>B</italic>(5,0.5)) as the editing outcome distribution (i.e., state distribution).</p>
      </sec>
      <sec id="Sec54">
        <title>Simulation of “phased recorder” technologies</title>
        <p>To simulate the phased recorder, we used 5 different experiments varying mutation rates across 50 characters and 10 states per character. In each experiment, we chose a mutation rate for each character from one of 10 regimes, each differing in their relationship to the base mutation rate <italic>p</italic><sub>0</sub>. To systematically implement this, mutation rate for <italic>χ</italic><sub><italic>i</italic></sub> is described as such:
<disp-formula id="Equu"><alternatives><tex-math id="M109">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$m_{i} = p_{0} * (1 + e_{j} * \lfloor\frac{i}{5}\rfloor) $$ \end{document}</tex-math><mml:math id="M110"><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>∗</mml:mo><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∗</mml:mo><mml:mo>⌊</mml:mo><mml:mfrac><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>5</mml:mn></mml:mrow></mml:mfrac><mml:mo>⌋</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:math><graphic xlink:href="13059_2020_2000_Article_Equu.gif" position="anchor"/></alternatives></disp-formula> where <italic>p</italic><sub>0</sub>=0.025 and <italic>e</italic><sub><italic>j</italic></sub> is an experiment scalar in <bold>e</bold>={0,0.05,0.1,0.25,0.5}. This means that for characters 1−5, <italic>m</italic><sub><italic>i</italic></sub>=<italic>p</italic><sub>0</sub>; for characters 6−10, <italic>m</italic><sub><italic>i</italic></sub>=<italic>e</italic><sub><italic>j</italic></sub><italic>p</italic><sub>0</sub>; for characters 11−15, <italic>m</italic><sub><italic>i</italic></sub>=2<italic>e</italic><sub><italic>j</italic></sub><italic>p</italic><sub>0</sub>; etc. To summarize each experiment, we provide the ratio between the maximum and minimum mutation rates, which is by definition 1+10<italic>r</italic><sub><italic>j</italic></sub> (because we had 50 characters). We compare two models of indel formation rates—the first being a negative binomial model (∼ <italic>N</italic><italic>B</italic>(5,0.5)) and the second being the spline distribution fit from empirical data.</p>
        <p>We simulated 10 trees per regime and reconstructed trees with Cassiopeia with and without priors.</p>
      </sec>
    </sec>
    <sec id="Sec55">
      <title>Reconstructions of GESTALT datasets</title>
      <p>We downloaded data corresponding to the original GESTALT study [<xref ref-type="bibr" rid="CR5">5</xref>] and the more recent scGESTALT study from <ext-link ext-link-type="uri" xlink:href="https://datadryad.org/resource/doi:10.5061/dryad.478t9">https://datadryad.org/resource/doi:10.5061/dryad.478t9</ext-link> and GSE105010, respectively. We created character matrices for input into Cassiopeia by creating pivot tables relating each cell the observed indel observed at each one of the 10 tandem sites on the GESTALT recorder. We then reconstructed trees from these character matrices using one of five algorithms: Camin-Sokal (used in the original studies), neighbor joining, Cassiopeia’s greedy method, Cassiopeia’s Steiner tree method, and Cassiopeia’s hybrid method.</p>
      <p>For each reconstruction, we record the parsimony of the tree, corresponding to the number of mutations that are inferred along the reconstructed tree. We display these findings in Fig. <xref rid="Fig6" ref-type="fig">6</xref>a, where we have <italic>Z</italic>-normalized the parsimonies across the methods for each dataset to enable easier visualization of relative performances.</p>
    </sec>
    <sec id="Sec56">
      <title>Visualization of trees</title>
      <p>To visualize trees, we use the iTOL interface [<xref ref-type="bibr" rid="CR64">64</xref>]. Colors in the heatmap denote a unique mutation, gray denotes an uncut site, and white denotes dropout.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary information</title>
    <sec id="Sec57">
      <p>
        <supplementary-material content-type="local-data" id="MOESM1">
          <media xlink:href="13059_2020_2000_MOESM1_ESM.pdf">
            <caption>
              <p><bold>Additional file 1</bold> Fig S1. Time complexity of lineage reconstruction approaches. Fig S2. Evaluation of the stability of the maximum neighborhood size parameter. Fig S3. Observed Frequency of Mutation is a Measure of True Mutation Count. Fig S4. Precision of Cassiopeia-Greedy First Split. Fig S5. Benchmarking of parallel evolution on the greedy heuristic. Fig S6. Determination of mutation rates used in simulation. Fig S7. Triplets Correct Statistic. Fig S8. Unthresholded Triplets Correct. Fig S9. Parsimony of reconstructed trees of 400 cell simulated datasets. Fig S10. Benchmarking of lineage tracing algorithms on 1000 cell synthetic datasets. Fig S11. Benchmarking of greedy and hybrid algorithms on large experiments. Fig S12. Bootstrapping analysis of Cassiopeia and Neighbor-Joining with the Transfer Bootstrap Expectation statistic. Fig S13. Reconstruction accuracy under over-dispersed state distributions. Fig S14. Observed Proportion of Parallel Evolution in Simulations. Fig S15. Determination of the indel prior transformation function. Fig S16. Incorporation of priors into Cassiopeia. Figure S17. Quality control metrics for the target-site sequencing library processing pipeline. Fig S18. Processing pipeline for the in vitro dataset. Fig S19. Identification of doublets using intBCs. Fig S20. Estimation of Prior Probabilities for Tree Reconstruction. Fig S21. Evaluation of algorithms on in vitro lineage tracing clones, First Split. Fig S22. Evaluation of algorithms on in vitro lineage tracing clones, Second Split. Fig S23. Exhaustion of Target Sites across Clones. Fig S24. Vignette of Inferential Mistakes for Clone 3. Fig S25. Parsimony scores from reconstructions of the GESTALT datasets. Fig S26. “Phased Recorder” leverages variability across target sites.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
      <p>
        <supplementary-material content-type="local-data" id="MOESM2">
          <media xlink:href="13059_2020_2000_MOESM2_ESM.docx">
            <caption>
              <p><bold>Additional file 2</bold> Review history.</p>
            </caption>
          </media>
        </supplementary-material>
      </p>
    </sec>
  </sec>
</body>
<back>
  <fn-group>
    <fn>
      <p>
        <bold>Publisher’s Note</bold>
      </p>
      <p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
    </fn>
    <fn>
      <p>Matthew G. Jones, Alex Khodaverdian, and Jeffrey J. Quinn contributed equally to this work.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary information</title>
    <p><bold>Supplementary information</bold> accompanies this paper at 10.1186/s13059-020-02000-8.</p>
  </sec>
  <ack>
    <title>Acknowledgements</title>
    <p>The authors would like to thank the members of the Yosef and Weissman labs for their helpful discussions in the development of this project. For sequencing, the authors thank Eric Chow and the UCSF CAT for their help.</p>
    <sec id="d29e9237">
      <title>Review history</title>
      <p>The review history is available as Additional file <xref rid="MOESM2" ref-type="media">2</xref>.</p>
    </sec>
  </ack>
  <notes notes-type="author-contribution">
    <title>Authors’ contributions</title>
    <p>M.G.J., A.K., J.J.Q, N.Y, and J.S.W. contributed to the design of the algorithm, interpretation of benchmarking results, and writing of the manuscript. A.K., C.X., and N.Y. conceived of the multi-state greedy algorithm and Steiner tree adaptation for the phylogeny inference problem. A.K. and M.G.J. implemented the algorithms and all code relevant to the project. M.G.J. and A.K. conducted all stress tests on synthetic datasets. R.W. and A.K. conducted experiments and theoretical work regarding the greedy heuristics robustness in lineage tracing experiments. J.J.Q. generated the in vitro reference dataset. M.G.J., J.J.Q, M.C, and J.A.H. designed the processing pipeline for empirical lineage tracing data. M.G.J. and J.J.Q processed the reference dataset and M.G.J. reconstructed trees. The authors read and approved the final manuscript.</p>
  </notes>
  <notes notes-type="funding-information">
    <title>Funding</title>
    <p>This work was funded by the NIH-NIAID grant U19 AI090023 (N.Y.), NIH R01 DA036858 and 1RM1 HG009490-01 (J.S.W.), F32 GM125247 (J.J.Q), and Chan-Zuckerberg Initiative 2018-184034. J.S.W. is a Howard Hughes Medical Institute Investigator. J.A.H. is the Rebecca Ridley Kry Fellow of the Damon Runyon Cancer Research Foundation (DRG-2262-16). M.M.C. is a Gordon and Betty Moore fellow of the Life Sciences Research Foundation.</p>
  </notes>
  <notes>
    <title>Ethics approval and consent to participate</title>
    <p>Not applicable.</p>
  </notes>
  <notes>
    <title>Consent for publication</title>
    <p>All authors have consented to the publication of this work in Genome Biology.</p>
  </notes>
  <notes notes-type="COI-statement">
    <title>Competing interests</title>
    <p>The authors declare that they have no competing interests.</p>
  </notes>
  <ref-list id="Bib1">
    <title>References</title>
    <ref id="CR1">
      <label>1</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sulston</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Schierenberg</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>White</surname>
            <given-names>JG</given-names>
          </name>
          <name>
            <surname>Thomson</surname>
            <given-names>JN</given-names>
          </name>
        </person-group>
        <article-title>The embryonic cell lineage of the nematode Caenorhabditis elegans</article-title>
        <source>Dev Biol</source>
        <year>1983</year>
        <volume>100</volume>
        <issue>1</issue>
        <fpage>64</fpage>
        <lpage>119</lpage>
        <pub-id pub-id-type="doi">10.1016/0012-1606(83)90201-4</pub-id>
        <?supplied-pmid 6684600?>
        <pub-id pub-id-type="pmid">6684600</pub-id>
      </element-citation>
    </ref>
    <ref id="CR2">
      <label>2</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Deppe</surname>
            <given-names>U</given-names>
          </name>
          <name>
            <surname>Schierenberg</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Cole</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Krieg</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Schmitt</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Yoder</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>von Ehrenstein</surname>
            <given-names>G</given-names>
          </name>
        </person-group>
        <article-title>Cell lineages of the embryo of the nematode Caenorhabditis elegans</article-title>
        <source>Proc Natl Acad Sci</source>
        <year>1978</year>
        <volume>75</volume>
        <issue>1</issue>
        <fpage>376</fpage>
        <lpage>80</lpage>
        <pub-id pub-id-type="doi">10.1073/pnas.75.1.376</pub-id>
        <?supplied-pmid 272653?>
        <pub-id pub-id-type="pmid">272653</pub-id>
      </element-citation>
    </ref>
    <ref id="CR3">
      <label>3</label>
      <mixed-citation publication-type="other">McKenna A, Gagnon JA. Recording development with single cell dynamic lineage tracing. Development. 2019; 146(12). 10.1242/dev.169730.</mixed-citation>
    </ref>
    <ref id="CR4">
      <label>4</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kester</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>van Oudenaarden</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Single-cell transcriptomics meets lineage tracing</article-title>
        <source>Cell Stem Cell</source>
        <year>2018</year>
        <volume>23</volume>
        <issue>2</issue>
        <fpage>166</fpage>
        <lpage>79</lpage>
        <pub-id pub-id-type="doi">10.1016/j.stem.2018.04.014</pub-id>
        <?supplied-pmid 29754780?>
        <pub-id pub-id-type="pmid">29754780</pub-id>
      </element-citation>
    </ref>
    <ref id="CR5">
      <label>5</label>
      <mixed-citation publication-type="other">McKenna A, Findlay GM, Gagnon JA, Horwitz MS, Schier AF, Shendure J. Whole organism lineage tracing by combinatorial and cumulative genome editing. Science. 2016. 10.1126/science.aaf7907.</mixed-citation>
    </ref>
    <ref id="CR6">
      <label>6</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Raj</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Wagner</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>McKenna</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pandey</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Klein</surname>
            <given-names>AM</given-names>
          </name>
          <name>
            <surname>Shendure</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Gagnon</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Schier</surname>
            <given-names>AF</given-names>
          </name>
        </person-group>
        <article-title>Simultaneous single-cell profiling of lineages and cell types in the vertebrate brain</article-title>
        <source>Nat Biotechnol</source>
        <year>2018</year>
        <volume>36</volume>
        <fpage>442</fpage>
        <pub-id pub-id-type="doi">10.1038/nbt.4103</pub-id>
        <?supplied-pmid 29608178?>
        <pub-id pub-id-type="pmid">29608178</pub-id>
      </element-citation>
    </ref>
    <ref id="CR7">
      <label>7</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Spanjaard</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Hu</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Mitic</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Olivares-Chauvet</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Janjuha</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Ninov</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Junker</surname>
            <given-names>JP</given-names>
          </name>
        </person-group>
        <article-title>Simultaneous lineage tracing and cell-type identification using CRISPR-Cas9-induced genetic scars</article-title>
        <source>Nat Biotechnol</source>
        <year>2018</year>
        <volume>36</volume>
        <fpage>469</fpage>
        <pub-id pub-id-type="doi">10.1038/nbt.4124</pub-id>
        <?supplied-pmid 29644996?>
        <pub-id pub-id-type="pmid">29644996</pub-id>
      </element-citation>
    </ref>
    <ref id="CR8">
      <label>8</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wagner</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>Weinreb</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Collins</surname>
            <given-names>ZM</given-names>
          </name>
          <name>
            <surname>Briggs</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Megason</surname>
            <given-names>SG</given-names>
          </name>
          <name>
            <surname>Klein</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Single-cell mapping of gene expression landscapes and lineage in the zebrafish embryo</article-title>
        <source>Science</source>
        <year>2018</year>
        <volume>360</volume>
        <issue>6392</issue>
        <fpage>981</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1126/science.aar4362</pub-id>
        <?supplied-pmid 29700229?>
        <pub-id pub-id-type="pmid">29700229</pub-id>
      </element-citation>
    </ref>
    <ref id="CR9">
      <label>9</label>
      <mixed-citation publication-type="other">Kalhor R, Kalhor K, Mejia L, Leeper K, Graveline A, Mali P, Church GM. Developmental barcoding of whole mouse via homing CRISPR. Science. 2018; 361(6405). https://doi.org/10.1126/science.aat9804. http://arxiv.org/abs/http://science.sciencemag.org/content/361/6405/eaat9804.full.pdf.</mixed-citation>
    </ref>
    <ref id="CR10">
      <label>10</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chan</surname>
            <given-names>MM</given-names>
          </name>
          <name>
            <surname>Smith</surname>
            <given-names>ZD</given-names>
          </name>
          <name>
            <surname>Grosswendt</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kretzmer</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Norman</surname>
            <given-names>TM</given-names>
          </name>
          <name>
            <surname>Adamson</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Jost</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Quinn</surname>
            <given-names>JJ</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Jones</surname>
            <given-names>MG</given-names>
          </name>
          <name>
            <surname>Khodaverdian</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Yosef</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Meissner</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>Molecular recording of mammalian embryogenesis</article-title>
        <source>Nature</source>
        <year>2019</year>
        <volume>570</volume>
        <issue>7759</issue>
        <fpage>77</fpage>
        <lpage>82</lpage>
        <pub-id pub-id-type="doi">10.1038/s41586-019-1184-5</pub-id>
        <?supplied-pmid 31086336?>
        <pub-id pub-id-type="pmid">31086336</pub-id>
      </element-citation>
    </ref>
    <ref id="CR11">
      <label>11</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Saitou</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Nei</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees</article-title>
        <source>Mol Biol Evol</source>
        <year>1987</year>
        <volume>4</volume>
        <issue>4</issue>
        <fpage>406</fpage>
        <lpage>25</lpage>
        <pub-id pub-id-type="pmid">3447015</pub-id>
      </element-citation>
    </ref>
    <ref id="CR12">
      <label>12</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Camin</surname>
            <given-names>JH</given-names>
          </name>
          <name>
            <surname>Sokal</surname>
            <given-names>RR</given-names>
          </name>
        </person-group>
        <article-title>A method for deducing branching sequences in phylogeny</article-title>
        <source>Evolution</source>
        <year>1965</year>
        <volume>19</volume>
        <issue>3</issue>
        <fpage>311</fpage>
        <lpage>26</lpage>
        <pub-id pub-id-type="doi">10.1111/j.1558-5646.1965.tb01722.x</pub-id>
      </element-citation>
    </ref>
    <ref id="CR13">
      <label>13</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Rannala</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Molecular phylogenetics: principles and practice</article-title>
        <source>Nat Rev Genet</source>
        <year>2012</year>
        <volume>13</volume>
        <fpage>303</fpage>
        <pub-id pub-id-type="doi">10.1038/nrg3186</pub-id>
        <?supplied-pmid 22456349?>
        <pub-id pub-id-type="pmid">22456349</pub-id>
      </element-citation>
    </ref>
    <ref id="CR14">
      <label>14</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gascuel</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Steel</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Neighbor-joining revealed</article-title>
        <source>Mol Biol Evol</source>
        <year>2006</year>
        <volume>23</volume>
        <issue>11</issue>
        <fpage>1997</fpage>
        <lpage>2000</lpage>
        <pub-id pub-id-type="doi">10.1093/molbev/msl072</pub-id>
        <?supplied-pmid 16877499?>
        <pub-id pub-id-type="pmid">16877499</pub-id>
      </element-citation>
    </ref>
    <ref id="CR15">
      <label>15</label>
      <mixed-citation publication-type="other">Mihaescu R, Levy D, Pachter L. Why neighbor-joining works. arXiv. 2006. <ext-link ext-link-type="uri" xlink:href="https://doi.org/arXiv:cs/0602041v3">https://doi.org/arXiv:cs/0602041v3</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR16">
      <label>16</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Cavalli-Sforza</surname>
            <given-names>LL</given-names>
          </name>
          <name>
            <surname>Edwards</surname>
            <given-names>AWF</given-names>
          </name>
        </person-group>
        <article-title>Phylogenetic analysis: models and estimation procedures</article-title>
        <source>Evolution</source>
        <year>1967</year>
        <volume>21</volume>
        <issue>3</issue>
        <fpage>550</fpage>
        <lpage>70</lpage>
        <pub-id pub-id-type="doi">10.1111/j.1558-5646.1967.tb03411.x</pub-id>
        <?supplied-pmid 28563688?>
        <pub-id pub-id-type="pmid">28563688</pub-id>
      </element-citation>
    </ref>
    <ref id="CR17">
      <label>17</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Fitch</surname>
            <given-names>WM</given-names>
          </name>
          <name>
            <surname>Margoliash</surname>
            <given-names>E</given-names>
          </name>
        </person-group>
        <article-title>Construction of phylogenetic trees</article-title>
        <source>Science</source>
        <year>1967</year>
        <volume>155</volume>
        <issue>3760</issue>
        <fpage>279</fpage>
        <lpage>84</lpage>
        <pub-id pub-id-type="doi">10.1126/science.155.3760.279</pub-id>
        <?supplied-pmid 5334057?>
        <pub-id pub-id-type="pmid">5334057</pub-id>
      </element-citation>
    </ref>
    <ref id="CR18">
      <label>18</label>
      <mixed-citation publication-type="other">Fitch W. Toward defining the course of evolution: minimum change for a specific tree topology. Syst Zool. 1971; 20(4).</mixed-citation>
    </ref>
    <ref id="CR19">
      <label>19</label>
      <mixed-citation publication-type="other">Farris JS. Methods for computing Wagner trees. Syst Zool. 1970; 19(1). 10.2307/2412028.</mixed-citation>
    </ref>
    <ref id="CR20">
      <label>20</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach</article-title>
        <source>J Mol Evol</source>
        <year>1981</year>
        <volume>17</volume>
        <issue>6</issue>
        <fpage>368</fpage>
        <lpage>76</lpage>
        <pub-id pub-id-type="doi">10.1007/BF01734359</pub-id>
        <pub-id pub-id-type="pmid">7288891</pub-id>
      </element-citation>
    </ref>
    <ref id="CR21">
      <label>21</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Price</surname>
            <given-names>MN</given-names>
          </name>
          <name>
            <surname>Dehal</surname>
            <given-names>PS</given-names>
          </name>
          <name>
            <surname>Arkin</surname>
            <given-names>AP</given-names>
          </name>
        </person-group>
        <article-title>Fasttree: Computing large minimum evolution trees with profiles instead of a distance matrix</article-title>
        <source>Mol Biol Evol</source>
        <year>2009</year>
        <volume>26</volume>
        <issue>7</issue>
        <fpage>1641</fpage>
        <lpage>50</lpage>
        <pub-id pub-id-type="doi">10.1093/molbev/msp077</pub-id>
        <?supplied-pmid 19377059?>
        <pub-id pub-id-type="pmid">19377059</pub-id>
      </element-citation>
    </ref>
    <ref id="CR22">
      <label>22</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huelsenbeck</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Ronquist</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Mrbayes: Bayesian inference of phylogenetic trees</article-title>
        <source>Bioinformatics</source>
        <year>2001</year>
        <volume>17</volume>
        <issue>8</issue>
        <fpage>754</fpage>
        <lpage>5</lpage>
        <pub-id pub-id-type="doi">10.1093/bioinformatics/17.8.754</pub-id>
        <?supplied-pmid 11524383?>
        <pub-id pub-id-type="pmid">11524383</pub-id>
      </element-citation>
    </ref>
    <ref id="CR23">
      <label>23</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kolaczkowski</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Thornton</surname>
            <given-names>JW</given-names>
          </name>
        </person-group>
        <article-title>Performance of maximum parsimony and likelihood phylogenetics when evolution is heterogeneous</article-title>
        <source>Nature</source>
        <year>2004</year>
        <volume>431</volume>
        <issue>7011</issue>
        <fpage>980</fpage>
        <lpage>4</lpage>
        <pub-id pub-id-type="doi">10.1038/nature02917</pub-id>
        <?supplied-pmid 15496922?>
        <pub-id pub-id-type="pmid">15496922</pub-id>
      </element-citation>
    </ref>
    <ref id="CR24">
      <label>24</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Zosin</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Khuller</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>On directed Steiner trees</article-title>
        <source>Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA ’02</source>
        <year>2002</year>
        <publisher-loc>Philadelphia, PA, USA</publisher-loc>
        <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR25">
      <label>25</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grotschel</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Martin</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Weismanel</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>The Steiner tree packing problem in VLSI design</article-title>
        <source>Math Program</source>
        <year>1997</year>
        <volume>78</volume>
        <fpage>265</fpage>
        <lpage>81</lpage>
        <pub-id pub-id-type="doi">10.1007/BF02614374</pub-id>
      </element-citation>
    </ref>
    <ref id="CR26">
      <label>26</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lu</surname>
            <given-names>CL</given-names>
          </name>
          <name>
            <surname>Tang</surname>
            <given-names>CY</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>RC-T</given-names>
          </name>
        </person-group>
        <article-title>The full Steiner tree problem</article-title>
        <source>Theor Comput Sci</source>
        <year>2003</year>
        <volume>306</volume>
        <issue>1</issue>
        <fpage>55</fpage>
        <lpage>67</lpage>
        <pub-id pub-id-type="doi">10.1016/S0304-3975(03)00209-3</pub-id>
      </element-citation>
    </ref>
    <ref id="CR27">
      <label>27</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Weng</surname>
            <given-names>JF</given-names>
          </name>
          <name>
            <surname>Mareels</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Thomas</surname>
            <given-names>DA</given-names>
          </name>
        </person-group>
        <article-title>Probability Steiner trees and maximum parsimony in phylogenetic analysis</article-title>
        <source>J Math Biol</source>
        <year>2012</year>
        <volume>64</volume>
        <issue>7</issue>
        <fpage>1225</fpage>
        <lpage>51</lpage>
        <pub-id pub-id-type="doi">10.1007/s00285-011-0442-4</pub-id>
        <?supplied-pmid 21706222?>
        <pub-id pub-id-type="pmid">21706222</pub-id>
      </element-citation>
    </ref>
    <ref id="CR28">
      <label>28</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Tajima</surname>
            <given-names>F</given-names>
          </name>
        </person-group>
        <article-title>Infinite-allele model and infinite-site model in population genetics</article-title>
        <source>J Genet</source>
        <year>1996</year>
        <volume>75</volume>
        <issue>1</issue>
        <fpage>27</fpage>
        <pub-id pub-id-type="doi">10.1007/BF02931749</pub-id>
      </element-citation>
    </ref>
    <ref id="CR29">
      <label>29</label>
      <mixed-citation publication-type="other">Kimura M. The number of heterozygous nucleotide sites maintained in a finite population due to steady flux of mutations. Genetics; 61(4):893–903.</mixed-citation>
    </ref>
    <ref id="CR30">
      <label>30</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>Efficient algorithms for inferring evolutionary trees</article-title>
        <source>Networks</source>
        <year>1991</year>
        <volume>21</volume>
        <issue>1</issue>
        <fpage>19</fpage>
        <lpage>28</lpage>
        <pub-id pub-id-type="doi">10.1002/net.3230210104</pub-id>
      </element-citation>
    </ref>
    <ref id="CR31">
      <label>31</label>
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bodlaender</surname>
            <given-names>HL</given-names>
          </name>
          <name>
            <surname>Fellows</surname>
            <given-names>MR</given-names>
          </name>
          <name>
            <surname>Warnow</surname>
            <given-names>TJ</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Kuich</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Two strikes against perfect phylogeny</article-title>
        <source>Automata, languages and programming</source>
        <year>1992</year>
        <publisher-loc>Berlin, Heidelberg</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="CR32">
      <label>32</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Steel</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>The complexity of reconstructing trees from qualitative characters and subtrees</article-title>
        <source>J Classif</source>
        <year>1992</year>
        <volume>9</volume>
        <issue>1</issue>
        <fpage>91</fpage>
        <lpage>116</lpage>
        <pub-id pub-id-type="doi">10.1007/BF02618470</pub-id>
      </element-citation>
    </ref>
    <ref id="CR33">
      <label>33</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gusfield</surname>
            <given-names>D</given-names>
          </name>
        </person-group>
        <article-title>The multi-state perfect phylogeny problem with missing and removable data: solutions via integer-programming and chordal graph theory</article-title>
        <source>J Comput Biol</source>
        <year>2010</year>
        <volume>17</volume>
        <issue>3</issue>
        <fpage>383</fpage>
        <lpage>99</lpage>
        <pub-id pub-id-type="doi">10.1089/cmb.2009.0200</pub-id>
        <?supplied-pmid 20377452?>
        <pub-id pub-id-type="pmid">20377452</pub-id>
      </element-citation>
    </ref>
    <ref id="CR34">
      <label>34</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Robinson</surname>
            <given-names>DF</given-names>
          </name>
          <name>
            <surname>Foulds</surname>
            <given-names>LR</given-names>
          </name>
        </person-group>
        <article-title>Comparison of phylogenetic trees</article-title>
        <source>Math Biosci</source>
        <year>1981</year>
        <volume>53</volume>
        <issue>1</issue>
        <fpage>131</fpage>
        <lpage>47</lpage>
        <pub-id pub-id-type="doi">10.1016/0025-5564(81)90043-2</pub-id>
      </element-citation>
    </ref>
    <ref id="CR35">
      <label>35</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Critchlow</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>Pearl</surname>
            <given-names>DK</given-names>
          </name>
          <name>
            <surname>Qian</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>The triples distance for rooted bifurcating phylogenetic trees</article-title>
        <source>Syst Biol</source>
        <year>1996</year>
        <volume>45</volume>
        <issue>3</issue>
        <fpage>323</fpage>
        <lpage>34</lpage>
        <pub-id pub-id-type="doi">10.1093/sysbio/45.3.323</pub-id>
      </element-citation>
    </ref>
    <ref id="CR36">
      <label>36</label>
      <mixed-citation publication-type="other">Verleysen M, François D. The curse of dimensionality in data mining and time series prediction. 2005:758–70. 10.1007/11494669_93.</mixed-citation>
    </ref>
    <ref id="CR37">
      <label>37</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McGinnis</surname>
            <given-names>CS</given-names>
          </name>
          <name>
            <surname>Murrow</surname>
            <given-names>LM</given-names>
          </name>
          <name>
            <surname>Gartner</surname>
            <given-names>ZJ</given-names>
          </name>
        </person-group>
        <article-title>Doubletfinder: doublet detection in single-cell RNA sequencing data using artificial nearest neighbors</article-title>
        <source>Cell Syst</source>
        <year>2019</year>
        <volume>8</volume>
        <issue>4</issue>
        <fpage>329</fpage>
        <lpage>3374</lpage>
        <pub-id pub-id-type="doi">10.1016/j.cels.2019.03.003</pub-id>
        <?supplied-pmid 30954475?>
        <pub-id pub-id-type="pmid">30954475</pub-id>
      </element-citation>
    </ref>
    <ref id="CR38">
      <label>38</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wolock</surname>
            <given-names>SL</given-names>
          </name>
          <name>
            <surname>Lopez</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Klein</surname>
            <given-names>AM</given-names>
          </name>
        </person-group>
        <article-title>Scrublet: Computational identification of cell doublets in single-cell transcriptomic data</article-title>
        <source>Cell Syst</source>
        <year>2019</year>
        <volume>8</volume>
        <issue>4</issue>
        <fpage>281</fpage>
        <lpage>2919</lpage>
        <pub-id pub-id-type="doi">10.1016/j.cels.2018.11.005</pub-id>
        <?supplied-pmid 30954476?>
        <pub-id pub-id-type="pmid">30954476</pub-id>
      </element-citation>
    </ref>
    <ref id="CR39">
      <label>39</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Stoeckius</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Zheng</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Houck-Loomis</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Hao</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Yeung</surname>
            <given-names>BZ</given-names>
          </name>
          <name>
            <surname>Mauck</surname>
            <given-names>WM</given-names>
          </name>
          <name>
            <surname>Smibert</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Satija</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>Cell hashing with barcoded antibodies enables multiplexing and doublet detection for single cell genomics</article-title>
        <source>Genome Biol</source>
        <year>2018</year>
        <volume>19</volume>
        <issue>1</issue>
        <fpage>224</fpage>
        <pub-id pub-id-type="doi">10.1186/s13059-018-1603-1</pub-id>
        <?supplied-pmid 30567574?>
        <pub-id pub-id-type="pmid">30567574</pub-id>
      </element-citation>
    </ref>
    <ref id="CR40">
      <label>40</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kim</surname>
            <given-names>HK</given-names>
          </name>
          <name>
            <surname>Min</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Song</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Jung</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Choi</surname>
            <given-names>JW</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Yoon</surname>
            <given-names>S</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>HH</given-names>
          </name>
        </person-group>
        <article-title>Deep learning improves prediction of CRISPR-Cpf1 guide RNA activity</article-title>
        <source>Nat Biotechnol</source>
        <year>2018</year>
        <volume>36</volume>
        <fpage>239</fpage>
        <pub-id pub-id-type="doi">10.1038/nbt.4061</pub-id>
        <?supplied-pmid 29431740?>
        <pub-id pub-id-type="pmid">29431740</pub-id>
      </element-citation>
    </ref>
    <ref id="CR41">
      <label>41</label>
      <mixed-citation publication-type="other">Chen W, McKenna A, Schreiber J, Yin Y, Agarwal V, Noble WS, Shendure J. Massively parallel profiling and predictive modeling of the outcomes of CRISPR/Cas9-mediated double-strand break repair. bioRxiv. 2018. https://doi.org/10.1101/481069. http://arxiv.org/abs/https://www.biorxiv.org/content/early/2018/11/28/481069.full.pdf.</mixed-citation>
    </ref>
    <ref id="CR42">
      <label>42</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Allen</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Crepaldi</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Alsinet</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Strong</surname>
            <given-names>AJ</given-names>
          </name>
          <name>
            <surname>Kleshchevnikov</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>De Angeli</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Páleníková</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Khodak</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Kiselev</surname>
            <given-names>V</given-names>
          </name>
          <name>
            <surname>Kosicki</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Bassett</surname>
            <given-names>AR</given-names>
          </name>
          <name>
            <surname>Harding</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Galanty</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Muñoz-Martínez</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Metzakopian</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Jackson</surname>
            <given-names>SP</given-names>
          </name>
          <name>
            <surname>Parts</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Predicting the mutations generated by repair of Cas9-induced double-strand breaks</article-title>
        <source>Nat Biotechnol</source>
        <year>2018</year>
        <volume>37</volume>
        <fpage>64</fpage>
        <pub-id pub-id-type="doi">10.1038/nbt.4317</pub-id>
      </element-citation>
    </ref>
    <ref id="CR43">
      <label>43</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gaudelli</surname>
            <given-names>NM</given-names>
          </name>
          <name>
            <surname>Komor</surname>
            <given-names>AC</given-names>
          </name>
          <name>
            <surname>Rees</surname>
            <given-names>HA</given-names>
          </name>
          <name>
            <surname>Packer</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Badran</surname>
            <given-names>AH</given-names>
          </name>
          <name>
            <surname>Bryson</surname>
            <given-names>DI</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>DR</given-names>
          </name>
        </person-group>
        <article-title>Programmable base editing of A*T to G*C in genomic DNA without DNA cleavage</article-title>
        <source>Nature</source>
        <year>2017</year>
        <volume>551</volume>
        <fpage>464</fpage>
        <pub-id pub-id-type="doi">10.1038/nature24644</pub-id>
        <?supplied-pmid 29160308?>
        <pub-id pub-id-type="pmid">29160308</pub-id>
      </element-citation>
    </ref>
    <ref id="CR44">
      <label>44</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Komor</surname>
            <given-names>AC</given-names>
          </name>
          <name>
            <surname>Kim</surname>
            <given-names>YB</given-names>
          </name>
          <name>
            <surname>Packer</surname>
            <given-names>MS</given-names>
          </name>
          <name>
            <surname>Zuris</surname>
            <given-names>JA</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>DR</given-names>
          </name>
        </person-group>
        <article-title>Programmable editing of a target base in genomic DNA without double-stranded DNA cleavage</article-title>
        <source>Nature</source>
        <year>2016</year>
        <volume>533</volume>
        <fpage>420</fpage>
        <pub-id pub-id-type="doi">10.1038/nature17946</pub-id>
        <?supplied-pmid 4873371?>
        <pub-id pub-id-type="pmid">27096365</pub-id>
      </element-citation>
    </ref>
    <ref id="CR45">
      <label>45</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gehrke</surname>
            <given-names>JM</given-names>
          </name>
          <name>
            <surname>Cervantes</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Clement</surname>
            <given-names>MK</given-names>
          </name>
          <name>
            <surname>Wu</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Zeng</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Bauer</surname>
            <given-names>DE</given-names>
          </name>
          <name>
            <surname>Pinello</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Joung</surname>
            <given-names>JK</given-names>
          </name>
        </person-group>
        <article-title>An APOBEC3A-Cas9 base editor with minimized bystander and off-target activities</article-title>
        <source>Nat Biotechnol</source>
        <year>2018</year>
        <volume>36</volume>
        <fpage>977</fpage>
        <pub-id pub-id-type="doi">10.1038/nbt.4199</pub-id>
        <?supplied-pmid 30059493?>
        <pub-id pub-id-type="pmid">30059493</pub-id>
      </element-citation>
    </ref>
    <ref id="CR46">
      <label>46</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hess</surname>
            <given-names>GT</given-names>
          </name>
          <name>
            <surname>Frésard</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Han</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Lee</surname>
            <given-names>CH</given-names>
          </name>
          <name>
            <surname>Li</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cimprich</surname>
            <given-names>KA</given-names>
          </name>
          <name>
            <surname>Montgomery</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Bassik</surname>
            <given-names>MC</given-names>
          </name>
        </person-group>
        <article-title>Directed evolution using dCas9-targeted somatic hypermutation in mammalian cells</article-title>
        <source>Nat Methods</source>
        <year>2016</year>
        <volume>13</volume>
        <fpage>1036</fpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.4038</pub-id>
        <?supplied-pmid 27798611?>
        <pub-id pub-id-type="pmid">27798611</pub-id>
      </element-citation>
    </ref>
    <ref id="CR47">
      <label>47</label>
      <mixed-citation publication-type="other">Yang H, Li Y, Zuo E, Sun Y, Wei W, Yuan T, Ying W, Steinmetz LM. Base editing generates substantial off-target single nucleotide variants. bioRxiv. 2018. https://doi.org/10.1101/480145. http://arxiv.org/abs/https://www.biorxiv.org/content/early/2018/11/27/480145.full.pdf.</mixed-citation>
    </ref>
    <ref id="CR48">
      <label>48</label>
      <mixed-citation publication-type="other">Jost M, Santos DA, Saunders RA, Horlbeck MA, Hawkins JS, Scaria SM, Norman TM, Hussmann JA, Liem CR, Gross CA, Weissman JS. Titrating gene expression with series of systematically compromised CRISPR guide RNAs. bioRxiv. 2019. https://doi.org/10.1101/717389. http://arxiv.org/abs/https://www.biorxiv.org/content/early/2019/07/28/717389.full.pdf.</mixed-citation>
    </ref>
    <ref id="CR49">
      <label>49</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Townsend</surname>
            <given-names>JP</given-names>
          </name>
        </person-group>
        <article-title>Profiling phylogenetic informativeness</article-title>
        <source>Syst Biol</source>
        <year>2007</year>
        <volume>56</volume>
        <issue>2</issue>
        <fpage>222</fpage>
        <lpage>31</lpage>
        <pub-id pub-id-type="doi">10.1080/10635150701311362</pub-id>
        <?supplied-pmid 17464879?>
        <pub-id pub-id-type="pmid">17464879</pub-id>
      </element-citation>
    </ref>
    <ref id="CR50">
      <label>50</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kalhor</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Mali</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Church</surname>
            <given-names>GM</given-names>
          </name>
        </person-group>
        <article-title>Rapidly evolving homing CRISPR barcodes</article-title>
        <source>Nat Methods</source>
        <year>2016</year>
        <volume>14</volume>
        <fpage>195</fpage>
        <pub-id pub-id-type="doi">10.1038/nmeth.4108</pub-id>
        <?supplied-pmid 27918539?>
        <pub-id pub-id-type="pmid">27918539</pub-id>
      </element-citation>
    </ref>
    <ref id="CR51">
      <label>51</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huelsenbeck</surname>
            <given-names>JP</given-names>
          </name>
          <name>
            <surname>Ronquist</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Nielsen</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Bollback</surname>
            <given-names>JP</given-names>
          </name>
        </person-group>
        <article-title>Bayesian inference of phylogeny and its impact on evolutionary biology</article-title>
        <source>Science</source>
        <year>2001</year>
        <volume>294</volume>
        <issue>5550</issue>
        <fpage>2310</fpage>
        <lpage>4</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1065889</pub-id>
        <?supplied-pmid 11743192?>
        <pub-id pub-id-type="pmid">11743192</pub-id>
      </element-citation>
    </ref>
    <ref id="CR52">
      <label>52</label>
      <mixed-citation publication-type="other">Feng J, DeWitt WS, McKenna A, Simon N, Willis A, Matsen FA. Estimation of cell lineage trees by maximum-likelihood phylogenetics. bioRxiv. 2019. https://doi.org/10.1101/595215. http://arxiv.org/abs/https://www.biorxiv.org/content/early/2019/03/31/595215.full.pdf.</mixed-citation>
    </ref>
    <ref id="CR53">
      <label>53</label>
      <mixed-citation publication-type="other">Zafar H, Lin C, Bar-Joseph Z. Single-cell lineage tracing by integrating CRISPR-Cas9 mutations with transcriptomic data. bioRxiv. 2019. https://doi.org/10.1101/630814. http://arxiv.org/abs/https://www.biorxiv.org/content/early/2019/05/07/630814.full.pdf.</mixed-citation>
    </ref>
    <ref id="CR54">
      <label>54</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sevillya</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Frenkel</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Snir</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Triplet MaxCut: a new toolkit for rooted supertree</article-title>
        <source>Methods Ecol Evol</source>
        <year>2016</year>
        <volume>7</volume>
        <issue>11</issue>
        <fpage>1359</fpage>
        <lpage>65</lpage>
        <pub-id pub-id-type="doi">10.1111/2041-210X.12606</pub-id>
      </element-citation>
    </ref>
    <ref id="CR55">
      <label>55</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Xi</surname>
            <given-names>Z</given-names>
          </name>
          <name>
            <surname>Liu</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Davis</surname>
            <given-names>CC</given-names>
          </name>
        </person-group>
        <article-title>The impact of missing data on species tree estimation</article-title>
        <source>Mol Biol Evol</source>
        <year>2015</year>
        <volume>33</volume>
        <issue>3</issue>
        <fpage>838</fpage>
        <lpage>60</lpage>
        <pub-id pub-id-type="doi">10.1093/molbev/msv266</pub-id>
        <?supplied-pmid 26589995?>
        <pub-id pub-id-type="pmid">26589995</pub-id>
      </element-citation>
    </ref>
    <ref id="CR56">
      <label>56</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Salvador-Martínez</surname>
            <given-names>I</given-names>
          </name>
          <name>
            <surname>Grillo</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Averof</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Telford</surname>
            <given-names>MJ</given-names>
          </name>
        </person-group>
        <article-title>Is it possible to reconstruct an accurate cell lineage using CRISPR recorders?</article-title>
        <source>eLife</source>
        <year>2019</year>
        <volume>8</volume>
        <fpage>40292</fpage>
        <pub-id pub-id-type="doi">10.7554/eLife.40292</pub-id>
      </element-citation>
    </ref>
    <ref id="CR57">
      <label>57</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Adamson</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Norman</surname>
            <given-names>TM</given-names>
          </name>
          <name>
            <surname>Jost</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Cho</surname>
            <given-names>MY</given-names>
          </name>
          <name>
            <surname>Nuñez</surname>
            <given-names>JK</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Villalta</surname>
            <given-names>JE</given-names>
          </name>
          <name>
            <surname>Gilbert</surname>
            <given-names>LA</given-names>
          </name>
          <name>
            <surname>Horlbeck</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Hein</surname>
            <given-names>MY</given-names>
          </name>
          <name>
            <surname>Pak</surname>
            <given-names>RA</given-names>
          </name>
          <name>
            <surname>Gray</surname>
            <given-names>AN</given-names>
          </name>
          <name>
            <surname>Gross</surname>
            <given-names>CA</given-names>
          </name>
          <name>
            <surname>Dixit</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Parnas</surname>
            <given-names>O</given-names>
          </name>
          <name>
            <surname>Regev</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>A multiplexed single-cell CRISPR screening platform enables systematic dissection of the unfolded protein response</article-title>
        <source>Cell</source>
        <year>2016</year>
        <volume>167</volume>
        <issue>7</issue>
        <fpage>1867</fpage>
        <lpage>188221</lpage>
        <pub-id pub-id-type="doi">10.1016/j.cell.2016.11.048</pub-id>
        <?supplied-pmid 27984733?>
        <pub-id pub-id-type="pmid">27984733</pub-id>
      </element-citation>
    </ref>
    <ref id="CR58">
      <label>58</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Jost</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Gilbert</surname>
            <given-names>LA</given-names>
          </name>
          <name>
            <surname>Horlbeck</surname>
            <given-names>MA</given-names>
          </name>
          <name>
            <surname>Krenning</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Menchon</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Rai</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Cho</surname>
            <given-names>MY</given-names>
          </name>
          <name>
            <surname>Stern</surname>
            <given-names>JJ</given-names>
          </name>
          <name>
            <surname>Prota</surname>
            <given-names>AE</given-names>
          </name>
          <name>
            <surname>Kampmann</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Akhmanova</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Steinmetz</surname>
            <given-names>MO</given-names>
          </name>
          <name>
            <surname>Tanenbaum</surname>
            <given-names>ME</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>JS</given-names>
          </name>
        </person-group>
        <article-title>Combined CRISPRi/a-based chemical genetic screens reveal that rigosertib is a microtubule-destabilizing agent</article-title>
        <source>Mol Cell</source>
        <year>2017</year>
        <volume>68</volume>
        <issue>1</issue>
        <fpage>210</fpage>
        <lpage>2236</lpage>
        <pub-id pub-id-type="doi">10.1016/j.molcel.2017.09.012</pub-id>
        <?supplied-pmid 28985505?>
        <pub-id pub-id-type="pmid">28985505</pub-id>
      </element-citation>
    </ref>
    <ref id="CR59">
      <label>59</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gilbert</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Horlbeck</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Adamson</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Villalta</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Chen</surname>
            <given-names>Y</given-names>
          </name>
          <name>
            <surname>Whitehead</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Guimaraes</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Panning</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Ploegh</surname>
            <given-names>H</given-names>
          </name>
          <name>
            <surname>Bassik</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Qi</surname>
            <given-names>L</given-names>
          </name>
          <name>
            <surname>Kampmann</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Weissman</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Genome-scale CRISPR-mediated control of gene repression and activation</article-title>
        <source>Cell</source>
        <year>2014</year>
        <volume>159</volume>
        <issue>3</issue>
        <fpage>647</fpage>
        <lpage>61</lpage>
        <pub-id pub-id-type="doi">10.1016/j.cell.2014.09.029</pub-id>
        <?supplied-pmid 25307932?>
        <pub-id pub-id-type="pmid">25307932</pub-id>
      </element-citation>
    </ref>
    <ref id="CR60">
      <label>60</label>
      <mixed-citation publication-type="other">Jones MG, Khodaverdian A, Quinn JJ, Chan MM, Hussmann JA, Wang R, Xu C, Weissman JS, Yosef N. Inference of single-cell phylogenies from lineage tracing data using Cassiopeia. All next generation sequencing datasets used in this study: RNA-seq libraries. Gene Expr Omnibus. <ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE146712">https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE146712</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR61">
      <label>61</label>
      <mixed-citation publication-type="other">Gurobi Optimization L. Gurobi optimizer reference manual. 2018. <ext-link ext-link-type="uri" xlink:href="http://www.gurobi.com">http://www.gurobi.com</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR62">
      <label>62</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lemoine</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Domelevo Entfellner</surname>
            <given-names>J-B</given-names>
          </name>
          <name>
            <surname>Wilkinson</surname>
            <given-names>E</given-names>
          </name>
          <name>
            <surname>Correia</surname>
            <given-names>D</given-names>
          </name>
          <name>
            <surname>Dávila Felipe</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>De Oliveira</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>Gascuel</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>Renewing Felsenstein’s phylogenetic bootstrap in the era of big data</article-title>
        <source>Nature</source>
        <year>2018</year>
        <volume>556</volume>
        <issue>7702</issue>
        <fpage>452</fpage>
        <lpage>6</lpage>
        <pub-id pub-id-type="doi">10.1038/s41586-018-0043-0</pub-id>
        <?supplied-pmid 29670290?>
        <pub-id pub-id-type="pmid">29670290</pub-id>
      </element-citation>
    </ref>
    <ref id="CR63">
      <label>63</label>
      <mixed-citation publication-type="other">Felsenstein J. Phylip (phylogeny inference package). Seattle: Distributed by the author. Department of Genome Sciences, University of Washington.</mixed-citation>
    </ref>
    <ref id="CR64">
      <label>64</label>
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ciccarelli</surname>
            <given-names>FD</given-names>
          </name>
          <name>
            <surname>Doerks</surname>
            <given-names>T</given-names>
          </name>
          <name>
            <surname>von Mering</surname>
            <given-names>C</given-names>
          </name>
          <name>
            <surname>Creevey</surname>
            <given-names>CJ</given-names>
          </name>
          <name>
            <surname>Snel</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Bork</surname>
            <given-names>P</given-names>
          </name>
        </person-group>
        <article-title>Toward automatic reconstruction of a highly resolved tree of life</article-title>
        <source>Science</source>
        <year>2006</year>
        <volume>311</volume>
        <issue>5765</issue>
        <fpage>1283</fpage>
        <lpage>7</lpage>
        <pub-id pub-id-type="doi">10.1126/science.1123061</pub-id>
        <?supplied-pmid 16513982?>
        <pub-id pub-id-type="pmid">16513982</pub-id>
      </element-citation>
    </ref>
    <ref id="CR65">
      <label>65</label>
      <mixed-citation publication-type="other">Jones MG, Khodaverdian A, Quinn JJ, Chan MM, Hussmann JA, Wang R, Xu C, Weissman JS, Yosef N. Inference of single-cell phylogenies from lineage tracing data using Cassiopeia. All software used in this study. 10.5281/zenodo.3697307. <ext-link ext-link-type="uri" xlink:href="https://github.com/YosefLab/Cassiopeia">https://github.com/YosefLab/Cassiopeia</ext-link>.</mixed-citation>
    </ref>
    <ref id="CR66">
      <label>66</label>
      <mixed-citation publication-type="other">Jones MG, Khodaverdian A, Quinn JJ, Chan MM, Hussmann JA, Wang R, Xu C, Weissman JS, Yosef N. Inference of single-cell phylogenies from lineage tracing data using Cassiopeia. All synthetic benchmarking data used in this study. 10.5281/zenodo.3706351.</mixed-citation>
    </ref>
  </ref-list>
</back>
