<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10766593</article-id>
    <article-id pub-id-type="pmid">38096585</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad751</article-id>
    <article-id pub-id-type="publisher-id">btad751</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genetics and Population Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic toggle="yes">Clumppling</italic>: cluster matching and permutation program with integer linear programming</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-3955-9026</contrib-id>
        <name>
          <surname>Liu</surname>
          <given-names>Xiran</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="equal">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="lead">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="lead">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute for Computational and Mathematical Engineering, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <xref rid="btad751-cor1" ref-type="corresp"/>
        <!--xiranliu@stanford.edu-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kopelman</surname>
          <given-names>Naama M</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="supporting">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Faculty of Sciences, Holon Institute of Technology</institution>, Holon 58109, <country country="IL">Israel</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Rosenberg</surname>
          <given-names>Noah A</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="equal">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="supporting">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="supporting">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="lead">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="supporting">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute for Computational and Mathematical Engineering, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <aff><institution>Department of Biology, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <xref rid="btad751-cor1" ref-type="corresp"/>
        <!--noahr@stanford.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad751-cor1">Corresponding author. Stanford University, Stanford, CA 94305, United States. E-mail: <email>xiranliu@stanford.edu</email> (X.L.) and <email>noahr@stanford.edu</email> (N.A.R.) </corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2024</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-12-14">
      <day>14</day>
      <month>12</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>12</month>
      <year>2023</year>
    </pub-date>
    <volume>40</volume>
    <issue>1</issue>
    <elocation-id>btad751</elocation-id>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>11</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>09</day>
        <month>12</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>12</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>04</day>
        <month>1</month>
        <year>2024</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad751.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>In the mixed-membership unsupervised clustering analyses commonly used in population genetics, multiple replicate data analyses can differ in their clustering solutions. Combinatorial algorithms assist in aligning clustering outputs from multiple replicates so that clustering solutions can be interpreted and combined across replicates. Although several algorithms have been introduced, challenges exist in achieving optimal alignments and performing alignments in reasonable computation time.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present <italic toggle="yes">Clumppling</italic>, a method for aligning replicate solutions in mixed-membership unsupervised clustering. The method uses integer linear programming for finding optimal alignments, embedding the cluster alignment problem in standard combinatorial optimization frameworks. In example analyses, we find that it achieves solutions with preferred values of a desired objective function relative to those achieved by <italic toggle="yes">Pong</italic> and that it proceeds with less computation time than <italic toggle="yes">Clumpak</italic>. It is also the first method to permit alignments across replicates with multiple arbitrary values of the number of clusters <italic toggle="yes">K</italic>.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><italic toggle="yes">Clumppling</italic> is available at <ext-link xlink:href="https://github.com/PopGenClustering/Clumppling" ext-link-type="uri">https://github.com/PopGenClustering/Clumppling</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01 HG005855</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>United States–Israel Binational Science Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2017024</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="11"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Population-genetic mixed-membership unsupervised clustering methods, such as <italic toggle="yes">Structure</italic> (<xref rid="btad751-B16" ref-type="bibr">Pritchard <italic toggle="yes">et al.</italic> 2000</xref>) and <italic toggle="yes">Admixture</italic> (<xref rid="btad751-B2" ref-type="bibr">Alexander <italic toggle="yes">et al.</italic> 2009</xref>), are essential tools for understanding patterns of genetic variation in populations. These methods make use of individual genomes to infer population-genetic clusters; each individual is assigned a membership vector, in which each entry represents the inferred membership of the individual in a specific cluster.</p>
    <p>Mixed-membership unsupervised clustering typically employs stochastic steps so that output memberships from independent runs of a clustering approach on the same set of individuals can differ. Membership differences across replicate analyses with the same settings can result from one of two sources. One source is <italic toggle="yes">label-switching</italic>, in which the clusters and the patterns of co-clustering of individuals across clusters are identical between runs, but the clusters are ordered differently across runs. The second source is <italic toggle="yes">genuine multimodality</italic>, in which the clustering algorithm yields multiple local optima that represent different patterns of co-clustering of individuals. The clustering methods are often employed with different settings, most notably for the number of clusters, denoted <italic toggle="yes">K</italic>, so that membership estimates in different runs can differ for additional reasons. Because multiple potential sources contribute to clustering differences among replicates, in mixed-membership unsupervised clustering analysis, it is important to align the clusters across these replicates—to resolve label-switching, to assess genuine multimodality with fixed settings, and to examine clustering solutions with different values of <italic toggle="yes">K</italic>.</p>
    <p>Three main methods exist for resolving the cluster alignment across runs of population-genetic unsupervised clustering: <italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>), <italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>), and <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>). The methods differ slightly in the precise cluster alignment problems they solve, the algorithmic rationale for their alignment solutions, and their computational performance. Our goal is to introduce a new method that expands the set of scenarios in which cluster alignment can be performed, connects cluster alignment in population genetics to classic techniques of combinatorial optimization, and introduces computational improvements. The new method is <italic toggle="yes">Clumppling</italic>: <underline>CLU</underline>ster <underline>M</underline>atching and <underline>P</underline>ermutation <underline>P</underline>rogram with integer <underline>L</underline>inear programm<underline>ING</underline>.</p>
  </sec>
  <sec>
    <title>2 Review of existing approaches</title>
    <sec>
      <title>2.1 <italic toggle="yes">Clumpp</italic></title>
      <p><italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>) aligns replicates with equally many clusters. It either enumerates all possible permutations of clusters for all replicates and returns the one that maximizes an average pairwise similarity between all replicates, or adopts a greedy algorithm to sequentially align successive replicates. The greedy algorithm reduces computational time but does not necessarily find the optimal alignment. To further speed up the alignment process, <italic toggle="yes">Clumpp</italic> has a “LargeKGreedy” method to sequentially align a replicate column-wise rather than all at once.</p>
    </sec>
    <sec>
      <title>2.2 <italic toggle="yes">Clumpak</italic></title>
      <p><italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>) extends beyond <italic toggle="yes">Clumpp</italic> in two ways: algorithmic mode detection and algorithmic alignment of replicates with different numbers of clusters. First, it uses <italic toggle="yes">Clumpp</italic> to align replicates with the same <italic toggle="yes">K</italic>. It then detects modes by constructing a similarity network from pairs of aligned replicates and using the Markov clustering algorithm to define nearly identical groups of replicates in the network: modes. A mode is represented by the mean memberships of replicates in the mode.</p>
      <p>To assess replicates with different numbers of clusters, <italic toggle="yes">Clumpak</italic> examines the alignment of modes with <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters to those with <italic toggle="yes">K</italic> clusters. It aligns replicates with <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">K</italic> clusters by including an empty cluster and solving a one-to-one matching problem.</p>
    </sec>
    <sec>
      <title>2.3 <italic toggle="yes">Pong</italic></title>
      <p><italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>) views the problem of aligning pairs of replicates with equally many clusters as an <italic toggle="yes">assignment problem</italic> (<xref rid="btad751-B5" ref-type="bibr">Burkard <italic toggle="yes">et al.</italic> 2009</xref>). It uses the polynomial-time Hungarian algorithm for this optimization.</p>
      <p>For mode detection among replicates with a fixed number of clusters, <italic toggle="yes">Pong</italic> follows a simple approach. It constructs a similarity network of aligned replicates and uses a user-specified threshold to remove edges, taking the disjoint cliques in the network as modes. A representative replicate is then randomly chosen from each clique to represent the mode.</p>
      <p>To align a pair of representative replicates of the major modes with numbers of clusters <italic toggle="yes">K</italic> and <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Pong</italic> considers mergings of every possible pair of clusters from the replicate with <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters and finds the optimal alignment from all one-to-one alignments. It proceeds through consecutive <italic toggle="yes">K</italic> values to align major modes across different <italic toggle="yes">K</italic> values.</p>
    </sec>
    <sec>
      <title>2.4 Improvements provided by <italic toggle="yes">Clumppling</italic></title>
      <p>The existing methods have been used in thousands of studies. Nevertheless, opportunities exist for more fully integrating cluster alignment methods with frameworks of combinatorial optimization and network theory, for addressing complex alignment scenarios, and for improving computation time. We highlight several desirable features of <italic toggle="yes">Clumppling</italic> (<xref rid="btad751-T1" ref-type="table">Table 1</xref>):</p>
      <table-wrap position="float" id="btad751-T1">
        <label>Table 1.</label>
        <caption>
          <p>Features of cluster alignment methods: (1) <italic toggle="yes">Clumpp</italic>, (2) <italic toggle="yes">Clumpak</italic>, (3) <italic toggle="yes">Pong</italic>, and (4) <italic toggle="yes">Clumppling</italic>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Feature</th>
              <th rowspan="1" colspan="1">1</th>
              <th rowspan="1" colspan="1">2</th>
              <th rowspan="1" colspan="1">3</th>
              <th rowspan="1" colspan="1">4</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Aligns same-<italic toggle="yes">K</italic> replicates on the same set of individuals</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Pairwise alignment uses established optimization tools</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Detects modes among same-<italic toggle="yes">K</italic> replicates algorithmically</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Mode detection uses established network tools</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns major modes of <italic toggle="yes">K</italic> and <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns all modes of <italic toggle="yes">K</italic> and <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Mode alignment uses all replicates in a mode</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns modes of <italic toggle="yes">K</italic> and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <list list-type="order">
        <list-item>
          <p>Like <italic toggle="yes">Pong</italic>, <italic toggle="yes">Clumppling</italic> performs pairwise alignments using established algorithms from combinatorial optimization.</p>
        </list-item>
        <list-item>
          <p>Like <italic toggle="yes">Clumpak</italic>, <italic toggle="yes">Clumppling</italic> performs mode detection using established community detection algorithms from network theory.</p>
        </list-item>
        <list-item>
          <p>Unlike the other methods, <italic toggle="yes">Clumppling</italic> performs alignments between all modes at successive values of <italic toggle="yes">K</italic>, not only the major modes.</p>
        </list-item>
        <list-item>
          <p>Unlike the other methods, <italic toggle="yes">Clumppling</italic> performs alignments between replicates that differ in number of clusters by more than one.</p>
        </list-item>
      </list>
      <p><italic toggle="yes">Clumppling</italic> combines benefits of <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> in relying on ideas used for optimization and alignment in other fields. It performs alignments in the settings considered by <italic toggle="yes">Clumpp</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> and also expands to new settings.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Methods</title>
    <sec>
      <title>3.1 Overview</title>
      <p>In the application of mixed-membership unsupervised clustering, the first step is to obtain multiple clustering replicates at each of multiple values of the number of clusters <italic toggle="yes">K</italic>. Beginning from these replicates, the procedure of <italic toggle="yes">Clumppling</italic> to align replicates and to extract modes is as follows:</p>
      <list list-type="order">
        <list-item>
          <p>Group replicates according to the number of clusters <italic toggle="yes">K</italic>.</p>
        </list-item>
        <list-item>
          <p>For each group of replicates with a shared <italic toggle="yes">K</italic>:</p>
          <list list-type="alpha-lower">
            <list-item>
              <p>For each pair of replicates in the group, obtain an optimal alignment with minimal pairwise cost.</p>
            </list-item>
            <list-item>
              <p>Detect subgroups of replicates belonging to shared modes.</p>
            </list-item>
            <list-item>
              <p>Obtain the consensus membership of each mode.</p>
            </list-item>
          </list>
        </list-item>
        <list-item>
          <p>Align pairs of modes across different values of <italic toggle="yes">K</italic> using their consensus memberships.</p>
        </list-item>
        <list-item>
          <p>Visualize the aligned modes.</p>
        </list-item>
      </list>
      <p>This pipeline follows that of <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> (<italic toggle="yes">Clumpp</italic> does not perform steps 2b, 2c, or 3, and its step analogous to 2a does not involve finding all pairwise alignments). However, <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> address only a special case of step 3 in which pairs of modes to be aligned across <italic toggle="yes">K</italic> values are the major modes of replicates with <italic toggle="yes">K</italic> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters. <italic toggle="yes">Clumppling</italic> provides alignments between each pair of modes, major and minor, considering replicates that can have numbers of clusters that differ by more than one. This new step is informative on how major and minor modes relate across <italic toggle="yes">K</italic> values and can also assist in aggregating clustering results with large <italic toggle="yes">K</italic> in which nonconsecutive <italic toggle="yes">K</italic> values may be of interest.</p>
      <p>For steps 2a and 2b, the central steps of the alignment procedure, we seek to improve performance and run time over previous methods. First, for pairwise alignment of replicates in step 2a, we use integer linear programming (ILP) from optimization theory. Second, for community detection in step 2b, we use the Louvain algorithm from network theory.</p>
    </sec>
    <sec>
      <title>3.2 Initial setup: dissimilarity between replicates</title>
      <p>Consider two replicates from a clustering algorithm on <italic toggle="yes">N</italic> individuals. Replicate 1, with <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters, can be represented as a matrix <italic toggle="yes">Q</italic> of size <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Entry <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the inferred membership coefficient of individual <italic toggle="yes">i</italic> in cluster <italic toggle="yes">k</italic>. Replicate 2, with <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters, is a matrix <italic toggle="yes">P</italic> of size <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Without loss of generality, suppose <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>To align two replicates, we need a measure that quantifies the similarity or dissimilarity of matrices <italic toggle="yes">Q</italic> and <italic toggle="yes">P</italic>. The problem of aligning the replicates can then be formulated as a problem of maximizing the similarity, or minimizing the dissimilarity, between membership matrices, one of whose columns is rearranged according to various proposed alignments.</p>
      <p>For <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Clumpp</italic> uses a pairwise similarity between two membership matrices, defined with the Frobenius matrix norm <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>⋅</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p><italic toggle="yes">Clumpp</italic> seeks to find the optimal alignment of <italic toggle="yes">R</italic> replicates by maximizing a measure of mean pairwise similarity of the <italic toggle="yes">R</italic> replicates, termed <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Clumpak</italic> uses this same method for the case of <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p><xref rid="E1" ref-type="disp-formula">Equation (1)</xref> applies only to membership matrices of the same size. For <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, we can consider measures that decompose the calculation into two levels: similarity or dissimilarity first between clusters, one from one replicate and one from the other, and second, between replicates.</p>
      <p><italic toggle="yes">Pong</italic> uses this two-level idea to define the similarity between replicates. Let <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denote the membership coefficients in cluster <italic toggle="yes">i</italic> of replicate 1, with entries <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">i</italic>th column of matrix <italic toggle="yes">Q</italic>. Similarly, let <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denote the membership coefficients in cluster <italic toggle="yes">j</italic> of replicate 2. A cluster similarity is derived from the Jaccard index on the overlap in membership coefficients between clusters <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>}</mml:mo><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the set of rows with nonzero membership in cluster <italic toggle="yes">i</italic> of <italic toggle="yes">Q</italic>, cluster <italic toggle="yes">j</italic> of <italic toggle="yes">P</italic>, or both.</p>
      <p>The similarity between replicates is then defined as the mean cluster similarity across all clusters for a pair of replicates:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the cluster in <italic toggle="yes">P</italic> to which cluster <italic toggle="yes">i</italic> in <italic toggle="yes">Q</italic> aligns.</p>
      <p>If <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> and all entries of the membership matrices are nonzero, i.e. <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mi mathvariant="script">J</mml:mi></mml:math></inline-formula> has a form close to <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, though not quite equal to it. <xref rid="E1" ref-type="disp-formula">Equations (1)</xref> and <xref rid="E3" ref-type="disp-formula">(3)</xref> can be rewritten as follows:
<disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>K</mml:mi></mml:mfrac></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> ranges from 0 to 1. <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> trivially if <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if for all <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. In this case, <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for 2 <italic toggle="yes">N</italic> of the <italic toggle="yes">NK</italic> pairs <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>However, the similarity measure <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mi mathvariant="script">J</mml:mi></mml:math></inline-formula> used by <italic toggle="yes">Pong</italic> does not reach 0. Because <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>≤</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow><mml:mo>≤</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math></inline-formula>. Therefore, <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></inline-formula>.</p>
      <p>For <italic toggle="yes">Clumppling</italic>, we seek a dissimilarity measure for membership matrices that (1) permits <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and (2) spans the full unit interval [0, 1], with a value of 0 for matrices with no overlap and a value of 1 for identical memberships. We use a measure with the two-level composition of <italic toggle="yes">Pong</italic> but with a form more similar to that of <italic toggle="yes">Clumpp</italic> and <italic toggle="yes">Clumpak</italic>.</p>
      <p>For the dissimilarity between cluster <italic toggle="yes">i</italic> of replicate 1 and cluster <italic toggle="yes">j</italic> of replicate 2, <italic toggle="yes">Clumppling</italic> uses
<disp-formula id="E6"><label>(6)</label><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>For the dissimilarity between two replicates with <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, it uses
<disp-formula id="E7"><label>(7)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Continuing with <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, dissimilarity <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is related to similarity <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> [<xref rid="E1" ref-type="disp-formula">Equations (1)</xref> and <xref rid="E4" ref-type="disp-formula">(4)</xref>]:
<disp-formula id="E8"><label>(8)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>We will see shortly how to proceed if <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.3 Step 2a: pairwise alignment</title>
      <p>Given a dissimilarity measure, the alignment of two replicates involves permuting the clusters of one replicate—the columns of its associated matrix—to minimize the dissimilarity with the other replicate.</p>
      <p>If <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, then aligning two replicates is the problem of finding the optimal one-to-one permutation that minimizes <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the matrix <italic toggle="yes">P</italic> with columns permuted under a permutation <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> of <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Minimizing the dissimilarity is equivalent to maximizing the similarity, the problem considered by <italic toggle="yes">Clumpp</italic>.</p>
      <p>If <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then the alignment between two replicates involves a many-to-one mapping from <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> in general, denote the alignment by <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>—i.e. <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Each <italic toggle="yes">i</italic> is mapped to exactly one <italic toggle="yes">j</italic>, and each <italic toggle="yes">j</italic> is the image of at least one <italic toggle="yes">i</italic>. The dissimilarity between replicates with alignment <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> is a function of <italic toggle="yes">Q</italic>, <italic toggle="yes">P</italic>, and <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>:
<disp-formula id="E9"><label>(9)</label><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Note that if <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then we have
<disp-formula id="E10"><label>(10)</label><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>as for each <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> is bounded above by 2. The maximal dissimilarity satisfies <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>If <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, however, then the alignment is no longer one-to-one, and for a specific <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> can exceed 2. For instance, for <italic toggle="yes">Q</italic> with dimensions <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">P</italic> with dimensions <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, an individual <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> with <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and alignment mapping <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>. Hence, if <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then the maximal value of <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can exceed 1. Nevertheless, for a specific pair <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, a smaller value of <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> always indicates a closer alignment.</p>
      <p>The problem of finding the optimal alignment between a pair of replicates can then be formulated as computing <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mtext>arg</mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mo>α</mml:mo></mml:msub></mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Clumppling</italic> uses ILP to perform this optimization.</p>
      <p>Linear programming (LP) concerns the problem of maximizing or minimizing a linear objective function subject to linear equality and inequality constraints (<xref rid="btad751-B19" ref-type="bibr">Schrijver 1998</xref>). These constraints form a feasible region of a convex polyhedron for variables that are optimized. LP problems are represented in canonical form by <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> records the <italic toggle="yes">n</italic> variables to be optimized, <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:math></inline-formula> is the objective function (cost function) to be minimized, and <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> summarize the linear constraints.</p>
      <p>ILP problems have additional constraints that some variables are integers; in those dimensions, the feasible set for the variables is restricted to lattice points in the polyhedron. An ILP problem in which all variables must be integers can be represented in canonical form <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Although ILP problems are NP-complete (<xref rid="btad751-B19" ref-type="bibr">Schrijver 1998</xref>), we can capitalize on extensive effort devoted to solving them as standard problems in optimization theory.</p>
      <p>To formulate the pairwise alignment problem with ILP, we place dissimilarities <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> between pairs of clusters in two replicates in a <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> matrix <italic toggle="yes">C</italic>. Denote the alignment <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> as a <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> indicator matrix <italic toggle="yes">W</italic>, where
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>Because <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> is a many-to-one mapping, each row of <italic toggle="yes">W</italic> in constrained to sum to exactly 1, and each column of <italic toggle="yes">W</italic> has sum at least 1.</p>
      <p>The dissimilarity between two replicates in <xref rid="E9" ref-type="disp-formula">Equation (9)</xref> can be written as follows:
<disp-formula id="E12"><label>(11)</label><mml:math id="M12" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>The alignment problem can now be formulated with ILP:
<disp-formula id="E13"><label>  </label><mml:math id="M13" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mtext>arg </mml:mtext><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>W</mml:mi></mml:munder></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><disp-formula id="E13a"><label>(12)</label><mml:math id="M13a" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>subject to</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>In fact, this minimization is an instance of <italic toggle="yes">binary linear programming</italic> (<xref rid="btad751-B24" ref-type="bibr">Wolsey 2020</xref>), in which variables are restricted to zeros and ones. The canonical form of this ILP problem appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods</xref>. A pairwise alignment problem framed in this manner can then be solved by standard ILP methods. <italic toggle="yes">Clumppling</italic> uses the branch-and-cut algorithm (<xref rid="btad751-B15" ref-type="bibr">Mitchell 2002</xref>). The optimal solution <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">w</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> that minimizes the objective function corresponds to the optimal alignment under the chosen dissimilarity measure [<xref rid="E13" ref-type="disp-formula">Equation (12)</xref>, as reformulated in <xref rid="sup1" ref-type="supplementary-material">Supplementary Equation (1)</xref>].</p>
    </sec>
    <sec>
      <title>3.4 Step 2b: mode detection via community detection</title>
      <p>For all replicates with equally many clusters, an optimal alignment is obtained for each pair using ILP as described in the previous section. Suppose there are <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> replicates with <italic toggle="yes">K</italic> clusters, and their membership matrices are <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>. Between a pair of replicates <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, the optimal alignment of <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, extracted from the solution <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">w</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> to <xref rid="E13" ref-type="disp-formula">Equation (12)</xref> that gives the minimal dissimilarity <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>To align all replicates simultaneously, <italic toggle="yes">Clumppling</italic> constructs an undirected graph <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using replicates as nodes <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Edge set <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> has weights <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> negatively weighted by the normalized dissimilarity of optimal alignments: <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>, and for <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>,
<disp-formula id="E14"><label>(13)</label><mml:math id="M14" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A higher weight indicates greater similarity of two replicates under their optimal alignment. The <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> matrix of edge weights is symmetric.</p>
      <p>We seek to find sets of replicates that are collectively similar to one another when optimally aligned, or <italic toggle="yes">modes</italic>. For this task, we rely on community detection algorithms (<xref rid="btad751-B7" ref-type="bibr">Fortunato 2010</xref>, <xref rid="btad751-B10" ref-type="bibr">Javed <italic toggle="yes">et al.</italic> 2018</xref>). In a graph, communities are groups of nodes that are more densely connected within the group than outside the group. A community in the graph <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> corresponds to a mode in the unsupervised clustering analysis. In terms of the associated edge-weight matrix, a matrix with nontrivial communities has a block-diagonal structure, with two or more blocks corresponding to communities. Entries within a block tend to exceed entries outside it for the associated rows and columns—indicating greater edge weights for node pairs within the same community than for pairs not in the same community.</p>
      <p><italic toggle="yes">Clumppling</italic> first tests a null hypothesis of no community structure. We use a test of <xref rid="btad751-B20" ref-type="bibr">Tokuda (2018)</xref>, based on differences between (i) random symmetric matrices with a block-diagonal community structure in which within-block off-diagonal entries are distributed differently from outside-block off-diagonal entries, and (ii) random symmetric matrices in which all off-diagonal entries are independently and identically distributed. Considering the largest and smallest eigenvalues of two transformed versions of the symmetric edge-weight matrix of the graph, the null hypothesis is rejected if one or both eigenvalues (of either matrix) lies outside specified intervals. In our application, if the null hypothesis of no community structure is rejected at <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">Clumppling</italic> proceeds to identify community structure in the undirected weighted graph <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>For community detection, <italic toggle="yes">Clumpak</italic> uses Markov clustering (MCL) (<xref rid="btad751-B21" ref-type="bibr">Van Dongen 2000</xref>), employing a threshold to remove some edges with lower weights from the network—i.e. to replace smaller edge weights with values of 0—thereby reducing the density of edges. <italic toggle="yes">Clumppling</italic> instead uses the Louvain method (<xref rid="btad751-B4" ref-type="bibr">Blondel <italic toggle="yes">et al.</italic> 2008</xref>), which does not require premodification of the network. This algorithm has a “resolution” parameter that affects the size of the detected communities; larger values typically find smaller communities and more of them. <italic toggle="yes">Clumppling</italic> allows the user to specify its value, with a default of 1.</p>
      <p>The outcome of mode detection via community detection algorithms is a set of communities of nodes, each of which corresponds to a subset of replicates that belong to the same mode. Modes are disjoint so that replicate each belongs to exactly one mode. Suppose <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> communities are detected, which we denote <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow><mml:mo>∩</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula> for all distinct <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∪</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It is possible for a mode to possess only one replicate, <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, although this “singleton” situation is somewhat unusual.</p>
    </sec>
    <sec>
      <title>3.5 Step 2c: consensus memberships for modes</title>
      <p>For each mode <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, we obtain a consensus membership matrix in one of two ways. First, we obtain a <italic toggle="yes">mean</italic> membership matrix of its replicates:
<disp-formula id="E15"><label>(14)</label><mml:math id="M15" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where, for simplicity, the <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> are treated as having already been aligned.</p>
      <p>We also obtain a <italic toggle="yes">representative</italic> membership matrix, the matrix of the replicate that has the largest sum of edge weights within the community:
<disp-formula id="E16"><label>(15)</label><mml:math id="M16" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mtext>arg </mml:mtext><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Either <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> can be used as the consensus membership of replicates in the mode. <italic toggle="yes">Clumppling</italic> uses <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> as its default.</p>
      <p>Suppose the set of the distinct numbers of clusters is <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>. After building networks of replicates for each <italic toggle="yes">K</italic>, we obtain a set of modes together with consensus memberships:
<disp-formula id="E17"><label>(16)</label><mml:math id="M17" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">K</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    </sec>
    <sec>
      <title>3.6 Step 3: alignment of modes across <italic toggle="yes">K</italic></title>
      <p>Finally, with modes defined, we align modes across values of <italic toggle="yes">K</italic>. In particular, we order the values of <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">K</mml:mi></mml:mrow></mml:math></inline-formula> in decreasing order: <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mo>⋯</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. We then obtain a multipartite graph of the pairwise alignments between modes across different values of <italic toggle="yes">K</italic>.</p>
      <p>For adjacent <italic toggle="yes">K</italic> values in <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>, <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, there exist <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> pairs of modes. For each such pair, we use ILP [<xref rid="E13" ref-type="disp-formula">Equation (12)</xref>] to align consensus memberships from <xref rid="E17" ref-type="disp-formula">Equation (16)</xref>. The optimal dissimilarity is <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the mapping of clusters of <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> to clusters of <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> that produces the optimum.</p>
      <p>We then use these dissimilarities between modes as weights to create a bipartite graph between modes of <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and modes of <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. For instance, the weight between mode <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and mode <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> can be set to
<disp-formula id="E18"><label>(17)</label><mml:math id="M18" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where larger weights indicate closer alignments. Note that theoretically, the dissimilarity <italic toggle="yes">D</italic> can exceed 1 for a pair of modes with different numbers of clusters. However, such a situation requires pairs of clusters to be matched extremely poorly between different values of <italic toggle="yes">K</italic>, an unlikely scenario after optimal alignment. Hence, negative weights in <xref rid="E18" ref-type="disp-formula">Equation (17)</xref> are unlikely.</p>
      <p>Combining the bipartite graphs between pairs of adjacent values of <italic toggle="yes">K</italic>, we obtain a <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>-partite graph representing alignments across modes with different numbers of clusters. We call our approach to the alignment of modes across <italic toggle="yes">K</italic> the “direct” approach.</p>
      <p>For consecutive values of <italic toggle="yes">K</italic>, we also consider a second approach that modifies the method of <italic toggle="yes">Pong</italic>; we term this second approach the “merge” approach. This approach enumerates all possible ways to merge a pair of clusters from the mode with <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters to produce <italic toggle="yes">K</italic> clusters. It then uses our ILP method to align two matrices of the same size. A total of <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> alignments are performed, and the one that achieves the smallest dissimilarity is chosen to be the optimal alignment between the two modes. Note that unlike the “direct” approach, which permits nonconsecutive <italic toggle="yes">K</italic> values, the “merge” approach requires the values of <italic toggle="yes">K</italic> to be consecutive.</p>
    </sec>
    <sec>
      <title>3.7 Visualization</title>
      <p>To display all modes at all numbers of clusters, we proceed sequentially in the order <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, arranging values of <italic toggle="yes">K</italic> with <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mo>…</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Proceeding from <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, for each adjacent pair <inline-formula id="IE162"><mml:math id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (e.g. <inline-formula id="IE163"><mml:math id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">K</italic> if their numbers of clusters are consecutive), we choose the most closely aligned pair of modes between them as “anchors.” We then perform the following three steps:</p>
      <list list-type="order">
        <list-item>
          <p>All other modes with <inline-formula id="IE164"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters are aligned to the <inline-formula id="IE165"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> anchor.</p>
        </list-item>
        <list-item>
          <p>All other modes with <inline-formula id="IE166"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters are aligned to the <inline-formula id="IE167"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> anchor.</p>
        </list-item>
        <list-item>
          <p>The modes of these two different <italic toggle="yes">K</italic> values are then aligned according to the alignment of the <inline-formula id="IE168"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> anchor pair.</p>
        </list-item>
      </list>
      <p>For example, consider three numbers of clusters <inline-formula id="IE169"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, each with two modes. Suppose the most closely aligned mode pair for <inline-formula id="IE170"><mml:math id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is (<inline-formula id="IE171"><mml:math id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>, <inline-formula id="IE172"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>) and that for <inline-formula id="IE173"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it is (<inline-formula id="IE174"><mml:math id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>, <inline-formula id="IE175"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>). First, we align modes of <inline-formula id="IE176"><mml:math id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: (1) <inline-formula id="IE177"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub> is aligned to the anchor <inline-formula id="IE178"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>. (2) <inline-formula id="IE179"><mml:math id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> is aligned to the anchor <inline-formula id="IE180"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. (3) Clusters in modes of these two <italic toggle="yes">K</italic> values are rearranged according to the alignment between <inline-formula id="IE181"><mml:math id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> and <inline-formula id="IE182"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. Next, we align modes of <inline-formula id="IE183"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the same way: (1) <inline-formula id="IE184"><mml:math id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub> is aligned to the anchor <inline-formula id="IE185"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>—which was already accomplished in the previous step (1), as alignments between modes with the same <italic toggle="yes">K</italic> apply symmetrically. (2) <inline-formula id="IE186"><mml:math id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> is aligned to the anchor <inline-formula id="IE187"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. (3) Across modes of <inline-formula id="IE188"><mml:math id="IM188" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE189"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, the alignment follows that between <inline-formula id="IE190"><mml:math id="IM190" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> and <inline-formula id="IE191"><mml:math id="IM191" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. In this way, all modes across <inline-formula id="IE192"><mml:math id="IM192" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are aligned.</p>
      <p>For visualization of aligned modes, <italic toggle="yes">Clumppling</italic> plots each mode as a “classic” structure plot—a stacked bar chart of equal height—with clusters represented by different colors (e.g. <xref rid="btad751-B17" ref-type="bibr">Rosenberg 2004</xref>). The number of replicates in a mode is marked above the associated plot. To visualize relationships between modes with different numbers of clusters, modes appear in a multipartite graph according to the across-<italic toggle="yes">K</italic> alignment. Modes with the same <italic toggle="yes">K</italic> appear in the same “layer,” where the number of layers is <inline-formula id="IE193"><mml:math id="IM193" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>, the number of distinct <italic toggle="yes">K</italic> values considered. For each <italic toggle="yes">K</italic>, modes are ordered in decreasing size (i.e. the number of replicates in the mode) and decreasing within-mode similarity [described in <xref rid="E19" ref-type="disp-formula">Equation (18)</xref>]. Modes with adjacent <italic toggle="yes">K</italic> values are joined by edges colored based on the edge weight [<xref rid="E18" ref-type="disp-formula">Equation (17)</xref>], with darker colors indicating larger weights and closer alignments. Minimal dissimilarities between pairs of modes under their optimal alignment—i.e. the optimal objective function values from <xref rid="E13" ref-type="disp-formula">Equation (12)</xref>—appear as labels on the edges, with smaller values indicating closer alignments. To visualize the variability within a mode, in addition to the structure plot, <italic toggle="yes">Clumppling</italic> provides a histogram of pairwise dissimilarities under optimal alignment of replicates within modes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>4 Evaluation of performance</title>
    <p>The <italic toggle="yes">Clumppling</italic> implementation is described in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods</xref>. We compare the alignment performance of <italic toggle="yes">Clumppling</italic> to the two existing methods, <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>, that align replicates across <italic toggle="yes">K</italic> values. Because they only align equal or consecutive <italic toggle="yes">K</italic> values, the evaluation does so as well—although <italic toggle="yes">Clumppling</italic> accommodates replicates with numbers of clusters differing by more than 1.</p>
    <sec>
      <title>4.1 Performance measure</title>
      <p>For replicates with a shared <italic toggle="yes">K</italic>, we use a performance measure based on the similarity score <inline-formula id="IE194"><mml:math id="IM194" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">Clumpp</italic> and <italic toggle="yes">Clumpak</italic>. For a mode <inline-formula id="IE195"><mml:math id="IM195" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE196"><mml:math id="IM196" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> denote the mean similarity score for all pairs of replicates in the mode after its replicates <inline-formula id="IE197"><mml:math id="IM197" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are all aligned pairwise:
<disp-formula id="E19"><label>(18)</label><mml:math id="M19" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is interpreted as the mapping of clusters of <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> to clusters of <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for the optimal alignment of <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Next, to obtain a mean similarity score involving all replicates and modes, we calculate a weighted similarity score <inline-formula id="IE203"><mml:math id="IM203" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> that assigns each replicate the mean similarity score of its associated mode:
<disp-formula id="E20"><label>(19)</label><mml:math id="M20" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We modify <xref rid="E20" ref-type="disp-formula">Equation (19)</xref> to exclude singleton modes <inline-formula id="IE204"><mml:math id="IM204" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> with <inline-formula id="IE205"><mml:math id="IM205" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Because singletons always have similarity score 1 in <xref rid="E19" ref-type="disp-formula">Equation (18)</xref>, their existence can upwardly bias the weighted similarity score. With <inline-formula id="IE206"><mml:math id="IM206" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> singleton modes, the singleton-excluded weighted similarity score becomes
<disp-formula id="E21"><label>(20)</label><mml:math id="M21" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:munderover></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula></p>
      <p>Note that removal of the singletons reduces the number of replicates that need to be aligned; it is useful to track the value <inline-formula id="IE207"><mml:math id="IM207" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> along with <inline-formula id="IE208"><mml:math id="IM208" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Because we compare the performance of <italic toggle="yes">Clumppling</italic> with methods that only support the alignment of replicates with consecutive values of <italic toggle="yes">K</italic>, we use a performance measure suited to consecutive <italic toggle="yes">K</italic> values. To evaluate across-<italic toggle="yes">K</italic> alignments, we measure the <inline-formula id="IE209"><mml:math id="IM209" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> similarity [<xref rid="E1" ref-type="disp-formula">Equation (1)</xref>] between the most closely aligned pair of modes aligned across each <inline-formula id="IE210"><mml:math id="IM210" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For this computation, an optimal alignment <inline-formula id="IE211"><mml:math id="IM211" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> has first already been identified for this pair of modes in Section 3.6. Two of the clusters in the mode with <inline-formula id="IE212"><mml:math id="IM212" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters are necessarily matched to the same cluster in the mode with <italic toggle="yes">K</italic> clusters, or <inline-formula id="IE213"><mml:math id="IM213" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for exactly one unordered pair of <inline-formula id="IE214"><mml:math id="IM214" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE215"><mml:math id="IM215" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. We apply the alignment <inline-formula id="IE216"><mml:math id="IM216" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>: we merge these two clusters, adding their columns in the membership matrix together to produce a single column. Mathematically, suppose the original <inline-formula id="IE217"><mml:math id="IM217" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> membership matrix for the mode with <inline-formula id="IE218"><mml:math id="IM218" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters is <italic toggle="yes">P</italic>, with columns <inline-formula id="IE219"><mml:math id="IM219" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It now becomes a new <inline-formula id="IE220"><mml:math id="IM220" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> membership matrix <inline-formula id="IE221"><mml:math id="IM221" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> with columns
<disp-formula id="E22"><mml:math id="M22" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Now the two membership matrices, <italic toggle="yes">Q</italic> and <inline-formula id="IE222"><mml:math id="IM222" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, both have size <inline-formula id="IE223"><mml:math id="IM223" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE224"><mml:math id="IM224" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is computed for these two matrices.</p>
      <p>Note that because this similarity calculation merges clusters, it measures the similarity of a mode with <italic toggle="yes">K</italic> clusters and a mode with <inline-formula id="IE225"><mml:math id="IM225" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters according to its value for a quantity optimized by the “merge” and not the “direct” approach. Hence, it is expected to have higher values when the “merge” rather than the “direct” approach is used to produce the optimal alignment. Because <italic toggle="yes">Pong</italic> uses the “merge” approach to align modes with consecutive numbers of clusters, the calculation evaluates <italic toggle="yes">Clumppling</italic> against <italic toggle="yes">Pong</italic> by a measure that <italic toggle="yes">Pong</italic> seeks to optimize.</p>
      <p>We evaluate the performances of all four possible combinations of the mode consensus approach and the approach for performing alignments. That is, we use either “representative” [<xref rid="E15" ref-type="disp-formula">Equation (14)</xref>] or “average” [<xref rid="E16" ref-type="disp-formula">Equation (15)</xref>] as the consensus membership of a mode. For alignments of modes with <italic toggle="yes">K</italic> and <inline-formula id="IE226"><mml:math id="IM226" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters, we use either the “direct” approach or the “merge” approach in identifying the alignment with the minimal dissimilarity [<xref rid="E9" ref-type="disp-formula">Equation (9)</xref>].</p>
    </sec>
    <sec>
      <title>4.2 Datasets</title>
      <p>We demonstrate the use of <italic toggle="yes">Clumppling</italic> and compare the alignment performance of the methods with two datasets. The first contains an unsupervised <italic toggle="yes">Admixture</italic> analysis of 399 individuals focused on the human population of Cape Verde. This dataset has replicates with small values of <italic toggle="yes">K</italic>. It provides an example in which many individuals, including 44 individuals in the admixed population of Cape Verde (<xref rid="btad751-B22" ref-type="bibr">Verdu <italic toggle="yes">et al.</italic> 2017</xref>), possess nontrivial memberships in multiple clusters; the original analysis of <xref rid="btad751-B22" ref-type="bibr">Verdu <italic toggle="yes">et al.</italic> (2017)</xref> considered 50 replicates each at <inline-formula id="IE227"><mml:math id="IM227" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>; we reanalyzed those replicates. For this dataset, we ran <italic toggle="yes">Clumppling</italic> using the default resolution parameter of 1 for the Louvain mode detection.</p>
      <p>The second dataset provides an example of alignment with relatively large values of <italic toggle="yes">K</italic>: a study of 600 chickens from 20 populations (<xref rid="btad751-B18" ref-type="bibr">Rosenberg <italic toggle="yes">et al.</italic> 2001</xref>) focused on values of <inline-formula id="IE228"><mml:math id="IM228" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mn>18</mml:mn><mml:mo>,</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula>, and we add <inline-formula id="IE229"><mml:math id="IM229" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:mn>21</mml:mn></mml:mrow></mml:math></inline-formula> here (“chicken dataset”). We begin from the original data, 27 genotyped loci in each of the 600 individuals, running <italic toggle="yes">Structure</italic> (<xref rid="btad751-B16" ref-type="bibr">Pritchard <italic toggle="yes">et al.</italic> 2000</xref>) for 20 replicates for each <italic toggle="yes">K</italic> from 17 to 21. We ran <italic toggle="yes">Structure</italic> with a burn-in period of length 5000 in the “Admixture” model followed by 50000 MCMC repetitions, as in <xref rid="btad751-B18" ref-type="bibr">Rosenberg <italic toggle="yes">et al.</italic> (2001)</xref>. For mode detection in <italic toggle="yes">Clumppling</italic>, we used 1.05 for the resolution parameter; for this more challenging dataset, increasing the resolution above the default of 1 leads to a larger number of modes but with greater within-mode similarity.</p>
    </sec>
    <sec>
      <title>4.3 Analysis of clustering replicates</title>
      <p>For each value of <italic toggle="yes">K</italic>, we used <italic toggle="yes">Clumppling</italic> to align the 50 <italic toggle="yes">Admixture</italic> replicates for the Cape Verde dataset. Alignments based on mean memberships for the mode consensus and the “direct” approach for alignment across <italic toggle="yes">K</italic> values appear in <xref rid="btad751-F1" ref-type="fig">Fig. 1</xref>.</p>
      <fig position="float" id="btad751-F1">
        <label>Figure 1.</label>
        <caption>
          <p><italic toggle="yes">Clumppling</italic>-aligned modes for the Cape Verde dataset (<italic toggle="yes">K</italic> from 2 to 5), using the mean memberships as mode consensus and the “direct” approach to alignment across <italic toggle="yes">K</italic> values. The multipartite graph shows the alignment across different <italic toggle="yes">K</italic>. Edges are colored by the edge weight [<xref rid="E18" ref-type="disp-formula">Equation (17)]</xref>; darker color indicates a larger weight and thus better alignment. The numbers on the edges are the optimal solutions for pairwise alignments, representing minimum values in <xref rid="E13" ref-type="disp-formula">Equation (12)</xref>. Each structure plot displays a mode, where the modes for the same <italic toggle="yes">K</italic> appear in decreasing order by their size—marked in parentheses above the top right corner of each plot—and then their within-mode similarity (if there is a tie in size).</p>
        </caption>
        <graphic xlink:href="btad751f1" position="float"/>
      </fig>
      <p>For the chicken dataset, for each <italic toggle="yes">K</italic>, alignments based on mean memberships for the mode consensus and the “direct” approach for alignment across <italic toggle="yes">K</italic> values appear in <xref rid="btad751-F2" ref-type="fig">Fig. 2</xref>. An additional analysis of alignments across non-consecutive <italic toggle="yes">K</italic> values appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>.</p>
      <fig position="float" id="btad751-F2">
        <label>Figure 2.</label>
        <caption>
          <p><italic toggle="yes">Clumppling</italic>-aligned modes for the chicken dataset (<italic toggle="yes">K</italic> from 17 to 21), using the mean memberships as mode consensus and the “direct” approach to alignment across <italic toggle="yes">K</italic> values. The figure design follows <xref rid="btad751-F1" ref-type="fig">Figure 1</xref>.</p>
        </caption>
        <graphic xlink:href="btad751f2" position="float"/>
      </fig>
      <p>For comparison, we ran <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>. <italic toggle="yes">Clumpak</italic> uses the <italic toggle="yes">LargeKGreedy</italic> algorithm of <italic toggle="yes">Clumpp</italic> to align replicates for fixed <italic toggle="yes">K</italic> values. In the MCL algorithm, it uses a threshold automatically generated from the graph properties to control inclusion of edges of the graph. It uses the <italic toggle="yes">Distruct for many K’s</italic> feature to align single results—major modes—for different <italic toggle="yes">K</italic> values. <italic toggle="yes">Clumpak</italic> alignment results appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>.</p>
      <p>We ran <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>) using its sum-squared distance metric for calculating the similarity between clusters; we chose the sum-squared distance rather than the Jaccard similarity in <italic toggle="yes">Pong</italic>, as it is closer to the objective used by <italic toggle="yes">Clumppling</italic>. A fixed threshold of 0.9 is chosen for the Cape Verde data and 0.955 for the chicken data to exclude edges with weights below the threshold from the pairwise similarity graph of replicates for mode detection. We chose these values to be lower than the <italic toggle="yes">Pong</italic> default of 0.97 in order to avoid producing large numbers of singleton modes. When identifying disjoint cliques in the graph of pairwise similarities for mode detection, we used the <italic toggle="yes">Pong</italic> default greedy approach to iteratively remove the maximal clique from the graph if no disjoint cliques are found. Alignment results for <italic toggle="yes">Pong</italic> appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>.</p>
      <p>For within-<italic toggle="yes">K</italic> alignments, the performance of <italic toggle="yes">Clumppling</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> appears for Cape Verde in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>; <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref> shows the numbers of replicates detected within modes by the three methods for the two datasets. <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S3</xref> and <xref rid="sup1" ref-type="supplementary-material">S4</xref> show corresponding results for the chicken dataset. For between-<italic toggle="yes">K</italic> alignments, <italic toggle="yes">Clumppling</italic> is evaluated in each of four combinations: using representative or average memberships, and using the “merge” and “direct” approaches to alignment. The performance of <italic toggle="yes">Clumppling</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> in across-<italic toggle="yes">K</italic> alignments for the Cape Verde dataset appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref> and for the chicken dataset in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>.</p>
    </sec>
    <sec>
      <title>4.4 Performance for within-<italic toggle="yes">K</italic> alignment</title>
      <p>In the Cape Verde dataset, for <inline-formula id="IE230"><mml:math id="IM230" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE231"><mml:math id="IM231" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, all three methods find a single mode (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>). No singletons are observed, and the singleton-excluded weighted similarity score <inline-formula id="IE232"><mml:math id="IM232" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> is 1 for all three methods (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). For <inline-formula id="IE233"><mml:math id="IM233" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, although <italic toggle="yes">Clumpak</italic> gives the largest score, this score discards 11 singletons. For <inline-formula id="IE234"><mml:math id="IM234" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Clumppling</italic> has the fewest modes and the largest within-mode similarity between replicates.</p>
      <p>In the chicken dataset, at different values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> achieves consistently greater values of the singleton-excluded similarity score (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>). It does so while finding no singleton modes; the other two methods both identify singletons at most values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>).</p>
    </sec>
    <sec>
      <title>4.5 Performance for across<italic toggle="yes">-K</italic> alignment</title>
      <p>In the Cape Verde dataset, across-<italic toggle="yes">K</italic> alignments have comparable performance for the various methods, with high similarity scores (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>). In the more challenging chicken dataset, with larger values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> produces the largest similarity scores between the most closely aligned pair of modes at consecutive values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>). The choice of the “representative” approach for mode consensus and the “merge” approach for cluster alignment gives the highest scores, but the three other choices all produce large values for the score as well. <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> achieve comparably high scores only in one of four transitions between <italic toggle="yes">K</italic> values (20–21 for <italic toggle="yes">Clumpak</italic>, 17–18 for <italic toggle="yes">Pong</italic>).</p>
    </sec>
    <sec>
      <title>4.6 Run time</title>
      <p>Run time with <italic toggle="yes">Clumppling</italic> (using the “direct” approach) is comparable to <italic toggle="yes">Pong</italic>; both are faster than <italic toggle="yes">Clumpak</italic>. In <italic toggle="yes">Clumppling</italic>, the “direct” approach is faster than the “merge” approach. A detailed comparison of the run time for the three methods appears in Supplementary Results and <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p><italic toggle="yes">Clumppling</italic> is a new method for aligning replicate mixed-membership unsupervised clustering analyses. Building upon <italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>), <italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>), and <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>), it performs alignment tasks that have not been addressed by earlier methods—alignment of all modes for one value of <italic toggle="yes">K</italic> with all modes of another value of <italic toggle="yes">K</italic>, and alignment of modes across nonconsecutive <italic toggle="yes">K</italic> values. <italic toggle="yes">Clumppling</italic> applies algorithms from combinatorial optimization and network theory in producing similar alignments to those obtained by the other methods (<xref rid="btad751-F1" ref-type="fig">Figs 1</xref> and <xref rid="btad751-F2" ref-type="fig">2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3–S5</xref>), often with higher values of a similarity score for replicates within modes at fixed <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1</xref> and <xref rid="sup1" ref-type="supplementary-material">S3</xref>) or modes at consecutive <italic toggle="yes">K</italic> values (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S5</xref> and <xref rid="sup1" ref-type="supplementary-material">S6</xref>), and in comparable or reduced computation time (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>). Thus, it compares favorably with other methods in terms of its novel features, algorithmic justification, performance measures, and run time.</p>
    <sec>
      <title>5.1 Algorithmic innovations</title>
      <p><italic toggle="yes">Clumppling</italic> introduces methodological advances for cluster alignment. Though <italic toggle="yes">Pong</italic> previously described the alignment problem as a standard combinatorial optimization problem, the <italic toggle="yes">Clumppling</italic> ILP formulation of the alignment of two replicates allows it to capitalize on efficiencies of ILP solvers. Hence, <italic toggle="yes">Clumppling</italic> is comparable in speed to <italic toggle="yes">Pong</italic>.</p>
      <p>The ILP formulation also enables <italic toggle="yes">Clumppling</italic> to address new scenarios not covered by <italic toggle="yes">Pong</italic>. In particular, the many-to-one matching that it permits for clustering replicates with different values of the number of clusters makes it possible for <italic toggle="yes">Clumppling</italic> to perform alignments across values of <italic toggle="yes">K</italic>, including across nonconsecutive values. Such alignments can be useful, e.g. in analyses for which <italic toggle="yes">K</italic> extends over a large range (<xref rid="btad751-B8" ref-type="bibr">Funk <italic toggle="yes">et al.</italic> 2020</xref>); for large datasets in which computation is slow, it may be sensible to perform exploratory clustering with select values of <italic toggle="yes">K</italic>—say, every fifth value—to then summarize with <italic toggle="yes">Clumppling</italic>, and only then, if necessary, to consider consecutive <italic toggle="yes">K</italic> in a meaningful range.</p>
      <p>Finally, combining the advance from <italic toggle="yes">Pong</italic> in formulating cluster alignment in terms of a classic setting in optimization with the advance from <italic toggle="yes">Clumpak</italic> of using community detection algorithms, <italic toggle="yes">Clumppling</italic> is able to perform a more comprehensive analysis of all observed modes. In particular, <italic toggle="yes">Clumppling</italic> aligns all modes across <italic toggle="yes">K</italic> values, rather than aligning only single modes at each <italic toggle="yes">K</italic> value, as in <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>. This alignment is informative to clarify clustering patterns in scenarios in which multimodality arises as <italic toggle="yes">K</italic> is increased but a major mode reappears as <italic toggle="yes">K</italic> is increased still further (e.g. Fig. 7 of <xref rid="btad751-B23" ref-type="bibr">Wang <italic toggle="yes">et al.</italic> 2007</xref>).</p>
      <p>The formalization of the cluster alignment problem here establishes a framework for further enhancement. By clarifying the components of the problem—pairwise alignment of replicates at fixed <italic toggle="yes">K</italic> (step 2a), mode detection at fixed <italic toggle="yes">K</italic> (step 2b), defining the consensus of modes (step 2c), and aligning modes across <italic toggle="yes">K</italic> (step 3)—each component can be separately investigated. Optimization methods other than the ILP branch-and-cut algorithm and network-based clustering methods other than the Louvain algorithm can be further tested for improvements in their associated steps.</p>
    </sec>
    <sec>
      <title>5.2 Empirical performance</title>
      <p>The performance differences in our empirical examples are relatively small. In the Cape Verde example, alignments were clear across the methods, all of which performed comparably (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1</xref>, <xref rid="sup1" ref-type="supplementary-material">S2</xref>, and <xref rid="sup1" ref-type="supplementary-material">S5</xref>). In our more difficult chicken example, <italic toggle="yes">Clumppling</italic> produced the highest value for the mean similarity of replicates within modes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>), identified the fewest singletons (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>), and produced the highest similarity scores between modes with consecutive values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>). In both cases, the modes themselves are similar across methods (<xref rid="btad751-F1" ref-type="fig">Fig. 1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3A, S4A, and S5A</xref> for Cape Verde, and <xref rid="btad751-F2" ref-type="fig">Fig. 2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3B, S4B, and S5B</xref> for chickens).</p>
      <p>Together, <italic toggle="yes">Clumpp</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> have been widely used, all performing well in typical empirical settings. When clustering algorithms uncover clear structure—e.g. with replicable co-clustering of some individuals in one cluster and other individuals in another—the proper alignment is often clear, and it is likely to be found by all methods. In a modeling study describing alignment cost under a Dirichlet model, we have found that a correct permutation often has cost far below that of the other permutations (<xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> 2022</xref>). <italic toggle="yes">Clumppling</italic> can be added to the list of methods that can be used to find this permutation.</p>
    </sec>
    <sec>
      <title>5.3 Methodological choices and extensions</title>
      <p>In developing <italic toggle="yes">Clumppling</italic>, we have made decisions about a number of methodological trade-offs. For the pairwise alignment step, <italic toggle="yes">Pong</italic> previously used the polynomial-time Hungarian algorithm for alignments at a fixed value of <italic toggle="yes">K</italic>. In <italic toggle="yes">Clumppling</italic>, we have chosen to use ILP, which is not polynomial-time and can be slower than the approach of <italic toggle="yes">Pong</italic>, though still faster than <italic toggle="yes">Clumpak</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>). However, ILP offers the ability to facilitate alignments across both consecutive and nonconsecutive values of <italic toggle="yes">K</italic>; <italic toggle="yes">Pong</italic> accommodates only consecutive values.</p>
      <p>For the alignment cost function, our framework allows any dissimilarity measure between replicates as the objective for the ILP problem—provided that it is a linear combination of pairwise between-cluster dissimilarities. Our specific quadratic function of entries in two membership matrices is grounded in the analysis of <xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> (2023)</xref>. In particular, if two replicates have the same number of clusters, then the dissimilarity that <italic toggle="yes">Clumppling</italic> seeks to minimize via ILP is exactly (a constant multiple of) the alignment cost from <xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> (2023)</xref>.</p>
      <p>Choices in community detection affect the granularity of the modes obtained. In one extreme, each replicate is its own mode; in the other, replicates with truly distinct co-clustering patterns are grouped in the same mode. <italic toggle="yes">Clumppling</italic> follows <italic toggle="yes">Clumpak</italic> in using an adaptable parameter for tuning this granularity. Nevertheless, it is possible that replicates visually distinguishable as belonging to distinct modes might be grouped. Such patterns can sometimes be diagnosed by the appearance of membership vectors that, within individual replicates, are near a permutation of <inline-formula id="IE235"><mml:math id="IM235" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, but that are not near a simplex vertex in the mean of replicates within the mode. In applications, users can increment the “resolution” parameter, e.g. by 0.05 or 0.01, choosing larger values to increase granularity and smaller values to decrease it.</p>
    </sec>
    <sec>
      <title>5.4 Conclusions</title>
      <p>With its formulation of the cluster alignment problem in defined steps, combination of pairwise alignment ideas based on <italic toggle="yes">Pong</italic> and community detection based on <italic toggle="yes">Clumpak</italic>, and addition of new features for mode alignment across values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> can assist in the many cluster alignments that take place in population-genetic data analysis. Notably, however, mixed-membership clustering, also sometimes known as soft or fuzzy clustering, has broad applications beyond population genetics, including elsewhere in bioinformatics, as well as in image analysis, marketing, and text mining (<xref rid="btad751-B6" ref-type="bibr">De Oliveira and Pedrycz 2007</xref>, <xref rid="btad751-B1" ref-type="bibr">Airoldi <italic toggle="yes">et al.</italic> 2014</xref>). Problems of comparing and visualizing multiple clustering results in a general context have perhaps been of greater interest for hard clustering (<xref rid="btad751-B14" ref-type="bibr">Meilă 2007</xref>, <xref rid="btad751-B25" ref-type="bibr">Zhou <italic toggle="yes">et al.</italic> 2009</xref>, <xref rid="btad751-B13" ref-type="bibr">L’Yi <italic toggle="yes">et al.</italic> 2015</xref>), in which memberships of individuals are assigned to single clusters. For similar problems of soft clustering, the methods from population genetics—<italic toggle="yes">Clumppling</italic> and its predecessors—are available. <italic toggle="yes">Clumppling</italic> can be applied to any membership-based clustering algorithms applied multiple times on the same set of entities, and it potentially has broad applications in diverse uses of mixed-membership cluster analysis.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad751_Supplementary_Data</label>
      <media xlink:href="btad751_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank D. Cotter, E. Lappo, M. Morrison, J. E. Rodríguez Rodríguez, and C. Shiff for assistance in testing the <italic toggle="yes">Clumppling</italic> software.</p>
  </ack>
  <sec>
    <title>Author contributions</title>
    <p>Xiran Liu (Conceptualization [equal], Investigation, Methodology, Software, Writing—original draft [lead], Writing—review &amp; editing [equal]), Naama M. Kopelman (Conceptualization, Writing—review &amp; editing [supporting]), Noah A. Rosenberg (Conceptualization [equal], Investigation, Methodology [supporting], Supervision [lead], Writing—original draft [supporting], Writing—review &amp; editing [equal])</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>We acknowledge National Institutes of Health grant R01 HG005855 and United States–Israel Binational Science Foundation grant 2017024.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The software is available as a python package at <ext-link xlink:href="https://github.com/PopGenClustering/Clumppling" ext-link-type="uri">https://github.com/PopGenClustering/Clumppling</ext-link>. The data underlying this article are available in its online <xref rid="sup1" ref-type="supplementary-material">supplementary material</xref>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad751-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Airoldi</surname><given-names>EM</given-names></string-name>, <string-name><surname>Blei</surname><given-names>D</given-names></string-name>, <string-name><surname>Erosheva</surname><given-names>EA</given-names></string-name></person-group><etal>et al</etal><source>Handbook of Mixed Membership Models and Their Applications</source>. <publisher-loc>Boca Raton, FL</publisher-loc>: <publisher-name>CRC Press</publisher-name>, <year>2014</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alexander</surname><given-names>DH</given-names></string-name>, <string-name><surname>Novembre</surname><given-names>J</given-names></string-name>, <string-name><surname>Lange</surname><given-names>K.</given-names></string-name></person-group><article-title>Fast model-based estimation of ancestry in unrelated individuals</article-title>. <source>Genome Res</source><year>2009</year>;<volume>19</volume>:<fpage>1655</fpage>–<lpage>64</lpage>.<pub-id pub-id-type="pmid">19648217</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Behr</surname><given-names>AA</given-names></string-name>, <string-name><surname>Liu</surname><given-names>KZ</given-names></string-name>, <string-name><surname>Liu-Fang</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Pong: fast analysis and visualization of latent clusters in population genetic data</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>2817</fpage>–<lpage>23</lpage>.<pub-id pub-id-type="pmid">27283948</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blondel</surname><given-names>VD</given-names></string-name>, <string-name><surname>Guillaume</surname><given-names>J-L</given-names></string-name>, <string-name><surname>Lambiotte</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Fast unfolding of communities in large networks</article-title>. <source>J Stat Mech</source><year>2008</year>;<volume>2008</volume>:<fpage>P10008</fpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Burkard</surname><given-names>R</given-names></string-name>, <string-name><surname>Dell’Amico</surname><given-names>M</given-names></string-name>, <string-name><surname>Martello</surname><given-names>S.</given-names></string-name></person-group><source>Assignment Problems</source>. <publisher-loc>Philadelphia</publisher-loc>: <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>, <year>2009</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>De Oliveira</surname><given-names>JV</given-names></string-name>, <string-name><surname>Pedrycz</surname><given-names>W.</given-names></string-name></person-group><source>Advances in Fuzzy Clustering and its Applications</source>. <publisher-loc>Chichester, United Kingdom</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>2007</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fortunato</surname><given-names>S.</given-names></string-name></person-group><article-title>Community detection in graphs</article-title>. <source>Phys Rep</source><year>2010</year>;<volume>486</volume>:<fpage>75</fpage>–<lpage>174</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Funk</surname><given-names>SM</given-names></string-name>, <string-name><surname>Guedaoura</surname><given-names>S</given-names></string-name>, <string-name><surname>Juras</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Major inconsistencies of inferred population genetic structure estimated in a large set of domestic horse breeds using microsatellites</article-title>. <source>Ecol Evol</source><year>2020</year>;<volume>10</volume>:<fpage>4261</fpage>–<lpage>79</lpage>.<pub-id pub-id-type="pmid">32489595</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title>Clumpp: a cluster matching and permutation program for dealing with label switching and multimodality in analysis of population structure</article-title>. <source>Bioinformatics</source><year>2007</year>;<volume>23</volume>:<fpage>1801</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">17485429</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Javed</surname><given-names>MA</given-names></string-name>, <string-name><surname>Younis</surname><given-names>MS</given-names></string-name>, <string-name><surname>Latif</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Community detection in networks: a multidisciplinary review</article-title>. <source>Journal of Network and Computer Applications</source><year>2018</year>;<volume>108</volume>:<fpage>87</fpage>–<lpage>111</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kopelman</surname><given-names>NM</given-names></string-name>, <string-name><surname>Mayzel</surname><given-names>J</given-names></string-name>, <string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Clumpak: a program for identifying clustering modes and packaging population structure inferences across <italic toggle="yes">K</italic></article-title>. <source>Mol Ecol Resour</source><year>2015</year>;<volume>15</volume>:<fpage>1179</fpage>–<lpage>91</lpage>.<pub-id pub-id-type="pmid">25684545</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>X</given-names></string-name>, <string-name><surname>Kopelman</surname><given-names>NM</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title>A dirichlet model of alignment cost in mixed-membership unsupervised clustering</article-title>. <source>J Comput Graph Stat</source><year>2023</year>;<volume>32</volume>:<fpage>1145</fpage>–<lpage>59</lpage>.<pub-id pub-id-type="pmid">37982130</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>L'Yi</surname><given-names>S</given-names></string-name>, <string-name><surname>Ko</surname><given-names>B</given-names></string-name>, <string-name><surname>Shin</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>XCluSim: a visual analytics tool for interactively comparing multiple clustering results of bioinformatics data</article-title>. <source>BMC Bioinform</source><year>2015</year>;<volume>16</volume>:<fpage>S5</fpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Meilă</surname><given-names>M.</given-names></string-name></person-group><article-title>Comparing clusterings—an information based distance</article-title>. <source>J Multivar Anal</source><year>2007</year>;<volume>98</volume>:<fpage>873</fpage>–<lpage>95</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mitchell</surname><given-names>J.</given-names></string-name></person-group><part-title>Branch-and-cut algorithms for combinatorial optimization problems</part-title>. in: Pardalos PM and Resende MGC (eds), <italic toggle="yes">Handbook of Applied Optimization</italic>. <publisher-loc>New York, NY, United States</publisher-loc>: <publisher-name>Oxford University Press</publisher-name>. pp. <fpage>65</fpage>-<lpage>77</lpage>, <year>2002</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pritchard</surname><given-names>JK</given-names></string-name>, <string-name><surname>Stephens</surname><given-names>M</given-names></string-name>, <string-name><surname>Donnelly</surname><given-names>P.</given-names></string-name></person-group><article-title>Inference of population structure using multilocus genotype data</article-title>. <source>Genetics</source><year>2000</year>;<volume>155</volume>:<fpage>945</fpage>–<lpage>59</lpage>.<pub-id pub-id-type="pmid">10835412</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title><italic toggle="yes">Distruct</italic>: a program for the graphical display of population structure</article-title>. <source>Mol Ecol Notes</source><year>2004</year>;<volume>4</volume>:<fpage>137</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosenberg</surname><given-names>NA</given-names></string-name>, <string-name><surname>Burke</surname><given-names>T</given-names></string-name>, <string-name><surname>Elo</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Empirical evaluation of genetic clustering methods using multilocus genotypes from 20 chicken breeds</article-title>. <source>Genetics</source><year>2001</year>;<volume>159</volume>:<fpage>699</fpage>–<lpage>713</lpage>.<pub-id pub-id-type="pmid">11606545</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Schrijver</surname><given-names>A.</given-names></string-name></person-group><source>Theory of Linear and Integer Programming</source>. <publisher-loc>Chichester, United Kingdom</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>1998</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tokuda</surname><given-names>T.</given-names></string-name></person-group><article-title>Statistical test for detecting community structure in real-valued edge-weighted graphs</article-title>. <source>PLoS One</source><year>2018</year>;<volume>13</volume>:<fpage>e0194079</fpage>.<pub-id pub-id-type="pmid">29558487</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B21">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Van Dongen</surname><given-names>SM.</given-names></string-name></person-group><year>2000</year>. Graph clustering by flow simulation. Ph.D. thesis, University of Utrecht.</mixed-citation>
    </ref>
    <ref id="btad751-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Verdu</surname><given-names>P</given-names></string-name>, <string-name><surname>Jewett</surname><given-names>EM</given-names></string-name>, <string-name><surname>Pemberton</surname><given-names>TJ</given-names></string-name></person-group><etal>et al</etal><article-title>Parallel trajectories of genetic and linguistic admixture in a genetically admixed creole population</article-title>. <source>Curr Biol</source><year>2017</year>;<volume>27</volume>:<fpage>2529</fpage>–<lpage>35.</lpage><pub-id pub-id-type="pmid">28803872</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>S</given-names></string-name>, <string-name><surname>Lewis</surname><given-names>CM</given-names><suffix>Jr</suffix></string-name>, <string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Genetic variation and population structure in native Americans</article-title>. <source>PLoS Genet</source><year>2007</year>;<volume>3</volume>:<fpage>e185</fpage>.<pub-id pub-id-type="pmid">18039031</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B24">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Wolsey</surname><given-names>LA.</given-names></string-name></person-group><source>Integer Programming</source>. <publisher-loc>Hoboken, NJ</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>2020</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname><given-names>J</given-names></string-name>, <string-name><surname>Konecni</surname><given-names>S</given-names></string-name>, <string-name><surname>Grinstein</surname><given-names>G.</given-names></string-name></person-group> Visually comparing multiple partitions of data with applications to clustering. In: <italic toggle="yes">Visualization and Data Analysis 2009</italic>, vol. <volume>7243</volume>, p. <fpage>157</fpage>–<lpage>168</lpage>. Bellingham, WA, United States: SPIE, <year>2009</year>.</mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10766593</article-id>
    <article-id pub-id-type="pmid">38096585</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad751</article-id>
    <article-id pub-id-type="publisher-id">btad751</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genetics and Population Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic toggle="yes">Clumppling</italic>: cluster matching and permutation program with integer linear programming</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-3955-9026</contrib-id>
        <name>
          <surname>Liu</surname>
          <given-names>Xiran</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="equal">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="lead">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="lead">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute for Computational and Mathematical Engineering, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <xref rid="btad751-cor1" ref-type="corresp"/>
        <!--xiranliu@stanford.edu-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kopelman</surname>
          <given-names>Naama M</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="supporting">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Faculty of Sciences, Holon Institute of Technology</institution>, Holon 58109, <country country="IL">Israel</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Rosenberg</surname>
          <given-names>Noah A</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="equal">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="supporting">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="supporting">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="lead">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="supporting">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute for Computational and Mathematical Engineering, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <aff><institution>Department of Biology, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <xref rid="btad751-cor1" ref-type="corresp"/>
        <!--noahr@stanford.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad751-cor1">Corresponding author. Stanford University, Stanford, CA 94305, United States. E-mail: <email>xiranliu@stanford.edu</email> (X.L.) and <email>noahr@stanford.edu</email> (N.A.R.) </corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2024</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-12-14">
      <day>14</day>
      <month>12</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>12</month>
      <year>2023</year>
    </pub-date>
    <volume>40</volume>
    <issue>1</issue>
    <elocation-id>btad751</elocation-id>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>11</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>09</day>
        <month>12</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>12</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>04</day>
        <month>1</month>
        <year>2024</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad751.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>In the mixed-membership unsupervised clustering analyses commonly used in population genetics, multiple replicate data analyses can differ in their clustering solutions. Combinatorial algorithms assist in aligning clustering outputs from multiple replicates so that clustering solutions can be interpreted and combined across replicates. Although several algorithms have been introduced, challenges exist in achieving optimal alignments and performing alignments in reasonable computation time.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present <italic toggle="yes">Clumppling</italic>, a method for aligning replicate solutions in mixed-membership unsupervised clustering. The method uses integer linear programming for finding optimal alignments, embedding the cluster alignment problem in standard combinatorial optimization frameworks. In example analyses, we find that it achieves solutions with preferred values of a desired objective function relative to those achieved by <italic toggle="yes">Pong</italic> and that it proceeds with less computation time than <italic toggle="yes">Clumpak</italic>. It is also the first method to permit alignments across replicates with multiple arbitrary values of the number of clusters <italic toggle="yes">K</italic>.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><italic toggle="yes">Clumppling</italic> is available at <ext-link xlink:href="https://github.com/PopGenClustering/Clumppling" ext-link-type="uri">https://github.com/PopGenClustering/Clumppling</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01 HG005855</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>United States–Israel Binational Science Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2017024</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="11"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Population-genetic mixed-membership unsupervised clustering methods, such as <italic toggle="yes">Structure</italic> (<xref rid="btad751-B16" ref-type="bibr">Pritchard <italic toggle="yes">et al.</italic> 2000</xref>) and <italic toggle="yes">Admixture</italic> (<xref rid="btad751-B2" ref-type="bibr">Alexander <italic toggle="yes">et al.</italic> 2009</xref>), are essential tools for understanding patterns of genetic variation in populations. These methods make use of individual genomes to infer population-genetic clusters; each individual is assigned a membership vector, in which each entry represents the inferred membership of the individual in a specific cluster.</p>
    <p>Mixed-membership unsupervised clustering typically employs stochastic steps so that output memberships from independent runs of a clustering approach on the same set of individuals can differ. Membership differences across replicate analyses with the same settings can result from one of two sources. One source is <italic toggle="yes">label-switching</italic>, in which the clusters and the patterns of co-clustering of individuals across clusters are identical between runs, but the clusters are ordered differently across runs. The second source is <italic toggle="yes">genuine multimodality</italic>, in which the clustering algorithm yields multiple local optima that represent different patterns of co-clustering of individuals. The clustering methods are often employed with different settings, most notably for the number of clusters, denoted <italic toggle="yes">K</italic>, so that membership estimates in different runs can differ for additional reasons. Because multiple potential sources contribute to clustering differences among replicates, in mixed-membership unsupervised clustering analysis, it is important to align the clusters across these replicates—to resolve label-switching, to assess genuine multimodality with fixed settings, and to examine clustering solutions with different values of <italic toggle="yes">K</italic>.</p>
    <p>Three main methods exist for resolving the cluster alignment across runs of population-genetic unsupervised clustering: <italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>), <italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>), and <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>). The methods differ slightly in the precise cluster alignment problems they solve, the algorithmic rationale for their alignment solutions, and their computational performance. Our goal is to introduce a new method that expands the set of scenarios in which cluster alignment can be performed, connects cluster alignment in population genetics to classic techniques of combinatorial optimization, and introduces computational improvements. The new method is <italic toggle="yes">Clumppling</italic>: <underline>CLU</underline>ster <underline>M</underline>atching and <underline>P</underline>ermutation <underline>P</underline>rogram with integer <underline>L</underline>inear programm<underline>ING</underline>.</p>
  </sec>
  <sec>
    <title>2 Review of existing approaches</title>
    <sec>
      <title>2.1 <italic toggle="yes">Clumpp</italic></title>
      <p><italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>) aligns replicates with equally many clusters. It either enumerates all possible permutations of clusters for all replicates and returns the one that maximizes an average pairwise similarity between all replicates, or adopts a greedy algorithm to sequentially align successive replicates. The greedy algorithm reduces computational time but does not necessarily find the optimal alignment. To further speed up the alignment process, <italic toggle="yes">Clumpp</italic> has a “LargeKGreedy” method to sequentially align a replicate column-wise rather than all at once.</p>
    </sec>
    <sec>
      <title>2.2 <italic toggle="yes">Clumpak</italic></title>
      <p><italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>) extends beyond <italic toggle="yes">Clumpp</italic> in two ways: algorithmic mode detection and algorithmic alignment of replicates with different numbers of clusters. First, it uses <italic toggle="yes">Clumpp</italic> to align replicates with the same <italic toggle="yes">K</italic>. It then detects modes by constructing a similarity network from pairs of aligned replicates and using the Markov clustering algorithm to define nearly identical groups of replicates in the network: modes. A mode is represented by the mean memberships of replicates in the mode.</p>
      <p>To assess replicates with different numbers of clusters, <italic toggle="yes">Clumpak</italic> examines the alignment of modes with <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters to those with <italic toggle="yes">K</italic> clusters. It aligns replicates with <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">K</italic> clusters by including an empty cluster and solving a one-to-one matching problem.</p>
    </sec>
    <sec>
      <title>2.3 <italic toggle="yes">Pong</italic></title>
      <p><italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>) views the problem of aligning pairs of replicates with equally many clusters as an <italic toggle="yes">assignment problem</italic> (<xref rid="btad751-B5" ref-type="bibr">Burkard <italic toggle="yes">et al.</italic> 2009</xref>). It uses the polynomial-time Hungarian algorithm for this optimization.</p>
      <p>For mode detection among replicates with a fixed number of clusters, <italic toggle="yes">Pong</italic> follows a simple approach. It constructs a similarity network of aligned replicates and uses a user-specified threshold to remove edges, taking the disjoint cliques in the network as modes. A representative replicate is then randomly chosen from each clique to represent the mode.</p>
      <p>To align a pair of representative replicates of the major modes with numbers of clusters <italic toggle="yes">K</italic> and <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Pong</italic> considers mergings of every possible pair of clusters from the replicate with <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters and finds the optimal alignment from all one-to-one alignments. It proceeds through consecutive <italic toggle="yes">K</italic> values to align major modes across different <italic toggle="yes">K</italic> values.</p>
    </sec>
    <sec>
      <title>2.4 Improvements provided by <italic toggle="yes">Clumppling</italic></title>
      <p>The existing methods have been used in thousands of studies. Nevertheless, opportunities exist for more fully integrating cluster alignment methods with frameworks of combinatorial optimization and network theory, for addressing complex alignment scenarios, and for improving computation time. We highlight several desirable features of <italic toggle="yes">Clumppling</italic> (<xref rid="btad751-T1" ref-type="table">Table 1</xref>):</p>
      <table-wrap position="float" id="btad751-T1">
        <label>Table 1.</label>
        <caption>
          <p>Features of cluster alignment methods: (1) <italic toggle="yes">Clumpp</italic>, (2) <italic toggle="yes">Clumpak</italic>, (3) <italic toggle="yes">Pong</italic>, and (4) <italic toggle="yes">Clumppling</italic>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Feature</th>
              <th rowspan="1" colspan="1">1</th>
              <th rowspan="1" colspan="1">2</th>
              <th rowspan="1" colspan="1">3</th>
              <th rowspan="1" colspan="1">4</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Aligns same-<italic toggle="yes">K</italic> replicates on the same set of individuals</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Pairwise alignment uses established optimization tools</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Detects modes among same-<italic toggle="yes">K</italic> replicates algorithmically</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Mode detection uses established network tools</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns major modes of <italic toggle="yes">K</italic> and <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns all modes of <italic toggle="yes">K</italic> and <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Mode alignment uses all replicates in a mode</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns modes of <italic toggle="yes">K</italic> and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <list list-type="order">
        <list-item>
          <p>Like <italic toggle="yes">Pong</italic>, <italic toggle="yes">Clumppling</italic> performs pairwise alignments using established algorithms from combinatorial optimization.</p>
        </list-item>
        <list-item>
          <p>Like <italic toggle="yes">Clumpak</italic>, <italic toggle="yes">Clumppling</italic> performs mode detection using established community detection algorithms from network theory.</p>
        </list-item>
        <list-item>
          <p>Unlike the other methods, <italic toggle="yes">Clumppling</italic> performs alignments between all modes at successive values of <italic toggle="yes">K</italic>, not only the major modes.</p>
        </list-item>
        <list-item>
          <p>Unlike the other methods, <italic toggle="yes">Clumppling</italic> performs alignments between replicates that differ in number of clusters by more than one.</p>
        </list-item>
      </list>
      <p><italic toggle="yes">Clumppling</italic> combines benefits of <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> in relying on ideas used for optimization and alignment in other fields. It performs alignments in the settings considered by <italic toggle="yes">Clumpp</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> and also expands to new settings.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Methods</title>
    <sec>
      <title>3.1 Overview</title>
      <p>In the application of mixed-membership unsupervised clustering, the first step is to obtain multiple clustering replicates at each of multiple values of the number of clusters <italic toggle="yes">K</italic>. Beginning from these replicates, the procedure of <italic toggle="yes">Clumppling</italic> to align replicates and to extract modes is as follows:</p>
      <list list-type="order">
        <list-item>
          <p>Group replicates according to the number of clusters <italic toggle="yes">K</italic>.</p>
        </list-item>
        <list-item>
          <p>For each group of replicates with a shared <italic toggle="yes">K</italic>:</p>
          <list list-type="alpha-lower">
            <list-item>
              <p>For each pair of replicates in the group, obtain an optimal alignment with minimal pairwise cost.</p>
            </list-item>
            <list-item>
              <p>Detect subgroups of replicates belonging to shared modes.</p>
            </list-item>
            <list-item>
              <p>Obtain the consensus membership of each mode.</p>
            </list-item>
          </list>
        </list-item>
        <list-item>
          <p>Align pairs of modes across different values of <italic toggle="yes">K</italic> using their consensus memberships.</p>
        </list-item>
        <list-item>
          <p>Visualize the aligned modes.</p>
        </list-item>
      </list>
      <p>This pipeline follows that of <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> (<italic toggle="yes">Clumpp</italic> does not perform steps 2b, 2c, or 3, and its step analogous to 2a does not involve finding all pairwise alignments). However, <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> address only a special case of step 3 in which pairs of modes to be aligned across <italic toggle="yes">K</italic> values are the major modes of replicates with <italic toggle="yes">K</italic> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters. <italic toggle="yes">Clumppling</italic> provides alignments between each pair of modes, major and minor, considering replicates that can have numbers of clusters that differ by more than one. This new step is informative on how major and minor modes relate across <italic toggle="yes">K</italic> values and can also assist in aggregating clustering results with large <italic toggle="yes">K</italic> in which nonconsecutive <italic toggle="yes">K</italic> values may be of interest.</p>
      <p>For steps 2a and 2b, the central steps of the alignment procedure, we seek to improve performance and run time over previous methods. First, for pairwise alignment of replicates in step 2a, we use integer linear programming (ILP) from optimization theory. Second, for community detection in step 2b, we use the Louvain algorithm from network theory.</p>
    </sec>
    <sec>
      <title>3.2 Initial setup: dissimilarity between replicates</title>
      <p>Consider two replicates from a clustering algorithm on <italic toggle="yes">N</italic> individuals. Replicate 1, with <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters, can be represented as a matrix <italic toggle="yes">Q</italic> of size <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Entry <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the inferred membership coefficient of individual <italic toggle="yes">i</italic> in cluster <italic toggle="yes">k</italic>. Replicate 2, with <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters, is a matrix <italic toggle="yes">P</italic> of size <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Without loss of generality, suppose <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>To align two replicates, we need a measure that quantifies the similarity or dissimilarity of matrices <italic toggle="yes">Q</italic> and <italic toggle="yes">P</italic>. The problem of aligning the replicates can then be formulated as a problem of maximizing the similarity, or minimizing the dissimilarity, between membership matrices, one of whose columns is rearranged according to various proposed alignments.</p>
      <p>For <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Clumpp</italic> uses a pairwise similarity between two membership matrices, defined with the Frobenius matrix norm <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>⋅</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p><italic toggle="yes">Clumpp</italic> seeks to find the optimal alignment of <italic toggle="yes">R</italic> replicates by maximizing a measure of mean pairwise similarity of the <italic toggle="yes">R</italic> replicates, termed <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Clumpak</italic> uses this same method for the case of <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p><xref rid="E1" ref-type="disp-formula">Equation (1)</xref> applies only to membership matrices of the same size. For <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, we can consider measures that decompose the calculation into two levels: similarity or dissimilarity first between clusters, one from one replicate and one from the other, and second, between replicates.</p>
      <p><italic toggle="yes">Pong</italic> uses this two-level idea to define the similarity between replicates. Let <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denote the membership coefficients in cluster <italic toggle="yes">i</italic> of replicate 1, with entries <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">i</italic>th column of matrix <italic toggle="yes">Q</italic>. Similarly, let <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denote the membership coefficients in cluster <italic toggle="yes">j</italic> of replicate 2. A cluster similarity is derived from the Jaccard index on the overlap in membership coefficients between clusters <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>}</mml:mo><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the set of rows with nonzero membership in cluster <italic toggle="yes">i</italic> of <italic toggle="yes">Q</italic>, cluster <italic toggle="yes">j</italic> of <italic toggle="yes">P</italic>, or both.</p>
      <p>The similarity between replicates is then defined as the mean cluster similarity across all clusters for a pair of replicates:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the cluster in <italic toggle="yes">P</italic> to which cluster <italic toggle="yes">i</italic> in <italic toggle="yes">Q</italic> aligns.</p>
      <p>If <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> and all entries of the membership matrices are nonzero, i.e. <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mi mathvariant="script">J</mml:mi></mml:math></inline-formula> has a form close to <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, though not quite equal to it. <xref rid="E1" ref-type="disp-formula">Equations (1)</xref> and <xref rid="E3" ref-type="disp-formula">(3)</xref> can be rewritten as follows:
<disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>K</mml:mi></mml:mfrac></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> ranges from 0 to 1. <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> trivially if <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if for all <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. In this case, <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for 2 <italic toggle="yes">N</italic> of the <italic toggle="yes">NK</italic> pairs <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>However, the similarity measure <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mi mathvariant="script">J</mml:mi></mml:math></inline-formula> used by <italic toggle="yes">Pong</italic> does not reach 0. Because <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>≤</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow><mml:mo>≤</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math></inline-formula>. Therefore, <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></inline-formula>.</p>
      <p>For <italic toggle="yes">Clumppling</italic>, we seek a dissimilarity measure for membership matrices that (1) permits <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and (2) spans the full unit interval [0, 1], with a value of 0 for matrices with no overlap and a value of 1 for identical memberships. We use a measure with the two-level composition of <italic toggle="yes">Pong</italic> but with a form more similar to that of <italic toggle="yes">Clumpp</italic> and <italic toggle="yes">Clumpak</italic>.</p>
      <p>For the dissimilarity between cluster <italic toggle="yes">i</italic> of replicate 1 and cluster <italic toggle="yes">j</italic> of replicate 2, <italic toggle="yes">Clumppling</italic> uses
<disp-formula id="E6"><label>(6)</label><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>For the dissimilarity between two replicates with <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, it uses
<disp-formula id="E7"><label>(7)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Continuing with <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, dissimilarity <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is related to similarity <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> [<xref rid="E1" ref-type="disp-formula">Equations (1)</xref> and <xref rid="E4" ref-type="disp-formula">(4)</xref>]:
<disp-formula id="E8"><label>(8)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>We will see shortly how to proceed if <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.3 Step 2a: pairwise alignment</title>
      <p>Given a dissimilarity measure, the alignment of two replicates involves permuting the clusters of one replicate—the columns of its associated matrix—to minimize the dissimilarity with the other replicate.</p>
      <p>If <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, then aligning two replicates is the problem of finding the optimal one-to-one permutation that minimizes <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the matrix <italic toggle="yes">P</italic> with columns permuted under a permutation <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> of <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Minimizing the dissimilarity is equivalent to maximizing the similarity, the problem considered by <italic toggle="yes">Clumpp</italic>.</p>
      <p>If <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then the alignment between two replicates involves a many-to-one mapping from <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> in general, denote the alignment by <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>—i.e. <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Each <italic toggle="yes">i</italic> is mapped to exactly one <italic toggle="yes">j</italic>, and each <italic toggle="yes">j</italic> is the image of at least one <italic toggle="yes">i</italic>. The dissimilarity between replicates with alignment <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> is a function of <italic toggle="yes">Q</italic>, <italic toggle="yes">P</italic>, and <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>:
<disp-formula id="E9"><label>(9)</label><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Note that if <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then we have
<disp-formula id="E10"><label>(10)</label><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>as for each <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> is bounded above by 2. The maximal dissimilarity satisfies <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>If <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, however, then the alignment is no longer one-to-one, and for a specific <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> can exceed 2. For instance, for <italic toggle="yes">Q</italic> with dimensions <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">P</italic> with dimensions <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, an individual <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> with <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and alignment mapping <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>. Hence, if <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then the maximal value of <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can exceed 1. Nevertheless, for a specific pair <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, a smaller value of <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> always indicates a closer alignment.</p>
      <p>The problem of finding the optimal alignment between a pair of replicates can then be formulated as computing <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mtext>arg</mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mo>α</mml:mo></mml:msub></mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Clumppling</italic> uses ILP to perform this optimization.</p>
      <p>Linear programming (LP) concerns the problem of maximizing or minimizing a linear objective function subject to linear equality and inequality constraints (<xref rid="btad751-B19" ref-type="bibr">Schrijver 1998</xref>). These constraints form a feasible region of a convex polyhedron for variables that are optimized. LP problems are represented in canonical form by <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> records the <italic toggle="yes">n</italic> variables to be optimized, <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:math></inline-formula> is the objective function (cost function) to be minimized, and <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> summarize the linear constraints.</p>
      <p>ILP problems have additional constraints that some variables are integers; in those dimensions, the feasible set for the variables is restricted to lattice points in the polyhedron. An ILP problem in which all variables must be integers can be represented in canonical form <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Although ILP problems are NP-complete (<xref rid="btad751-B19" ref-type="bibr">Schrijver 1998</xref>), we can capitalize on extensive effort devoted to solving them as standard problems in optimization theory.</p>
      <p>To formulate the pairwise alignment problem with ILP, we place dissimilarities <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> between pairs of clusters in two replicates in a <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> matrix <italic toggle="yes">C</italic>. Denote the alignment <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> as a <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> indicator matrix <italic toggle="yes">W</italic>, where
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>Because <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> is a many-to-one mapping, each row of <italic toggle="yes">W</italic> in constrained to sum to exactly 1, and each column of <italic toggle="yes">W</italic> has sum at least 1.</p>
      <p>The dissimilarity between two replicates in <xref rid="E9" ref-type="disp-formula">Equation (9)</xref> can be written as follows:
<disp-formula id="E12"><label>(11)</label><mml:math id="M12" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>The alignment problem can now be formulated with ILP:
<disp-formula id="E13"><label>  </label><mml:math id="M13" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mtext>arg </mml:mtext><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>W</mml:mi></mml:munder></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><disp-formula id="E13a"><label>(12)</label><mml:math id="M13a" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>subject to</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>In fact, this minimization is an instance of <italic toggle="yes">binary linear programming</italic> (<xref rid="btad751-B24" ref-type="bibr">Wolsey 2020</xref>), in which variables are restricted to zeros and ones. The canonical form of this ILP problem appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods</xref>. A pairwise alignment problem framed in this manner can then be solved by standard ILP methods. <italic toggle="yes">Clumppling</italic> uses the branch-and-cut algorithm (<xref rid="btad751-B15" ref-type="bibr">Mitchell 2002</xref>). The optimal solution <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">w</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> that minimizes the objective function corresponds to the optimal alignment under the chosen dissimilarity measure [<xref rid="E13" ref-type="disp-formula">Equation (12)</xref>, as reformulated in <xref rid="sup1" ref-type="supplementary-material">Supplementary Equation (1)</xref>].</p>
    </sec>
    <sec>
      <title>3.4 Step 2b: mode detection via community detection</title>
      <p>For all replicates with equally many clusters, an optimal alignment is obtained for each pair using ILP as described in the previous section. Suppose there are <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> replicates with <italic toggle="yes">K</italic> clusters, and their membership matrices are <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>. Between a pair of replicates <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, the optimal alignment of <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, extracted from the solution <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">w</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> to <xref rid="E13" ref-type="disp-formula">Equation (12)</xref> that gives the minimal dissimilarity <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>To align all replicates simultaneously, <italic toggle="yes">Clumppling</italic> constructs an undirected graph <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using replicates as nodes <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Edge set <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> has weights <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> negatively weighted by the normalized dissimilarity of optimal alignments: <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>, and for <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>,
<disp-formula id="E14"><label>(13)</label><mml:math id="M14" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A higher weight indicates greater similarity of two replicates under their optimal alignment. The <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> matrix of edge weights is symmetric.</p>
      <p>We seek to find sets of replicates that are collectively similar to one another when optimally aligned, or <italic toggle="yes">modes</italic>. For this task, we rely on community detection algorithms (<xref rid="btad751-B7" ref-type="bibr">Fortunato 2010</xref>, <xref rid="btad751-B10" ref-type="bibr">Javed <italic toggle="yes">et al.</italic> 2018</xref>). In a graph, communities are groups of nodes that are more densely connected within the group than outside the group. A community in the graph <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> corresponds to a mode in the unsupervised clustering analysis. In terms of the associated edge-weight matrix, a matrix with nontrivial communities has a block-diagonal structure, with two or more blocks corresponding to communities. Entries within a block tend to exceed entries outside it for the associated rows and columns—indicating greater edge weights for node pairs within the same community than for pairs not in the same community.</p>
      <p><italic toggle="yes">Clumppling</italic> first tests a null hypothesis of no community structure. We use a test of <xref rid="btad751-B20" ref-type="bibr">Tokuda (2018)</xref>, based on differences between (i) random symmetric matrices with a block-diagonal community structure in which within-block off-diagonal entries are distributed differently from outside-block off-diagonal entries, and (ii) random symmetric matrices in which all off-diagonal entries are independently and identically distributed. Considering the largest and smallest eigenvalues of two transformed versions of the symmetric edge-weight matrix of the graph, the null hypothesis is rejected if one or both eigenvalues (of either matrix) lies outside specified intervals. In our application, if the null hypothesis of no community structure is rejected at <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">Clumppling</italic> proceeds to identify community structure in the undirected weighted graph <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>For community detection, <italic toggle="yes">Clumpak</italic> uses Markov clustering (MCL) (<xref rid="btad751-B21" ref-type="bibr">Van Dongen 2000</xref>), employing a threshold to remove some edges with lower weights from the network—i.e. to replace smaller edge weights with values of 0—thereby reducing the density of edges. <italic toggle="yes">Clumppling</italic> instead uses the Louvain method (<xref rid="btad751-B4" ref-type="bibr">Blondel <italic toggle="yes">et al.</italic> 2008</xref>), which does not require premodification of the network. This algorithm has a “resolution” parameter that affects the size of the detected communities; larger values typically find smaller communities and more of them. <italic toggle="yes">Clumppling</italic> allows the user to specify its value, with a default of 1.</p>
      <p>The outcome of mode detection via community detection algorithms is a set of communities of nodes, each of which corresponds to a subset of replicates that belong to the same mode. Modes are disjoint so that replicate each belongs to exactly one mode. Suppose <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> communities are detected, which we denote <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow><mml:mo>∩</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula> for all distinct <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∪</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It is possible for a mode to possess only one replicate, <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, although this “singleton” situation is somewhat unusual.</p>
    </sec>
    <sec>
      <title>3.5 Step 2c: consensus memberships for modes</title>
      <p>For each mode <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, we obtain a consensus membership matrix in one of two ways. First, we obtain a <italic toggle="yes">mean</italic> membership matrix of its replicates:
<disp-formula id="E15"><label>(14)</label><mml:math id="M15" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where, for simplicity, the <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> are treated as having already been aligned.</p>
      <p>We also obtain a <italic toggle="yes">representative</italic> membership matrix, the matrix of the replicate that has the largest sum of edge weights within the community:
<disp-formula id="E16"><label>(15)</label><mml:math id="M16" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mtext>arg </mml:mtext><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Either <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> can be used as the consensus membership of replicates in the mode. <italic toggle="yes">Clumppling</italic> uses <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> as its default.</p>
      <p>Suppose the set of the distinct numbers of clusters is <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>. After building networks of replicates for each <italic toggle="yes">K</italic>, we obtain a set of modes together with consensus memberships:
<disp-formula id="E17"><label>(16)</label><mml:math id="M17" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">K</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    </sec>
    <sec>
      <title>3.6 Step 3: alignment of modes across <italic toggle="yes">K</italic></title>
      <p>Finally, with modes defined, we align modes across values of <italic toggle="yes">K</italic>. In particular, we order the values of <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">K</mml:mi></mml:mrow></mml:math></inline-formula> in decreasing order: <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mo>⋯</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. We then obtain a multipartite graph of the pairwise alignments between modes across different values of <italic toggle="yes">K</italic>.</p>
      <p>For adjacent <italic toggle="yes">K</italic> values in <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>, <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, there exist <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> pairs of modes. For each such pair, we use ILP [<xref rid="E13" ref-type="disp-formula">Equation (12)</xref>] to align consensus memberships from <xref rid="E17" ref-type="disp-formula">Equation (16)</xref>. The optimal dissimilarity is <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the mapping of clusters of <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> to clusters of <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> that produces the optimum.</p>
      <p>We then use these dissimilarities between modes as weights to create a bipartite graph between modes of <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and modes of <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. For instance, the weight between mode <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and mode <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> can be set to
<disp-formula id="E18"><label>(17)</label><mml:math id="M18" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where larger weights indicate closer alignments. Note that theoretically, the dissimilarity <italic toggle="yes">D</italic> can exceed 1 for a pair of modes with different numbers of clusters. However, such a situation requires pairs of clusters to be matched extremely poorly between different values of <italic toggle="yes">K</italic>, an unlikely scenario after optimal alignment. Hence, negative weights in <xref rid="E18" ref-type="disp-formula">Equation (17)</xref> are unlikely.</p>
      <p>Combining the bipartite graphs between pairs of adjacent values of <italic toggle="yes">K</italic>, we obtain a <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>-partite graph representing alignments across modes with different numbers of clusters. We call our approach to the alignment of modes across <italic toggle="yes">K</italic> the “direct” approach.</p>
      <p>For consecutive values of <italic toggle="yes">K</italic>, we also consider a second approach that modifies the method of <italic toggle="yes">Pong</italic>; we term this second approach the “merge” approach. This approach enumerates all possible ways to merge a pair of clusters from the mode with <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters to produce <italic toggle="yes">K</italic> clusters. It then uses our ILP method to align two matrices of the same size. A total of <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> alignments are performed, and the one that achieves the smallest dissimilarity is chosen to be the optimal alignment between the two modes. Note that unlike the “direct” approach, which permits nonconsecutive <italic toggle="yes">K</italic> values, the “merge” approach requires the values of <italic toggle="yes">K</italic> to be consecutive.</p>
    </sec>
    <sec>
      <title>3.7 Visualization</title>
      <p>To display all modes at all numbers of clusters, we proceed sequentially in the order <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, arranging values of <italic toggle="yes">K</italic> with <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mo>…</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Proceeding from <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, for each adjacent pair <inline-formula id="IE162"><mml:math id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (e.g. <inline-formula id="IE163"><mml:math id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">K</italic> if their numbers of clusters are consecutive), we choose the most closely aligned pair of modes between them as “anchors.” We then perform the following three steps:</p>
      <list list-type="order">
        <list-item>
          <p>All other modes with <inline-formula id="IE164"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters are aligned to the <inline-formula id="IE165"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> anchor.</p>
        </list-item>
        <list-item>
          <p>All other modes with <inline-formula id="IE166"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters are aligned to the <inline-formula id="IE167"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> anchor.</p>
        </list-item>
        <list-item>
          <p>The modes of these two different <italic toggle="yes">K</italic> values are then aligned according to the alignment of the <inline-formula id="IE168"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> anchor pair.</p>
        </list-item>
      </list>
      <p>For example, consider three numbers of clusters <inline-formula id="IE169"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, each with two modes. Suppose the most closely aligned mode pair for <inline-formula id="IE170"><mml:math id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is (<inline-formula id="IE171"><mml:math id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>, <inline-formula id="IE172"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>) and that for <inline-formula id="IE173"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it is (<inline-formula id="IE174"><mml:math id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>, <inline-formula id="IE175"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>). First, we align modes of <inline-formula id="IE176"><mml:math id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: (1) <inline-formula id="IE177"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub> is aligned to the anchor <inline-formula id="IE178"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>. (2) <inline-formula id="IE179"><mml:math id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> is aligned to the anchor <inline-formula id="IE180"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. (3) Clusters in modes of these two <italic toggle="yes">K</italic> values are rearranged according to the alignment between <inline-formula id="IE181"><mml:math id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> and <inline-formula id="IE182"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. Next, we align modes of <inline-formula id="IE183"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the same way: (1) <inline-formula id="IE184"><mml:math id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub> is aligned to the anchor <inline-formula id="IE185"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>—which was already accomplished in the previous step (1), as alignments between modes with the same <italic toggle="yes">K</italic> apply symmetrically. (2) <inline-formula id="IE186"><mml:math id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> is aligned to the anchor <inline-formula id="IE187"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. (3) Across modes of <inline-formula id="IE188"><mml:math id="IM188" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE189"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, the alignment follows that between <inline-formula id="IE190"><mml:math id="IM190" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> and <inline-formula id="IE191"><mml:math id="IM191" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. In this way, all modes across <inline-formula id="IE192"><mml:math id="IM192" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are aligned.</p>
      <p>For visualization of aligned modes, <italic toggle="yes">Clumppling</italic> plots each mode as a “classic” structure plot—a stacked bar chart of equal height—with clusters represented by different colors (e.g. <xref rid="btad751-B17" ref-type="bibr">Rosenberg 2004</xref>). The number of replicates in a mode is marked above the associated plot. To visualize relationships between modes with different numbers of clusters, modes appear in a multipartite graph according to the across-<italic toggle="yes">K</italic> alignment. Modes with the same <italic toggle="yes">K</italic> appear in the same “layer,” where the number of layers is <inline-formula id="IE193"><mml:math id="IM193" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>, the number of distinct <italic toggle="yes">K</italic> values considered. For each <italic toggle="yes">K</italic>, modes are ordered in decreasing size (i.e. the number of replicates in the mode) and decreasing within-mode similarity [described in <xref rid="E19" ref-type="disp-formula">Equation (18)</xref>]. Modes with adjacent <italic toggle="yes">K</italic> values are joined by edges colored based on the edge weight [<xref rid="E18" ref-type="disp-formula">Equation (17)</xref>], with darker colors indicating larger weights and closer alignments. Minimal dissimilarities between pairs of modes under their optimal alignment—i.e. the optimal objective function values from <xref rid="E13" ref-type="disp-formula">Equation (12)</xref>—appear as labels on the edges, with smaller values indicating closer alignments. To visualize the variability within a mode, in addition to the structure plot, <italic toggle="yes">Clumppling</italic> provides a histogram of pairwise dissimilarities under optimal alignment of replicates within modes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>4 Evaluation of performance</title>
    <p>The <italic toggle="yes">Clumppling</italic> implementation is described in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods</xref>. We compare the alignment performance of <italic toggle="yes">Clumppling</italic> to the two existing methods, <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>, that align replicates across <italic toggle="yes">K</italic> values. Because they only align equal or consecutive <italic toggle="yes">K</italic> values, the evaluation does so as well—although <italic toggle="yes">Clumppling</italic> accommodates replicates with numbers of clusters differing by more than 1.</p>
    <sec>
      <title>4.1 Performance measure</title>
      <p>For replicates with a shared <italic toggle="yes">K</italic>, we use a performance measure based on the similarity score <inline-formula id="IE194"><mml:math id="IM194" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">Clumpp</italic> and <italic toggle="yes">Clumpak</italic>. For a mode <inline-formula id="IE195"><mml:math id="IM195" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE196"><mml:math id="IM196" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> denote the mean similarity score for all pairs of replicates in the mode after its replicates <inline-formula id="IE197"><mml:math id="IM197" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are all aligned pairwise:
<disp-formula id="E19"><label>(18)</label><mml:math id="M19" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is interpreted as the mapping of clusters of <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> to clusters of <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for the optimal alignment of <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Next, to obtain a mean similarity score involving all replicates and modes, we calculate a weighted similarity score <inline-formula id="IE203"><mml:math id="IM203" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> that assigns each replicate the mean similarity score of its associated mode:
<disp-formula id="E20"><label>(19)</label><mml:math id="M20" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We modify <xref rid="E20" ref-type="disp-formula">Equation (19)</xref> to exclude singleton modes <inline-formula id="IE204"><mml:math id="IM204" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> with <inline-formula id="IE205"><mml:math id="IM205" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Because singletons always have similarity score 1 in <xref rid="E19" ref-type="disp-formula">Equation (18)</xref>, their existence can upwardly bias the weighted similarity score. With <inline-formula id="IE206"><mml:math id="IM206" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> singleton modes, the singleton-excluded weighted similarity score becomes
<disp-formula id="E21"><label>(20)</label><mml:math id="M21" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:munderover></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula></p>
      <p>Note that removal of the singletons reduces the number of replicates that need to be aligned; it is useful to track the value <inline-formula id="IE207"><mml:math id="IM207" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> along with <inline-formula id="IE208"><mml:math id="IM208" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Because we compare the performance of <italic toggle="yes">Clumppling</italic> with methods that only support the alignment of replicates with consecutive values of <italic toggle="yes">K</italic>, we use a performance measure suited to consecutive <italic toggle="yes">K</italic> values. To evaluate across-<italic toggle="yes">K</italic> alignments, we measure the <inline-formula id="IE209"><mml:math id="IM209" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> similarity [<xref rid="E1" ref-type="disp-formula">Equation (1)</xref>] between the most closely aligned pair of modes aligned across each <inline-formula id="IE210"><mml:math id="IM210" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For this computation, an optimal alignment <inline-formula id="IE211"><mml:math id="IM211" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> has first already been identified for this pair of modes in Section 3.6. Two of the clusters in the mode with <inline-formula id="IE212"><mml:math id="IM212" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters are necessarily matched to the same cluster in the mode with <italic toggle="yes">K</italic> clusters, or <inline-formula id="IE213"><mml:math id="IM213" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for exactly one unordered pair of <inline-formula id="IE214"><mml:math id="IM214" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE215"><mml:math id="IM215" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. We apply the alignment <inline-formula id="IE216"><mml:math id="IM216" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>: we merge these two clusters, adding their columns in the membership matrix together to produce a single column. Mathematically, suppose the original <inline-formula id="IE217"><mml:math id="IM217" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> membership matrix for the mode with <inline-formula id="IE218"><mml:math id="IM218" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters is <italic toggle="yes">P</italic>, with columns <inline-formula id="IE219"><mml:math id="IM219" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It now becomes a new <inline-formula id="IE220"><mml:math id="IM220" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> membership matrix <inline-formula id="IE221"><mml:math id="IM221" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> with columns
<disp-formula id="E22"><mml:math id="M22" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Now the two membership matrices, <italic toggle="yes">Q</italic> and <inline-formula id="IE222"><mml:math id="IM222" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, both have size <inline-formula id="IE223"><mml:math id="IM223" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE224"><mml:math id="IM224" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is computed for these two matrices.</p>
      <p>Note that because this similarity calculation merges clusters, it measures the similarity of a mode with <italic toggle="yes">K</italic> clusters and a mode with <inline-formula id="IE225"><mml:math id="IM225" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters according to its value for a quantity optimized by the “merge” and not the “direct” approach. Hence, it is expected to have higher values when the “merge” rather than the “direct” approach is used to produce the optimal alignment. Because <italic toggle="yes">Pong</italic> uses the “merge” approach to align modes with consecutive numbers of clusters, the calculation evaluates <italic toggle="yes">Clumppling</italic> against <italic toggle="yes">Pong</italic> by a measure that <italic toggle="yes">Pong</italic> seeks to optimize.</p>
      <p>We evaluate the performances of all four possible combinations of the mode consensus approach and the approach for performing alignments. That is, we use either “representative” [<xref rid="E15" ref-type="disp-formula">Equation (14)</xref>] or “average” [<xref rid="E16" ref-type="disp-formula">Equation (15)</xref>] as the consensus membership of a mode. For alignments of modes with <italic toggle="yes">K</italic> and <inline-formula id="IE226"><mml:math id="IM226" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters, we use either the “direct” approach or the “merge” approach in identifying the alignment with the minimal dissimilarity [<xref rid="E9" ref-type="disp-formula">Equation (9)</xref>].</p>
    </sec>
    <sec>
      <title>4.2 Datasets</title>
      <p>We demonstrate the use of <italic toggle="yes">Clumppling</italic> and compare the alignment performance of the methods with two datasets. The first contains an unsupervised <italic toggle="yes">Admixture</italic> analysis of 399 individuals focused on the human population of Cape Verde. This dataset has replicates with small values of <italic toggle="yes">K</italic>. It provides an example in which many individuals, including 44 individuals in the admixed population of Cape Verde (<xref rid="btad751-B22" ref-type="bibr">Verdu <italic toggle="yes">et al.</italic> 2017</xref>), possess nontrivial memberships in multiple clusters; the original analysis of <xref rid="btad751-B22" ref-type="bibr">Verdu <italic toggle="yes">et al.</italic> (2017)</xref> considered 50 replicates each at <inline-formula id="IE227"><mml:math id="IM227" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>; we reanalyzed those replicates. For this dataset, we ran <italic toggle="yes">Clumppling</italic> using the default resolution parameter of 1 for the Louvain mode detection.</p>
      <p>The second dataset provides an example of alignment with relatively large values of <italic toggle="yes">K</italic>: a study of 600 chickens from 20 populations (<xref rid="btad751-B18" ref-type="bibr">Rosenberg <italic toggle="yes">et al.</italic> 2001</xref>) focused on values of <inline-formula id="IE228"><mml:math id="IM228" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mn>18</mml:mn><mml:mo>,</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula>, and we add <inline-formula id="IE229"><mml:math id="IM229" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:mn>21</mml:mn></mml:mrow></mml:math></inline-formula> here (“chicken dataset”). We begin from the original data, 27 genotyped loci in each of the 600 individuals, running <italic toggle="yes">Structure</italic> (<xref rid="btad751-B16" ref-type="bibr">Pritchard <italic toggle="yes">et al.</italic> 2000</xref>) for 20 replicates for each <italic toggle="yes">K</italic> from 17 to 21. We ran <italic toggle="yes">Structure</italic> with a burn-in period of length 5000 in the “Admixture” model followed by 50000 MCMC repetitions, as in <xref rid="btad751-B18" ref-type="bibr">Rosenberg <italic toggle="yes">et al.</italic> (2001)</xref>. For mode detection in <italic toggle="yes">Clumppling</italic>, we used 1.05 for the resolution parameter; for this more challenging dataset, increasing the resolution above the default of 1 leads to a larger number of modes but with greater within-mode similarity.</p>
    </sec>
    <sec>
      <title>4.3 Analysis of clustering replicates</title>
      <p>For each value of <italic toggle="yes">K</italic>, we used <italic toggle="yes">Clumppling</italic> to align the 50 <italic toggle="yes">Admixture</italic> replicates for the Cape Verde dataset. Alignments based on mean memberships for the mode consensus and the “direct” approach for alignment across <italic toggle="yes">K</italic> values appear in <xref rid="btad751-F1" ref-type="fig">Fig. 1</xref>.</p>
      <fig position="float" id="btad751-F1">
        <label>Figure 1.</label>
        <caption>
          <p><italic toggle="yes">Clumppling</italic>-aligned modes for the Cape Verde dataset (<italic toggle="yes">K</italic> from 2 to 5), using the mean memberships as mode consensus and the “direct” approach to alignment across <italic toggle="yes">K</italic> values. The multipartite graph shows the alignment across different <italic toggle="yes">K</italic>. Edges are colored by the edge weight [<xref rid="E18" ref-type="disp-formula">Equation (17)]</xref>; darker color indicates a larger weight and thus better alignment. The numbers on the edges are the optimal solutions for pairwise alignments, representing minimum values in <xref rid="E13" ref-type="disp-formula">Equation (12)</xref>. Each structure plot displays a mode, where the modes for the same <italic toggle="yes">K</italic> appear in decreasing order by their size—marked in parentheses above the top right corner of each plot—and then their within-mode similarity (if there is a tie in size).</p>
        </caption>
        <graphic xlink:href="btad751f1" position="float"/>
      </fig>
      <p>For the chicken dataset, for each <italic toggle="yes">K</italic>, alignments based on mean memberships for the mode consensus and the “direct” approach for alignment across <italic toggle="yes">K</italic> values appear in <xref rid="btad751-F2" ref-type="fig">Fig. 2</xref>. An additional analysis of alignments across non-consecutive <italic toggle="yes">K</italic> values appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>.</p>
      <fig position="float" id="btad751-F2">
        <label>Figure 2.</label>
        <caption>
          <p><italic toggle="yes">Clumppling</italic>-aligned modes for the chicken dataset (<italic toggle="yes">K</italic> from 17 to 21), using the mean memberships as mode consensus and the “direct” approach to alignment across <italic toggle="yes">K</italic> values. The figure design follows <xref rid="btad751-F1" ref-type="fig">Figure 1</xref>.</p>
        </caption>
        <graphic xlink:href="btad751f2" position="float"/>
      </fig>
      <p>For comparison, we ran <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>. <italic toggle="yes">Clumpak</italic> uses the <italic toggle="yes">LargeKGreedy</italic> algorithm of <italic toggle="yes">Clumpp</italic> to align replicates for fixed <italic toggle="yes">K</italic> values. In the MCL algorithm, it uses a threshold automatically generated from the graph properties to control inclusion of edges of the graph. It uses the <italic toggle="yes">Distruct for many K’s</italic> feature to align single results—major modes—for different <italic toggle="yes">K</italic> values. <italic toggle="yes">Clumpak</italic> alignment results appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>.</p>
      <p>We ran <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>) using its sum-squared distance metric for calculating the similarity between clusters; we chose the sum-squared distance rather than the Jaccard similarity in <italic toggle="yes">Pong</italic>, as it is closer to the objective used by <italic toggle="yes">Clumppling</italic>. A fixed threshold of 0.9 is chosen for the Cape Verde data and 0.955 for the chicken data to exclude edges with weights below the threshold from the pairwise similarity graph of replicates for mode detection. We chose these values to be lower than the <italic toggle="yes">Pong</italic> default of 0.97 in order to avoid producing large numbers of singleton modes. When identifying disjoint cliques in the graph of pairwise similarities for mode detection, we used the <italic toggle="yes">Pong</italic> default greedy approach to iteratively remove the maximal clique from the graph if no disjoint cliques are found. Alignment results for <italic toggle="yes">Pong</italic> appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>.</p>
      <p>For within-<italic toggle="yes">K</italic> alignments, the performance of <italic toggle="yes">Clumppling</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> appears for Cape Verde in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>; <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref> shows the numbers of replicates detected within modes by the three methods for the two datasets. <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S3</xref> and <xref rid="sup1" ref-type="supplementary-material">S4</xref> show corresponding results for the chicken dataset. For between-<italic toggle="yes">K</italic> alignments, <italic toggle="yes">Clumppling</italic> is evaluated in each of four combinations: using representative or average memberships, and using the “merge” and “direct” approaches to alignment. The performance of <italic toggle="yes">Clumppling</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> in across-<italic toggle="yes">K</italic> alignments for the Cape Verde dataset appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref> and for the chicken dataset in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>.</p>
    </sec>
    <sec>
      <title>4.4 Performance for within-<italic toggle="yes">K</italic> alignment</title>
      <p>In the Cape Verde dataset, for <inline-formula id="IE230"><mml:math id="IM230" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE231"><mml:math id="IM231" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, all three methods find a single mode (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>). No singletons are observed, and the singleton-excluded weighted similarity score <inline-formula id="IE232"><mml:math id="IM232" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> is 1 for all three methods (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). For <inline-formula id="IE233"><mml:math id="IM233" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, although <italic toggle="yes">Clumpak</italic> gives the largest score, this score discards 11 singletons. For <inline-formula id="IE234"><mml:math id="IM234" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Clumppling</italic> has the fewest modes and the largest within-mode similarity between replicates.</p>
      <p>In the chicken dataset, at different values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> achieves consistently greater values of the singleton-excluded similarity score (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>). It does so while finding no singleton modes; the other two methods both identify singletons at most values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>).</p>
    </sec>
    <sec>
      <title>4.5 Performance for across<italic toggle="yes">-K</italic> alignment</title>
      <p>In the Cape Verde dataset, across-<italic toggle="yes">K</italic> alignments have comparable performance for the various methods, with high similarity scores (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>). In the more challenging chicken dataset, with larger values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> produces the largest similarity scores between the most closely aligned pair of modes at consecutive values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>). The choice of the “representative” approach for mode consensus and the “merge” approach for cluster alignment gives the highest scores, but the three other choices all produce large values for the score as well. <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> achieve comparably high scores only in one of four transitions between <italic toggle="yes">K</italic> values (20–21 for <italic toggle="yes">Clumpak</italic>, 17–18 for <italic toggle="yes">Pong</italic>).</p>
    </sec>
    <sec>
      <title>4.6 Run time</title>
      <p>Run time with <italic toggle="yes">Clumppling</italic> (using the “direct” approach) is comparable to <italic toggle="yes">Pong</italic>; both are faster than <italic toggle="yes">Clumpak</italic>. In <italic toggle="yes">Clumppling</italic>, the “direct” approach is faster than the “merge” approach. A detailed comparison of the run time for the three methods appears in Supplementary Results and <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p><italic toggle="yes">Clumppling</italic> is a new method for aligning replicate mixed-membership unsupervised clustering analyses. Building upon <italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>), <italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>), and <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>), it performs alignment tasks that have not been addressed by earlier methods—alignment of all modes for one value of <italic toggle="yes">K</italic> with all modes of another value of <italic toggle="yes">K</italic>, and alignment of modes across nonconsecutive <italic toggle="yes">K</italic> values. <italic toggle="yes">Clumppling</italic> applies algorithms from combinatorial optimization and network theory in producing similar alignments to those obtained by the other methods (<xref rid="btad751-F1" ref-type="fig">Figs 1</xref> and <xref rid="btad751-F2" ref-type="fig">2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3–S5</xref>), often with higher values of a similarity score for replicates within modes at fixed <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1</xref> and <xref rid="sup1" ref-type="supplementary-material">S3</xref>) or modes at consecutive <italic toggle="yes">K</italic> values (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S5</xref> and <xref rid="sup1" ref-type="supplementary-material">S6</xref>), and in comparable or reduced computation time (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>). Thus, it compares favorably with other methods in terms of its novel features, algorithmic justification, performance measures, and run time.</p>
    <sec>
      <title>5.1 Algorithmic innovations</title>
      <p><italic toggle="yes">Clumppling</italic> introduces methodological advances for cluster alignment. Though <italic toggle="yes">Pong</italic> previously described the alignment problem as a standard combinatorial optimization problem, the <italic toggle="yes">Clumppling</italic> ILP formulation of the alignment of two replicates allows it to capitalize on efficiencies of ILP solvers. Hence, <italic toggle="yes">Clumppling</italic> is comparable in speed to <italic toggle="yes">Pong</italic>.</p>
      <p>The ILP formulation also enables <italic toggle="yes">Clumppling</italic> to address new scenarios not covered by <italic toggle="yes">Pong</italic>. In particular, the many-to-one matching that it permits for clustering replicates with different values of the number of clusters makes it possible for <italic toggle="yes">Clumppling</italic> to perform alignments across values of <italic toggle="yes">K</italic>, including across nonconsecutive values. Such alignments can be useful, e.g. in analyses for which <italic toggle="yes">K</italic> extends over a large range (<xref rid="btad751-B8" ref-type="bibr">Funk <italic toggle="yes">et al.</italic> 2020</xref>); for large datasets in which computation is slow, it may be sensible to perform exploratory clustering with select values of <italic toggle="yes">K</italic>—say, every fifth value—to then summarize with <italic toggle="yes">Clumppling</italic>, and only then, if necessary, to consider consecutive <italic toggle="yes">K</italic> in a meaningful range.</p>
      <p>Finally, combining the advance from <italic toggle="yes">Pong</italic> in formulating cluster alignment in terms of a classic setting in optimization with the advance from <italic toggle="yes">Clumpak</italic> of using community detection algorithms, <italic toggle="yes">Clumppling</italic> is able to perform a more comprehensive analysis of all observed modes. In particular, <italic toggle="yes">Clumppling</italic> aligns all modes across <italic toggle="yes">K</italic> values, rather than aligning only single modes at each <italic toggle="yes">K</italic> value, as in <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>. This alignment is informative to clarify clustering patterns in scenarios in which multimodality arises as <italic toggle="yes">K</italic> is increased but a major mode reappears as <italic toggle="yes">K</italic> is increased still further (e.g. Fig. 7 of <xref rid="btad751-B23" ref-type="bibr">Wang <italic toggle="yes">et al.</italic> 2007</xref>).</p>
      <p>The formalization of the cluster alignment problem here establishes a framework for further enhancement. By clarifying the components of the problem—pairwise alignment of replicates at fixed <italic toggle="yes">K</italic> (step 2a), mode detection at fixed <italic toggle="yes">K</italic> (step 2b), defining the consensus of modes (step 2c), and aligning modes across <italic toggle="yes">K</italic> (step 3)—each component can be separately investigated. Optimization methods other than the ILP branch-and-cut algorithm and network-based clustering methods other than the Louvain algorithm can be further tested for improvements in their associated steps.</p>
    </sec>
    <sec>
      <title>5.2 Empirical performance</title>
      <p>The performance differences in our empirical examples are relatively small. In the Cape Verde example, alignments were clear across the methods, all of which performed comparably (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1</xref>, <xref rid="sup1" ref-type="supplementary-material">S2</xref>, and <xref rid="sup1" ref-type="supplementary-material">S5</xref>). In our more difficult chicken example, <italic toggle="yes">Clumppling</italic> produced the highest value for the mean similarity of replicates within modes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>), identified the fewest singletons (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>), and produced the highest similarity scores between modes with consecutive values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>). In both cases, the modes themselves are similar across methods (<xref rid="btad751-F1" ref-type="fig">Fig. 1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3A, S4A, and S5A</xref> for Cape Verde, and <xref rid="btad751-F2" ref-type="fig">Fig. 2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3B, S4B, and S5B</xref> for chickens).</p>
      <p>Together, <italic toggle="yes">Clumpp</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> have been widely used, all performing well in typical empirical settings. When clustering algorithms uncover clear structure—e.g. with replicable co-clustering of some individuals in one cluster and other individuals in another—the proper alignment is often clear, and it is likely to be found by all methods. In a modeling study describing alignment cost under a Dirichlet model, we have found that a correct permutation often has cost far below that of the other permutations (<xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> 2022</xref>). <italic toggle="yes">Clumppling</italic> can be added to the list of methods that can be used to find this permutation.</p>
    </sec>
    <sec>
      <title>5.3 Methodological choices and extensions</title>
      <p>In developing <italic toggle="yes">Clumppling</italic>, we have made decisions about a number of methodological trade-offs. For the pairwise alignment step, <italic toggle="yes">Pong</italic> previously used the polynomial-time Hungarian algorithm for alignments at a fixed value of <italic toggle="yes">K</italic>. In <italic toggle="yes">Clumppling</italic>, we have chosen to use ILP, which is not polynomial-time and can be slower than the approach of <italic toggle="yes">Pong</italic>, though still faster than <italic toggle="yes">Clumpak</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>). However, ILP offers the ability to facilitate alignments across both consecutive and nonconsecutive values of <italic toggle="yes">K</italic>; <italic toggle="yes">Pong</italic> accommodates only consecutive values.</p>
      <p>For the alignment cost function, our framework allows any dissimilarity measure between replicates as the objective for the ILP problem—provided that it is a linear combination of pairwise between-cluster dissimilarities. Our specific quadratic function of entries in two membership matrices is grounded in the analysis of <xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> (2023)</xref>. In particular, if two replicates have the same number of clusters, then the dissimilarity that <italic toggle="yes">Clumppling</italic> seeks to minimize via ILP is exactly (a constant multiple of) the alignment cost from <xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> (2023)</xref>.</p>
      <p>Choices in community detection affect the granularity of the modes obtained. In one extreme, each replicate is its own mode; in the other, replicates with truly distinct co-clustering patterns are grouped in the same mode. <italic toggle="yes">Clumppling</italic> follows <italic toggle="yes">Clumpak</italic> in using an adaptable parameter for tuning this granularity. Nevertheless, it is possible that replicates visually distinguishable as belonging to distinct modes might be grouped. Such patterns can sometimes be diagnosed by the appearance of membership vectors that, within individual replicates, are near a permutation of <inline-formula id="IE235"><mml:math id="IM235" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, but that are not near a simplex vertex in the mean of replicates within the mode. In applications, users can increment the “resolution” parameter, e.g. by 0.05 or 0.01, choosing larger values to increase granularity and smaller values to decrease it.</p>
    </sec>
    <sec>
      <title>5.4 Conclusions</title>
      <p>With its formulation of the cluster alignment problem in defined steps, combination of pairwise alignment ideas based on <italic toggle="yes">Pong</italic> and community detection based on <italic toggle="yes">Clumpak</italic>, and addition of new features for mode alignment across values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> can assist in the many cluster alignments that take place in population-genetic data analysis. Notably, however, mixed-membership clustering, also sometimes known as soft or fuzzy clustering, has broad applications beyond population genetics, including elsewhere in bioinformatics, as well as in image analysis, marketing, and text mining (<xref rid="btad751-B6" ref-type="bibr">De Oliveira and Pedrycz 2007</xref>, <xref rid="btad751-B1" ref-type="bibr">Airoldi <italic toggle="yes">et al.</italic> 2014</xref>). Problems of comparing and visualizing multiple clustering results in a general context have perhaps been of greater interest for hard clustering (<xref rid="btad751-B14" ref-type="bibr">Meilă 2007</xref>, <xref rid="btad751-B25" ref-type="bibr">Zhou <italic toggle="yes">et al.</italic> 2009</xref>, <xref rid="btad751-B13" ref-type="bibr">L’Yi <italic toggle="yes">et al.</italic> 2015</xref>), in which memberships of individuals are assigned to single clusters. For similar problems of soft clustering, the methods from population genetics—<italic toggle="yes">Clumppling</italic> and its predecessors—are available. <italic toggle="yes">Clumppling</italic> can be applied to any membership-based clustering algorithms applied multiple times on the same set of entities, and it potentially has broad applications in diverse uses of mixed-membership cluster analysis.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad751_Supplementary_Data</label>
      <media xlink:href="btad751_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank D. Cotter, E. Lappo, M. Morrison, J. E. Rodríguez Rodríguez, and C. Shiff for assistance in testing the <italic toggle="yes">Clumppling</italic> software.</p>
  </ack>
  <sec>
    <title>Author contributions</title>
    <p>Xiran Liu (Conceptualization [equal], Investigation, Methodology, Software, Writing—original draft [lead], Writing—review &amp; editing [equal]), Naama M. Kopelman (Conceptualization, Writing—review &amp; editing [supporting]), Noah A. Rosenberg (Conceptualization [equal], Investigation, Methodology [supporting], Supervision [lead], Writing—original draft [supporting], Writing—review &amp; editing [equal])</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>We acknowledge National Institutes of Health grant R01 HG005855 and United States–Israel Binational Science Foundation grant 2017024.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The software is available as a python package at <ext-link xlink:href="https://github.com/PopGenClustering/Clumppling" ext-link-type="uri">https://github.com/PopGenClustering/Clumppling</ext-link>. The data underlying this article are available in its online <xref rid="sup1" ref-type="supplementary-material">supplementary material</xref>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad751-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Airoldi</surname><given-names>EM</given-names></string-name>, <string-name><surname>Blei</surname><given-names>D</given-names></string-name>, <string-name><surname>Erosheva</surname><given-names>EA</given-names></string-name></person-group><etal>et al</etal><source>Handbook of Mixed Membership Models and Their Applications</source>. <publisher-loc>Boca Raton, FL</publisher-loc>: <publisher-name>CRC Press</publisher-name>, <year>2014</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alexander</surname><given-names>DH</given-names></string-name>, <string-name><surname>Novembre</surname><given-names>J</given-names></string-name>, <string-name><surname>Lange</surname><given-names>K.</given-names></string-name></person-group><article-title>Fast model-based estimation of ancestry in unrelated individuals</article-title>. <source>Genome Res</source><year>2009</year>;<volume>19</volume>:<fpage>1655</fpage>–<lpage>64</lpage>.<pub-id pub-id-type="pmid">19648217</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Behr</surname><given-names>AA</given-names></string-name>, <string-name><surname>Liu</surname><given-names>KZ</given-names></string-name>, <string-name><surname>Liu-Fang</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Pong: fast analysis and visualization of latent clusters in population genetic data</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>2817</fpage>–<lpage>23</lpage>.<pub-id pub-id-type="pmid">27283948</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blondel</surname><given-names>VD</given-names></string-name>, <string-name><surname>Guillaume</surname><given-names>J-L</given-names></string-name>, <string-name><surname>Lambiotte</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Fast unfolding of communities in large networks</article-title>. <source>J Stat Mech</source><year>2008</year>;<volume>2008</volume>:<fpage>P10008</fpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Burkard</surname><given-names>R</given-names></string-name>, <string-name><surname>Dell’Amico</surname><given-names>M</given-names></string-name>, <string-name><surname>Martello</surname><given-names>S.</given-names></string-name></person-group><source>Assignment Problems</source>. <publisher-loc>Philadelphia</publisher-loc>: <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>, <year>2009</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>De Oliveira</surname><given-names>JV</given-names></string-name>, <string-name><surname>Pedrycz</surname><given-names>W.</given-names></string-name></person-group><source>Advances in Fuzzy Clustering and its Applications</source>. <publisher-loc>Chichester, United Kingdom</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>2007</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fortunato</surname><given-names>S.</given-names></string-name></person-group><article-title>Community detection in graphs</article-title>. <source>Phys Rep</source><year>2010</year>;<volume>486</volume>:<fpage>75</fpage>–<lpage>174</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Funk</surname><given-names>SM</given-names></string-name>, <string-name><surname>Guedaoura</surname><given-names>S</given-names></string-name>, <string-name><surname>Juras</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Major inconsistencies of inferred population genetic structure estimated in a large set of domestic horse breeds using microsatellites</article-title>. <source>Ecol Evol</source><year>2020</year>;<volume>10</volume>:<fpage>4261</fpage>–<lpage>79</lpage>.<pub-id pub-id-type="pmid">32489595</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title>Clumpp: a cluster matching and permutation program for dealing with label switching and multimodality in analysis of population structure</article-title>. <source>Bioinformatics</source><year>2007</year>;<volume>23</volume>:<fpage>1801</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">17485429</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Javed</surname><given-names>MA</given-names></string-name>, <string-name><surname>Younis</surname><given-names>MS</given-names></string-name>, <string-name><surname>Latif</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Community detection in networks: a multidisciplinary review</article-title>. <source>Journal of Network and Computer Applications</source><year>2018</year>;<volume>108</volume>:<fpage>87</fpage>–<lpage>111</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kopelman</surname><given-names>NM</given-names></string-name>, <string-name><surname>Mayzel</surname><given-names>J</given-names></string-name>, <string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Clumpak: a program for identifying clustering modes and packaging population structure inferences across <italic toggle="yes">K</italic></article-title>. <source>Mol Ecol Resour</source><year>2015</year>;<volume>15</volume>:<fpage>1179</fpage>–<lpage>91</lpage>.<pub-id pub-id-type="pmid">25684545</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>X</given-names></string-name>, <string-name><surname>Kopelman</surname><given-names>NM</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title>A dirichlet model of alignment cost in mixed-membership unsupervised clustering</article-title>. <source>J Comput Graph Stat</source><year>2023</year>;<volume>32</volume>:<fpage>1145</fpage>–<lpage>59</lpage>.<pub-id pub-id-type="pmid">37982130</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>L'Yi</surname><given-names>S</given-names></string-name>, <string-name><surname>Ko</surname><given-names>B</given-names></string-name>, <string-name><surname>Shin</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>XCluSim: a visual analytics tool for interactively comparing multiple clustering results of bioinformatics data</article-title>. <source>BMC Bioinform</source><year>2015</year>;<volume>16</volume>:<fpage>S5</fpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Meilă</surname><given-names>M.</given-names></string-name></person-group><article-title>Comparing clusterings—an information based distance</article-title>. <source>J Multivar Anal</source><year>2007</year>;<volume>98</volume>:<fpage>873</fpage>–<lpage>95</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mitchell</surname><given-names>J.</given-names></string-name></person-group><part-title>Branch-and-cut algorithms for combinatorial optimization problems</part-title>. in: Pardalos PM and Resende MGC (eds), <italic toggle="yes">Handbook of Applied Optimization</italic>. <publisher-loc>New York, NY, United States</publisher-loc>: <publisher-name>Oxford University Press</publisher-name>. pp. <fpage>65</fpage>-<lpage>77</lpage>, <year>2002</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pritchard</surname><given-names>JK</given-names></string-name>, <string-name><surname>Stephens</surname><given-names>M</given-names></string-name>, <string-name><surname>Donnelly</surname><given-names>P.</given-names></string-name></person-group><article-title>Inference of population structure using multilocus genotype data</article-title>. <source>Genetics</source><year>2000</year>;<volume>155</volume>:<fpage>945</fpage>–<lpage>59</lpage>.<pub-id pub-id-type="pmid">10835412</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title><italic toggle="yes">Distruct</italic>: a program for the graphical display of population structure</article-title>. <source>Mol Ecol Notes</source><year>2004</year>;<volume>4</volume>:<fpage>137</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosenberg</surname><given-names>NA</given-names></string-name>, <string-name><surname>Burke</surname><given-names>T</given-names></string-name>, <string-name><surname>Elo</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Empirical evaluation of genetic clustering methods using multilocus genotypes from 20 chicken breeds</article-title>. <source>Genetics</source><year>2001</year>;<volume>159</volume>:<fpage>699</fpage>–<lpage>713</lpage>.<pub-id pub-id-type="pmid">11606545</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Schrijver</surname><given-names>A.</given-names></string-name></person-group><source>Theory of Linear and Integer Programming</source>. <publisher-loc>Chichester, United Kingdom</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>1998</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tokuda</surname><given-names>T.</given-names></string-name></person-group><article-title>Statistical test for detecting community structure in real-valued edge-weighted graphs</article-title>. <source>PLoS One</source><year>2018</year>;<volume>13</volume>:<fpage>e0194079</fpage>.<pub-id pub-id-type="pmid">29558487</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B21">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Van Dongen</surname><given-names>SM.</given-names></string-name></person-group><year>2000</year>. Graph clustering by flow simulation. Ph.D. thesis, University of Utrecht.</mixed-citation>
    </ref>
    <ref id="btad751-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Verdu</surname><given-names>P</given-names></string-name>, <string-name><surname>Jewett</surname><given-names>EM</given-names></string-name>, <string-name><surname>Pemberton</surname><given-names>TJ</given-names></string-name></person-group><etal>et al</etal><article-title>Parallel trajectories of genetic and linguistic admixture in a genetically admixed creole population</article-title>. <source>Curr Biol</source><year>2017</year>;<volume>27</volume>:<fpage>2529</fpage>–<lpage>35.</lpage><pub-id pub-id-type="pmid">28803872</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>S</given-names></string-name>, <string-name><surname>Lewis</surname><given-names>CM</given-names><suffix>Jr</suffix></string-name>, <string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Genetic variation and population structure in native Americans</article-title>. <source>PLoS Genet</source><year>2007</year>;<volume>3</volume>:<fpage>e185</fpage>.<pub-id pub-id-type="pmid">18039031</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B24">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Wolsey</surname><given-names>LA.</given-names></string-name></person-group><source>Integer Programming</source>. <publisher-loc>Hoboken, NJ</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>2020</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname><given-names>J</given-names></string-name>, <string-name><surname>Konecni</surname><given-names>S</given-names></string-name>, <string-name><surname>Grinstein</surname><given-names>G.</given-names></string-name></person-group> Visually comparing multiple partitions of data with applications to clustering. In: <italic toggle="yes">Visualization and Data Analysis 2009</italic>, vol. <volume>7243</volume>, p. <fpage>157</fpage>–<lpage>168</lpage>. Bellingham, WA, United States: SPIE, <year>2009</year>.</mixed-citation>
    </ref>
  </ref-list>
</back>
<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10766593</article-id>
    <article-id pub-id-type="pmid">38096585</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad751</article-id>
    <article-id pub-id-type="publisher-id">btad751</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genetics and Population Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title><italic toggle="yes">Clumppling</italic>: cluster matching and permutation program with integer linear programming</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-3955-9026</contrib-id>
        <name>
          <surname>Liu</surname>
          <given-names>Xiran</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="equal">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="lead">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="lead">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software" degree-contribution="lead">Software</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="lead">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute for Computational and Mathematical Engineering, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <xref rid="btad751-cor1" ref-type="corresp"/>
        <!--xiranliu@stanford.edu-->
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kopelman</surname>
          <given-names>Naama M</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="supporting">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="supporting">Writing - review &amp; editing</role>
        <aff><institution>Faculty of Sciences, Holon Institute of Technology</institution>, Holon 58109, <country country="IL">Israel</country></aff>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <name>
          <surname>Rosenberg</surname>
          <given-names>Noah A</given-names>
        </name>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization" degree-contribution="equal">Conceptualization</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation" degree-contribution="supporting">Investigation</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology" degree-contribution="supporting">Methodology</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Supervision" vocab-term-identifier="https://credit.niso.org/contributor-roles/supervision" degree-contribution="lead">Supervision</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft" degree-contribution="supporting">Writing - original draft</role>
        <role vocab="credit" vocab-identifier="https://credit.niso.org" vocab-term="Writing - review &amp; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing" degree-contribution="equal">Writing - review &amp; editing</role>
        <aff><institution>Institute for Computational and Mathematical Engineering, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <aff><institution>Department of Biology, Stanford University</institution>, Stanford, CA 94305, <country country="US">United States</country></aff>
        <xref rid="btad751-cor1" ref-type="corresp"/>
        <!--noahr@stanford.edu-->
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad751-cor1">Corresponding author. Stanford University, Stanford, CA 94305, United States. E-mail: <email>xiranliu@stanford.edu</email> (X.L.) and <email>noahr@stanford.edu</email> (N.A.R.) </corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>1</month>
      <year>2024</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-12-14">
      <day>14</day>
      <month>12</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>14</day>
      <month>12</month>
      <year>2023</year>
    </pub-date>
    <volume>40</volume>
    <issue>1</issue>
    <elocation-id>btad751</elocation-id>
    <history>
      <date date-type="received">
        <day>22</day>
        <month>8</month>
        <year>2023</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>11</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>09</day>
        <month>12</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>13</day>
        <month>12</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>04</day>
        <month>1</month>
        <year>2024</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad751.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>In the mixed-membership unsupervised clustering analyses commonly used in population genetics, multiple replicate data analyses can differ in their clustering solutions. Combinatorial algorithms assist in aligning clustering outputs from multiple replicates so that clustering solutions can be interpreted and combined across replicates. Although several algorithms have been introduced, challenges exist in achieving optimal alignments and performing alignments in reasonable computation time.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We present <italic toggle="yes">Clumppling</italic>, a method for aligning replicate solutions in mixed-membership unsupervised clustering. The method uses integer linear programming for finding optimal alignments, embedding the cluster alignment problem in standard combinatorial optimization frameworks. In example analyses, we find that it achieves solutions with preferred values of a desired objective function relative to those achieved by <italic toggle="yes">Pong</italic> and that it proceeds with less computation time than <italic toggle="yes">Clumpak</italic>. It is also the first method to permit alignments across replicates with multiple arbitrary values of the number of clusters <italic toggle="yes">K</italic>.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p><italic toggle="yes">Clumppling</italic> is available at <ext-link xlink:href="https://github.com/PopGenClustering/Clumppling" ext-link-type="uri">https://github.com/PopGenClustering/Clumppling</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>National Institutes of Health</institution>
            <institution-id institution-id-type="DOI">10.13039/100000002</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>R01 HG005855</award-id>
      </award-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>United States–Israel Binational Science Foundation</institution>
          </institution-wrap>
        </funding-source>
        <award-id>2017024</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="11"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Population-genetic mixed-membership unsupervised clustering methods, such as <italic toggle="yes">Structure</italic> (<xref rid="btad751-B16" ref-type="bibr">Pritchard <italic toggle="yes">et al.</italic> 2000</xref>) and <italic toggle="yes">Admixture</italic> (<xref rid="btad751-B2" ref-type="bibr">Alexander <italic toggle="yes">et al.</italic> 2009</xref>), are essential tools for understanding patterns of genetic variation in populations. These methods make use of individual genomes to infer population-genetic clusters; each individual is assigned a membership vector, in which each entry represents the inferred membership of the individual in a specific cluster.</p>
    <p>Mixed-membership unsupervised clustering typically employs stochastic steps so that output memberships from independent runs of a clustering approach on the same set of individuals can differ. Membership differences across replicate analyses with the same settings can result from one of two sources. One source is <italic toggle="yes">label-switching</italic>, in which the clusters and the patterns of co-clustering of individuals across clusters are identical between runs, but the clusters are ordered differently across runs. The second source is <italic toggle="yes">genuine multimodality</italic>, in which the clustering algorithm yields multiple local optima that represent different patterns of co-clustering of individuals. The clustering methods are often employed with different settings, most notably for the number of clusters, denoted <italic toggle="yes">K</italic>, so that membership estimates in different runs can differ for additional reasons. Because multiple potential sources contribute to clustering differences among replicates, in mixed-membership unsupervised clustering analysis, it is important to align the clusters across these replicates—to resolve label-switching, to assess genuine multimodality with fixed settings, and to examine clustering solutions with different values of <italic toggle="yes">K</italic>.</p>
    <p>Three main methods exist for resolving the cluster alignment across runs of population-genetic unsupervised clustering: <italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>), <italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>), and <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>). The methods differ slightly in the precise cluster alignment problems they solve, the algorithmic rationale for their alignment solutions, and their computational performance. Our goal is to introduce a new method that expands the set of scenarios in which cluster alignment can be performed, connects cluster alignment in population genetics to classic techniques of combinatorial optimization, and introduces computational improvements. The new method is <italic toggle="yes">Clumppling</italic>: <underline>CLU</underline>ster <underline>M</underline>atching and <underline>P</underline>ermutation <underline>P</underline>rogram with integer <underline>L</underline>inear programm<underline>ING</underline>.</p>
  </sec>
  <sec>
    <title>2 Review of existing approaches</title>
    <sec>
      <title>2.1 <italic toggle="yes">Clumpp</italic></title>
      <p><italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>) aligns replicates with equally many clusters. It either enumerates all possible permutations of clusters for all replicates and returns the one that maximizes an average pairwise similarity between all replicates, or adopts a greedy algorithm to sequentially align successive replicates. The greedy algorithm reduces computational time but does not necessarily find the optimal alignment. To further speed up the alignment process, <italic toggle="yes">Clumpp</italic> has a “LargeKGreedy” method to sequentially align a replicate column-wise rather than all at once.</p>
    </sec>
    <sec>
      <title>2.2 <italic toggle="yes">Clumpak</italic></title>
      <p><italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>) extends beyond <italic toggle="yes">Clumpp</italic> in two ways: algorithmic mode detection and algorithmic alignment of replicates with different numbers of clusters. First, it uses <italic toggle="yes">Clumpp</italic> to align replicates with the same <italic toggle="yes">K</italic>. It then detects modes by constructing a similarity network from pairs of aligned replicates and using the Markov clustering algorithm to define nearly identical groups of replicates in the network: modes. A mode is represented by the mean memberships of replicates in the mode.</p>
      <p>To assess replicates with different numbers of clusters, <italic toggle="yes">Clumpak</italic> examines the alignment of modes with <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters to those with <italic toggle="yes">K</italic> clusters. It aligns replicates with <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">K</italic> clusters by including an empty cluster and solving a one-to-one matching problem.</p>
    </sec>
    <sec>
      <title>2.3 <italic toggle="yes">Pong</italic></title>
      <p><italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>) views the problem of aligning pairs of replicates with equally many clusters as an <italic toggle="yes">assignment problem</italic> (<xref rid="btad751-B5" ref-type="bibr">Burkard <italic toggle="yes">et al.</italic> 2009</xref>). It uses the polynomial-time Hungarian algorithm for this optimization.</p>
      <p>For mode detection among replicates with a fixed number of clusters, <italic toggle="yes">Pong</italic> follows a simple approach. It constructs a similarity network of aligned replicates and uses a user-specified threshold to remove edges, taking the disjoint cliques in the network as modes. A representative replicate is then randomly chosen from each clique to represent the mode.</p>
      <p>To align a pair of representative replicates of the major modes with numbers of clusters <italic toggle="yes">K</italic> and <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Pong</italic> considers mergings of every possible pair of clusters from the replicate with <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters and finds the optimal alignment from all one-to-one alignments. It proceeds through consecutive <italic toggle="yes">K</italic> values to align major modes across different <italic toggle="yes">K</italic> values.</p>
    </sec>
    <sec>
      <title>2.4 Improvements provided by <italic toggle="yes">Clumppling</italic></title>
      <p>The existing methods have been used in thousands of studies. Nevertheless, opportunities exist for more fully integrating cluster alignment methods with frameworks of combinatorial optimization and network theory, for addressing complex alignment scenarios, and for improving computation time. We highlight several desirable features of <italic toggle="yes">Clumppling</italic> (<xref rid="btad751-T1" ref-type="table">Table 1</xref>):</p>
      <table-wrap position="float" id="btad751-T1">
        <label>Table 1.</label>
        <caption>
          <p>Features of cluster alignment methods: (1) <italic toggle="yes">Clumpp</italic>, (2) <italic toggle="yes">Clumpak</italic>, (3) <italic toggle="yes">Pong</italic>, and (4) <italic toggle="yes">Clumppling</italic>.</p>
        </caption>
        <table frame="hsides" rules="groups">
          <colgroup span="1">
            <col valign="top" align="left" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
            <col valign="top" align="center" span="1"/>
          </colgroup>
          <thead>
            <tr>
              <th rowspan="1" colspan="1">Feature</th>
              <th rowspan="1" colspan="1">1</th>
              <th rowspan="1" colspan="1">2</th>
              <th rowspan="1" colspan="1">3</th>
              <th rowspan="1" colspan="1">4</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td rowspan="1" colspan="1">Aligns same-<italic toggle="yes">K</italic> replicates on the same set of individuals</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Pairwise alignment uses established optimization tools</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Detects modes among same-<italic toggle="yes">K</italic> replicates algorithmically</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Mode detection uses established network tools</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns major modes of <italic toggle="yes">K</italic> and <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns all modes of <italic toggle="yes">K</italic> and <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Mode alignment uses all replicates in a mode</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
            <tr>
              <td rowspan="1" colspan="1">Aligns modes of <italic toggle="yes">K</italic> and <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>d</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula></td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✗</td>
              <td rowspan="1" colspan="1">✓</td>
            </tr>
          </tbody>
        </table>
      </table-wrap>
      <list list-type="order">
        <list-item>
          <p>Like <italic toggle="yes">Pong</italic>, <italic toggle="yes">Clumppling</italic> performs pairwise alignments using established algorithms from combinatorial optimization.</p>
        </list-item>
        <list-item>
          <p>Like <italic toggle="yes">Clumpak</italic>, <italic toggle="yes">Clumppling</italic> performs mode detection using established community detection algorithms from network theory.</p>
        </list-item>
        <list-item>
          <p>Unlike the other methods, <italic toggle="yes">Clumppling</italic> performs alignments between all modes at successive values of <italic toggle="yes">K</italic>, not only the major modes.</p>
        </list-item>
        <list-item>
          <p>Unlike the other methods, <italic toggle="yes">Clumppling</italic> performs alignments between replicates that differ in number of clusters by more than one.</p>
        </list-item>
      </list>
      <p><italic toggle="yes">Clumppling</italic> combines benefits of <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> in relying on ideas used for optimization and alignment in other fields. It performs alignments in the settings considered by <italic toggle="yes">Clumpp</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> and also expands to new settings.</p>
    </sec>
  </sec>
  <sec>
    <title>3 Methods</title>
    <sec>
      <title>3.1 Overview</title>
      <p>In the application of mixed-membership unsupervised clustering, the first step is to obtain multiple clustering replicates at each of multiple values of the number of clusters <italic toggle="yes">K</italic>. Beginning from these replicates, the procedure of <italic toggle="yes">Clumppling</italic> to align replicates and to extract modes is as follows:</p>
      <list list-type="order">
        <list-item>
          <p>Group replicates according to the number of clusters <italic toggle="yes">K</italic>.</p>
        </list-item>
        <list-item>
          <p>For each group of replicates with a shared <italic toggle="yes">K</italic>:</p>
          <list list-type="alpha-lower">
            <list-item>
              <p>For each pair of replicates in the group, obtain an optimal alignment with minimal pairwise cost.</p>
            </list-item>
            <list-item>
              <p>Detect subgroups of replicates belonging to shared modes.</p>
            </list-item>
            <list-item>
              <p>Obtain the consensus membership of each mode.</p>
            </list-item>
          </list>
        </list-item>
        <list-item>
          <p>Align pairs of modes across different values of <italic toggle="yes">K</italic> using their consensus memberships.</p>
        </list-item>
        <list-item>
          <p>Visualize the aligned modes.</p>
        </list-item>
      </list>
      <p>This pipeline follows that of <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> (<italic toggle="yes">Clumpp</italic> does not perform steps 2b, 2c, or 3, and its step analogous to 2a does not involve finding all pairwise alignments). However, <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> address only a special case of step 3 in which pairs of modes to be aligned across <italic toggle="yes">K</italic> values are the major modes of replicates with <italic toggle="yes">K</italic> and <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters. <italic toggle="yes">Clumppling</italic> provides alignments between each pair of modes, major and minor, considering replicates that can have numbers of clusters that differ by more than one. This new step is informative on how major and minor modes relate across <italic toggle="yes">K</italic> values and can also assist in aggregating clustering results with large <italic toggle="yes">K</italic> in which nonconsecutive <italic toggle="yes">K</italic> values may be of interest.</p>
      <p>For steps 2a and 2b, the central steps of the alignment procedure, we seek to improve performance and run time over previous methods. First, for pairwise alignment of replicates in step 2a, we use integer linear programming (ILP) from optimization theory. Second, for community detection in step 2b, we use the Louvain algorithm from network theory.</p>
    </sec>
    <sec>
      <title>3.2 Initial setup: dissimilarity between replicates</title>
      <p>Consider two replicates from a clustering algorithm on <italic toggle="yes">N</italic> individuals. Replicate 1, with <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters, can be represented as a matrix <italic toggle="yes">Q</italic> of size <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Entry <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the inferred membership coefficient of individual <italic toggle="yes">i</italic> in cluster <italic toggle="yes">k</italic>. Replicate 2, with <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters, is a matrix <italic toggle="yes">P</italic> of size <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Without loss of generality, suppose <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>To align two replicates, we need a measure that quantifies the similarity or dissimilarity of matrices <italic toggle="yes">Q</italic> and <italic toggle="yes">P</italic>. The problem of aligning the replicates can then be formulated as a problem of maximizing the similarity, or minimizing the dissimilarity, between membership matrices, one of whose columns is rearranged according to various proposed alignments.</p>
      <p>For <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Clumpp</italic> uses a pairwise similarity between two membership matrices, defined with the Frobenius matrix norm <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mo>⋅</mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E1"><label>(1)</label><mml:math id="M1" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>Q</mml:mi><mml:mo>−</mml:mo><mml:mi>P</mml:mi><mml:mo>|</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mi>F</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p><italic toggle="yes">Clumpp</italic> seeks to find the optimal alignment of <italic toggle="yes">R</italic> replicates by maximizing a measure of mean pairwise similarity of the <italic toggle="yes">R</italic> replicates, termed <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Clumpak</italic> uses this same method for the case of <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>.</p>
      <p><xref rid="E1" ref-type="disp-formula">Equation (1)</xref> applies only to membership matrices of the same size. For <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, we can consider measures that decompose the calculation into two levels: similarity or dissimilarity first between clusters, one from one replicate and one from the other, and second, between replicates.</p>
      <p><italic toggle="yes">Pong</italic> uses this two-level idea to define the similarity between replicates. Let <inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denote the membership coefficients in cluster <italic toggle="yes">i</italic> of replicate 1, with entries <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>; <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the <italic toggle="yes">i</italic>th column of matrix <italic toggle="yes">Q</italic>. Similarly, let <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denote the membership coefficients in cluster <italic toggle="yes">j</italic> of replicate 2. A cluster similarity is derived from the Jaccard index on the overlap in membership coefficients between clusters <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as
<disp-formula id="E2"><label>(2)</label><mml:math id="M2" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:msqrt><mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mo>|</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mrow></mml:msqrt><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi><mml:mo>}</mml:mo><mml:mo>:</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the set of rows with nonzero membership in cluster <italic toggle="yes">i</italic> of <italic toggle="yes">Q</italic>, cluster <italic toggle="yes">j</italic> of <italic toggle="yes">P</italic>, or both.</p>
      <p>The similarity between replicates is then defined as the mean cluster similarity across all clusters for a pair of replicates:
<disp-formula id="E3"><label>(3)</label><mml:math id="M3" display="block" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the cluster in <italic toggle="yes">P</italic> to which cluster <italic toggle="yes">i</italic> in <italic toggle="yes">Q</italic> aligns.</p>
      <p>If <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> and all entries of the membership matrices are nonzero, i.e. <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, then <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mi mathvariant="script">J</mml:mi></mml:math></inline-formula> has a form close to <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, though not quite equal to it. <xref rid="E1" ref-type="disp-formula">Equations (1)</xref> and <xref rid="E3" ref-type="disp-formula">(3)</xref> can be rewritten as follows:
<disp-formula id="E4"><label>(4)</label><mml:math id="M4" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><disp-formula id="E5"><label>(5)</label><mml:math id="M5" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>K</mml:mi></mml:mfrac></mml:mrow><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> ranges from 0 to 1. <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> trivially if <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>P</mml:mi><mml:mo>=</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> if for all <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for some <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo>≠</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>. In this case, <inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for 2 <italic toggle="yes">N</italic> of the <italic toggle="yes">NK</italic> pairs <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>However, the similarity measure <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mi mathvariant="script">J</mml:mi></mml:math></inline-formula> used by <italic toggle="yes">Pong</italic> does not reach 0. Because <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>≤</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> for all <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt></mml:mrow><mml:mo>≤</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:math></inline-formula>. Therefore, <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">J</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>≥</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:msqrt><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></inline-formula>.</p>
      <p>For <italic toggle="yes">Clumppling</italic>, we seek a dissimilarity measure for membership matrices that (1) permits <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and (2) spans the full unit interval [0, 1], with a value of 0 for matrices with no overlap and a value of 1 for identical memberships. We use a measure with the two-level composition of <italic toggle="yes">Pong</italic> but with a form more similar to that of <italic toggle="yes">Clumpp</italic> and <italic toggle="yes">Clumpak</italic>.</p>
      <p>For the dissimilarity between cluster <italic toggle="yes">i</italic> of replicate 1 and cluster <italic toggle="yes">j</italic> of replicate 2, <italic toggle="yes">Clumppling</italic> uses
<disp-formula id="E6"><label>(6)</label><mml:math id="M6" display="block" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>For the dissimilarity between two replicates with <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, it uses
<disp-formula id="E7"><label>(7)</label><mml:math id="M7" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Continuing with <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, dissimilarity <inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is related to similarity <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> [<xref rid="E1" ref-type="disp-formula">Equations (1)</xref> and <xref rid="E4" ref-type="disp-formula">(4)</xref>]:
<disp-formula id="E8"><label>(8)</label><mml:math id="M8" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>We will see shortly how to proceed if <inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
    </sec>
    <sec>
      <title>3.3 Step 2a: pairwise alignment</title>
      <p>Given a dissimilarity measure, the alignment of two replicates involves permuting the clusters of one replicate—the columns of its associated matrix—to minimize the dissimilarity with the other replicate.</p>
      <p>If <inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>, then aligning two replicates is the problem of finding the optimal one-to-one permutation that minimizes <inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is the matrix <italic toggle="yes">P</italic> with columns permuted under a permutation <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> of <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Minimizing the dissimilarity is equivalent to maximizing the similarity, the problem considered by <italic toggle="yes">Clumpp</italic>.</p>
      <p>If <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then the alignment between two replicates involves a many-to-one mapping from <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> in general, denote the alignment by <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>—i.e. <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Each <italic toggle="yes">i</italic> is mapped to exactly one <italic toggle="yes">j</italic>, and each <italic toggle="yes">j</italic> is the image of at least one <italic toggle="yes">i</italic>. The dissimilarity between replicates with alignment <inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> is a function of <italic toggle="yes">Q</italic>, <italic toggle="yes">P</italic>, and <inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula>:
<disp-formula id="E9"><label>(9)</label><mml:math id="M9" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Note that if <inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then we have
<disp-formula id="E10"><label>(10)</label><mml:math id="M10" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo>≤</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>as for each <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> is bounded above by 2. The maximal dissimilarity satisfies <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>≤</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mrow><mml:mn>2</mml:mn><mml:mi>N</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
      <p>If <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, however, then the alignment is no longer one-to-one, and for a specific <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, <inline-formula id="IE77"><mml:math id="IM77" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> can exceed 2. For instance, for <italic toggle="yes">Q</italic> with dimensions <inline-formula id="IE78"><mml:math id="IM78" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">P</italic> with dimensions <inline-formula id="IE79"><mml:math id="IM79" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, an individual <inline-formula id="IE80"><mml:math id="IM80" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> with <inline-formula id="IE81"><mml:math id="IM81" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE82"><mml:math id="IM82" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and alignment mapping <inline-formula id="IE83"><mml:math id="IM83" display="inline" overflow="scroll"><mml:mrow><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE84"><mml:math id="IM84" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>. Hence, if <inline-formula id="IE85"><mml:math id="IM85" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>&gt;</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, then the maximal value of <inline-formula id="IE86"><mml:math id="IM86" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can exceed 1. Nevertheless, for a specific pair <inline-formula id="IE87"><mml:math id="IM87" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, a smaller value of <inline-formula id="IE88"><mml:math id="IM88" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> always indicates a closer alignment.</p>
      <p>The problem of finding the optimal alignment between a pair of replicates can then be formulated as computing <inline-formula id="IE89"><mml:math id="IM89" display="inline" overflow="scroll"><mml:mrow><mml:mtext>arg</mml:mtext><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mo>α</mml:mo></mml:msub></mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. <italic toggle="yes">Clumppling</italic> uses ILP to perform this optimization.</p>
      <p>Linear programming (LP) concerns the problem of maximizing or minimizing a linear objective function subject to linear equality and inequality constraints (<xref rid="btad751-B19" ref-type="bibr">Schrijver 1998</xref>). These constraints form a feasible region of a convex polyhedron for variables that are optimized. LP problems are represented in canonical form by <inline-formula id="IE90"><mml:math id="IM90" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE91"><mml:math id="IM91" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> records the <italic toggle="yes">n</italic> variables to be optimized, <inline-formula id="IE92"><mml:math id="IM92" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:math></inline-formula> is the objective function (cost function) to be minimized, and <inline-formula id="IE93"><mml:math id="IM93" display="inline" overflow="scroll"><mml:mrow><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE94"><mml:math id="IM94" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> summarize the linear constraints.</p>
      <p>ILP problems have additional constraints that some variables are integers; in those dimensions, the feasible set for the variables is restricted to lattice points in the polyhedron. An ILP problem in which all variables must be integers can be represented in canonical form <inline-formula id="IE95"><mml:math id="IM95" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">c</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mi mathvariant="bold">x</mml:mi><mml:mo>|</mml:mo><mml:mi>A</mml:mi><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≤</mml:mo><mml:mi mathvariant="bold">b</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>≥</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="bold">x</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow><mml:mi>n</mml:mi></mml:msup></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Although ILP problems are NP-complete (<xref rid="btad751-B19" ref-type="bibr">Schrijver 1998</xref>), we can capitalize on extensive effort devoted to solving them as standard problems in optimization theory.</p>
      <p>To formulate the pairwise alignment problem with ILP, we place dissimilarities <inline-formula id="IE96"><mml:math id="IM96" display="inline" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mo>⋅</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> between pairs of clusters in two replicates in a <inline-formula id="IE97"><mml:math id="IM97" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> matrix <italic toggle="yes">C</italic>. Denote the alignment <inline-formula id="IE98"><mml:math id="IM98" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> as a <inline-formula id="IE99"><mml:math id="IM99" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> indicator matrix <italic toggle="yes">W</italic>, where
<disp-formula id="E11"><mml:math id="M11" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="true">{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>if</mml:mtext><mml:mo> </mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mtext>otherwise</mml:mtext><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p>
      <p>Because <inline-formula id="IE100"><mml:math id="IM100" display="inline" overflow="scroll"><mml:mo>α</mml:mo></mml:math></inline-formula> is a many-to-one mapping, each row of <italic toggle="yes">W</italic> in constrained to sum to exactly 1, and each column of <italic toggle="yes">W</italic> has sum at least 1.</p>
      <p>The dissimilarity between two replicates in <xref rid="E9" ref-type="disp-formula">Equation (9)</xref> can be written as follows:
<disp-formula id="E12"><label>(11)</label><mml:math id="M12" display="block" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mo>α</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>P</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>The alignment problem can now be formulated with ILP:
<disp-formula id="E13"><label>  </label><mml:math id="M13" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mtext>arg </mml:mtext><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:mrow><mml:mi>W</mml:mi></mml:munder></mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow/></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><disp-formula id="E13a"><label>(12)</label><mml:math id="M13a" display="block" overflow="scroll"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtext>subject to</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow/></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo> </mml:mo><mml:mtext>for each</mml:mtext><mml:mo> </mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p>
      <p>In fact, this minimization is an instance of <italic toggle="yes">binary linear programming</italic> (<xref rid="btad751-B24" ref-type="bibr">Wolsey 2020</xref>), in which variables are restricted to zeros and ones. The canonical form of this ILP problem appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods</xref>. A pairwise alignment problem framed in this manner can then be solved by standard ILP methods. <italic toggle="yes">Clumppling</italic> uses the branch-and-cut algorithm (<xref rid="btad751-B15" ref-type="bibr">Mitchell 2002</xref>). The optimal solution <inline-formula id="IE101"><mml:math id="IM101" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">w</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> that minimizes the objective function corresponds to the optimal alignment under the chosen dissimilarity measure [<xref rid="E13" ref-type="disp-formula">Equation (12)</xref>, as reformulated in <xref rid="sup1" ref-type="supplementary-material">Supplementary Equation (1)</xref>].</p>
    </sec>
    <sec>
      <title>3.4 Step 2b: mode detection via community detection</title>
      <p>For all replicates with equally many clusters, an optimal alignment is obtained for each pair using ILP as described in the previous section. Suppose there are <inline-formula id="IE102"><mml:math id="IM102" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> replicates with <italic toggle="yes">K</italic> clusters, and their membership matrices are <inline-formula id="IE103"><mml:math id="IM103" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>. Between a pair of replicates <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic>, the optimal alignment of <inline-formula id="IE104"><mml:math id="IM104" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE105"><mml:math id="IM105" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> is <inline-formula id="IE106"><mml:math id="IM106" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, extracted from the solution <inline-formula id="IE107"><mml:math id="IM107" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">w</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> to <xref rid="E13" ref-type="disp-formula">Equation (12)</xref> that gives the minimal dissimilarity <inline-formula id="IE108"><mml:math id="IM108" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>To align all replicates simultaneously, <italic toggle="yes">Clumppling</italic> constructs an undirected graph <inline-formula id="IE109"><mml:math id="IM109" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo>,</mml:mo><mml:mi>E</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> using replicates as nodes <inline-formula id="IE110"><mml:math id="IM110" display="inline" overflow="scroll"><mml:mrow><mml:mi>V</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. Edge set <inline-formula id="IE111"><mml:math id="IM111" display="inline" overflow="scroll"><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> has weights <inline-formula id="IE112"><mml:math id="IM112" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> negatively weighted by the normalized dissimilarity of optimal alignments: <inline-formula id="IE113"><mml:math id="IM113" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE114"><mml:math id="IM114" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>, and for <inline-formula id="IE115"><mml:math id="IM115" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>,
<disp-formula id="E14"><label>(13)</label><mml:math id="M14" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE116"><mml:math id="IM116" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>min</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE117"><mml:math id="IM117" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A higher weight indicates greater similarity of two replicates under their optimal alignment. The <inline-formula id="IE118"><mml:math id="IM118" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> matrix of edge weights is symmetric.</p>
      <p>We seek to find sets of replicates that are collectively similar to one another when optimally aligned, or <italic toggle="yes">modes</italic>. For this task, we rely on community detection algorithms (<xref rid="btad751-B7" ref-type="bibr">Fortunato 2010</xref>, <xref rid="btad751-B10" ref-type="bibr">Javed <italic toggle="yes">et al.</italic> 2018</xref>). In a graph, communities are groups of nodes that are more densely connected within the group than outside the group. A community in the graph <inline-formula id="IE119"><mml:math id="IM119" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> corresponds to a mode in the unsupervised clustering analysis. In terms of the associated edge-weight matrix, a matrix with nontrivial communities has a block-diagonal structure, with two or more blocks corresponding to communities. Entries within a block tend to exceed entries outside it for the associated rows and columns—indicating greater edge weights for node pairs within the same community than for pairs not in the same community.</p>
      <p><italic toggle="yes">Clumppling</italic> first tests a null hypothesis of no community structure. We use a test of <xref rid="btad751-B20" ref-type="bibr">Tokuda (2018)</xref>, based on differences between (i) random symmetric matrices with a block-diagonal community structure in which within-block off-diagonal entries are distributed differently from outside-block off-diagonal entries, and (ii) random symmetric matrices in which all off-diagonal entries are independently and identically distributed. Considering the largest and smallest eigenvalues of two transformed versions of the symmetric edge-weight matrix of the graph, the null hypothesis is rejected if one or both eigenvalues (of either matrix) lies outside specified intervals. In our application, if the null hypothesis of no community structure is rejected at <inline-formula id="IE120"><mml:math id="IM120" display="inline" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo>=</mml:mo><mml:mn>0.01</mml:mn></mml:mrow></mml:math></inline-formula>, then <italic toggle="yes">Clumppling</italic> proceeds to identify community structure in the undirected weighted graph <inline-formula id="IE121"><mml:math id="IM121" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>For community detection, <italic toggle="yes">Clumpak</italic> uses Markov clustering (MCL) (<xref rid="btad751-B21" ref-type="bibr">Van Dongen 2000</xref>), employing a threshold to remove some edges with lower weights from the network—i.e. to replace smaller edge weights with values of 0—thereby reducing the density of edges. <italic toggle="yes">Clumppling</italic> instead uses the Louvain method (<xref rid="btad751-B4" ref-type="bibr">Blondel <italic toggle="yes">et al.</italic> 2008</xref>), which does not require premodification of the network. This algorithm has a “resolution” parameter that affects the size of the detected communities; larger values typically find smaller communities and more of them. <italic toggle="yes">Clumppling</italic> allows the user to specify its value, with a default of 1.</p>
      <p>The outcome of mode detection via community detection algorithms is a set of communities of nodes, each of which corresponds to a subset of replicates that belong to the same mode. Modes are disjoint so that replicate each belongs to exactly one mode. Suppose <inline-formula id="IE122"><mml:math id="IM122" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> communities are detected, which we denote <inline-formula id="IE123"><mml:math id="IM123" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mn>1</mml:mn></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> through <inline-formula id="IE124"><mml:math id="IM124" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula id="IE125"><mml:math id="IM125" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>i</mml:mi></mml:msubsup></mml:mrow><mml:mo>∩</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>j</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula> for all distinct <inline-formula id="IE126"><mml:math id="IM126" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE127"><mml:math id="IM127" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∪</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mi>V</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE128"><mml:math id="IM128" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It is possible for a mode to possess only one replicate, <inline-formula id="IE129"><mml:math id="IM129" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, although this “singleton” situation is somewhat unusual.</p>
    </sec>
    <sec>
      <title>3.5 Step 2c: consensus memberships for modes</title>
      <p>For each mode <inline-formula id="IE130"><mml:math id="IM130" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula>, we obtain a consensus membership matrix in one of two ways. First, we obtain a <italic toggle="yes">mean</italic> membership matrix of its replicates:
<disp-formula id="E15"><label>(14)</label><mml:math id="M15" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where, for simplicity, the <inline-formula id="IE131"><mml:math id="IM131" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> are treated as having already been aligned.</p>
      <p>We also obtain a <italic toggle="yes">representative</italic> membership matrix, the matrix of the replicate that has the largest sum of edge weights within the community:
<disp-formula id="E16"><label>(15)</label><mml:math id="M16" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mrow><mml:mtext>arg </mml:mtext><mml:mrow><mml:mtext>max</mml:mtext></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Either <inline-formula id="IE132"><mml:math id="IM132" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> or <inline-formula id="IE133"><mml:math id="IM133" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> can be used as the consensus membership of replicates in the mode. <italic toggle="yes">Clumppling</italic> uses <inline-formula id="IE134"><mml:math id="IM134" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> as its default.</p>
      <p>Suppose the set of the distinct numbers of clusters is <inline-formula id="IE135"><mml:math id="IM135" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>. After building networks of replicates for each <italic toggle="yes">K</italic>, we obtain a set of modes together with consensus memberships:
<disp-formula id="E17"><label>(16)</label><mml:math id="M17" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>:</mml:mo><mml:mi>ℓ</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">K</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
    </sec>
    <sec>
      <title>3.6 Step 3: alignment of modes across <italic toggle="yes">K</italic></title>
      <p>Finally, with modes defined, we align modes across values of <italic toggle="yes">K</italic>. In particular, we order the values of <inline-formula id="IE136"><mml:math id="IM136" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>∈</mml:mo><mml:mi mathvariant="script">K</mml:mi></mml:mrow></mml:math></inline-formula> in decreasing order: <inline-formula id="IE137"><mml:math id="IM137" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mo>⋯</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. We then obtain a multipartite graph of the pairwise alignments between modes across different values of <italic toggle="yes">K</italic>.</p>
      <p>For adjacent <italic toggle="yes">K</italic> values in <inline-formula id="IE138"><mml:math id="IM138" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>, <inline-formula id="IE139"><mml:math id="IM139" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE140"><mml:math id="IM140" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE141"><mml:math id="IM141" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, there exist <inline-formula id="IE142"><mml:math id="IM142" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>×</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> pairs of modes. For each such pair, we use ILP [<xref rid="E13" ref-type="disp-formula">Equation (12)</xref>] to align consensus memberships from <xref rid="E17" ref-type="disp-formula">Equation (16)</xref>. The optimal dissimilarity is <inline-formula id="IE143"><mml:math id="IM143" display="inline" overflow="scroll"><mml:mrow><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <inline-formula id="IE144"><mml:math id="IM144" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE145"><mml:math id="IM145" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, and <inline-formula id="IE146"><mml:math id="IM146" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the mapping of clusters of <inline-formula id="IE147"><mml:math id="IM147" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> to clusters of <inline-formula id="IE148"><mml:math id="IM148" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> that produces the optimum.</p>
      <p>We then use these dissimilarities between modes as weights to create a bipartite graph between modes of <inline-formula id="IE149"><mml:math id="IM149" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and modes of <inline-formula id="IE150"><mml:math id="IM150" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. For instance, the weight between mode <inline-formula id="IE151"><mml:math id="IM151" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE152"><mml:math id="IM152" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and mode <inline-formula id="IE153"><mml:math id="IM153" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> of <inline-formula id="IE154"><mml:math id="IM154" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> can be set to
<disp-formula id="E18"><label>(17)</label><mml:math id="M18" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>μ</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>−</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>Q</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>ℓ</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:msubsup></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where larger weights indicate closer alignments. Note that theoretically, the dissimilarity <italic toggle="yes">D</italic> can exceed 1 for a pair of modes with different numbers of clusters. However, such a situation requires pairs of clusters to be matched extremely poorly between different values of <italic toggle="yes">K</italic>, an unlikely scenario after optimal alignment. Hence, negative weights in <xref rid="E18" ref-type="disp-formula">Equation (17)</xref> are unlikely.</p>
      <p>Combining the bipartite graphs between pairs of adjacent values of <italic toggle="yes">K</italic>, we obtain a <inline-formula id="IE155"><mml:math id="IM155" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>-partite graph representing alignments across modes with different numbers of clusters. We call our approach to the alignment of modes across <italic toggle="yes">K</italic> the “direct” approach.</p>
      <p>For consecutive values of <italic toggle="yes">K</italic>, we also consider a second approach that modifies the method of <italic toggle="yes">Pong</italic>; we term this second approach the “merge” approach. This approach enumerates all possible ways to merge a pair of clusters from the mode with <inline-formula id="IE156"><mml:math id="IM156" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters to produce <italic toggle="yes">K</italic> clusters. It then uses our ILP method to align two matrices of the same size. A total of <inline-formula id="IE157"><mml:math id="IM157" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> alignments are performed, and the one that achieves the smallest dissimilarity is chosen to be the optimal alignment between the two modes. Note that unlike the “direct” approach, which permits nonconsecutive <italic toggle="yes">K</italic> values, the “merge” approach requires the values of <italic toggle="yes">K</italic> to be consecutive.</p>
    </sec>
    <sec>
      <title>3.7 Visualization</title>
      <p>To display all modes at all numbers of clusters, we proceed sequentially in the order <inline-formula id="IE158"><mml:math id="IM158" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, arranging values of <italic toggle="yes">K</italic> with <inline-formula id="IE159"><mml:math id="IM159" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>≥</mml:mo><mml:mo>…</mml:mo><mml:mo>≥</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Proceeding from <inline-formula id="IE160"><mml:math id="IM160" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula id="IE161"><mml:math id="IM161" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi mathvariant="script">K</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, for each adjacent pair <inline-formula id="IE162"><mml:math id="IM162" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (e.g. <inline-formula id="IE163"><mml:math id="IM163" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and <italic toggle="yes">K</italic> if their numbers of clusters are consecutive), we choose the most closely aligned pair of modes between them as “anchors.” We then perform the following three steps:</p>
      <list list-type="order">
        <list-item>
          <p>All other modes with <inline-formula id="IE164"><mml:math id="IM164" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters are aligned to the <inline-formula id="IE165"><mml:math id="IM165" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> anchor.</p>
        </list-item>
        <list-item>
          <p>All other modes with <inline-formula id="IE166"><mml:math id="IM166" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> clusters are aligned to the <inline-formula id="IE167"><mml:math id="IM167" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> anchor.</p>
        </list-item>
        <list-item>
          <p>The modes of these two different <italic toggle="yes">K</italic> values are then aligned according to the alignment of the <inline-formula id="IE168"><mml:math id="IM168" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> anchor pair.</p>
        </list-item>
      </list>
      <p>For example, consider three numbers of clusters <inline-formula id="IE169"><mml:math id="IM169" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, each with two modes. Suppose the most closely aligned mode pair for <inline-formula id="IE170"><mml:math id="IM170" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is (<inline-formula id="IE171"><mml:math id="IM171" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>, <inline-formula id="IE172"><mml:math id="IM172" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>) and that for <inline-formula id="IE173"><mml:math id="IM173" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it is (<inline-formula id="IE174"><mml:math id="IM174" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>, <inline-formula id="IE175"><mml:math id="IM175" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>). First, we align modes of <inline-formula id="IE176"><mml:math id="IM176" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>: (1) <inline-formula id="IE177"><mml:math id="IM177" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub> is aligned to the anchor <inline-formula id="IE178"><mml:math id="IM178" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>. (2) <inline-formula id="IE179"><mml:math id="IM179" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> is aligned to the anchor <inline-formula id="IE180"><mml:math id="IM180" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. (3) Clusters in modes of these two <italic toggle="yes">K</italic> values are rearranged according to the alignment between <inline-formula id="IE181"><mml:math id="IM181" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> and <inline-formula id="IE182"><mml:math id="IM182" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. Next, we align modes of <inline-formula id="IE183"><mml:math id="IM183" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> in the same way: (1) <inline-formula id="IE184"><mml:math id="IM184" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub> is aligned to the anchor <inline-formula id="IE185"><mml:math id="IM185" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub>—which was already accomplished in the previous step (1), as alignments between modes with the same <italic toggle="yes">K</italic> apply symmetrically. (2) <inline-formula id="IE186"><mml:math id="IM186" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> is aligned to the anchor <inline-formula id="IE187"><mml:math id="IM187" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. (3) Across modes of <inline-formula id="IE188"><mml:math id="IM188" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE189"><mml:math id="IM189" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, the alignment follows that between <inline-formula id="IE190"><mml:math id="IM190" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>1</sub> and <inline-formula id="IE191"><mml:math id="IM191" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>-Mode<sub>2</sub>. In this way, all modes across <inline-formula id="IE192"><mml:math id="IM192" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are aligned.</p>
      <p>For visualization of aligned modes, <italic toggle="yes">Clumppling</italic> plots each mode as a “classic” structure plot—a stacked bar chart of equal height—with clusters represented by different colors (e.g. <xref rid="btad751-B17" ref-type="bibr">Rosenberg 2004</xref>). The number of replicates in a mode is marked above the associated plot. To visualize relationships between modes with different numbers of clusters, modes appear in a multipartite graph according to the across-<italic toggle="yes">K</italic> alignment. Modes with the same <italic toggle="yes">K</italic> appear in the same “layer,” where the number of layers is <inline-formula id="IE193"><mml:math id="IM193" display="inline" overflow="scroll"><mml:mi mathvariant="script">K</mml:mi></mml:math></inline-formula>, the number of distinct <italic toggle="yes">K</italic> values considered. For each <italic toggle="yes">K</italic>, modes are ordered in decreasing size (i.e. the number of replicates in the mode) and decreasing within-mode similarity [described in <xref rid="E19" ref-type="disp-formula">Equation (18)</xref>]. Modes with adjacent <italic toggle="yes">K</italic> values are joined by edges colored based on the edge weight [<xref rid="E18" ref-type="disp-formula">Equation (17)</xref>], with darker colors indicating larger weights and closer alignments. Minimal dissimilarities between pairs of modes under their optimal alignment—i.e. the optimal objective function values from <xref rid="E13" ref-type="disp-formula">Equation (12)</xref>—appear as labels on the edges, with smaller values indicating closer alignments. To visualize the variability within a mode, in addition to the structure plot, <italic toggle="yes">Clumppling</italic> provides a histogram of pairwise dissimilarities under optimal alignment of replicates within modes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S1</xref>).</p>
    </sec>
  </sec>
  <sec>
    <title>4 Evaluation of performance</title>
    <p>The <italic toggle="yes">Clumppling</italic> implementation is described in the <xref rid="sup1" ref-type="supplementary-material">Supplementary Methods</xref>. We compare the alignment performance of <italic toggle="yes">Clumppling</italic> to the two existing methods, <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>, that align replicates across <italic toggle="yes">K</italic> values. Because they only align equal or consecutive <italic toggle="yes">K</italic> values, the evaluation does so as well—although <italic toggle="yes">Clumppling</italic> accommodates replicates with numbers of clusters differing by more than 1.</p>
    <sec>
      <title>4.1 Performance measure</title>
      <p>For replicates with a shared <italic toggle="yes">K</italic>, we use a performance measure based on the similarity score <inline-formula id="IE194"><mml:math id="IM194" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> of <italic toggle="yes">Clumpp</italic> and <italic toggle="yes">Clumpak</italic>. For a mode <inline-formula id="IE195"><mml:math id="IM195" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, let <inline-formula id="IE196"><mml:math id="IM196" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> denote the mean similarity score for all pairs of replicates in the mode after its replicates <inline-formula id="IE197"><mml:math id="IM197" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are all aligned pairwise:
<disp-formula id="E19"><label>(18)</label><mml:math id="M19" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:munderover></mml:mrow><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>where <inline-formula id="IE198"><mml:math id="IM198" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is interpreted as the mapping of clusters of <inline-formula id="IE199"><mml:math id="IM199" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> to clusters of <inline-formula id="IE200"><mml:math id="IM200" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> for the optimal alignment of <inline-formula id="IE201"><mml:math id="IM201" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE202"><mml:math id="IM202" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Next, to obtain a mean similarity score involving all replicates and modes, we calculate a weighted similarity score <inline-formula id="IE203"><mml:math id="IM203" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> that assigns each replicate the mean similarity score of its associated mode:
<disp-formula id="E20"><label>(19)</label><mml:math id="M20" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:munderover></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>We modify <xref rid="E20" ref-type="disp-formula">Equation (19)</xref> to exclude singleton modes <inline-formula id="IE204"><mml:math id="IM204" display="inline" overflow="scroll"><mml:mi>ℓ</mml:mi></mml:math></inline-formula> with <inline-formula id="IE205"><mml:math id="IM205" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Because singletons always have similarity score 1 in <xref rid="E19" ref-type="disp-formula">Equation (18)</xref>, their existence can upwardly bias the weighted similarity score. With <inline-formula id="IE206"><mml:math id="IM206" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> singleton modes, the singleton-excluded weighted similarity score becomes
<disp-formula id="E21"><label>(20)</label><mml:math id="M21" display="block" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow><mml:mo>−</mml:mo><mml:mrow><mml:msub><mml:mi>s</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow><mml:mrow><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>ℓ</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mo>≠</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>m</mml:mi><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:munderover></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>M</mml:mi><mml:mi>K</mml:mi><mml:mi>ℓ</mml:mi></mml:msubsup></mml:mrow><mml:mo>|</mml:mo><mml:mrow><mml:msubsup><mml:mi>H</mml:mi><mml:mi>ℓ</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>.</mml:mo></mml:math></disp-formula></p>
      <p>Note that removal of the singletons reduces the number of replicates that need to be aligned; it is useful to track the value <inline-formula id="IE207"><mml:math id="IM207" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> along with <inline-formula id="IE208"><mml:math id="IM208" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:mrow><mml:mi>K</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p>
      <p>Because we compare the performance of <italic toggle="yes">Clumppling</italic> with methods that only support the alignment of replicates with consecutive values of <italic toggle="yes">K</italic>, we use a performance measure suited to consecutive <italic toggle="yes">K</italic> values. To evaluate across-<italic toggle="yes">K</italic> alignments, we measure the <inline-formula id="IE209"><mml:math id="IM209" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> similarity [<xref rid="E1" ref-type="disp-formula">Equation (1)</xref>] between the most closely aligned pair of modes aligned across each <inline-formula id="IE210"><mml:math id="IM210" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. For this computation, an optimal alignment <inline-formula id="IE211"><mml:math id="IM211" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> has first already been identified for this pair of modes in Section 3.6. Two of the clusters in the mode with <inline-formula id="IE212"><mml:math id="IM212" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters are necessarily matched to the same cluster in the mode with <italic toggle="yes">K</italic> clusters, or <inline-formula id="IE213"><mml:math id="IM213" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for exactly one unordered pair of <inline-formula id="IE214"><mml:math id="IM214" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, <inline-formula id="IE215"><mml:math id="IM215" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>≠</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula>. We apply the alignment <inline-formula id="IE216"><mml:math id="IM216" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>: we merge these two clusters, adding their columns in the membership matrix together to produce a single column. Mathematically, suppose the original <inline-formula id="IE217"><mml:math id="IM217" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> membership matrix for the mode with <inline-formula id="IE218"><mml:math id="IM218" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters is <italic toggle="yes">P</italic>, with columns <inline-formula id="IE219"><mml:math id="IM219" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. It now becomes a new <inline-formula id="IE220"><mml:math id="IM220" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula> membership matrix <inline-formula id="IE221"><mml:math id="IM221" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> with columns
<disp-formula id="E22"><mml:math id="M22" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:msubsup></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>∈</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mo>α</mml:mo></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mtext>for</mml:mtext><mml:mo> </mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>K</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula></p>
      <p>Now the two membership matrices, <italic toggle="yes">Q</italic> and <inline-formula id="IE222"><mml:math id="IM222" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, both have size <inline-formula id="IE223"><mml:math id="IM223" display="inline" overflow="scroll"><mml:mrow><mml:mi>N</mml:mi><mml:mo>×</mml:mo><mml:mi>K</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula id="IE224"><mml:math id="IM224" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>G</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>Q</mml:mi><mml:mo>,</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msup></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is computed for these two matrices.</p>
      <p>Note that because this similarity calculation merges clusters, it measures the similarity of a mode with <italic toggle="yes">K</italic> clusters and a mode with <inline-formula id="IE225"><mml:math id="IM225" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters according to its value for a quantity optimized by the “merge” and not the “direct” approach. Hence, it is expected to have higher values when the “merge” rather than the “direct” approach is used to produce the optimal alignment. Because <italic toggle="yes">Pong</italic> uses the “merge” approach to align modes with consecutive numbers of clusters, the calculation evaluates <italic toggle="yes">Clumppling</italic> against <italic toggle="yes">Pong</italic> by a measure that <italic toggle="yes">Pong</italic> seeks to optimize.</p>
      <p>We evaluate the performances of all four possible combinations of the mode consensus approach and the approach for performing alignments. That is, we use either “representative” [<xref rid="E15" ref-type="disp-formula">Equation (14)</xref>] or “average” [<xref rid="E16" ref-type="disp-formula">Equation (15)</xref>] as the consensus membership of a mode. For alignments of modes with <italic toggle="yes">K</italic> and <inline-formula id="IE226"><mml:math id="IM226" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> clusters, we use either the “direct” approach or the “merge” approach in identifying the alignment with the minimal dissimilarity [<xref rid="E9" ref-type="disp-formula">Equation (9)</xref>].</p>
    </sec>
    <sec>
      <title>4.2 Datasets</title>
      <p>We demonstrate the use of <italic toggle="yes">Clumppling</italic> and compare the alignment performance of the methods with two datasets. The first contains an unsupervised <italic toggle="yes">Admixture</italic> analysis of 399 individuals focused on the human population of Cape Verde. This dataset has replicates with small values of <italic toggle="yes">K</italic>. It provides an example in which many individuals, including 44 individuals in the admixed population of Cape Verde (<xref rid="btad751-B22" ref-type="bibr">Verdu <italic toggle="yes">et al.</italic> 2017</xref>), possess nontrivial memberships in multiple clusters; the original analysis of <xref rid="btad751-B22" ref-type="bibr">Verdu <italic toggle="yes">et al.</italic> (2017)</xref> considered 50 replicates each at <inline-formula id="IE227"><mml:math id="IM227" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>; we reanalyzed those replicates. For this dataset, we ran <italic toggle="yes">Clumppling</italic> using the default resolution parameter of 1 for the Louvain mode detection.</p>
      <p>The second dataset provides an example of alignment with relatively large values of <italic toggle="yes">K</italic>: a study of 600 chickens from 20 populations (<xref rid="btad751-B18" ref-type="bibr">Rosenberg <italic toggle="yes">et al.</italic> 2001</xref>) focused on values of <inline-formula id="IE228"><mml:math id="IM228" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mn>18</mml:mn><mml:mo>,</mml:mo><mml:mn>19</mml:mn></mml:mrow></mml:math></inline-formula>, and we add <inline-formula id="IE229"><mml:math id="IM229" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:mn>21</mml:mn></mml:mrow></mml:math></inline-formula> here (“chicken dataset”). We begin from the original data, 27 genotyped loci in each of the 600 individuals, running <italic toggle="yes">Structure</italic> (<xref rid="btad751-B16" ref-type="bibr">Pritchard <italic toggle="yes">et al.</italic> 2000</xref>) for 20 replicates for each <italic toggle="yes">K</italic> from 17 to 21. We ran <italic toggle="yes">Structure</italic> with a burn-in period of length 5000 in the “Admixture” model followed by 50000 MCMC repetitions, as in <xref rid="btad751-B18" ref-type="bibr">Rosenberg <italic toggle="yes">et al.</italic> (2001)</xref>. For mode detection in <italic toggle="yes">Clumppling</italic>, we used 1.05 for the resolution parameter; for this more challenging dataset, increasing the resolution above the default of 1 leads to a larger number of modes but with greater within-mode similarity.</p>
    </sec>
    <sec>
      <title>4.3 Analysis of clustering replicates</title>
      <p>For each value of <italic toggle="yes">K</italic>, we used <italic toggle="yes">Clumppling</italic> to align the 50 <italic toggle="yes">Admixture</italic> replicates for the Cape Verde dataset. Alignments based on mean memberships for the mode consensus and the “direct” approach for alignment across <italic toggle="yes">K</italic> values appear in <xref rid="btad751-F1" ref-type="fig">Fig. 1</xref>.</p>
      <fig position="float" id="btad751-F1">
        <label>Figure 1.</label>
        <caption>
          <p><italic toggle="yes">Clumppling</italic>-aligned modes for the Cape Verde dataset (<italic toggle="yes">K</italic> from 2 to 5), using the mean memberships as mode consensus and the “direct” approach to alignment across <italic toggle="yes">K</italic> values. The multipartite graph shows the alignment across different <italic toggle="yes">K</italic>. Edges are colored by the edge weight [<xref rid="E18" ref-type="disp-formula">Equation (17)]</xref>; darker color indicates a larger weight and thus better alignment. The numbers on the edges are the optimal solutions for pairwise alignments, representing minimum values in <xref rid="E13" ref-type="disp-formula">Equation (12)</xref>. Each structure plot displays a mode, where the modes for the same <italic toggle="yes">K</italic> appear in decreasing order by their size—marked in parentheses above the top right corner of each plot—and then their within-mode similarity (if there is a tie in size).</p>
        </caption>
        <graphic xlink:href="btad751f1" position="float"/>
      </fig>
      <p>For the chicken dataset, for each <italic toggle="yes">K</italic>, alignments based on mean memberships for the mode consensus and the “direct” approach for alignment across <italic toggle="yes">K</italic> values appear in <xref rid="btad751-F2" ref-type="fig">Fig. 2</xref>. An additional analysis of alignments across non-consecutive <italic toggle="yes">K</italic> values appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S2</xref>.</p>
      <fig position="float" id="btad751-F2">
        <label>Figure 2.</label>
        <caption>
          <p><italic toggle="yes">Clumppling</italic>-aligned modes for the chicken dataset (<italic toggle="yes">K</italic> from 17 to 21), using the mean memberships as mode consensus and the “direct” approach to alignment across <italic toggle="yes">K</italic> values. The figure design follows <xref rid="btad751-F1" ref-type="fig">Figure 1</xref>.</p>
        </caption>
        <graphic xlink:href="btad751f2" position="float"/>
      </fig>
      <p>For comparison, we ran <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>. <italic toggle="yes">Clumpak</italic> uses the <italic toggle="yes">LargeKGreedy</italic> algorithm of <italic toggle="yes">Clumpp</italic> to align replicates for fixed <italic toggle="yes">K</italic> values. In the MCL algorithm, it uses a threshold automatically generated from the graph properties to control inclusion of edges of the graph. It uses the <italic toggle="yes">Distruct for many K’s</italic> feature to align single results—major modes—for different <italic toggle="yes">K</italic> values. <italic toggle="yes">Clumpak</italic> alignment results appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S3</xref>.</p>
      <p>We ran <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>) using its sum-squared distance metric for calculating the similarity between clusters; we chose the sum-squared distance rather than the Jaccard similarity in <italic toggle="yes">Pong</italic>, as it is closer to the objective used by <italic toggle="yes">Clumppling</italic>. A fixed threshold of 0.9 is chosen for the Cape Verde data and 0.955 for the chicken data to exclude edges with weights below the threshold from the pairwise similarity graph of replicates for mode detection. We chose these values to be lower than the <italic toggle="yes">Pong</italic> default of 0.97 in order to avoid producing large numbers of singleton modes. When identifying disjoint cliques in the graph of pairwise similarities for mode detection, we used the <italic toggle="yes">Pong</italic> default greedy approach to iteratively remove the maximal clique from the graph if no disjoint cliques are found. Alignment results for <italic toggle="yes">Pong</italic> appear in <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S4</xref> and <xref rid="sup1" ref-type="supplementary-material">S5</xref>.</p>
      <p>For within-<italic toggle="yes">K</italic> alignments, the performance of <italic toggle="yes">Clumppling</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> appears for Cape Verde in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>; <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref> shows the numbers of replicates detected within modes by the three methods for the two datasets. <xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S3</xref> and <xref rid="sup1" ref-type="supplementary-material">S4</xref> show corresponding results for the chicken dataset. For between-<italic toggle="yes">K</italic> alignments, <italic toggle="yes">Clumppling</italic> is evaluated in each of four combinations: using representative or average memberships, and using the “merge” and “direct” approaches to alignment. The performance of <italic toggle="yes">Clumppling</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> in across-<italic toggle="yes">K</italic> alignments for the Cape Verde dataset appears in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref> and for the chicken dataset in <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>.</p>
    </sec>
    <sec>
      <title>4.4 Performance for within-<italic toggle="yes">K</italic> alignment</title>
      <p>In the Cape Verde dataset, for <inline-formula id="IE230"><mml:math id="IM230" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE231"><mml:math id="IM231" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>, all three methods find a single mode (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S2</xref>). No singletons are observed, and the singleton-excluded weighted similarity score <inline-formula id="IE232"><mml:math id="IM232" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mi>H</mml:mi><mml:mo>˜</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> is 1 for all three methods (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S1</xref>). For <inline-formula id="IE233"><mml:math id="IM233" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula>, although <italic toggle="yes">Clumpak</italic> gives the largest score, this score discards 11 singletons. For <inline-formula id="IE234"><mml:math id="IM234" display="inline" overflow="scroll"><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">Clumppling</italic> has the fewest modes and the largest within-mode similarity between replicates.</p>
      <p>In the chicken dataset, at different values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> achieves consistently greater values of the singleton-excluded similarity score (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>). It does so while finding no singleton modes; the other two methods both identify singletons at most values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>).</p>
    </sec>
    <sec>
      <title>4.5 Performance for across<italic toggle="yes">-K</italic> alignment</title>
      <p>In the Cape Verde dataset, across-<italic toggle="yes">K</italic> alignments have comparable performance for the various methods, with high similarity scores (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S5</xref>). In the more challenging chicken dataset, with larger values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> produces the largest similarity scores between the most closely aligned pair of modes at consecutive values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>). The choice of the “representative” approach for mode consensus and the “merge” approach for cluster alignment gives the highest scores, but the three other choices all produce large values for the score as well. <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic> achieve comparably high scores only in one of four transitions between <italic toggle="yes">K</italic> values (20–21 for <italic toggle="yes">Clumpak</italic>, 17–18 for <italic toggle="yes">Pong</italic>).</p>
    </sec>
    <sec>
      <title>4.6 Run time</title>
      <p>Run time with <italic toggle="yes">Clumppling</italic> (using the “direct” approach) is comparable to <italic toggle="yes">Pong</italic>; both are faster than <italic toggle="yes">Clumpak</italic>. In <italic toggle="yes">Clumppling</italic>, the “direct” approach is faster than the “merge” approach. A detailed comparison of the run time for the three methods appears in Supplementary Results and <xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>.</p>
    </sec>
  </sec>
  <sec>
    <title>5 Discussion</title>
    <p><italic toggle="yes">Clumppling</italic> is a new method for aligning replicate mixed-membership unsupervised clustering analyses. Building upon <italic toggle="yes">Clumpp</italic> (<xref rid="btad751-B9" ref-type="bibr">Jakobsson and Rosenberg 2007</xref>), <italic toggle="yes">Clumpak</italic> (<xref rid="btad751-B11" ref-type="bibr">Kopelman <italic toggle="yes">et al.</italic> 2015</xref>), and <italic toggle="yes">Pong</italic> (<xref rid="btad751-B3" ref-type="bibr">Behr <italic toggle="yes">et al.</italic> 2016</xref>), it performs alignment tasks that have not been addressed by earlier methods—alignment of all modes for one value of <italic toggle="yes">K</italic> with all modes of another value of <italic toggle="yes">K</italic>, and alignment of modes across nonconsecutive <italic toggle="yes">K</italic> values. <italic toggle="yes">Clumppling</italic> applies algorithms from combinatorial optimization and network theory in producing similar alignments to those obtained by the other methods (<xref rid="btad751-F1" ref-type="fig">Figs 1</xref> and <xref rid="btad751-F2" ref-type="fig">2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3–S5</xref>), often with higher values of a similarity score for replicates within modes at fixed <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1</xref> and <xref rid="sup1" ref-type="supplementary-material">S3</xref>) or modes at consecutive <italic toggle="yes">K</italic> values (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S5</xref> and <xref rid="sup1" ref-type="supplementary-material">S6</xref>), and in comparable or reduced computation time (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>). Thus, it compares favorably with other methods in terms of its novel features, algorithmic justification, performance measures, and run time.</p>
    <sec>
      <title>5.1 Algorithmic innovations</title>
      <p><italic toggle="yes">Clumppling</italic> introduces methodological advances for cluster alignment. Though <italic toggle="yes">Pong</italic> previously described the alignment problem as a standard combinatorial optimization problem, the <italic toggle="yes">Clumppling</italic> ILP formulation of the alignment of two replicates allows it to capitalize on efficiencies of ILP solvers. Hence, <italic toggle="yes">Clumppling</italic> is comparable in speed to <italic toggle="yes">Pong</italic>.</p>
      <p>The ILP formulation also enables <italic toggle="yes">Clumppling</italic> to address new scenarios not covered by <italic toggle="yes">Pong</italic>. In particular, the many-to-one matching that it permits for clustering replicates with different values of the number of clusters makes it possible for <italic toggle="yes">Clumppling</italic> to perform alignments across values of <italic toggle="yes">K</italic>, including across nonconsecutive values. Such alignments can be useful, e.g. in analyses for which <italic toggle="yes">K</italic> extends over a large range (<xref rid="btad751-B8" ref-type="bibr">Funk <italic toggle="yes">et al.</italic> 2020</xref>); for large datasets in which computation is slow, it may be sensible to perform exploratory clustering with select values of <italic toggle="yes">K</italic>—say, every fifth value—to then summarize with <italic toggle="yes">Clumppling</italic>, and only then, if necessary, to consider consecutive <italic toggle="yes">K</italic> in a meaningful range.</p>
      <p>Finally, combining the advance from <italic toggle="yes">Pong</italic> in formulating cluster alignment in terms of a classic setting in optimization with the advance from <italic toggle="yes">Clumpak</italic> of using community detection algorithms, <italic toggle="yes">Clumppling</italic> is able to perform a more comprehensive analysis of all observed modes. In particular, <italic toggle="yes">Clumppling</italic> aligns all modes across <italic toggle="yes">K</italic> values, rather than aligning only single modes at each <italic toggle="yes">K</italic> value, as in <italic toggle="yes">Clumpak</italic> and <italic toggle="yes">Pong</italic>. This alignment is informative to clarify clustering patterns in scenarios in which multimodality arises as <italic toggle="yes">K</italic> is increased but a major mode reappears as <italic toggle="yes">K</italic> is increased still further (e.g. Fig. 7 of <xref rid="btad751-B23" ref-type="bibr">Wang <italic toggle="yes">et al.</italic> 2007</xref>).</p>
      <p>The formalization of the cluster alignment problem here establishes a framework for further enhancement. By clarifying the components of the problem—pairwise alignment of replicates at fixed <italic toggle="yes">K</italic> (step 2a), mode detection at fixed <italic toggle="yes">K</italic> (step 2b), defining the consensus of modes (step 2c), and aligning modes across <italic toggle="yes">K</italic> (step 3)—each component can be separately investigated. Optimization methods other than the ILP branch-and-cut algorithm and network-based clustering methods other than the Louvain algorithm can be further tested for improvements in their associated steps.</p>
    </sec>
    <sec>
      <title>5.2 Empirical performance</title>
      <p>The performance differences in our empirical examples are relatively small. In the Cape Verde example, alignments were clear across the methods, all of which performed comparably (<xref rid="sup1" ref-type="supplementary-material">Supplementary Tables S1</xref>, <xref rid="sup1" ref-type="supplementary-material">S2</xref>, and <xref rid="sup1" ref-type="supplementary-material">S5</xref>). In our more difficult chicken example, <italic toggle="yes">Clumppling</italic> produced the highest value for the mean similarity of replicates within modes (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S3</xref>), identified the fewest singletons (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S4</xref>), and produced the highest similarity scores between modes with consecutive values of <italic toggle="yes">K</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S6</xref>). In both cases, the modes themselves are similar across methods (<xref rid="btad751-F1" ref-type="fig">Fig. 1</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3A, S4A, and S5A</xref> for Cape Verde, and <xref rid="btad751-F2" ref-type="fig">Fig. 2</xref> and <xref rid="sup1" ref-type="supplementary-material">Supplementary Figs S3B, S4B, and S5B</xref> for chickens).</p>
      <p>Together, <italic toggle="yes">Clumpp</italic>, <italic toggle="yes">Clumpak</italic>, and <italic toggle="yes">Pong</italic> have been widely used, all performing well in typical empirical settings. When clustering algorithms uncover clear structure—e.g. with replicable co-clustering of some individuals in one cluster and other individuals in another—the proper alignment is often clear, and it is likely to be found by all methods. In a modeling study describing alignment cost under a Dirichlet model, we have found that a correct permutation often has cost far below that of the other permutations (<xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> 2022</xref>). <italic toggle="yes">Clumppling</italic> can be added to the list of methods that can be used to find this permutation.</p>
    </sec>
    <sec>
      <title>5.3 Methodological choices and extensions</title>
      <p>In developing <italic toggle="yes">Clumppling</italic>, we have made decisions about a number of methodological trade-offs. For the pairwise alignment step, <italic toggle="yes">Pong</italic> previously used the polynomial-time Hungarian algorithm for alignments at a fixed value of <italic toggle="yes">K</italic>. In <italic toggle="yes">Clumppling</italic>, we have chosen to use ILP, which is not polynomial-time and can be slower than the approach of <italic toggle="yes">Pong</italic>, though still faster than <italic toggle="yes">Clumpak</italic> (<xref rid="sup1" ref-type="supplementary-material">Supplementary Table S7</xref>). However, ILP offers the ability to facilitate alignments across both consecutive and nonconsecutive values of <italic toggle="yes">K</italic>; <italic toggle="yes">Pong</italic> accommodates only consecutive values.</p>
      <p>For the alignment cost function, our framework allows any dissimilarity measure between replicates as the objective for the ILP problem—provided that it is a linear combination of pairwise between-cluster dissimilarities. Our specific quadratic function of entries in two membership matrices is grounded in the analysis of <xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> (2023)</xref>. In particular, if two replicates have the same number of clusters, then the dissimilarity that <italic toggle="yes">Clumppling</italic> seeks to minimize via ILP is exactly (a constant multiple of) the alignment cost from <xref rid="btad751-B12" ref-type="bibr">Liu <italic toggle="yes">et al.</italic> (2023)</xref>.</p>
      <p>Choices in community detection affect the granularity of the modes obtained. In one extreme, each replicate is its own mode; in the other, replicates with truly distinct co-clustering patterns are grouped in the same mode. <italic toggle="yes">Clumppling</italic> follows <italic toggle="yes">Clumpak</italic> in using an adaptable parameter for tuning this granularity. Nevertheless, it is possible that replicates visually distinguishable as belonging to distinct modes might be grouped. Such patterns can sometimes be diagnosed by the appearance of membership vectors that, within individual replicates, are near a permutation of <inline-formula id="IE235"><mml:math id="IM235" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, but that are not near a simplex vertex in the mean of replicates within the mode. In applications, users can increment the “resolution” parameter, e.g. by 0.05 or 0.01, choosing larger values to increase granularity and smaller values to decrease it.</p>
    </sec>
    <sec>
      <title>5.4 Conclusions</title>
      <p>With its formulation of the cluster alignment problem in defined steps, combination of pairwise alignment ideas based on <italic toggle="yes">Pong</italic> and community detection based on <italic toggle="yes">Clumpak</italic>, and addition of new features for mode alignment across values of <italic toggle="yes">K</italic>, <italic toggle="yes">Clumppling</italic> can assist in the many cluster alignments that take place in population-genetic data analysis. Notably, however, mixed-membership clustering, also sometimes known as soft or fuzzy clustering, has broad applications beyond population genetics, including elsewhere in bioinformatics, as well as in image analysis, marketing, and text mining (<xref rid="btad751-B6" ref-type="bibr">De Oliveira and Pedrycz 2007</xref>, <xref rid="btad751-B1" ref-type="bibr">Airoldi <italic toggle="yes">et al.</italic> 2014</xref>). Problems of comparing and visualizing multiple clustering results in a general context have perhaps been of greater interest for hard clustering (<xref rid="btad751-B14" ref-type="bibr">Meilă 2007</xref>, <xref rid="btad751-B25" ref-type="bibr">Zhou <italic toggle="yes">et al.</italic> 2009</xref>, <xref rid="btad751-B13" ref-type="bibr">L’Yi <italic toggle="yes">et al.</italic> 2015</xref>), in which memberships of individuals are assigned to single clusters. For similar problems of soft clustering, the methods from population genetics—<italic toggle="yes">Clumppling</italic> and its predecessors—are available. <italic toggle="yes">Clumppling</italic> can be applied to any membership-based clustering algorithms applied multiple times on the same set of entities, and it potentially has broad applications in diverse uses of mixed-membership cluster analysis.</p>
    </sec>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad751_Supplementary_Data</label>
      <media xlink:href="btad751_supplementary_data.zip">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We thank D. Cotter, E. Lappo, M. Morrison, J. E. Rodríguez Rodríguez, and C. Shiff for assistance in testing the <italic toggle="yes">Clumppling</italic> software.</p>
  </ack>
  <sec>
    <title>Author contributions</title>
    <p>Xiran Liu (Conceptualization [equal], Investigation, Methodology, Software, Writing—original draft [lead], Writing—review &amp; editing [equal]), Naama M. Kopelman (Conceptualization, Writing—review &amp; editing [supporting]), Noah A. Rosenberg (Conceptualization [equal], Investigation, Methodology [supporting], Supervision [lead], Writing—original draft [supporting], Writing—review &amp; editing [equal])</p>
  </sec>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> are available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec sec-type="COI-statement">
    <title>Conflict of interest</title>
    <p>None declared.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>We acknowledge National Institutes of Health grant R01 HG005855 and United States–Israel Binational Science Foundation grant 2017024.</p>
  </sec>
  <sec sec-type="data-availability">
    <title>Data availability</title>
    <p>The software is available as a python package at <ext-link xlink:href="https://github.com/PopGenClustering/Clumppling" ext-link-type="uri">https://github.com/PopGenClustering/Clumppling</ext-link>. The data underlying this article are available in its online <xref rid="sup1" ref-type="supplementary-material">supplementary material</xref>.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad751-B1">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Airoldi</surname><given-names>EM</given-names></string-name>, <string-name><surname>Blei</surname><given-names>D</given-names></string-name>, <string-name><surname>Erosheva</surname><given-names>EA</given-names></string-name></person-group><etal>et al</etal><source>Handbook of Mixed Membership Models and Their Applications</source>. <publisher-loc>Boca Raton, FL</publisher-loc>: <publisher-name>CRC Press</publisher-name>, <year>2014</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Alexander</surname><given-names>DH</given-names></string-name>, <string-name><surname>Novembre</surname><given-names>J</given-names></string-name>, <string-name><surname>Lange</surname><given-names>K.</given-names></string-name></person-group><article-title>Fast model-based estimation of ancestry in unrelated individuals</article-title>. <source>Genome Res</source><year>2009</year>;<volume>19</volume>:<fpage>1655</fpage>–<lpage>64</lpage>.<pub-id pub-id-type="pmid">19648217</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Behr</surname><given-names>AA</given-names></string-name>, <string-name><surname>Liu</surname><given-names>KZ</given-names></string-name>, <string-name><surname>Liu-Fang</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal><article-title>Pong: fast analysis and visualization of latent clusters in population genetic data</article-title>. <source>Bioinformatics</source><year>2016</year>;<volume>32</volume>:<fpage>2817</fpage>–<lpage>23</lpage>.<pub-id pub-id-type="pmid">27283948</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Blondel</surname><given-names>VD</given-names></string-name>, <string-name><surname>Guillaume</surname><given-names>J-L</given-names></string-name>, <string-name><surname>Lambiotte</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Fast unfolding of communities in large networks</article-title>. <source>J Stat Mech</source><year>2008</year>;<volume>2008</volume>:<fpage>P10008</fpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B5">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Burkard</surname><given-names>R</given-names></string-name>, <string-name><surname>Dell’Amico</surname><given-names>M</given-names></string-name>, <string-name><surname>Martello</surname><given-names>S.</given-names></string-name></person-group><source>Assignment Problems</source>. <publisher-loc>Philadelphia</publisher-loc>: <publisher-name>Society for Industrial and Applied Mathematics</publisher-name>, <year>2009</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B6">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>De Oliveira</surname><given-names>JV</given-names></string-name>, <string-name><surname>Pedrycz</surname><given-names>W.</given-names></string-name></person-group><source>Advances in Fuzzy Clustering and its Applications</source>. <publisher-loc>Chichester, United Kingdom</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>2007</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Fortunato</surname><given-names>S.</given-names></string-name></person-group><article-title>Community detection in graphs</article-title>. <source>Phys Rep</source><year>2010</year>;<volume>486</volume>:<fpage>75</fpage>–<lpage>174</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Funk</surname><given-names>SM</given-names></string-name>, <string-name><surname>Guedaoura</surname><given-names>S</given-names></string-name>, <string-name><surname>Juras</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Major inconsistencies of inferred population genetic structure estimated in a large set of domestic horse breeds using microsatellites</article-title>. <source>Ecol Evol</source><year>2020</year>;<volume>10</volume>:<fpage>4261</fpage>–<lpage>79</lpage>.<pub-id pub-id-type="pmid">32489595</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title>Clumpp: a cluster matching and permutation program for dealing with label switching and multimodality in analysis of population structure</article-title>. <source>Bioinformatics</source><year>2007</year>;<volume>23</volume>:<fpage>1801</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">17485429</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Javed</surname><given-names>MA</given-names></string-name>, <string-name><surname>Younis</surname><given-names>MS</given-names></string-name>, <string-name><surname>Latif</surname><given-names>S</given-names></string-name></person-group><etal>et al</etal><article-title>Community detection in networks: a multidisciplinary review</article-title>. <source>Journal of Network and Computer Applications</source><year>2018</year>;<volume>108</volume>:<fpage>87</fpage>–<lpage>111</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Kopelman</surname><given-names>NM</given-names></string-name>, <string-name><surname>Mayzel</surname><given-names>J</given-names></string-name>, <string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Clumpak: a program for identifying clustering modes and packaging population structure inferences across <italic toggle="yes">K</italic></article-title>. <source>Mol Ecol Resour</source><year>2015</year>;<volume>15</volume>:<fpage>1179</fpage>–<lpage>91</lpage>.<pub-id pub-id-type="pmid">25684545</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liu</surname><given-names>X</given-names></string-name>, <string-name><surname>Kopelman</surname><given-names>NM</given-names></string-name>, <string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title>A dirichlet model of alignment cost in mixed-membership unsupervised clustering</article-title>. <source>J Comput Graph Stat</source><year>2023</year>;<volume>32</volume>:<fpage>1145</fpage>–<lpage>59</lpage>.<pub-id pub-id-type="pmid">37982130</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>L'Yi</surname><given-names>S</given-names></string-name>, <string-name><surname>Ko</surname><given-names>B</given-names></string-name>, <string-name><surname>Shin</surname><given-names>D</given-names></string-name></person-group><etal>et al</etal><article-title>XCluSim: a visual analytics tool for interactively comparing multiple clustering results of bioinformatics data</article-title>. <source>BMC Bioinform</source><year>2015</year>;<volume>16</volume>:<fpage>S5</fpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Meilă</surname><given-names>M.</given-names></string-name></person-group><article-title>Comparing clusterings—an information based distance</article-title>. <source>J Multivar Anal</source><year>2007</year>;<volume>98</volume>:<fpage>873</fpage>–<lpage>95</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B15">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Mitchell</surname><given-names>J.</given-names></string-name></person-group><part-title>Branch-and-cut algorithms for combinatorial optimization problems</part-title>. in: Pardalos PM and Resende MGC (eds), <italic toggle="yes">Handbook of Applied Optimization</italic>. <publisher-loc>New York, NY, United States</publisher-loc>: <publisher-name>Oxford University Press</publisher-name>. pp. <fpage>65</fpage>-<lpage>77</lpage>, <year>2002</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Pritchard</surname><given-names>JK</given-names></string-name>, <string-name><surname>Stephens</surname><given-names>M</given-names></string-name>, <string-name><surname>Donnelly</surname><given-names>P.</given-names></string-name></person-group><article-title>Inference of population structure using multilocus genotype data</article-title>. <source>Genetics</source><year>2000</year>;<volume>155</volume>:<fpage>945</fpage>–<lpage>59</lpage>.<pub-id pub-id-type="pmid">10835412</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosenberg</surname><given-names>NA.</given-names></string-name></person-group><article-title><italic toggle="yes">Distruct</italic>: a program for the graphical display of population structure</article-title>. <source>Mol Ecol Notes</source><year>2004</year>;<volume>4</volume>:<fpage>137</fpage>–<lpage>8</lpage>.</mixed-citation>
    </ref>
    <ref id="btad751-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Rosenberg</surname><given-names>NA</given-names></string-name>, <string-name><surname>Burke</surname><given-names>T</given-names></string-name>, <string-name><surname>Elo</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Empirical evaluation of genetic clustering methods using multilocus genotypes from 20 chicken breeds</article-title>. <source>Genetics</source><year>2001</year>;<volume>159</volume>:<fpage>699</fpage>–<lpage>713</lpage>.<pub-id pub-id-type="pmid">11606545</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Schrijver</surname><given-names>A.</given-names></string-name></person-group><source>Theory of Linear and Integer Programming</source>. <publisher-loc>Chichester, United Kingdom</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>1998</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tokuda</surname><given-names>T.</given-names></string-name></person-group><article-title>Statistical test for detecting community structure in real-valued edge-weighted graphs</article-title>. <source>PLoS One</source><year>2018</year>;<volume>13</volume>:<fpage>e0194079</fpage>.<pub-id pub-id-type="pmid">29558487</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B21">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Van Dongen</surname><given-names>SM.</given-names></string-name></person-group><year>2000</year>. Graph clustering by flow simulation. Ph.D. thesis, University of Utrecht.</mixed-citation>
    </ref>
    <ref id="btad751-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Verdu</surname><given-names>P</given-names></string-name>, <string-name><surname>Jewett</surname><given-names>EM</given-names></string-name>, <string-name><surname>Pemberton</surname><given-names>TJ</given-names></string-name></person-group><etal>et al</etal><article-title>Parallel trajectories of genetic and linguistic admixture in a genetically admixed creole population</article-title>. <source>Curr Biol</source><year>2017</year>;<volume>27</volume>:<fpage>2529</fpage>–<lpage>35.</lpage><pub-id pub-id-type="pmid">28803872</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B23">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wang</surname><given-names>S</given-names></string-name>, <string-name><surname>Lewis</surname><given-names>CM</given-names><suffix>Jr</suffix></string-name>, <string-name><surname>Jakobsson</surname><given-names>M</given-names></string-name></person-group><etal>et al</etal><article-title>Genetic variation and population structure in native Americans</article-title>. <source>PLoS Genet</source><year>2007</year>;<volume>3</volume>:<fpage>e185</fpage>.<pub-id pub-id-type="pmid">18039031</pub-id></mixed-citation>
    </ref>
    <ref id="btad751-B24">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Wolsey</surname><given-names>LA.</given-names></string-name></person-group><source>Integer Programming</source>. <publisher-loc>Hoboken, NJ</publisher-loc>: <publisher-name>Wiley</publisher-name>, <year>2020</year>.</mixed-citation>
    </ref>
    <ref id="btad751-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Zhou</surname><given-names>J</given-names></string-name>, <string-name><surname>Konecni</surname><given-names>S</given-names></string-name>, <string-name><surname>Grinstein</surname><given-names>G.</given-names></string-name></person-group> Visually comparing multiple partitions of data with applications to clustering. In: <italic toggle="yes">Visualization and Data Analysis 2009</italic>, vol. <volume>7243</volume>, p. <fpage>157</fpage>–<lpage>168</lpage>. Bellingham, WA, United States: SPIE, <year>2009</year>.</mixed-citation>
    </ref>
  </ref-list>
</back>
