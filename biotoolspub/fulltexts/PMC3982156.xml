<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3982156</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btt760</article-id>
    <article-id pub-id-type="publisher-id">btt760</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group subj-group-type="heading">
          <subject>Phylogenetics</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Optimization strategies for fast detection of positive selection on phylogenetic trees</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Valle</surname>
          <given-names>Mario</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="author-notes" rid="btt760-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Schabauer</surname>
          <given-names>Hannes</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>3</sup>
        </xref>
        <xref ref-type="author-notes" rid="btt760-FN1">
          <sup>†</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Pacher</surname>
          <given-names>Christoph</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>4</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stockinger</surname>
          <given-names>Heinz</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>5</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Stamatakis</surname>
          <given-names>Alexandros</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>6</sup>
        </xref>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>7</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Robinson-Rechavi</surname>
          <given-names>Marc</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Salamin</surname>
          <given-names>Nicolas</given-names>
        </name>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="btt760-AFF1">
          <sup>3</sup>
        </xref>
        <xref ref-type="corresp" rid="btt760-COR1">*</xref>
      </contrib>
      <aff id="btt760-AFF1"><sup>1</sup>Swiss National Supercomputing Centre, Scientific Computing Group, Lugano, Switzerland, <sup>2</sup>Department of Ecology and Evolution, University of Lausanne, Lausanne, Switzerland, <sup>3</sup>SIB Swiss Institute of Bioinformatics, Lausanne, Switzerland, <sup>4</sup>AIT Austrian Institute of Technology, Safety &amp; Security Department, Vienna, Austria, <sup>5</sup>Vital-IT Group, SIB Swiss Institute of Bioinformatics, Lausanne, Switzerland, <sup>6</sup>Heidelberg Institute for Theoretical Studies, Scientific Computing Group and <sup>7</sup>Karlsruhe Institute of Technology, Institute for Theoretical Informatics, Karlsruhe, Germany</aff>
    </contrib-group>
    <author-notes>
      <corresp id="btt760-COR1">*To whom correspondence should be addressed.</corresp>
      <fn id="btt760-FN2">
        <p>Associate Editor: David Posada</p>
      </fn>
      <fn id="btt760-FN1">
        <p><sup>†</sup>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>4</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>2</day>
      <month>1</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>2</day>
      <month>1</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>8</issue>
    <fpage>1129</fpage>
    <lpage>1137</lpage>
    <history>
      <date date-type="received">
        <day>20</day>
        <month>6</month>
        <year>2013</year>
      </date>
      <date date-type="rev-recd">
        <day>19</day>
        <month>12</month>
        <year>2013</year>
      </date>
      <date date-type="accepted">
        <day>23</day>
        <month>12</month>
        <year>2013</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">http://creativecommons.org/licenses/by-nc/3.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> The detection of positive selection is widely used to study gene and genome evolution, but its application remains limited by the high computational cost of existing implementations. We present a series of computational optimizations for more efficient estimation of the likelihood function on large-scale phylogenetic problems. We illustrate our approach using the branch-site model of codon evolution.</p>
      <p><bold>Results:</bold> We introduce novel optimization techniques that substantially outperform both CodeML from the PAML package and our previously optimized sequential version SlimCodeML. These techniques can also be applied to other likelihood-based phylogeny software. Our implementation scales well for large numbers of codons and/or species. It can therefore analyse substantially larger datasets than CodeML. We evaluated FastCodeML on different platforms and measured average sequential speedups of FastCodeML (single-threaded) versus CodeML of up to 5.8, average speedups of FastCodeML (multi-threaded) versus CodeML on a single node (shared memory) of up to 36.9 for 12 CPU cores, and average speedups of the distributed FastCodeML versus CodeML of up to 170.9 on eight nodes (96 CPU cores in total).</p>
      <p><bold>Availability and implementation:</bold><ext-link ext-link-type="ftp" xlink:href="ftp://ftp.vital-it.ch/tools/FastCodeML/">ftp://ftp.vital-it.ch/tools/FastCodeML/</ext-link>.</p>
      <p><bold>Contact:</bold><email>selectome@unil.ch</email> or <email>nicolas.salamin@unil.ch</email></p>
    </abstract>
    <counts>
      <page-count count="9"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>The development of evolutionary models has a long tradition in phylogenetics, and recent advances have enhanced our understanding of the molecular mechanisms involved. At the heart of these advances is the democratization of the use of the likelihood framework, which was made possible by algorithmic developments (<xref rid="btt760-B7" ref-type="bibr">Felsenstein, 1981</xref>) and the wide availability of powerful computing platforms. The surge of genomic data is, however, pushing the limits of current implementations [e.g. (<xref rid="btt760-B22" ref-type="bibr">Rannala and Yang, 2008</xref>)] and demands for the developments of better and more efficient ways to compute the phylogenetic likelihood function (PLF).</p>
    <p>The development of codon models is a good example to illustrate these current challenges and the benefits that can be reached by improving the efficiency of current likelihood calculations (<xref rid="btt760-B9" ref-type="bibr">Gil <italic>et al.</italic>, 2013</xref>). There are clear advantages to use codon models in phylogenetics (<xref rid="btt760-B26" ref-type="bibr">Seo and Kishino, 2008</xref>), but these are currently not widely used because of the large computational burdens involved (<xref rid="btt760-B1" ref-type="bibr">Anisimova and Kosiol, 2009</xref>). Further, the detection of positive selection has been facilitated by the development of new codon models. However, their application to genome-scale data comprising a large number of species, or individuals in the case of population genomic studies, remains challenging. Thus, there exists an urgent need for improved implementations and novel optimization techniques to analyse emerging genomic datasets (<xref rid="btt760-B17" ref-type="bibr">Lemey <italic>et al.</italic>, 2012</xref>; <xref rid="btt760-B19" ref-type="bibr">Murrell <italic>et al.</italic>, 2012</xref>; <xref rid="btt760-B24" ref-type="bibr">Schabauer <italic>et al.</italic>, 2012</xref>).</p>
    <p>The prevalent approach for detecting positive selection in protein-coding genes is to use Markov models of codon substitution to estimate the ratio of non-synonymous to synonymous changes along the branches of a phylogenetic tree (<xref rid="btt760-B34" ref-type="bibr">Yang, 2006</xref>). The branch-site model (BSM) [<xref rid="btt760-B34" ref-type="bibr">Yang, 2006</xref> (Section 8.4); <xref rid="btt760-B37" ref-type="bibr">Zhang <italic>et al.</italic>, 2005</xref>] allows to detect positive selection that affects a subset of codon sites for a subset of branches in a phylogenetic tree. This model is particularly useful to perform interspecific comparisons and is probably the most widely used approach for this specific purpose. The test compares a model that assumes positive selection on one branch or on a set of a priori specified branches (hypothesis <italic>H</italic><sub>1</sub>) with a null model that does not incorporate positive selection (hypothesis <italic>H</italic><sub>0</sub>). If the test is significant, the Bayes Empirical Bayes (BEB) method is used to compute the posterior probability of each particular codon to evolve under positive selection along the specified branches (<xref rid="btt760-B35" ref-type="bibr">Yang <italic>et al.</italic>, 2005</xref>). In CodeML, the test is usually applied iteratively and independently to each branch of a given phylogenetic tree (<xref rid="btt760-B2" ref-type="bibr">Anisimova and Yang, 2007</xref>; <xref rid="btt760-B30" ref-type="bibr">Studer <italic>et al.</italic>, 2008</xref>).</p>
    <p>This approach is compute bound, and although alternatives have recently been proposed, the limiting factor of such analyses still lies with the repeated calls to compute the PLF. For example, the estimation of positive selection on a large genomic vertebrate dataset (<xref rid="btt760-B21" ref-type="bibr">Proux <italic>et al.</italic>, 2009</xref>) shows the enormous computational requirements of such analyses [approx. 100 CPU years for <italic>each</italic> release of the Selectome database (<xref rid="btt760-B15" ref-type="bibr">Kraut <italic>et al.</italic>, 2010</xref>)]. As a consequence, large gene trees, comprising more than 100 sequences, are usually excluded and faster implementations of the BSM are urgently needed. This clearly illustrates the need to further optimize current software and to develop more efficient computational approaches for maximum likelihood inference on phylogenetic trees.</p>
    <p>Several recent studies introduced techniques for efficiently computing positive selection on the branches of a phylogenetic tree. One idea is to use stochastic mapping to count substitutions along the branches of a tree and thereby derive dN/dS ratios (<xref rid="btt760-B6" ref-type="bibr">Dutheil <italic>et al.</italic>, 2012</xref>; <xref rid="btt760-B17" ref-type="bibr">Lemey <italic>et al.</italic>, 2012</xref>). While this approach is fast, it is computationally distinct. Alternatively, new models have been proposed to avoid the likelihood ratio test (LRT) estimation of positive selection for all branches of the tree. Instead, branch assignments are considered as a random effect within a mixed effect framework (<xref rid="btt760-B19" ref-type="bibr">Murrell <italic>et al.</italic>, 2012</xref>). Their model notably differs from the BSM (<xref rid="btt760-B37" ref-type="bibr">Zhang <italic>et al.</italic>, 2005</xref>) in that putative positive selection is not optimized on a priori defined branches, but over a subset of branches which are determined by the software. This technique reduces the computational cost of the test, but the accuracy and robustness of this new model is not yet fully characterized. Moreover, the authors introduced solutions for parallelizing BSM computations, but the parallel approach is not discussed in their article.</p>
    <p>The bottleneck in efficiency of phylogenetic software is commonly the PLF, as the majority of runtime is spent here. In (<xref rid="btt760-B27" ref-type="bibr">Stamatakis, 2011</xref>, p.2), the PLF is reported to consume &gt;95% of total execution time in maximum likelihood and Bayesian tools for phylogenetic tree reconstruction. Although this was estimated when searching for the best tree topology, which is a key component of phylogenetic computations but not the focus of this article, the PLF is still the core element in <italic>all</italic> phylogenetic applications using maximum likelihood. All these areas would therefore benefit from an optimized PLF. Recent discussions have proposed to use data augmentation strategies to speed up the likelihood calculations by using heuristics to simplify the estimation of the conditional vectors at each node (<xref rid="btt760-B23" ref-type="bibr">Rodrigue and Aris-Brosou, 2011</xref>). However, there are still opportunities for improving the PLF with respect to sequential efficiency and parallelization techniques.</p>
    <p>Our main objective is therefore to propose methodological and algorithmic improvements and parallelization strategies to compute the PLF <italic>without</italic> modifying the underlying evolutionary model. Our optimizations and parallelizations yield substantial speedups in the likelihood computations. Hence, we can apply the BSM to large trees of several hundreds of sequences and obtain results in feasible times. These computational optimizations are thus of broad applicability to further likelihood-based phylogenetic software, including but not limited to nucleotide- and amino acid-based phylogenetic analyses in both the maximum likelihood and Bayesian frameworks (<xref rid="btt760-B20" ref-type="bibr">Nielsen, 2005</xref>).</p>
    <sec id="SEC1.1">
      <title>1.1 Number of elementary tree operations</title>
      <p>In the BSM framework, four site classes 0, 1, 2a and 2b are applied to model combinations of purifying selection, neutral evolution, and positive selection on foreground and background branches. When computing hypotheses <italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub>, each site class has its distinct proportion according to its contribution to the overall likelihood (cf. the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btt760/-/DC1">supplementary material</ext-link> for an introduction to the BSM). These proportions only depend on the two parameters <italic>p</italic><sub>0</sub> and <italic>p</italic><sub>1</sub>; each site class has a specific ω value for its selective pressure in the foreground and in the background. <inline-formula><inline-graphic xlink:href="btt760i1.jpg"/></inline-formula> is in the interval (0,1), <inline-formula><inline-graphic xlink:href="btt760i2.jpg"/></inline-formula> and <italic>either</italic>
<inline-formula><inline-graphic xlink:href="btt760i3.jpg"/></inline-formula> (foreground for <italic>H</italic><sub>1</sub>) <italic>or</italic>
<inline-formula><inline-graphic xlink:href="btt760i4.jpg"/></inline-formula> (foreground for <italic>H</italic><sub>0</sub>). <inline-formula><inline-graphic xlink:href="btt760i5.jpg"/></inline-formula> corresponds to <inline-formula><inline-graphic xlink:href="btt760i6.jpg"/></inline-formula>, respectively.</p>
      <p>Computing the likelihood requires computing the transition probabilities for a given branch length <italic>t</italic> by computing the matrix exponential <inline-formula><inline-graphic xlink:href="btt760i7.jpg"/></inline-formula>, where <italic>Q</italic> is the instantaneous substitution rate matrix, <italic>S</italic> is the symmetric codon substitution matrix and Π is the diagonal matrix of codon frequencies. The resulting probability matrix <italic>P<sub>t</sub></italic> is used to update the corresponding conditional probability vector (CPV) <italic>w</italic>, that is, <inline-formula><inline-graphic xlink:href="btt760i8.jpg"/></inline-formula>. Each CPV models the site-wise transition between 61 codon states (universal genetic code) along each branch of the phylogenetic tree. This operation is applied to all sites of the multiple sequence alignment (MSA) and to all nodes of the tree by means of a post-order tree traversal.</p>
      <p>The CPU-intensive computation of the CPV entails the following three computational kernels that operate on real dense matrices (similar to SlimCodeML, see <xref ref-type="sec" rid="SEC2.1.2">Section 2.1.2</xref>): (i) eigendecomposition of a symmetric matrix [see, e.g. (<xref rid="btt760-B3" ref-type="bibr">Bai <italic>et al.</italic>, 2000</xref>)], (ii) multiplication of a matrix by its transpose (resulting in a symmetric matrix) and (iii) multiplication of a symmetric matrix by a vector.</p>
      <sec id="SEC1.1.1">
        <title>1.1.1 How many decompositions?</title>
        <p>To compute <italic>e<sup>Qt</sup></italic> we need to decompose <italic>Q</italic> for each distinct combination of parameters κ (transition to transversion rate), <inline-formula><inline-graphic xlink:href="btt760i9.jpg"/></inline-formula> and ω. The <inline-formula><inline-graphic xlink:href="btt760i10.jpg"/></inline-formula> are constant over site classes and parameter optimization steps; κ may change at each parameter optimization step (but is constant over site classes); ω varies among optimization steps <italic>and</italic> site classes. For each distinct value of ω, <italic>Q</italic> is distinct and therefore needs to be decomposed separately. There are three distinct ω values over all site classes; hence, we need to decompose three <italic>Q</italic> matrices in the first parameter optimization step. For subsequent steps, <inline-formula><inline-graphic xlink:href="btt760i11.jpg"/></inline-formula> remains constant, but <italic>Q</italic><sub>1</sub> may change because of a new κ value. The total number of <italic>Q</italic> decompositions does not depend on the number of branches in the tree nor on the number of sites in the MSA. In the general case, the number of <italic>Q</italic> matrices depends on the number of unique substitution matrices in the model, which can be large in mixture models [e.g. (<xref rid="btt760-B16" ref-type="bibr">Lartillot and Philippe, 2004</xref>; <xref rid="btt760-B33" ref-type="bibr">Venditti <italic>et al.</italic>, 2008</xref>)]. With respect to other evolutionary models, similar optimizations may be applicable.</p>
      </sec>
      <sec id="SEC1.1.2">
        <title>1.1.2 How many matrix–matrix multiplications?</title>
        <p><italic>P<sub>t</sub></italic> has to be computed for each combination of <italic>Q</italic> and <italic>t</italic>. For our case of binary trees, the number of branches in the phylogeny equals <inline-formula><inline-graphic xlink:href="btt760i12.jpg"/></inline-formula> where <italic>n</italic> is the number of extant taxa. For each distinct <italic>Q</italic>, branches have to be computed separately. The BSM applies <italic>Q</italic><sub>0</sub> and <italic>Q</italic><sub>1</sub> to each branch, but <italic>Q</italic><sub>2</sub> only to foreground branches. In other words, <italic>P<sub>t</sub></italic> has to be computed for all branches using <italic>Q</italic><sub>0</sub> and <italic>Q</italic><sub>1</sub> (site classes 0 and 1), <italic>and</italic> in addition on the foreground branch(es) by using <italic>Q</italic><sub>2</sub> (site classes 2a and 2b). Therefore, we need to compute <italic>P<sub>t</sub></italic>
<inline-formula><inline-graphic xlink:href="btt760i13.jpg"/></inline-formula> times for <italic>m</italic> branches in the phylogeny and <italic>l</italic> foreground branches; this yields <inline-formula><inline-graphic xlink:href="btt760i14.jpg"/></inline-formula> branches when using a single foreground branch. Overall, we need to compute 17 distinct <italic>P</italic> matrices in our example 1. This matrix–matrix multiplication is also applied in further evolutionary models based on substitution matrices.</p>
      </sec>
      <sec id="SEC1.1.3">
        <title>1.1.3 How many matrix–vector computations?</title>
        <p>In a straightforward approach, each CPV is computed along each branch for all sites and all site classes. In our example this makes <inline-formula><inline-graphic xlink:href="btt760i15.jpg"/></inline-formula> CPV computations. If a CPV connected to a leaf is computed on ‘clean’ data [no ambiguity symbols in MSA (<xref rid="btt760-B4" ref-type="bibr">Comnish-Bowden, 1985</xref>)], the CPV at the leaf only contains a single 1 (0 elsewhere). In this case, computing the resulting CPV simplifies to selecting the corresponding column of the P matrix. In the general case, an upper limit of the number of involved matrix–vector multiplications per site class is the number of branches in the phylogeny × the number of sites in the MSA. Certainly, this number can be decreased depending on similarities in the codons as discussed in <xref ref-type="sec" rid="SEC2.1.1">Section 2.1.1</xref> (‘subtrees reuse’). Likewise, this step is important to all other evolutionary models based on substitution matrices.</p>
        <p>Further computational savings are possible. In this context, we refer to a ‘subtree’ as a connected part of the phylogeny where at least one node is a leaf. Whenever a particular branch of a single site applies the same <italic>P</italic> and all other CPVs of its subtree match, the particular CPV has a ‘twin’ in another site class and needs to be computed only once. In <xref ref-type="fig" rid="btt760-F1">Figure 1</xref>, such matching CPVs are identified by matching indexes. For example, CPV23 appears in site class 1 and in site class 2b, as also CPV20 and CPV21 have twins, and they pairwise apply matching <italic>P</italic> matrices (here, all based on <italic>Q</italic><sub>1</sub>). These redundancies are caused by matching <inline-formula><inline-graphic xlink:href="btt760i18.jpg"/></inline-formula> values for site classes 0 and 2a and by matching <inline-formula><inline-graphic xlink:href="btt760i19.jpg"/></inline-formula> values for site classes 1 and 2b. In our example, this means that only 40 out of 64 (62.5%) CPVs have distinct values and will hence have to be computed. CPVs are computed recursively via a postorder traversal propagating from the leaves towards the root (<xref rid="btt760-B7" ref-type="bibr">Felsenstein, 1981</xref>). Hence, for the BSM in general, the number of distinct CPVs depends on the location of the foreground branch in the tree (the closer to the root, the less CPV computations are required).
<fig id="btt760-F1" position="float"><label>Fig. 1.</label><caption><p>Analysis on how many elementary subtree computations are necessary in the branch-site model; CPV<italic>m</italic> correspond to <italic>m</italic> distinct conditional probability vectors, where matching <italic>m</italic> need to be computed only once; Q<inline-formula><inline-graphic xlink:href="btt760i16.jpg"/></inline-formula> identify three distinct Q matrices for distinct <inline-formula><inline-graphic xlink:href="btt760i17.jpg"/></inline-formula> values</p></caption><graphic xlink:href="btt760f1p"/></fig></p>
      </sec>
    </sec>
  </sec>
  <sec id="SEC2">
    <title>2 IMPROVEMENTS</title>
    <p>Here we discuss optimization techniques that we propose. Note that we have not added any heuristics, and each of the following improvements is supposed to be beneficial independent of the number of species and independent of the number of alignment sites. Specific implementation issues are described along with each optimization technique.</p>
    <sec id="SEC2.1">
      <title>2.1 Sequential improvements</title>
      <sec id="SEC2.1.1">
        <title>2.1.1 Subtrees reuse</title>
        <p>The per-site likelihoods for a MSA are independent of each other and can thus be computed in an arbitrary order. If two or more sites of the MSA are identical, it suffices to only compute the logarithmic likelihood (lnL) on one site and multiply it by the number of identical sites to obtain the total lnL. This technique is used in most likelihood-based software, but there are further redundant computations caused by re-occurring patterns in the MSA.</p>
        <p>In each subtree, there is a potential to economize CPV computations for different sites of the MSA. If the same state appears at two or more sites of a sequence, all occurrences yield identical CPVs at the particular leaf. If the patterns of the sub-alignment induced by a subtree match are identical for two or more sites, the corresponding CPVs for the two sites are also identical. However, identical patterns in the sub-alignments induced by a subtree need to be identified first. The identification of such identical patterns in sub-alignments can be done, e.g. by searching (i) sequentially or (ii) using a symbol table (<xref rid="btt760-B25" ref-type="bibr">Sedgewick and Wayne, 2011</xref>, p.361). In the latter case, the <italic>key</italic> is the index of the CPV within the tree, and the <italic>value</italic> associated with the key is its CPV. In the straightforward approach (i), there are no costs on storing values, but up to <italic>m</italic> – 1 lookups for a matching subpattern, where <italic>m</italic> is the length of the MSA. For huge MSAs, it may be advantageous to implement the second approach, where the additional cost for storing or linking site patterns is compensated by a faster lookup. In FastCodeML, we identify reusable subtree patterns in a preprocessing step and tag each node with the codon sequence identified by the subtree rooted in this node. Subsequently, a lookup of these tags for all sites with identical subtrees is done. Once identified, the CPV that can be re-used is linked via a pointer in the reusing tree, that is, this saves the costs of computing this particular CPV. The unused subtree can be freed to reduce memory consumption. In the example of <xref ref-type="fig" rid="btt760-F2">Figure 2</xref>, computing the two CPVs incident to two leaves in box ① and the CPV at <bold>②</bold> are redundant, because both codon sites feature an identical subtree: all involved CPVs match. Thus three CPV computations can be saved.
<fig id="btt760-F2" position="float"><label>Fig. 2.</label><caption><p>Subtrees reuse strategy depicted for two (not necessarily neighboring) sites in the MSA; in (<bold>a</bold>) subtree (1) contains identical codons for both sites; consequently, in (<bold>b</bold>) the CPVs for both sites are identical and need to be computed only once (dotted line)</p></caption><graphic xlink:href="btt760f2p"/></fig></p>
        <p>Related techniques for extending pattern detection and re-use in the MSA to the subtree level have already been proposed (<xref rid="btt760-B12" ref-type="bibr">Izquierdo-Carrasco <italic>et al.</italic>, 2011</xref>; <xref rid="btt760-B29" ref-type="bibr">Stamatakis <italic>et al.</italic>, 2002</xref>; <xref rid="btt760-B31" ref-type="bibr">Sumner and Charleston, 2010</xref>). However, they focus on detecting patterns and avoiding redundant likelihood computations on trees whose topologies change in the course of ML tree search. For dynamically changing trees, a trade-off between the pattern detection and memory storage costs and the amount of saved computations needs to be achieved. To reduce the cost of pattern detection, the initial implementation of the Subtree Equality Vector (SEV) technique (<xref rid="btt760-B29" ref-type="bibr">Stamatakis <italic>et al.</italic>, 2002</xref>) only considered subtree patterns that contained a single identical character. The book keeping was subsequently further simplified to sites consisting entirely of gaps (<xref rid="btt760-B12" ref-type="bibr">Izquierdo-Carrasco <italic>et al.</italic>, 2011</xref>). In <xref rid="btt760-B13" ref-type="bibr">Kosakovsky Pond and Muse (2004)</xref>, the authors suggest to sort nucleotide-based MSAs by site similarity to avoid redundant computations. This approach minimizes memory consumption, as only a subset of sites needs to be kept in memory. However, this incurs additional costs for rearranging the sites in order to maximize the number of lookups from neighboring sites. The memory consumption for our application scenario (Selectome database updates) does not represent a limiting factor. Hence, all CPVs can be kept in memory, avoiding the expensive reordering of sites. However, especially for memory-intensive approaches, it may be more effective to keep only a subset of all CPVs in memory and consider site sorting.</p>
      </sec>
      <sec id="SEC2.1.2">
        <title>2.1.2 New matrix exponential and CPV computation</title>
        <p>In <xref rid="btt760-B24" ref-type="bibr">Schabauer <italic>et al.</italic> (2012)</xref>, we transformed the problem of computing the matrix exponential of non-symmetric <italic>Qt</italic> into a symmetric problem as follows: we define the symmetric matrix <inline-formula><inline-graphic xlink:href="btt760i20.jpg"/></inline-formula> and compute its eigendecomposition <inline-formula><inline-graphic xlink:href="btt760i21.jpg"/></inline-formula>. By introducing <inline-formula><inline-graphic xlink:href="btt760i22.jpg"/></inline-formula>, the matrix exponential of <italic>Qt</italic> becomes <inline-formula><inline-graphic xlink:href="btt760i23.jpg"/></inline-formula>.</p>
        <p>An additional modification transforms the final asymmetric matrix–vector multiplication <inline-formula><inline-graphic xlink:href="btt760i24.jpg"/></inline-formula> into a symmetric matrix–vector product:
<disp-formula id="btt760-M1"><label>(1)</label><graphic xlink:href="btt760m1.jpg" position="float"/></disp-formula>
<disp-formula id="btt760-M2"><label>(2)</label><graphic xlink:href="btt760m2.jpg" position="float"/></disp-formula>
</p>
        <p>Note that <inline-formula><inline-graphic xlink:href="btt760i25.jpg"/></inline-formula> is by construction a symmetric matrix, whereas <inline-formula><inline-graphic xlink:href="btt760i26.jpg"/></inline-formula> is generally asymmetric. The advantage of this modification is that the symmetry reduces the number of necessary matrix memory accesses by approx. 50% (<xref rid="btt760-B10" ref-type="bibr">Golub and Van Loan, 2013</xref>, p.18). This technique has been implemented in FastCodeML.</p>
      </sec>
      <sec id="SEC2.1.3">
        <title>2.1.3 LRT optimization</title>
        <p>When optimizing parameter values for H<sub>0</sub> and H<sub>1</sub> one after the other, one can save on parameter optimization steps. Each step in the parameter optimization procedure improves the associated lnL of the tree until convergence has been reached. In this discussion, the optimizer may modify all parameter values at each single step. One can either (i) optimize H<sub>0</sub> first with high accuracy and iteratively improve H<sub>1</sub> afterwards: once <inline-formula><inline-graphic xlink:href="btt760i27.jpg"/></inline-formula> becomes larger than <inline-formula><inline-graphic xlink:href="btt760i28.jpg"/></inline-formula>, the parameter optimization for H<sub>1</sub> can be stopped because the LRT is already significant. This potentially saves optimization steps for H<sub>1</sub>. Or we can (ii) optimize H<sub>1</sub> first, then proceed analogously: the parameters of H<sub>0</sub> are optimized until <inline-formula><inline-graphic xlink:href="btt760i29.jpg"/></inline-formula> becomes smaller than <inline-formula><inline-graphic xlink:href="btt760i30.jpg"/></inline-formula>. In general, a significant LRT (i.e. detecting positive selection) is a relatively rare event (<xref rid="btt760-B14" ref-type="bibr">Kosiol <italic>et al.</italic>, 2008</xref>; <xref rid="btt760-B30" ref-type="bibr">Studer <italic>et al.</italic>, 2008</xref>). Strategy (i) saves optimization steps if positive selection occurs; strategy (ii) saves optimization steps if not. Consequently, without prior knowledge of the frequency of occurrence of positive selection in the MSA at hand, strategy (ii) (implemented in FastCodeML) will yield larger savings. If the LRT is significant, a BEB is applied to identify the sites under positive selection. Otherwise, FastCodeML does not execute the BEB, in contrast to CodeML. In the general case, this optimization is applicable if different models are compared, where each of them is optimized iteratively.</p>
      </sec>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Parallelization</title>
      <p>While the parallelization of ML-based nucleotide- protein- and codon models has already been addressed (<xref rid="btt760-B27" ref-type="bibr">Stamatakis, 2011</xref>) (e.g. RAxML, IQPNNI, HyPhy), it has mostly been in the context of tree topology optimization, and not for the likelihood itself. The main challenge in parallelizing ML-based phylogeny computations comes from the tree structure that leads to an irregular domain decomposition (<xref rid="btt760-B32" ref-type="bibr">Tomko, 1995</xref>). An efficient parallelization of the BSM is even more challenging due to its site classes and dependencies in between.</p>
      <p>Our implementation optimizes simultaneously all the parameters. The maximizer acts as an impenetrable boundary for parallelization, and we distinguish parallelization ‘above’ (coarse-grain) and ‘within’ (fine-grain) this boundary (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btt760/-/DC1">supplementary material</ext-link>, <xref ref-type="fig" rid="btt760-F1">Fig. 1</xref>).</p>
      <sec id="SEC2.2.1">
        <title>2.2.1 Coarse-grain parallelization:</title>
        <p><italic>Gene-wise </italic><italic>parallelization</italic>. Because distinct genes typically have different evolutionary histories with distinct branch lengths and evolutionary parameters, phylogenies for genes are commonly estimated independently for each gene. Consequently, single genes cannot be concatenated into multi-gene alignments to attain high scalability by means of a fine-grain parallelization of the likelihood function [see, e.g. (<xref rid="btt760-B28" ref-type="bibr">Stamatakis and Ott, 2009</xref>)]. Here we test for selection independently (gene-wise), these analyses can be carried out in an embarrassingly parallel way [see, e.g. (<xref rid="btt760-B8" ref-type="bibr">Foster, 1995</xref>, p.21)].</p>
        <p><italic>Foreground branch </italic><italic>parallelization</italic><italic>.</italic> A further BSM parallelization option is the simultaneous analysis of distinct foreground branches. This is possible because we want to test for positive selection on each branch of a given phylogeny. Thus, the <inline-formula><inline-graphic xlink:href="btt760i31.jpg"/></inline-formula> tests for positive selection, where <italic>n</italic> is the number of taxa, can be conducted in parallel by duplicating the tree data structure and CPVs.</p>
        <p>Under this parallelization strategy, a dedicated master process broadcasts all model parameters, tree topologies and branch lengths to all worker nodes. The workers then conduct the tests independently of each other on different foreground branches of the same tree. Afterwards, the worker nodes return the estimated parameter values and the lnL scores to the master process. We implemented this approach using MPI (<xref rid="btt760-B18" ref-type="bibr">Message Passing Interface Forum, 1994</xref>). The foreground-branch based parallelization can be combined with a site-wise fine-grain parallelization of the per-tree likelihood computations (<xref ref-type="sec" rid="SEC2.2.2">Section 2.2.2</xref>) into a <italic>hybrid</italic> parallelization scheme.</p>
        <p><italic>Hypotheses </italic><italic>parallelization</italic><italic>.</italic> Note that for each foreground branch, hypotheses <italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub> can be computed independently and simultaneously, thus increasing the degree of parallelism. However, the simultaneous computation of <italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub> prevents us from using the aforementioned LRT optimization (<xref ref-type="sec" rid="SEC2.1.3">Section 2.1.3</xref>). Although the LRT and the subsequent BEB must be computed after <italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub>, they can be parallelized between different foreground branch computations. This parallelization strategy can be applied whenever two evolutionary models are compared. It is implemented in FastCodeML via the same master-worker scheme.</p>
      </sec>
      <sec id="SEC2.2.2">
        <title>2.2.2 Fine-grain parallelization:</title>
        <p><italic>Site-wise </italic><italic>parallelization</italic>. A common way to parallelize likelihood computations on shared memory architectures is by parallelizing over the sites of the MSA. This site-wise parallelization can be implemented using OpenMP or POSIX Threads. MPI-based implementations exist but focus on large MSAs that are outside the scope of this article. However, while our subtree patterns re-use scheme (<xref ref-type="sec" rid="SEC2.1.1">Section 2.1.1</xref>) reduces the number of computations along the branches, it poses a load balance challenge: (i) a particular CPV for a site can only be computed after the site whose results it reuses (i.e. data dependency) has been computed and (ii) a site that reuses a previously computed CPV exhibits a smaller workload which leads to load imbalance.</p>
        <p>The load balancing strategy we use in FastCodeML subdivides the alignment sites into groups such that each group exclusively reuses subtrees from the previous groups (<xref ref-type="fig" rid="btt760-F3">Fig. 3</xref>). Each group is assigned a rank value starting from zero. CPVs from groups with lower rank values can potentially be reused. The first group does not reuse any subtree. All subtrees of a group can be parallelized, because they are independent of each other. The groups are then computed sequentially in order of rank. To balance the load for each group, subtrees can be moved to higher ranked groups. To increase parallelism, the trees of each group are replicated for each site class that should be computed until no lower rank group depends on it. The parallelization inside each group has been implemented using OpenMP.
<fig id="btt760-F3" position="float"><label>Fig. 3.</label><caption><p>Load balancing strategy: the sites of the tree are grouped so that each group depends only on groups at its left (continuous lines). A tree can be moved to a group to its right (dashed line) only if it has no dependencies from other trees in intermediate groups</p></caption><graphic xlink:href="btt760f3p"/></fig></p>
        <p>This site-wise parallelization strategy including load balancing can likewise be applied to nucleotide- or protein-based MSAs. The parallel performance may vary due to different computational load per site.</p>
      </sec>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Implementation</title>
      <p>FastCodeML has been implemented from scratch (except for the BEB that was largely taken from the CodeML codebase) in ISO C++ 2003 utilizing BLAS and LAPACK for linear algebra operations, and Spirit (<ext-link ext-link-type="uri" xlink:href="http://www.boost.org/doc/libs/release/libs/spirit/">http://www.boost.org/doc/libs/release/libs/spirit/</ext-link>) for tree parsing. We use the parameter optimization codebase of CodeML.</p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 EVALUATION</title>
    <p>We measure median runtimes of 10 individual runs for each evaluation (three on the large scale analysis in <xref ref-type="sec" rid="SEC3.5">Section 3.5</xref>). Speedup values are determined by <inline-formula><inline-graphic xlink:href="btt760i32.jpg"/></inline-formula>, where <italic>T</italic><sub>1</sub> is the runtime (elapsed time, wall-clock time) of the reference execution and <italic>T</italic><sub>2</sub> the runtime of the execution to be evaluated on the same dataset; for a <italic>relative</italic> speedup <italic>T</italic><sub>1</sub> and <italic>T</italic><sub>2</sub> denominate runtimes of the same executable, while for the <italic>absolute</italic> speedup <italic>T</italic><sub>1</sub> is strictly the original CodeML. Initial branch lengths were read from file, while model parameters are initialized randomly. Memory consumption of CodeML, SlimCodeML and FastCodeML for these datasets is not a limiting factor and therefore not performance critical. Although a single executable can be used for all subsequent evaluations, we built sequential, OpenMP parallelized, MPI parallelized and hybrid executables separately. A summary of the platforms used can be found in the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btt760/-/DC1">supplementary material</ext-link>.</p>
    <sec id="SEC3.1">
      <title>3.1 Datasets</title>
      <p><xref ref-type="table" rid="btt760-T1">Table 1</xref> contains the six datasets we used for evaluation. With respect to the Selectome database, these empirical datasets are representative for the cases: (D1) small number of species/medium sequence length; (D2) small number of species/large sequence length; (D3) medium number of species/small sequence length; (D4) large number of species/short sequence length; (D5) a simulated dataset with positive selection based on dataset D1 (using PAML’s evolver choosing ‘evolverNSbranchsites’ for the BSM with <inline-formula><inline-graphic xlink:href="btt760i34.jpg"/></inline-formula>). Finally, we analyse in D6 a very large rbcL dataset (<xref rid="btt760-B11" ref-type="bibr">Grass Phylogeny Working Group II, 2012</xref>) which cannot be processed in a feasible time by CodeML.
<table-wrap id="btt760-T1" position="float"><label>Table 1.</label><caption><p>Test datasets of our analyses; remaining branches is the percentage of non-redundant branches for the given data over all sites of the alignment; dataset D5 is generated based on ENSGT00390000016702.Primates.1 with <inline-formula><inline-graphic xlink:href="btt760i33.jpg"/></inline-formula></p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Abbr.</th><th rowspan="1" colspan="1">Full name</th><th rowspan="1" colspan="1">No. of species</th><th rowspan="1" colspan="1">No. of branches</th><th rowspan="1" colspan="1">Remaining branches [%]</th><th rowspan="1" colspan="1">Length (codons)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">D1</td><td rowspan="1" colspan="1">ENSGT00390000016702.Primates.1</td><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1">37.74</td><td rowspan="1" colspan="1">299</td></tr><tr><td rowspan="1" colspan="1">D2</td><td rowspan="1" colspan="1">ENSGT00530000063518.Primates.1</td><td rowspan="1" colspan="1">95</td><td rowspan="1" colspan="1">188</td><td rowspan="1" colspan="1">75.49</td><td rowspan="1" colspan="1">39</td></tr><tr><td rowspan="1" colspan="1">D3</td><td rowspan="1" colspan="1">ENSGT00550000073950.Euteleostomi.7</td><td rowspan="1" colspan="1">25</td><td rowspan="1" colspan="1">48</td><td rowspan="1" colspan="1">56.31</td><td rowspan="1" colspan="1">67</td></tr><tr><td rowspan="1" colspan="1">D4</td><td rowspan="1" colspan="1">ENSGT00580000081590.Primates.1</td><td rowspan="1" colspan="1">6</td><td rowspan="1" colspan="1">10</td><td rowspan="1" colspan="1">20.92</td><td rowspan="1" colspan="1">5004</td></tr><tr><td rowspan="1" colspan="1">D5</td><td rowspan="1" colspan="1">Generated by evolver (PAML)</td><td rowspan="1" colspan="1">7</td><td rowspan="1" colspan="1">12</td><td rowspan="1" colspan="1">38.04</td><td rowspan="1" colspan="1">282</td></tr><tr><td rowspan="1" colspan="1">D6</td><td rowspan="1" colspan="1">Grass_rbcL</td><td rowspan="1" colspan="1">506</td><td rowspan="1" colspan="1">1242</td><td rowspan="1" colspan="1">19.54</td><td rowspan="1" colspan="1">414</td></tr></tbody></table></table-wrap></p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Accuracy</title>
      <p>In <xref ref-type="table" rid="btt760-T2">Table 2</xref> we analyse the accuracy of FastCodeml with respect to lnLs and LRT scores. We use SlimCodeML as a proxy for good accuracy, as it gives very similar results as CodeML (<xref rid="btt760-B24" ref-type="bibr">Schabauer <italic>et al.</italic>, 2012</xref>), which is the established gold standard. We note that the accuracy of computed lnLs is much higher than typically required to discriminate between significant and insignificant LRTs.
<table-wrap id="btt760-T2" position="float"><label>Table 2.</label><caption><p>Accuracy of SlimCodeML and FastCodeml on Macpro; <inline-formula><inline-graphic xlink:href="btt760i35.jpg"/></inline-formula> is the absolute difference of lnLs comparing either SlimCodeML or FastCodeML with CodeML on <italic>H</italic><sub>0</sub> (<italic>H</italic><sub>1</sub>), respectively</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1"/><th rowspan="1" colspan="1">Dataset</th><th rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i36.jpg"/></inline-formula></th><th rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i37.jpg"/></inline-formula></th><th rowspan="1" colspan="1">LRT</th><th rowspan="1" colspan="1">pos. selection</th></tr></thead><tbody align="left"><tr><td rowspan="5" colspan="1">SlimCode versus CodeML</td><td rowspan="1" colspan="1">D1</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i38.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i39.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i40.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D2</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i41.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i42.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i43.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D3</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i44.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i45.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i46.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D4</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i47.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i48.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i49.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D5</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i50.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i51.jpg"/></inline-formula></td><td rowspan="1" colspan="1">10.4</td><td rowspan="1" colspan="1">site 239 (✓)</td></tr><tr><td rowspan="5" colspan="1">FastCodeML versus CodeML</td><td rowspan="1" colspan="1">D1</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i52.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i53.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i54.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D2</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i55.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i56.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i57.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D3</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i58.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i59.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i60.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D4</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i61.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i62.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i63.jpg"/></inline-formula></td><td rowspan="1" colspan="1">no (✓)</td></tr><tr><td rowspan="1" colspan="1">D5</td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i64.jpg"/></inline-formula></td><td rowspan="1" colspan="1"><inline-formula><inline-graphic xlink:href="btt760i65.jpg"/></inline-formula></td><td rowspan="1" colspan="1">10.4</td><td rowspan="1" colspan="1">site 239 (✓)</td></tr></tbody></table><table-wrap-foot><fn id="btt760-TF1"><p><italic>Note</italic>: ‘✓’ indicates agreement of the computed result with CodeML.</p></fn></table-wrap-foot></table-wrap></p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Sequential runtimes</title>
      <p>Sequential speedups of FastCodeML (single-threaded) versus CodeML and SlimCodeML for five datasets (<italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub>, respectively) on platform Macpro (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btt760/-/DC1">supplementary material</ext-link>) are depicted in <xref ref-type="fig" rid="btt760-F4">Figure 4</xref>; here, FastCodeML includes the following improvements: faster matrix exponentiation (<xref ref-type="sec" rid="SEC2.1.2">Section 2.1.2</xref>) and subtrees reuse (<xref ref-type="sec" rid="SEC2.1.1">Section 2.1.1</xref>). LRT optimization (<xref ref-type="sec" rid="SEC2.1.3">Section 2.1.3</xref>) is not considered, as either <italic>H</italic><sub>0</sub> or <italic>H</italic><sub>1</sub> is computed per run. We observe speedups of FastCodeML versus CodeML ranging from 2.6 to 5.8. The sequential FastCodeML is significantly faster than both CodeML and SlimCodeML on all five datasets.
<fig id="btt760-F4" position="float"><label>Fig. 4.</label><caption><p>Sequential speedups of FastCodeML in comparison with CodeML and SlimCodeML on Macpro for <italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub>, respectively</p></caption><graphic xlink:href="btt760f4p"/></fig></p>
    </sec>
    <sec id="SEC3.4">
      <title>3.4 Parallel runtimes</title>
      <sec id="SEC3.4.1">
        <title>3.4.1 Site-wise parallelization</title>
        <p><xref ref-type="fig" rid="btt760-F5">Figure 5</xref> shows the scaling of FastCodeML on a site-wise (OpenMP based) parallelization strategy for dataset D2 on 1–12 CPU cores (one thread per core); we observe relative speedups comparing FastCodeML in <inline-formula><inline-graphic xlink:href="btt760i66.jpg"/></inline-formula> versus 1 threads, reaching 11.1 for 12 cores without subtrees reuse, and speedups up to 7.6 for 12 cores with subtrees reuse. These relative speedups correspond to absolute speedups versus CodeML of up to 23.4 without subtrees reuse, and speedups up to 19.9 with subtrees reuse. While scaling of subtrees reuse is slightly worse than without subtrees reuse, absolute runtimes on this particular platform and dataset suggest to enable subtrees reuse on 1–11 cores but not on 12. The worse scaling of subtrees reuse is presumably caused by load imbalance. Due to differences in the sequential performance of subtrees reuse, we also expect the performance of parallel subtrees reuse to vary with different datasets. In general, the effectiveness of parallel subtrees reuse is a trade-off between the number of redundant branches versus the data dependencies introduced.
<fig id="btt760-F5" position="float"><label>Fig. 5.</label><caption><p>Parallel site-wise relative (<italic>top</italic>) and absolute (<italic>bottom</italic>) speedups of FastCodeML on Castor on dataset D2 for <italic>H</italic><sub>1</sub></p></caption><graphic xlink:href="btt760f5p"/></fig></p>
      </sec>
      <sec id="SEC3.4.2">
        <title>3.4.2 Foreground branch-based parallelization</title>
        <p><xref ref-type="fig" rid="btt760-F6">Figure 6</xref> depicts the relative scaling of FastCodeML on a foreground-branch based parallelization strategy. The evaluation has been done for dataset D3 on 1–7 worker nodes (single thread per node). Due to the master–worker scheme used, performance gains are observed for two or more worker nodes. The analysis is done for all possible 22 foreground branches, where the runtime for CodeML is measured only on a single foreground branch but multiplied by 22; running CodeML on all foreground branches is expected to consume more than a day. We observe relative speedups of up to 5.9 on 7 worker nodes, which corresponds to absolute speedups from 3.3 to 19.4. In general, the relative speedup for foreground branch-based parallelizations benefits from a high ratio of foreground branches to available nodes, as the workload can more easily be divided into balanced parts.
<fig id="btt760-F6" position="float"><label>Fig. 6.</label><caption><p>Parallel foreground branch (MPI based) relative speedups of FastCodeML for dataset D3 on Castor for <italic>H</italic><sub>1</sub>; only a <italic>single</italic> CPU core per node was used</p></caption><graphic xlink:href="btt760f6p"/></fig></p>
      </sec>
      <sec id="SEC3.4.3">
        <title>3.4.3 Hybrid parallelization</title>
        <p><xref ref-type="fig" rid="btt760-F7">Figure 7</xref> depicts absolute scaling of FastCodeML on a hybrid (foreground branch and site-wise) parallelization strategy implemented using OpenMP and MPI on 1–7 worker nodes, where all 12 CPU cores are used. Corresponding runtimes, relative and absolute speedup values are summarized in <xref ref-type="table" rid="btt760-T3">Table 3</xref>. We observe relative speedups up to 6.3 on 7 worker nodes, which corresponds to absolute speedups up to 170.9.
<fig id="btt760-F7" position="float"><label>Fig. 7.</label><caption><p>Parallel hybrid (OpenMP and MPI based) scaling of FastCodeML for dataset D3 on Castor for <italic>H</italic><sub>1</sub></p></caption><graphic xlink:href="btt760f7p"/></fig>
<table-wrap id="btt760-T3" position="float"><label>Table 3.</label><caption><p>Overall parallel performance of FastCodeml versus CodeML on Castor for dataset D3 on all possible foreground branches for <italic>H</italic><sub>1</sub>; CodeML runtime for absolute speedups is extrapolated from computing a single foreground branch</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Worker nodes (cores)</th><th rowspan="1" colspan="1">FastCodeML runtime [s]</th><th rowspan="1" colspan="1">Rel. speedup</th><th rowspan="1" colspan="1">Abs. speedup</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">1 (12)</td><td rowspan="1" colspan="1">429</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">27.6</td></tr><tr><td rowspan="1" colspan="1">2 (24)</td><td rowspan="1" colspan="1">218</td><td rowspan="1" colspan="1">2</td><td rowspan="1" colspan="1">54.2</td></tr><tr><td rowspan="1" colspan="1">3 (36)</td><td rowspan="1" colspan="1">151</td><td rowspan="1" colspan="1">2.9</td><td rowspan="1" colspan="1">78.4</td></tr><tr><td rowspan="1" colspan="1">4 (48)</td><td rowspan="1" colspan="1">114</td><td rowspan="1" colspan="1">3.8</td><td rowspan="1" colspan="1">103.7</td></tr><tr><td rowspan="1" colspan="1">5 (60)</td><td rowspan="1" colspan="1">93</td><td rowspan="1" colspan="1">4.7</td><td rowspan="1" colspan="1">126.5</td></tr><tr><td rowspan="1" colspan="1">6 (72)</td><td rowspan="1" colspan="1">81</td><td rowspan="1" colspan="1">5.4</td><td rowspan="1" colspan="1">145.3</td></tr><tr><td rowspan="1" colspan="1">7 (84)</td><td rowspan="1" colspan="1">69</td><td rowspan="1" colspan="1">6.3</td><td rowspan="1" colspan="1">170.9</td></tr></tbody></table></table-wrap></p>
      </sec>
    </sec>
    <sec id="SEC3.5">
      <title>3.5 Large scale analysis</title>
      <p>A large scale analysis has been conducted to prove the use of FastCodeML beyond the capabilities of CodeML. In initial tests, we verified that dataset D6 achieves its best runtime performance on platform Castor (cf. <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btt760/-/DC1">supplementary material</ext-link>) by using all 12 available cores per node and by reusing subtrees (<xref ref-type="sec" rid="SEC2.1.1">Section 2.1.1</xref>). We analysed D6 for <italic>H</italic><sub>0</sub> and <italic>H</italic><sub>1</sub> running FastCodeML (multi-threading) on 12 CPU cores and determined average runtimes of three test runs. The average runtime of FastCodeML on dataset D6 is 21.9 h for <italic>H</italic><sub>0</sub> and 31.9 h for <italic>H</italic><sub>1</sub>. Due to time restrictions, we evaluated only a single iteration of CodeML for D6 which took 2.2 h on <italic>H</italic><sub>0</sub> (367 iteration steps) and 2.3 h on <italic>H</italic><sub>1</sub> (426 iteration steps) on the same platform. As we apply the same parameter optimization codes, we use the average number of optimization steps of FastCodeML on dataset D6 for the following speedup metric: we extrapolate that CodeML would have finished executing in approximately <inline-formula><inline-graphic xlink:href="btt760i67.jpg"/></inline-formula> h (i.e. ca. 33.6 days) for <italic>H</italic><sub>0</sub> and <inline-formula><inline-graphic xlink:href="btt760i68.jpg"/></inline-formula> h (i.e. ca. 40.8 days) for <italic>H</italic><sub>1</sub>. The estimated speedups comparing the single threaded CodeML with FastCodeML running in 12 threads is thus 36.9 for <italic>H</italic><sub>0</sub> and 30.7 for <italic>H</italic><sub>1</sub>. In this example, the LRT optimization saves 268 optimization steps for <italic>H</italic><sub>1</sub> (63%).</p>
    </sec>
  </sec>
  <sec id="SEC4">
    <title>4 CONCLUSIONS</title>
    <p>We introduced here three sequential code optimizations: an improved matrix exponential, subtrees reuse and LRT optimization. We observed significant speedups versus both CodeML and our previous version SlimCodeML, and the first two optimizations can be used in various likelihood computations in phylogenetics. Moreover, we present a parallelization strategy that uses a fine-grain and a coarse-grain approach. Overall, our improvements allow for testing selection on phylogenetic trees which exceed the possibilities of the original CodeML software; this is crucial to tackle the genomic data avalanche. The discussed improvements are motivated by the branch-site model but can, due to the likelihood framework, be extended to nucleotide- and amino acid-based MSAs as well as Bayesian approaches. We briefly identified such opportunities where applicable, but an extensive discussion is subject to future work.</p>
    <p>The optimization of the likelihood surface for phylogenetics problems is complex and we have started experimenting with the alternative parameter optimizers available in NLopt (<ext-link ext-link-type="uri" xlink:href="http://ab-initio.mit.edu/wiki/index.php/NLopt">http://ab-initio.mit.edu/wiki/index.php/NLopt</ext-link>). It may be interesting to compare different implementations of the Broyden–Fletcher–Goldfard–Shanno (BFGS) optimization method, but a deeper investigation of the global and derivative-free optimizers is needed to better understand the potential solutions to find the maximum likelihood estimator for complex evolutionary models.</p>
    <p>In a future version the dependencies between nodes could be modelled as a directed acyclic graph and the parallelism be based on a dataflow model (<xref rid="btt760-B36" ref-type="bibr">YarKhan <italic>et al.</italic>, 2011</xref>) to study and potentially further improve parallel performance. Moreover, the site classes could be included into the dependency graph. This way a more fine-grained parallelism could be achieved. Increasing the parallel performance becomes crucial with the trend of more parallelism in future computer platforms (<xref rid="btt760-B5" ref-type="bibr">Dongarra, 2012</xref>).</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_30_8_1129__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="pdf" xlink:href="supp_btt760_Valleetal_SuppData.pdf"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We thank Sébastien Moretti and Walid Gharib for providing test datasets and feedback on FastCodeML. The computations on Castor were performed at the Swiss National Supercomputing Centre (<ext-link ext-link-type="uri" xlink:href="http://www.cscs.ch">http://www.cscs.ch</ext-link>), and those on Vital-IT at the Vital-IT (<ext-link ext-link-type="uri" xlink:href="http://www.vital-it.ch">http://www.vital-it.ch</ext-link>) Center for high-performance computing of the SIB Swiss Institute of Bioinformatics.</p>
    <p><italic>Funding</italic>: This work is supported by the <funding-source>Swiss Platform for High-Performance and High-Productivity Computing (HP2C)</funding-source>, the <funding-source>Swiss Federal Government through the Federal Office of Education and Science</funding-source>, the <funding-source>Swiss National Science Foundation</funding-source> (grant <award-id>CR32I3_143768</award-id>) and État de Vaud and the Vienna Science and Technology Fund (WWTF) through project ICT10-067 (HiPANQ).</p>
    <p><italic>Conflict of Interest:</italic> none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btt760-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Anisimova</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Kosiol</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>Investigating protein-coding sequence evolution with probabilistic codon substitution models</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2009</year>
        <volume>26</volume>
        <fpage>255</fpage>
        <lpage>271</lpage>
        <pub-id pub-id-type="pmid">18922761</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Anisimova</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Multiple hypothesis testing to detect lineages under positive selection that affects only a few sites</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2007</year>
        <volume>24</volume>
        <fpage>1219</fpage>
        <lpage>1228</lpage>
        <pub-id pub-id-type="pmid">17339634</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B3">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Bai</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <source>Templates for the Solution of Algebraic Eigenvalue Problems: A Practical Guide</source>
        <year>2000</year>
        <publisher-loc>Philadelphia</publisher-loc>
        <publisher-name>SIAM</publisher-name>
      </element-citation>
    </ref>
    <ref id="btt760-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Comnish-Bowden</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Nomenclature for incompletely specified bases in nucleic acid sequences: recommendation 1984</article-title>
        <source>Nucleic Acids Res.</source>
        <year>1985</year>
        <volume>13</volume>
        <fpage>3021</fpage>
        <lpage>3030</lpage>
        <pub-id pub-id-type="pmid">2582368</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dongarra</surname>
            <given-names>JJ</given-names>
          </name>
        </person-group>
        <article-title>High performance computing systems: status and outlook</article-title>
        <source>Acta Numerica</source>
        <year>2012</year>
        <volume>21</volume>
        <fpage>379</fpage>
        <lpage>474</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dutheil</surname>
            <given-names>JY</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Efficient selection of branch-specific models of sequence evolution</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2012</year>
        <volume>29</volume>
        <fpage>1861</fpage>
        <lpage>1874</lpage>
        <pub-id pub-id-type="pmid">22319139</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Felsenstein</surname>
            <given-names>J</given-names>
          </name>
        </person-group>
        <article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach</article-title>
        <source>J. Mol. Evol.</source>
        <year>1981</year>
        <volume>17</volume>
        <fpage>368</fpage>
        <lpage>376</lpage>
        <pub-id pub-id-type="pmid">7288891</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B8">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Foster</surname>
            <given-names>IT</given-names>
          </name>
        </person-group>
        <source>Designing and Building Parallel Programs</source>
        <year>1995</year>
        <publisher-loc>Reading, Mass</publisher-loc>
        <publisher-name>Addison-Wesley</publisher-name>
      </element-citation>
    </ref>
    <ref id="btt760-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gil</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>CodonPhyML: fast maximum likelihood phylogeny estimation under codon substitution models</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2013</year>
        <volume>30</volume>
        <fpage>1270</fpage>
        <lpage>1280</lpage>
        <pub-id pub-id-type="pmid">23436912</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B10">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Golub</surname>
            <given-names>GH</given-names>
          </name>
          <name>
            <surname>Van Loan</surname>
            <given-names>CF</given-names>
          </name>
        </person-group>
        <source>Matrix Computations</source>
        <year>2013</year>
        <edition>4th edn</edition>
        <publisher-loc>Baltimore, MD</publisher-loc>
        <publisher-name>Johns Hopkins University Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="btt760-B11">
      <element-citation publication-type="journal">
        <collab>Grass Phylogeny Working Group II</collab>
        <article-title>New grass phylogeny resolves deep evolutionary relationships and discovers C<sub>4</sub> origins</article-title>
        <source>New Phytol.</source>
        <year>2012</year>
        <volume>193</volume>
        <fpage>304</fpage>
        <lpage>312</lpage>
        <pub-id pub-id-type="pmid">22115274</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Izquierdo-Carrasco</surname>
            <given-names>F</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Algorithms, data structures, and numerics for likelihood-based phylogenetic inference of huge trees</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>1</fpage>
        <lpage>14</lpage>
        <pub-id pub-id-type="pmid">21199577</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kosakovsky Pond</surname>
            <given-names>SL</given-names>
          </name>
          <name>
            <surname>Muse</surname>
            <given-names>SV</given-names>
          </name>
        </person-group>
        <article-title>Column sorting: rapid calculation of the phylogenetic likelihood function</article-title>
        <source>Syst. Biol.</source>
        <year>2004</year>
        <volume>53</volume>
        <fpage>685</fpage>
        <lpage>692</lpage>
        <pub-id pub-id-type="pmid">15545249</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kosiol</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Patterns of positive selection in six mammalian genomes</article-title>
        <source>PLoS Genet.</source>
        <year>2008</year>
        <volume>4</volume>
        <fpage>e1000144</fpage>
        <pub-id pub-id-type="pmid">18670650</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B15">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Kraut</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Phylogenetic code in the cloud – can it meet the expectations?</article-title>
        <source>HealthGrid</source>
        <year>2010</year>
        <publisher-loc>Birmingham, AL</publisher-loc>
        <publisher-name>IOS Press</publisher-name>
        <fpage>55</fpage>
        <lpage>63</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lartillot</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Philippe</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>A bayesian mixture model for across-site heterogeneities in the amino-acid replacement process</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2004</year>
        <volume>21</volume>
        <fpage>1095</fpage>
        <lpage>1109</lpage>
        <pub-id pub-id-type="pmid">15014145</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lemey</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A counting renaissance: combining stochastic mapping and empirical Bayes to quickly detect amino acid sites under positive selection</article-title>
        <source>Bioinformatics</source>
        <year>2012</year>
        <volume>28</volume>
        <fpage>3248</fpage>
        <lpage>3256</lpage>
        <pub-id pub-id-type="pmid">23064000</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B18">
      <element-citation publication-type="journal">
        <collab>Message Passing Interface Forum</collab>
        <article-title>MPI: a message-passing interface standard</article-title>
        <source>Int. J. Supercomput. Appl. High Performance Comput.</source>
        <year>1994</year>
        <volume>8</volume>
        <fpage>3</fpage>
        <lpage>4</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Murrell</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Detecting individual sites subject to episodic diversifying selection</article-title>
        <source>PloS Genet.</source>
        <year>2012</year>
        <volume>8</volume>
        <fpage>e1002764</fpage>
        <pub-id pub-id-type="pmid">22807683</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B20">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Nielsen</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <source>Statistical Methods in Molecular Evolution</source>
        <year>2005</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>Springer</publisher-name>
      </element-citation>
    </ref>
    <ref id="btt760-B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Proux</surname>
            <given-names>E</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Selectome: a database of positive selection</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2009</year>
        <volume>37</volume>
        <fpage>404</fpage>
        <lpage>407</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rannala</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Yang</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <article-title>Phylogenetic inference using whole genomes</article-title>
        <source>Annu. Rev. Genomics Hum. Genet.</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>217</fpage>
        <lpage>231</lpage>
        <pub-id pub-id-type="pmid">18767964</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rodrigue</surname>
            <given-names>N</given-names>
          </name>
          <name>
            <surname>Aris-Brosou</surname>
            <given-names>S</given-names>
          </name>
        </person-group>
        <article-title>Fast bayesian choice of phylogenetic models: prospecting data augmentation-based thermodynamic integration</article-title>
        <source>Syst. Biol.</source>
        <year>2011</year>
        <volume>60</volume>
        <fpage>881</fpage>
        <lpage>887</lpage>
        <pub-id pub-id-type="pmid">21804092</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B24">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Schabauer</surname>
            <given-names>H</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>SlimCodeML: an optimized version of CodeML for the branch-site model</article-title>
        <source>11th International Workshop on High Performance Computational Biology (HiCOMB)</source>
        <year>2012</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>700</fpage>
        <lpage>708</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B25">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Sedgewick</surname>
            <given-names>R</given-names>
          </name>
          <name>
            <surname>Wayne</surname>
            <given-names>K</given-names>
          </name>
        </person-group>
        <source>Algorithms</source>
        <year>2011</year>
        <edition>4th edn</edition>
        <publisher-loc>Reading, Mass</publisher-loc>
        <publisher-name>Addison-Wesley</publisher-name>
      </element-citation>
    </ref>
    <ref id="btt760-B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Seo</surname>
            <given-names>TK</given-names>
          </name>
          <name>
            <surname>Kishino</surname>
            <given-names>H</given-names>
          </name>
        </person-group>
        <article-title>Synonymous substitutions substantially improve evolutionary inference from highly diverged proteins</article-title>
        <source>Syst. Biol.</source>
        <year>2008</year>
        <volume>57</volume>
        <fpage>367</fpage>
        <lpage>377</lpage>
        <pub-id pub-id-type="pmid">18570032</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B27">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Stamatakis</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Schmidt</surname>
            <given-names>B</given-names>
          </name>
        </person-group>
        <article-title>Orchestrating the phylogenetic likelihood function on emerging parallel architectures</article-title>
        <source>Bioinformatics—High Performance Parallel Computer Architectures</source>
        <year>2011</year>
        <publisher-loc>Singapore</publisher-loc>
        <publisher-name>CRC Press</publisher-name>
        <fpage>85</fpage>
        <lpage>115</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B28">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Stamatakis</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Ott</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Load balance in the phylogenetic likelihood kernel</article-title>
        <source>ICPP</source>
        <year>2009</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>348</fpage>
        <lpage>355</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B29">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Stamatakis</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>AxML: a fast program for sequential and parallel phylogenetic tree calculations based on the maximum likelihood method</article-title>
        <source>Bioinformatics Conference</source>
        <year>2002</year>
        <publisher-loc>New York</publisher-loc>
        <publisher-name>IEEE</publisher-name>
        <fpage>21</fpage>
        <lpage>28</lpage>
      </element-citation>
    </ref>
    <ref id="btt760-B30">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Studer</surname>
            <given-names>RA</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Pervasive positive selection on duplicated and nonduplicated vertebrate protein coding genes</article-title>
        <source>Genome Res.</source>
        <year>2008</year>
        <volume>18</volume>
        <fpage>1393</fpage>
        <lpage>1402</lpage>
        <pub-id pub-id-type="pmid">18562677</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B31">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Sumner</surname>
            <given-names>J</given-names>
          </name>
          <name>
            <surname>Charleston</surname>
            <given-names>M</given-names>
          </name>
        </person-group>
        <article-title>Phylogenetic estimation with partial likelihood tensors</article-title>
        <source>J. Theor. Biol.</source>
        <year>2010</year>
        <volume>262</volume>
        <fpage>413</fpage>
        <lpage>424</lpage>
        <pub-id pub-id-type="pmid">19822153</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B32">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Tomko</surname>
            <given-names>KA</given-names>
          </name>
        </person-group>
        <source>Domain Decomposition, Irregular Applications, and Parallel Computers</source>
        <year>1995</year>
        <comment>Ph.D. thesis, University of Michigan, Michigan</comment>
      </element-citation>
    </ref>
    <ref id="btt760-B33">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Venditti</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Phylogenetic mixture models can reduce node-density artifacts</article-title>
        <source>Syst. Biol.</source>
        <year>2008</year>
        <volume>57</volume>
        <fpage>286</fpage>
        <lpage>293</lpage>
        <pub-id pub-id-type="pmid">18432549</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B34">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>Z</given-names>
          </name>
        </person-group>
        <source>Computational Molecular Evolution</source>
        <year>2006</year>
        <publisher-loc>Oxford</publisher-loc>
        <publisher-name>Oxford University Press</publisher-name>
      </element-citation>
    </ref>
    <ref id="btt760-B35">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Yang</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Bayes empirical bayes inference of amino acid sites under positive selection</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2005</year>
        <volume>22</volume>
        <fpage>1107</fpage>
        <lpage>1118</lpage>
        <pub-id pub-id-type="pmid">15689528</pub-id>
      </element-citation>
    </ref>
    <ref id="btt760-B36">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>YarKhan</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <source>QUARK Users’ Guide: QUeueing and Runtime for Kernels</source>
        <year>2011</year>
        <comment>Technical report. University of Tennessee Innovative Computing Laboratory. ICL-UT-11-02, Tennessee</comment>
      </element-citation>
    </ref>
    <ref id="btt760-B37">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>J</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Evaluation of an improved branch-site likelihood method for detecting positive selection at the molecular level</article-title>
        <source>Mol. Biol. Evol.</source>
        <year>2005</year>
        <volume>22</volume>
        <fpage>2472</fpage>
        <lpage>2479</lpage>
        <pub-id pub-id-type="pmid">16107592</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
