<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">4058932</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btu288</article-id>
    <article-id pub-id-type="publisher-id">btu288</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Ismb 2014 Proceedings Papers Committee</subject>
        <subj-group subj-group-type="heading">
          <subject>Original Papers</subject>
          <subj-group subj-group-type="heading">
            <subject>RNA Bioinformatics</subject>
          </subj-group>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>RNA-Skim: a rapid method for RNA-Seq quantification at transcript level</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Zhang</surname>
          <given-names>Zhaojun</given-names>
        </name>
        <xref ref-type="aff" rid="btu288-AFF1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Wang</surname>
          <given-names>Wei</given-names>
        </name>
        <xref ref-type="aff" rid="btu288-AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="btu288-COR1">*</xref>
      </contrib>
    </contrib-group>
    <aff id="btu288-AFF1"><sup>1</sup>Department of Computer Science, University of North Carolina at Chapel Hill, Chapel Hill, NC, USA and <sup>2</sup>Department of Computer Science, University of California, Los Angeles, CA, USA</aff>
    <author-notes>
      <corresp id="btu288-COR1">*To whom correspondence should be addressed.</corresp>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>15</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>6</month>
      <year>2014</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>30</volume>
    <issue>12</issue>
    <fpage>i283</fpage>
    <lpage>i292</lpage>
    <permissions>
      <copyright-statement>© The Author 2014. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2014</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/3.0">
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">http://creativecommons.org/licenses/by-nc/3.0/</ext-link>), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> RNA-Seq technique has been demonstrated as a revolutionary means for exploring transcriptome because it provides deep coverage and base pair-level resolution. RNA-Seq quantification is proven to be an efficient alternative to Microarray technique in gene expression study, and it is a critical component in RNA-Seq differential expression analysis. Most existing RNA-Seq quantification tools require the alignments of fragments to either a genome or a transcriptome, entailing a time-consuming and intricate alignment step. To improve the performance of RNA-Seq quantification, an alignment-free method, Sailfish, has been recently proposed to quantify transcript abundances using all k-mers in the transcriptome, demonstrating the feasibility of designing an efficient alignment-free method for transcriptome quantification. Even though Sailfish is substantially faster than alternative alignment-dependent methods such as Cufflinks, using all k-mers in the transcriptome quantification impedes the scalability of the method.</p>
      <p><bold>Results:</bold> We propose a novel RNA-Seq quantification method, RNA-Skim, which partitions the transcriptome into disjoint transcript clusters based on sequence similarity, and introduces the notion of sig-mers, which are a special type of k-mers uniquely associated with each cluster. We demonstrate that the sig-mer counts within a cluster are sufficient for estimating transcript abundances with accuracy comparable with any state-of-the-art method. This enables RNA-Skim to perform transcript quantification on each cluster independently, reducing a complex optimization problem into smaller optimization tasks that can be run in parallel. As a result, RNA-Skim uses &lt;4% of the k-mers and &lt;10% of the CPU time required by Sailfish. It is able to finish transcriptome quantification in &lt;10 min per sample by using just a single thread on a commodity computer, which represents &gt;100 speedup over the state-of-the-art alignment-based methods, while delivering comparable or higher accuracy.</p>
      <p><bold>Availability and implementation:</bold> The software is available at <ext-link ext-link-type="uri" xlink:href="http://www.csbio.unc.edu/rs">http://www.csbio.unc.edu/rs</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>weiwang@cs.ucla.edu</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu288/-/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
    <counts>
      <page-count count="10"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 INTRODUCTION</title>
    <p>RNA-Seq technique has been demonstrated as a revolutionary means for examining transcriptome because it provides incomparable deep coverage and base pair-level resolution (<xref rid="btu288-B19" ref-type="bibr">Ozsolak and Milos, 2010</xref>). Though RNA-Seq sequencing exhibits itself as an efficient alternative to Microarray techniques in gene expression study (<xref rid="btu288-B31" ref-type="bibr">Wang <italic>et al.</italic>, 2009</xref>), it also brings unprecedented challenges, including (but not limited to) how to rapidly and effectively process the massive data produced by the proliferation of RNA-Seq high-throughput sequencing, how to build statistical model for accurate quantification of transcript abundances for transcriptome, etc.</p>
    <p>Most of current RNA-Seq tools for RNA-Seq quantification contain two main steps: an alignment step and a quantification step. Various aligners [TopHat (<xref rid="btu288-B25" ref-type="bibr">Trapnell <italic>et al.</italic>, 2009</xref>), SpliceMap (<xref rid="btu288-B1" ref-type="bibr">Au <italic>et al.</italic>, 2010</xref>), MapSplice (<xref rid="btu288-B30" ref-type="bibr">Wang <italic>et al.</italic>, 2010</xref>)] are devised to infer the origin of each RNA-Seq fragment in the genome. The alignment step is usually time-consuming, requiring substantial computational resources and demanding hours to align even one individual’s RNA-Seq data. Because there are multiple variations of RNA-Seq sequencing techniques, e.g. single-end sequencing and paired-end sequencing, to facilitate the discussion in this article, we simply refer to the <italic>read</italic> or the pair of reads from a RNA-Seq fragment as a <italic>fragment</italic>. More importantly, a significant percentage of the fragments cannot be aligned without ambiguity, which yields a complicated problem in the quantification step: how to assign the ambiguous fragments to compatible transcripts and to accurately estimate the transcript abundances. To tackle the fragment multiple-assignment problem, an expectation-maximization (EM) algorithm (<xref rid="btu288-B20" ref-type="bibr">Pachter, 2011</xref>) is often used to probabilistically resolve the ambiguity of fragment assignments: at each iteration, it assigns fragments to their compatible transcripts with a probability proportional to the transcript abundances, and then updates the transcript abundances to be the total weights contributed from the assigned fragments, until a convergence is reached. The EM algorithm’s simplicity in its formulation and implementation makes it a popular choice in several RNA-Seq quantification methods [Cufflinks (<xref rid="btu288-B26" ref-type="bibr">Trapnell <italic>et al.</italic>, 2010</xref>), Scripture (<xref rid="btu288-B9" ref-type="bibr">Guttman <italic>et al.</italic>, 2010</xref>), RSEM (<xref rid="btu288-B15" ref-type="bibr">Li and Dewey, 2011</xref>), eXpress (<xref rid="btu288-B24" ref-type="bibr">Roberts and Pachter, 2013</xref>)]. Because all fragments and all transcripts are quantified at the same time in the EM algorithm, it usually requires considerable running time. Some studies [IsoEM (<xref rid="btu288-B18" ref-type="bibr">Nicolae <italic>et al.</italic>, 2011</xref>), MMSEQ (<xref rid="btu288-B28" ref-type="bibr">Turro <italic>et al.</italic>, 2011</xref>)] reduced the scale of the problem by collapsing reads if they can be aligned to the same set of transcripts. It is also worth mentioning that RNA-Seq quantification is an important first step for differential analysis on the transcript abundances among different samples (<xref rid="btu288-B27" ref-type="bibr">Trapnell <italic>et al.</italic>, 2012</xref>).</p>
    <p>The alignment step is a vital step in the RNA-Seq assembly study (<xref rid="btu288-B26" ref-type="bibr">Trapnell <italic>et al.</italic>, 2010</xref>) and has become the computational bottleneck for RNA-Seq quantification tasks. If users are only interested in RNA-Seq quantification of an annotated transcriptome, aligning RNA-Seq fragments to the genome seems cumbersome: not only do the RNA-Seq aligners take a long time to align fragments to the genome by exhaustively searching all possible splice junctions in the fragments, they may also generate misaligned results owing to repetitive regions in the genome or sequencing errors, introducing errors in the quantification results (<xref rid="btu288-B32" ref-type="bibr">Zhang <italic>et al.</italic>, 2013</xref>).</p>
    <p>From another perspective, the annotation databases of transcriptome, e.g. RefSeq (<xref rid="btu288-B22" ref-type="bibr">Pruitt <italic>et al.</italic>, 2007</xref>) and Ensembl (<xref rid="btu288-B4" ref-type="bibr">Flicek <italic>et al.</italic>, 2011</xref>), play an increasingly important role in RNA-Seq quantification. For example, TopHat/Cufflinks supports a mode that allows users to specify the transcriptome by supplying an annotation database (a GTF file). RSEM (<xref rid="btu288-B15" ref-type="bibr">Li and Dewey, 2011</xref>) uses bowtie (<xref rid="btu288-B13" ref-type="bibr">Langmead <italic>et al.</italic>, 2009</xref>)—a DNA sequence aligner—to align fragments directly to the transcriptome. Aligning RNA-Seq fragments to transcriptome avoids the computation to detect novel splice junctions in fragments and eliminates the non-transcriptome regions in the genome from further examination, and thus reduces the total running time of the quantification method and the number of erroneous alignments in the results.</p>
    <p>To further improve the performance, the utility of k-mers was recently proposed. The concept of k-mers—short and consecutive sequences containing k nucleic acids—has been widely used in bioinformatics, including genome and transcriptome assembly (<xref rid="btu288-B5" ref-type="bibr">Fu <italic>et al.</italic>, 2014</xref>; <xref rid="btu288-B7" ref-type="bibr">Grabherr <italic>et al.</italic>, 2011</xref>), error correction in sequence reads (<xref rid="btu288-B14" ref-type="bibr">Le <italic>et al.</italic>, 2013</xref>), etc. Because the number of k-mers in the genome or transcriptome is enormous when k is large (e.g. <inline-formula><mml:math id="n1"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≥</mml:mo><mml:mn>25</mml:mn></mml:mrow></mml:math></inline-formula>), the need to store all k-mers impedes their counting. Most of existing methods save memory usage during the computation by using sophisticated algorithms and advanced data structures [bloom filter (<xref rid="btu288-B17" ref-type="bibr">Melsted and Pritchard, 2011</xref>), lock-free memory-efficient hash table (<xref rid="btu288-B16" ref-type="bibr">Marcais and Kingsford, 2011</xref>), suffix array (<xref rid="btu288-B12" ref-type="bibr">Kurtz <italic>et al.</italic>, 2008</xref>)] or relying on disk space to compensate memory space (<xref rid="btu288-B23" ref-type="bibr">Rizk <italic>et al.</italic>, 2013</xref>).</p>
    <p>Thanks to the recent advances in both annotated transcriptome and algorithms to rapidly count k-mers, the transcriptome-based alignment-free method, Sailfish (<xref rid="btu288-B21" ref-type="bibr">Patro <italic>et al.</italic>, 2013</xref>), requires 20 times less running time and generates comparable results with alignment-dependent quantification methods. Sailfish is a lightweight method: it first builds a unique index of all k-mers that appear at least once in the transcriptome, counts the occurrences of the k-mers in the RNA-Seq fragments and quantifies the transcripts by the number of occurrences of the k-mers through an EM algorithm.</p>
    <p>Regardless of being alignment-dependent or alignment-free, all methods need to recover the fragment depth—the number of fragments that cover a specific location—across the whole transcriptome as one of the initial steps. However, none of the existing methods exploit the strong redundancy of the fragment depth in RNA-Seq data. More specifically, <xref ref-type="fig" rid="btu288-F1">Fig. 1</xref> shows a strong correlation between the fragment depth of any two locations that are a certain distance apart on the transcriptome, varying the distance from 1 to 100 bp. Even when the two locations are 20 bp away from each other, the Pearson correlation score is still as high as 0.985. In other words, if an RNA-Seq quantification method that is able to recover the fragment depths for every 20 bp and quantify the abundance levels based on such information, there should be no significant accuracy loss in the result. Recently, <xref rid="btu288-B29" ref-type="bibr">Uziela and Honkela (2013)</xref> developed a method that simply counts the number of alignments that covers the locations of hybridization probes used in the gene expression studies. Though these probes only represent a sparse sampling on every transcript in the transcriptome, the method still provides reasonably accurate results. The observation and the method inspire us to ask the following question: what is the minimum information we need to achieve comparable accuracy in RNA-Seq quantification to the state-of-the-art methods? More specifically, does there exist a subset of k-mers that can provide accurate transcriptome quantification? And if so, how do we identify and use them to quantify transcriptome efficiently?
<fig id="btu288-F1" position="float"><label>Fig. 1.</label><caption><p>This figure shows the correlations of the fragment depth of any pair of locations as a function of the distance between the two locations from 1 to 100 bp. This figure is generated based on the alignments reported by TopHat on a real RNA-Seq data</p></caption><graphic xlink:href="btu288f1"/></fig></p>
    <p>To answer these questions, we introduced a special type of k-mers called <italic>sig-mers</italic>, which only appear in a (small) subset of transcripts in the transcriptome. Based on these sig-mers, we developed a method, RNA-Skim, which is much faster than Sailfish and also maintains the same level of accuracy in the results. RNA-Skim includes two stages, <italic>preparation</italic> and <italic>quantification</italic>. In the preparation stage, RNA-Skim first partitions transcripts into clusters and uses bloom filters to discover all sig-mers for each transcript cluster, from which a small yet informative subset of sig-mers is selected to be used in the quantification stage. In the quantification stage, a rolling hash method (<xref rid="btu288-B11" ref-type="bibr">Karp and Rabin, 1987</xref>) is developed to rapidly count the occurrences of the selected sig-mers, and an EM algorithm is used to properly estimate the transcript abundance levels using the sig-mer counts. Because no sig-mer is shared by two transcript clusters, the task can be easily divided into many small quantification problems, which significantly reduces the scale of each EM process and also makes it trivial to be parallelized. While RNA-Skim provides similar results to those of alternative methods, it only consumes 10% of the computational resources required by Sailfish.</p>
    <p>In this article, we first describe the RNA-Skim method, then discuss how we compared RNA-Skim with other methods, followed by the experimental results using both simulated and real data.</p>
  </sec>
  <sec id="SEC2">
    <title>2 METHOD</title>
    <p>In this section, we introduced the notion of sig-mers, which is a special type of k-mers that may serve as <italic>signatures</italic> of a cluster of transcripts, distinguishing them from transcripts in other clusters in the transcriptome that do not contain these k-mers.</p>
    <sec id="SEC2.1">
      <title>2.1 sig-mer</title>
      <p>In this article, an annotated <italic>transcriptome</italic> Θ consists of a set of <italic>T</italic> transcripts: <inline-formula><mml:math id="n2"><mml:mrow><mml:mo>Θ</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>T</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. A <italic>transcript t</italic> is an RNA sequence composed of a string of four bases ‘A’, ‘U’, ‘C’ and ‘G’. In this article, we use the corresponding four DNA nucleotide bases ‘A', ‘T', ‘C', ‘G' to represent. The length of a transcript sequence may vary from 100 to 10 000 bp. A <italic>partition</italic> of a given transcriptome Θ groups all transcripts into <italic>P</italic> disjoint non-empty subsets or clusters, denoted by <inline-formula><mml:math id="n3"><mml:mrow><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Θ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>P</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. For example, one commonly adopted partition of transcriptome is to group transcripts into genes based on their locations on the genome. For any transcript <italic>t</italic>, we use <inline-formula><mml:math id="n4"><mml:mrow><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> to denote the cluster to which <italic>t</italic> belongs.</p>
      <p>A substring of length <italic>k</italic> from a transcript sequence, its reverse sequence, its complimentary sequence or its reverse and complimentary sequence is called a <italic>k-mer</italic> of the transcript. We define a function <bold>k-mer</bold>() to represent the set of all k-mers from a single transcript or a cluster of transcripts, denoted as <bold>k-mer</bold>(t) or <inline-formula><mml:math id="n5"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, respectively. For simplicity, if a string <italic>s</italic> is a k-mer of transcript <italic>t</italic>, we say <inline-formula><mml:math id="n6"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In this case, <inline-formula><mml:math id="n7"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>ϕ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is also true.
<statement><title>D<sc>efinition</sc></title><p>Given a length <italic>k</italic>, a transcriptome Θ and its partition <inline-formula><mml:math id="n8"><mml:mrow><mml:mi>Φ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Θ</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, if a k-mer <italic>s</italic> only exists in one cluster <inline-formula><mml:math id="n9"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and never appears in other clusters <inline-formula><mml:math id="n10"><mml:mrow><mml:mo>Θ</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we call it a <italic>sig-mer</italic> of cluster <inline-formula><mml:math id="n11"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. And for any given cluster <inline-formula><mml:math id="n12"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we denote all of its sig-mers as <inline-formula><mml:math id="n13"><mml:mrow><mml:mo>Ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. That is,
<disp-formula><mml:math id="n14"><mml:mrow><mml:mo>Ω</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">|</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>∀</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo>∈</mml:mo><mml:mo>Θ</mml:mo><mml:mo>∖</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:menclose notation="updiagonalstrike"><mml:mo>∈</mml:mo></mml:menclose><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>q</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p></statement>
</p>
      <p>Sig-mers characterize the uniqueness of each cluster. It is obvious that the number of sig-mers heavily depends on the transcriptome partition. If transcripts with similar sequences are assigned to different clusters, k-mers from these transcripts may not qualify as sig-mers. Consequently, fewer sig-mers may be identified, and in the worst case, some cluster may not have any sig-mers.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Workflow of RNA-Skim</title>
      <p>Because sig-mers are unique to only one cluster of transcripts, if a sig-mer occurs in some RNA-Seq reads, it indicates the sig-mer’s corresponding transcripts may be expressed. Therefore, its occurrence in the RNA-Seq data may serve as an accurate and reliable indicator of the abundance levels of these transcripts. We proposed a method, RNA-Skim, for quantifying the transcripts using the sig-mer counts in RNA-Seq data. Because no sig-mer is shared between transcript clusters, the problem reduces to quantifying transcript abundances using sig-mer counts within each cluster, which can be solved much more efficiently and can be easily parallelized. This is different from Sailfish that uses all k-mers in the transcriptome. In fact, RNA-Skim can be considered as a generalization of Sailfish: if the whole transcriptome is treated as a single cluster that includes all transcripts, all k-mers become sig-mers, and RNA-Skim degenerates to the exact formulation of Sailfish.</p>
      <p>The workflow of RNA-Skim includes two stages: <italic>preparation</italic> and <italic>quantification</italic>. In preparation, RNA-Skim clusters the transcripts based on their sequence similarities, finds all sig-mers for each transcript cluster and selects a subset of sig-mers to be used in the quantification stage. In quantification, RNA-Skim quickly counts the occurrences of sig-mers and quantifies transcripts within each cluster. The preparation stage of RNA-Skim does not require RNA-Seq read data and thus can be computed once as an offline process and be repeatedly used in the quantification stage.</p>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Preparation stage</title>
      <p>In the preparation stage, RNA-Skim only requires users to supply a transcriptome (including all transcript sequences and gene annotations) and specifies a desired sig-mer length to be used in RNA-Skim.</p>
      <p><bold>Transcriptome Partitioning</bold> A straightforward way to partition transcripts is based on their genome locations from an annotation database. However, the result of this partitioning approach may not be optimal because some transcripts of different genes may have similar sequences or share common subsequences. To minimize the number of common k-mers shared between clusters, RNA-Skim uses a sequence similarity-based algorithm to generate a partition of transcriptome, instead of using any existing partition. We first define the k-mer-based similarity, which is used as the sequence similarity in the algorithm.
<statement><title>D<sc>efinition</sc></title><p>The k-mer-based similarity of two sets of sequences <inline-formula><mml:math id="n15"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n16"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is defined as the higher of the two ratios: the number of common k-mers divided by the total number of k-mers in <inline-formula><mml:math id="n17"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and the number of common k-mers divided by the total number of k-mers in <inline-formula><mml:math id="n18"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>:
<disp-formula id="btu288-M1"><label>(1)</label><mml:math id="n19"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mspace width="2em"/><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mrow></mml:math></disp-formula>
<disp-formula id="btu288-M2"><label>(2)</label><graphic xlink:href="btu288m2.jpg" position="float"/></disp-formula>
</p></statement>
</p>
      <p>Transcripts from the same gene are likely to be similar to each other. To avoid unnecessary computation, RNA-Skim operates at the level of genes rather than transcripts. However, calculating the exact similarity between a pair of genes requires generating all k-mers appearing in each gene and taking the intersection of the two sets. This is computationally expensive. To expedite the computation, RNA-Skim uses the data structure—bloom filter (<xref rid="btu288-B2" ref-type="bibr">Bloom, 1970</xref>)—coupled with a sampling-based approach to approximate the similarity between two genes. The bloom filter is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set, without the need of storing the set explicitly. A bloom filter includes a vector of bits and several independent hash functions. Initially, all bits are set to 0. When an element is added to the bloom filter, the bits based on the hash values of the element are set to 1. The bloom filter reports an element is in the bloom filter if its corresponding bits are all set to 1. A bloom filter may yield a small number of false positives, but no false negatives. The false-positive rate is bounded if the number of elements in the set is known. It can be maintained efficiently when new members are added to the set.</p>
      <p>RNA-Skim first builds a bloom filter for the set of k-mers of each gene. Then, it randomly samples two subsets of k-mers—noted as <inline-formula><mml:math id="n21"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="n22"><mml:mrow><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>—from the pair of genes, and the <inline-formula><mml:math id="n23"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>S</mml:mi><mml:mi>i</mml:mi><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>l</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is approximated by <inline-formula><mml:math id="n24"><mml:mrow><mml:mi>max</mml:mi><mml:mo>⁡</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width=".2em"/><mml:mo>∩</mml:mo><mml:mspace width=".2em"/><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mfrac><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width=".2em"/><mml:mo>∩</mml:mo><mml:mspace width=".2em"/><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo><mml:mi>X</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (our experiments show that we only need a small number (e.g. 10) of k-mers from each gene to achieve approximation with high accuracy). After we calculate the approximated similarities for every pair of genes, an undirected graph is built with each node representing a gene. There is an edge between two nodes if the similarity of the two corresponding genes exceeds a user-specified threshold γ. Each connected component of this graph naturally forms a cluster of nodes; each cluster of nodes forms a cluster of genes and transcripts of the genes.</p>
      <p><bold>Sig-mers discovery</bold> By definition, the sig-mers are essentially the k-mers occurring in only one cluster of transcripts. A brute force way to find all sig-mers is, for every k-mer in the transcriptome, to determine whether the k-mer that appears in one cluster also appears in some other cluster. Because the number of possible k-mers is in the order of billions, without any sophisticated data structure and data compression algorithms, storing the k-mers alone will easily take at least tens of gigabytes of memory space, which is way beyond the capacity of any commodity computer.</p>
      <p>RNA-Skim again uses bloom filters to reduce memory usage. Three types of bloom filters are used: a bloom filter <inline-formula><mml:math id="n25"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>L</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> for checking whether a given k-mer has been examined, a bloom filter <inline-formula><mml:math id="n26"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>D</mml:mi><mml:mi>U</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula> for checking whether a given k-mer appears in more than one cluster and a bloom filter <inline-formula><mml:math id="n27"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for each cluster <inline-formula><mml:math id="n28"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for checking whether a given k-mer is in <inline-formula><mml:math id="n29"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>k</mml:mi></mml:mstyle><mml:mi mathvariant="normal">-</mml:mi><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>First, for each cluster <inline-formula><mml:math id="n30"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, all distinct k-mers in it are enumerated: RNA-Skim enumerates all k-mers for every transcript in the cluster, and adds them to <inline-formula><mml:math id="n31"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>; if a k-mer is already in <inline-formula><mml:math id="n32"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, it will be ignored. Second, every distinct k-mer in <inline-formula><mml:math id="n33"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is added into <inline-formula><mml:math id="n34"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>L</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>, and if it is already in <inline-formula><mml:math id="n35"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>A</mml:mi><mml:mi>L</mml:mi><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula> (that is, it was added when RNA-Skim examined other clusters), it is added into <inline-formula><mml:math id="n36"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>D</mml:mi><mml:mi>U</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>. Therefore, if a k-mer occurs in multiple clusters, it is added in <inline-formula><mml:math id="n37"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>D</mml:mi><mml:mi>U</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>. Last, every k-mer of the transcriptome is enumerated again, and if the k-mer is not in <inline-formula><mml:math id="n38"><mml:mrow><mml:mi>B</mml:mi><mml:mi>F</mml:mi><mml:mo>.</mml:mo><mml:mi>D</mml:mi><mml:mi>U</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:math></inline-formula>, it is reported as a sig-mer, as it only occurs in one cluster.</p>
      <p>Because bloom filters may have false-positive reports, but never have false-negative reports, through this approach, some genuine sig-mer strings may be missed, but a non-sig-mer will never be labeled as a sig-mer. <xref ref-type="fig" rid="btu288-F2">Figure 2</xref> shows the pseudocode of our algorithm.
<fig id="btu288-F2" position="float"><label>Fig. 2.</label><caption><p>The pseudocode to find all sig-mers</p></caption><graphic xlink:href="btu288f2"/></fig></p>
      <p><bold>Sig-mers selection</bold> RNA-Skim does not use all sig-mers because they are still numerous. Instead, RNA-Skim selects a subset of sig-mers for the quantification stage. We used a simple approach to select sig-mers from all sig-mers found by the previous step: for every transcript, sig-mers are evenly chosen based on the sig-mer locations such that any two sig-mers are at least 50 base pair away from each other in the given transcript. Because some sig-mers may appear in multiple transcripts in the same cluster, for every selected sig-mer, all transcripts are re-examined, and the ones that contain the sig-mer are also recorded. Through this approach, we can guarantee that every transcript is associated with some sig-mers (as long as there exist some sig-mers). A good sig-mer coverage is crucial for accurate quantification of transcript abundance. The final output of the preparation step includes the partition of the transcriptome, selected sig-mers and their associating clusters and transcripts.</p>
    </sec>
    <sec id="SEC2.4">
      <title>2.4 Quantification stage</title>
      <p>The quantification stage requires users to provide RNA-Seq data (e.g. FASTQ/FASTA files) and the selected sig-mers associated with transcripts containing them from the preparation stage.</p>
      <p><bold>Sig-mer counting</bold> Because the number of sig-mers used in RNA-Skim is much smaller than the number of k-mers typically used by other k-mer-based approaches, all sig-mers can be stored in a hash table in memory. The number of occurrences of all sig-mers can be counted by enumerating all k-mers in the RNA-Seq reads and looking up the k-mers in the hash table to update the corresponding counters. RNA-Skim basically follows this scheme with a tweak on the hash function to further speed up the computation.</p>
      <p>In a straightforward implementation of the previously described algorithm, every k-mer incurs an O(k) operation to calculate its hash value, and this hash operation can be further reduced to O(1) by the Robin–Karp pattern matching algorithm (<xref rid="btu288-B11" ref-type="bibr">Karp and Rabin, 1987</xref>). The Robin–Karp pattern matching algorithm requires a special hash function—rolling hash—that only uses multiplications, additions and subtractions.</p>
      <p>In rolling hash, the hash value <inline-formula><mml:math id="n39"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> of the first k-mer in the RNA-Seq read <italic>r</italic> is calculated by
<disp-formula><mml:math id="n40"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mn>...</mml:mn><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mn>0</mml:mn></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
where <italic>h</italic> is the base of the hash function, <inline-formula><mml:math id="n41"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is the <italic>i</italic>th character in <italic>s</italic> and the character hash function <inline-formula><mml:math id="n42"><mml:mrow><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> maps a character to an integer value. One way to calculate the hash value for the (sequentially ordered) second k-mer <inline-formula><mml:math id="n43"><mml:mrow><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> is
<disp-formula><mml:math id="n44"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:mn>...</mml:mn><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mn>0</mml:mn></mml:msup><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>But thanks to the structure of the rolling hash function, <inline-formula><mml:math id="n45"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> can be calculated in a much faster way:
<disp-formula><mml:math id="n46"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>...</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>−</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:mi>h</mml:mi><mml:mo>+</mml:mo><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>×</mml:mo><mml:msup><mml:mi>h</mml:mi><mml:mn>0</mml:mn></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
which only requires one subtraction, three multiplications and one addition. We can look up the hash value in the hash table, and if it is in the hash table, its associated counter is incremented accordingly. Because RNA-Skim uses this specially designed hash function, we implemented our own hash table in RNA-Skim using open addressing with linear probing. The base <italic>h</italic> is arbitrarily set to be a prime number 37, and the function <inline-formula><mml:math id="n47"><mml:mrow><mml:mi mathvariant="bold-italic">χ</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> maps every character to its actual ASCII value.</p>
      <p><bold>Quantification</bold> Because every cluster of transcripts has a unique set of sig-mers, which are the k-mers that never appear in other transcript clusters, every cluster can be independently quantified by RNA-Skim, resulting in a set of smaller independent quantification problems, instead of one huge whole transcriptome quantification problem in other approaches.</p>
      <p>Formally, if <inline-formula><mml:math id="n48"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is a cluster of transcripts, the set of sig-mers of <inline-formula><mml:math id="n49"><mml:mrow><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>P</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is denoted by <inline-formula><mml:math id="n50"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, a sig-mer is denoted by <italic>s</italic> (<inline-formula><mml:math id="n51"><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>), the set of all occurrences of sig-mers is denoted by <inline-formula><mml:math id="n52"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, an occurrence of a sig-mer in the RNA-Seq dataset is denoted by <italic>o</italic> (<inline-formula><mml:math id="n53"><mml:mrow><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>) and the sig-mer of the occurrence is denoted by <italic>z</italic><sub>o</sub>. From the previous steps, we obtained <italic>c</italic><sub>s</sub> (the number of occurrences of the sig-mer <italic>s</italic> in the RNA-Seq data), <inline-formula><mml:math id="n54"><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> (binary variables indicating whether the sig-mer <italic>s</italic> is contained in the sequence of transcript <italic>t</italic>) and <italic>b</italic><sub>t</sub> (the number of sig-mers that are contained by transcript <italic>t</italic>). <italic>C</italic> is the number of occurrences of all sig-mers (<inline-formula><mml:math id="n55"><mml:mrow><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mi>s</mml:mi></mml:munder><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math></inline-formula>).</p>
      <p>Same as in the previous study (<xref rid="btu288-B20" ref-type="bibr">Pachter, 2011</xref>), we define <inline-formula><mml:math id="n56"><mml:mrow><mml:mi mathvariant="bold">Ψ</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>α</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="n57"><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the proportion of all selected sig-mers that are included by the reads from transcript <italic>t</italic>, and <inline-formula><mml:math id="n58"><mml:mrow><mml:mstyle displaystyle="true"><mml:mo>∑</mml:mo><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mstyle><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. For an occurrence <inline-formula><mml:math id="n59"><mml:mrow><mml:mi>o</mml:mi><mml:mo>,</mml:mo><mml:mtext>
</mml:mtext><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> represents the probability that <italic>o</italic> is chosen from transcript <italic>t</italic>, in a generative model,
<disp-formula id="btu288-M3"><label>(3)</label><mml:math id="n60"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
</p>
      <p>Therefore, the likelihood of observing all occurrences of the sig-mers as a function of the parameter <bold>Ψ</bold> is
<disp-formula id="btu288-M4"><label>(4)</label><mml:math id="n62"><mml:mrow><mml:mi mathvariant="script" class="calligraphy">L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>Ψ</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mi>p</mml:mi></mml:mstyle></mml:mrow></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>o</mml:mi><mml:mo>∈</mml:mo><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:msub><mml:mi>z</mml:mi><mml:mi>o</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mstyle><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
<disp-formula id="btu288-M5"><label>(5)</label><mml:math id="n63"><mml:mrow><mml:mspace width="8.1em"/><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∏</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:munder><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:msub><mml:mi>ϕ</mml:mi><mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mfrac><mml:mrow><mml:msub><mml:mi>α</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mstyle><mml:mo>.</mml:mo></mml:mrow></mml:math></disp-formula>
</p>
      <p>This is in spirit similar to the likelihood function used in other studies, except that this is the likelihood of observing sig-mers rather than fragments (<xref rid="btu288-B15" ref-type="bibr">Li and Dewey, 2011</xref>) or k-mers (<xref rid="btu288-B21" ref-type="bibr">Patro <italic>et al.</italic>, 2013</xref>). Thus, we also used an EM algorithm to find <inline-formula><inline-graphic xlink:href="btu288i1.jpg"/></inline-formula> that maximizes the likelihood: it alternates between allocating the fraction of counts of observed sig-mers to transcripts according to the proportions <inline-formula><inline-graphic xlink:href="btu288i2.jpg"/></inline-formula> and updating <inline-formula><inline-graphic xlink:href="btu288i3.jpg"/></inline-formula> given the amount of sig-mers assigned to transcripts. RNA-Skim also applies the same technique used in <xref rid="btu288-B21" ref-type="bibr">Patro <italic>et al.</italic> (2013)</xref>, <xref rid="btu288-B18" ref-type="bibr">Nicolae <italic>et al.</italic> (2011)</xref> and <xref rid="btu288-B28" ref-type="bibr">Turro <italic>et al.</italic> (2011)</xref> to collapse sig-mers if they are contained by the same set of transcripts. (See the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu288/-/DC1">Supplementary Material</ext-link>)</p>
      <p>RNA-Skim reports both Reads Per Kilobase per Million mapped reads (RPKM) and Transcripts Per Million as the relative abundance estimations of the transcripts, and both metrics are calculated by the way used in Sailfish (<xref rid="btu288-B21" ref-type="bibr">Patro <italic>et al.</italic>, 2013</xref>).</p>
      <p>So far, we have described both preparation and quantification stages in RNA-Skim. In the last, a toy example is provided to illustrate how each stage works in RNA-Skim in <xref ref-type="fig" rid="btu288-F3">Figure 3</xref>.
<fig id="btu288-F3" position="float"><label>Fig. 3.</label><caption><p>An illustration of how RNA-Skim works on a toy transcriptome of five transcripts</p></caption><graphic xlink:href="btu288f3"/></fig></p>
    </sec>
  </sec>
  <sec id="SEC3">
    <title>3 SOFTWARE FOR COMPARISON</title>
    <p>RNA-Skim is implemented in C++ with heavy usage of the open-source libraries bloomd (<xref rid="btu288-B3" ref-type="bibr">Dadgar, 2013</xref>), protobuf (<xref rid="btu288-B6" ref-type="bibr">Google, 2013</xref>) and an open-source class StringPiece (<xref rid="btu288-B10" ref-type="bibr">Hsieh, 2013</xref>). The parameter settings will be discussed in the Section 5.</p>
    <p>We compared RNA-Skim with four different quantification methods: Sailfish (0.6.2), Cufflinks (2.1.1), RSEM (1.2.8) and eXpress (1.5.1) in both simulated and real datasets. TopHat (2.0.10) and Bowtie (1.0.0) are used as the aligners when needed.</p>
    <p>For Sailfish, we set k-mer size to be 31 because this value gives the highest accuracy in the simulation study, among all k-mer sizes supported by Sailfish (<inline-formula><mml:math id="n67"><mml:mrow><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mn>31</mml:mn></mml:mrow></mml:math></inline-formula>). For other software, we followed the experiments in <xref rid="btu288-B21" ref-type="bibr">Patro <italic>et al.</italic> (2013)</xref> to set the parameters. Input to Cufflinks was generated by TopHat, which used Bowtie (–bowtie1), allowing up to three mismatches per read (-N 3 and –read-edit-dist 3). Both TopHat and Cufflinks were provided with a reference transcriptome. RSEM and eXpress directly used Bowtie to align the reads to the transcriptome, with the argument (-N 3) to allow up to three mismatches per read. The eXpress was executed in the streaming mode, to save the total quantification running time. For simulation study, we used the estimations without bias correction for Sailfish, Cufflinks and eXpress. For real datasets, the estimations with bias correction are used for these three methods. For RSEM, since it does not provide an option to control the bias correction, we did not differentiate its usage in the simulation and real data studies. Other parameters were set to default values for these methods.</p>
    <p>All methods were run on a shared cluster managed by the Load Sharing Facility (LSF) system. The running time and CPU time of these methods are measured by LSF. Each cluster node is equipped with Intel(R) Xeon(R) 12-core 2.93 GHz CPU and at least 48 GB memory. All files were served by the Lustre file system.</p>
  </sec>
  <sec>
    <title>4 MATERIALS</title>
    <p>All materials including both simulated and real data are based on the mouse population and consist of paired-end reads with 100 bp length per read. We used C57BL/6J downloaded from Ensembl (Build 70) as the reference genome in all experiments. All methods studied in this article were provided with 74 215 protein-coding annotated transcripts from the Ensembl database. The simulation datasets, including 100 mouse samples with the number of reads varying from 20 millions to 100 millions, were generated by the flux-simulator (<xref rid="btu288-B8" ref-type="bibr">Griebel <italic>et al.</italic>, 2012</xref>) with its default error model enabled. For real datasets, we used the RNA-Seq data from 18 inbred samples and 58 F1 samples derived from three inbred mouse strains CAST/EiJ, PWK/PhJ and WSB/EiJ. The RNA-Seq data was sequenced from mRNA extracted from brain tissues of both sexes and from all six possible crosses (including the reciprocal).</p>
  </sec>
  <sec>
    <title>5 RESULTS</title>
    <p>In this section, we first compared alternative partition algorithms and how they impact sig-mer selections in RNA-Skim and then furnish a comparison with four alternative methods on both simulated and real data. At last, we demonstrated that RNA-Skim is the fastest method among all considered methods.</p>
    <sec id="SEC5.1">
      <title>5.1 Similarity-based partition algorithm</title>
      <p>We compared the result of our similarity-based partition algorithm with those from two alternative ways to partition transcripts: transcript-based partition (every cluster contains a transcript) and gene-based partition (every cluster contains the transcripts from an annotated gene). The similarity threshold γ in our partition algorithm was set to be 0.2 (more details are provided later on the parameter choice). <xref ref-type="table" rid="btu288-T1">Table 1</xref> compares these partitions on the same transcriptome. The number of clusters generated by our similarity-based partition is 20% fewer than the number of genes. The average number of transcripts per cluster is ∼20% more than the average number of transcripts per gene. Most clusters only contain transcripts from a single gene, though the largest cluster contains 6107 transcripts. These transcripts in the largest cluster share a substantial number of k-mers (e.g. from paralogous genes), which need to be examined altogether to accurately estimate their abundance levels. Failing to consider them together (e.g. by using transcript-based or gene-based partitions) will compromise the number of sig-mers that help distinguish transcripts and hence impair the accuracy of transcriptome quantification. Even though this cluster contains many transcripts, it represents &lt;10% of the total number of transcripts.
<table-wrap id="btu288-T1" position="float"><label>Table 1.</label><caption><p>This table compares three different partitions</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Type</th><th rowspan="1" colspan="1">Number of clusters</th><th rowspan="1" colspan="1">Average number of transcripts per cluster</th><th rowspan="1" colspan="1">Size of the largest cluster</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">Transcript</td><td rowspan="1" colspan="1">74 215</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">1</td></tr><tr><td rowspan="1" colspan="1">Gene</td><td rowspan="1" colspan="1">22 584</td><td rowspan="1" colspan="1">3.29</td><td rowspan="1" colspan="1">39</td></tr><tr><td rowspan="1" colspan="1">RNA-Skim</td><td rowspan="1" colspan="1">18 269</td><td rowspan="1" colspan="1">4.06</td><td rowspan="1" colspan="1">6107</td></tr><tr><td rowspan="1" colspan="1">Sailfish</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">74 215</td><td rowspan="1" colspan="1">74 215</td></tr></tbody></table><table-wrap-foot><fn id="btu288-TF1"><p><italic>Note:</italic> If the partition contains only one cluster of all transcripts, RNA-Skim degenerates to Sailfish. We thus listed it in the table for comparison.</p></fn></table-wrap-foot></table-wrap></p>
      <p>We used these three types of partitions as the input to the sig-mer discovery method. To evaluate the goodness of a partition, we measured the proportion of each transcript that is covered by sig-mers and plot the cumulative distribution of all transcripts sorted in ascending order of their <italic>sig-mer coverage</italic> in <xref ref-type="fig" rid="btu288-F4">Figure 4</xref>, with varying k-mer sizes. For any transcript, the higher the sig-mer coverage is, the more accurate the abundance estimation will be. Our similarity-based partition is the best: almost all transcripts have at least 80% sig-mer coverage, which pushes the curves to the upper left corner of the plot regardless of the k-mer size. The gene-based partition is slightly worse: ∼95% of transcripts have at least 80% sig-mer coverage. The gene-based partition tends to result in low sig-mer coverage for genes sharing similar sequences. The transcript-based partition is the worst for an obvious reason: transcripts from the same genes may share exons and thus the number of sig-mers that can distinguish a transcript may be very small. We also observed that using longer k-mer improves the sig-mer coverage.
<fig id="btu288-F4" position="float"><label>Fig. 4.</label><caption><p>The distribution sig-mer coverages across all transcripts an ascending order of the sig-mer coverage. The upper the curve is, the better the corresponding partition is</p></caption><graphic xlink:href="btu288f4"/></fig></p>
      <p>In the end, RNA-Skim selects 2 586 388 sig-mers to be used in the quantification stage, and these sig-mers count for &lt;3.5% of 74 651 849 distinguished k-mers used by Sailfish. Because RNA-Skim uses a much smaller set of sig-mers, it is able to use the rolling hash method—a very fast but memory-inefficient method—to count sig-mers in RNA-Seq reads.</p>
    </sec>
    <sec id="SEC5.2">
      <title>5.2 Simulation study</title>
      <p><xref ref-type="fig" rid="btu288-F5">Figure 5</xref> compares the performance of the five methods on the simulated data using four metrics: Pearson’s correlation coefficient, Spearman’s rank correlation coefficient, significant false-positive rate (SFPR) and significant false-negative rate (SFNR). For brevity, we use Pearson (Truth), Spearman (Truth), SFPR and SFNR to denote these metrics, respectively. The Pearson’s correlation coefficient is calculated in a logarithmic scale, using all transcripts whose true and estimated abundance values are &gt;0.01 RPKM. This calculation is the same as that used by Sailfish (<xref rid="btu288-B21" ref-type="bibr">Patro <italic>et al.</italic>, 2013</xref>). The Spearman’s rank correlation is calculated on the set of transcripts whose true abundance values are &gt;0.01 RPKM. The SFPR and SFNR are calculated to assess the estimation distributions on the set of transcripts excluded by the previous metrics: if a transcript’s estimation is &gt;0.1 RPKM, but its true abundance value is &lt;0.01 RPKM (a 10-fold suppression), we call it a <italic>significant false positive</italic>; similarity, if a transcript’s estimation is &lt;0.01 RPKM, but its true abundance value is &gt;0.1 RPKM (a 10-fold amplification), we call it a <italic>significant false negative</italic>. There are two reasons that we chose SFPR and SFNR instead of the regular false-positive rate and false-negative rate: first, we prefer the transcripts with relatively large abundance values (&gt;0.1 RPKM) because they are accountable for 99% the RNA-Seq data; second, owing to the noisy nature of RNA-Seq, for the transcripts with small abundance values (&lt;0.01 RPKM), it is difficult to calculate accurately, e.g. both RSEM and Sailfish set the default minimal abundance value to be 0.01 RPKM.
<fig id="btu288-F5" position="float"><label>Fig. 5.</label><caption><p>(<bold>a</bold>), (<bold>b</bold>), (<bold>c</bold>) and (<bold>d</bold>) plot Pearson (Truth), Spearman (Truth), SFPR and SFNR of RNA-Skim as a function of sig-mer length, respectively. For comparison, we also plotted that of the other four methods as the horizontal lines. The reported values are the average across 100 simulated samples. The red crosses indicate the sig-mer length (i.e. 60 bp) used in other experiments in this article</p></caption><graphic xlink:href="btu288f5"/></fig></p>
      <p>For RNA-Skim, we varied the sig-mer length from 20 to 95 bp. Other methods are presented as horizontal lines for comparisons. Despite the small differences by individual metrics, <xref ref-type="fig" rid="btu288-F5">Figure 5</xref> shows that these five methods exhibit comparable performance: no method outperforms the remaining methods across all metrics and the maximal difference by any metric is within 0.05.</p>
      <p><xref ref-type="fig" rid="btu288-F5">Figure 5</xref>(a) and <xref ref-type="fig" rid="btu288-F5">5</xref>(b) show two concave curves of Pearson (Truth) and Spearman (Truth) for RNA-Skim by varying its sig-mer length. There are two factors explaining the concave curves. First, when the sig-mer length increases, sig-mers become more distinct and the sig-mer coverage increases, which improves the correlations between the truth and estimation. Second, for any fixed read length, when we increased the sig-mer length, the probability that a sig-mer is contained by a single read drops, causing the decrease in the number of sig-mers observed in the RNA-Seq data, which may exacerbate the correlations. In summary, there is a clear trade-off on the sig-mer length. Empirically, the best sig-mer length is between 55 to 60, and we thus used 60 in other experiments.</p>
      <p>For the same reason, in <xref ref-type="fig" rid="btu288-F5">Figure 5</xref>(c) and <xref ref-type="fig" rid="btu288-F5">5</xref>(d), we found that the increase in the sig-mer length affects positively on SFPR, but negatively on SFNR. When the sig-mer length equals 30, it has similar SFPR with Sailfish, but worse SFNR score than Sailfish, indicating that the complete set of k-mers still has its advantage than a small set of sig-mers. However, RNA-Skim is able to use much longer k-mers that Sailfish does not support, so RNA-Skim using longer k-mers can have a better SFPR than Sailfish. Other methods also follow the same inverse correlation: while Sailfish and eXpress are the worst in SFPR among these five methods, they are the best two in SFNR.</p>
      <p><xref ref-type="fig" rid="btu288-F6">Figure 6</xref> shows the Pearson (Truth), Spearman (Truth), SFPR and SFNR as a function of the number of sig-mers used in RNA-Skim. In <xref ref-type="fig" rid="btu288-F6">Figure 6</xref>(a), <xref ref-type="fig" rid="btu288-F6">6</xref>(b) and <xref ref-type="fig" rid="btu288-F6">6</xref>(d), when the number of sig-mers increases, the three metrics improve substantially, though at different paces. <xref ref-type="fig" rid="btu288-F6">Figure 6</xref>(c) shows no significant change in SFPR for different numbers of sig-mers. This observation suggests that we should use as many sig-mers as possible given available memory space. To ensure RNA-Skim to have similar memory usage to that of other methods, RNA-Skim uses 2.58 million sig-mers. This is also the default setting in other experiments in this article.
<fig id="btu288-F6" position="float"><label>Fig. 6.</label><caption><p><bold>(a)</bold>, <bold>(b)</bold>, <bold>(c)</bold> and <bold>(d)</bold> plot Pearson (Truth), Spearman (Truth), SFPR and SFNR as a function of the number of sig-mers used in RNA-Skim, respectively. For comparison, we also showed that of the other four methods as horizontal lines. The reported values are the average across 100 simulated samples. The red crosses indicate the number of sig-mers (i.e. 2.58 million sig-mers) used in other experiments in this article</p></caption><graphic xlink:href="btu288f6"/></fig></p>
      <p><xref ref-type="table" rid="btu288-T2">Table 2</xref> shows that the metrics do not vary much when using different similarity thresholds. In the simulation study, we varied the similarity threshold γ from 0.06 to 0.28 and observed at most 0.005 change across all metrics. Owing to limited space, the detailed results for the thresholds between 0.06 and 0.28 are omitted.
<table-wrap id="btu288-T2" position="float"><label>Table 2.</label><caption><p>This table shows that the four metrics do not change much for different similarity threshold γ</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">γ</th><th rowspan="1" colspan="1">Pearson</th><th rowspan="1" colspan="1">Spearman</th><th rowspan="1" colspan="1">SFP</th><th rowspan="1" colspan="1">SFN</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">0.06</td><td rowspan="1" colspan="1">0.9438</td><td rowspan="1" colspan="1">0.9242</td><td rowspan="1" colspan="1">0.0692</td><td rowspan="1" colspan="1">0.0233</td></tr><tr><td rowspan="1" colspan="1">0.28</td><td rowspan="1" colspan="1">0.9440</td><td rowspan="1" colspan="1">0.9237</td><td rowspan="1" colspan="1">0.0698</td><td rowspan="1" colspan="1">0.0235</td></tr></tbody></table></table-wrap></p>
      <p><xref ref-type="fig" rid="btu288-F7">Figure 7</xref> shows a strong and clear linear correlation between the estimated RPKM scores by RNA-Skim and the true RPKM scores on one simulated sample.
<fig id="btu288-F7" position="float"><label>Fig. 7.</label><caption><p>The scatterplot of the estimated RPKM scores by RNA-Skim versus the true RPKM scores. Both axes are in a logarithmic scale, and all transcripts whose true RPKM or estimated RPKM is &lt;0.01 are omitted</p></caption><graphic xlink:href="btu288f7"/></fig></p>
      <p>In simulation study, we note that the accuracy of RNA-Skim depends on the sig-mer length and the number of sig-mers, but is insensitive to the threshold γ. When these parameters are chosen properly, RNA-Skim produces similar results to those by other methods.</p>
    </sec>
    <sec id="SEC5.3">
      <title>5.3 Study using real RNA-Seq data</title>
      <p>Because the flux simulator cannot simulate RNA-Seq data with bias effects, and there might also be other unknown factors in the real RNA-Seq data that the simulator fails to capture, we also compared RNA-Skim with other methods on real data. Because we do not know the ground truth on real data, we computed the Pearson correlation and Spearman correlation between the results produced by RNA-Skim and one other method, referred to as Pearson (methods) and Spearman (methods) to distinguish from the previous computed correlations between RNA-Skim result and the ground truth.</p>
      <p><xref ref-type="fig" rid="btu288-F8">Figure 8</xref> shows that the distributions of the Pearson (methods) and Spearman (methods) are not significantly different between real data and simulated data. For example, the differences between the mean values of the correlations on both simulated and real data are no more than 0.02 across all methods. This consistency suggests that the result from RNA-Skim may have similar correlations with the unobserved truth. The slightly wider distribution of the correlations in real data (than that in simulated data) suggests the real data may exhibit more diversity than simulated data. (For the comparison with gene expression data, please see the <ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/lookup/suppl/doi:10.1093/bioinformatics/btu288/-/DC1">Supplementary Material</ext-link>).
<fig id="btu288-F8" position="float"><label>Fig. 8.</label><caption><p>(<bold>a</bold>), (<bold>b</bold>), (<bold>c</bold>) and (<bold>d</bold>) show the distributions of the Pearson (methods) and Spearman (methods) correlations between the results from RNA-Skim and the results from each of the remaining methods on both simulated and real data</p></caption><graphic xlink:href="btu288f8"/></fig></p>
    </sec>
    <sec id="SEC5.4">
      <title>5.4 Running time</title>
      <p>For the preparation stage (including transcriptome partitioning and sig-mer selection), RNA-Skim takes ∼3 h to finish on the mouse transcriptome by using a single thread. Most time is spent on calculating the k-mer-based similarities between different pairs of genes. It takes ∼10 min to finish sig-mer discovery and selection. It is worth noting that these steps only need to be run once for one population beforehand, and after sig-mers are selected and their connections with transcripts are established, the result can be repeatedly used on quantifying the transcriptome of many samples. Therefore, the running time for the preparation stage is less critical than the running time of the quantification stage, and the one-time investment of 3 h is acceptable.</p>
      <p>For the quantification stage, we compared both the running time and the CPU time of these five methods on a real sample with 44 millions of paired-end reads. The running time is the elapsed time between the start and end of a method, and the CPU time is the total time a method uses on each core of the CPU. For a single thread method, the running time is exactly the same as the CPU time. And for a multi-threading method running on a multi-core CPU, the running time is typically shorter than the CPU time. RNA-Skim is submitted as a single thread method. Sailfish, Cufflinks with TopHat as the aligner and RSEM with Bowtie as the aligner are submitted with multi-threading enabled and requiring eight threads. eXpress is an online algorithm, and it can quantify a streaming input of alignments generated by Bowtie in real time. Bowtie and eXpress use six and two threads for alignment and quantification, respectively.</p>
      <p><xref ref-type="table" rid="btu288-T3">Table 3</xref> summarizes the running time of all five methods. RNA-Skim is the fastest, ∼11× faster than the second best method, Sailfish, on the CPU time. Even when Sailfish uses eight threads, RNA-Skim is ∼1.6× faster on the running time by just using one thread. Because the aligner usually consumes lots of computation time, RNA-Skim has &gt;100 times speedup on the CPU time compared with Cufflinks, RSEM and eXpress.
<table-wrap id="btu288-T3" position="float"><label>Table 3.</label><caption><p>This table shows the running time of these five methods on a real sample with 44 millions of paired-end reads</p></caption><table frame="hsides" rules="groups"><thead align="left"><tr><th rowspan="1" colspan="1">Method</th><th rowspan="1" colspan="1">Number of threads</th><th rowspan="1" colspan="1">Running time (s)</th><th rowspan="1" colspan="1">CPU time (s)</th><th rowspan="1" colspan="1">Speedup (CPU time)</th></tr></thead><tbody align="left"><tr><td rowspan="1" colspan="1">RNA-Skim</td><td rowspan="1" colspan="1">1</td><td rowspan="1" colspan="1">592</td><td rowspan="1" colspan="1">592</td><td rowspan="1" colspan="1">1x</td></tr><tr><td rowspan="1" colspan="1">Sailfish</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">972</td><td rowspan="1" colspan="1">7005</td><td rowspan="1" colspan="1">11.8x</td></tr><tr><td rowspan="1" colspan="1">TopHat + Cufflinks</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">12 480</td><td rowspan="1" colspan="1">68 834</td><td rowspan="1" colspan="1">116x</td></tr><tr><td rowspan="1" colspan="1">Bowtie + RSEM</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">17 60</td><td rowspan="1" colspan="1">79 222</td><td rowspan="1" colspan="1">133x</td></tr><tr><td rowspan="1" colspan="1">Bowtie + eXpress</td><td rowspan="1" colspan="1">8</td><td rowspan="1" colspan="1">13 800</td><td rowspan="1" colspan="1">111 273</td><td rowspan="1" colspan="1">188x</td></tr></tbody></table></table-wrap></p>
      <p>Overall, these results demonstrate that RNA-Skim provides comparable accuracy with other methods on both simulated and real data, using a much shorter running time.</p>
    </sec>
  </sec>
  <sec>
    <title>6 DISCUSSION AND CONCLUSION</title>
    <p>We introduced RNA-Skim, a lightweight method that can rapidly and efficiently estimate the transcript abundance levels in RNA-Seq data. RNA-Skim exploits the property of sig-mers, significantly reducing the number of k-mers used by the method and the scale of the optimization problem solved by the EM algorithm. Based on our benchmark, it is at least 10× faster than any alternative methods. To the best of our knowledge, the design principle of almost all existing methods is to use as much data as possible for RNA-Seq quantification. Our results are encouraging, in the sense that they demonstrate a different, yet promising, direction of building a much faster method by discovering and using only informative and reliable features—the counts of sig-mers in RNA-Seq data.</p>
    <p>Currently, the annotation databases are incomplete and still under development. Aligners and alignment-dependent RNA-Seq methods are commonly used to allow unknown transcript discovery, which will further improve the completeness and accuracy of the annotation databases. The performance of tools like Sailfish and RNA-Skim depends on the quality of the annotation database. Their accuracy is likely to improve when annotation databases become complete or nearly complete in the future. They will become better choices when we have a better understanding of transcriptome and transcript discovery task becomes less important.</p>
    <p>Because RNA-Skim is still under development, there are several directions to further improve its performance. (i) RNA-Skim uses a simple hash table implementation without any optimization on the memory usage. We will investigate advanced data structures enabling better memory utilization. (ii) Currently, the sig-mer selection algorithm in RNA-Skim only ensures uniform coverage. In the future, we will explore variable selection techniques to select fewer but more informative sig-mers. (iii) The current version of RNA-Skim does not have built-in bias correction capability, even though it already produces results comparable with the state-of-the-art methods with bias correction on real data. We plan to incorporate bias correction in the next version of RNA-Skim, which is likely to improve the performance further. In addition, we also plan to support multi-thread implementation and deploy RNA-Skim in differential expression analysis. We are optimistic that, when we add the multi-threading capability to RNA-Skim, the running time will be further improved.</p>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We would like to thank those center members who prepared and processed samples as well as those who commented on and encouraged the development of RNA-Skim, in particular, Leonard McMillan, Vladimir Jojic, William Valdar and Yunjung Kim. We also would like to thank three anonymous reviewers for their thoughtful comments.</p>
    <p><italic>Funding</italic>: This work was funded by <funding-source>NIH</funding-source><award-id>R01HG006703</award-id>, <funding-source>NIH</funding-source><award-id>P50 GM076468-08</award-id> and <funding-source>NSF</funding-source>
<award-id>IIS-1313606</award-id>.</p>
    <p><italic>Conflict of Interest:</italic> none declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="btu288-B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Au</surname>
            <given-names>KF</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Detection of splice junctions from paired-end RNA-seq data by SpliceMap</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>4570</fpage>
        <lpage>4578</lpage>
        <pub-id pub-id-type="pmid">20371516</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Bloom</surname>
            <given-names>BH</given-names>
          </name>
        </person-group>
        <article-title>Space/time trade-offs in hash coding with allowable errors</article-title>
        <source>Commun. ACM</source>
        <year>1970</year>
        <volume>13</volume>
        <fpage>422</fpage>
        <lpage>426</lpage>
      </element-citation>
    </ref>
    <ref id="btu288-B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Dadgar</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Bloomd library</article-title>
        <year>2013</year>
        <comment><ext-link ext-link-type="uri" xlink:href="https://github.com/armon/bloomd">https://github.com/armon/bloomd</ext-link> (14 May 2014, date last accessed)</comment>
      </element-citation>
    </ref>
    <ref id="btu288-B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Flicek</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ensembl 2012</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2011</year>
        <volume>40</volume>
        <fpage>D84</fpage>
        <lpage>D90</lpage>
        <pub-id pub-id-type="pmid">22086963</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B5">
      <element-citation publication-type="book">
        <person-group person-group-type="author">
          <name>
            <surname>Fu</surname>
            <given-names>CP</given-names>
          </name>
          <etal/>
        </person-group>
        <person-group person-group-type="editor">
          <name>
            <surname>Sharan</surname>
            <given-names>R</given-names>
          </name>
        </person-group>
        <article-title>An alignment-free regression approach for estimating allele-specific expression using RNA-seq data</article-title>
        <source>Research in Computational Molecular Biology</source>
        <year>2014</year>
        <volume>Vol. 8394</volume>
        <publisher-name>Springer</publisher-name>
        <fpage>69</fpage>
        <lpage>84</lpage>
      </element-citation>
    </ref>
    <ref id="btu288-B6">
      <element-citation publication-type="journal">
        <collab>Google</collab>
        <article-title>Protocal buffers</article-title>
        <year>2013</year>
        <comment><ext-link ext-link-type="uri" xlink:href="https://code.google.com/p/protobuf/">https://code.google.com/p/protobuf/</ext-link> (14 May 2014, date last accessed)</comment>
      </element-citation>
    </ref>
    <ref id="btu288-B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Grabherr</surname>
            <given-names>MG</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Full-length transcriptome assembly from RNA-Seq data without a reference genome</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2011</year>
        <volume>29</volume>
        <fpage>644</fpage>
        <lpage>652</lpage>
        <pub-id pub-id-type="pmid">21572440</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Griebel</surname>
            <given-names>T</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Modelling and simulating generic rna-seq experiments with the flux simulator</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2012</year>
        <volume>40</volume>
        <fpage>10073</fpage>
        <lpage>10083</lpage>
        <pub-id pub-id-type="pmid">22962361</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Guttman</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ab initio reconstruction of cell type–specific transcriptomes in mouse reveals the conserved multi-exonic structure of lincRNAs</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>503</fpage>
        <lpage>510</lpage>
        <pub-id pub-id-type="pmid">20436462</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hsieh</surname>
            <given-names>W</given-names>
          </name>
        </person-group>
        <article-title>Stringpiece</article-title>
        <year>2013</year>
        <comment><ext-link ext-link-type="uri" xlink:href="https://chromium.googlesource.com/chromium/">https://chromium.googlesource.com/chromium/</ext-link> (14 May 2014, date last accessed)</comment>
      </element-citation>
    </ref>
    <ref id="btu288-B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Karp</surname>
            <given-names>RM</given-names>
          </name>
          <name>
            <surname>Rabin</surname>
            <given-names>MO</given-names>
          </name>
        </person-group>
        <article-title>Efficient randomized pattern-matching algorithms</article-title>
        <source>IBM J. Res. Dev.</source>
        <year>1987</year>
        <volume>31</volume>
        <fpage>249</fpage>
        <lpage>260</lpage>
      </element-citation>
    </ref>
    <ref id="btu288-B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kurtz</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A new method to compute K-mer frequencies and its application to annotate large repetitive plant genomes</article-title>
        <source>BMC Genomics</source>
        <year>2008</year>
        <volume>9</volume>
        <fpage>517</fpage>
        <pub-id pub-id-type="pmid">18976482</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Langmead</surname>
            <given-names>B</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R25</fpage>
        <pub-id pub-id-type="pmid">19261174</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Le</surname>
            <given-names>HS</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Probabilistic error correction for RNA sequencing</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2013</year>
        <volume>41</volume>
        <fpage>e109</fpage>
        <pub-id pub-id-type="pmid">23558750</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Li</surname>
            <given-names>B</given-names>
          </name>
          <name>
            <surname>Dewey</surname>
            <given-names>CN</given-names>
          </name>
        </person-group>
        <article-title>RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>323</fpage>
        <pub-id pub-id-type="pmid">21816040</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Marcais</surname>
            <given-names>G</given-names>
          </name>
          <name>
            <surname>Kingsford</surname>
            <given-names>C</given-names>
          </name>
        </person-group>
        <article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title>
        <source>Bioinformatics</source>
        <year>2011</year>
        <volume>27</volume>
        <fpage>764</fpage>
        <lpage>770</lpage>
        <pub-id pub-id-type="pmid">21217122</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Melsted</surname>
            <given-names>P</given-names>
          </name>
          <name>
            <surname>Pritchard</surname>
            <given-names>JK</given-names>
          </name>
        </person-group>
        <article-title>Efficient counting of k-mers in DNA sequences using a bloom filter</article-title>
        <source>BMC Bioinformatics</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>333</fpage>
        <pub-id pub-id-type="pmid">21831268</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Nicolae</surname>
            <given-names>M</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Estimation of alternative splicing isoform frequencies from RNA-Seq data</article-title>
        <source>Algorithms Mol. Biol.</source>
        <year>2011</year>
        <volume>6</volume>
        <fpage>9</fpage>
        <pub-id pub-id-type="pmid">21504602</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Ozsolak</surname>
            <given-names>F</given-names>
          </name>
          <name>
            <surname>Milos</surname>
            <given-names>PM</given-names>
          </name>
        </person-group>
        <article-title>RNA sequencing: advances, challenges and opportunities</article-title>
        <source>Nat. Rev. Genet</source>
        <year>2010</year>
        <volume>12</volume>
        <fpage>87</fpage>
        <lpage>98</lpage>
        <pub-id pub-id-type="pmid">21191423</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B20">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Models for transcript quantification from RNA-Seq</article-title>
        <year>2011</year>
        <comment><italic>arXiv.org,</italic> 1104.3889v2</comment>
      </element-citation>
    </ref>
    <ref id="btu288-B21">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Patro</surname>
            <given-names>R</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Sailfish: alignment-free Isoform quantification from RNA-seq reads using lightweight algorithms</article-title>
        <source>Nat. Biotech.</source>
        <year>2014</year>
        <volume>32</volume>
        <fpage>462</fpage>
        <lpage>464</lpage>
      </element-citation>
    </ref>
    <ref id="btu288-B22">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Pruitt</surname>
            <given-names>KD</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>NCBI reference sequences (RefSeq): a curated non-redundant sequence database of genomes, transcripts and proteins</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2007</year>
        <volume>35</volume>
        <fpage>D61</fpage>
        <lpage>D65</lpage>
        <pub-id pub-id-type="pmid">17130148</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B23">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Rizk</surname>
            <given-names>G</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>DSK: k-mer counting with very low memory usage</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>652</fpage>
        <lpage>653</lpage>
        <pub-id pub-id-type="pmid">23325618</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B24">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Roberts</surname>
            <given-names>A</given-names>
          </name>
          <name>
            <surname>Pachter</surname>
            <given-names>L</given-names>
          </name>
        </person-group>
        <article-title>Streaming fragment assignment for real-time analysis of sequencing experiments</article-title>
        <source>Nat. Methods</source>
        <year>2013</year>
        <volume>10</volume>
        <fpage>71</fpage>
        <lpage>73</lpage>
        <pub-id pub-id-type="pmid">23160280</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B25">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>TopHat: discovering splice junctions with RNA-Seq</article-title>
        <source>Bioinformatics</source>
        <year>2009</year>
        <volume>25</volume>
        <fpage>1105</fpage>
        <lpage>1111</lpage>
        <pub-id pub-id-type="pmid">19289445</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B26">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Transcript assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>516</fpage>
        <lpage>520</lpage>
        <pub-id pub-id-type="pmid">20436463</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B27">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Trapnell</surname>
            <given-names>C</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Differential gene and transcript expression analysis of RNA-seq experiments with TopHat and Cufflinks</article-title>
        <source>Nat. Protocols</source>
        <year>2012</year>
        <volume>7</volume>
        <fpage>562</fpage>
        <lpage>578</lpage>
      </element-citation>
    </ref>
    <ref id="btu288-B28">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Turro</surname>
            <given-names>E</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Haplotype and isoform specific expression estimation using multi-mapping RNA-seq reads</article-title>
        <source>Genome Biol.</source>
        <year>2011</year>
        <volume>12</volume>
        <fpage>R13</fpage>
        <pub-id pub-id-type="pmid">21310039</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B29">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Uziela</surname>
            <given-names>K</given-names>
          </name>
          <name>
            <surname>Honkela</surname>
            <given-names>A</given-names>
          </name>
        </person-group>
        <article-title>Probe region expression estimation for RNA-seq data for improved microarray comparability</article-title>
        <year>2013</year>
        <comment><italic>ArXiv e-prints,</italic> 1304.1698v1</comment>
      </element-citation>
    </ref>
    <ref id="btu288-B30">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>K</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>MapSplice: accurate mapping of RNA-seq reads for splice junction discovery</article-title>
        <source>Nucleic Acids Res.</source>
        <year>2010</year>
        <volume>38</volume>
        <fpage>e178</fpage>
        <pub-id pub-id-type="pmid">20802226</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B31">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>RNA-Seq: a revolutionary tool for transcriptomics</article-title>
        <source>Nat. Rev. Genet.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>57</fpage>
        <lpage>63</lpage>
        <pub-id pub-id-type="pmid">19015660</pub-id>
      </element-citation>
    </ref>
    <ref id="btu288-B32">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Zhang</surname>
            <given-names>Z</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>GeneScissors: a comprehensive approach to detecting and correcting spurious transcriptome inference owing to RNA-seq reads misalignment</article-title>
        <source>Bioinformatics</source>
        <year>2013</year>
        <volume>29</volume>
        <fpage>291</fpage>
        <lpage>299</lpage>
      </element-citation>
    </ref>
  </ref-list>
</back>
