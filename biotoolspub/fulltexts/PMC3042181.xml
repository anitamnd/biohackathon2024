<?properties open_access?>
<?DTDIdentifier.IdentifierValue -//NLM//DTD Journal Publishing DTD v2.3 20070202//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName journalpublishing.dtd?>
<?SourceDTD.Version 2.3?>
<?ConverterInfo.XSLTName jp2nlmx2.xsl?>
<?ConverterInfo.Version 2?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-id journal-id-type="hwp">bioinfo</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">3042181</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btq713</article-id>
    <article-id pub-id-type="publisher-id">btq713</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Papers</subject>
        <subj-group>
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>AGE: defining breakpoints of genomic structural variants at single-nucleotide resolution, through optimal alignments with gap excision</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Abyzov</surname>
          <given-names>Alexej</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="corresp" rid="COR1">*</xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Gerstein</surname>
          <given-names>Mark</given-names>
        </name>
        <xref ref-type="aff" rid="AFF1">
          <sup>1</sup>
        </xref>
        <xref ref-type="aff" rid="AFF1">
          <sup>2</sup>
        </xref>
        <xref ref-type="aff" rid="AFF1">
          <sup>3</sup>
        </xref>
      </contrib>
    </contrib-group>
    <aff id="AFF1"><sup>1</sup>Program in Computation Biology and Bioinformatics, <sup>2</sup>Department of Molecular Biophysics and Biochemistry and <sup>3</sup>Department of Computer Science, Yale University, New Haven, CT 06520, USA</aff>
    <author-notes>
      <corresp id="COR1">* To whom correspondence should be addressed.</corresp>
      <fn>
        <p>Associate Editor: Alfonso Valencia</p>
      </fn>
    </author-notes>
    <pub-date pub-type="ppub">
      <day>1</day>
      <month>3</month>
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>13</day>
      <month>1</month>
      <year>2011</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>13</day>
      <month>1</month>
      <year>2011</year>
    </pub-date>
    <!-- PMC Release delay is 0 months and 0 days and was based on the
							<pub-date pub-type="epub"/>. -->
    <volume>27</volume>
    <issue>5</issue>
    <fpage>595</fpage>
    <lpage>603</lpage>
    <history>
      <date date-type="received">
        <day>17</day>
        <month>6</month>
        <year>2010</year>
      </date>
      <date date-type="rev-recd">
        <day>13</day>
        <month>12</month>
        <year>2010</year>
      </date>
      <date date-type="accepted">
        <day>14</day>
        <month>12</month>
        <year>2010</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2011. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2011</copyright-year>
      <license license-type="creative-commons" xlink:href="http://creativecommons.org/licenses/by-nc/2.0/uk/">
        <license-p><!--CREATIVE COMMONS-->This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by-nc/2.5">http://creativecommons.org/licenses/by-nc/2.5</ext-link>), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <abstract>
      <p><bold>Motivation:</bold> Defining the precise location of structural variations (SVs) at single-nucleotide breakpoint resolution is an important problem, as it is a prerequisite for classifying SVs, evaluating their functional impact and reconstructing personal genome sequences. Given approximate breakpoint locations and a bridging assembly or split read, the problem essentially reduces to finding a correct sequence alignment. Classical algorithms for alignment and their generalizations guarantee finding the optimal (in terms of scoring) global or local alignment of two sequences. However, they cannot generally be applied to finding the biologically correct alignment of genomic sequences containing SVs because of the need to simultaneously span the SV (e.g. make a large gap) and perform precise local alignments at the flanking ends.</p>
      <p><bold>Results:</bold> Here, we formulate the computations involved in this problem and describe a dynamic-programming algorithm for its solution. Specifically, our algorithm, called AGE for Alignment with Gap Excision, finds the optimal solution by simultaneously aligning the 5′ and 3′ ends of two given sequences and introducing a ‘large-gap jump’ between the local end alignments to maximize the total alignment score. We also describe extensions allowing the application of AGE to tandem duplications, inversions and complex events involving two large gaps. We develop a memory-efficient implementation of AGE (allowing application to long contigs) and make it available as a downloadable software package. Finally, we applied AGE for breakpoint determination and standardization in the 1000 Genomes Project by aligning locally assembled contigs to the human genome.</p>
      <p><bold>Availability and Implementation:</bold> AGE is freely available at <ext-link ext-link-type="uri" xlink:href="http://sv.gersteinlab.org/age">http://sv.gersteinlab.org/age</ext-link>.</p>
      <p>
        <bold>Contact:</bold>
        <email>pi@gersteinlab.org</email>
      </p>
      <p><bold>Supplementary information:</bold><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/full/btq713/DC1">Supplementary data</ext-link> are available at <italic>Bioinformatics</italic> online.</p>
    </abstract>
  </article-meta>
</front>
<body>
  <sec sec-type="intro" id="SEC1">
    <title>1 INTRODUCTION</title>
    <p>The problem of single-nucleotide breakpoint resolution for genome structural variations (SVs) (deletions, insertions, inversions, etc.) is of great importance for a number of reasons. First, as recently demonstrated (<xref ref-type="bibr" rid="B10">Lam <italic>et al.</italic>, 2010</xref>), single-nucleotide breakpoint resolution is absolutely necessary for SV classification and annotation. It is also important for genotyping known SVs in newly sequenced genomes (<xref ref-type="bibr" rid="B10">Lam <italic>et al.</italic>, 2010</xref>). Second, precise breakpoints are required to evaluate the functional impact of SVs. For example, uncertainty in breakpoints in just a few bases may lead to ambiguous conclusions when an SV is close to a splice-junction and/or regulation sites or overlaps exon(s). Last, but not least, construction of personal diploid genomes (one of the ultimate long-term goals of human genome analysis) cannot be done properly without precise knowledge of SV breakpoints.</p>
    <p>It might seem obvious, but the only plausible way to achieve single-nucleotide breakpoint resolution is to align two sequences: one without an SV (e.g. a region in the reference human genome) and another containing an SV (e.g. locally assembled contig, completely sequenced and assembled fosmid clone or long read). Most commonly used methods for SV detection provide only approximate breakpoint locations. Paired-end mapping (also called read-pair) approaches inherently have uncertainty in breakpoint resolution, due to uncertainty in the distance between sequenced ends and the possibility of read mismapping (<xref ref-type="bibr" rid="B9">Korbel <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B13">Medvedev <italic>et al.</italic>, 2009</xref>). Resolution of breakpoints by array comparative genomic hybridization analysis and read-depth approaches is limited by the probe density (for array) and the genomic bin size (for read-depth) used to produce the subsequently analyzed signal (Abyzov <italic>et al.</italic>, 2010; <xref ref-type="bibr" rid="B13">Medvedev <italic>et al.</italic>, 2009</xref>; <xref ref-type="bibr" rid="B18">Wang <italic>et al.</italic>, 2009</xref>).</p>
    <p>While being imprecise in breakpoint resolution, the approaches mentioned above yield approximate SV locations, where a local assembly of a haplotype bridging an SV region could be accomplished. Subsequently, alignment of the assembled contig to the predicted SV region identifies precise SV breakpoints. The described strategy is employed by the 1000 Genomes Project (<xref ref-type="bibr" rid="B3">Durbin <italic>et al.</italic>, 2010</xref>; Mills, 2010), where tens of thousands of local haplotype assemblies in the SV regions are made. Proper alignment of those contigs will and already is an important challenge that must be fulfilled precisely and computationally efficiently, given the number of expected local assemblies. Single-nucleotide resolution of SV breakpoints will allow their standardization and analysis in a single framework.</p>
    <p>The problem of aligning two sequences containing SVs might seem to be trivial, but upon deeper consideration it is not. The major complications are due to possible repeats within aligned sequence, sequence homology/identity around breakpoints and, the often complex nature of SVs, where, for instance, a deletion/insertion is accompanied by smaller insertion/deletion. More specifically, classical algorithms, which guarantee the finding the optimal global Needleman–Wunsch (<xref ref-type="bibr" rid="B4">Gotoh, 1982</xref>; <xref ref-type="bibr" rid="B15">Needleman and Wunsch, 1970</xref>) and local SmithWaterman (<xref ref-type="bibr" rid="B17">Smith and Waterman, 1981</xref>) alignments, generally cannot arrive at a biologically correct solution when aligned sequences contain SVs (<xref ref-type="fig" rid="F1">Fig. 1</xref>). The major problem with those algorithms is the gap penalty. A large gap penalty does not allow for the extension of alignment across an SV. Reducing the gap penalty interferes with the alignment scoring scheme and jeopardizes the construction of the proper alignment in regions flanking the SV and when the sequence(s) contains repeats. In addition, it offers only a partial solution to the problem, and cases when the SV is not a pure deletion or insertion are still not solved (<xref ref-type="fig" rid="F1">Fig. 1</xref>B).
<fig id="F1" position="float"><label>Fig. 1.</label><caption><p>Schematics of the expected optimal alignment around a structural variation (left) and alignments produced by global Needleman–Wunsch (NW) and local Smith–Waterman (SW) algorithms (right). The structural variation, i.e. deletion, is in red. In (<bold>B</bold>), the deletion is accompanied by a small insertion (blue). Throughout the figure, alignable flanking regions are shown in green and orange. Both SW and NW algorithms generally cannot arrive at a biologically correct alignment.</p></caption><graphic xlink:href="btq713f1"/></fig></p>
    <p>A generalized global alignment (<xref ref-type="bibr" rid="B6">Huang and Chao, 2003</xref>) algorithm is generally also unable to solve the formulated problem. The algorithm works by introducing the concept of a ‘difference block’, e.g. large gap, and imposing a cap on the penalty for having such a block in an alignment. When a block is small, e.g. small gap, it is penalized, as it would be in the classical Needleman–Wunsch algorithm. For a large block, e.g. large gap, the penalty is constant. Therefore, it can only be applied to the alignment of sequences where the SV size is large enough for the algorithm to work in the non-classical mode. More importantly, the algorithm can be misled by sequence similarity around SV breakpoints. Specifically, when sequences around breakpoints are homologous (<xref ref-type="fig" rid="F2">Fig. 2</xref>A), the algorithm has to choose between aligning with a higher sequence identity—but introducing a large gap—or aligning with a lower sequence identity and no gap (<xref ref-type="fig" rid="F2">Fig. 2</xref>B). Only the former scenario is correct, but either one can be chosen by the algorithm (considered to be optimal) depending on the scoring scheme, size of deletion, length and percent of homology around breakpoints, and the lengths of aligned sequences flanking the breakpoints (longer flanking sequences allow one to resolve breakpoints within longer and higher homologous sequences). Incidentally, this problem is inherent to all algorithms employing a concave/piecewise gap penalty. It is also inherent to Needleman–Wunsch and Smith–Waterman algorithms. Therefore, the described problem may hamper the discovery and characterization of a particular class of NAHR (<xref ref-type="bibr" rid="B10">Lam <italic>et al.</italic>, 2010</xref>) SVs that are characterized by long similar/homologous sequences around breakpoints.
<fig id="F2" position="float"><label>Fig. 2.</label><caption><p>Sequence similarity (see <bold>A</bold>) around SV breakpoints (shades of green) can mislead local and/or global alignment(s) to produce incorrect alignment (see <bold>B</bold>). Conceptually, to produce correct alignment one has to find an optimal jump between overlapping local alignments. However, local alignment calculation and jump finding have to be done simultaneously rather than successively to guarantee finding the optimal alignment (Supplementary Fig. S4).</p></caption><graphic xlink:href="btq713f2"/></fig></p>
    <p>The ‘sandwich dynamic programming’ algorithm, introduced (<xref ref-type="bibr" rid="B19">Wu and Watanabe, 2005</xref>) to align cDNAs to exons, could be useful, but even if adopted for aligning sequences containing SVs, it does not offer a general solution, as it has the same problems as the Needleman–Wunsch algorithm when handling events that are not pure deletions or insertions (<xref ref-type="fig" rid="F1">Fig. 1</xref>B). Also, none of the mentioned algorithms could be applied to determine tandem duplication and inversion breakpoints.</p>
    <p>Hence, with the aim of achieving single-nucleotide SV breakpoint resolution and standardization, we have developed an algorithm for the correct alignment of sequences containing SVs. This article first describes an algorithm for optimal sequence alignment containing only a single SV deletion or insertion. We then describe algorithm extensions to align sequences containing other SVs. To accomplish the first aim, we formulated it as a problem of finding the optimal local alignment of two sequences containing one unaligned and unpenalized region/gap (corresponding to one SV) between two aligned regions.</p>
    <p>The rationale is that flanking regions of an SV are very similar and can be aligned collinearly (5′ end to 5′ end and 3′ end to 3′ end) using a local Smith–Waterman algorithm (<xref ref-type="fig" rid="F2">Fig. 2</xref>C). To yield the final alignment, the two local ones should simply be combined. However, if the alignments of the flanking regions overlap, combining two local alignments becomes complicated, and an optimal jump from one local alignment to another must be found—that is, a gap must be introduced—to maximize the alignment score. The optimal (highest scoring) alignment may not be found if the jump is searched between already calculated local alignments because trimming a local alignment does not guarantee that it is still optimal (a simple example demonstrating the concept is shown in Supplementary Fig. S4). Therefore, the calculation of flanking sequence alignments and finding the optimal jump between the two must be done simultaneously rather than successively.</p>
    <p>When formulated this way, the problem explicitly addresses only the issue of the largest gap in the alignment and does not require adjustment or modifications of the alignment scoring scheme. Therefore, substitution matrices and gap penalties tuned to a particular alignment purpose, e.g. contig or short/long-read alignment, can be used unchanged.</p>
  </sec>
  <sec sec-type="methods" id="SEC2">
    <title>2 METHODS</title>
    <sec id="SEC2.1">
      <title>2.1 Algorithm</title>
      <p>Let us denote the lengths of two compared sequences as <italic>N</italic> and <italic>M</italic>. The algorithm starts with the construction of two [0,<italic>N</italic> + 1]<italic>x</italic>[0,<italic>M</italic> + 1] alignment scoring matrices <italic>S</italic><sup><italic>L</italic></sup> and <italic>S</italic><sup><italic>R</italic></sup>, <italic>a la</italic> the Smith–Waterman algorithm, for the local alignment of two sequences (<xref ref-type="fig" rid="F3">Fig. 3</xref>A). Indices [1,<italic>N</italic>] and [1,<italic>M</italic>] in each matrix, respectively, are used to store alignment scores while indices 0, <italic>N</italic> + 1, and <italic>M</italic> + 1 are used for the convenience of filling the matrices and tracing back. One matrix represents a score for the alignment initiated from the 5′ ends (left flanking region of the SV), whereas the other one represents a score for the alignment initiated from the 3′ ends (right flanking regions of the SV). The maximum in each matrix defines a cell from which to start tracing back to find the best local alignment. Importantly, the maximum in the leading/trailing submatrix does so for the local alignment of sequence ends. Specifically, the maximum <italic>M</italic><sup><italic>L</italic></sup>(<italic>n</italic>, <italic>m</italic>) in the leading submatrix [0,<italic>n</italic>]<italic>x</italic>[0,<italic>m</italic>] of <italic>S</italic><sup><italic>L</italic></sup>, where <italic>n</italic>&lt;=<italic>N</italic> and <italic>m</italic>&lt;=<italic>M</italic>, anchors the best local alignment for <italic>n</italic> and <italic>m</italic> nucleotides at the 5′ ends. Similarly, the maximum <italic>M</italic><sup><italic>R</italic></sup>(<italic>n</italic>+1,<italic>m</italic> + 1) in the trailing submatrix [<italic>n</italic>+1, <italic>N</italic>+1]<italic>x</italic>[<italic>m</italic>+1,<italic>M</italic>+1] of <italic>S</italic><sup><italic>R</italic></sup>, anchors the best local alignment for <italic>N</italic> − <italic>n</italic> and <italic>M</italic> − <italic>m</italic> nucleotides at the 3′ ends: i.e.
<disp-formula id="M1"><label>(1)</label><graphic xlink:href="btq713m1"/></disp-formula>
Then, the total score of aligning <italic>n</italic> and <italic>m</italic> nucleotides at the 5′ ends and <italic>N</italic> − <italic>n</italic> and <italic>M</italic> − <italic>m</italic> nucleotides at the 3′ ends is <italic>M</italic><sup><italic>L</italic></sup>(<italic>n</italic>, <italic>m</italic>)+<italic>M</italic><sup><italic>R</italic></sup>(<italic>n</italic>+1, <italic>m</italic>+1). The optimal alignment has the highest score; thus it maximizes the sum: i.e.
<disp-formula id="M2"><label>(2)</label><graphic xlink:href="btq713m2"/></disp-formula>
where BS is the best score. In other words, one has to maximize the sum of the maxima in the paired submatrices of <italic>S</italic><sup><italic>L</italic></sup> and <italic>S</italic><sup><italic>R</italic></sup> (<xref ref-type="fig" rid="F3">Fig. 3</xref>B). Such a maximum can be found in quadratic time. Note that
<disp-formula id="M3"><label>(3)</label><graphic xlink:href="btq713m3"/></disp-formula>
Using (<xref ref-type="disp-formula" rid="M3">3</xref>), one can convert matrices <italic>S</italic><sup><italic>L</italic></sup> and <italic>S</italic><sup><italic>R</italic></sup> to have values <italic>M</italic><sup><italic>L</italic></sup>(<italic>n</italic>, <italic>m</italic>) and <italic>M</italic><sup><italic>R</italic></sup>(<italic>n</italic>, <italic>m</italic>), respectively. During such conversion, one can trace from whence the value in each cell was assigned, just like when constructing an alignment score matrix. Having matrices <italic>M</italic><sup><italic>L</italic></sup> and <italic>M</italic><sup><italic>R</italic></sup> calculated, one can find the highest score sum (<xref ref-type="disp-formula" rid="M2">2</xref>) in one pass through the matrices. The corresponding alignment is then constructed by, first, tracing back the maximum location in each matrix and, then, tracing back alignments for the 5′ and 3′ ends (i.e. alignment is inferred from each matrix) and combining them (<xref ref-type="fig" rid="F3">Fig. 3</xref>C). The unaligned region is the one between 5′ and 3′ end alignments.
<fig id="F3" position="float"><label>Fig. 3.</label><caption><p>Schematics of the algorithm. (<bold>A</bold>) Two alignment score matrices for the alignment of the 5′ ends (<italic>S</italic><sup><italic>L</italic></sup> matrix) and the 3′ ends (<italic>S</italic><sup><italic>R</italic></sup> matrix) are constructed <italic>a la</italic> the Smith–Waterman local alignment. In this example, scoring is as follows: match = 1, mismatch = −1, gap open penalty = 4 and gap extend penalty = 2. Orange arrows represent trace-back information. The best alignment maximizes the sum of the maximum in the leading submatrix (highlighted buff) in <italic>S</italic><sup><italic>L</italic></sup> and the maximum in the paired trailing submatrix (highlighted cyan) in <italic>S</italic><sup><italic>R</italic></sup>. (<bold>B</bold>) Matrices are converted so that each cell contains the maximum score of the leading submatrix in <italic>S</italic><sup><italic>L</italic></sup> and the trailing submatrix in <italic>S</italic><sup><italic>R</italic></sup>. The location of score maxima is traced (blue arrows), just like the score is traced in scoring matrices. Maximum score sum (red) can now be found in one pass through the matrices. (<bold>C</bold>) Alignment is constructed by, first, tracing back the maximum location (red arrows) in each matrix and then, tracing back alignments for the 5′ and 3′ ends (green arrow). The resulting alignment is the sum of the alignments at the 5′ and 3′ ends, with the unaligned region in-between. The maximum score can be redundant (bold rectangles). However, the resulting alignment will be the same.</p></caption><graphic xlink:href="btq713f3"/></fig></p>
      <p>The best score can be redundant (<xref ref-type="fig" rid="F3">Fig. 3</xref>B). However, redundancy does not necessarily imply alternative alignments. As shown in the figure, the sum for indices (<italic>n</italic>, <italic>m</italic>) falling in the bold area is equal to the best score. However, tracing back for the maximum locations in each matrix will lead to the same cells, i.e. the very northwest and southeast cells of the bold area for matrices <italic>S</italic><sup><italic>L</italic></sup> and <italic>S</italic><sup><italic>R</italic></sup>, respectively. Intuitively, one can think about finding the optimal (maximum) score as a procedure of trying all possible sequence splitting into two subsequences (5′ end and 3′ end) and optimally aligning those subsequences. The splitting of one of the sequences within the SV region does not change flanking alignment, and, thus, generates the same maximum score (Supplementary Fig. S6). Thus, only different maximum locations are indicative of alternative alignments. It is a trivial computational task to check for such alternative alignments.</p>
      <p>Another reason for a redundant maximum score sum is sequence identity around SV breakpoints (Supplementary Fig. S2). In such cases, ‘shuttling’ of one or a few pairs of aligned nucleotides in alignment from one breakpoint to another does not change the overall score. Thus, in some cases, the resolution of SV breakpoints is naturally limited to the length of sequences that are identical around breakpoints. Note, that the limitation is not methodological, but, rather, biological. Moreover, wherever the actual breakpoints within the identical sequences are, the resulting sequence, after SV excision, is the same. Therefore, breakpoint uncertainty caused by sequence identity will not affect downstream analysis. Such cases can be easily identified and described by post-processing the produced alignments.</p>
    </sec>
    <sec id="SEC2.2">
      <title>2.2 Generalization of the algorithm</title>
      <p>The generalizations described below allow for breakpoint inference for multiple deletions/insertions, tandem duplication, inversions and for splice sites within genes. As previously explained, approximate locations of breakpoints and read/assembly bridging SV breakpoints or splice sites are a prerequisite.</p>
      <sec id="SEC2.2.1">
        <title>2.2.1 Inferring breakpoints when sequences contain multiple deletions/insertions</title>
        <p>When aligned sequences contain two SVs (either insertions or deletions) an optimal alignment with two unaligned regions must be found. Thus, it is necessary to introduce two jumps between three matrices (Supplementary Fig. S5). As before, two matrices <italic>M</italic><sup><italic>L</italic></sup> and <italic>M</italic><sup><italic>R</italic></sup> represent the alignment of sequence 5′ and 3′ ends and one <italic>S</italic><sup><italic>R</italic></sup> represents the local alignment of sequence fragments between two SVs. The optimal alignment will maximize the total score of aligning all three fragments: i.e.
<disp-formula id="M4"><label>(4)</label><graphic xlink:href="btq713m4"/></disp-formula>
where <italic>TS</italic><sup><italic>R</italic></sup>(<italic>n</italic>, <italic>m</italic>) is a trace−back path for element (<italic>n</italic>, <italic>m</italic>) in matrix <italic>S</italic><sup><italic>R</italic></sup>. The last condition states that elements (<italic>n</italic>, <italic>m</italic>) and (<italic>n</italic>′, <italic>m</italic>′) are on the same alignment path. The maximum can efficiently be found by checking all pairs of (<italic>n</italic>, <italic>m</italic>) and only those (<italic>n</italic>′, <italic>m</italic>′) pairs that can be traced back from the (<italic>n</italic>+1, <italic>m</italic>+1) element in matrix S<sup><italic>R</italic></sup>. Tracing back is a linear procedure and may require up to min(<italic>N</italic>, <italic>M</italic>) operations: thus, the optimal solution can be found in <italic>O</italic>(<italic>NM</italic> min(<italic>N</italic>, <italic>M</italic>)) time in the worst case.</p>
        <p>Furthermore, the algorithm can be inductively generalized to produce alignments with any given <italic>k</italic> number of SVs. For <italic>k</italic> = 3, one needs to maximize the sum of scores for Smith–Waterman alignment of 5′ end sequences and that of 3′ end sequences with two SVs: i.e.
<disp-formula><graphic xlink:href="btq713um1"/></disp-formula>
where BS<sup><italic>r</italic></sup> is the best score for aligning residual sequences at 3′ ends, i.e. [<italic>n</italic>+1, <italic>N</italic>] and [<italic>m</italic>+1, <italic>M</italic>]. Generally, for <italic>k</italic> &gt; 2 SVs in alignment, best score can be found using the following induction
<disp-formula id="M5"><label>(5)</label><graphic xlink:href="btq713m5"/></disp-formula>
For each increment of <italic>k</italic> &gt; 2, the time complexity of the algorithm increases multiplicatively by a factor of <italic>O</italic>(<italic>NM</italic>).</p>
      </sec>
      <sec id="SEC2.2.2">
        <title>2.2.2 Inferring splice sites by cDNA alignment</title>
        <p>Given a cDNA sequence containing two exons and an approximate location of an intron between the two exons, the described algorithm can be extended to determine the splice site at breakpoint resolution. Aligning such cDNA to the genome is similar to aligning sequences containing deletion/insertion SVs, but has an important difference. The complete cDNA sequence is expected to align to the genome, i.e. cases when deletion is accompanied by micro insertion (<xref ref-type="fig" rid="F1">Fig. 1</xref>B) do not happen. In other words, with an excised intron the sequence should align to the genome globaly. This can be accomplished by introducing two changes to the algorithm: (i) matrices S<sup><italic>L</italic></sup> and S<sup><italic>R</italic></sup> should be calculated <italic>a la</italic> the Needelman–Wunsch algorithm; (ii) maxima should be calculated for different submatrices
<disp-formula id="M6"><label>(6)</label><graphic xlink:href="btq713m6"/></disp-formula>
where we assume that the second sequence is cDNA. Now <italic>M</italic><sup><italic>L</italic></sup>(<italic>n</italic>, <italic>m</italic>) stores the value of the the best global alignment for the 5′ end, while <italic>M</italic><sup><italic>R</italic></sup>(<italic>n</italic>, <italic>m</italic>) does so for the 3′ end. Subsequent steps (finding best score and tracking back) should be done as before.</p>
      </sec>
      <sec id="SEC2.2.3">
        <title>2.2.3 Inferring breakpoints for tandem duplications</title>
        <p>Aligning a contig or a read that spans tandem duplication breakpoints is similar to aligning sequences with deletions and insertions (<xref ref-type="fig" rid="F4">Fig. 4</xref>). In particular, when a contig/read spans an insertion site around a breakpoint that is farther from the duplication original site (<xref ref-type="fig" rid="F4">Fig. 4</xref>A), then the alignment procedure is exactly the same as for sequences with simple deletion or insertion. In cases when a contig/read spans an insertion site around a breakpoint that is closer to the duplication original site (<xref ref-type="fig" rid="F4">Fig. 4</xref>B), then the order of the aligned fragments is different in the two sequences. Using the described methodology, but maximizing a different function (assuming the second sequence is a contig/read)
<disp-formula id="M7"><label>(7)</label><graphic xlink:href="btq713m7"/></disp-formula>
one can find the highest scoring split-alignment for a contig's 3′- and 5′-ends. Subsequently, post-processing can be applied to ensure that end alignments do not overlap.
<fig id="F4" position="float"><label>Fig. 4.</label><caption><p>Schematics for aligning sequences with tandem duplication and inversion. Color gradient reflects the directionality of sequences from the 5′-end to the 3′-end. (<bold>A</bold>) Aligning a contig/read spanning a duplication breakpoint can be no different than aligning sequences with a deletion/insertion. (<bold>B</bold>) For contigs spanning other duplication breakpoints, the order of the aligned fragments is different in the two se-quences. (<bold>C</bold>) Optimal split-alignment for sequences with inversions is calculated by aligning the 5′-end of the first sequence to the 5′-end of the second one and aligning the 3′-end of the first sequence to the 3′-end of the reverse complement of the second one.</p></caption><graphic xlink:href="btq713f4"/></fig></p>
      </sec>
      <sec id="SEC2.2.4">
        <title>2.2.4 Inferring breakpoints for inversions</title>
        <p>The algorithm for the optimal alignment of inversions was described a number of years ago (<xref ref-type="bibr" rid="B16">Schoniger and Waterman, 1992</xref>). However, it is only applicable to cases in which an inversion is completely enclosed in either of the aligned sequences. Cases in which an inversion is incomplete, i.e. one sequence spans only the inversion breakpoint, are not handled by that algorithm, but this can be accomplished by generalizing the algorithm described above. Indeed, if we have two sequences, part of the first sequence will align to the second and another non-overlapping part will align to the reverse complement of the second sequence (see schematics in <xref ref-type="fig" rid="F4">Fig. 4</xref>). Again, using the described methodology one can find split-alignment for a contig's 3′ and 5′ ends. Note that one should use a reverse complement for one of the aligned sequences to construct matrix S<sup><italic>R</italic></sup> together with maximizing the function in Equation (<xref ref-type="disp-formula" rid="M7">7</xref>). The same post-processing as for tandem duplication breakpoint inference can be applied to ensure that end alignments do not overlap.</p>
      </sec>
    </sec>
    <sec id="SEC2.3">
      <title>2.3 Alternative recurrence</title>
      <p>The described algorithm and generalizations can be restated using alternative but equivalent recurrence. Namely, to infer deletion/insertion breakpoints, the recurrence is
<disp-formula id="M8"><label>(8)</label><graphic xlink:href="btq713m8"/></disp-formula>
and to infer splice sites, the recurrence is
<disp-formula id="M9"><label>(9)</label><graphic xlink:href="btq713m9"/></disp-formula>
where second sequence is cDNA, match(<italic>n</italic>, <italic>m</italic>) is match or mismatch between nucleotides in positions <italic>n</italic> and <italic>m</italic>, and gap is a gap function. The matrices <italic>S</italic><sup>1</sup> and <italic>M</italic><sup>1</sup> are the same as <italic>S</italic><sup><italic>L</italic></sup> and <italic>M</italic><sup><italic>L</italic></sup>, while the matrix <italic>S</italic><sup>2</sup> keeps the alignment score for the left flanking region (matrix <italic>S</italic><sup>1</sup>) and (via <italic>M</italic><sup>1</sup>) for the right flanking region. Generalizing to two or more SVs/introns in an alignment requires the use of additional pairs of matrices <italic>M</italic><sup><italic>i</italic></sup> and <italic>S</italic><sup><italic>i</italic></sup> for each SV/intron, where the recurrence for <italic>M</italic><sup><italic>i</italic></sup> utilizes values from <italic>S</italic><sup><italic>i</italic></sup> (just as <italic>M</italic><sup>1</sup> does from <italic>S</italic><sup>1</sup>), and the recurrence for <italic>S</italic><sup><italic>i</italic>+1</sup> utilizes values from <italic>M</italic><sup><italic>i</italic></sup> (just as <italic>S</italic><sup>2</sup> does from <italic>M</italic><sup>1</sup>). Linear space alignment algorithms (<xref ref-type="bibr" rid="B2">Chao <italic>et al.</italic>, 1994</xref>; <xref ref-type="bibr" rid="B5">Hirschberg, 1975</xref>) can also be applied with this recurrence.</p>
    </sec>
  </sec>
  <sec sec-type="results" id="SEC3">
    <title>3 RESULTS</title>
    <sec id="SEC3.1">
      <title>3.1 Implementation, Alignment with Gap Excision program</title>
      <p>We have implemented the algorithm described above in the C++ language as the Alignment with Gap Excision (AGE ) program (freely available at <ext-link ext-link-type="uri" xlink:href="http://sv.gersteinlab.org/age">http://sv.gersteinlab.org/age</ext-link>). The current implementation is limited to aligning sequences containing only one deletion, insertion or inversion. The major challenge in implementation was to reduce memory usage, as the algorithm operates on two matrices (unlike only one, in the case of the classical Smith–Waterman algorithm) and requires additional storage for recording of traces to locations of maxima (<xref ref-type="fig" rid="F3">Fig. 3</xref>B). In addition, genomics sequences containing SVs are typically thousands (at times, hundreds of thousands) of nucleotides in length requiring large matrices for alignment calculations. To reduce memory usage, we used small integers for scoring and greedy affine gap penalty calculations (Supplementary Material). Having done this, we showed that AGE is practical even when aligning long sequences of fosmid clones (Supplementary Material).</p>
      <p>The input to the program is simple and consists of two FASTA files, e.g. reference sequence and assembled contig, specification of expected SV, e.g. option –inv for alignment with inversions, and optional specification of sequence subranges and scoring parameters. The output is comprehensive and includes breakpoint coordinates of unaligned/excised region(s) for the two best alignments, i.e. having the same maximum score (this can be used to evaluate alignment uniqueness), coordinates of aligned regions, i.e. regions flanking the SV from left and right, and lengths of identical sequence at breakpoints calculated in three different ways: around breakpoints, inside breakpoints and outside breakpoints (Supplementary Fig. S2). The reported numbers are followed by actual sequence alignment in blast-like format.</p>
      <p>We have tested AGE to ensure that it reports accurate breakpoints. To do this, we constructed a total of 312 contigs, by merging the 500 bp flanking regions of large deletions (&gt;1 kb), known with breakpoint resolution from sequencing and assembly by long Sanger reads (<xref ref-type="bibr" rid="B11">Levy <italic>et al.</italic>, 2007</xref>). We then aligned these contigs to deletion regions extended by 1 kb. In 303 (97%) cases, SV breakpoints from optimal alignment(s) by AGE exactly matched those we started from. In 8 (2.5%) cases, contigs could be perfectly aligned (i.e. no mismatched and no gap) to the reference genome; thus, no breakpoints were reported by AGE. In one case, however, breakpoints were different. This may be due to the existence of more than two optimal solutions, with the solution containing actual deletion breakpoints simply not being reported. Indeed, when increasing contig length up to 5 kb we found exact breakpoints for all deletions. Thus, AGE is perfectly accurate in SV breakpoint determination.</p>
    </sec>
    <sec id="SEC3.2">
      <title>3.2 Application to 1000 Genomes Project data</title>
      <p>The AGE program has been used to align genomic contigs that were locally assembled by the 1000 Genome Project around predicted SV regions (mostly deletions), with the aim of confirming predictions and standardizing deletion breakpoints. Due to technical limitations, current local assembly was done for a fraction (∼50%) of predicted deletions and mostly for predictions made by read-pair and split-read approaches, with only a tiny fraction of contigs assembled for SV regions predicted by read-depth approaches. Thus, assembled regions are not representative of all predicted deletions but are still suited for demonstration purposes. The length of contigs ranged from 43 to 2472, with an average of 915 nt. A total of 38 226 contigs were aligned.</p>
      <p>Below we will refer to predicted breakpoints, determined by a variety of approaches (read-pair, read-depth, etc.) as ‘predicted’ and to breakpoints inferred from contig alignment using AGE as ‘derived’. ‘Predicted’ breakpoints are typically a few dozen nucleotides away from the true ones. Of all SV predictions, 35 822 (94%) have regions between predicted and derived breakpoints overlapping by 80%, reciprocally. Moreover, for 36 290 (95%) predictions, we observed excellent (within 50 bases) agreement of breakpoints (Supplementary Fig. S3). The analyzed set of deletions was a union of predictions made using different data and approaches that have different breakpoint resolutions. Therefore, we use either criterion: 80% reciprocal overall or 50 bases difference at each breakpoint, to consider a prediction confirmed by assembly. A total of 36 986 (97%) deletions have been confirmed, ranging in size from 51 to 994 703 nt in length. For the confirmed deletions, we investigated sequence identity around breakpoints (see definition in Supplementary Fig. S2). We observed that 97% of sequences that are identical around breakpoints are shorter than 20 nt, but can be as long as 100 nt. Distribution of sequence identity around breakpoints has two distinct peaks (around 0 and 15 bp). The first one is likely to represent random sequence matches, while the second one is indicative of transposable elements (<xref ref-type="bibr" rid="B10">Lam <italic>et al.</italic>, 2010</xref>), characterized by Target Site Duplication around breakpoints (∼15 nt in length). Identical sequences outside breakpoints (Supplementary Fig. S3) were almost all no longer than 30 nt and were typically shorter than 10 nt. Similarly, 98% of identical sequences inside breakpoints were shorter than 10 nt.</p>
      <p>Most of the contigs could be aligned as pure deletions, but in 4340 (11%) cases, deletion was accompanied by micro-insertion (as on schematics in <xref ref-type="fig" rid="F1">Fig. 1</xref>B). We further analyzed such cases (Supplementary Fig. S3). The distribution of insertion lengths peaks around 1 nt and decays exponentially. There is a slight elevation in the event frequency for insertions of length 12 and 15 nt. This could be further studied to determine whether this is a biological phenomenon. In one case, the inserted sequences was extremely long (1385 nt) and could be partially aligned to the opposite DNA strand in the region of deletion and to the genome in the region next to corresponding deletion. Thus, the region is a complex SV event that has a deletion, duplication and inversion. Another alternative is that the region was misassembled.</p>
    </sec>
    <sec id="SEC3.3">
      <title>3.3 Examples</title>
      <p>Application of other existing programs aimed at long gap alignment to the same set of contigs from the 1000 Genomes Project revealed a substantially higher SV confirmation rate when using AGE, thereby suggesting its superior performance in determining SV breakpoints (Supplementary Material). As it was pointed out in <xref ref-type="sec" rid="SEC1">Section 1</xref>, SV breakpoints with sequences homology around them are the most challenging to determine (<xref ref-type="fig" rid="F2">Fig. 2</xref>). For such SVs, successful resolution of breakpoints depends on the length and percent of homology of breakpoint sequences as well as the lengths of the aligned sequence. To demonstrate the advantage of using AGE in practice, we provide a few examples of alignments in such cases. We chose to demonstrate examples for AGE, CrossMatch (<ext-link ext-link-type="uri" xlink:href="http://www.phrap.org/phredphrapconsed.html">http://www.phrap.org/phredphrapconsed.html</ext-link>, implementing the Smith–Waterman alignment), GAP3 (<xref ref-type="bibr" rid="B6">Huang and Chao, 2003</xref>) (implementing a generalized global alignment with piecewise gap penalty), and Blat (<xref ref-type="bibr" rid="B7">Kent, 2002</xref>), a popular heuristic alignment program aimed at aligning highly similar sequences with large gaps.</p>
      <p><xref ref-type="fig" rid="F5">Figure 5</xref>A shows an example of comparative contig-to-genome alignments made by these programs. The contig is the local assembly of the alternative (to the reference genome) haplotype around the region of predicted deletion chr20:2,969,769-2,970,056. AGE alignment clearly identifies a large unaligned region, confirms the predicted deletion and derives deletion breakpoints as chr20:2,969,756-2,970,052—in excellent agreement with the prediction. GAP3 was challenged by sequence homology around deletion breakpoints and did not introduce a large gap. Instead, it aligned the left flanking sequence with gaps and mismatches. CrossMatch aligned two regions, but contig sequence fragments in those two alignments overlap by 315 bases and additional analysis is required for breakpoints identification. Note that, as mentioned, post-processing of local overlapping alignment does not guarantee finding optimal alignment around breakpoints (see also Supplementary Fig. S4). Blat heuristically starts alignment from near-exact matches and, in fact, penalizes large gaps. Exact repeats within homologous regions flanking breakpoints misled the program into initiating alignment in the wrong regions and, as a result, produced incorrect alignment. Another example (Supplementary <xref ref-type="fig" rid="F5">Fig. 5</xref>B) demonstrates the difficulty the GAP3 program has producing the correct alignment in cases when SV flanking sequences are not long enough. Note all alignment methods that utilize concave/piecewise gap penalty will face the same challenge.
<fig id="F5" position="float"><label>Fig. 5.</label><caption><p>Comparison of assembled contig alignments in the region of predicted deletions. The first line in each alignment is the sequence for the genomic region, while the second is for the contig sequence. Nucleotide numbering is sequential, starting from one in both compared sequences. Each alignment is accompanied by a schematic representation underneath. (<bold>A</bold>) The predicted deletion is chr20:2,969,769-2,970,056. The contig that is 614 bp in length has been aligned by the AGE, GAP3, CrossMatch and Blat programs to the predicted region of deletion, which is extended by 1 kb in each direction, i.e. from 2,968,769-2,971,056. The first sequence (genomic region) has two pairs of homologous sequences: orange to yellow and dark green to light green. AGE alignment clearly identifies a large unaligned region, confirms a predicted deletion, and derives deletion breakpoints as chr20:2,969,756-2,970,052 (coordinates are for the first and the last deleted bases). Note that the resulting breakpoints are in excellent agreement (within 13 bp) with the prediction. No other program was able to produce the correct alignment. (<bold>B</bold>) Predicted deletion is chr8:118,292,728-118,292,987. The contig of 530 bp in length has been aligned by the AGE and GAP3 programs to the predicted region of deletion, which is extended by 1 kb in each direction, i.e. from 118 291 728 to 118 293 987. AGE alignment clearly identifies a large unaligned region, confirms a predicted deletion, and derives deletion breakpoints as chr8:118,292,711-118,292,990 (coordinates are for first and last deleted bases). GAP3 is not able to align the left flanking sequence, as the penalty for a long gap outweighs the matches at the left flanking sequence. All coordinates are for human hg18 reference.</p></caption><graphic xlink:href="btq713f5"/></fig></p>
    </sec>
  </sec>
  <sec sec-type="discussion" id="SEC4">
    <title>4 DISCUSSION</title>
    <p>We have described an algorithm for the correct alignment of two nucleotide sequences containing SVs, i.e. deletion, insertion, tandem duplication or inversion, called AGE. The algorithm does not require the adjustment or modification of the alignment scoring scheme(s) that is usually tuned for a particular alignment purpose, e.g. cross-species, contig or read alignments. Thus, the algorithm can be universally applied in various biological studies relying on alignment. Its distinguishing feature is that it produces correct alignments in cases that are challenging for methods utilizing concave/piecewise gap penalty, i.e. cases with long sequence homology around breakpoints and/or a short SV region and/or short flanking sequences. The algorithm naturally handles certain cases of complex SV events, such as when deletion is accompanied by insertion.</p>
    <p>The most straightforward application of AGE is single-nucleotide SV breakpoint resolution and standardization, as has just been demonstrated by using the algorithm implemented in AGE software. While the algorithm can be generalized to align sequences containing any number of SVs, its most practical (due to computational scalability) application is to align sequence with one SV, which are also the most common. Sequences containing more SVs are very rare, even when aligning long sequences of fosmid clones (<xref ref-type="bibr" rid="B8">Kidd <italic>et al.</italic>, 2008</xref>). Still, AGE can also be useful in aligning such sequences. One may envision a strategy in which SV breakpoints are approximately localized (e.g. by analysis of local alignments) and then precisely identified using AGE to align only subsequences that flank SVs.</p>
    <p>Of perhaps equal importance, the algorithm can be used to refine read alignment once a read has been heuristically mapped to a particular genomic location that is expected to contain an SV. Such read realignment has potential implications for genotyping known SVs in newly sequenced individuals, and/or discovering <italic>de novo</italic> SVs within loci that are known or expected to have a strong copy-number association with genetic diseases (<xref ref-type="bibr" rid="B12">McCarroll and Altshuler, 2007</xref>). Finally, the algorithm is not alphabet specific and can therefore be applied to the alignment of protein sequences.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="PMC_1" content-type="local-data">
      <caption>
        <title>Supplementary Data</title>
      </caption>
      <media mimetype="text" mime-subtype="html" xlink:href="supp_27_5_595__index.html"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="msword" xlink:href="supp_btq713_AGE_R3_aan_v1_supp.doc"/>
      <media xlink:role="associated-file" mimetype="application" mime-subtype="x-zip-compressed" xlink:href="supp_btq713_Non-redundant_breakpoints_by_AGE_release_txt.zip"/>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack>
    <title>ACKNOWLEDGEMENTS</title>
    <p>We thank Xinmeng Jasmine Mu and Declan Clarke for useful discussions, and Nicholas Carriero for help with algorithm implementation. We also thank the anonymous reviewers for valuable suggestions.</p>
    <p><italic>Funding</italic>: <funding-source>National Institutes of Health</funding-source> (<funding-source>NIH</funding-source>); the AL Williams Professorship funds; ‘Yale University Biomedical High Performance Computing Center’; its support team (in particular, Robert Bjornson and Nicholas Carriero); <funding-source>NIH</funding-source> (grant <award-id>RR19895</award-id>).</p>
    <p><italic>Conflict of Interest</italic>: None declared.</p>
  </ack>
  <ref-list>
    <title>REFERENCES</title>
    <ref id="B1">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Abyzov</surname>
            <given-names>A</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>CNVnator: an approach to discover, genotype and characterize typical and atypical cnvs from family and population genome sequencing</article-title>
        <source>Genome Res.</source>
        <year>2011</year>
        <comment>(submitted)</comment>
      </element-citation>
    </ref>
    <ref id="B2">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Chao</surname>
            <given-names>KM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Recent developments in linear-space alignment methods: a survey</article-title>
        <source>J. Comput. Biol.</source>
        <year>1994</year>
        <volume>1</volume>
        <fpage>271</fpage>
        <lpage>291</lpage>
        <pub-id pub-id-type="pmid">8790471</pub-id>
      </element-citation>
    </ref>
    <ref id="B3">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Durbin</surname>
            <given-names>RM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>A map of human genome variation from population-scale sequencing</article-title>
        <source>Nature</source>
        <year>2010</year>
        <volume>467</volume>
        <fpage>1061</fpage>
        <lpage>1073</lpage>
        <pub-id pub-id-type="pmid">20981092</pub-id>
      </element-citation>
    </ref>
    <ref id="B4">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Gotoh</surname>
            <given-names>O</given-names>
          </name>
        </person-group>
        <article-title>An improved algorithm for matching biological sequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1982</year>
        <volume>162</volume>
        <fpage>705</fpage>
        <lpage>708</lpage>
        <pub-id pub-id-type="pmid">7166760</pub-id>
      </element-citation>
    </ref>
    <ref id="B5">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Hirschberg</surname>
            <given-names>DS</given-names>
          </name>
        </person-group>
        <article-title>A linear space algorithm for computing maximal common subsequences</article-title>
        <source>Commun. ACM</source>
        <year>1975</year>
        <volume>18</volume>
        <fpage>341</fpage>
        <lpage>343</lpage>
      </element-citation>
    </ref>
    <ref id="B6">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Huang</surname>
            <given-names>X</given-names>
          </name>
          <name>
            <surname>Chao</surname>
            <given-names>K-M</given-names>
          </name>
        </person-group>
        <article-title>A generalized global alignment algorithm</article-title>
        <source>Bioinformatics</source>
        <year>2003</year>
        <volume>19</volume>
        <fpage>228</fpage>
        <lpage>233</lpage>
        <pub-id pub-id-type="pmid">12538243</pub-id>
      </element-citation>
    </ref>
    <ref id="B7">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kent</surname>
            <given-names>WJ</given-names>
          </name>
        </person-group>
        <article-title>BLAT–the BLAST-like alignment tool</article-title>
        <source>Genome Res.</source>
        <year>2002</year>
        <volume>12</volume>
        <fpage>656</fpage>
        <lpage>664</lpage>
        <pub-id pub-id-type="pmid">11932250</pub-id>
      </element-citation>
    </ref>
    <ref id="B8">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Kidd</surname>
            <given-names>JM</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Mapping and sequencing of structural variation from eight human genomes</article-title>
        <source>Nature</source>
        <year>2008</year>
        <volume>453</volume>
        <fpage>56</fpage>
        <lpage>64</lpage>
        <pub-id pub-id-type="pmid">18451855</pub-id>
      </element-citation>
    </ref>
    <ref id="B9">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Korbel</surname>
            <given-names>JO</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>PEMer: a computational framework with simulation-based error models for inferring genomic structural variants from massive paired-end sequencing data</article-title>
        <source>Genome Biol.</source>
        <year>2009</year>
        <volume>10</volume>
        <fpage>R23</fpage>
        <pub-id pub-id-type="pmid">19236709</pub-id>
      </element-citation>
    </ref>
    <ref id="B10">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Lam</surname>
            <given-names>HY</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Nucleotide-resolution analysis of structural variants using BreakSeq and a breakpoint library</article-title>
        <source>Nat. Biotechnol.</source>
        <year>2010</year>
        <volume>28</volume>
        <fpage>47</fpage>
        <lpage>55</lpage>
        <pub-id pub-id-type="pmid">20037582</pub-id>
      </element-citation>
    </ref>
    <ref id="B11">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Levy</surname>
            <given-names>S</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>The diploid genome sequence of an individual human</article-title>
        <source>PLoS Biol.</source>
        <year>2007</year>
        <volume>5</volume>
        <fpage>e254</fpage>
        <pub-id pub-id-type="pmid">17803354</pub-id>
      </element-citation>
    </ref>
    <ref id="B12">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>McCarroll</surname>
            <given-names>SA</given-names>
          </name>
          <name>
            <surname>Altshuler</surname>
            <given-names>DM</given-names>
          </name>
        </person-group>
        <article-title>Copy-number variation and association studies of human disease</article-title>
        <source>Nat. Genet.</source>
        <year>2007</year>
        <volume>39</volume>
        <fpage>S37</fpage>
        <lpage>S42</lpage>
        <pub-id pub-id-type="pmid">17597780</pub-id>
      </element-citation>
    </ref>
    <ref id="B13">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Medvedev</surname>
            <given-names>P</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>Computational methods for discovering structural variation with next-generation sequencing</article-title>
        <source>Nat. Methods</source>
        <year>2009</year>
        <volume>6</volume>
        <fpage>S13</fpage>
        <lpage>S20</lpage>
        <pub-id pub-id-type="pmid">19844226</pub-id>
      </element-citation>
    </ref>
    <ref id="B14">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Mills</surname>
            <given-names>RE</given-names>
          </name>
        </person-group>
        <article-title>Mapping structural variation at fine-scale by population genome sequencing</article-title>
        <source>Nature</source>
        <year>2011</year>
        <comment>(in press)</comment>
      </element-citation>
    </ref>
    <ref id="B15">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Needleman</surname>
            <given-names>SB</given-names>
          </name>
          <name>
            <surname>Wunsch</surname>
            <given-names>CD</given-names>
          </name>
        </person-group>
        <article-title>A general method applicable to the search for similarities in the amino acid sequence of two proteins</article-title>
        <source>J. Mol. Biol.</source>
        <year>1970</year>
        <volume>48</volume>
        <fpage>443</fpage>
        <lpage>453</lpage>
        <pub-id pub-id-type="pmid">5420325</pub-id>
      </element-citation>
    </ref>
    <ref id="B16">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Schoniger</surname>
            <given-names>M</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>A local algorithm for DNA sequence alignment with inversions</article-title>
        <source>Bull. Math. Biol.</source>
        <year>1992</year>
        <volume>54</volume>
        <fpage>521</fpage>
        <lpage>536</lpage>
        <pub-id pub-id-type="pmid">1591531</pub-id>
      </element-citation>
    </ref>
    <ref id="B17">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Smith</surname>
            <given-names>TF</given-names>
          </name>
          <name>
            <surname>Waterman</surname>
            <given-names>MS</given-names>
          </name>
        </person-group>
        <article-title>Identification of common molecular subsequences</article-title>
        <source>J. Mol. Biol.</source>
        <year>1981</year>
        <volume>147</volume>
        <fpage>195</fpage>
        <lpage>197</lpage>
        <pub-id pub-id-type="pmid">7265238</pub-id>
      </element-citation>
    </ref>
    <ref id="B18">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wang</surname>
            <given-names>LY</given-names>
          </name>
          <etal/>
        </person-group>
        <article-title>MSB: a mean-shift-based approach for the analysis of structural variation in the genome</article-title>
        <source>Genome Res.</source>
        <year>2009</year>
        <volume>19</volume>
        <fpage>106</fpage>
        <lpage>117</lpage>
        <pub-id pub-id-type="pmid">19037015</pub-id>
      </element-citation>
    </ref>
    <ref id="B19">
      <element-citation publication-type="journal">
        <person-group person-group-type="author">
          <name>
            <surname>Wu</surname>
            <given-names>TD</given-names>
          </name>
          <name>
            <surname>Watanabe</surname>
            <given-names>CK</given-names>
          </name>
        </person-group>
        <article-title>GMAP: a genomic mapping and alignment program for mRNA and EST sequences</article-title>
        <source>Bioinformatics</source>
        <year>2005</year>
        <volume>21</volume>
        <fpage>1859</fpage>
        <lpage>1875</lpage>
        <pub-id pub-id-type="pmid">15728110</pub-id>
      </element-citation>
    </ref>
  </ref-list>
</back>
