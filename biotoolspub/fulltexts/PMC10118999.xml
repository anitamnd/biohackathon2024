<?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.2 20190208//EN?>
<?DTDIdentifier.IdentifierType public?>
<?SourceDTD.DTDName JATS-journalpublishing1.dtd?>
<?SourceDTD.Version 1.2?>
<?ConverterInfo.XSLTName jats2jats3.xsl?>
<?ConverterInfo.Version 1?>
<?properties open_access?>
<processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats">
  <restricted-by>pmc</restricted-by>
</processing-meta>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Bioinformatics</journal-id>
    <journal-id journal-id-type="iso-abbrev">Bioinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">bioinformatics</journal-id>
    <journal-title-group>
      <journal-title>Bioinformatics</journal-title>
    </journal-title-group>
    <issn pub-type="ppub">1367-4803</issn>
    <issn pub-type="epub">1367-4811</issn>
    <publisher>
      <publisher-name>Oxford University Press</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">10118999</article-id>
    <article-id pub-id-type="pmid">37039842</article-id>
    <article-id pub-id-type="doi">10.1093/bioinformatics/btad185</article-id>
    <article-id pub-id-type="publisher-id">btad185</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Original Paper</subject>
        <subj-group subj-group-type="category-toc-heading">
          <subject>Genome Analysis</subject>
        </subj-group>
      </subj-group>
      <subj-group subj-group-type="category-taxonomy-collection">
        <subject>AcademicSubjects/SCI01060</subject>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>Decomposing mosaic tandem repeats accurately from long reads</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-7123-3018</contrib-id>
        <name>
          <surname>Masutani</surname>
          <given-names>Bansho</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Kawahara</surname>
          <given-names>Riki</given-names>
        </name>
      </contrib>
      <contrib contrib-type="author" corresp="yes">
        <contrib-id contrib-id-type="orcid" authenticated="false">https://orcid.org/0000-0002-6201-8885</contrib-id>
        <name>
          <surname>Morishita</surname>
          <given-names>Shinichi</given-names>
        </name>
        <xref rid="btad185-cor1" ref-type="corresp"/>
        <!--moris@edu.k.u-tokyo.ac.jp-->
        <aff><institution>Department of Computational Biology and Medical Sciences, Graduate School of Frontier Sciences, The University of Tokyo</institution>, Chiba 277-8562, <country country="JP">Japan</country></aff>
      </contrib>
    </contrib-group>
    <contrib-group>
      <contrib contrib-type="editor">
        <name>
          <surname>Marschall</surname>
          <given-names>Tobias</given-names>
        </name>
        <role>Associate Editor</role>
      </contrib>
    </contrib-group>
    <author-notes>
      <corresp id="btad185-cor1">Corresponding author. Department of Computational Biology and Medical Sciences, Graduate School of Frontier Sciences, The University of Tokyo, Chiba 277-8562, Japan. E-mail: <email>moris@edu.k.u-tokyo.ac.jp</email></corresp>
    </author-notes>
    <pub-date pub-type="collection">
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="epub" iso-8601-date="2023-04-11">
      <day>11</day>
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <pub-date pub-type="pmc-release">
      <day>11</day>
      <month>4</month>
      <year>2023</year>
    </pub-date>
    <volume>39</volume>
    <issue>4</issue>
    <elocation-id>btad185</elocation-id>
    <history>
      <date date-type="received">
        <day>09</day>
        <month>8</month>
        <year>2022</year>
      </date>
      <date date-type="rev-recd">
        <day>20</day>
        <month>1</month>
        <year>2023</year>
      </date>
      <date date-type="editorial-decision">
        <day>20</day>
        <month>3</month>
        <year>2023</year>
      </date>
      <date date-type="accepted">
        <day>06</day>
        <month>4</month>
        <year>2023</year>
      </date>
      <date date-type="corrected-typeset">
        <day>20</day>
        <month>4</month>
        <year>2023</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>© The Author(s) 2023. Published by Oxford University Press.</copyright-statement>
      <copyright-year>2023</copyright-year>
      <license>
        <ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref>
        <license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p>
      </license>
    </permissions>
    <self-uri xlink:href="btad185.pdf"/>
    <abstract>
      <title>Abstract</title>
      <sec id="s1">
        <title>Motivation</title>
        <p>Over the past 30 years, extended tandem repeats (TRs) have been correlated with ∼60 diseases with high odds ratios, and most known TRs consist of single repeat units. However, in the last few years, mosaic TRs composed of different units have been found to be associated with several brain disorders by long-read sequencing techniques. Mosaic TRs are difficult-to-characterize sequence configurations that are usually confirmed by manual inspection. Widely used tools are not designed to solve the mosaic TR problem and often fail to properly decompose mosaic TRs.</p>
      </sec>
      <sec id="s2">
        <title>Results</title>
        <p>We propose an efficient algorithm that can decompose mosaic TRs in the input string with high sensitivity. Using synthetic benchmark data, we demonstrate that our program named uTR outperforms TRF and RepeatMasker in terms of prediction accuracy, this is especially true when mosaic TRs are more complex, and uTR is faster than TRF and RepeatMasker in most cases.</p>
      </sec>
      <sec id="s3">
        <title>Availability and implementation</title>
        <p>The software program <monospace>uTR</monospace> that implements the proposed algorithm is available at <ext-link xlink:href="https://github.com/morisUtokyo/uTR" ext-link-type="uri">https://github.com/morisUtokyo/uTR</ext-link>.</p>
      </sec>
    </abstract>
    <funding-group>
      <award-group award-type="grant">
        <funding-source>
          <institution-wrap>
            <institution>Japan Agency for Medical Research and Development</institution>
            <institution-id institution-id-type="DOI">10.13039/100009619</institution-id>
          </institution-wrap>
        </funding-source>
        <award-id>21tm0424219h0001</award-id>
      </award-group>
    </funding-group>
    <counts>
      <page-count count="6"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec>
    <title>1 Introduction</title>
    <p>Tandem repeats (TRs) are consecutive genomic sequence duplications of one or more units in tandem (<xref rid="btad185-B27" ref-type="bibr">Smith 1976</xref>). In the early 1980s, when TRs consisting of units of 2–6 base pairs (bp) were discovered, they were called microsatellites (<xref rid="btad185-B22" ref-type="bibr">Miesfeld et al. 1981</xref>; <xref rid="btad185-B29" ref-type="bibr">Spritz 1981</xref>; <xref rid="btad185-B15" ref-type="bibr">Hamada and Kakunaga 1982</xref>) but were later referred to as short sequence repeats, short tandem repeats, or simple repeats (<xref rid="btad185-B14" ref-type="bibr">Ellegren 2004</xref>). In 1985, TRs of units of a few dozen base pairs were also discovered and designated as minisatellites to distinguish them from microsatellites (<xref rid="btad185-B18" ref-type="bibr">Jeffreys et al. 1985</xref>). Micro- and minisatellites varying in length among individuals were identified (<xref rid="btad185-B30" ref-type="bibr">Tautz et al. 1986</xref>), and referred to as variable number tandem repeats (VNTR), which have been valuable for understanding genetic diversity in human populations (<xref rid="btad185-B3" ref-type="bibr">Bowcock et al. 1994</xref>; <xref rid="btad185-B31" ref-type="bibr">Weber and Wong 1993</xref>). Here, micro-/minisatellites and VNTRs are collectively referred to as TRs.</p>
    <p>With the availability of abundant genomic data, such as individual exome and whole genome sequences on a population basis, a number of algorithms have been proposed to estimate the length and structure of TRs on a genome-wide basis in individual genomes (<xref rid="btad185-B7" ref-type="bibr">Dashnow et al. 2018</xref>; <xref rid="btad185-B11" ref-type="bibr">Dolzhenko et al. 2019</xref>, <xref rid="btad185-B10" ref-type="bibr">2020</xref>; <xref rid="btad185-B24" ref-type="bibr">Mousavi et al. 2019</xref>), although it is still difficult to accurately determine the entire structure of TRs of &gt;100 bp in length using short-read sequencing. Therefore, long-read sequencing platforms, such as PacBio and Nanopore, have recently become attractive because long-read sequencing can cover most TRs &lt;10 kb in length and can sequence long DNA fragments without using polymerase chain reaction (PCR), which is prone to replication slippages during amplification (<xref rid="btad185-B16" ref-type="bibr">Hannan 2018</xref>). An initial study of using long read sequencing suggested that ∼30% of structural variants are TRs (<xref rid="btad185-B1" ref-type="bibr">Audano et al. 2019</xref>).</p>
    <p>Over the past 30 years since 1990, ∼60 diseases have been shown to be associated with extremely expanded TRs at different loci, which are assumed to be disease-causing variants (<xref rid="btad185-B9" ref-type="bibr">Depienne and Mandel 2021</xref>). The diversity of TRs is considered to provide insight into missing heritability. Long-read sequencing is expected to uncover two types of hidden, disease-associated TRs: minisatellites and mosaic TRs. Indeed, several disease-associated minisatellites have been identified (<xref rid="btad185-B4" ref-type="bibr">Cortese et al. 2019</xref>; <xref rid="btad185-B5" ref-type="bibr">Course et al. 2020</xref>; De Roeck et al. <xref rid="btad185-B8" ref-type="bibr">2018</xref>; <xref rid="btad185-B28" ref-type="bibr">Song et al. 2018</xref>).</p>
    <p>Another type of disease-associated TR has a mosaic structure in which different units are expanded in individual genomes. For example, a total of 400–2000 copies of AAAAG, AAAGG, AAGAG, and AGAGC within the RFC1 gene are associated with cerebellar ataxia, neuropathy, vestibular areflexia syndrome (CANVAS) (<xref rid="btad185-B4" ref-type="bibr">Cortese et al. 2019</xref>). Several disease-associated mosaic TRs have been reported to date (<xref rid="btad185-B17" ref-type="bibr">Ishiura et al. 2018</xref>; <xref rid="btad185-B20" ref-type="bibr">Koob et al. 1999</xref>; <xref rid="btad185-B21" ref-type="bibr">Liquori et al. 2001</xref>; <xref rid="btad185-B32" ref-type="bibr">Wright et al. 2019</xref>). The sequence compositions of mosaic TRs are difficult to characterize and are usually confirmed by manual inspection. Widely used tools such as PBSV, TRF (<xref rid="btad185-B2" ref-type="bibr">Benson 1999</xref>), and RepeatMasker (<ext-link xlink:href="http://repeatmasker.org" ext-link-type="uri">http://repeatmasker.org</ext-link>) were not designed to compensate for this issue and often fail to correctly parse mosaic TRs. For example, repeats of the form (AAAG)<italic toggle="yes">i</italic> (AG)<italic toggle="yes">j</italic> (AGGG)<italic toggle="yes">k</italic> (AG)<italic toggle="yes">l</italic> (AAAG)<italic toggle="yes">m</italic>, where the italic suffixes indicate the number of unit occurrences, are likely to be falsely detected as a single (AAAG)-repeat or (AG)-repeat. Therefore, we developed computational algorithms to address the issue of automatic characterization of mosaics in TRs.</p>
  </sec>
  <sec>
    <title>2 Materials and methods</title>
    <sec>
      <title>2.1 Approximate regular expression matching problem</title>
      <p>Replication slippage and/or non-homologous recombination are thought to drive TR stretching that generates tandem copies of units. For this reason, mosaic TRs often have a limited number of units specific to them. It is crucial to find a set of strings (units) <italic toggle="yes">U</italic> for the input string (TR) <italic toggle="yes">S</italic>.</p>
      <p>Before proposing a method for selecting the unit set <italic toggle="yes">U</italic>, we point out here that once <italic toggle="yes">U</italic> is selected, an optimal solution can be obtained according to a reasonable measure with a known efficient algorithm. The idea is to calculate an optimal concatenation of elements in <italic toggle="yes">U</italic> that partially matches the input <italic toggle="yes">S</italic> with the minimum Levenshtein distance (i.e. the sum of substitutions, insertions, and deletions) of the global alignment between <italic toggle="yes">S</italic> and the concatenation. Partial matches are taken into account to accommodate sequence errors and unit-copy mutations. This is a subproblem of the approximate regular expression matching problem, which is to calculate an optimal instance of a regular expression that maximizes its alignment score with a given string, because a concatenation of elements in <italic toggle="yes">U</italic> is represented as the regular expression <inline-formula id="IE1"><mml:math id="IM1" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>|</mml:mo><mml:mo>…</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>*</mml:mo></mml:mrow></mml:math></inline-formula> for all units <inline-formula id="IE2"><mml:math id="IM2" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>u</mml:mi></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> in <italic toggle="yes">U</italic>. The approximate regular expression matching problem can be solved efficiently in <inline-formula id="IE3"><mml:math id="IM3" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> (<xref rid="btad185-B25" ref-type="bibr">Myers and Miller 1989</xref>). This concept has recently been reinvented and used in the string decomposer algorithm (<xref rid="btad185-B12" ref-type="bibr">Dvorkina et al. 2020</xref>), which is a wraparound dynamic programming algorithm that handles a set of multiple repeat units, say <italic toggle="yes">U</italic>. In the next subsection, we propose a method for selecting a better set of units.</p>
    </sec>
    <sec>
      <title>2.2 Selecting a better set of units according to maximum parsimony that minimizes replication slippage events</title>
      <p>We continue to use <italic toggle="yes">S</italic> and <italic toggle="yes">U</italic> for denoting a string of length <italic toggle="yes">n</italic> and a set of substrings in <italic toggle="yes">S</italic> that respectively represent a TR and units in it. Suppose that <italic toggle="yes">S</italic> is decomposed into a series of neighboring, non-overlapping substrings <inline-formula id="IE4"><mml:math id="IM4" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> for <inline-formula id="IE5"><mml:math id="IM5" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula> such that <inline-formula id="IE6"><mml:math id="IM6" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> begins at <italic toggle="yes">b<sub>i</sub></italic> and ends at <inline-formula id="IE7"><mml:math id="IM7" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>&lt;</mml:mo><mml:mi>k</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, <italic toggle="yes">e<sub>k</sub></italic> = <italic toggle="yes">n</italic>, and all <inline-formula id="IE8"><mml:math id="IM8" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> are present in <italic toggle="yes">U</italic>. Such a series is called a <italic toggle="yes">decomposition D</italic> of <italic toggle="yes">S</italic> by <italic toggle="yes">U</italic>. There could be more than one decomposition of <italic toggle="yes">S</italic> by <italic toggle="yes">U</italic>. For example, when <italic toggle="yes">S</italic> = <monospace>ACCGACCGACCG</monospace> and <italic toggle="yes">U</italic> = {<monospace>ACCG, AC, CG, CGAC</monospace>}, consider the following decompositions of <italic toggle="yes">S</italic> by <italic toggle="yes">U</italic>:
</p>
      <disp-formula id="E1">
        <mml:math id="M1" display="block" overflow="scroll">
          <mml:msub>
            <mml:mrow>
              <mml:mi>D</mml:mi>
            </mml:mrow>
            <mml:mn>1</mml:mn>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi mathvariant="monospace">ACCG</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">ACCG</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">ACCG</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mo> </mml:mo>
          <mml:msub>
            <mml:mrow>
              <mml:mi mathvariant="italic">D</mml:mi>
            </mml:mrow>
            <mml:mn>2</mml:mn>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi mathvariant="monospace">AC</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">CG</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">AC</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">CG</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">AC</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">CG</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mo> </mml:mo>
          <mml:msub>
            <mml:mrow>
              <mml:mi mathvariant="italic">D</mml:mi>
            </mml:mrow>
            <mml:mn>3</mml:mn>
          </mml:msub>
          <mml:mo>=</mml:mo>
          <mml:mi mathvariant="monospace">AC</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">CGAC</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">CGAC</mml:mi>
          <mml:mo> </mml:mo>
          <mml:mi mathvariant="monospace">CG</mml:mi>
        </mml:math>
      </disp-formula>
      <p>To measure the goodness of decomposition <italic toggle="yes">D</italic> of <italic toggle="yes">S</italic> by <italic toggle="yes">U</italic>, assuming maximum parsimony that prefers fewer events of replicate slippage and/or non-homologous recombination, we design the penalty of <italic toggle="yes">D</italic> to be smaller when <italic toggle="yes">D</italic> consists of fewer copies of fewer and shorter generating units. For this purpose, we associate each unit <inline-formula id="IE9"><mml:math id="IM9" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:math></inline-formula> with the <italic toggle="yes">penalty</italic>, <inline-formula id="IE10"><mml:math id="IM10" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, where <italic toggle="yes">o</italic>(<italic toggle="yes">u</italic>) is the number of occurrences of <italic toggle="yes">u</italic> in <italic toggle="yes">D</italic> (<xref rid="btad185-B13" ref-type="bibr">Dvorkina et al. 2021</xref>), and set the penalty of <italic toggle="yes">D</italic> to the sum of penalties, <inline-formula id="IE11"><mml:math id="IM11" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>. In the running example, the penalty of <italic toggle="yes">D</italic><sub>1</sub> is 15=(4 + 3)+(2 + 0)+(2 + 0)+(4 + 0) because <monospace>ACCG</monospace> appears three times in tandem, while no other unit of <italic toggle="yes">U</italic> appears. Similarly, the penalties of <italic toggle="yes">D</italic><sub>2</sub> and <italic toggle="yes">D</italic><sub>3</sub> are 18 and 16, showing that <italic toggle="yes">D</italic><sub>1</sub> has the minimum penalty. For a given decomposition, <italic toggle="yes">U</italic> can be made smaller by eliminating unnecessary elements from <italic toggle="yes">U</italic> that do not appear in the decomposition: for example, by setting <italic toggle="yes">U</italic> = {<monospace>ACCG</monospace>} for <italic toggle="yes">D</italic><sub>1</sub>, the penalty of <italic toggle="yes">D</italic><sub>1</sub> becomes 7(=4 + 3).</p>
      <p>In general, a variety of unit sets can be candidates. Extreme examples are the set of all single letters and the singleton set of the entire string <italic toggle="yes">S</italic>. The penalty of the former set is <inline-formula id="IE12"><mml:math id="IM12" display="inline" overflow="scroll"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula> when the number of letters is <italic toggle="yes">k</italic>, the penalty of the latter is <inline-formula id="IE13"><mml:math id="IM13" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>, and both penalties are large. Extremely long or short units can generally be avoided by selecting a pair of <italic toggle="yes">U</italic> and <italic toggle="yes">D</italic> for <italic toggle="yes">S</italic> that minimizes the penalty <inline-formula id="IE14"><mml:math id="IM14" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>In practice, we had to generalize the penalty function to accommodate sequencing errors. Sequencing errors often generate infrequent units in a TR. Such rarely occurring outlier units can be placed in <italic toggle="yes">U</italic>, but may unnecessarily enlarge the unit set <italic toggle="yes">U</italic> with rare units. Instead, we took the approach of excluding these rare units. To this end, we measure the degree that <italic toggle="yes">most</italic> substrings are in <italic toggle="yes">U</italic>, and we define the <italic toggle="yes">coverage</italic> of <italic toggle="yes">D</italic> by <italic toggle="yes">U</italic> as the total length of substrings of <italic toggle="yes">D</italic> that are also present in <italic toggle="yes">U</italic>; i.e. <inline-formula id="IE15"><mml:math id="IM15" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>.</mml:mo></mml:mrow></mml:math></inline-formula> Thus, it is ideal to find <italic toggle="yes">U</italic> that minimizes the penalty of <italic toggle="yes">D</italic> by <italic toggle="yes">U</italic>, and maximizes the coverage of <italic toggle="yes">D</italic> by <italic toggle="yes">U</italic>; however, it may not always be possible to optimize both of these criteria simultaneously. Of note, as the latter maximization is equivalent to the minimization of <inline-formula id="IE16"><mml:math id="IM16" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∉</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo> </mml:mo><mml:mo> </mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>=</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>−</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we instead attempt to minimize:
in order to output nearly optimal values of the penalty and coverage of <italic toggle="yes">D</italic> by <italic toggle="yes">U</italic>. Therefore, we generalize the penalty of <italic toggle="yes">D</italic> by <italic toggle="yes">U</italic> to the above formula, and call it the <italic toggle="yes">extended</italic> penalty.</p>
      <disp-formula id="E2">
        <mml:math id="M2" display="block" overflow="scroll">
          <mml:mrow>
            <mml:munder>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>u</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:mi>U</mml:mi>
              </mml:mrow>
            </mml:munder>
            <mml:mrow>
              <mml:mo stretchy="false">(</mml:mo>
              <mml:mo>|</mml:mo>
              <mml:mi>u</mml:mi>
              <mml:mo>|</mml:mo>
              <mml:mo>+</mml:mo>
              <mml:mi>o</mml:mi>
              <mml:mo stretchy="false">(</mml:mo>
            </mml:mrow>
            <mml:mi>u</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>+</mml:mo>
            <mml:munder>
              <mml:mo>∑</mml:mo>
              <mml:mrow>
                <mml:mi>s</mml:mi>
                <mml:mo>∈</mml:mo>
                <mml:mi>D</mml:mi>
                <mml:mo>,</mml:mo>
                <mml:mi>s</mml:mi>
                <mml:mo>∉</mml:mo>
                <mml:mi>U</mml:mi>
              </mml:mrow>
            </mml:munder>
            <mml:mo>|</mml:mo>
            <mml:mi>s</mml:mi>
            <mml:mo>|</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Whether it is intractable to compute a pair of <italic toggle="yes">U</italic> and <italic toggle="yes">D</italic> that minimizes the extended penalty is an open question. We have considered this problem, but with partial results, which will be discussed later. Because of this situation, we implemented a greedy algorithm that initially assigns the empty set to <italic toggle="yes">U</italic> and lets decomposition <italic toggle="yes">D</italic> undivided. It then repeats the process of selecting and adding to <italic toggle="yes">U</italic> the best unit that minimizes the extended penalty defined above until no more units can be selected to minimize the extended penalty. Using the running example, we illustrate how the greedy algorithm works. For input <italic toggle="yes">S</italic>, set <italic toggle="yes">U</italic> to the empty set:
</p>
      <disp-formula id="E3">
        <mml:math id="M3" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>U</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mo>{</mml:mo>
            <mml:mo>}</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:mi>S</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="monospace">ACCGACCGACCG</mml:mi>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>We can select more than one unit as the first candidate (e.g. <monospace>ACCG</monospace>, <monospace>AC</monospace>, <monospace>CG</monospace>, and <monospace>CGAC</monospace>). If we select and add <monospace>ACCG</monospace> to <italic toggle="yes">U</italic>, we have decomposition <italic toggle="yes">D</italic><sub>1</sub>:
</p>
      <disp-formula id="E4">
        <mml:math id="M4" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>U</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mo>{</mml:mo>
            <mml:mi mathvariant="monospace">ACCG</mml:mi>
            <mml:mo>}</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>D</mml:mi>
              </mml:mrow>
              <mml:mn>1</mml:mn>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="monospace">ACCG</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">ACCG</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">ACCG</mml:mi>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>Because <monospace>ACCG</monospace> ∈ <italic toggle="yes">U</italic> is of length 4 and has 3 occurrences, the extended penalty becomes 7 = 4 + 3. Instead, if we select <monospace>AC</monospace>,
</p>
      <disp-formula id="E5">
        <mml:math id="M5" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>U</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mo>{</mml:mo>
            <mml:mi mathvariant="monospace">AC</mml:mi>
            <mml:mo>}</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>D</mml:mi>
              </mml:mrow>
              <mml:mn>2</mml:mn>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="monospace">AC</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">CG</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">AC</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">CG</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">AC</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">CG</mml:mi>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p><monospace>AC</monospace> ∈ <italic toggle="yes">U</italic> is of length 2 and has 3 occurrences, but 3 instances of <monospace>CG</monospace> are absent in <italic toggle="yes">U</italic>, and the extended penalty is <inline-formula id="IE17"><mml:math id="IM17" display="inline" overflow="scroll"><mml:mrow><mml:mn>11</mml:mn><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>×</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:math></inline-formula>. Selecting <monospace>CG</monospace> instead also outputs the penalty of 11. Selection of <monospace>CGAC</monospace> yields:
</p>
      <disp-formula id="E6">
        <mml:math id="M6" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>U</mml:mi>
            <mml:mo>=</mml:mo>
            <mml:mo>{</mml:mo>
            <mml:mi mathvariant="monospace">CGAC</mml:mi>
            <mml:mo>}</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:mo> </mml:mo>
            <mml:msub>
              <mml:mrow>
                <mml:mi>D</mml:mi>
              </mml:mrow>
              <mml:mn>3</mml:mn>
            </mml:msub>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="monospace">AC</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">CGAC</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">CGAC</mml:mi>
            <mml:mo> </mml:mo>
            <mml:mi mathvariant="monospace">CG</mml:mi>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The penalty is <inline-formula id="IE18"><mml:math id="IM18" display="inline" overflow="scroll"><mml:mrow><mml:mn>10</mml:mn><mml:mo>=</mml:mo><mml:mn>4</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> as <italic toggle="yes">U</italic> excludes <monospace>AC</monospace> and <monospace>CG</monospace>. Thus, <monospace>ACCG</monospace> minimizes the penalty and covers <italic toggle="yes">D</italic><sub>1</sub> entirely. No more units are selected.</p>
      <p>HORDecomposer has been proposed to detect higher-order repeats (HORs), a special case of centromere mosaic TRs, from a series of alpha satellite monomers of length ∼171 in human centromeres (<xref rid="btad185-B13" ref-type="bibr">Dvorkina et al. 2021</xref>). Our algorithm differs from HORDecomposer in that it used the extended penalty function defined above, and it focuses on accelerating the detection of candidate shorter units of various lengths ≤100 b using suffix arrays and Burrow–Wheeler transform. We will show that this greedy algorithm can estimate benchmark mosaic TRs with high accuracy in the section of experimental results.</p>
    </sec>
    <sec>
      <title>2.3 Mosaic tandem repeats</title>
      <p>Here, we formally define “mosaic tandem repeats.” A <italic toggle="yes">tandem repeat</italic> of string <italic toggle="yes">u</italic> is defined as having the form <inline-formula id="IE19"><mml:math id="IM19" display="inline" overflow="scroll"><mml:mrow><mml:mi>s</mml:mi><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msup><mml:mi>p</mml:mi></mml:mrow></mml:math></inline-formula> such that <italic toggle="yes">s</italic> and <italic toggle="yes">p</italic> are a suffix and a prefix of <italic toggle="yes">u</italic>, respectively, and <inline-formula id="IE20"><mml:math id="IM20" display="inline" overflow="scroll"><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> is a series of copies of <italic toggle="yes">u</italic>. To eliminate ambiguity, assume that <italic toggle="yes">u</italic> is not a TR of any shorter substring, and a TR of <italic toggle="yes">u</italic> is maximal such that none of its superstrings are TRs of <italic toggle="yes">u</italic>. Decomposition <italic toggle="yes">D</italic> is <italic toggle="yes">mosaic tandem repeats</italic> of <italic toggle="yes">U</italic> if and only if the coverage of <italic toggle="yes">D</italic> by TRs of units in <italic toggle="yes">U</italic>,</p>
      <p><inline-formula id="IE21"><mml:math id="IM21" display="inline" overflow="scroll"><mml:mrow><mml:mo>∑</mml:mo><mml:mo>{</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> is a substring of a TR of unit <inline-formula id="IE22"><mml:math id="IM22" display="inline" overflow="scroll"><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:math></inline-formula>}exceeds a given threshold (e.g. <inline-formula id="IE23"><mml:math id="IM23" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mn>0.8</mml:mn></mml:mrow></mml:math></inline-formula>). For example, when <italic toggle="yes">U</italic> = {<monospace>AC</monospace>, <monospace>CGA</monospace>}, for example,</p>
      <list list-type="bullet">
        <list-item>
          <p><monospace>AC AC C CGA CGA</monospace> is mosaic TRs of <italic toggle="yes">U</italic>, but</p>
        </list-item>
        <list-item>
          <p><monospace>AC CGA AC T CGA</monospace> is not if the threshold is set to <inline-formula id="IE24"><mml:math id="IM24" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>×</mml:mo><mml:mn>0.8</mml:mn></mml:mrow></mml:math></inline-formula>.</p>
        </list-item>
      </list>
      <p>We can select more than one unit from a TR of a single unit. For example, in (<monospace>AAGA</monospace>)<sup><italic toggle="yes">k</italic></sup>, any rotation of <monospace>AAGA</monospace> can be a unit because
and <monospace>AAG</monospace> and <monospace>A</monospace> are a suffix and a prefix of <monospace>AAAG</monospace>, respectively. To resolve ambiguity and select a representative unit, we define that a substring is <italic toggle="yes">self-overlapping</italic> if a proper suffix matches a prefix; otherwise, it is <italic toggle="yes">non-self-overlapping</italic>. There exists a non-self-overlapping unit because any unit is not a TR. In the running example, <monospace>AAAG</monospace> and <monospace>GAAA</monospace> are non-self-overlapping units. In the next subsection, we present the design of an <inline-formula id="IE25"><mml:math id="IM25" display="inline" overflow="scroll"><mml:mrow><mml:mo>Θ</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time algorithm for enumerating all non-self-overlapping substrings in string <italic toggle="yes">S</italic> of size <italic toggle="yes">n</italic>.</p>
      <disp-formula id="E7">
        <mml:math id="M7" display="block" overflow="scroll">
          <mml:mrow>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi mathvariant="monospace">AAGA</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mi>k</mml:mi>
            </mml:msup>
            <mml:mo>=</mml:mo>
            <mml:mi mathvariant="monospace">AAG</mml:mi>
            <mml:msup>
              <mml:mrow>
                <mml:mrow>
                  <mml:mo stretchy="false">(</mml:mo>
                  <mml:mi mathvariant="monospace">AAAG</mml:mi>
                  <mml:mo stretchy="false">)</mml:mo>
                </mml:mrow>
              </mml:mrow>
              <mml:mrow>
                <mml:mi>k</mml:mi>
                <mml:mo>−</mml:mo>
                <mml:mn>1</mml:mn>
              </mml:mrow>
            </mml:msup>
            <mml:mi mathvariant="monospace">A</mml:mi>
            <mml:mo>,</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
    </sec>
    <sec>
      <title>2.4 Algorithm for enumerating repetitive non-self-overlapping substrings</title>
      <p>In this section, we introduce an algorithm for efficiently enumerating repetitive non-self-overlapping substrings of given string <italic toggle="yes">S</italic> of length <italic toggle="yes">n</italic>. We determine for each <inline-formula id="IE26"><mml:math id="IM26" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> whether <inline-formula id="IE27"><mml:math id="IM27" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is repetitive and whether <inline-formula id="IE28"><mml:math id="IM28" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is non-self-overlapping respectively, and add it to the list if both are satisfied.</p>
      <p>First, we describe how to determine if <inline-formula id="IE29"><mml:math id="IM29" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is repetitive. For this purpose, we define an array <italic toggle="yes">LEN</italic> as follows:
</p>
      <disp-formula id="E8">
        <mml:math id="M8" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi mathvariant="italic">LEN</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>max</mml:mi>
            <mml:mo>{</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo>|</mml:mo>
            <mml:mi>S</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo> </mml:mo>
            <mml:mtext>appears</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mtext>twice</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mtext>or</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mtext>more</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mtext>in</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mi>S</mml:mi>
            <mml:mo>}</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>If and only if <inline-formula id="IE30"><mml:math id="IM30" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is repetitive. If we denote the length of the longest common prefix (LCP) of <inline-formula id="IE31"><mml:math id="IM31" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE32"><mml:math id="IM32" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> as <inline-formula id="IE33"><mml:math id="IM33" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">lcp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, we have <inline-formula id="IE34"><mml:math id="IM34" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mi>max</mml:mi><mml:mo>{</mml:mo><mml:mi mathvariant="italic">lcp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo><mml:mi>j</mml:mi><mml:mo>≠</mml:mo><mml:mi>i</mml:mi><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula>. The closer <italic toggle="yes">i</italic> and <italic toggle="yes">j</italic> are on the suffix array of <italic toggle="yes">S</italic>, the larger <inline-formula id="IE35"><mml:math id="IM35" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">lcp</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> becomes. Therefore, for the two (or one) suffixes adjacent to <inline-formula id="IE36"><mml:math id="IM36" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> on the suffix array, we calculate the length of the longest common suffix with <inline-formula id="IE37"><mml:math id="IM37" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>, and the maximum of these is the value of <inline-formula id="IE38"><mml:math id="IM38" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>. Given a suffix array and LCP array of <italic toggle="yes">S</italic>, this can be computed in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic>) (see <xref rid="btad185-BOX1" ref-type="boxed-text">Algorithm 1</xref>). We can obtain the suffix array using SA-IS (<xref rid="btad185-B26" ref-type="bibr">Nong et al. 2009</xref>), and the LCP array using Kasai’s algorithm (<xref rid="btad185-B19" ref-type="bibr">Kasai et al. 2001</xref>), both in <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic>).<boxed-text id="btad185-BOX1" position="float"><label>Algorithm 1</label><caption><p>Calculate maximum lengths of repetitive substring starting with <italic toggle="yes">i</italic> for each <italic toggle="yes">i</italic></p></caption><p><bold>Input:</bold> String <italic toggle="yes">S</italic></p><p><bold>Output:</bold> Array of maximum lengths of repetitive substrings <italic toggle="yes">LEN</italic></p><p>1: <bold>function</bold> CALC_LEN(<italic toggle="yes">S</italic>)</p><p>2: <inline-formula id="IE39"><mml:math id="IM39" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula></p><p>3: Prepare an array <italic toggle="yes">LEN</italic> of length <italic toggle="yes">n</italic> and initialize all elements to 0.</p><p>4: <inline-formula id="IE40"><mml:math id="IM40" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> suffix array of <italic toggle="yes">S</italic></p><p>5: <inline-formula id="IE41"><mml:math id="IM41" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LCP</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> longest common prefix array of <italic toggle="yes">S</italic></p><p>6: <inline-formula id="IE42"><mml:math id="IM42" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></inline-formula></p><p>7: <bold>for</bold><inline-formula id="IE43"><mml:math id="IM43" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>…</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>: <inline-formula id="IE44"><mml:math id="IM44" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>S</mml:mi><mml:mi>A</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>←</mml:mo><mml:mi>max</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>L</mml:mi><mml:mi>C</mml:mi><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula></p><p>8: <bold>return</bold> <italic toggle="yes">LEN</italic></p></boxed-text>Second, we describe how to determine if <inline-formula id="IE45"><mml:math id="IM45" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is non-self-overlapping. For each <italic toggle="yes">i</italic>, let <italic toggle="yes">OL<sub>i</sub></italic> be the array of length <italic toggle="yes">n</italic> − <italic toggle="yes">i</italic>:</p>
      <disp-formula id="E9">
        <mml:math id="M9" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi>O</mml:mi>
            <mml:msub>
              <mml:mrow>
                <mml:mi>L</mml:mi>
              </mml:mrow>
              <mml:mi>i</mml:mi>
            </mml:msub>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo stretchy="false">]</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>max</mml:mi>
            <mml:mo>{</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo>|</mml:mo>
            <mml:mi>S</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>=</mml:mo>
            <mml:mi>S</mml:mi>
            <mml:mo stretchy="false">[</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo>−</mml:mo>
            <mml:mi>l</mml:mi>
            <mml:mo>,</mml:mo>
            <mml:mi>i</mml:mi>
            <mml:mo>+</mml:mo>
            <mml:mi>k</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mo>}</mml:mo>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>If and only if <inline-formula id="IE46"><mml:math id="IM46" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo> </mml:mo><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is non-self-overlapping. Construction of <italic toggle="yes">OL<sub>i</sub></italic> can be performed in <inline-formula id="IE47"><mml:math id="IM47" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> time, using the Morris-Pratt algorithm (<xref rid="btad185-B23" ref-type="bibr">Morris and Pratt 1970</xref>). Combining the above two algorithms, we can enumerate repetitive non-self-overlapping substrings (see <xref rid="btad185-BOX2" ref-type="boxed-text">Algorithm 2</xref>). In <xref rid="btad185-BOX2" ref-type="boxed-text">Algorithm 2</xref>, Line 5 calling the <inline-formula id="IE48"><mml:math id="IM48" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> process for each <italic toggle="yes">i</italic> is the bottleneck, and the overall complexity is <inline-formula id="IE49"><mml:math id="IM49" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>.</p>
      <p>
        <boxed-text id="btad185-BOX2" position="float">
          <label>Algorithm 2</label>
          <caption>
            <p>Enumaration of repetitive non-self-overlapping substrings</p>
          </caption>
          <p><bold>Input:</bold> String <italic toggle="yes">S</italic></p>
          <p><bold>Output:</bold> List of repetitive non-self-overlapping substrings <italic toggle="yes">L</italic></p>
          <p>1: <inline-formula id="IE50"><mml:math id="IM50" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi><mml:mo>←</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>2: <inline-formula id="IE51"><mml:math id="IM51" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>←</mml:mo><mml:mo>∅</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>3: <inline-formula id="IE52"><mml:math id="IM52" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> CALC_LEN(<italic toggle="yes">S</italic>)</p>
          <p>4: <bold>for</bold><inline-formula id="IE53"><mml:math id="IM53" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>:</p>
          <p>5:  <inline-formula id="IE54"><mml:math id="IM54" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>←</mml:mo></mml:mrow></mml:math></inline-formula> MORRIS_PRATT(<inline-formula id="IE55"><mml:math id="IM55" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>)</p>
          <p>6:  <bold>for</bold><inline-formula id="IE56"><mml:math id="IM56" display="inline" overflow="scroll"><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>…</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>:</p>
          <p>7:  <bold>if</bold><inline-formula id="IE57"><mml:math id="IM57" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="italic">LEN</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>≥</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula id="IE58"><mml:math id="IM58" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">[</mml:mo><mml:mi>j</mml:mi><mml:mo>−</mml:mo><mml:mi>i</mml:mi><mml:mo stretchy="false">]</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>:</p>
          <p>8:      <inline-formula id="IE59"><mml:math id="IM59" display="inline" overflow="scroll"><mml:mrow><mml:mi>L</mml:mi><mml:mo>←</mml:mo><mml:mi>L</mml:mi><mml:mo>∪</mml:mo><mml:mo>{</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:math></inline-formula></p>
          <p>9: <bold>return</bold> <italic toggle="yes">L</italic></p>
        </boxed-text>
      </p>
    </sec>
    <sec>
      <title>2.5 Algorithm for decomposing an input string</title>
      <p>To decompose an input string <italic toggle="yes">S</italic> into mosaic TRs efficiently, we are now in a position to combine the algorithms presented in this section:</p>
      <list list-type="order">
        <list-item>
          <p>With <xref rid="btad185-BOX2" ref-type="boxed-text">Algorithm 2</xref>, calculate the set of repetitive non-self-overlapping substrings in <italic toggle="yes">S</italic> and assign the set to <italic toggle="yes">V</italic>.</p>
        </list-item>
        <list-item>
          <p>Set <italic toggle="yes">U</italic> to the empty set. Repeat the process that selects the best unit from <italic toggle="yes">V</italic> with the minimum extended penalty and adds the unit into <italic toggle="yes">U</italic> until no more units can be selected to minimize the penalty.</p>
        </list-item>
        <list-item>
          <p>Compute an optimal concatenation of elements in <italic toggle="yes">U</italic> that partially matches the input <italic toggle="yes">S</italic>. For this purpose, an <inline-formula id="IE60"><mml:math id="IM60" display="inline" overflow="scroll"><mml:mrow><mml:mi>O</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>S</mml:mi><mml:mo>|</mml:mo><mml:mo>·</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula>-time algorithm for solving the approximate regular expression matching problem (<xref rid="btad185-B25" ref-type="bibr">Myers and Miller 1989</xref>) or the string decomposer (<xref rid="btad185-B12" ref-type="bibr">Dvorkina et al. 2020</xref>), a wraparound dynamic programming algorithm, are available.</p>
        </list-item>
      </list>
    </sec>
  </sec>
  <sec>
    <title>3 Results</title>
    <sec>
      <title>3.1 Accuracy of decomposition</title>
      <p>To demonstrate that the program, named uTR, can decompose various mosaic TRs, we created a test data set consisting of typical mosaic TRs with widely different units:</p>
      <list list-type="bullet">
        <list-item>
          <p>(<monospace>AC</monospace>) <italic toggle="yes">i</italic> (<monospace>AG</monospace>) <italic toggle="yes">j</italic>(<monospace>ACC</monospace>) <italic toggle="yes">i</italic> (<monospace>GTT</monospace>) <italic toggle="yes">j</italic>(<monospace>AAG</monospace>) <italic toggle="yes">i</italic> (<monospace>AG</monospace>) <italic toggle="yes">j</italic>(<monospace>AAG</monospace>) <italic toggle="yes">i</italic>(<monospace>AGG</monospace>) <italic toggle="yes">j</italic></p>
        </list-item>
        <list-item>
          <p>(<monospace>AAAG</monospace>) <italic toggle="yes">i</italic>(<monospace>AG</monospace>) <italic toggle="yes">j</italic>(<monospace>AAAG</monospace>) <italic toggle="yes">i</italic> (<monospace>AG</monospace>) <italic toggle="yes">j</italic> (<monospace>AAAG</monospace>) <italic toggle="yes">k</italic></p>
        </list-item>
        <list-item>
          <p>(<monospace>AAAG</monospace>) <italic toggle="yes">i</italic>(<monospace>AG</monospace>) <italic toggle="yes">j</italic>(<monospace>AGGG</monospace>) <italic toggle="yes">k</italic>(<monospace>AG</monospace>) <italic toggle="yes">l</italic>(<monospace>AAAG</monospace>) <italic toggle="yes">m</italic></p>
        </list-item>
        <list-item>
          <p>(<monospace>AAAAAG</monospace>) <italic toggle="yes">i</italic>(<monospace>AAAGAGAGGGAAAAG</monospace>) <italic toggle="yes">j</italic>(<monospace>AGGGG</monospace>) <italic toggle="yes">k</italic></p>
        </list-item>
      </list>
      <p>The variable (e.g. <inline-formula id="IE61"><mml:math id="IM61" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>) next to each unit in parentheses represents the number of unit occurrences. Mosaic TRs are harder to decompose correctly when more distinct units are present, and different units are more similar. To understand the hardness of the decomposition, we generate a variety of datasets of different lengths for each mosaic TR pattern; i.e. variables in each pattern were set to random values ranging from 10 to 200.</p>
      <p>To see how sequencing errors affect the prediction of the original mosaic TR patterns, letters of strings in each dataset were modified at random by sequencing errors (substitutions, insertions, and deletions) at the rate of 0%, 1%, 3%, 5%, 10%, and 15%. When a mosaic TR has three units <inline-formula id="IE62"><mml:math id="IM62" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>V</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, for example, all of the three units need to be predicted nearly accurately. A series of units <inline-formula id="IE63"><mml:math id="IM63" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>U</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is accurate if the value of <italic toggle="yes">i</italic> differs by at most <inline-formula id="IE64"><mml:math id="IM64" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> of the true value, where we call <inline-formula id="IE65"><mml:math id="IM65" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> an <italic toggle="yes">allowance</italic> and set <inline-formula id="IE66"><mml:math id="IM66" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> to 0%, 1%, 2%,…, for example. Accuracy increases by setting allowance <inline-formula id="IE67"><mml:math id="IM67" display="inline" overflow="scroll"><mml:mrow><mml:mi>X</mml:mi><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula> to a larger value, and this mitigation is reasonable and necessary when dealing with two homologous units (i.e. <monospace>AAG</monospace> and <monospace>AG</monospace>) because it becomes ambiguous to correctly determine the boundary between two similar units in the presence of sequencing errors.</p>
      <p>We compared the prediction accuracy of uTR with TRF (Version 4.09) and RepeatMasker (version open-4.0.7). We used RepeatMasker with default parameter settings (<monospace>-e hmmer -noint -pa 4 -div 0 -xsmall</monospace>) and TRF with default parameter settings except for lowering the minimum alignment score from 50 to 10 (i.e. <monospace>2 7 7 80 10 10 1000 -h -ngs</monospace>) in order to detect small TRs with <inline-formula id="IE68"><mml:math id="IM68" display="inline" overflow="scroll"><mml:mrow><mml:mo>≥</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> units in our benchmark datasets. TRF sometimes returns a single most likely mosaic TR, but it often outputs a number of TRs some of which overlap each other. To find a mosaic TR, a series of non-overlapping TRs has to be selected, which is actually solved by RepeatMasker. Therefore, RepeatMasker seems to be better suited to detect mosaic TRs than TRFs, and this tendency will be confirmed empirically later.</p>
      <p>For each of eight mosaic TR patterns, we considered six sequencing error rates, and created a total of 48 (<inline-formula id="IE69"><mml:math id="IM69" display="inline" overflow="scroll"><mml:mrow><mml:mo>=</mml:mo><mml:mn>8</mml:mn><mml:mo>×</mml:mo><mml:mn>6</mml:mn></mml:mrow></mml:math></inline-formula>) datasets with 1000 strings. Appling uTR, RepeatMasker, and TRF to the datasets, we observed trends in prediction accuracy (<xref rid="btad185-F1" ref-type="fig">Fig. 1A and 1B</xref>) when using different allowance values, TR units, and sequencing error rates. <xref rid="btad185-F1" ref-type="fig">Fig. 1A and 1B</xref> respectively show accuracy when the allowance parameter is set to 0% and 2%<xref rid="btad185-FN1" ref-type="fn"><sup>1</sup></xref>. The accuracy of 2% allowance (<xref rid="btad185-F1" ref-type="fig">Fig. 1B</xref>) is remarkably better than that of 0% allowance (<xref rid="btad185-F1" ref-type="fig">Fig. 1A</xref>). In most cases, uTR outperformed RepeatMasker and TRF in terms of prediction accuracy, and this is especially true when mosaic TRs have three or more series of units. Prediction accuracy of uTR, RepeatMasker, and TRF tends to decrease as the sequencing error rate increases because sequencing errors obscure the original unit patterns and make prediction hard.</p>
      <fig position="float" id="btad185-F1">
        <label>Figure 1.</label>
        <caption>
          <p>(A) Graphs show accuracy of eight mosaic TR patterns shown in the titles and of six sequencing error rates (0%, 1%, 3%, 5%, 10%, and 15%) in the <italic toggle="yes">x</italic>-axis when the allowance is set to 0%. The <italic toggle="yes">y</italic>-axis shows the prediction accuracy of uTR (blue), RepeatMasker (orange) and TRF (gray) to estimate the original patterns of 1000 strings. (B) Accuracy when the allowance is set to 2%. (C) The <italic toggle="yes">y</italic>-axis shows the total computation time (in seconds) when 48 datasets are processed by uTR, RepeatMasker, and TRF. The <italic toggle="yes">x</italic>-axis and graph legend are the same as Figure A. (D) The average length of 1000 mosaic TRs in each dataset. The test code is available at <ext-link xlink:href="https://github.com/morisUtokyo/uTR/tree/main/test_public" ext-link-type="uri">https://github.com/morisUtokyo/uTR/tree/main/test_public</ext-link>.</p>
        </caption>
        <graphic xlink:href="btad185f1" position="float"/>
      </fig>
      <p>While prediction accuracy is essential in evaluating the usefulness of the tools, their computational performance was also measured using the same 48 datasets with 1000 mosaic TRs (<xref rid="btad185-F1" ref-type="fig">Fig. 1C</xref>). Computational performance was evaluated using the Apple M1 Max processor (10 high-performance cores, clocked at 3.228 GHz) and 64 GB of main memory. On most of the 48 datasets, uTR was faster than RepeatMasker and TRF. Since the time required to verify that a mosaic TR pattern meets the allowance condition is a small constant, allowance differences do not affect computational performance. Higher error rates resulted in longer computation times presumably because more errors produced more candidate units with sequencing errors. <xref rid="btad185-F1" ref-type="fig">Figure 1D</xref> shows the average length of each of the eight mosaic TRs, showing that processing longer mosaic TRs also needs longer computation time. Overall, uTR is more accurate and faster than RepeatMasker and TRF.</p>
      <p>We now turn our attention to the ambiguity of the decomposition; i.e. a single string can be decomposed into several optimal mosaic TR patterns that minimize the (revised) penalty. For example,
has two optimal decompositions:
</p>
      <disp-formula id="E10">
        <mml:math id="M10" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mi mathvariant="monospace">AGAGAGGGAGGGAGAGAGGGAGGG</mml:mi>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <disp-formula id="E11">
        <mml:math id="M11" display="block" overflow="scroll">
          <mml:mrow>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi mathvariant="monospace">AG</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mn>2</mml:mn>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi mathvariant="monospace">AGGG</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mn>2</mml:mn>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi mathvariant="monospace">AG</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mn>2</mml:mn>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi mathvariant="monospace">AGGG</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mn>2</mml:mn>
            <mml:mo> </mml:mo>
            <mml:mtext>and</mml:mtext>
            <mml:mo> </mml:mo>
            <mml:mo stretchy="false">(</mml:mo>
            <mml:mi mathvariant="monospace">AGAGAGGGAGGG</mml:mi>
            <mml:mo stretchy="false">)</mml:mo>
            <mml:mn>2</mml:mn>
          </mml:mrow>
        </mml:math>
      </disp-formula>
      <p>The above two have the same penalty of 14 (= 2 + 4 + 4 + 4 = 12 + 2). The source of the ambiguity is the duplication of subpattern (<monospace>AG</monospace>)2(<monospace>AGGG</monospace>)2. Although it is correct to select one of the two as the best one, this is a corner case because (<monospace>AG</monospace>) <italic toggle="yes">i</italic>(<monospace>AGGG</monospace>) <italic toggle="yes">j</italic>(<monospace>AG</monospace>) <italic toggle="yes">k</italic>(<monospace>AGGG</monospace>) <italic toggle="yes">m</italic> is the unique optimal answer when (<monospace>AG</monospace>) occurs two or more times (<inline-formula id="IE70"><mml:math id="IM70" display="inline" overflow="scroll"><mml:mrow><mml:mn>2</mml:mn><mml:mo>≤</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:math></inline-formula>) while (<monospace>AGGG</monospace>) occurs three or more times (<inline-formula id="IE71"><mml:math id="IM71" display="inline" overflow="scroll"><mml:mrow><mml:mn>3</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>). When we generated the benchmark string datasets, we avoided such duplication of subpatterns as much as possible and eliminated the ambiguity of obtaining multiple correct decompositions. Put another way, each dataset was designed to have a single optimal decomposition and to be easily checked for consistency with one hidden pattern.</p>
    </sec>
    <sec>
      <title>3.2 Detecting real mosaic tandem repeats with uTR</title>
      <p>To demonstrate the practical application of uTR, we show that uTR could detect the following mosaic TRs in publicly available sequence data. The first two TRs are collected from patients with benign adult familial myoclonic epilepsy (BAFME), while the latter three are obtained from the human reference genome hg38.</p>
      <list list-type="bullet">
        <list-item>
          <p>(<monospace>ATTTT</monospace>)221 (<monospace>ATTTC</monospace>)221 (<monospace>ATTTT</monospace>)82 is in the 4th intron of <italic toggle="yes">SAND12</italic> and is found in Patient II-1 of BAFME in family F6115 (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S6</xref> in <xref rid="btad185-B17" ref-type="bibr">Ishiura et al. 2018</xref>).</p>
        </list-item>
        <list-item>
          <p>(<monospace>ATTTT</monospace>)613 (<monospace>ATTTC</monospace>)320 (<monospace>ATTTT</monospace>)5 (<monospace>ATTTC</monospace>)130 is another type in the 4th intron of <italic toggle="yes">SAND12</italic> and is found in Patient II6 of BAFME in family F6906 (see <xref rid="sup1" ref-type="supplementary-material">Supplementary Fig. S6</xref> in <xref rid="btad185-B17" ref-type="bibr">Ishiura et al. 2018</xref>).</p>
        </list-item>
        <list-item>
          <p>(<monospace>AAAAG</monospace>)11 in an intron of <italic toggle="yes">RFC1</italic> is located at chr4:39 348 425-39 348 483 in the human reference genome hg38. (<monospace>AAGGG</monospace>) expansions associated with CANVAS have been reported at the same locus (<xref rid="btad185-B4" ref-type="bibr">Cortese et al. 2019</xref>), but the sequence data is not publicly available for privacy protection reasons. Thus, we used the (<monospace>AAAAG</monospace>) expansion in the reference.</p>
        </list-item>
        <list-item>
          <p>(<monospace>AAAG</monospace>)6 (<monospace>AG</monospace>)11 (<monospace>AAAG</monospace>)20 is in an intron of <italic toggle="yes">KAZN</italic> and is at chr1:14 883 297-14 883 426 in reference hg38.</p>
        </list-item>
        <list-item>
          <p>(<monospace>CTTTT</monospace>)12 (<monospace>CTTGT</monospace>)3 (<monospace>CTTTT</monospace>)2 is in an intron of <italic toggle="yes">ZNF37A</italic> and is at chr10:38 112 731-38 112 826 in reference hg38.</p>
        </list-item>
      </list>
      <p>uTR could identify all the mosaic TRs, while TRF detected the third one. A fasta file with the DNA sequences of the above mosaic TRs is available at <ext-link xlink:href="https://github.com/morisUtokyo/uTR" ext-link-type="uri">https://github.com/morisUtokyo/uTR</ext-link>.</p>
    </sec>
    <sec>
      <title>3.3 Merit of using non-self-overlapping units</title>
      <p>Here, we show that using non-self-duplicating units is quite effective in reducing the number of units to be considered. To quantify the benefits, let <italic toggle="yes">W<sub>all</sub></italic> be the set of all unique substrings in string <italic toggle="yes">S</italic> of length <italic toggle="yes">θ</italic> or less (e.g. <italic toggle="yes">θ </italic> = 20), and <italic toggle="yes">W<sub>nsop</sub></italic> be the set of all non-self-overlapping substrings in <italic toggle="yes">W<sub>all</sub></italic>. The ratio of the sizes of <italic toggle="yes">W<sub>nsop</sub></italic> and <italic toggle="yes">W<sub>all</sub></italic>, <inline-formula id="IE72"><mml:math id="IM72" display="inline" overflow="scroll"><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">nsop</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo><mml:mo>/</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">all</mml:mi></mml:mrow></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>, is called the <italic toggle="yes">compression ratio</italic> by non-self-overlapping. To measure the compression ratio, we examined the 48 datasets that were used to measure the prediction accuracy in <xref rid="btad185-F1" ref-type="fig">Fig. 1</xref>. <xref rid="btad185-F2" ref-type="fig">Figure 2</xref> presents the distribution of the compression ratios of the 48 files, and most compression ratios were 5% or less, highlighting a remarkable reduction in the number of units.</p>
      <fig position="float" id="btad185-F2">
        <label>Figure 2.</label>
        <caption>
          <p>Compression ratio distribution: the boxplot shows the first, second, and third quartiles.</p>
        </caption>
        <graphic xlink:href="btad185f2" position="float"/>
      </fig>
    </sec>
  </sec>
  <sec>
    <title>4 Discussion</title>
    <p>It is an open question to understand the computational complexity of calculating a pair of unit set <italic toggle="yes">U</italic> and decomposition <italic toggle="yes">D</italic> that minimizes <inline-formula id="IE73"><mml:math id="IM73" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>∈</mml:mo><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>s</mml:mi><mml:mo>∉</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mo>|</mml:mo><mml:mi>s</mml:mi><mml:mo>|</mml:mo></mml:mrow></mml:math></inline-formula>. We speculate on its intractability. This is because we studied a restricted case when <italic toggle="yes">U</italic> is fixed, asked whether there is a decomposition of <italic toggle="yes">S</italic> for which the penalty <inline-formula id="IE74"><mml:math id="IM74" display="inline" overflow="scroll"><mml:mrow><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>∈</mml:mo><mml:mi>U</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>+</mml:mo><mml:mi>o</mml:mi><mml:mo stretchy="false">(</mml:mo></mml:mrow><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> is <italic toggle="yes">T</italic> or less for a given constant <italic toggle="yes">T</italic>, which is called the unit coding problem, and we proved its NP-completeness (<xref rid="sup1" ref-type="supplementary-material">Supplementary Appendix</xref>).</p>
    <p>Our program uTR estimates a mosaic TR pattern for an input DNA string, but the pattern and the string may have a number of mismatches because of variants in units. Resolution of this problem is medically important because for example, some variants in minisatellite units have been reported to be associated with several brain diseases (<xref rid="btad185-B4" ref-type="bibr">Cortese et al. 2019</xref>; <xref rid="btad185-B5" ref-type="bibr">Course et al. 2020</xref>, <xref rid="btad185-B6" ref-type="bibr">2021</xref>; <xref rid="btad185-B8" ref-type="bibr">De Roeck et al. 2018</xref>; <xref rid="btad185-B28" ref-type="bibr">Song et al. 2018</xref>). To identify unit variants in a minisatellite that has the representative form <inline-formula id="IE75"><mml:math id="IM75" display="inline" overflow="scroll"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, one can compare the given string and the concatenation of <italic toggle="yes">n</italic> copies of <italic toggle="yes">u</italic> by using a dynamic programming alignment algorithm, and find an optimal concatenation of <italic toggle="yes">u’</italic>s variants (<italic toggle="yes">u<sub>i</sub></italic> for <inline-formula id="IE76"><mml:math id="IM76" display="inline" overflow="scroll"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>). This concept can be generalized to mosaic TRs, and a program for this purpose is available at: <ext-link xlink:href="https://github.com/morisUtokyo/vTR" ext-link-type="uri">https://github.com/morisUtokyo/vTR</ext-link>.</p>
  </sec>
  <sec>
    <title>5 Conclusion</title>
    <p>Expanded mosaic TRs have attracted a great deal of attention because they are relevant to a number of disorders (<xref rid="btad185-B9" ref-type="bibr">Depienne and Mandel 2021</xref>). Most mosaic TRs require a long read sequence to cover the entire sequence, but it is difficult to automatically characterize the sequence configurations of mosaic TRs, so they have been analyzed by manual inspection and remain largely unknown. To resolve this problem, we proposed how to measure the goodness of selecting units in mosaic TRs and developed an efficient algorithm for calculating a better unit set according to the measurement. After selecting units, it is tractable to compute an optimal concatenation of the units that partially matches the input string with the minimum Levenshtein distance in the presence of sequencing errors (<xref rid="btad185-B25" ref-type="bibr">Myers and Miller 1989</xref>). We demonstrated the high accuracy and computational efficiency of our program using synthetic benchmark data modeling typical mosaic TRs of human genomes.</p>
    <p>The next goal is to calculate the distribution of mosaic TRs by applying this program to long reads collected from individual genomes from a healthy population. It will then be important to apply the program to long reads from affected individuals and to compare the mosaic TRs to those of a healthy population to determine which repeating units are significantly expanded and cause disease. We expect the program to be used to assist in this type of discovery, which to date has been performed manually.</p>
  </sec>
  <sec sec-type="supplementary-material">
    <title>Supplementary Material</title>
    <supplementary-material id="sup1" position="float" content-type="local-data">
      <label>btad185_supplementary_data</label>
      <media xlink:href="btad185_supplementary_data.pdf">
        <caption>
          <p>Click here for additional data file.</p>
        </caption>
      </media>
    </supplementary-material>
  </sec>
</body>
<back>
  <ack id="ack1">
    <title>Acknowledgements</title>
    <p>We would like to thank Dr Gene Myers and Dr Kazuki Ichikawa for the stimulating discussion.</p>
  </ack>
  <fn-group>
    <title>Notes</title>
    <fn id="btad185-FN1">
      <label>1</label>
      <p>Using a larger allowance (e.g., 3%) produced a similar tendency.</p>
    </fn>
  </fn-group>
  <sec>
    <title>Supplementary data</title>
    <p><xref rid="sup1" ref-type="supplementary-material">Supplementary data</xref> is available at <italic toggle="yes">Bioinformatics</italic> online.</p>
  </sec>
  <sec>
    <title>Funding</title>
    <p>This work was supported in part by the Grant-in-Aid for JSPS Fellows [21J10716] (to B.M.), and the Japan Agency for Medical Research and Development (AMED) [21tm0424219h0001] (to S.M.).</p>
    <p>Conflict of interest: None declared.</p>
  </sec>
  <ref-list id="ref1">
    <title>References</title>
    <ref id="btad185-B1">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Audano</surname><given-names>PA</given-names></string-name>, <string-name><surname>Sulovari</surname><given-names>A</given-names></string-name>, <string-name><surname>Graves-Lindsay</surname><given-names>TA</given-names></string-name></person-group><etal>et al</etal><article-title>Characterizing the major structural variant alleles of the human genome</article-title>. <source>Cell</source><year>2019</year>;<volume>176</volume>:<fpage>663</fpage>–<lpage>75.e19</lpage>.<pub-id pub-id-type="pmid">30661756</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B2">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Benson</surname><given-names>G.</given-names></string-name></person-group><article-title>Tandem repeats finder: a program to analyze DNA sequences</article-title>. <source>Nucleic Acids Res</source><year>1999</year>;<volume>27</volume>:<fpage>573</fpage>–<lpage>80</lpage>.<pub-id pub-id-type="pmid">9862982</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B3">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Bowcock</surname><given-names>AM</given-names></string-name>, <string-name><surname>Ruiz-Linares</surname><given-names>A</given-names></string-name>, <string-name><surname>Tomfohrde</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>High resolution of human evolutionary trees with polymorphic microsatellites</article-title>. <source>Nature</source><year>1994</year>;<volume>368</volume>:<fpage>455</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">7510853</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B4">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Cortese</surname><given-names>A</given-names></string-name>, <string-name><surname>Simone</surname><given-names>R</given-names></string-name>, <string-name><surname>Sullivan</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Biallelic expansion of an intronic repeat in RFC1 is a common cause of late-onset ataxia</article-title>. <source>Nat Genet</source><year>2019</year>;<volume>51</volume>:<fpage>649</fpage>–<lpage>58</lpage>.<pub-id pub-id-type="pmid">30926972</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B5">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Course</surname><given-names>MM</given-names></string-name>, <string-name><surname>Gudsnuk</surname><given-names>K</given-names></string-name>, <string-name><surname>Smukowski</surname><given-names>SN</given-names></string-name></person-group><etal>et al</etal><article-title>Evolution of a human-specific tandem repeat associated with ALS</article-title>. <source>Am J Hum Genet</source><year>2020</year>;<volume>107</volume>:<fpage>445</fpage>–<lpage>60</lpage>.<pub-id pub-id-type="pmid">32750315</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B6">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Course</surname><given-names>MM</given-names></string-name>, <string-name><surname>Sulovari</surname><given-names>A</given-names></string-name>, <string-name><surname>Gudsnuk</surname><given-names>K</given-names></string-name></person-group><etal>et al</etal><article-title>Characterizing nucleotide variation and expansion dynamics in human-specific variable number tandem repeats</article-title>. <source>Genome Res</source><year>2021</year>;<volume>31</volume>:<fpage>1313</fpage>–<lpage>24</lpage>.<pub-id pub-id-type="pmid">34244228</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B7">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dashnow</surname><given-names>H</given-names></string-name>, <string-name><surname>Lek</surname><given-names>M</given-names></string-name>, <string-name><surname>Phipson</surname><given-names>B</given-names></string-name></person-group><etal>et al</etal><article-title>STRetch: detecting and discovering pathogenic short tandem repeat expansions</article-title>. <source>Genome Biol</source><year>2018</year>;<volume>19</volume>:<fpage>1</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">29301551</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B8">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>De Roeck</surname><given-names>A</given-names></string-name>, <string-name><surname>Duchateau</surname><given-names>L</given-names></string-name>, <string-name><surname>Van Dongen</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal>; <collab>BELNEU Consortium</collab>. <article-title>An intronic VNTR affects splicing of ABCA7 and increases risk of alzheimer’s disease</article-title>. <source>Acta Neuropathol</source><year>2018</year>;<volume>135</volume>:<fpage>827</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">29589097</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B9">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Depienne</surname><given-names>C</given-names></string-name>, <string-name><surname>Mandel</surname><given-names>J-L.</given-names></string-name></person-group><article-title>30 Years of repeat expansion disorders: what have we learned and what are the remaining challenges?</article-title><source>Am J Hum Genet</source><year>2021</year>;<volume>108</volume>:<fpage>764</fpage>–<lpage>85</lpage>.<pub-id pub-id-type="pmid">33811808</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B10">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dolzhenko</surname><given-names>E</given-names></string-name>, <string-name><surname>Bennett</surname><given-names>MF</given-names></string-name>, <string-name><surname>Richmond</surname><given-names>PA</given-names></string-name></person-group><etal>et al</etal><article-title>ExpansionHunter denovo: a computational method for locating known and novel repeat expansions in short-read sequencing data</article-title>. <source>Genome Biol</source><year>2020</year>;<volume>21</volume>:<fpage>1</fpage>–<lpage>14</lpage>.</mixed-citation>
    </ref>
    <ref id="btad185-B11">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dolzhenko</surname><given-names>E</given-names></string-name>, <string-name><surname>Deshpande</surname><given-names>V</given-names></string-name>, <string-name><surname>Schlesinger</surname><given-names>F</given-names></string-name></person-group><etal>et al</etal><article-title>ExpansionHunter: a sequence-graph-based tool to analyze variation in short tandem repeat regions</article-title>. <source>Bioinformatics</source><year>2019</year>;<volume>35</volume>:<fpage>4754</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">31134279</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B12">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dvorkina</surname><given-names>T</given-names></string-name>, <string-name><surname>Bzikadze</surname><given-names>AV</given-names></string-name>, <string-name><surname>Pevzner</surname><given-names>PA</given-names></string-name></person-group><etal>et al</etal><article-title>The string decomposition problem and its applications to centromere analysis and assembly</article-title>. <source>Bioinformatics</source><year>2020</year>;<volume>36</volume>:<fpage>i93</fpage>–<lpage>101</lpage>.<pub-id pub-id-type="pmid">32657390</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B13">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Dvorkina</surname><given-names>T</given-names></string-name>, <string-name><surname>Kunyavskaya</surname><given-names>O</given-names></string-name>, <string-name><surname>Bzikadze</surname><given-names>AV</given-names></string-name></person-group><etal>et al</etal><article-title>CentromereArchitect: inference and analysis of the architecture of centromeres</article-title>. <source>Bioinformatics</source><year>2021</year>;<volume>37</volume>:<fpage>i196</fpage>–<lpage>204</lpage>.<pub-id pub-id-type="pmid">34252949</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B14">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ellegren</surname><given-names>H.</given-names></string-name></person-group><article-title>Microsatellites: simple sequences with complex evolution</article-title>. <source>Nat Rev Genet</source><year>2004</year>;<volume>5</volume>:<fpage>435</fpage>–<lpage>45</lpage>.<pub-id pub-id-type="pmid">15153996</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B15">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hamada</surname><given-names>H</given-names></string-name>, <string-name><surname>Kakunaga</surname><given-names>T.</given-names></string-name></person-group><article-title>Potential Z-DNA forming sequences are highly dispersed in the human genome</article-title>. <source>Nature</source><year>1982</year>;<volume>298</volume>:<fpage>396</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">6283389</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B16">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Hannan</surname><given-names>AJ.</given-names></string-name></person-group><article-title>Tandem repeats mediating genetic plasticity in health and disease</article-title>. <source>Nat Rev Genet</source><year>2018</year>;<volume>19</volume>:<fpage>286</fpage>–<lpage>98</lpage>.<pub-id pub-id-type="pmid">29398703</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B17">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Ishiura</surname><given-names>H</given-names></string-name>, <string-name><surname>Doi</surname><given-names>K</given-names></string-name>, <string-name><surname>Mitsui</surname><given-names>J</given-names></string-name></person-group><etal>et al</etal><article-title>Expansions of intronic TTTCA and TTTTA repeats in benign adult familial myoclonic epilepsy</article-title>. <source>Nat Genet</source><year>2018</year>;<volume>50</volume>:<fpage>581</fpage>–<lpage>90</lpage>.<pub-id pub-id-type="pmid">29507423</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B18">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Jeffreys</surname><given-names>AJ</given-names></string-name>, <string-name><surname>Wilson</surname><given-names>V</given-names></string-name>, <string-name><surname>Thein</surname><given-names>SL</given-names></string-name></person-group><etal>et al</etal><article-title>Hypervariable ’minisatellite’ regions in human DNA</article-title>. <source>Nature</source><year>1985</year>;<volume>314</volume>:<fpage>67</fpage>–<lpage>73</lpage>.<pub-id pub-id-type="pmid">3856104</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B19">
      <mixed-citation publication-type="book"><person-group person-group-type="author"><string-name><surname>Kasai</surname><given-names>T</given-names></string-name>, <string-name><surname>Lee</surname><given-names>G</given-names></string-name>, <string-name><surname>Arimura</surname><given-names>H</given-names></string-name>, <string-name><surname>Arikawa</surname><given-names>S</given-names></string-name>, <string-name><surname>Park</surname><given-names>K</given-names></string-name></person-group>. <part-title>Linear-time longest-common-prefix computation in suffix arrays and its applications</part-title>. In: Amir, A. (ed) <source>Combinatorial Pattern Matching</source>. <publisher-loc>Berlin, Heidelberg</publisher-loc>. <publisher-name>Springer Berlin Heidelberg</publisher-name>, <year>2001</year>, <fpage>181</fpage>–<lpage>192</lpage>.</mixed-citation>
    </ref>
    <ref id="btad185-B20">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Koob</surname><given-names>MD</given-names></string-name>, <string-name><surname>Moseley</surname><given-names>ML</given-names></string-name>, <string-name><surname>Schut</surname><given-names>LJ</given-names></string-name></person-group><etal>et al</etal><article-title>An untranslated CTG expansion causes a novel form of spinocerebellar ataxia (SCA8)</article-title>. <source>Nat Genet</source><year>1999</year>;<volume>21</volume>:<fpage>379</fpage>–<lpage>84</lpage>.<pub-id pub-id-type="pmid">10192387</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B21">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Liquori</surname><given-names>CL</given-names></string-name>, <string-name><surname>Ricker</surname><given-names>K</given-names></string-name>, <string-name><surname>Moseley</surname><given-names>ML</given-names></string-name></person-group><etal>et al</etal><article-title>Myotonic dystrophy type 2 caused by a CCTG expansion in intron I of ZNF9</article-title>. <source>Science</source><year>2001</year>;<volume>293</volume>:<fpage>864</fpage>–<lpage>7</lpage>.<pub-id pub-id-type="pmid">11486088</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B22">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Miesfeld</surname><given-names>R</given-names></string-name>, <string-name><surname>Krystal</surname><given-names>M</given-names></string-name>, <string-name><surname>Arnheim</surname><given-names>N.</given-names></string-name></person-group><article-title>A member of a new repeated sequence family which is conserved throughout eucaryotic evolution is found between the human Delta and beta globin genes</article-title>. <source>Nucleic Acids Res</source><year>1981</year>;<volume>9</volume>:<fpage>5931</fpage>–<lpage>47</lpage>.<pub-id pub-id-type="pmid">6273813</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B23">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Morris</surname><given-names>J</given-names></string-name>, <string-name><surname>Pratt</surname><given-names>V.</given-names></string-name></person-group> A linear pattern-matching algorithm. In: <italic toggle="yes">Technical Report 40</italic>, Vol. 40. Computing Center, University of California, Berkeley, <year>1970</year>.</mixed-citation>
    </ref>
    <ref id="btad185-B24">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Mousavi</surname><given-names>N</given-names></string-name>, <string-name><surname>Shleizer-Burko</surname><given-names>S</given-names></string-name>, <string-name><surname>Yanicky</surname><given-names>R</given-names></string-name></person-group><etal>et al</etal><article-title>Profiling the genome-wide landscape of tandem repeat expansions</article-title>. <source>Nucleic Acids Res</source><year>2019</year>;<volume>47</volume>:<fpage>e90</fpage>–<lpage>13</lpage>.<pub-id pub-id-type="pmid">31194863</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B25">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Myers</surname><given-names>EW</given-names></string-name>, <string-name><surname>Miller</surname><given-names>W.</given-names></string-name></person-group><article-title>Approximate matching of regular expressions</article-title>. <source>Bull Math Biol</source><year>1989</year>;<volume>51</volume>:<fpage>5</fpage>–<lpage>37</lpage>.<pub-id pub-id-type="pmid">2706401</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B26">
      <mixed-citation publication-type="other"><person-group person-group-type="author"><string-name><surname>Nong</surname><given-names>G</given-names></string-name></person-group><etal>et al</etal> Linear suffix array construction by almost pure induced-sorting. In: <italic toggle="yes">2009 Data Compression Conference</italic>, Snowbird, UT, USA. <year>2009</year>, <fpage>193</fpage>–<lpage>202</lpage>.</mixed-citation>
    </ref>
    <ref id="btad185-B27">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Smith</surname><given-names>GP.</given-names></string-name></person-group><article-title>Evolution of repeated DNA sequences by unequal crossover</article-title>. <source>Science</source><year>1976</year>;<volume>191</volume>:<fpage>528</fpage>–<lpage>35</lpage>.<pub-id pub-id-type="pmid">1251186</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B28">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Song</surname><given-names>JHT</given-names></string-name>, <string-name><surname>Lowe</surname><given-names>CB</given-names></string-name>, <string-name><surname>Kingsley</surname><given-names>DM.</given-names></string-name></person-group><article-title>Characterization of a human-specific tandem repeat associated with bipolar disorder and schizophrenia</article-title>. <source>Am J Hum Genet</source><year>2018</year>;<volume>103</volume>:<fpage>421</fpage>–<lpage>30</lpage>.<pub-id pub-id-type="pmid">30100087</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B29">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Spritz</surname><given-names>RA.</given-names></string-name></person-group><article-title>Duplication/deletion polymorphism 5’- to the human <italic toggle="yes">β</italic> globin gene</article-title>. <source>Nucleic Acids Res</source><year>1981</year>;<volume>9</volume>:<fpage>5037</fpage>–<lpage>47</lpage>.<pub-id pub-id-type="pmid">7312624</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B30">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Tautz</surname><given-names>D</given-names></string-name>, <string-name><surname>Trick</surname><given-names>M</given-names></string-name>, <string-name><surname>Dover</surname><given-names>GA.</given-names></string-name></person-group><article-title>Cryptic simplicity in DNA is a major source of genetic variation</article-title>. <source>Nature</source><year>1986</year>;<volume>322</volume>:<fpage>652</fpage>–<lpage>6</lpage>.<pub-id pub-id-type="pmid">3748144</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B31">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Weber</surname><given-names>JL</given-names></string-name>, <string-name><surname>Wong</surname><given-names>C.</given-names></string-name></person-group><article-title>Mutation of human short tandem repeats</article-title>. <source>Hum Mol Genet</source><year>1993</year>;<volume>2</volume>:<fpage>1123</fpage>–<lpage>8</lpage>.<pub-id pub-id-type="pmid">8401493</pub-id></mixed-citation>
    </ref>
    <ref id="btad185-B32">
      <mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><surname>Wright</surname><given-names>GEB</given-names></string-name>, <string-name><surname>Collins</surname><given-names>JA</given-names></string-name>, <string-name><surname>Kay</surname><given-names>C</given-names></string-name></person-group><etal>et al</etal><article-title>Length of uninterrupted CAG, independent of polyglutamine size, results in increased somatic instability, hastening onset of Huntington disease</article-title>. <source>Am J Hum Genet</source><year>2019</year>;<volume>104</volume>:<fpage>1116</fpage>–<lpage>26</lpage>.<pub-id pub-id-type="pmid">31104771</pub-id></mixed-citation>
    </ref>
  </ref-list>
</back>
