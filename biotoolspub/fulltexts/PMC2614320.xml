<?properties open_access?>
<front>
  <journal-meta>
    <journal-id journal-id-type="nlm-ta">Front Neuroinformatics</journal-id>
    <journal-id journal-id-type="publisher-id">Front. Neuroinform.</journal-id>
    <journal-title>Frontiers in Neuroinformatics</journal-title>
    <issn pub-type="epub">1662-5196</issn>
    <publisher>
      <publisher-name>Frontiers Research Foundation</publisher-name>
    </publisher>
  </journal-meta>
  <article-meta>
    <article-id pub-id-type="pmcid">2614320</article-id>
    <article-id pub-id-type="doi">10.3389/neuro.11.006.2008</article-id>
    <article-id pub-id-type="pmid">19129924</article-id>
    <article-categories>
      <subj-group subj-group-type="heading">
        <subject>Neuroscience</subject>
        <subj-group>
          <subject>Original Research</subject>
        </subj-group>
      </subj-group>
    </article-categories>
    <title-group>
      <article-title>PyMOOSE: Interoperable Scripting in Python for MOOSE</article-title>
    </title-group>
    <contrib-group>
      <contrib contrib-type="author">
        <name>
          <surname>Ray</surname>
          <given-names>Subhasis</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
      </contrib>
      <contrib contrib-type="author">
        <name>
          <surname>Bhalla</surname>
          <given-names>Upinder S.</given-names>
        </name>
        <xref ref-type="aff" rid="aff1">
          <sup>1</sup>
        </xref>
        <xref ref-type="author-notes" rid="fn001">*</xref>
      </contrib>
    </contrib-group>
    <aff id="aff1">
      <sup>1</sup>
      <institution>National Centre for Biological Sciences</institution>
      <country>Bangalore, India</country>
    </aff>
    <author-notes>
      <fn fn-type="edited-by">
        <p>Edited by: Rolf Kötter, Radboud University Nijmegen, The Netherlands</p>
      </fn>
      <fn fn-type="edited-by">
        <p>Reviewed by: Michael Hines, Yale University, USA; Hugo Cornelis, UTHSCSA, USA</p>
      </fn>
      <corresp id="fn001">*Correspondence: Upinder S. Bhalla, National Centre for Biological Sciences, Tata Institute of Fundamental Research, Bellary Road, Bangalore 560065, India. e-mail: <email>bhalla@ncbs.res.in</email></corresp>
    </author-notes>
    <pub-date pub-type="epreprint">
      <day>13</day>
      <month>10</month>
      <year>2008</year>
    </pub-date>
    <pub-date pub-type="epub">
      <day>19</day>
      <month>12</month>
      <year>2008</year>
    </pub-date>
    <pub-date pub-type="collection">
      <year>2008</year>
    </pub-date>
    <volume>2</volume>
    <elocation-id>6</elocation-id>
    <history>
      <date date-type="received">
        <day>15</day>
        <month>9</month>
        <year>2008</year>
      </date>
      <date date-type="accepted">
        <day>01</day>
        <month>11</month>
        <year>2008</year>
      </date>
    </history>
    <permissions>
      <copyright-statement>Copyright © 2008 Ray and Bhalla.</copyright-statement>
      <copyright-year>2008</copyright-year>
      <license license-type="open-access" xlink:href="http://www.frontiersin.org/licenseagreement">
        <p>This is an open-access article subject to an exclusive license agreement between the authors and the Frontiers Research Foundation, which permits unrestricted use, distribution, and reproduction in any medium, provided the original authors and source are credited.</p>
      </license>
    </permissions>
    <abstract>
      <p>Python is emerging as a common scripting language for simulators. This opens up many possibilities for interoperability in the form of analysis, interfaces, and communications between simulators. We report the integration of Python scripting with the Multi-scale Object Oriented Simulation Environment (MOOSE). MOOSE is a general-purpose simulation system for compartmental neuronal models and for models of signaling pathways based on chemical kinetics. We show how the Python-scripting version of MOOSE, PyMOOSE, combines the power of a compiled simulator with the versatility and ease of use of Python. We illustrate this by using Python numerical libraries to analyze MOOSE output online, and by developing a GUI in Python/Qt for a MOOSE simulation. Finally, we build and run a composite neuronal/signaling model that uses both the NEURON and MOOSE numerical engines, and Python as a bridge between the two. Thus PyMOOSE has a high degree of interoperability with analysis routines, with graphical toolkits, and with other simulators.</p>
    </abstract>
    <kwd-group>
      <kwd>simulators</kwd>
      <kwd>compartmental models</kwd>
      <kwd>systems biology</kwd>
      <kwd>NEURON</kwd>
      <kwd>GENESIS</kwd>
      <kwd>multi-scale models</kwd>
      <kwd>Python</kwd>
      <kwd>MOOSE</kwd>
    </kwd-group>
    <counts>
      <fig-count count="4"/>
      <table-count count="0"/>
      <equation-count count="0"/>
      <ref-count count="26"/>
      <page-count count="16"/>
      <word-count count="7325"/>
    </counts>
  </article-meta>
</front>
<body>
  <sec sec-type="introduction">
    <title>Introduction</title>
    <p>In computational biology there are two approaches to developing a simulation. First, write your custom program to do a specific simulation, and second, write a model and run it in a general-purpose simulator. While the first approach is very common, it requires the scientist to be a good programmer (or have one at her/his disposal) and moves the focus towards programming rather than science. Furthermore, it is very difficult for others to read such a program and understand how it relates to the targeted biological system. In this context, a model is a well-defined set of equations and parameters that is meant to represent and predict the behavior of a biological system. Ideally, a general-purpose simulator allows the model to be separated from the low-level data-structures and control. The scientist is no longer concerned with minutiae of software engineering and can concentrate on the biological system of interest. The model can be shared by other people and understood relatively easily using intermediate-level descriptions of the model with a more obvious mapping to the real biological system. General simulators also lend themselves to declarative, high-level model descriptions that have now become important part of scientific interchange in the computational neuroscience and systems biology communities (Beeman and Bower, <xref ref-type="bibr" rid="B3">2004</xref>; Cannon et al., <xref ref-type="bibr" rid="B9">2007</xref>; Goddard et al., <xref ref-type="bibr" rid="B15">2001</xref>; Hucka et al., <xref ref-type="bibr" rid="B19">2002</xref>; <uri xlink:type="simple" xlink:href="http://www.morphml.org/">http://www.morphml.org/</uri>; <uri xlink:type="simple" xlink:href="http://neuroml.org">http://neuroml.org</uri>, <uri xlink:type="simple" xlink:href="http://sbml.org">http://sbml.org</uri>). The goal of this paper is to show how the simulator Multi-scale Object Oriented Simulation Environment (MOOSE; <uri xlink:type="simple" xlink:href="http://moose.ncbs.res.in/">http://moose.ncbs.res.in/</uri>, mirrored at <uri xlink:type="simple" xlink:href="http://moose.sourceforge.net/">http://moose.sourceforge.net/</uri>) uses Python to address these issues of interoperability with analysis software, graphical interfaces, and other simulators.</p>
    <p>General-purpose simulators have been in use since the venerable circuit simulator SPICE was utilized to solve compartmental models (Bunow et al., <xref ref-type="bibr" rid="B8">1985</xref>; Segev et al., <xref ref-type="bibr" rid="B25">1985</xref>). While this level of generality ran into limitations of computing power, more specialized neuronal simulators such as GENESIS and NEURON (Bower and Beeman, <xref ref-type="bibr" rid="B7">1998</xref>; Carnevale and Hines, <xref ref-type="bibr" rid="B10">2006</xref>; Hines, <xref ref-type="bibr" rid="B17">1993</xref>) included optimized custom code that would allow the simulation to be run in affordable time and memory. This process of building domain-specific general simulators has continued with several simulators devoted to different aspects of computational and systems biology (e.g., VCell, Smoldyn, COPASI). This proliferation of simulators brings back the problems of model exchange and interoperability, albeit at a higher-level than raw Fortran or C code. While these simulators now have a common set of shared higher-level concepts (e.g., compartments, channels, synapses), they use entirely different vocabularies and languages for set up and control.</p>
    <p>MOOSE is a new simulator project that supports simulations across a wide range of scales in computational biology, including computational neuroscience and systems biology. In order to improve interoperability, MOOSE uses two existing languages: the GENESIS scripting language, and Python. The Neurospaces (Cornelis and De Schutter, <xref ref-type="bibr" rid="B11">2003</xref>; <uri xlink:type="simple" xlink:href="http://neurospaces.sourceforge.net/">http://neurospaces.sourceforge.net/</uri>) project takes a distinct approach to supporting some GENESIS capabilities using backward-compatible scripting, and it too can utilize Python.</p>
    <p>Most established simulators have their own scripting languages. For example, NEURON uses hoc along with modl files to set up simulations. GENESIS has its own custom scripting language. MOOSE avoids introducing a new language, and instead inherits the GENESIS parser. To increase compatibility, MOOSE has equivalents for most objects in GENESIS, and many old scripts can be run on MOOSE with little or no modification. Given these existing capabilities, why add Python scripting? Despite its flexibility, the GENESIS scripting language has several limitations:
<list list-type="order"><list-item><p>Domain specificity: It is not used outside GENESIS. This forces the user to learn a special-purpose scripting language.</p></list-item><list-item><p>Problem with extensibility: While it is easy to write a script to define functions that can be included in other scripts, these interpreted functions are much slower than compiled code. The GENESIS scripting language itself provides for some degree of extensibility, but this is difficult to implement. Adding a single command requires implementation in C, as well as definition of the command in a configuration file that must be pre-processed to include into the interpreter. The addition of a new class is still more involved.</p></list-item><list-item><p>Lack of existing libraries: The GENESIS scripting language is a special-purpose language and has no additional features other than those written into the language.</p></list-item><list-item><p>Syntax: The syntax is complex and inconsistent as a result of accretion of features by many developers and users. For example, arrays are implemented in three inconsistent ways in the GENESIS scripting language: as arrays of elements, entries within tables and extended fields.</p></list-item></list></p>
    <p>To harness the capabilities provided by a modern widely used scripting language, we chose a Python interface. Among the plethora of programming languages, Python has some special advantages:
<list list-type="order"><list-item><p>Interactive: We need a scripting language that comes with a command line interpreter. Python is suited for this. User interaction is as important as running standalone scripts. Simulations are built incrementally, and it is important that users can try out bits and pieces of code and get quick feedback from the system. Moreover, this practice helps in identifying errors early in the development process, which saves considerable time and computational resources.</p></list-item><list-item><p>It is easy to interface with other programming languages: Python itself is written in C. It has a standard developers' API for creating extension libraries. This simplifies creating Python interface for C/C++ code. Moreover, tools like Simplified Wrapper and Interface Generator (SWIG), Qt sip, boost-Python can automate the task of creating a Python interface from existing C/C++ code.</p></list-item><list-item><p>It is portable: Python runs on Linux, Solaris, Macintosh and Windows operating systems and many other platforms (<uri xlink:type="simple" xlink:href="http://www.python.org/about/">http://www.python.org/about/</uri>).</p></list-item><list-item><p>Free: Python is free and open-source.</p></list-item><list-item><p>Widely used: Python is widely used in scientific community. There is a large repertoire of third-party libraries for Python. Many of these libraries are free, open source and mature.</p></list-item></list></p>
    <p>In this study we show how PyMOOSE harnesses each of these capabilities.</p>
  </sec>
  <sec sec-type="materials|methods">
    <title>Materials and Methods</title>
    <p>There are two common approaches to create a Python interface to a C/C++ library: (1) statically link it with the Python interpreter – which involves compiling the Python interpreter source-code, (2) create a dynamic link library and provide it as a Python module. We took the second approach as it provides more flexibility on the choice of the Python interpreter and reduces the burden on the maintainer.</p>
    <sec>
      <title>Mapping MOOSE classes into python</title>
      <p>MOOSE has a set of built-in classes for representing simulation entities. These classes provide a mapping from the concept space to the computational space. Physical or chemical properties and other relevant parameters are accessible as member fields of the classes and the time-evolution of these parameters is calculated by a special process method of each class. These classes add another layer over ordinary C++ classes to provide messaging and scheduling as well as customized access to the member fields. MOOSE provides introspection (Maes, <xref ref-type="bibr" rid="B21">1987</xref>; Smith, <xref ref-type="bibr" rid="B26">1982</xref>), so that full field information for each class is accessible to the programmer. This class information is statically initialized for each class at startup time. We utilized this class information and SWIG (Beazley, <xref ref-type="bibr" rid="B2">1996</xref>; <uri xlink:type="simple" xlink:href="http://www.swig.org">http://www.swig.org</uri>) to build the Python interface.</p>
      <p>SWIG is a mature software with good support for Python and C/C++ interfacing as well as many other languages. While it is rather simple to create an interface for ordinary C++ class using SWIG, our task was complicated because MOOSE classes have another layer over ordinary C++ classes. For this reason we created a framework for Python interface with additional C++ classes to wrap MOOSE classes and a few classes to manage the system.</p>
    </sec>
    <sec>
      <title>Simulator control through python</title>
      <p>All operations on MOOSE objects are carried out via a special class, Shell, of which there is a single instance on each processor node that is running MOOSE. In PyMOOSE we implemented a singleton context object to communicate with the Shell. The context object provides a set of functions that can be called to pass appropriate messages to the Shell. The user can call global MOOSE functions by calling the corresponding methods of the context object. Operations like creation of objects, setting integration time step, running the simulation are all done through the context object.</p>
      <p>We created a one-to-one mapping of MOOSE classes to Python classes by means of light-weight C++ wrapper classes. All the wrapper classes were derived from one common base class. Each MOOSE object is identified by an Identifier (ID) field. The main data content of a wrapper class instance is the ID of the corresponding object in MOOSE. Additionally, the wrapper classes have a static pointer to the single instance of the context object. Wrapper classes provide accessor methods that can be used to access the fields in the corresponding MOOSE object.</p>
      <p>These C++ wrapper classes were input to SWIG to create the Python module. After translation to Python, the user sees the member fields in the Python classes in place of the accessor methods in the C++ wrapper classes. Behind the scene the Python interpreter calls these accessor methods whenever the user script tries to access MOOSE object fields (Figure <xref ref-type="fig" rid="F1">1</xref>A).</p>
      <p>Manually developing C++ wrapper classes for all MOOSE classes was a tedious but repetitive task. We therefore embedded stub code in the MOOSE initialization code to generate most of the wrapper code programmatically using Run-Time Type Information in C++. This auto-generated code was used with a few modifications to generate a Python module using SWIG. SWIG takes an interface file with SWIG-specific directives and generates a single C++ file for the library and a Python source-code file that contains support code. We completed the PyMOOSE code generation by compiling and linking the SWIG-generated C++ source-code as a dynamic library. This dynamic library can be imported in any Python program.</p>
      <fig id="F1" position="float">
        <label>Figure 1</label>
        <caption>
          <p><bold>PyMOOSE interface</bold>. <bold>(A)</bold> Communication between Python and MOOSE. MOOSE represents concepts through objects and manipulates them using the singleton Shell object. PyMOOSE provides a light-weight mirror representation of each MOOSE object. Operations on PyMOOSE objects are communicated to MOOSE via the context and the Shell object. <bold>(B)</bold> Accessing legacy scripts through PyMOOSE. The Shell object is usually controlled through the PyMooseContext. When loading a GENESIS script, control is temporarily passed to the legacy GENESIS script language parser, and then returned to the PyMooseContext.</p>
        </caption>
        <graphic xlink:href="fninf-02-006-g001"/>
      </fig>
    </sec>
    <sec>
      <title>Legacy models and PyMOOSE</title>
      <p>The PyMOOSE context object keeps a single instance of the GenesisParser class in order to run legacy GENESIS scripts. Whenever the user asks for executing a GENESIS statement, the context object disconnects itself from the Shell and connects the GenesisParser object instead. The GENESIS statement string is passed to the GenesisParser object, which executes it as if the user typed it in at the MOOSE command prompt. After execution of the statement (or script) the GenesisParser object is disconnected from the Shell and the context object is reconnected (Figure <xref ref-type="fig" rid="F1">1</xref>B).</p>
      <p>While it is valuable to run GENESIS scripts within PyMOOSE, this feature is intended only to support legacy code and is better avoided in new model development. The use of GENESIS scripting language inside Python defeats the whole purpose of moving to a general-purpose programming language. It reduces readability and the user needs to know both languages in order to understand the code.</p>
    </sec>
  </sec>
  <sec>
    <title>Results</title>
    <p>We used the Python interface of MOOSE to achieve three key targets: (1) Interfacing with standard libraries in a mature scientific computing language, (2) giving access to a portable GUI library for developing user interface and (3) enabling MOOSE to work together with other simulators.</p>
    <sec>
      <title>Interfacing simulations with python libraries</title>
      <p>We used Python scientific and graphing libraries to analyze and display the output of a PyMOOSE simulation. The interface with Python gives the user freedom to choose from a wide variety of scientific and numerical libraries available from third parties. We demonstrate the use of two libraries along with PyMOOSE for developing simulations with plotting and data analysis within Python. The first of these, NumPy, is a library that provides data structures and algorithms for fast matrix manipulation (<uri xlink:type="simple" xlink:href="http://numpy.scipy.org/">http://numpy.scipy.org/</uri>). Even though Python is interpreted, with attendant slow execution, NumPy library provides access to compiled code and hence the functions from the library are as fast as compiled code. The second library, matplotlib, provides a rich set of functions for plotting 2D data both in hardcopy formats and interactively (<uri xlink:type="simple" xlink:href="http://matplotlib.sourceforge.net/">http://matplotlib.sourceforge.net/</uri>). It can use NumPy for fast matrix operations in Python and several portable GUI toolkits (GTK/Qt/Tk/wxWidgets) as graphical back-end.</p>
      <p>We implemented a simulation of the squid giant axon using Hodgkin–Huxley Na<sup>+</sup> and K<sup>+</sup> channels and parameters (script attached in Appendix). We applied an injection current with random amplitude uniformly distributed between 0 and 100 nA. We recorded the time-series for the membrane potential during the simulation in a MOOSE table object, which can accumulate a time-series of simulation output (Figure <xref ref-type="fig" rid="F2">2</xref>A). The interface to Python was done using the MOOSE table class. This class is exposed to Python with methods to emulate iterable type (Martelli et al., <xref ref-type="bibr" rid="B22">2005</xref>). The array constructor in NumPy accepts an iterable object and creates a NumPy array with a copy of the contents of the object. Thus the user is relieved of explicitly iterating over the table entries and copying them to a NumPy array. This completes the interface from the MOOSE simulation output to NumPy (Figure <xref ref-type="fig" rid="F2">2</xref>B). We used the fast Fourier transform operation available in NumPy to compute the discrete Fourier transform of the time-series of the simulated membrane potential. We used matplotlib to plot the original time-series, as well as the output of the FFT (Figure <xref ref-type="fig" rid="F2">2</xref>C).</p>
      <fig id="F2" position="float">
        <label>Figure 2</label>
        <caption>
          <p><bold>Analysis and graphing of a PyMOOSE simulation</bold>. <bold>(A)</bold> Simulation input (random input current) and output (membrane potential). <bold>(B)</bold> Data flow. The simulation time-series is recorded in the MOOSE table object, which is visible to Python as a sequence object. This is accessed as an array in NumPy. The fast Fourier transform is applied to this array, and the result plotted in Matplotlib. <bold>(C)</bold> Output of FFT analysis (with the fundamental frequency removed).</p>
        </caption>
        <graphic xlink:href="fninf-02-006-g002"/>
      </fig>
      <p>Overall, this example simulation illustrates how PyMOOSE facilitates interoperability of Python numerical and graphing libraries with MOOSE.</p>
    </sec>
    <sec>
      <title>Portable GUI through python</title>
      <p>The use of Python separates the problem of GUI development from simulator development. Moreover, it gives one the freedom to choose from a number of free GUI toolkits. The major platform independent GUI toolkits with Python interfaces are Qt(TM) available as PyQt, wxWidgets (wxPython), Tk and GTK (<uri xlink:type="simple" xlink:href="http://wiki.python.org/moin/GuiProgramming">http://wiki.python.org/moin/GuiProgramming</uri>; <uri xlink:type="simple" xlink:href="http://www.python.org/doc/faq/gui/">http://www.python.org/doc/faq/gui/</uri>). We used PyQt4 to develop a simple user interface for a clone of the GENESIS squid tutorial in MOOSE. We selected Qt4 as it is a mature and clean toolkit that is freely distributed and runs well on all the major operating systems.</p>
      <p>The program was divided into three modules – (1) the squid axon compartment with Hodgkin–Huxley channels, (2) a model object which combined a few tables with the squid compartment to record various parameters through the time of the simulation, and (3) the GUI to take user inputs and to plot data. We implemented the squid axon model as described in the previous section, using PyMOOSE to set up and parameterize the model. As before, the model was interfaced with table objects to monitor time-series output of the simulation. Finally, we implemented the GUI by loading in the PyQt4 libraries, and using Python calls to set up the interface (Figure <xref ref-type="fig" rid="F3">3</xref>). While there are Qt IDEs available (<uri xlink:type="simple" xlink:href="http://trolltech.com/products/qt/">http://trolltech.com/products/qt/</uri>), we constructed the interface through explicit Python calls to create widgets, assign actions, and manage output data. Qt uses a signal-slot mechanism for passing event information. PyQt allows the use of arbitrary Python methods to be used as slots. Hence we could connect the GUI widgets to methods in the PyMOOSE model class and thus provided simulation control through the GUI in a clean manner. We used PyQwt, a Python interface of the Qt-based plotting library Qwt, for creating output graphs. Since PyQwt can take NumPy arrays as data, we converted the tables in MOOSE to NumPy arrays and used PyQwt plotting widgets to display them.</p>
      <fig id="F3" position="float">
        <label>Figure 3</label>
        <caption>
          <p><bold>Screen shot of PyMOOSE/Qt interface for the Hodgkin–Huxley model</bold>. The layout is closely modeled on the Squid demo from GENESIS.</p>
        </caption>
        <graphic xlink:href="fninf-02-006-g003"/>
      </fig>
      <p>We based the layout of the simulation on the widely used GENESIS Squid tutorial program. To confirm portability of the system, we ran the model on Linux as well as the Windows operating system.</p>
      <p>This exercise demonstrated the capability of PyMOOSE to draw upon existing graphical libraries for its graphical requirements. This is an important departure from GENESIS. The GENESIS graphical libraries (XODUS) were an integral part of the C code-base and XODUS objects were visible as, and manipulated in the same way as other GENESIS objects. In contrast, PyMOOSE did not need to implement any graphical objects within the MOOSE C++ code, but instead reused extant third-party graphical libraries available for Python. Furthermore the existing libraries are professionally designed and have a much more consistent look-and-feel than did the original GENESIS graphical library, XODUS (Bhalla, <xref ref-type="bibr" rid="B4">1998</xref>).</p>
    </sec>
    <sec>
      <title>Simulator interoperability</title>
      <p>With Python becoming a popular language for developing platform independent scripts, several neuronal simulators have implemented Python interfaces. This raises the possibility of using Python as a glue language to run simulations that span different simulators. As a final demonstration of interoperability, we used PyMOOSE with PyNEURON to build a multi-scale, multi-simulator model that incorporates neuronal electrical activity as well as biochemical signaling (Figure <xref ref-type="fig" rid="F4">4</xref>A).</p>
      <fig id="F4" position="float">
        <label>Figure 4</label>
        <caption>
          <p><bold>A combined, multi-scale NEURON and GENESIS model</bold>. <bold>(A)</bold> Setup of combined model, using NEURON and GENESIS model definition files. <bold>(B)</bold> Information flow during simulation. The two models were run independently for an initial settling period and for the test pulse to the NEURON model. During the combined simulation phase, each model was advanced for 1 s and then data was transferred via Python to the other model. Finally a second test pulse was delivered. <bold>(C)</bold> Response of NEURON model to first test pulse. <bold>(D)</bold> Calcium and MAPK levels in the signaling model. <bold>(E)</bold> Voltage responses from the NEURON model. <bold>(F)</bold> Experiment design and input to NEURON model. A test current pulse of 0.15 nA was delivered for 0.25 s to the NEURON model in the initialization phase. At the start of the combined simulation, a stimulus of 10 nA was delivered for 7 s. After 180 s of combined simulation a second test pulse (0.15 nA, 0.25 s) was applied. <bold>(G)</bold> Response of NEURON model to second test pulse. The difference is due to modulation of KCa by the elevated MAPK activity.</p>
        </caption>
        <graphic xlink:href="fninf-02-006-g004"/>
      </fig>
      <p>We used NEURON to model a multicompartmental electrical model of a Type A neuron from the CA3b region of the rat hippocampus (Migliore et al., <xref ref-type="bibr" rid="B23">1995</xref>; <uri xlink:type="simple" xlink:href="http://senselab.med.yale.edu/ModelDB/ShowModel.asp?model=3263">http://senselab.med.yale.edu/ModelDB/ShowModel.asp?model=3263</uri>). This is a morphologically detailed model with experimentally constrained distribution of membrane ion channels. It reproduces experimental observations of firing behavior and intracellular Ca<sup>2+</sup> dynamics. We modified the hoc script for the model, to run it for arbitrary time intervals. We directed the output data to Vector objects in NEURON. The Python wrapper class for this model provided a handle for the simulation parameters and functions defined in the hoc script. As described in the PyNEURON documentation (<uri xlink:type="simple" xlink:href="http://www.neuron.yale.edu/neuron/docs/help/neuron/neuron/classes/python.html">http://www.neuron.yale.edu/neuron/docs/help/neuron/neuron/classes/python.html</uri>), Python commands were directed to the NEURON engine by constructing hoc statement strings and executing them through the hoc interpreter instance provided by the neuron module. Moreover, hoc object references are directly available in Python as attributes of the hoc interpreter object. Thus accessing hoc objects was quite clean in Python (Figure <xref ref-type="fig" rid="F4">4</xref>A).</p>
      <p>We used MOOSE to model calcium-triggered biochemical signaling events at the synapse. We used a model of a bistable MAPK-PKC-PLA2 feedback loop that was originally implemented in GENESIS/Kinetikit (Ajay and Bhalla, <xref ref-type="bibr" rid="B1">2004</xref>; Bhalla and Iyengar, <xref ref-type="bibr" rid="B5">1999</xref>; Bhalla et al., <xref ref-type="bibr" rid="B6">2002</xref>) and uploaded to the DOQCS database (<uri xlink:type="simple" xlink:href="http://doqcs.ncbs.res.in/template.php?&amp;y=accessiondetails&amp;an=79">http://doqcs.ncbs.res.in/template.php?&amp;y=accessiondetails&amp;an=79</uri>). The model was defined in the GENESIS scripting language. We used the legacy scripting mode of PyMOOSE to load the GENESIS/kinetikit model. The simulation objects thus instantiated were standard MOOSE objects, and were accessible using Unix-like path strings. The PyMOOSE interface exposed these objects as regular Python objects. Thus access to the MOOSE objects, representing GENESIS data concepts, was also straightforward in Python (Figure <xref ref-type="fig" rid="F4">4</xref>A).</p>
      <p>We used the Python interface to accomplish three critical operations to combine the two simulations: (1) Initialization, (2) run-time control and synchronization, and (3) variable communication and rescaling.</p>
      <list list-type="order">
        <list-item>
          <p>To initialize the models, we used PyNEURON command <italic>load</italic>_<italic>file</italic> to load the hoc script. Once the script is loaded, variables and functions defined in the script become available as members of the hoc interpreter instance inside Python. In this case we defined a setup function to initialize the NEURON simulation. This function is called in the constructor (__<italic>init</italic>__) of the Python wrapper class over the NEURON simulation. At this stage we applied a test pulse of 1 nA for 250 ms to measure the firing properties of the neuron before potentiation. We then ran the NEURON model for 1 s to allow the model to settle. Similarly we loaded the GENESIS/Kinetikit model using the <italic>loadG</italic> command, and ran this simulation for 1800 s to settle.</p>
        </list-item>
        <list-item>
          <p>In the Python wrapper class for each model, we defined a run method to advance the simulation in time. That for the NEURON model uses a <italic>run</italic> function we defined in the custom hoc script. This run function calls NEURON's <italic>fadvance</italic> command to advance the simulation. In the wrapper class for the GENESIS/Kinetikit model the run method calls the <italic>step</italic> command to advance the simulation (Figure <xref ref-type="fig" rid="F4">4</xref>B).</p>
        </list-item>
        <list-item>
          <p>We used the Python interface to read out somatic calcium levels from the NEURON model and insert them into the MOOSE model, and to feed back MAPK activity changes from the MOOSE model to modulate KCa conductances.</p>
        </list-item>
      </list>
      <p>We wrote another higher-level function <italic>run</italic> to advance the coupled simulations using the two wrapper classes (not to be confused with the member method <italic>run</italic> of these classes). This function (1) creates instances of both wrappers, which involves initializing the models, (2) runs the NEURON simulation for 1 s, (3) reads out the calcium level, performs rescaling and updates the kinetic model with this value, (4) advances the kinetic simulation for 1 s to catch up with the electrical model, (5) reads out the activity level of MAPK from the GENESIS/Kinetikit model and modifies the [Ca<sup>2+</sup>] dependent K<sup>+</sup> channel conductances in the NEURON model in inverse proportion to this (Figures <xref ref-type="fig" rid="F4">4</xref>E,F).</p>
      <p>Our simulated experiment is illustrated in Figure <xref ref-type="fig" rid="F4">4</xref>F. We loaded the models and allowed them to settle. We measured baseline neuronal responses at this stage using a 250-ms, 0.15 nA current pulse. Following this we used the run function for the further time-evolution of the system. We applied a strong LTP-inducing stimulus to the neuronal model for 7 s, and then allowed the simulation to continue for 183 s. Finally we repeated the 250 ms, 0.15 nA test for neuronal responses.</p>
      <p>The time-evolution of membrane potential, Ca<sup>2+</sup> levels, and MAPK activity are shown in Figures <xref ref-type="fig" rid="F4">4</xref>D,E. The initial and final burst waveforms of the neuron are shown in Figures <xref ref-type="fig" rid="F4">4</xref>C,G. We observe that the coupled model shows how electrical stimulation can lead to signaling events, with feedback effects on the electrical properties of the neuron. We should point out that this simulation is only a demonstration and the relationship between the chemical system and the biophysical properties of the neuron is over-simplified, although the two component models we used are realistic within their respective domains.</p>
      <p>This example also illustrates the efficiency of using Python for data transfer when traffic volumes are small compared to the computational times. The neuronal calculations in NEURON took about 91% of the simulation run-time, the signaling calculations in MOOSE took ∼8.5%, and the data transfer through Python accounted for only around 0.5%. As we discuss below, there may be other interface contexts where more efficient, low-level data transfer protocols may be needed, and the relatively facile Python interface may not be appropriate.</p>
    </sec>
  </sec>
  <sec sec-type="discussion">
    <title>Discussion</title>
    <p>We have used PyMOOSE, the Python interface to MOOSE, to achieve interoperability at three levels. First, we used standard mathematical packages in Python to analyze MOOSE output. Second, we used the QT graphical toolkit from within Python to build a GUI for a MOOSE simulation. Third, we used Python as a glue language to run a cross-simulator model combining an electrophysiological model set up in NEURON with a biochemical signaling model set up in GENESIS/Kinetikit.</p>
    <sec>
      <title>Issues with python interoperability</title>
      <p>The strengths of the Python language make it perhaps too easy to repeat well-known mistakes in simulation development. We consider two such issues. First, Python is an interpreted language in most implementations. In the context of simulations, it is not meant for number crunching. Well-designed libraries like NumPy can hide some of these limitations from the user, and fast hardware can conceal other inefficiencies. However, given the same specialized algorithms, a compiled language will perform better than an interpreted one. Therefore, for large simulations, we need to combine the best possible algorithms with optimized and compiled languages. MOOSE has as one of its goals the capability of managing the low-level, high-traffic flow of data between different numerical engines incorporated into MOOSE. We do not consider Python appropriate for such operations. Second, many aspects of model specification should be done using declarative rather than procedural approaches (Cannon et al., <xref ref-type="bibr" rid="B9">2007</xref>; Crook et al., <xref ref-type="bibr" rid="B12">2005</xref>, <xref ref-type="bibr" rid="B13">2007</xref>). However, Python makes procedural model definition very easy, and may even provide a certain level of interoperability if several simulators provide equivalent calls for model setup. For example, there are some impressive recent efforts to develop a standard vocabulary for network definitions across simulators (<uri xlink:type="simple" xlink:href="http://neuralensemble.org/trac/PyNN/">http://neuralensemble.org/trac/PyNN/</uri>; this issue). While the presence of Python as a common link language may temporarily address the interoperability issues of this approach, we feel that it would be a cleaner design to use a separate, declarative definition for networks such as NeuroML (<uri xlink:type="simple" xlink:href="http://neuroml.org">http://neuroml.org</uri>). Nevertheless, we completely agree that a standard vocabulary for model definitions is an important first step toward this goal.</p>
    </sec>
    <sec>
      <title>Model specification vs. simulator control</title>
      <p>Model specification and exchange issues have been ably addressed by the communities developing model specification languages (Le Novère et al., <xref ref-type="bibr" rid="B20">2005</xref>; Qi and Crook, <xref ref-type="bibr" rid="B24">2004</xref>; <uri xlink:type="simple" xlink:href="http://neuroml.org">http://neuroml.org</uri>; <uri xlink:type="simple" xlink:href="http://sbml.org">http://sbml.org</uri>). The current paper focuses on the second problem, that of making it easier for researchers to control and set up these diverse simulation tools. We have shown how this can be done with the simulator MOOSE, using Python as a glue language. Run-time communication between simulators has previously been achieved using the NEOSIM framework, which uses Java (Goddard et al., <xref ref-type="bibr" rid="B15">2001</xref>; Howell et al., <xref ref-type="bibr" rid="B18">2002</xref>). More recently, the MUSIC framework specifies an API for simulators to use to communicate with each other (Ekeberg and Djurfeldt, <xref ref-type="bibr" rid="B14">2008</xref>). Our study is novel in two respects. First, we use the built-in Python capabilities of two simulators to achieve run-time communication, without the need to modify either simulator or to build an additional framework for communication. Second, we carry out bidirectional communications across scales (biophysical to biochemical models) and involving continuous data types (channel conductance and calcium concentrations) rather than spike events.</p>
      <p>The evolution of neuronal simulator technology has seen a gradual separation of different aspects of modeling, with a corresponding improvement in interoperability. The first step was to develop higher-level simulation tools (e.g., NEURON and GENESIS) to separate the numerical and housekeeping code from the model-specific code. This let people share models, provided they were written for the same simulator. The second was the development of declarative model specifications that were separate from the simulator. This initially took the form of semi-declarative cell morphology files (NEURON ‘.geom’ files and GENESIS ‘.p’ files), which required additional files for channel specification. This process of separation of model definition from simulator control has continued. The Neuroconstruct suite refines the declarative definition of models, with NeuroML and ChannelML as declarative definitions sufficient for most single-neuron models. Importantly, at this level quite different simulators can use the same original model definition to run simulations. A third stage is the convergence of different simulators to use the same link language, in this case Python. This makes it possible to explicitly separate model definition from simulator control. In the current paper, we have illustrated this with a composite signaling-neuronal model drawing on NEURON and MOOSE. We have utilized two legacy models, one written for NEURON, and one written for GENESIS. Even though the legacy models themselves were not entirely set up in a declarative manner, we used the original model definitions only to load in the model specifications. We used Python as the procedural language to control these operations, and to mediate communication between the models at run-time.</p>
    </sec>
    <sec>
      <title>Sustainability of python interoperability</title>
      <p>Simulator interoperability has long been regarded as important (Crook et al., <xref ref-type="bibr" rid="B12">2005</xref>, <xref ref-type="bibr" rid="B13">2007</xref>; Goddard et al., <xref ref-type="bibr" rid="B15">2001</xref>). Such projects have been difficult to execute, and still harder to maintain, because they depend on multiple underlying simulator projects, each with different APIs, directions and life-cycles. Python is a potential way out of this problem. First, Python itself is a well-established language with a strong community and support. Second, the issues of interfacing to Python are now being undertaken by individual simulator development teams. Interoperability emerges from these independent efforts rather than requiring a separate project to achieve coordination. Third, PyMOOSE itself will be maintained for the long-term, since Python will be the default scripting language for MOOSE. We suggest that long-term improvements in interoperability will be driven both by widespread simulator support for declarative model specifications, and by a richer ecosystem of simulators fluent in Python.</p>
    </sec>
  </sec>
  <sec>
    <title>Conflict of Interest Statement</title>
    <p>The authors declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p>
  </sec>
</body>
<back>
  <ack>
    <p>The development of MOOSE is supported by grants from the Department of Biotechnology, India, and the NIGMS/Systems Biology Center of New York. We acknowledge support from FACETS to S. Ray to attend the FACETS/CodeJam meeting at CNRS, Gif-sur-Yvette, which further stimulated PyMOOSE development.</p>
  </ack>
  <app-group>
    <app>
      <title>Appendix</title>
      <p>Program listing: ca3_db.hoc provides the functions to load and initialize the NEURON CA3 cell model as well as for advancing the simulation for a specified interval and for updating parameters.</p>
      <preformat position="float" xml:space="preserve">
        <monospace>
/******************************************************************************
 * Derived from Hippocampal CA3 pyramidal neuron model from the paper 
 * M. Migliore, E. Cook, D.B. Jaffe, D.A. Turner and D. Johnston, Computer
 * simulations of morphologically reconstructed CA3 hippocampal neurons, J.
 * Neurophysiol. 73, 1157-1168 (1995). 
 * The original model is available in modeldb: accession no: 3263
 * <uri xlink:type="simple" xlink:href="http://senselab.med.yale.edu/ModelDb/ShowModel.asp?model=3263">http://senselab.med.yale.edu/ModelDb/ShowModel.asp?model=3263</uri>
 *
 * Modified by: Subhasis Ray , 2008 
 ******************************************************************************/
objref cvode, vecCai, vecT, vecV, outFile, stim1, stim2, stim3, fih
vecV = new Vector()
vecCai = new Vector()
vecT = new Vector()
outFile = new File()
cvode = new CVode(0)
cvode.active(1)
cvode.atol(1e-3)
START = 2
AMP = 1.0
// ************* NEURON A **********
FARADAY=96520
PI=3.14159
secondorder=2
dt=0.025
celsius=30
flagl=0
xopen("ca3a.geo")
proc conductances() {
    forall {
        insert pas e_pas=-65 g_pas=1/60000 Ra=200
        insert cadifus
        insert cal  gcalbar_cal=0.0025
        insert can  gcanbar_can=0.0025
        insert cat  gcatbar_cat=0.00025
        insert kahp gkahpbar_kahp=0.0004
        insert cagk gkbar_cagk=0.00055
    }
    soma {
        insert nahh    gnabar_nahh=gna
        insert borgkdr gkdrbar_borgkdr=gkdr
        insert borgka  gkabar_borgka=gka
        insert borgkm  gkmbar_borgkm=gkm
    }
    for i=0,1 dend2[i] {
        insert nahh    gnabar_nahh=gna
        insert borgkdr gkdrbar_borgkdr=gkdr
        insert borgka  gkabar_borgka=gka
        insert borgkm  gkmbar_borgkm=gkm
    }
    for i=0,2 dend3[i] {
        insert nahh    gnabar_nahh=gna   
        insert borgkdr gkdrbar_borgkdr=gkdr
        insert borgka  gkabar_borgka=gka
        insert borgkm  gkmbar_borgkm=gkm
    }
    for i=37,38 dend3[i] {
        insert nahh    gnabar_nahh=gna   
        insert borgkdr gkdrbar_borgkdr=gkdr
        insert borgka  gkabar_borgka=gka
        insert borgkm  gkmbar_borgkm=gkm
    }
}
proc init() {
    t=0
    coord_cadifus()
    forall {
        cao=2
        cai=50.e-6
        ek=-91
        v=-65
        if (ismembrane("nahh")) {ena=50}
    }
    vecV.record(&amp;soma.v(0.5))
    vecCai.record(&amp;soma.cai(0.5))
    vecT.record(&amp;t)
    finitialize(v)
    fcurrent()
    forall {
	if (ismembrane("nahh")) {e_pas=v+(ina+ik+ica)/g_pas} else {e_pas=v+(ik+ica)/g_pas}
    }
    cvode.re_init()
}
proc setup(){
    strength = 1.0	/*namps*/
    tstim = 50
    tstop=500
    gna=0.015
    gkdr=0.03
    gka=0.001
    gkm=0.0001
    conductances()
    /* The schedule of experiment is as follows:
</monospace>
      </preformat>
      <p>
        <inline-graphic xlink:href="fninf-02-006-i001.jpg"/>
      </p>
      <preformat position="float" xml:space="preserve">
        <monospace>
     The 1800 s runs with 1 s intervals interspersed with 1 s of
     kinetic simulation and update of gkbar for all ca dependent k
     channels.
     The genesis model needs over 1 uM [Ca2+] for 10 s.
    */
    soma {
				// first test pulse
				stim1 = new IClamp(0.5)
				stim1.amp = 0.15
				stim1.del = 1000.0
				stim1.dur = 250
				// tetanus pulse
				stim2 = new IClamp(0.5)
				stim2.amp = 1.0
				stim2.del = 2250
				stim2.dur = 7e3
				// final test pulse
				stim3 = new IClamp(0.5)
				stim3.amp = 0.15
				stim3.del = 192.25e3
				stim3.dur = 250
    }
    init()
}
proc update_gkbar(){/* multiply all Ca2+ dependent K+ conductance by $1 */
  forall {
       gkahpbar_kahp = gkahpbar_kahp * $1
   }
   soma {
       print "soma gkdrbar before:", gkdrbar_borgkdr
       gkdrbar_borgkdr = gkdrbar_borgkdr * $1
       gkmbar_borgkm = gkmbar_borgkm * $1
       print "soma gkdrbar after", gkdrbar_borgkdr   
   }
   for i=0,1 dend2[i] {
       gkdrbar_borgkdr = gkdrbar_borgkdr * $1
       gkmbar_borgkm = gkmbar_borgkm * $1
   }
   for i=0,2 dend3[i] {
       gkdrbar_borgkdr = gkdrbar_borgkdr * $1
       gkmbar_borgkm = gkmbar_borgkm * $1
   }
   for i=37,38 dend3[i] {
       gkdrbar_borgkdr = gkdrbar_borgkdr * $1
       gkmbar_borgkm = gkmbar_borgkm * $1
   }
   fcurrent()
}
access soma
distance()
/* run for interval specified as argument# 1 */
proc run(){ 
    t_start = t
    while (t &lt; (t_start + $1)){ 
// 	print "run() - @t=", t
	fadvance() 
    }
//     print "run(): t_start =", t_start, " current time =", t, "run interval =", $1
}
proc do_run(){
    setup()
    print "setup done. running 7.25s"
    run(12250)
    print "t = ", t, "ms. done running. dumping data in test_neuron1.dat"
    outFile.wopen("test_neuron1.dat")
    for ii = 0, vecT.size() - 1 {
	outFile.printf("%g %g %g\n", vecT.x(ii), (vecCai.x(ii) - 50e-6)*2e6, vecV.x(ii)) // the original GUI plots this function of cai instead of absolute value - unit is nM*2
    }
    outFile.close()
    print "done dumping. running for 5s with 0.5nA"
    run(5000)
    print "t =", t, "ms. soma.Cai = ", soma.cai(0.5), ". now updating gkbar"
    update_gkbar(10.0)
    print "done updating. writing to file"
    outFile.wopen("test_neuron2.dat")
    for ii = 0, vecT.size() - 1 {
	outFile.printf("%g %g %g\n", vecT.x(ii), (vecCai.x(ii) - 50e-6)*2e6, vecV.x(ii)) // the original GUI plots this function of cai instead of absolute value - unit is nM*2
    }
    outFile.close()
    print "done dumping. now running the rest"
    run(1800300)
    print "t = ", t, "ms. done running. writing to file"
    outFile.wopen("test_neuron3.dat")
    for ii = 0, vecT.size() - 1 {
	outFile.printf("%g %g %\n", vecT.x(ii), (vecCai.x(ii) - 50e-6)*2e6, vecV.x(ii)) // the original GUI plots this function of cai instead of absolute value - unit is nM*2
    }
    outFile.close()
}
</monospace>
      </preformat>
      <p>Program listing 2: moosenrn.py – this program wraps the GENESIS model and the NEURON model and provides simulation control and data exchange between the two simulators.</p>
      <preformat position="float" xml:space="preserve">
        <monospace>
#!/usr/bin/env python
# Author: Subhasis Ray
import sys
sys.path.append("/home/subha/lib/python2.5/site-packages")
sys.path.append("/home/subha/lib/python2.5/site-packages/neuron")
import pylab
import numpy
import neuron
import moose
class NeuronSim:
    """Wrapper class for the neuron simulation"""
    def __init__(self, fileName="ca3_db.hoc"):
        """Load the file specified by fileName"""
        self.hoc = neuron.h
        self.hoc.load_file(fileName)
        self.hoc.setup()
    def run(self, interval):
        """Simulate for interval time in second"""
        self.hoc.run(interval * 1e3) # neuron keeps time in milli second
    def cai(self):
        """Returns cai of in nM"""
        return self.hoc.soma(0.5).cai
    def cai_record(self):
        """Returns a tuple containing the array of time points and the array
of cai values at the corresponding points"""
        timeVec = numpy.array(neuron.h.vecT)
        caiVec = numpy.array(neuron.h.vecCai)
        return (timeVec, caiVec)
    def v_record(self):
        """Returns a tuple containing the array of time points and the array
of membrane potential values at the corresponding points"""
        timeVec = numpy.array(neuron.h.vecT)
        vmVec = numpy.array(neuron.h.vecV)
        return (timeVec, vmVec)
    def update_kconductance(self, factor):
        """Modify the k hcannel conductances in inverse proportion of mapk_star_conc"""
        self.hoc.update_gkbar(factor)
        self.hoc.fcurrent()
    def saveplots(self, suffix):
        cai = "nrn_cai_" + str(suffix) + ".plot"
        vm = "nrn_vm_" + str(suffix) + ".plot"
        t_series, vm_series, = self.v_record()
        t_series, cai_series, = self.cai_record()
        numpy.savetxt(cai, cai_series)
        numpy.savetxt(vm, vm_series)
        numpy.savetxt("nrn_t_" + str(suffix) + ".plot", t_series)
class MooseSim:
    """Wrapper class for moose simulation"""
    volume_scale = 6e20 * 1.257e-16
    def __init__(self, fileName="acc79.g"):
        self._settle_time = 1800.0
        self._ctx = moose.PyMooseBase.getContext()
        self._t_table = []
        self._t = 0.0
        self._ctx.loadG(fileName)
        self.ca_input = moose.Molecule("/kinetics/Ca_input")
        self.mapk_star = moose.Molecule("/kinetics/MAPK*")
        self.pkc_active = moose.Molecule("/kinetics/PKC-active")
        self.pkc_active_table = moose.Table("/graphs/conc2/PKC-active.Co")
        self.pkc_ca_table = moose.Table("/graphs/conc1/PKC-Ca.Co")
        self.mapk_star_table = moose.Table("/moregraphs/conc3/MAPK*.Co")
        self.mapk_star_table.stepMode = 3
        self.mapk_star_table.connect("inputRequest", self.mapk_star, "conc")
        self.mapk_star_table.useClock(2)
        self.ca_input_table = moose.Table("/moregraphs/conc4/Ca_input.Co")
        self.ca_input_table.stepMode = 3
        self.ca_input_table.connect("inputRequest", self.ca_input, "conc")
        self.ca_input_table.useClock(2)
        self._ctx.reset()
        self._ctx.reset()
    def set_ca_input(self, ca_input):
        """Sets the conc. of Ca_input molecule"""
        print "set_ca_input: BEFORE: nInit =", self.ca_input.nInit, ", n =", self.ca_input.n, ", setting to: ", ca_input* MooseSim.volume_scale
        self.ca_input.nInit = ca_input * MooseSim.volume_scale
        self.ca_input.n = ca_input * MooseSim.volume_scale
        print "set_ca_input: AFTER: nInit =", self.ca_input.nInit, ", n =", self.ca_input.n
    def ca_input(self):
        """Returns scaled value of Ca_input conc."""
        return self.ca_input.conc
    def run(self, interval):
        """Run the simulation for interval time."""
        self._ctx.step(float(interval))
        # Now expand the list of time points to be plotted
        points = len(self.pkc_ca_table) - len(self._t_table)
        delta = interval * 1.0 / points
        for ii in range(points):
            self._t_table.append(self._t)
            self._t += delta
    def pkc_ca_record(self):
        """Returns the time series for pkc_ca conc."""
        return (self._t_table, self.pkc_ca_table)
    def pkc_active_record(self):
        """Returns time series for pkc_active conc."""
        return (self._t_table, self.pkc_active_table)
    def mapk_star_conc(self):
        """Returns MAPK* conc. in uM"""
        return self.mapk_star.n / MooseSim.volume_scale
    def mapk_star_record(self):
        """Returns time series for [MAPK*]"""
        return (self._t_table, self.mapk_star_table)
    def saveplots(self, suffix):
        pkc_a = "mus_pkc_act_" + str(suffix) + ".plot"
        pkc_ca = "mus_pkc_ca_" + str(suffix) + ".plot"
        mapk_star = "mus_mapk_star_" + str(suffix) + ".plot"
        ca_input = "mus_ca_input_" + str(suffix) + ".plot"
        numpy.savetxt("mus_t_" + str(suffix) + ".plot", self._t_table)
        self.mapk_star_table.dumpFile(mapk_star)
        self.pkc_ca_table.dumpFile(pkc_ca)
        self.pkc_active_table.dumpFile(pkc_a)
        self.ca_input_table.dumpFile(ca_input)
    def test_run(self):
        self.run(500)
        print "After 500 steps of uninited run: [MAPK*] =", self.mapk_star_conc()
        self.ca_input.nInit = 10 * MooseSim.volume_scale
        self.ca_input.n = 10 * MooseSim.volume_scale
        self.run(5)
        print "After another 5 s with 10uM ca input: [MAPK*] =", self.mapk_star_conc()
        self.ca_input.nInit = 0.08 * MooseSim.volume_scale
        self.ca_input.n = 0.08 * MooseSim.volume_scale
        self.run(500)
        print "finished run. going to plot" 
        print "After another 500 s with 0.08 uM ca input: [MAPK*] =", self.mapk_star_conc()
        pylab.plot(pylab.array(self._t_table),
                   pylab.array(self.pkc_active_table),
                   pylab.array(self._t_table),
                   pylab.array(self.pkc_ca_table))
	pylab.show()
if __name__ == "__main__":
    mus = MooseSim()
    mus.set_ca_input(0.08)
    mus.run(1800.0)
    mus.saveplots("1")
    start_mapk = mus.mapk_star_conc()
    nrn = NeuronSim()
    nrn.run(2.25)
    nrn.saveplots("1")
    file_ = open("cai_setings.txt", "w")
    # Interleaved execution of MOOSE and NEURON model
    # Synchronizing after every 1 s of simulation
    while nrn.hoc.t &lt; 192.25e3
        scaled_cai = scale_nrncai(nrn.cai())
        mus.set_ca_input(scaled_cai)
        print "scaled_cai =",scaled_cai
        file_.write(str(nrn.cai()) + " " + str(scaled_cai)+"\n")
        mus.run(1.0)
        gkbar_scale = start_mapk / mus.mapk_star_conc()
        start_mapk = mus.mapk_star_conc()
        print "[mapk*] = ", start_mapk
        nrn.update_kconductance(gkbar_scale)
        nrn.run(1.0)
        print "time is ", nrn.hoc.t * le-3, "s"
    file_.close()
    nrn.saveplots("2")
    mus.saveplots("2")
    # final test pulse run
    nrn.run(0.3)
    nrn.saveplots("3")
    t_series, vm_series, = nrn.v_record()
    t_series, cai_series, = nrn.cai_record()
    pylab.subplot(121)
    pylab.plot(t_series, numpy.array(vm_series), t_series, numpy.array(cai_series) * 1e6)
    t_series, pkc_act, = mus.pkc_active_record()
    t_series, pkc_ca, = mus.pkc_ca_record()
    t_series, mapk_star, = mus.mapk_star_record()
    pylab.subplot(122)
    pylab.plot(numpy.array(t_series), numpy.array(pkc_act), numpy.array(t_series), numpy.array(pkc_ca), numpy.array(t_series), numpy.array(mapk_star))
    pylab.show()
</monospace>
      </preformat>
    </app>
  </app-group>
  <ref-list>
    <title>References</title>
    <ref id="B1">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ajay</surname><given-names>S. M.</given-names></name><name><surname>Bhalla</surname><given-names>U. S.</given-names></name></person-group> (<year>2004</year>). <article-title>A role for ERKII in synaptic pattern selectivity on the time-scale of minutes</article-title>. <source>Eur. J. Neurosci.</source><volume>20</volume>, <fpage>2671</fpage>–<lpage>2680</lpage><pub-id pub-id-type="doi">10.1111/j.1460-9568.2004.03725.x</pub-id><pub-id pub-id-type="pmid">15548210</pub-id></citation>
    </ref>
    <ref id="B2">
      <citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Beazley</surname><given-names>D. M.</given-names></name></person-group> (<year>1996</year>). <article-title>SWIG: an easy to use tool for integrating scripting languages with C and C++</article-title>. In <conf-name>Proceedings of the 4th Annual USENIX Tcl/Tk Workshop</conf-name>, <conf-loc>Monterey, CA</conf-loc></citation>
    </ref>
    <ref id="B3">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Beeman</surname><given-names>D.</given-names></name><name><surname>Bower</surname><given-names>J. M.</given-names></name></person-group> (<year>2004</year>). <article-title>Simulator-independent representation of ionic conductance models with ChannelDB</article-title>. <source>Neurocomputing</source><volume>58</volume>–<volume>60</volume>, <fpage>1085</fpage>–<lpage>1090</lpage><pub-id pub-id-type="doi">10.1016/j.neucom.2004.01.170</pub-id></citation>
    </ref>
    <ref id="B4">
      <citation citation-type="book"><person-group person-group-type="author"><name><surname>Bhalla</surname><given-names>U. S.</given-names></name></person-group> (<year>1998</year>). <article-title>Advanced XODUS techniques</article-title>. In <source>The Book of GENESIS: Exploring Realistic Neural Models with the General Neural Simulation System</source>, <edition>2nd edn</edition>, <person-group person-group-type="editor"><name><surname>Bower</surname><given-names>J. M.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name></person-group>, eds (<publisher-loc>New York</publisher-loc>, <publisher-name>Springer</publisher-name>).</citation>
    </ref>
    <ref id="B5">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bhalla</surname><given-names>U. S.</given-names></name><name><surname>Iyengar</surname><given-names>R.</given-names></name></person-group> (<year>1999</year>). <article-title>Emergent properties of networks of biological signaling pathways</article-title>. <source>Science</source><volume>283</volume>, <fpage>381</fpage>–<lpage>387</lpage><pub-id pub-id-type="doi">10.1126/science.283.5400.381</pub-id><pub-id pub-id-type="pmid">9888852</pub-id></citation>
    </ref>
    <ref id="B6">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bhalla</surname><given-names>U. S.</given-names></name><name><surname>Ram</surname><given-names>P. T.</given-names></name><name><surname>Iyengar</surname><given-names>R.</given-names></name></person-group> (<year>2002</year>). <article-title>Map kinase phosphatase as a locus of flexibility in a mitogen-activated protein kinase signaling network</article-title>. <source>Science</source><volume>297</volume>, <fpage>1018</fpage>–<lpage>1023</lpage><pub-id pub-id-type="doi">10.1126/science.1068873</pub-id><pub-id pub-id-type="pmid">12169734</pub-id></citation>
    </ref>
    <ref id="B7">
      <citation citation-type="book"><person-group person-group-type="author"><name><surname>Bower</surname><given-names>J. M.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name></person-group> (<year>1998</year>). <article-title>The Book of GENESIS: Exploring Realistic Neural Models with the General Neural Simulation System</article-title>, <edition>2nd edn.</edition><publisher-loc>New York</publisher-loc>, <publisher-name>Springer</publisher-name></citation>
    </ref>
    <ref id="B8">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Bunow</surname><given-names>B.</given-names></name><name><surname>Segev</surname><given-names>I.</given-names></name><name><surname>Fleshman</surname><given-names>J. W.</given-names></name></person-group> (<year>1985</year>). <article-title>Modeling the electrical behavior of anatomically complex neurons using a network analysis program: excitable membrane</article-title>. <source>Biol. Cybern.</source><volume>53</volume>, <fpage>41</fpage>–<lpage>56</lpage><pub-id pub-id-type="doi">10.1007/BF00355689</pub-id><pub-id pub-id-type="pmid">3841014</pub-id></citation>
    </ref>
    <ref id="B9">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cannon</surname><given-names>R. C.</given-names></name><name><surname>Gewaltig</surname><given-names>M. O.</given-names></name><name><surname>Gleeson</surname><given-names>P.</given-names></name><name><surname>Bhalla</surname><given-names>U. S.</given-names></name><name><surname>Cornelis</surname><given-names>H.</given-names></name><name><surname>Hines</surname><given-names>M. L.</given-names></name><name><surname>Howell</surname><given-names>F. W.</given-names></name><name><surname>Muller</surname><given-names>E.</given-names></name><name><surname>Stiles</surname><given-names>J. R.</given-names></name><name><surname>Wils</surname><given-names>S.</given-names></name><name><surname>De Schutter</surname><given-names>E.</given-names></name></person-group> (<year>2007</year>). <article-title>Interoperability of neuroscience modeling software: current status and future directions</article-title>. <source>Neuroinformatics</source><volume>5</volume>, <fpage>127</fpage>–<lpage>138</lpage><pub-id pub-id-type="doi">10.1007/s12021-007-0004-5</pub-id><pub-id pub-id-type="pmid">17873374</pub-id></citation>
    </ref>
    <ref id="B10">
      <citation citation-type="book"><person-group person-group-type="author"><name><surname>Carnevale</surname><given-names>N. T.</given-names></name><name><surname>Hines</surname><given-names>M. L.</given-names></name></person-group> (<year>2006</year>). <article-title>The NEURON Book</article-title>. <publisher-loc>Cambridge</publisher-loc>, <publisher-name>Cambridge University Press</publisher-name></citation>
    </ref>
    <ref id="B11">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Cornelis</surname><given-names>H.</given-names></name><name><surname>De Schutter</surname><given-names>E.</given-names></name></person-group> (<year>2003</year>). <article-title>NeuroSpaces: separating modeling and simulation</article-title>. <source>Neurocomputing</source><volume>52</volume>–<volume>54</volume>, <fpage>227</fpage>–<lpage>231</lpage><pub-id pub-id-type="doi">10.1016/S0925-2312(02)00750-6</pub-id><pub-id pub-id-type="pmid">12934604</pub-id></citation>
    </ref>
    <ref id="B12">
      <citation citation-type="other"><person-group person-group-type="author"><name><surname>Crook</surname><given-names>S.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name><name><surname>Gleeson</surname><given-names>P.</given-names></name><name><surname>Howell</surname><given-names>F.</given-names></name></person-group> (<year>2005</year>). <article-title>XML for model specification in neuroscience</article-title>. In <source>Special Issue on Realistic Neuro Modeling – Wam-Bamm ‘05 Tutorials</source> <person-group person-group-type="editor"><name><surname>Bower</surname><given-names>J.M.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name></person-group> (eds.). <source>Brains Minds Media</source>, <volume>Vol. 1</volume>, bmm228 (urn:nbn:de:0009-3-2282). <uri xlink:type="simple" xlink:href="http://www.brains-minds-media.org/archive/228">http://www.brains-minds-media.org/archive/228</uri></citation>
    </ref>
    <ref id="B13">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Crook</surname><given-names>S.</given-names></name><name><surname>Gleeson</surname><given-names>P.</given-names></name><name><surname>Howell</surname><given-names>F.</given-names></name><name><surname>Svitak</surname><given-names>J.</given-names></name><name><surname>Silver</surname><given-names>R. A.</given-names></name></person-group> (<year>2007</year>). <article-title>MorphML: level 1 of the NeuroML standards for neuronal morphology data and model specification</article-title>. <source>Neuroinformatics</source><volume>5</volume>, <fpage>96</fpage>–<lpage>104</lpage><pub-id pub-id-type="doi">10.1007/s12021-007-0003-6</pub-id><pub-id pub-id-type="pmid">17873371</pub-id></citation>
    </ref>
    <ref id="B14">
      <citation citation-type="other"><person-group person-group-type="author"><name><surname>Ekeberg</surname><given-names>Ö.</given-names></name><name><surname>Djurfeldt</surname><given-names>M.</given-names></name></person-group> (<year>2008</year>). <article-title>MUSIC – multisimulation coordinator: request for comments</article-title>. Nature Proceedings. Available at: <uri xlink:type="simple" xlink:href="http://dx. doi.org/10.1038/npre.2008.1830.1">http://dx. doi.org/10.1038/npre.2008.1830.1</uri></citation>
    </ref>
    <ref id="B15">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Goddard</surname><given-names>N.</given-names></name><name><surname>Hood</surname><given-names>G.</given-names></name><name><surname>Howell</surname><given-names>F.</given-names></name><name><surname>Hines</surname><given-names>M.</given-names></name><name><surname>De Schutter</surname><given-names>E.</given-names></name></person-group> (<year>2001</year>). <article-title>NEOSIM: portable large-scale plug and play modelling</article-title>. <source>Neurocomputing</source><volume>38</volume>–<volume>40</volume>, <fpage>1657</fpage>–<lpage>1661</lpage><pub-id pub-id-type="doi">10.1016/S0925-2312(01)00528-8</pub-id><pub-id pub-id-type="pmid">12194188</pub-id></citation>
    </ref>
    <ref id="B16">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Goddard</surname><given-names>N.</given-names></name><name><surname>Hucka</surname><given-names>M.</given-names></name><name><surname>Howell</surname><given-names>F.</given-names></name><name><surname>Cornelis</surname><given-names>H.</given-names></name><name><surname>Shankar</surname><given-names>K.</given-names></name><name><surname>Beeman</surname><given-names>D.</given-names></name></person-group> (<year>2001</year>). <article-title>Towards NeuroML: model description methods for collaborative modeling in neuroscience</article-title>. <source>Philos. Trans. R. Soc. Lond., B, Biol. Sci.</source><volume>356</volume>, <fpage>1209</fpage>–<lpage>1228</lpage><pub-id pub-id-type="doi">10.1098/rstb.2001.0910</pub-id><pub-id pub-id-type="pmid">11545699</pub-id></citation>
    </ref>
    <ref id="B17">
      <citation citation-type="book"><person-group person-group-type="author"><name><surname>Hines</surname><given-names>M.</given-names></name></person-group> (<year>1993</year>). <article-title>NEURON – a program for simulation of nerve equations</article-title>. In <source>Neural Systems: Analysis and Modeling</source>, <person-group person-group-type="editor"><name><surname>Eeckman</surname><given-names>F.</given-names></name></person-group>, ed. (<publisher-loc>Norwell, MA</publisher-loc>, <publisher-name>Kluwer</publisher-name>), pp. <fpage>127</fpage>–<lpage>136</lpage></citation>
    </ref>
    <ref id="B18">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Howell</surname><given-names>F.</given-names></name><name><surname>Bazhenov</surname><given-names>M.</given-names></name><name><surname>Rogister</surname><given-names>P.</given-names></name><name><surname>Seznowski</surname><given-names>T.</given-names></name><name><surname>Goddard</surname><given-names>N.</given-names></name></person-group> (<year>2002</year>). <article-title>Scaling a slow-wave sleep cortical network model using NEOSIM</article-title>. <source>Neurocomputing</source><volume>44</volume>–<volume>46</volume>, <fpage>453</fpage>–<lpage>458</lpage><pub-id pub-id-type="doi">10.1016/S0925-2312(02)00399-5</pub-id><pub-id pub-id-type="pmid">12744262</pub-id></citation>
    </ref>
    <ref id="B19">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hucka</surname><given-names>M.</given-names></name><etal/></person-group> (<year>2002</year>). <article-title>The systems biology markup language (SBML): a medium for representation and exchange of biochemical network models</article-title>. <source>Bioinformatics</source><volume>19</volume>, <fpage>524</fpage>–<lpage>531</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btg015</pub-id><pub-id pub-id-type="pmid">12611808</pub-id></citation>
    </ref>
    <ref id="B20">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Le Novère</surname><given-names>N.</given-names></name><name><surname>Finney</surname><given-names>A.</given-names></name><name><surname>Hucka</surname><given-names>M.</given-names></name><name><surname>Bhalla</surname><given-names>U. S.</given-names></name><name><surname>Campagne</surname><given-names>F.</given-names></name><name><surname>Collado-Vides</surname><given-names>J.</given-names></name><name><surname>Crampin</surname><given-names>E. J.</given-names></name><name><surname>Halstead</surname><given-names>M.</given-names></name><name><surname>Klipp</surname><given-names>E.</given-names></name><name><surname>Mendes</surname><given-names>P.</given-names></name><name><surname>Nielsen</surname><given-names>P.</given-names></name><name><surname>Sauro</surname><given-names>H.</given-names></name><name><surname>Shapiro</surname><given-names>B.</given-names></name><name><surname>Snoep</surname><given-names>J. L.</given-names></name><name><surname>Spence</surname><given-names>H. D.</given-names></name><name><surname>Wanner</surname><given-names>B. L.</given-names></name></person-group> (<year>2005</year>). <article-title>Minimum information requested in the annotation of biochemical models (MIRIAM)</article-title>. <source>Nat. Biotechnol.</source><volume>23</volume>, <fpage>1509</fpage>–<lpage>1515</lpage><pub-id pub-id-type="doi">10.1038/nbt1156</pub-id><pub-id pub-id-type="pmid">16333295</pub-id></citation>
    </ref>
    <ref id="B21">
      <citation citation-type="confproc"><person-group person-group-type="author"><name><surname>Maes</surname><given-names>P.</given-names></name></person-group> (<year>1987</year>). <article-title>Concepts and experiments in computational reflection</article-title>. In <conf-name>Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)</conf-name> <conf-loc>Orlando, FL</conf-loc>, <conf-sponsor>ACM</conf-sponsor>, pp. <fpage>147</fpage>–<lpage>155</lpage></citation>
    </ref>
    <ref id="B22">
      <citation citation-type="book"><person-group person-group-type="author"><name><surname>Martelli</surname><given-names>A.</given-names></name><name><surname>Ravenscroft</surname><given-names>A. M.</given-names></name><name><surname>Ascher</surname><given-names>D.</given-names></name></person-group> (<year>2005</year>). <article-title>Python Cookbook, O'Reilly</article-title>, p. <fpage>14</fpage></citation>
    </ref>
    <ref id="B23">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Migliore</surname><given-names>M.</given-names></name><name><surname>Cook</surname><given-names>E. P.</given-names></name><name><surname>Jaffe</surname><given-names>D. B.</given-names></name><name><surname>Turner</surname><given-names>D. A.</given-names></name><name><surname>Johnston</surname><given-names>D.</given-names></name></person-group> (<year>1995</year>). <article-title>Computer simulations of morphologically reconstructed CA3 hippocampal neurons</article-title>. <source>J. Neurophysiol.</source><volume>73</volume>, <fpage>1157</fpage>–<lpage>1168</lpage><pub-id pub-id-type="pmid">7608762</pub-id></citation>
    </ref>
    <ref id="B24">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Qi</surname><given-names>W.</given-names></name><name><surname>Crook</surname><given-names>S. M.</given-names></name></person-group> (<year>2004</year>). <article-title>Tools for neuroinformatic data exchange: an XML application for neuronal morphology data</article-title>. <source>Neurocomputing</source><volume>58C</volume>–<volume>60C</volume>, <fpage>1091</fpage>–<lpage>1095</lpage></citation>
    </ref>
    <ref id="B25">
      <citation citation-type="journal"><person-group person-group-type="author"><name><surname>Segev</surname><given-names>I.</given-names></name><name><surname>Fleshman</surname><given-names>J. W.</given-names></name><name><surname>Miller</surname><given-names>J. P.</given-names></name><name><surname>Bunow</surname><given-names>B.</given-names></name></person-group> (<year>1985</year>). <article-title>Modeling the electrical behavior of anatomically complex neurons using a network analysis program: passive membrane</article-title>. <source>Biol. Cybern.</source><volume>53</volume>, <fpage>27</fpage>–<lpage>40</lpage><pub-id pub-id-type="doi">10.1007/BF00355688</pub-id><pub-id pub-id-type="pmid">3841013</pub-id></citation>
    </ref>
    <ref id="B26">
      <citation citation-type="thesis"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>B. C.</given-names></name></person-group> (<year>1982</year>). <article-title>Reflection and Semantics in a Procedural Language</article-title>. Ph.D. thesis, MIT, Cambridge, MA.<pub-id pub-id-type="pmid">17396957</pub-id></citation>
    </ref>
  </ref-list>
</back>
